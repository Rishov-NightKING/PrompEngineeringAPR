 installTemplate("build.template", "build.xml", keywords, false, testsOutDir); installTemplate("default.properties.template", "default.properties", keywords, true /*force*/, testsOutDir); 
 public static int RADIO_TYPE_CDMA = 2; public static int RADIO_TYPE_WCDMA = 3; 
<|del|> 
 static final int RADIO_TYPE_CDMA = 4; static final int RADIO_TYPE_WCDMA = 5; 
 static final int RADIO_TYPE_CDMA = 4; static final int RADIO_TYPE_WCDMA = 5; 
 static final int RADIO_TYPE_CDMA = 4; static final int RADIO_TYPE_WCDMA = 5; 
 if (enabled) { 
 if (RILConstants.CDMA_PHONE == SystemProperties.getInt(Settings.System.CURRENT_ACTIVE_PHONE, 0)) { 
 * Stop listening for updates. 
<|del|> 
<|del|> 
 AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); 
 * ServiceState.RADIO_TECHNOLOGY_EVDO is the same as "attached" and * ServiceState.RADIO_TECHNOLOGY_UNKNOWN is the same as detached. 
 GsmCall call = (GsmCall) getForegroundCall(); 
 } 
 public static int RADIO_TYPE_CDMA = 2; public static int RADIO_TYPE_WCDMA = 3; 
 if (!SystemProperties.get("ro.com.google.locationfeatures").equals("1")) { 
<|del|> 
 static final int RADIO_TYPE_CDMA = 4; static final int RADIO_TYPE_WCDMA = 5; 
 static final int RADIO_TYPE_CDMA = 4; static final int RADIO_TYPE_WCDMA = 5; 
 static final int RADIO_TYPE_CDMA = 4; static final int RADIO_TYPE_WCDMA = 5; 
 ss.getRadioTechnology() == ServiceState.RADIO_TECHNOLOGY_IS95B) { Log.w(TAG, "Warning! CDMA radio technology is either IS95A or IS95B," + " but you will see 1xRTT!"); 
 if (enabled) { 
 if (RILConstants.CDMA_PHONE == SystemProperties.getInt(Settings.System.CURRENT_ACTIVE_PHONE, 0)) { 
 * Stop listening for updates. 
 static final String LOG_TAG = "RILB"; 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an " + "inactive CDMAPhone then."); 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an" + "inactive CDMAPhone then."); 
 }else { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } 
 if (cdmaDataConnectionState == ServiceState.RADIO_TECHNOLOGY_1xRTT || cdmaDataConnectionState == ServiceState.RADIO_TECHNOLOGY_EVDO_0 || cdmaDataConnectionState == ServiceState.RADIO_TECHNOLOGY_EVDO_A) { 
 if (cdmaDataConnectionState != ServiceState.RADIO_TECHNOLOGY_1xRTT && cdmaDataConnectionState != ServiceState.RADIO_TECHNOLOGY_EVDO_0 && cdmaDataConnectionState != ServiceState.RADIO_TECHNOLOGY_EVDO_A) { 
 responseValuesRegistrationState[i] = Integer.parseInt(states[i + offset], 16); 
 Log.w(LOG_TAG, "Warning! There is an unexpected value returned" + " as response from RIL_REQUEST_REGISTRATION_STATE."); 
 Log.e(LOG_TAG, "Too less parameters returned from" + " RIL_REQUEST_REGISTRATION_STATE"); 
 this.newCdmaDataConnectionState = radioTechnologyToServiceState(responseValuesRegistrationState[0]); 
 newSS.setSystemAndNetworkId(responseValuesRegistrationState[5], responseValuesRegistrationState[6]); 
 Log.e(LOG_TAG, "RIL response handle in wrong phone!" + " Expected CDMA RIL request and get GSM RIL request."); 
 Log.w(LOG_TAG, "Received a different registration state, " + "but don't changed the extended cdma roaming mode."); 
 pollingContext[0]++; //RIL_REQUEST_REGISTRATION_STATE is necessary for CDMA 
 pollingContext[0]++; //RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE necessary for CDMA 
 obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE_CDMA, pollingContext)); 
 boolean hasCdmaDataConnectionChanged = cdmaDataConnectionState != newCdmaDataConnectionState; 
<|del|> 
 * ServiceState.RADIO_TECHNOLOGY_EVDO is the same as "attached" and * ServiceState.RADIO_TECHNOLOGY_UNKNOWN is the same as detached. 
<|del|> 
 } 
 public static int RADIO_TYPE_CDMA = 2; public static int RADIO_TYPE_WCDMA = 3; 
<|del|> 
 static final int RADIO_TYPE_CDMA = 4; static final int RADIO_TYPE_WCDMA = 5; 
 static final int RADIO_TYPE_CDMA = 4; static final int RADIO_TYPE_WCDMA = 5; 
 ss.getRadioTechnology() == ServiceState.RADIO_TECHNOLOGY_IS95B) { Log.w(TAG, "Warning! CDMA radio technology is either IS95A or IS95B," + " but you will see 1xRTT!"); 
 if (enabled) { 
 if (RILConstants.CDMA_PHONE == SystemProperties.getInt(Settings.System.CURRENT_ACTIVE_PHONE, 0)) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } 
 if (cdmaDataConnectionState == ServiceState.RADIO_TECHNOLOGY_1xRTT || cdmaDataConnectionState == ServiceState.RADIO_TECHNOLOGY_EVDO_0 || cdmaDataConnectionState == ServiceState.RADIO_TECHNOLOGY_EVDO_A) { 
 if (cdmaDataConnectionState != ServiceState.RADIO_TECHNOLOGY_1xRTT && cdmaDataConnectionState != ServiceState.RADIO_TECHNOLOGY_EVDO_0 && cdmaDataConnectionState != ServiceState.RADIO_TECHNOLOGY_EVDO_A) { 
 //offset, because we don't want the first 3 values in the int-array final int offset = 3; 
 responseValuesRegistrationState[i] = Integer.parseInt(states[i + offset], 16); 
 Log.w(LOG_TAG, "Warning! There is an unexpected value returned" + " as response from RIL_REQUEST_REGISTRATION_STATE."); 
 Log.e(LOG_TAG, "Too less parameters returned from" + " RIL_REQUEST_REGISTRATION_STATE"); 
 this.newCdmaDataConnectionState = radioTechnologyToServiceState(responseValuesRegistrationState[0]); 
 newSS.setSystemAndNetworkId(responseValuesRegistrationState[5], responseValuesRegistrationState[6]); 
 Log.e(LOG_TAG, "RIL response handle in wrong phone!" + " Expected CDMA RIL request and get GSM RIL request."); 
 pollingContext[0]++; //RIL_REQUEST_REGISTRATION_STATE is necessary for CDMA 
 pollingContext[0]++; //RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE necessary for CDMA 
 obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE_CDMA, pollingContext)); 
 boolean hasCdmaDataConnectionChanged = cdmaDataConnectionState != newCdmaDataConnectionState; 
 AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); 
 mPhone.enableEnhancedVoicePrivacy(value, Message.obtain(mSetOptionComplete, EVENT_ENHANCED_VP_EXECUTED)); 
 if (DBG) Log.d(LOG_TAG, "setOptionComplete: Received event EVENT_ENHANCED_VP_EXECUTED"); 
 log("mGetAllOptionsComplete: VP query done, all call features queried."); 
 addPreferencesFromResource(R.xml.gsm_umts_options); 
 int settingsNetworkMode = android.provider.Settings.System.getInt(mPhone.getContext().getContentResolver(), android.provider.Settings.System.PREFERRED_NETWORK_MODE, preferredNetworkMode); 
 if (!SystemProperties.get("ro.com.google.locationfeatures").equals("1")) { 
 if (!SystemProperties.get("ro.com.google.locationfeatures").equals("1")) { 
 != EXT_RECORD_TYPE_ADDITIONAL_DATA) { 
<|del|> 
 static final String LOG_TAG = "RILB"; 
 } 
<|del|> 
 static final String LOG_TAG = "CDMA"; 
 static final String LOG_TAG = "CDMA"; 
 static final String LOG_TAG = "CDMA"; 
 static final String LOG_TAG = "CDMA"; 
 static final String LOG_TAG = "CDMA"; 
 mPhone.enableEnhancedVoicePrivacy(value, Message.obtain(mSetOptionComplete, EVENT_ENHANCED_VP_EXECUTED)); 
 if (DBG) Log.d(LOG_TAG, "setOptionComplete: Received event EVENT_ENHANCED_VP_EXECUTED"); 
 log("mGetAllOptionsComplete: VP query done, all call features queried."); 
 addPreferencesFromResource(R.xml.gsm_umts_options); 
 int settingsNetworkMode = android.provider.Settings.System.getInt(mPhone.getContext().getContentResolver(), android.provider.Settings.System.PREFERRED_NETWORK_MODE, preferredNetworkMode); 
 if (!SystemProperties.get("ro.com.google.locationfeatures").equals("1")) { 
 if (!SystemProperties.get("ro.com.google.locationfeatures").equals("1")) { 
 != EXT_RECORD_TYPE_ADDITIONAL_DATA) { 
<|del|> 
 static final String LOG_TAG = "RILB"; 
<|del|> 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an " + "inactive CDMAPhone then."); 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an " + "inactive CDMAPhone then."); 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an" + "inactive CDMAPhone then."); 
 } 
<|del|> 
 static final String LOG_TAG = "CDMA"; 
 static final String LOG_TAG="CDMA"; 
 static final String LOG_TAG = "CDMA"; 
 static final String LOG_TAG = "CDMA"; 
 static final String LOG_TAG = "CDMA"; 
 static final String LOG_TAG = "CDMA"; 
<|del|> 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an " + "inactive CDMAPhone then."); 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an " + "inactive CDMAPhone then."); 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an" + "inactive CDMAPhone then."); 
 // This function should be overridden by the class CDMAPhone. // It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an " + "inactive CDMAPhone then."); 
 " == '" + Downloads.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + "')"; 
 " = " + Downloads.DESTINATION_CACHE_PARTITION_PURGEABLE + " )", 
 CallerInfo ci = null; { 
 CallerInfo ci = null; { 
 mConferenceCallList = new ViewGroup[MAX_CALLERS_IN_CONFERENCE]; { 
 AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); 
 AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); 
 // check for GSM if(networkType == TelephonyManager.NETWORK_TYPE_GPRS || networkType == TelephonyManager.NETWORK_TYPE_EDGE || networkType == TelephonyManager.NETWORK_TYPE_UMTS ) { showIMEIPanel(context, useSystemWindow); 
 * manually anyway, for instance in {@link 
 // check for GSM if(networkType == TelephonyManager.NETWORK_TYPE_GPRS || networkType == TelephonyManager.NETWORK_TYPE_EDGE || networkType == TelephonyManager.NETWORK_TYPE_UMTS ) { showIMEIPanel(context, useSystemWindow); 
 static final int MAX_CONNECTIONS = 1; // only 1 connection allowed in CDMA static final int MAX_CONNECTIONS_PER_CALL = 1; // only 1 connection allowed per call 
<|del|> 
 (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); 
 /** PROPERTY_ICC_OPERATOR_ALPHA is also known as the SPN, or Service Provider Name. 
<|del|> 
import android.os.*; import android.os.AsyncResult; import android.util.Log; import com.android.internal.telephony.IccConstants; 
<|del|> 
 this.mHandler.removeCallbacksAndMessages(null); 
 mPhone.getIccFileHandler().updateEFLinearFixed( 
 mPhone.getIccFileHandler().updateEFLinearFixed( 
 mPhone.mCM.writeSmsToRuim(status, IccUtils.bytesToHexString(pdu), 
 public int getPhoneType() { return Phone.PHONE_TYPE_GSM; 
 case Phone.NT_MODE_GSM_UMTS: modemNetworkMode = Phone.NT_MODE_GSM_UMTS; 
<|del|> 
<|del|> 
<|del|>
 // check for GSM if(networkType == TelephonyManager.NETWORK_TYPE_GPRS || networkType == TelephonyManager.NETWORK_TYPE_EDGE || networkType == TelephonyManager.NETWORK_TYPE_UMTS ) { showIMEIPanel(context, useSystemWindow); 
 // check for GSM if(networkType == TelephonyManager.NETWORK_TYPE_GPRS || networkType == TelephonyManager.NETWORK_TYPE_EDGE || networkType == TelephonyManager.NETWORK_TYPE_UMTS ) { showIMEIPanel(context, useSystemWindow); 
 (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); 
 case Phone.NT_MODE_GSM_UMTS: modemNetworkMode = Phone.NT_MODE_GSM_UMTS; 
 protected static final boolean DBG = true; 
 return mActivePhone.getDataActivityState(); 
 //TODO T: property strings do not have to be gsm specific 
 try { if(c != null) hangup(c); } catch (CallStateException ex) { Log.e(LOG_TAG, "unexpected error on hangup during dispose"); 
<|del|> 
 cr.unregisterContentObserver(this.mAutoTimeObserver); } 
 protected void finalize() { if(DBG) Log.d(LOG_TAG, "RuimCard finalized"); 
 protected void finalize() { Log.d(LOG_TAG, "RuimFileHandler finalized"); 
<|del|> 
 protected void finalize() { if(DBG) Log.d(LOG_TAG, "RuimRecords finalized"); 
 protected void finalize() { if(DBG) Log.d(LOG_TAG, "RuimSmsInterfaceManager finalized"); 
 try { if(c != null) hangup(c); } catch (CallStateException ex) { Log.e(LOG_TAG, "unexpected error on hangup during dispose"); 
 protected void finalize() { Log.d(LOG_TAG, "SIMFileHandler finalized"); 
 protected void finalize() { if(DBG) Log.d(LOG_TAG, "SimCard finalized"); 
 protected void finalize() { if(DBG) Log.d(LOG_TAG, "SimSmsInterfaceManager finalized"); 
 protected void finalize() { Log.d(TAG, "Service finalized"); 
 //we keep these for not breaking old applications sURLMatcher.addURI("sms", "sim", SMS_ALL_ICC); sURLMatcher.addURI("sms", "sim/#", SMS_ICC); 
<|del|> 
<|del|>
 } 
<|del|>
 adnCache = phone.mRuimRecords.getAdnCache(); 
<|del|> 
 protected void finalize() { if(DBG) Log.d(LOG_TAG, "RuimPhoneBookInterfaceManager finalized"); 
<|del|> 
 phone.getIccFileHandler().getEFLinearRecordSize(efid, response); 
<|del|> 
 protected void finalize() { if(DBG) Log.d(LOG_TAG, "SimPhoneBookInterfaceManager finalized"); 
 phone.getIccFileHandler().getEFLinearRecordSize(efid, response); 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 phone.getIccFileHandler().getEFLinearRecordSize(efid, response); 
 /* * A mask with all bits set, matching the size of the cache. */ private final static int CACHE_MASK = CACHE_SIZE - 1; 
 replacementIndex = (replacementIndex + 1) % MAX_PROBES; return cache[(idx + replacementIndex) & CACHE_MASK] = 
 replacementIndex = (replacementIndex + 1) % MAX_PROBES; return cache[(idx + replacementIndex) & CACHE_MASK] = 
 replacementIndex = (replacementIndex + 1) % MAX_PROBES; return cache[(idx + replacementIndex) & CACHE_MASK] = 
 replacementIndex = (replacementIndex + 1) % MAX_PROBES; return cache[(idx + replacementIndex) & CACHE_MASK] = 
 /** 
 for (int probe = 0; probe < MAX_PROBES; probe++) { 
 EventLog.writeEvent(LOG_BATTERY_STATUS, 
 param = WELL_KNOWN_PARAMETERS.get(wellKnownParameterValue); if (param == null) { param = "unassigned/0x" + Long.toHexString(wellKnownParameterValue); } 
 * Stops the animation. Contrary to {@link #forceFinished(boolean)}, * aborting the animating cause the scroller to move to the final x and y * position * * @see #forceFinished(boolean) 
 * @return The elapsed time in milliseconds. 
 * Sets the final position (X) for this scroller. 
 * Sets the final position (Y) for this scroller. 
 VideoView view = (VideoView) (screen == null ? null : screen.findViewById(R.id.video)); if (wait && show) { 
 VideoView view = (VideoView) (screen == null ? null : screen.findViewById(R.id.video)); if (wait && show) { 
 } catch (InterruptedException e) { } 
 } catch (InterruptedException e) { } 
 } catch (InterruptedException e) { } 
 view = (VideoView) (screen == null ? null : screen.findViewById(R.id.video)); 
 return (show ? view : null); 
 RingtoneManager.TYPE_RINGTONE | RingtoneManager.TYPE_VIDEO); 
 String msg = getString(R.string.fail_to_start_stream); Toast mt = Toast.makeText(StreamStarter.this, msg, Toast.LENGTH_SHORT); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 ContentValues values = new ContentValues(); values.put(Contacts.LAST_TIME_CONTACTED, 0); values.put(Contacts.TIMES_CONTACTED, 0); getContentResolver().update(Contacts.CONTENT_URI, values, null, null); 
 String[] presenceProjection = new String[] { Presence.IM_HANDLE, // COLUMN_PRESENCE_HANDLE Presence.IM_PROTOCOL // COLUMN_PRESENCE_PROTOCOL 
<|del|> 
 * @return The item's checked state or <code>false</code> if choice mode * is invalid 
 if (Config.DEBUG) Log.w(LOG_TAG, "Received PDU. Header Content-Type error."); return Intents.RESULT_SMS_GENERIC_ERROR; 
 int binaryContentType; 
<|del|>
 dispatchWapPdu_default(pdu, transactionId, pduType, mimeType, dataIndex, 
 return Activity.RESULT_OK; 
 private final static HashMap<Integer, String> WELL_KNOWN_MIME_TYPES = new HashMap<Integer, String>(); 
 private final static HashMap<Integer, String> WELL_KNOWN_PARAMETERS = new HashMap<Integer, String>(); 
 private final static HashMap<Integer, String> WELL_KNOWN_PARAMETERS = new HashMap<Integer, String>(); 
 private final static HashMap<Integer, String> WELL_KNOWN_PARAMETERS = new HashMap<Integer, String>(); 
<|del|>
 if (readContentParameters(startIndex + dataLength, (headersLength - (dataLength - mediaPrefixLength)), 0)) { 
 if (readContentParameters(startIndex + dataLength, (headersLength - (dataLength - mediaPrefixLength)), 0)) { 
 if (readContentParameters(startIndex + dataLength, (headersLength - (dataLength - mediaPrefixLength)), 0)) { 
 } } 
 if (decodeNoValue(startIndex + totalRead)) { 
 value = null; } else if (decodeIntegerValue(startIndex + totalRead)) { totalRead += dataLength; int intValue = (int) unsigned32bit; 
 return readContentParameters(startIndex + totalRead, leftToRead - totalRead, accumulator + totalRead); 
 return readContentParameters(startIndex + totalRead, leftToRead - totalRead, accumulator + totalRead); 
<|del|> 
 * should be used for summaries. * @attr ref android.R.styleable#ListPreference_summaryFromEntries 
<|del|> 
 ServiceManager.getService(Context.POWER_SERVICE)); 
 * Application that sets the provisioned bit, like SetupWizard does. 
<|del|>
 Status s = new Status(Status.ERROR, DdmsPlugin.PLUGIN_ID, e.getMessage(), e); DdmsPlugin.getDefault().getLog().log(s); 
 Status s = new Status(Status.ERROR, DdmsPlugin.PLUGIN_ID, e.getMessage(), e); DdmsPlugin.getDefault().getLog().log(s); 
 Status s = new Status(Status.ERROR, DdmsPlugin.PLUGIN_ID, e.getMessage(), e); DdmsPlugin.getDefault().getLog().log(s); 
<|del|> 
<|del|> 
<|del|> 
 final String WINDOWS1252_EXPECT = "This is some happy unicode text \u00e2\u02dc\u00ba"; TextBody tb = new TextBody(UNICODE_EXPECT); 
 // We call setHeader after setBody, since setBody overwrites Content-Type p.setHeader(MimeHeader.HEADER_CONTENT_TYPE, "text/html; charset=utf-8"); 
 // TEST 1: Extra fields and quotes in Content-Type (from RFC 2045) 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // Acquire wakelock during PIN code request to bring up LCD display mWakeLock.acquire(); Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST); 
 // Set the CDMA subscription mode // Do not store new value in persistent storage because modem can // return error. We can update the persistent storage (android DB) // only after getting a positive response from the modem. 
 + "|(mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])" 
 if (result.contains("-STARTTLS") || result.contains(" STARTTLS")) { 
<|del|> 
 MockTransport mockDash = new MockTransport(); mockDash.setSecurity(Transport.CONNECTION_SECURITY_TLS, false); mockDash.setTlsAllowed(true); mSender.setTransport(mockDash); 
 MockTransport mockDash = new MockTransport(); mockDash.setSecurity(Transport.CONNECTION_SECURITY_TLS, false); mockDash.setTlsAllowed(true); mSender.setTransport(mockDash); 
 assertTrue("dash", mockDash.getTlsReopened()); 
 assertTrue("space", mockSpace.getTlsReopened()); 
 } 
<|del|> 
<|del|> 
 String addContactString = getString( R.string.menu_add_address_to_contacts).replace("%s", uriString); 
<|del|> 
 // Reset the call screen since the calls cannot be transferred 
<|del|> 
 + "|(mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])" 
 return Math.round(density * dip); 
 } 
<|del|> 
 address = "Unknown"; 
 void onMMIDone(CdmaMmiCode mmi) { 
 final AST mAst; final ASTRewrite mRewriter; 
<|del|> 
 if(deviceSupportsNvAndRuim()) { mButtonCdmaSubscription.setEnabled(true); } else { mButtonCdmaSubscription.setEnabled(false); } 
 // Check if the position is less than size of all entries 
 address = getString(R.string.unknown_sender); 
 String addContactString = getString( R.string.menu_add_address_to_contacts).replace("%s", uriString); 
 ContentValues values = new ContentValues(); values.put(Contacts.LAST_TIME_CONTACTED, 0); values.put(Contacts.TIMES_CONTACTED, 0); getContentResolver().update(Contacts.CONTENT_URI, values, null, null); 
<|del|> 
 final String CLIR_OFF = "#31#+"; final String CLIR_ON = "*31#+"; 
 ipAddress = String.format("%d.%d.%d.%d", 
 ipAddress = String.format("%d.%d.%d.%d", 
 + ": must be >=0, got " //$NON-NLS-1$ 
 private static void initAdbSocketAddr() { 
 String errMsg = "env var " + SERVER_PORT_ENV_VAR + //$NON-NLS-1$ ": must be >=0, got " + //$NON_NLS-1$ System.getenv(SERVER_PORT_ENV_VAR); 
 String errMsg = "env var " + SERVER_PORT_ENV_VAR + //$NON-NLS-1$ ": illegal value '" + //$NON-NLS-1$ System.getenv(SERVER_PORT_ENV_VAR) + "'"; //$NON-NLS-1$ 
 // remove leading or trailing comma 
<|del|> 
<|del|> 
 public void setMultiChoiceModeListener(MultiChoiceModeListener listener) { if (mMultiChoiceModeCallback == null) { mMultiChoiceModeCallback = new MultiChoiceModeWrapper(); } mMultiChoiceModeCallback.setWrapped(listener); 
 if (mFastScrollOverlay != null) mFastScrollOverlay.setState(state); if (mFastScrollThumb != null) mFastScrollThumb.setState(state); 
 } mOverlayDrawable = overlay; mOverlayWidth = width; mOverlayHeight = height; setupDrawables(); mList.invalidate(); 
 if (thumb == null || width == 0 || height == 0) { throw new IllegalArgumentException("A valid drawable and correct width and height " + "must be set for the fast scroller thumb"); 
 canvas.translate(0, y); mThumbDrawable.draw(canvas); canvas.translate(0, -y); 
 url = url.substring(4); 
 throw new IllegalArgumentException("Invalid Uri (" + uri + ") used for observer"); 
 + "WARNING: This platform requires Ant build rules not supported by your SDK Tools.\n" 
 "WARNING: Ignoring invalid version code value '%s'.", versionCode)); 
 * Sets an ABI filter. If non <code>null</code>, then only native libraries matching the given 
 * are rejected. This must be a single ABI name as defined by the Android NDK. For a list * of valid ABI names, see $NDK/docs/CPU-ARCH-ABIS.TXT 
 mSelectedLayout = null; 
 view.mSelectedLayout = null; 
 mLayouts = new ArrayList<StaticLayout>(events.size()); // Replace layouts as well // Fill the layouts with nulls while(mLayouts.size() < events.size()) { mLayouts.add(null); } 
 private StaticLayout getEventLayout(int i, Event event, Paint paint, RectF rf) { StaticLayout layout=mLayouts.get(i); 
 // XXX Is this really needed when working with a StaticLayout? text=drawTextSanitizer(text); 
 return mSelectedLayout; } 
 return mSelectedLayout; 
<|del|> 
 if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_DPAD_CENTER) { 
 .substring(0, AndroidConstants.NS_CUSTOM_RESOURCES.lastIndexOf('/') + 1); 
 .substring(0, AndroidConstants.NS_CUSTOM_RESOURCES.lastIndexOf('/') + 1); 
<|del|> 
 throw new ApkCreationException(file.getAbsolutePath()+ " does not exist!"); 
 private void drag(VelocityTracker vt, int startX, int endX, int startY, int endY, int steps, long startime, int duration) { 
 url = url.substring(4); 
 url = url.substring(4); 
 StaticLayout layout = mLayouts.get(i); 
 (int) rf.width() - 2, Alignment.ALIGN_NORMAL, 1.0f, 0.0f, true, TextUtils.TruncateAt.END, (int) rf.width() - 2); 
 (int) rf.width() - 2, Alignment.ALIGN_NORMAL, 1.0f, 0.0f, true, TextUtils.TruncateAt.END, (int) rf.width() - 2); 
 StaticLayout layout = getEventLayout(i, event, eventTextPaint, rf); 
 * Copyright (C) 2010 The Android Open Source Project 
 if (TextUtils.isEmpty(mName)) { 
<|del|> 
 writer.append("# what follows is one line per generated apk with its description.\n"); 
 mDeliveryReportSupported = !(NO_DELIVERY_REPORTS.contains(mccmnc)); 
<|del|> 
 * threads should perform its own synchronization when using the Cursor. 
 * threads should perform its own synchronization when using the SQLiteCursor. 
 * threads should perform its own synchronization when using the SQLiteProgram. 
<|del|> 
 private static final int LEFT = 1; private static final int RIGHT = 2; private int mPreviousMove; 
 mFastScroller.setOverlay(overlay, overlayWidth, overlayHeight); mFastScroller.setThumb(thumb, thumbWidth, thumbHeight); mFastScroller.setTextSize(textSize); 
 if (mDialog == null) { 
 if (mDialog == null) { 
<|del|> 
 ed.commit(); setResult(RESULT_OK); 
<|del|> 
 setButton(DialogInterface.BUTTON_NEGATIVE, context.getText(R.string.no), (OnClickListener) null); 
<|del|> 
<|del|> 
 VERB_UPDATE, OBJECT_SDK, "n", KEY_DRY_MODE, 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (segment == null) { 
 private SensorManager mSensorManager; private Sensor mSensor; 
 if (mDialog == null) { 
 if (mDialog == null) { 
 setButton(DialogInterface.BUTTON_NEGATIVE, context.getText(R.string.no), (OnClickListener) null); 
 protected List<Map<String, Object>> getData(String prefix) { List<Map<String, Object>> myData = new ArrayList<Map<String, Object>>(); 
<|del|> 
<|del|> 
<|del|> 
 // Display the stored values, or if not stored initialize with an empty String 
 } else { 
 mGestureDetector = new GestureDetector(context, this, null); 
 "Any change in the multi-apk configuration requires an increment of the versionCode.", 
 * Sets the icon for this Preference with a Drawable. 
 Utils.updatePreferenceToSpecificActivityFromMetaDataOrRemove(this, parent, KEY_OPERATOR_SETTINGS); Utils.updatePreferenceToSpecificActivityFromMetaDataOrRemove(this, parent, KEY_MANUFACTURER_SETTINGS); 
 Utils.updatePreferenceToSpecificActivityFromMetaDataOrRemove(this, parent, KEY_OPERATOR_SETTINGS); Utils.updatePreferenceToSpecificActivityFromMetaDataOrRemove(this, parent, KEY_MANUFACTURER_SETTINGS); 
 if ((resolveInfo.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) { 
 Resources res = pm .getResourcesForApplication(resolveInfo.activityInfo.packageName); 
 private static final String INTENT_OPERATOR_HOOK = "com.android.settings.OPERATOR_APPLICATION_SETTING"; private static final String INTENT_MANUFACTURER_HOOK = "com.android.settings.MANUFACTURER_APPLICATION_SETTING"; 
 try { mGlVersion = Integer.decode(tmp); } catch (NumberFormatException e) { // pass. This is probably due to a manual edit, and it'll most likely // generate an error when matching the log to the current setup. } 
 if (Boolean.TRUE.equals(mSmallScreens)) { 
 LayoutConstants.ATTR_ID, 
<|del|>
 len = is.read(buffer); 
<|del|> 
<|del|> 
<|del|> 
 String[] fields = line.split("\\s+"); final int expectedNumColumns = 12; assertTrue(String.format("%s should have at least %d columns of output" + fields, procFilePath, expectedNumColumns), fields.length >= expectedNumColumns); 
 } } catch (FileNotFoundException notFound) { fail("Could not open file " + procFilePath + " to check for listening ports."); 
<|del|>
 // because the file may already exist and contain other values (like apk config), 
<|del|> 
 if (DECODE_STREAM) { 
<|del|> 
 if (TEST_PICTURE) { 
 view.setText(cursor.getString(COLUMN_DISPLAY_NAME)); 
<|del|> 
<|del|> 
<|del|>
 PEOPLE_PROJECTION, null, null, null); 
<|del|>
 fail("Found port listening on " + localAddress + " in " + procFilePath); 
<|del|> 
 Phone._ID, Phone.CONTACT_ID, Phone.NUMBER 
 Cursor groupCursor = managedQuery(Contacts.CONTENT_URI, 
 new String[] {Phone.NUMBER}, // Number for child layouts 
<|del|> 
<|del|> 
 public static final String[] CONTACT_PROJECTION = new String[] { 
 private static final String[] CONTACT_PROJECTION = new String[] { 
<|del|> 
 public synchronized void show(Uri lookupUri, Rect anchor, int mode, String[] excludeMimes) { 
 assertEquals(mArrayAdapter.getCount(), 0); 
 mArrayAdapter.add("testing"); mArrayAdapter.add("android"); Assert.assertEquals(mArrayAdapter.getCount(), 2); Assert.assertEquals(mArrayAdapter.getItem(0), "testing"); Assert.assertEquals(mArrayAdapter.getItem(1), "android"); 
 mArrayAdapter.add("testing"); mArrayAdapter.add("android"); Assert.assertEquals(mArrayAdapter.getCount(), 2); Assert.assertEquals(mArrayAdapter.getItem(0), "testing"); Assert.assertEquals(mArrayAdapter.getItem(1), "android"); 
 mArrayAdapter.add("testing"); mArrayAdapter.add("android"); Assert.assertEquals(mArrayAdapter.getCount(), 2); Assert.assertEquals(mArrayAdapter.getItem(0), "testing"); Assert.assertEquals(mArrayAdapter.getItem(1), "android"); 
<|del|> 
 "sh", // Why is sh running as root? Seems to be when using adb... 
 if (originalVideoCount == 0 && mImagesUri.equals(Video.Media.getContentUri("external"))) { 
 * around {@link android.net.Proxy#getHost()}. Currently no proxy will * be returned for localhost or if the active network is Wi-Fi. 
 * {@link android.net.Proxy#getHost()} 
 * {@link android.net.Proxy#getHost()} 
 static final public HttpHost getPreferredHttpHost(Context context, 
 (new File(fileToDelete)).delete(); 
 * Passing null will count all rows for the given table 
 System.err.println("com.android.sdklib.build.ApkBuilder which provides support for"); 
 if (s == null) { 
 adnStringFieldToStringGsm8BitHelper(byte[] data, int offset, int length) { 
 System.out.println("WARNING: Using deprecated <file> inner element in ApkBuilderTask." + "Use <dex path=...> instead."); 
 "Expected one dex file but path value resolve to %d files.", dexFiles.length)); 
 private final static class JarStatusImpl implements JarStatus { 
 * An optional {@link PrintStream} can also be provided for verbose output. If null, there will 
 * An optional {@link PrintStream} can also be provided for verbose output. If null, there will 
 * There will be one version of gdbserver for each ABI supported by the application. 
 return folderName.equalsIgnoreCase("CVS") == false && folderName.equalsIgnoreCase(".svn") == false && folderName.equalsIgnoreCase("SCCS") == false && folderName.equalsIgnoreCase("META-INF") == false && 
 public static boolean checkFileForPackaging(String fileName, String extension) { 
 System.out.println("WARNING: Using deprecated <file> inner element in ApkBuilderTask." + "Use <dex path=...> instead."); 
 protected void onNightModeChange() { 
 /* host */ "([-A-Za-z0-9%_]+(?:\\.[-A-Za-z0-9%_]+)*\\.*|\\[[0-9a-fA-F:\\.]+\\])?" + 
<|del|> 
<|del|> 
 static WeakHashMap<Context, WeakReference<AppWidgetManager>> sManagerCache = new WeakHashMap<Context, WeakReference<AppWidgetManager>>(); 
 * Task to execute aapt. * 
 private static class AdnComparator implements Comparator<AdnRecord> { 
<|del|> 
 if (DBG) log("adnRecords.size=" + N); 
 if (DBG) log("loadFromEf: results =" + newAdn); 
 "Value for '%1$s' is not valid. It must resolve to a single path", attribute)); 
 DeviceProvisionedObserver deviceProvisionedObserver = new DeviceProvisionedObserver(mHandler); 
 public static final String EXTRA_ACTIVE_TETHER = "activeArray"; 
 // Don't go over the end of the buffer, Process.parseProcLine might // write to wlBuffer[endIndex] 
 String username, String password, String routeList, String excludeRouteList) throws IOException { 
 // Also, record the updated projects that are libraries, to update 
 // we have a match! Add the library to the list (if it was 
 LinkLibraryBundle bundle = new LinkLibraryBundle(); 
 * to manually control the job that's running them (for instance each action is started from 
 "Failed to create library links: %1$s", //$NON-NLS-1$ 
<|del|> 
 HashMap<String, String> contentTypeParameters) { 
<|del|> 
<|del|> 
 public void testRunEnded(long elapsedTime, Map<String, String> runMetrics); 
 private static int 
 public static final int VIRTUAL_CALL_STATE_CONNECTED = 1; 
 // Looks like the call has been transferred back to the handsfree device if (isCellularCallInProgress()) { 
 if (isCellularCallInProgress()) { 
<|del|> 
 if (isCellularCallInProgress()) { 
 /* this is possible if the handsfree device powered off while in the middle of a * virtual call */ if (isVirtualCallInProgress()) { broadcastVirtualCallStateIntent(BluetoothHeadset.VIRTUAL_CALL_STATE_DISCONNECTED); 
<|del|> 
<|del|>
 if (efid == EF_PBR) { oldAdnList = mUsimPhoneBookManager.loadEfFilesFromUsim(); } else { oldAdnList = getRecordsIfLoaded(efid); } 
 adnCache.requestLoadAllAdnLike(efid, response); 
<|del|> 
 case WspTypeDecoder.CONTENT_TYPE_B_EMN: mimeType = WspTypeDecoder.CONTENT_MIME_TYPE_B_EMN; break; 
 binaryContentType = WspTypeDecoder.CONTENT_TYPE_B_VND_DOCOMO_PF; 
 if (Config.LOGD) Log.w(LOG_TAG, "Received PDU. Unknown Content-Type = " + mimeType); 
 if (Config.LOGD) Log.w(LOG_TAG, "Received PDU. Unknown Content-Type = " + mimeType); 
 * Copyright (C) 2010 The Android Open Source Project 
<|del|> 
 for (AdnRecord record : adnRecords) { 
 public static InetAddress intToInetAddress(int hostAddress) { 
 index += pduDecoder.getDecodedDataLength(); int dataIndex = headerStartIndex + headerLength; 
 * for a period longer than <var>maxTimeToOutputResponse</var>. 
 if (maxTimeToOutputResponse > 0 && timeToResponseCount > maxTimeToOutputResponse) { 
 * to not output any response. A value of 0 means the method will wait forever * (until the <var>receiver</var> cancels the execution) for command output and * never throw. 
<|del|>
 * Copyright (C) 2010 The Android Open Source Project 
 public static final String PLUGIN_ID = "com.android.ide.eclipse.hierarchyviewer"; 
<|del|> 
<|del|> 
 * Copyright (C) 2010 The Android Open Source Project 
 if (NetworkUtils.addRoute(mInterfaceName, inetAddress, 0)) { mDefaultRouteSet = true; } else { if (DBG) Log.d(TAG, " Unable to add default route."); } 
 extensionEF = foundAdn.extRecord; index = foundAdn.recordNumber; 
 boolean shouldReportAnrTraces = false; boolean shouldReportDumpsysMemInfo = false; boolean shouldAbort = false; 
 // Report ANR, dumpsys after releasing lock on this. // This ensures the availability of the lock to Activity controller's appNotResponding if (mLocalRequestAnrTraces) { 
 if (mLocalRequestDumpsysMemInfo) { 
 rotDiff[3*i+j] += prevR_i[3*k+i] * R_i[3*k+j]; 
 protected void addItem(List<HashMap<String,Object>> myData, String id, String displayName, 
 return (value != null) && (value instanceof Comparable<?>); 
 /** * A constant describing a rotation vector sensor type. * See {@link android.hardware.SensorEvent SensorEvent} * for more details. */ public static final int TYPE_ROTATION_VECTOR = 12; 
 * <p>{@link android.hardware.Sensor#TYPE_LINEAR_ACCELERATION Sensor.TYPE_LINEAR_ACCELERATION}:<p> * A three dimensional vector indicating acceleration along each device axis, not including * gravity. All values have units of m/s^2. 
public class SelectorTest extends TestCase { 
 } catch (Exception _) {} 
 fail("test does not work"); } else if (fail[0].booleanValue()) { 
 fail("test does not work"); } else if (fail[0].booleanValue()) { 
 private int getReadyOps(SelectionKeyImpl key) { SelectableChannel channel = key.channel(); return ((channel instanceof SocketChannel) && !((SocketChannel) channel).isConnectionPending()) ? OP_WRITE : CONNECT_OR_WRITE; 
 private int getReadyOps(SelectionKeyImpl key) { SelectableChannel channel = key.channel(); return ((channel instanceof SocketChannel) && !((SocketChannel) channel).isConnectionPending()) ? OP_WRITE : CONNECT_OR_WRITE; 
 private int getReadyOps(SelectionKeyImpl key) { SelectableChannel channel = key.channel(); return ((channel instanceof SocketChannel) && !((SocketChannel) channel).isConnectionPending()) ? OP_WRITE : CONNECT_OR_WRITE; 
 DescriptorsUtils.setDefaultLayoutAttributes( uiChild, false /*updateLayout*/); 
 * targets (local and/or remote) were wrong. 
 // Ignore 
 private final ExecutorService executor = Executors.newSingleThreadExecutor(); 
 String hvParentLocation = System.getProperty("com.android.hierarchyviewer.bindir"); if (hvParentLocation != null && hvParentLocation.length() != 0) { return hvParentLocation + File.separator + SdkConstants.FN_ADB; 
 return SdkConstants.FN_ADB; 
<|del|> 
public class DeviceBridge { public static final String TAG = "hierarchyviewer"; 
 Log.e(TAG, String.format("Failed to remove forward for device %1$s: %2$s", device, e.getMessage())); 
 } catch (IOException e) { Log.e(TAG, "Unable to get view server version from device " + device); 
/** * This class is used for connecting to a device in debug mode running the view * server. */ 
 return in; 
 return out; 
 /** * Used for storing a window from the window manager service on the device. * These are the windows that the device selector shows. */ 
 private final HashMap<IDevice, Window[]> deviceMap = new HashMap<IDevice, Window[]>(); 
 private final HashMap<IDevice, Integer> focusedWindowHashes = new HashMap<IDevice, Integer>(); 
 private final ArrayList<IDevice> deviceList = new ArrayList<IDevice>(); 
 private final ArrayList<WindowChangeListener> windowChangeListeners = new ArrayList<WindowChangeListener>(); 
 * Copyright (C) 2010 The Android Open Source Project 
 mContext = context; mDevice = device; 
 .onRestoreInstanceState(ss.customLabelDialogEditTextState); 
 assertEquals(testType, mimeType); 
 out.write(WSP_STRING_TERMINATOR); 
 out.write(0x01); out.write(SHORT_MIME_TYPE_ROLLOVER_CERTIFICATE | WSP_SHORT_INTEGER_MASK); 
 +"01234567890123456789012345678901234567890123456789012345678901234567890123456789"; 
 assertEquals(testType, mimeType); 
 public static void actionCheckMail(Context context, String emailAddress) { Intent i = new Intent(ACTION_CHECK_MAIL); i.setClass(context, MailService.class); i.putExtra(EXTRA_CHECK_ACCOUNT, emailAddress); context.startService(i); 
<|del|> 
 private static final String STRING_MIME_TYPE_ROLLOVER_CERTIFICATE = "application/vnd.wap.rollover-certificate"; 
 assertEquals(WSP_DEFINED_SHORT_MIME_TYPE_COUNT, WELL_KNOWN_SHORT_MIME_TYPES.size()); 
 WspTypeDecoder unit = new WspTypeDecoder( HexDump.toByteArray((byte) (value | WSP_SHORT_INTEGER_MASK))); 
 WspTypeDecoder unit = new WspTypeDecoder( HexDump.toByteArray((byte) (value | WSP_SHORT_INTEGER_MASK))); 
 public void testDecodeReturnsFalse_WhenOnlyAZeroBytePresent() { 
 if (emailAddress!=null && !TextUtils.isEmpty(emailAddress)) { 
 // if found start a thread to do the lookup if (emailAddress.length() > 0) { Thread thread = new LookupAccount(controller, intent, startId, emailAddress); thread.start(); 
 // if found get the account ID try { if (accountCursor.moveToFirst()) { accountID = accountCursor.getLong(EmailContent.ID_PROJECTION_COLUMN); } } finally { accountCursor.close(); 
 if (platformOSPath.endsWith(File.separator) == false) { platformOSPath = platformOSPath + File.separator; 
 mPaths.put(AIDL, sdkOsPath + SdkConstants.OS_SDK_PLATFORM_TOOLS_FOLDER + 
 * @param sdkOsPath Location of the SDK * @param platformFolder the root folder of the platform. 
 Map<String, String> map = ProjectProperties.parsePropertyFile(buildProp, log); if (map != null) { platformProp.putAll(map); } 
<|del|> 
 if (mimeType.equals(WspTypeDecoder.CONTENT_TYPE_B_PUSH_CO)) { 
 private static final String EMAIL_FIRST = 
 new FileWrapper(skinHardwareFile), 
 new FileWrapper(targetHardwareFile), 
 new FileWrapper(skinHardwareFile), 
 new FileWrapper(path), 
 new FileWrapper(configIniFile), 
 new FileWrapper(targetHardwareFile), 
 new FileWrapper(skinHardwareFile), 
<|del|> 
 private static final int WAP_PDU_SHORT_LENGTH_MAX = 30; private static final int WAP_PDU_LENGTH_QUOTE = 31; 
 * VIRTUAL_CALL_STATE_CHANGED 
 broadcastCallStateChange(msg.what); 
<|del|> 
 * All values are in radians/second and measure the rate of rotation 
<|del|> 
 if (!TextUtils.isEmpty(emailAddress)) { 
 if ((wbxmlBody[i] & WBXML_TOKEN_MASK) != WBXML_TAG_EMN) { 
 // if empty string if (i == j) return null; 
 private final Controller mController; private final Intent mIntent; private final int mStartId; private final String mEmailAddress; 
 List<HashMap<String,Object>> alphabeticalList = new ArrayList<HashMap<String,Object>>(timezoneSortedList); 
 i += wbxmlBody[i] + 1; 
 String extension = decodeExtension(wbxmlBody[i]); 
 private String decodeExtension(byte encodedByte) { 
 else if (encodedByte == WBXML_ATTR_EDU) { 
 private static final String EMAIL_FIRST = 
 private static final String TIMESTAMP_FIRST = 
<|del|> 
 * VIRTUAL_CALL_STATE_CHANGED 
 broadcastCallStateChange(msg.what); 
<|del|> 
 * All values are in radians/second and measure the rate of rotation 
 final float[] values = new float[3]; 
 public static void getQuaternionFromVector(float[] Q, float[] rv) { 
 builder.withValueBackReference(AggregationExceptions.RAW_CONTACT_ID1, backRefs.get(index1)); 
 builder.withValueBackReference(AggregationExceptions.RAW_CONTACT_ID2, backRefs.get(index2)); 
 ArrayList<Integer> backRefs = new ArrayList<Integer>(size()); 
 * gravity. All values have units of m/s^2. The coordinate system is the same as is used by the * acceleration sensor. 
<|del|> 
<|del|> 
<|del|> 
 while (!mDevices.isEmpty()) { Device device = mDevices.remove(0); 
 featureName.startsWith("android")); 
<|del|> 
 package com.android.hierarchyviewerlib.scene; 
<|del|>
 for (int n = mDevices.size() -1; n >= 0; n--) { Device device = mDevices.get(0); 
 for (int n = mDevices.size() -1; n >= 0; n--) { Device device = mDevices.get(0); 
<|del|> 
 } catch(IOException e) { // As the given path is invalid, // set mData = null, so that further processDrmInfo() // call would fail with IllegalArgumentException because of mData = null mData = null; 
 DrmUtils.writeToFile(rightsPath, drmRights.getData()); 
 if(length > 0) { data = new byte[length]; // read the entire data bufferedStream.read(data); } 
 @MonkeyRunnerExported(doc = "Given the name of a variable on the device, " + 
 returns = "boolean 'true' if the two objects contain the same image.") 
 } // Headset vendor-specific commands registerAllVendorSpecificCommands(); 
<|del|> 
 * Add a default route through the specified gateway. 
 for (int n = mDevices.size() - 1; n >= 0; n--) { 
 private String getMacAddress() { 
 ((msg.getWhen() - mLastSunPositionTime) >= ONE_MINUTE)) { 
 " oldType=" + networkType.toString()+ " newType=" + newNetworkType.toString()); 
 " oldType=" + networkType.toString()+ " newType=" + newNetworkType.toString()); 
 "RAT switched " + networkType.toString() + " -> " + newNetworkType.toString() + " at cell " + cid); 
 private View oldView = null; 
 mDeviceList.removeAll(); 
 * gives a String[] 
 if (oldView != null) { 
 if (oldView != null) { 
 byte[] address = hostAddress.getAddress(); 
<|del|> 
 * Add a default route through the specified gateway. 
 public static boolean addDefaultRoute(String interfaceName, InetAddress gw) { 
 * Add a host route. 
 InetAddress inetAddress = InetAddress.getByAddress(hostAddress); 
<|del|> 
 package com.android.hierarchyviewerlib.ui; 
 return; 
 * if null, indicates a directly-connected route. 
<|del|> 
 * <p>{@link android.hardware.Sensor#TYPE_GYROSCOPE Sensor.TYPE_GYROSCOPE}:<p> 
<|del|> 
<|del|> 
 PROTECTED, /** The element should be considered package-private. */ PACKAGE, 
 * Intended visibility if the element had not been made public or package-private for testing. 
<|del|> 
<|del|> 
 Thread.sleep(2000); 
 model = new TreeViewModel(); 
<|del|>
<|del|>
 private int mStatus; 
 public void notifyClamshellClosed(); 
 public void notifyClamshellOpened() { 
 public void notifyClamshellOpened() { 
 // initialize for next DIM animation because we did force screen on 
 void sendOnTextChanged(CharSequence text, int start, int before, int after) { 
<|del|> 
 private final String mMimeType; private final int mInfoType; 
 private final HashMap<String, Object> mAttributes = new HashMap<String, Object>(); 
 public static final int TYPE_REGISTRATION_INFO = 1; public static final int TYPE_UNREGISTRATION_INFO = 2; public static final int TYPE_RIGHTS_ACQUISITION_INFO = 3; public static final int TYPE_RIGHTS_ACQUISITION_PROGRESS_INFO = 4; 
 private final int mInfoType; private final String mMimeType; private final HashMap<String, Object> mRequestInformation = new HashMap<String, Object>(); 
 private final int mInfoType; private final String mMimeType; private final HashMap<String, Object> mRequestInformation = new HashMap<String, Object>(); 
 private final ArrayList<String> mFileSuffixList = new ArrayList<String>(); private final ArrayList<String> mMimeTypeList = new ArrayList<String>(); 
 if (connInst != null && connInst.equalsIgnoreCase("close")) { 
 if (connInst != null && connInst.equalsIgnoreCase("close")) { 
 return mCallbackProxy.createWindow(dialog, userGesture); 
 private int mStatus; 
<|del|> 
<|del|> 
 int err = setScreenStateLocked(true); 
 err = setScreenStateLocked(true); 
 // do not animate lights when clamshell is opened if (ANIMATE_SCREEN_LIGHTS && !mTempDisableLightAnimation) { 
 } return; } 
<|del|> 
<|del|> 
 /** The container id for the android framework jar file */ 
 private static AndroidClasspathContainer getContainerFromCache(IProject project, IAndroidTarget target) { 
 private static IClasspathEntry[] createClasspathEntriesFromPaths(String[] paths, IAndroidTarget target) { 
 // same; Cannot find source for API level 5 
 * Copyright (C) 2010 The Android Open Source Project 
<|del|> 
public class AndroidClasspathContainerPage extends WizardPage implements IClasspathContainerPage, IClasspathContainerPageExtension { 
 * Copyright (C) 2010 The Android Open Source Project 
<|del|> 
 String projectName = configuration.getAttribute("org.eclipse.jdt.launching.PROJECT_ATTR", //$NON-NLS-1$ ""); //$NON-NLS-1$ 
 IPath androidLib = new Path(paths[CACHE_INDEX_JAR]); 
 androidSrcOsPath = ProjectHelper.loadStringProperty(root, getAndroidSourceProperty(target)); 
 IPath androidSrc = null; String androidSrcOsPath = null; 
<|del|> 
 new IAccessRule[] { accessRule }, attributes, false // not exported. 
 IClasspathEntry entry = JavaCore.newLibraryEntry( jarPath, null, // source attachment path 
<|del|>
 ISourceContainer defaultContainer = 
 private void logUnexpectedGsmMethodCall(String name) { 
 assertEquals(0f, step, 0.000001f); 
<|del|> 
 if (srcFile.isFile()) { 
 if (srcFile.isDirectory()) { 
 private volatile Integer mStatus = null; 
 if (i != tokenCount - 1) { keys.add(keyInitial.toString()); } 
 // if the exec failed, and we couldn't parse the error output (and // therefore not all files that should have been marked, were marked), // we put a generic marker on the project and abort. 
 devTree = store.getString(PrefPage.PREFS_DEVTREE_DIR); 
 private final boolean isPowered() { 
 window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); 
 try { file.delete(); } catch (SecurityException ex) { // ignore 
/** * A text change that operates on android manifest using WTP SSE model. * It is base class for Rename Package and Rename Type changes */ 
 private String targetToString(IAndroidTarget target) { return target.getFullName().replace(SEP, ""); //$NON-NLS-1$ } 
 "Shows the outline of all views in the layout.", 
/** * A text change that operates on android manifest using WTP SSE model. * It is base class for Rename Package and Rename Type changes */ 
 * * Creates a new <code>AndroidDocumentChange</code> for the given * {@link IDocument}. * * @param document the document this change is working on 
 status.addFatalError("File " + SdkConstants.FN_ANDROID_MANIFEST_XML + " is invalid."); 
 /** * A text change that operates on android layout using WTP SSE model. * It is base class for Rename Package and Rename Type changes */ 
 * Creates a new <code>AndroidLayoutChange</code> * * @param file the layout file * @param document the document * @param manager the buffer manager * @param changes the list of changes 
 /** * This class describes the text changes of android layout files * */ 
 /** * Set of layout files with required text changes * */ 
 return "_android_" + name.replaceAll("-", "_"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ 
 private IFile mFile; 
 mAppPackage = manifestData.getPackage(); 
<|del|> 
 AdtPlugin.log(IStatus.ERROR, AdtPlugin.PLUGIN_ID, message); 
 * Register a callback to be invoked when the caller required to receive * error result of asynchronous APIs. 
 if ("Value".equals(mContext.getSharedPreferences("testPref", Context.MODE_PRIVATE).getString("test", "Default"))) { 
 if (deleteRoot && wasNotEmpty && folder.members().length == 0) { 
 // Only return the device when it is online 
 private IFile mFile; 
 private IFile mFile; 
 mAppPackage = manifestData.getPackage(); 
<|del|> 
<|del|> 
 AdtPlugin.log(IStatus.ERROR, AdtPlugin.PLUGIN_ID, message); 
 AdtPlugin.log(IStatus.ERROR, AdtPlugin.PLUGIN_ID, message); 
 * Copyright (C) 2010 The Android Open Source Project 
 public static int FOO = 42; public int getFoo() { return FOO; } public int getRandomFoo() { Random r = new Random(System.currentTimeMillis()); return r.nextInt(FOO); } 
 // if this returns true, this forces a full workspace rebuild which is not 
 // Only return the device when it is online 
 private CommonAction mGotoMethodDeclarationAction; private CommonAction mGotoErrorLineAction; 
 * This class defines what to do with the search match returned by a double-click or by the * Go to Problem action. 
 private boolean mFoundFirstMatch = false; 
<|del|> 
<|del|> 
 } 
 // we should expect to find adb, aidl, aapt and dx (adapted to the current OS). 
 // Bluetooth spec says length is limited to 248 bytes. Since utf-8 encoding can be 4 bytes 
 private void unlinkVibration(Vibration vib) { 
 vib.mToken.unlinkToDeath(vib, 0); 
<|del|> 
 if (LOCAL_LOGD) { Log.d(TAG, "Removed message from pending queue. " + mPendingMessagesList.size() + " left"); } 
 nextMessage = mPendingMessagesList.get(0); 
 if (LOCAL_LOGD) { Log.d(TAG, "Added message to the pending queue. Queue size is " + mPendingMessagesList.size()); } 
 "touch_icon BLOB DEFAULT NULL," + 
<|del|> 
 /** * A map of the {@link SwtDrawingStyle} colors that we have actually used * (to be disposed) */ private final Map<DrawingStyle, Color> mStyleColorMap = new EnumMap<DrawingStyle, Color>( DrawingStyle.class); 
<|del|> 
 public void setLogCatViewInterface(LogCatViewInterface i) { 
 public LogCatViewSearchRequestor(String choice, int lineNumber) { 
 IFile matched_file = (IFile) match.getResource(); IMarker marker = createMarkerFromSearchMatch(matched_file, match); 
 if (marker != null) { switchPerspective(); openFile(matched_file, marker); } 
 public void onDestroy() { 
<|del|> 
 if (RefactoringUtil.isRefactorAppPackage() && mAppPackage != null && mAppPackage.equals(packageName)) { 
<|del|> 
 private static boolean sRefactorAppPackage = false; 
 public static Attr findAndroidAttributes(final NamedNodeMap attributes, final String localName) { 
 if (SdkConstants.NS_RESOURCES.equals(namespace) && name != null && name.equals(localName)) { 
 RefactoringUtil.sRefactorAppPackage = refactorAppPackage; 
 public static final String CHOICE_METHOD_DECLARATION = DdmsPlugin.PLUGIN_ID + ".logcat.MethodDeclaration"; // $NON-NLS-1$ public static final String CHOICE_ERROR_LINE = DdmsPlugin.PLUGIN_ID + ".logcat.ErrorLine"; // $NON-NLS-1$ 
 public void setLogCatViewInterface(LogCatViewInterface i) { 
 public LogCatViewSearchRequestor(String choice, int lineNumber) { 
 if (marker != null) { switchPerspective(); openFile(matched_file, marker); } 
 public void onDestroy() { 
 * Copyright (C) 2010 The Android Open Source Project 
 * Performs the actual work promised by the {@link MenuAction}. 
 * Operate on the given node. 
 logError("DropFeedback.painter failed: %s", 
 * Displays a simple input alert dialog with an OK and Cancel buttons. 
 * Paints feedback for the given target node into the given graphics context. 
 * Performs the actual work promised by the {@link MenuAction}. 
 * Validates the given input string, and return null if the text is valid, 
 * Logs an error to the console. 
 oslibraryList.add(new File(resource.getLocation().toOSString()) .toURI().toURL()); 
 Process process = new ProcessBuilder("dexdeps", "--format=xml", testApk.getPath()).start(); 
<|del|> 
 selection += " AND " + Telephony.Carriers.APN + "=?"; selectionArgs = new String[]{ apnName }; 
 Log.d("sleeping after package action complete interrupted"); 
 * @param tag A string identifier for this notification. May be {@code null}. 
 Log.d("sleeping after package action complete interrupted"); 
 // as a move and consider everything else a "Drop" 
 return String.format("%1$s %2$s in %3$s", verb, object, where); 
 * @param selection The selection (which can be null, for example when the * user drags from the palette) 
 mSourceCanvas = null; mRemoveSourceHandler = null; 
 * Creates a new <code>AndroidDocumentChange</code> for the given 
 * Finds the attribute with values oldName 
 * Adds text edits for this change 
 mSourceCanvas = null; mRemoveSourceHandler = null; 
<|del|> 
 if (imm != null && imm.isActive(this)) { 
import java.util.Map; 
 * Creates a new <code>AndroidDocumentChange</code> for the given 
 * Finds the attribute with values oldName 
 * Adds text edits for this change 
 * Creates a new <code>AndroidDocumentChange</code> 
 * Creates a new <code>AndroidPackageRenameChange</code> 
 * Adds text edits for this change 
 * Creates a new <code>AndroidTypeMoveChange</code> 
 * Extensions to this extension point must therefore extend * <code>org.eclipse.ltk.core.refactoring.participants.RenameParticipant</code>. 
 Change change = new AndroidPackageRenameChange(mAndroidManifest, mManager, mDocument, mAndroidElements, mNewName, mOldName, mIsPackage); 
<|del|> 
 classpaths[index] = setIncludeInApkAttribute(containerEntry, include); 
<|del|> 
<|del|> 
<|del|> 
 private final LinkedList<SmsTracker> mPendingMessagesList; private final boolean mSynchronousSending; 
 nextMessage = mPendingMessagesList.get(0); 
 mSourceCanvas = null; mRemoveSourceHandler = null; 
 return System.getProperty("os.name").startsWith("Mac OS"); //$NON-NLS-1$ //$NON-NLS-2$ 
 /* * Cache of mSelectedEvent's corresponding StaticLayout. Set this to null whenever you change * mSelectedEvent. */ 
 private boolean mBuildForceErrorOnNativeLibInJar = true; private boolean mFormatXml = false; 
<|del|> 
 // Expect to see a recipient rectangle around the bounds of the 
 } 
 // Use a BookmarkItem to get the same look and feel as in the other context menus. 
 return hitTestResult(mInitialHitTestResult); 
 char[] tmp = new char[2048]; 
 char[] tmp = new char[2048]; 
 CalendarPreferenceActivity.SHARED_PREFS_NAME)); 
<|del|>
 BackupManager.dataChanged(this.getPackageName()); 
 if (mUaprofHeader != null && mUaprofHeader.length() > 0) { 
 * Copyright (C) 2010 The Android Open Source Project 
 * Copyright (C) 2010 The Android Open Source Project 
 fail("expected IllegalAccessError exception"); } catch (IllegalAccessError e) { 
 fail("expected an IllegalAccessError exception"); 
 * Copyright (C) 2010 The Android Open Source Project 
 * Copyright (C) 2010 The Android Open Source Project 
 throw new IllegalArgumentException(); } 
 new T_iget_13().run(); 
 new T_iget_boolean_6().run(); 
 new T_iget_char_6().run(); 
 * Copyright (C) 2010 The Android Open Source Project 
 * Copyright (C) 2010 The Android Open Source Project 
 * Copyright (C) 2010 The Android Open Source Project 
 * Copyright (C) 2010 The Android Open Source Project 
 * Copyright (C) 2010 The Android Open Source Project 
 * Copyright (C) 2010 The Android Open Source Project 
 try { 
 throw new MmsException(); 
 new T_iget_13().run(); 
 new T_iget_char_6().run(); 
 * Get the XML text directly from the editor. * * @param xmlNode The node whose XML text we want to obtain. * @return The XML representation of the {@link Node}. 
 /* package */ SimpleElement toSimpleElement() { 
 "android", //$NON-NLS-1$ 
 return "ControlPoint [x=" + x + ", y=" + y + "]"; //$NON-NLS-1$ 
public abstract class DropGesture extends Gesture { 
 * Sets the image to be drawn as an overlay from the passed in AWT * {@link BufferedImage} (which will be converted to an SWT image). 
 * be zoomed and scrolled.) 
 int cx = mCanvas.getHorizontalTransform().translate(x); int cy = mCanvas.getVerticalTransform().translate(y); return ControlPoint.create(mCanvas, cx, cy); 
 throw new IllegalArgumentException(); } 
 if (first == last) line2 = line; 
 * @return The next UI sibling of this UI node, or null. 
 Node lastChild = parentXmlNode.getLastChild(); 
 if (indent.length() > 0 && indent.charAt(indent.length()-1) == '\t') { 
 private final static Pattern FLOAT_PATTERN = Pattern.compile("(-?[0-9]+(?:\\.[0-9]+)?)(.*)"); //$NON-NLS-1$ 
 private static final String DEFAULT_PADDING_VALUE = 
 * @param densityValue the density factor for the screen. * @param xdpi the screen actual dpi in X 
<|del|> 
 * @return a new {@link ILayoutScene} object that contains the result of the layout. 
 * An object allowing interaction with an Android layout. 
 * Returns the actual android.view.View (or child class) object. This can be used * to query the object properties. 
 Object getViewObject(); 
 String getClassName(); 
 * Returns the left of the view bounds, relative to the view parent bounds. 
 * the result as a {@link LayoutScene}. Any error messages will be written to the 
 * The goal is to let tools only uses the latest API by providing a conversion interface 
 ArrayList<ViewInfo> convertedChildren = new ArrayList<ViewInfo>(children.length); 
<|del|> 
 mUiViewNode = (UiViewElementNode) viewInfo.getCookie(); 
 this(name, cookie, left, top, right, bottom, null /*viewObject*/, null /*layoutParamsObject*/); 
 assertEquals(WifiManager.WIFI_STATE_DISABLED, mWifiManager.getWifiState()); 
 String selection = String.format(Locale.US, "%s=1 AND %s!=%d", 
 void onChildInserted(INode child, INode parent, InsertType insertType); 
 hint.setAttribute(ANDROID_URI, BaseView.ATTR_TEXT, "Hint"); 
 label += String.format(" (%d elements)", actions.size()); 
 return mFqcn.substring(mFqcn.lastIndexOf('.') + 1); // This also works when there is no "." 
 * insertion. For example, the <code>DialerFilterRule</code> will insert EditText children 
 * <li> {@link NullSdkLog} is an implementation that does <em>nothing</em> with the log. 
 public void onChildInserted(INode child, INode parent, InsertType insertType) { super.onChildInserted(child, parent, insertType); 
 public void onChildInserted(INode child, INode parent, InsertType insertType) { super.onChildInserted(child, parent, insertType); 
 boolean isBarDragged = mHud.getTimeBar().isDragged(); 
 displayItem.mAnimatedPosition.add( 0.0f, 0.0f, i * DEPTH_POSITION); 
 * <li> {@link NullSdkLog} is an implementation that does <em>nothing</em> with the log. 
 * Copyright (C) 2006,2010 The Android Open Source Project 
 String selection = Calendars.SELECTED + "=1 AND " + Instances.SELF_ATTENDEE_STATUS + "!=" + Attendees.ATTENDEE_STATUS_DECLINED; 
 String selection = Calendars.SELECTED + "=1 AND " + Instances.SELF_ATTENDEE_STATUS + "!=" + Attendees.ATTENDEE_STATUS_DECLINED; 
 return resolver.query(uri, EVENT_PROJECTION, EVENT_SELECTION, null, EVENT_SORT_ORDER); 
 boolean isBarDragged = mHud.getTimeBar().isDragged(); 
 Image result = SwtUtils.drawRectangles(image, Collections.<Rectangle> emptyList(), null, 1.0, (byte) 121); 
<|del|> 
<|del|> 
 public Uri insert(Uri uri, ContentValues initialValues) { 
 public int delete(Uri uri, String selection, String[] selectionArgs) { 
 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { 
<|del|> 
 status.addFatalError(String.format("Failed to modify file %1$s%2$s", 
 String wsBefore = ""; //$NON-NLS-1$ 
 mScene.dispose(); mScene = null; 
 GridData gd = new GridData(GridData.FILL_HORIZONTAL); gd.grabExcessVerticalSpace = true; group.setLayoutData(gd); 
 mReplaceAllXml.setToolTipText("When checked, string literals will be replaced in other XML resource files having the same name but located in different resource configuration folders."); mReplaceAllXml.setText("Replace in all &XML files for different configuration"); 
 mReplaceAllXml.setToolTipText("When checked, string literals will be replaced in other XML resource files having the same name but located in different resource configuration folders."); mReplaceAllXml.setText("Replace in all &XML files for different configuration"); 
 examineAssignment(node); 
 mPhoneStateReceiver = new PhoneStateIntentReceiver(mContext, mHandler); mPhoneStateReceiver.notifyServiceState(EVENT_SERVICE_STATE_CHANGED); 
 SSLCertificateSocketFactory.getHttpSocketFactory(SOCKET_OPERATION_TIMEOUT, sessionCache), 443)); 
 SearchRequestor requestor = new SearchRequestor() { @Override 
 public final static String CLASS_APPLICATION = "android.app.Application"; //$NON-NLS-1$ 
 public final static String NODE_ACTIVITY_ALIAS = "activity-alias"; 
 Log.w(TAG, "No authenticator found for type=" + accountType + ", ignoring it."); 
 private static final int SOCKET_OPERATION_TIMEOUT = 60 * 1000; 
 SSLCertificateSocketFactory.getHttpSocketFactory( SOCKET_OPERATION_TIMEOUT, sessionCache), 443)); 
<|del|> 
 private AvdManager mAvdManager; private SdkManager mSdkManager; private MockLog mLog; private File mFakeSdk; private File mAvdFolder; private IAndroidTarget mTarget; 
 public static class MockLog implements ISdkLog { public Vector<String> messages = new Vector<String>(); 
import junit.framework.TestCase; 
 private boolean mHasSnapshot = true; private boolean mLaunchSnapshot = true; private boolean mSaveSnapshot = true; 
 SceneResult res = getResult(); if (data != null) { res = res.getCopyWithData(data); 
 * Copyright (C) 2010 The Android Open Source Project 
 if (NODE_ACTIVITY.equals(nodeName) && ATTRIBUTE_NAME.equals(attribute.getLocalName()) && ANDROID_URI.equals(attribute.getNamespaceURI())) { 
<|del|> 
 ResourceFolderType[] folderTypes = FolderTypeRelationship.getRelatedFolders(type); for (ResourceFolderType folderType : folderTypes) { if (folderType == ResourceFolderType.VALUES) { 
 private boolean open(Node node, Attr attribute) { 
 Pair<IFile, IRegion> target = findInXml(type, name, file); if (target != null) { return target; 
 editText = new MenuAction.Action(EDIT_TEXT_ID, AdtMessages.BaseViewRule_Edit_Text, null, onChange); 
 for (Node strNode = findChild(root, null, ResourcesDescriptors.STRING_ELEMENT); 
 Node nameAttr = attrs.getNamedItem(ResourcesDescriptors.NAME_ATTR); 
 /** Absolute path of the layout folder, e.g. "/res/layout".<br> This is a workspace path. */ 
 private final String CHAIN_FORMAT = "%1$s=>%2$s"; //NON-NLS-1$ 
 if (RILJ_LOGD) unsljLog(response); 
 * by the system. * * @deprecated This constant has never been used. 
 * Extra for {@link android.os.DropBoxManager#ACTION_DROPBOX_ENTRY_ADDED}: * long integer value containing time (in milliseconds since January 1, 1970 00:00:00 UTC) * when the entry was created. 
 if (mNtpActive && ntpAge < (mMaxNtpCacheAgeSec - 3 * mPolicyPollPeriodSec) * 1000) { if (VDBG) Slog.v(TAG, "using cached time"); return cachedNtp + ntpAge; 
 VERB_CREATE, OBJECT_AVD, "a", KEY_SNAPSHOT, "Place a snapshots file in the AVD, to enable persistence.", false); 
 private MockLog mLog; 
 c.parseArgs(new String[] { "create", "avd", "-t", "android-100", "-n", "myProject" }); 
 snapshotLaunchCheckbox.setLayoutData(gd = new GridData(GridData.FILL_HORIZONTAL)); 
 public boolean hasSnapshot() { 
 + SdkConstants.OS_SDK_TOOLS_LIB_EMULATOR_FOLDER; 
 fqcn = fqcn.replaceAll("\\$", "."); //NON-NLS-1$ //NON-NLS-2$ 
 // IndexedRegion.getLength() returns bogus values 
 * messages are waiting * @param onComplete Message that needs to be posted back to the caller on * completion. Used to propagate errors from the response to the * request originator 
 } else if (efCPHS_MWI != null) { 
 } else { 
<|del|> 
 * From TS 22.101: A.20 DTMF control Digits Separator * Upon the called party answering the UE shall send 
 assertEquals(WifiManager.WIFI_STATE_DISABLED, mWifiManager.getWifiState()); 
 */ @Deprecated 
 * Returns the dot-per-inch value associated with the density. * @return the dpi value. 
 mwi = 99; 
 //Get CDMA subscription mode from Settings.System 
 static final protected int EVENT_UPDATE_ICC_MWI = 14; 
import com.android.internal.telephony.CommandsInterface; import com.android.internal.telephony.PhoneBase; 
 ITextEditor textEditor = (ITextEditor) getAdapter(ITextEditor.class); 
 IDocument document = textEditor.getDocumentProvider().getDocument( textEditor.getEditorInput()); IRegion wordRegion = JavaWordFinder.findWord(document, offset); 
 if (VALUE_MATCH_PARENT.equals(value) && (ATTR_LAYOUT_WIDTH.equals(localName) || ATTR_LAYOUT_HEIGHT.equals(localName)) && SdkConstants.NS_RESOURCES.equals(namespace)) { return VALUE_FILL_PARENT; 
<|del|> 
 (this == UNKNOWN_PDP_ADDRESS_TYPE) || (this == USER_AUTHENTICATION) || 
 //***** Abstract methods @Override 
 if (mRadioTech == ServiceState.RADIO_TECHNOLOGY_UNKNOWN) 
 private static final int MASTER_CLEAR_EXECUTE_LEVEL = 20; 
 updateBatteryState(intent); 
<|del|> 
 level * 100 / scale >= MASTER_CLEAR_EXECUTE_LEVEL; 
 level * 100 / scale >= MASTER_CLEAR_EXECUTE_LEVEL; 
 selection = maximum - thumb; 
 * @param childXml an {@link ILayoutPullParser} containing the content of the new child, * including ViewGroup.LayoutParams attributes. 
 protected static Map<String, Pair<String, String>> collectIds( Map<String, Pair<String, String>> idMap, 
<|del|> 
<|del|> 
 * Copyright (C) 2010 The Android Open Source Project 
 verifyWordLimits(textDash, 0, -1, -1); 
 verifyWordLimits(textPunctOther, 0, -1, -1); 
 verifyWordLimits(textSymbolOther, 0, -1, -1); 
<|del|> 
<|del|> 
 // Test not writable / deletable for all files 
<|del|> 
 return filename.endsWith(".apk"); 
 log.warning("Ignoring platform '%1$s': %2$s is missing.", //$NON-NLS-1$ platformFolder.getName(), 
 * @param addonDir the location of the add-on directory. 
 // looks like revision does not parse to a number. 
 File addons = new File(new File(sdkManager.getLocation()), SdkConstants.FD_ADDONS); 
 for (File file : files) { 
 "Installs obsolete packages", 
 "Simulates the update but does not download or install anything", 
 keep += start; if (Character.isHighSurrogate(source.charAt(keep - 1))) { --keep; if (keep == start) { 
 if (configFilter != null) { commandArray.add("-c"); //$NON-NLS-1$ commandArray.add(configFilter); } 
 * Such package requires the {@code <api-level>} element. It is not an optional 
 int gmtOffset = zone.getOffset(System.currentTimeMillis()); 
 * Copyright (C) 2011 The Android Open Source Project 
 // The plug-in ID public static final String PLUGIN_ID = "com.android.ide.eclipse.traceview"; // $NON-NLS-1$ 
 // The shared instance private static TraceviewPlugin sPlugin; 
<|del|> 
<|del|> 
 mBluetoothService.sendUuidIntent(address); 
<|del|> 
 setChoiceMode(a.getInt(R.styleable.AbsListView_choiceMode, CHOICE_MODE_NONE)); setFastScrollAlwaysVisible( a.getBoolean(R.styleable.AbsListView_fastScrollAlwaysVisible, false)); 
 setChoiceMode(a.getInt(R.styleable.AbsListView_choiceMode, CHOICE_MODE_NONE)); setFastScrollAlwaysVisible( a.getBoolean(R.styleable.AbsListView_fastScrollAlwaysVisible, false)); 
 intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); 
 mBiggerTouchSlopSquare = biggerTouchSlop * biggerTouchSlop; 
 String dateTimeString = getAttribute(TAG_DATETIME); if (dateTimeString == null || !sNonZeroTimePattern.matcher(dateTimeString).matches()) return -1; 
<|del|> 
 * @param tag a tag describing the type of the warning 
 static final int ON_LAYOUT = 187; 
<|del|> 
 mPrevVolDirection = direction; 
<|del|> 
 private final List<Path> mPaths = new ArrayList<Path>(); 
 * In most case the list will only contain one item. If the top level node is {@code merge} 
 public List<ViewInfo> getRootViews() { 
 } setLayout(new FillLayout()); 
 RGB color = new RGB((rgb & 0xFF0000) >> 16, (rgb & 0xFF00) >> 8, rgb & 0xFF); 
 "LayoutLibrary initialization failed"); 
 StyleResourceValue theme = resources.getCurrentTheme(); 
 mWorkingSetGroup = new WorkingSetGroup(); 
 public static IWorkingSet[] getSelectedWorkingSet(IStructuredSelection selection, IWorkbenchPart activePart) { 
 * Copied from * org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageOne$WorkingSetGroup 
 size = new Dimension(width * zoom, height * zoom); 
 IPerspectiveDescriptor[] perspectiveDescriptors = PlatformUI.getWorkbench().getPerspectiveRegistry().getPerspectives(); 
 for (int i = 0; i < perspectiveDescriptors.length; i++) { 
 mWhichPerspective.setEnabled(mSwitchPerspective.getBooleanValue() , getFieldEditorParent()); 
<|del|> 
 "LayoutLibrary initialization failed"); 
 String projectName = configuration.getAttribute("org.eclipse.jdt.launching.PROJECT_ATTR", ""); 
 return RESULT_CANCELED; 
<|del|> 
 mRemaingMessages = msgCount; 
 mRemaingMessages = msgCount; 
 if (mState == STATE_GRID_VIEW || mState == STATE_FULL_SCREEN || mState == STATE_MEDIA_SETS) 
 // If the progress bar is still been dragged, then we do not want to blink the 
 mCurrentTime.setVisibility(View.VISIBLE); 
<|del|> 
<|del|> 
 /** * Confirm that decodeBody() does not crash when * given bad Base64 data. */ public void testDecodeBody_BadBase64() throws IOException { InputStream in = new ByteArrayInputStream(GOOD_BASE64.getBytes("us-ascii")); 
 /** * Confirm that decodeBody() does not crash when * given bad Base64 data. */ public void testDecodeBody_BadBase64() throws IOException { InputStream in = new ByteArrayInputStream(GOOD_BASE64.getBytes("us-ascii")); 
 true, message.isStatusReportMessage()); 
 SmsMessage message = SmsMessage.createFromPdu(pdu); 
 SmsMessage message = SmsMessage.createFromPdu(pdu); if (message.getStatus() < Sms.STATUS_PENDING) MessagingNotification.nonBlockingUpdateNewMessageIndicator(context, true, isStatusMessage); 
<|del|> 
<|del|> 
 ((GSMPhone) phone).notifyCallForwardingIndicator(); 
 float posPrevX = getPrevFocusX(); float posPrevY = getPrevFocusY(); 
<|del|> 
 true, message.isStatusReportMessage()); 
<|del|> 
<|del|> 
 mVmConfig = new VoiceMailConstants(); mSpnOverride = new SpnOverride(); 
 Log.e(LOG_TAG, "Exception querying IMSI, Exception:" + ar.exception); 
 if (mMethodHandler != null && (event.stateMask & SWT.MOD1) != 0) { 
 posX = detector.getFocusX(); posY = detector.getFocusY(); 
<|del|> 
 if (mSupportPanAndZoom && layer.getState() == GridLayer.STATE_FULL_SCREEN) { 
 * Copyright (C) 2011 The Android Open Source Project 
 if (!new File(directory).exists()) { 
 * Copyright (C) 2011 The Android Open Source Project 
<|del|> 
 public final static String PREFS_SHOW_ME = AdtPlugin.PLUGIN_ID + ".showMe"; //$NON-NLS-1$ 
 assertTrue("Aspect ratio must be between 1.333 (4:3) and 1.779 (16:9): " + aspectRatio, 
<|del|> 
 return ""; 
 } 
<|del|>
 public String getPathForAbi(); 
 fos.close(); fis.close(); 
<|del|> 
<|del|> 
<|del|> 
 String imagePath = getImageRelativePath(target); 
 private String[] mAbis; 
<|del|> 
 public String[] getAbiList(); 
 public String getPathForAbi(); 
 private String[] mSkins; private String mAbiType; 
 dlg.setFileName(fileName); 
 * @param format The YUV data format as defined in {@link ImageFormat}. 
 * @return the YUV format as defined in {@link ImageFormat}. 
 model.beginRecording(this, String.format("Add %1$s", type.getDisplayName())); 
 return "/data/resource-cache/" + apkPath.substring(1).replace('/', '@') + "@idmap"; 
 private static final int LARGE_TOUCH_SLOP = 18; 
 private final int mLargeTouchSlop; 
 public int getScaledLargeTouchSlop() { return mLargeTouchSlop; 
 "The original file ''%s'' has been deleted or is not accessible.", 
 "Save As", 
 "%s already exists.\nDo you want to replace it?" 
 String title = "Problems During Save As..."; String msg = String.format("Save could not be completed. %s", 
<|del|> 
 case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: ret = responseInts(p); break; case RIL_UNSOL_CDMA_PRL_CHANGED: ret = responseInts(p); break; 
 break; 
 break; 
 synchronized (this) { Log.i("**", "******************************* WAITING!!!"); try { wait(100); } catch (InterruptedException e) { 
 synchronized (this) { Log.i("**", "******************************* WAITING!!!"); try { wait(100); } catch (InterruptedException e) { 
 return mLastCompilationStatus; 
 assert workingSets != null; 
 whereArgs[0] = String.valueOf(mEventId); 
<|del|> 
<|del|> 
 pointerCoords[n].x = fromX[n] + (toX[n] - fromX[n]) * i / stepCount; pointerCoords[n].y = fromY[n] + (toY[n] - fromY[n]) * i / stepCount; 
 Control workingSetControl = mWorkingSetGroup.createControl(composite); 
 Control workingSetControl = mWorkingSetGroup.createControl(composite);; 
 assert workingSets != null; 
 Control workingSetControl = mWorkingSetGroup.createControl(composite);; 
 IWorkingSet[] workingSets = mMainInfo.getSelectedWorkingSets(); if (workingSets != null && workingSets.length > 0) { mWorkingSetGroup.setWorkingSets(workingSets); } 
<|del|> 
 assert workingSets != null; 
 * Copyright (C) 2011 The Android Open Source Project 
 // if device vibrate function is turned on, test this function if (mAudioManager.getVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER) == AudioManager.VIBRATE_SETTING_ON) { 
<|del|>
 new ConnectivityActionReceiver(ConnectivityManager.TYPE_MOBILE_HIPRI); 
 new ConnectivityActionReceiver(ConnectivityManager.TYPE_WIFI); 
<|del|> 
 preferredAbi, 
 private boolean mAbiCompatibilityMode; 
 * Returns array of permitted processor architectures */ 
 private boolean mAbiCompatibilityMode; 
<|del|> 
<|del|> 
 displayValue(c, "Abi Type:", AvdInfo.getPrettyAbiType(mAvdInfo.getAbiType())); 
 column4.setWidth(r.width * 20 / 100); // 22% 
 return "Invalid name"; 
 mPidWarning.setToolTipText("PID must be a number"); //$NON-NLS-1$ 
<|del|> 
 mTagWarning.setToolTipText("Tag cannot contain | or :"); //$NON-NLS-1$ 
 mNameWarning.setToolTipText("Name cannot contain | or :"); //$NON-NLS-1$ 
 mOkButton.setEnabled(result); 
 avdInfo.getTargetHash(), avdInfo.getTarget(), avdInfo.getAbiType(), avdInfo.getProperties()); 
 && (newText.indexOf("/") == -1) //$NON-NLS-1$ && (newText.indexOf("\\") == -1)) { //$NON-NLS-1$ 
 AddOnTarget(String location, String name, String vendor, int revision, String description, String[] abis, Map<String, String[]> libMap, PlatformTarget basePlatform) { 
 return mLocation + SdkConstants.OS_IMAGES_FOLDER; 
 PlatformTarget(String sdkOsPath, String platformOSPath, int apiLevel, String codeName, String versionName, int revision, String[] abis, Map<String, String> properties) { 
 return mRootFolderOsPath + SdkConstants.OS_IMAGES_FOLDER + abiType + File.separator; 
 // Note: Do not remove! As a side effect, following // constructor calls bind listeners to services. 
 * Copyright (C) 2011 The Android Open Source Project 
<|del|> 
 avdInfo.getTargetHash(), avdInfo.getTarget(), avdInfo.getAbiType(), avdInfo.getProperties()); 
 displayValue(c, "ABI:", AvdInfo.getPrettyAbiType(mAvdInfo.getAbiType())); 
 column4.setText("ABI"); 
 return mRootFolderOsPath + SdkConstants.OS_IMAGES_FOLDER + abiType + File.separator; 
 // Note: Do not remove! As a side effect, following // constructor calls bind listeners to services. 
 callOnKeyDown(keyListener, KeyEvent.KEYCODE_2, 2); assertEquals("Hi. B", mTextView.getText().toString()); 
 callOnKeyDown(keyListener, KeyEvent.KEYCODE_2, 2); assertEquals("Hi B", mTextView.getText().toString()); 
 HashSet<Uri> msgBox = mThreads.get(Long.valueOf(entry.getMessageBox())); 
 MotionEvent me = MotionEvent.obtain(0L, 10, 1, .0f, .0f, 0); 
<|del|> 
 return Collections.singletonList((ResourceFile) match); 
 Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_HOME); 
 * An object that is associated with a {@link FolderConfiguration}. 
 return "FrameworkResourceItem [mName=" + getName() + ", mFiles=" //$NON-NLS-1$ //$NON-NLS-2$ + getSourceFileList() + "]"; //$NON-NLS-1$ 
 * {@link #getResources(ResourceType)} and {@link #hasResourcesOfType(ResourceType)} only return 
 * returns all resources, even the non public ones so that this can be used for rendering. 
 for (Entry<ResourceType, Map<String, ResourceValue>> libEntry : libMap.entrySet()) { 
 protected ResourceItem createResourceItem(String name) { 
 public final static boolean DEBUG = false; 
 if (DEBUG) { switch (kind) { case IResourceDelta.ADDED: return "ADDED"; case IResourceDelta.REMOVED: return "REMOVED"; case IResourceDelta.CHANGED: return "CHANGED"; } 
 * Makes a resource repository * @param isFrameworkRepository whether the repository is for framework resources. 
 * Makes a resource repository * @param isFrameworkRepository whether the repository is for framework resources. 
 * Returns a list of {@link ResourceItem} matching a given {@link ResourceType}. 
 ArrayList<ResourceFolder> matchingFolders = new ArrayList<ResourceFolder>(folders.size()); 
 return Collections.singletonList((ResourceFile) match); 
 HashMap<String, ResourceValue> map = new HashMap<String, ResourceValue>(items.size()); 
<|del|> 
 private ResourceItem findDeclaredResourceItem(ResourceType type, String name) { 
<|del|> 
 * Copyright (C) 2011 The Android Open Source Project 
 IPerspectiveDescriptor[] perspectiveDescriptors = PlatformUI.getWorkbench().getPerspectiveRegistry().getPerspectives(); 
 Messages.DeviceView_Unable_Create_HPROF_For_Application, 
 return "ResourceItem [mName=" + mName + ", mFiles=" + mFiles + "]"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ 
 * document. Note that this does <b>not</b> do any kind of equivalence check * (see {@link #isEquivalent(Element, Element)}), and currently the search * is only by id; there is no structural search. 
 results.add("@" + namePrefix + resType.getName() + "/"); //$NON-NLS-1$ //$NON-NLS-2$ 
 if (attr.contains(name)) { 
 public static final String FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING = "android.hardware.camera.capability.manual_post_processing"; 
 public static final String FEATURE_CONSUMER_IR = "android.hardware.consumerir"; 
 // observed on quickfix1.xml. assertEquals("Unit test is hardcoded to errors for quickfix1.xml", "quickfix1.xml", name); 
<|del|> 
 private Pair<Image, Rectangle> renderPreview() { 
<|del|> 
 && (newText.indexOf('/') == -1) && (newText.indexOf('\\') == -1)) { 
 * @return Bitmap, or null on failures 
 String command = "mkdir " + entry.getFullEscapedPath() //$NON-NLS-1$ 
 Locale[] requiredLocales = {Locale.US, Locale.CHINESE}; if (Support_Locale.areLocalesAvailable(requiredLocales)) { Calendar us_calendar = Calendar.getInstance(Locale.US); Calendar ch_calendar = Calendar.getInstance(Locale.CHINESE); assertEquals(Calendar.SUNDAY, us_calendar 
<|del|> 
<|del|> 
 ANDROID_NS_NAME_PREFIX.length(), // cursorPosition 
 // <style><item name="android:foo"/>|</style> 
 if (name == null || name.equals(ATTR_ID) || name.startsWith(ATTR_STYLE)) { 
<|del|> 
 Log.e(TAG, "Unable to decode file " + filePath + ". OutOfMemoryError.", oom); 
 static final String CACHE_CONTROL_COMPOUND = "Cache-Control: no-cache, max-age=200000"; static final String CACHE_CONTROL_COMPOUND2 = "Cache-Control: max-age=200000, no-cache"; 
<|del|> 
 bmpOptions.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(mJpegData, 0, mJpegData.length, bmpOptions); assertEquals(pictureSize.width, bmpOptions.outWidth); assertEquals(pictureSize.height, bmpOptions.outHeight); 
 bmpOptions.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(thumb, 0, thumb.length, bmpOptions); assertEquals(size.width, bmpOptions.outWidth); assertEquals(size.height, bmpOptions.outHeight); 
 * @return the item value or null if there's no value. 
 if (name == null || name.equals(ATTR_ID) || name.startsWith(ATTR_STYLE)) { 
<|del|> 
 mWebView.setWebChromeClient(new WebChromeClient()); 
 if (name == null || name.equals(ATTR_ID) || name.startsWith(ATTR_STYLE) || name.startsWith(ATTR_LAYOUT_PREFIX) || name.equals(ATTR_TEXT) 
 mLargeDefaultTheme = mDefaultTheme; 
 if (usesSdks.getLength() > 0) { Element usesSdk = (Element) usesSdks.item(0); String targetSdk = null; 
 statusString = getString(R.string.battery_info_status_charging); 
 statusString = getString(R.string.battery_info_status_discharging); break; 
 // Headset's usually only have one button, which is meant to cause the 
 this.mMinFrequency = 87900; this.mMaxFrequency = 107900; this.mDefaultFrequency = 87900; 
 if ((frequency - mMinFrequency) % mChannelOffset != 0) { 
 * WARNING: This API is under development, expect the interface to change * without notice. 
 private static final Set<String> EXPORTED_METHODS = JythonUtils.getMethodNames(EasyMonkeyDevice.class); 
 By selector = getSelector(ap, 0); ViewNode node = mHierarchyViewer.findView(selector); 
 return new AndroidVersion(mApiLevel, null); 
 private boolean mDisplayArchives = false; // TODO: toggle via a menu item 
 treeColumn1.setImage(getImage(ICON_COLUMN_NAME)); 
 * WARNING: This API is under development, expect the interface to change * without notice. * * TODO: Implement other selectors, like classid, hash, and so on. 
 String logCfg = getStringAttributeValueOpt(doc, "TestLog", "path", fileName); if (null == logCfg) { 
 Thread.sleep(1000); 
 ret.poundString = dialString.endsWith("#") ? dialString : null; 
 } else if (dialingNumber != null && poundString == null) { 
 sendUssd(poundString); 
 public static boolean isApiSupported(Context context) { return context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_RADIO_FM_RECEIVER); } 
 functions = Collections2.filter(functions, new Predicate<String>() { @Override 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 * MonkeyImage interface. * * This interface defines an image representing a screen snapshot. 
 * Base class with basic functionality for MonkeyImage implementations. 
<|del|>
 * Dispose of any native resources this device may have taken hold of. 
 SwingUtilities.invokeLater(new Runnable() { @Override 
<|del|> 
 assertEquals(2, allDownloads); 
<|del|> 
 * Dispose of any native resources this device may have taken hold of. 
<|del|> 
 private static Uri getDefaultRingtoneUri(Context context, String setting) { 
 String[] prop = line.split(" *=", 2); 
 private static final LayoutMetadata sInstance = new LayoutMetadata(); 
 } else if (value != null) { 
 "chmod", "+x", file.getAbsolutePath() 
 * Will read length bytes. 
 if (offset >= mLength) { 
 * Will read length bytes. 
 if (offset + length > mLength) { 
 * Will copy (src.length - srcOffset) bytes. 
 * Will copy srcLength bytes. 
 * Will copy src.getLength() bytes. The bytes in src will not be consumed. 
 * Will copy (src.getLength() - srcOffset) bytes. The bytes in src will not 
 * Will copy srcLength bytes. The bytes in src will not be 
 if (srcOffset + srcLength > src.mLength) { 
 String ssid; String bssid; int security; int networkId; boolean wpsAvailable = false; 
 return (DetailedState.CONNECTED == mState) && AccessPoint.isLocalLinkAddress(mInfo); 
 File f = new File(mFolderPath, "userdata-qemu.img.lock"); //$NON-NLS-1$ 
<|del|> 
 * @param powerLevel Transmit power level to set. One of: * TRANSMIT_POWER_DEFAULT * TRANSMIT_POWER_WIFI_HOTSPOT 
import com.android.internal.telephony.uicc.IccUtils; import com.android.internal.telephony.uicc.SIMRecords; 
 private Method mViewGetParentMethod; private Method mViewGetBaselineMethod; 
 mViewGetBaselineMethod = viewClass.getMethod("getBaseline"); 
 mWebView.loadData("<html><body>" + p +"</body></html>", "text/html", "UTF-8"); } }); 
 .appendQueryParameter(NUM_BYTES_PARAMETER, Integer.toString(numBytes)) 
 response.setHeader("Content-Length", Integer.toString(numBytes)); 
 response.setHeader("Content-Length", Integer.toString(numBytes)); 
 * and perform some semi-automatic installation of a given package if available. 
 private volatile boolean mQuitRequested = false; 
 int RIL_REQUEST_REGISTRATION_STATE = 20; int RIL_REQUEST_GPRS_REGISTRATION_STATE = 21; 
 * Returns the threshold for the tuner. 
 } else { 
 if (BuildHelper.BENCHMARK_FLAG) { 
 consoleMsgs.add("Additionally some of those libraries will interfere with the installation of the application because of their location in lib/"); 
 AdtPlugin.printBuildToConsole(BuildVerbosity.ALWAYS, mProject, msg); 
 if (BENCHMARK_FLAG && line.startsWith("BENCHMARK:")) { 
 public static final boolean BENCHMARK_FLAG = false; public static long sStartOverallTime = 0; public static long sStartJavaCTime = 0; 
 public static final boolean BENCHMARK_FLAG = false; public static long sStartOverallTime = 0; public static long sStartJavaCTime = 0; 
 public static final boolean BENCHMARK_FLAG = false; public static long sStartOverallTime = 0; public static long sStartJavaCTime = 0; 
 // Benchmarking start long startPackageTime = 0; if (BENCHMARK_FLAG) { String msg = "BENCHMARK ADT: Starting Initial Packaging (.ap_)"; 
<|del|>
 "Native libraries detected in '%1$s'. See console for more information.", 
<|del|> 
 if (e1.getMessage().equals("Abort Received")) { status = BluetoothShare.STATUS_CANCELED; } else { status = BluetoothShare.STATUS_OBEX_DATA_ERROR; 
 ArrayList<Integer> uidToDelete = null; 
 // get the filepath of the script to run. // This will be the last undashed argument. 
 return MenuAction.createAction(ACTION_MARGIN, AdtMessages.BaseLayoutRule_Change_Margins_Title, 
 node.editXml(String.format(AdtMessages.BaseViewRule_Change_Attribute_s, ATTR_LAYOUT_WIDTH), 
 String message = String.format(AdtMessages.BaseViewRule_New_Value_s, attribute); 
 hint.setAttribute(ANDROID_URI, ATTR_TEXT, AdtMessages.DialerFilterRule_Hint_AttrText); 
 node.setAttribute(ANDROID_URI, "android:apiKey", //$NON-NLS-1$ String.format(AdtMessages.MapViewRule_ApiKey_URL_s, "http://code.google.com/android/add-ons/google-apis/mapkey.html")); //$NON-NLS-1$ 
 return errorHandler.handleWarning(AdtMessages.AdtPlugin_Sdk_Platform_Tools_Missing); 
 return AdtMessages.AaptQuickFix_Creates_XML_Entry_For_Missing_Resource_Opens_The_Editor; 
 AdtPlugin.printToConsole(project, "AIDL: " + name); //$NON-NLS-1$ 
 result += " \n" + AdtMessages.ExecResultException_Output_ToString; //$NON-NLS-1$ 
 rawTooltip += "* " + AdtMessages.DescriptorsUtils_Tooltip_Deprecated; //$NON-NLS-1$ 
 sb.append("* " + AdtMessages.DescriptorsUtils_Tooltip_Required); //$NON-NLS-1$ 
 return DEPRECATED_CATEGORY; 
 buf.append(AdtMessages.ExportLinksPart_Do_Something); 
 buf.append(AdtMessages.ExportLinksPart_Do_Something); 
 buf.append(AdtMessages.ExportLinksPart_Edit_AndroidManifest_File); 
 buf.append(AdtMessages.ExportLinksPart_Edit_AndroidManifest_File); 
 buf.append("<a href=\"http://code.google.com/android/devel/bblocks-manifest.html\">"); //$NON-NLS-1$ buf.append(AdtMessages.ExportLinksPart_Documentation); buf.append("</a>"); //$NON-NLS-1$ buf.append(AdtMessages.ExportLinksPart_Documentation_From_SDK); 
 String.format( AdtMessages.ProjectCallback_ProjectCallback_Wrong_Constructor_Message_s, clazz.getSimpleName()), null /* data */); 
 return String.format(AdtMessages.ProjectCallback_List_View_Item2_Sub_Item_s, (fullPosition + 1)); 
 String.format(AdtMessages.ConfigManagerDialog_New_Name_s, selection.device.getName()), // new name 
 title += String.format(AdtMessages.DynamicContextMenu_Ratio_2d, numOn, numOff + numOn); 
 AdtPlugin.log(IStatus.ERROR, AdtMessages.LayoutActionBar_Action_Not_Supported_s, 
 if (DEBUG) AdtPlugin.printErrorToConsole(AdtMessages.MoveGesture_Debug_Console_Tag, AdtMessages.MoveGesture_Drag_Enter, event); 
 * Copyright (C) 2011 The Android Open Source Project 
 public static String AaptParser_Apk_configuration_filter_invalid_s; 
 if ("Abort Received".equals(e1.getMessage())) { 
 Rect previousBounds, Rect newBounds, SegmentType horizontalEdge, SegmentType verticalEdge) { super.setNewSizeBounds(resizeState, node, layout, previousBounds, newBounds, horizontalEdge, verticalEdge); 
 String.format(VALUE_N_DP, mRulesEngine.pxToDp(newBounds.h))); 
 String.format(VALUE_N_DP, mRulesEngine.pxToDp(newBounds.w))); 
 default: return false; 
 false /* targetParent */, true /* horizontalEdge */, false /* verticalEdge */, 
 } return null; 
 // TODO: Consider doing the snap logic on all the possible matches // BEFORE sorting, in case this affects the best-pick algorithm (since some // edges snap and others don't). snapHorizontal(match.with, match.edge.at, mBounds); 
<|del|> 
 // Make size adjustments to ensure that the arrow has enough width to be visible 
 mRenderingMode = renderingMode; 
 public RenderSession createRenderSession() { 
 name = ""; 
 if (CallerInfo.UNKNOWN_NUMBER.equals(number) || CallerInfo.PRIVATE_NUMBER.equals(number) || CallerInfo.PAYPHONE_NUMBER.equals(number)) { number = mContext.getString(R.string.unknownNumber); 
<|del|> 
 * Copyright (C) 2011 The Android Open Source Project 
<|del|> 
 if (mSelection instanceof IStructuredSelection) { 
 return mProject.getFile(ANDROID_MK).getLocalTimeStamp() > mLastUpdate; //$NON-NLS-1$ 
 * 
 * <i>Asks user for login/password information.</i> 
 public Pair<String, String> displayLoginPasswordPrompt(String title, String message) { return mRoot.displayLoginPasswordPrompt(title, message); 
 public Pair<String, String> displayLoginPasswordPrompt(final String title, final String message) { final String[] resultArray = new String[2]; 
 public Pair<String, String> displayLoginPasswordPrompt(final String title, final String message) { final String[] resultArray = new String[2]; 
 * Copyright (C) 2011 The Android Open Source Project 
<|del|>
 // Benchmarking start long startPackageTime = 0; if (BENCHMARK_FLAG) { String msg = "BENCHMARK ADT: Starting Initial Packaging (.ap_)"; 
 } 
 mUpdateCrunchCache = true; } 
 return Pair.of("", ""); //$NON-NLS-1$ //$NON-NLS-2$ 
 mSdkLog.printf("\n%1$s\n%2$s", title, message); byte[] readBuffer = new byte[2048]; 
 mSdkLog.printf("\n%1$s\n%2$s", title, message); byte[] readBuffer = new byte[2048]; 
 public Pair<String, String> displayLoginPasswordPrompt( final String title, final String message) { 
 * Set this flag whenever calling build if PostCompiler is to run 
 Map<String, String> args = new TreeMap<String, String>(); 
 * Packages the resources of the project into a .ap_ file. 
 if (mConvertToDex && mUpdateCrunchCache && mPackageResources && mMakeFinalPackage) { 
 return mPackageResources == false || mUpdateCrunchCache == false; 
<|del|> 
<|del|> 
 * Build project incrementally. If fullBuild is not set, then the packaging steps in * the post compiler are skipped. (Though resource deltas are still processed). 
 * @param fullBuild Set whether to run the packaging (dexing and building apk) steps of * the post compiler. 
 * Build the project incrementally. Post compilation step will not occur. * This is equivalent to calling * <code>build(project, monitor, false)</code> * @see #build(IProject, IProgressMonitor, boolean) 
 // Skip over flag setting 
<|del|> 
 IntentFilter intentFilter = new IntentFilter(ACTION_PAIRING_REQUEST); 
 String libJavaPackages = null; 
 if (libJavaPackages == null) { libJavaPackages = libJavaPackage; } else { libJavaPackages += ";" + libJavaPackage; } 
<|del|> 
 int firstRightParenthesisIndex = messageBody.indexOf(')', 
<|del|> 
 libJavaPackages += ":" + libJavaPackage; 
<|del|> 
 } if (property == null || PREFS_PALETTE_MODE.equals(property)) { mPalette = mStore.getString(PREFS_PALETTE_MODE); } 
 * Copyright (C) 2011 The Android Open Source Project 
<|del|> 
<|del|> 
 public static IChimpBackend createBackendByName(String backendName) { if ("adb".equals(backendName)) { return new AdbBackend(); } else { return null; } } 
<|del|> 
 private final ExecutorService executor = Executors.newSingleThreadExecutor(); 
 } ChimpChat chimpchat = new ChimpChat(backend); 
 public final static String CPU_MODEL_CORTEX_A8 = "cortex-a8"; 
 if (!mReceiverRegistered) { registerReceiver(mBatteryReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); mReceiverRegistered = true; } 
 String[] lines = content.toString().split("\n"); //$NON-NLS-1$ StringBuilder sb = new StringBuilder(content.length()); 
 private void callAapt(String extraPackages) { 
 String line; while ((line = in.readLine()) != null) { content.append(line); 
 String[] prereqs = {}; 
<|del|> 
 StringBuilder content = new StringBuilder(); 
 content.append(in.readLine()); content.append("\n"); 
 String[] lines = content.toString().split("\n"); //$NON-NLS-1$ StringBuilder sb = new StringBuilder(content.length()); 
 mTargets = new HashSet<File>(targets.length); 
 if (preFile.getName().equals("AndroidManifest.xml") == false) { 
 for (File file : files) { 
 private static final String TAG = ApacheHttpClientTest.class.getSimpleName(); private static final int NUM_DOWNLOADS = 20; 
 private Map<ResourceType, Map<String, Integer>> mIdMap = new HashMap<ResourceType, Map<String, Integer>>(); private Map<Integer, Pair<ResourceType, String>> mReverseIdMap = new HashMap<Integer, Pair<ResourceType,String>>(); 
 public void setNoCrunch(boolean nocrunch) { mUseCrunchCache = nocrunch; 
 * @param extraPackages an optional list of colon-separated packages. Can be null * Ex: com.foo.one:com.foo.two:com.foo.lib 
<|del|> 
 if (line.endsWith("\\")) { 
 prereqs = files[1].trim().split(" "); 
 * @return the map of (name, integer) values. Can be null. 
 assertCanBeHandled(intent); intent.setAction(android.provider.MediaStore.INTENT_ACTION_VIDEO_CAMERA); assertCanBeHandled(intent); 
 metrics = getAndResetTestMetrics(); 
 listener.testEnded(testId, metrics); 
<|del|> 
 /** * Whether or not to load the expected policy from the preferences and check against * what the {@link DevicePolicyManager} reports. */ private static final String LOAD_EXPECTED_POLICY_PREFERENCE = "load-expected-policy"; 
 /** * Whether or not to load the expected policy from the preferences and check against * what the {@link DevicePolicyManager} reports. */ private static final String LOAD_EXPECTED_POLICY_PREFERENCE = "load-expected-policy"; 
 return mExpectedValue != null && mExpectedValue.equals(mActualValue); 
 /** * Whether or not to load the expected policy from the preferences and check against * what the {@link DevicePolicyManager} reports. */ private static final String LOAD_EXPECTED_POLICY_PREFERENCE = "load-expected-policy"; 
<|del|> 
 StringBuilder output = new StringBuilder(n); 
 if (prefixSize > 0 && prefixSize < maxLen) { 
 * the new process. * @param niceName null-ok a string specifying the process name. 
 private final String peerSecurityContext; private final String abiList; 
 peerSecurityContext = SELinux.getPeerContext(mSocket.getFileDescriptor()); 
 boolean seInfoSpecified; String seInfo; 
 seInfoSpecified = true; seInfo = arg.substring(arg.indexOf('=') + 1); 
<|del|> 
 if ((mLoaderManager != null) && (!mLoaderManager.mStarted)) { mLoaderManager.doStart(); 
 if (!mReleased) { Log.w(TAG, "You should have called release()"); release(); 
 public void release() { if (mReleased) { Log.w(TAG, "You have already called release()"); return; } mReleased = true; if (mEventHandler != null) { 
<|del|> 
 callForwardTxt = mApplication.getString( R.string.card_title_unconditionalCF); 
<|del|> 
 if (bitmap.getConfig() != reference.getConfig() || bitmap.getWidth() != reference.getWidth() || bitmap.getHeight() != reference.getHeight()) { return false; 
 for (int i = 0; i < length; i++) { 
 int dg = ((pel1 & 0x0000FF00) - (pel2 & 0x0000FF00)) >> 8; int db = ((pel1 & 0x00FF0000) - (pel2 & 0x00FF0000)) >> 16; 
 if (Math.abs(db) > threshold || Math.abs(dg) > threshold || Math.abs(dr) > threshold) { 
 if (Math.abs(db) > threshold || Math.abs(dg) > threshold || Math.abs(dr) > threshold) { 
 if (Math.abs(db) > threshold || Math.abs(dg) > threshold || Math.abs(dr) > threshold) { 
 if (bitmap.hasAlpha()) { int da = ((pel1 & 0xFF000000) - (pel2 & 0xFF000000)) >> 24; if (Math.abs(da) > threshold) { 
 if (bitmap.hasAlpha()) { int da = ((pel1 & 0xFF000000) - (pel2 & 0xFF000000)) >> 24; if (Math.abs(da) > threshold) { 
 if (bitmap.hasAlpha()) { int da = ((pel1 & 0xFF000000) - (pel2 & 0xFF000000)) >> 24; if (Math.abs(da) > threshold) { 
 if (bitmap.hasAlpha()) { int da = ((pel1 & 0xFF000000) - (pel2 & 0xFF000000)) >> 24; if (Math.abs(da) > threshold) { 
 JFileChooser chooser = new JFileChooser(name.substring(0, name.lastIndexOf(File.separatorChar))); 
 JFileChooser chooser = new JFileChooser(name.substring(0, name.lastIndexOf(File.separatorChar))); 
 error = new DrmErrorEvent(uniqueId, eventType, message); 
<|del|> 
 if (!fileName.endsWith(".png")) { 
<|del|> 
 assertEquals('Z', keyData.displayLabel); assertEquals(0, keyData.number); assertEquals('z', keyData.meta[0]); assertEquals('Z', keyData.meta[1]); assertEquals(0, keyData.meta[3]); 
 throw new BuildException("Missing attribute libraryResFolderPathRefid"); 
 * Copyright (C) 2012 The Android Open Source Project 
 * Copyright (C) 2012 The Android Open Source Project 
 * Cannot be null. * @param cache The {@link DownloadCache} instance to use. Cannot be null. 
 private final static int MAX_SMALL_FILE_SIZE = 640 * 1024; 
 private DownloadCache mDownloadCache; // lazily created in getDownloadCache 
 // our ExportHelper will convert them properly according to the platform. 
 /** An approximate share percentage of this platform and all the * platforms of lower API level. */ public float getShare() { return mShare; 
 && (next.state == ActivityState.PAUSED || next.state == ActivityState.STOPPED || next.state == ActivityState.STOPPING)) { 
 // Note that the actual ping is performed in MonitorStartup 
 int p1 = mPreview == NOT_A_PREVIEW ? Integer.MAX_VALUE : mPreview; int p2 = rhs.mPreview == NOT_A_PREVIEW ? Integer.MAX_VALUE : rhs.mPreview; 
 * Copyright (C) 2012 The Android Open Source Project 
<|del|> 
 String value = p.getProperty(ATTR_SRC); 
 p.load(is = new FileInputStream(jarProperties)); 
 InternalHandler() { 
 throw new IllegalStateException("Only the main " + "UI thread can create AsyncTasks"); 
 xmlName = AdtUtils.stripSuffix(xmlName, "Params"); //$NON-NLS-1$ 
 if (System.getenv("SDKMAN_DISABLE_CACHE") != null) { //$NON-NLS-1$ 
 if (System.getenv("SDKMAN_DISABLE_CACHE") != null) { //$NON-NLS-1$ 
 return string.substring(0, string.length() - suffix.length()); 
 || (viewName.startsWith(className) && viewName.equals(className + "_Layout"))) { //$NON-NLS-1$ 
 private final short[] mIndices = 
 assert(mVertexPoints != null); 
 direction = (x > y) ? 1 : 0; 
 * 
 Log.e(TAG, "isPrivateIP()" + address, e); 
 if (textProperty == null) { 
 * Converts latitude or longitude from 0.25 seconds (as defined in the 
 // Invalid value 
<|del|> 
 final long y = metrics.heightPixels/2; 
 // we want the final release package listed before its rc/preview packages. 
 Log.e(TAG, "[RadioInfo] EVENT_QUERY_PREFERRED_TYPE_DONE: unknown " + "type=" + type); 
<|del|> 
 final long y = metrics.widthPixels/2; 
 // messages added since last refresh, synchronized on mLogBuffer private List<LogCatMessage> mLogBuffer; 
<|del|> 
 /* The major revision for tool and platform-tool package 
<|del|> 
 //Use the middle of the screen to avoid the status bar. 
 d.setDefaults("", defaultTag, defaultText, defaultPid, defaultAppName, defaultLevel); 
 mgr.add(filterAction); 
<|del|>
 mCodename = sanitizeCodename(codename); 
 AndroidVersion apiVersion = new AndroidVersion(apiNumber, platformProp.get(PROP_VERSION_CODENAME)); 
 if (mAccessPoint.getLevel() != -1 && mAccessPoint.getState() == null && mEdit == false) { 
 AdtPlugin.log(IStatus.ERROR, AdtMessages.LayoutActionBar_Action_Not_Supported_s, 
<|del|> 
 AndroidVersion version = target.getVersion(); 
 loadPackages(true /*useLocalCache*/); // Next a regular package loader is created that will // respect the expiration and refresh parameters of the // download cache. 
<|del|> 
 mPrefStore.setValue(AUTO_MONITOR_PROMPT_SHOWN, true); 
 JFileChooser chooser = new JFileChooser( name.substring(0, name.lastIndexOf(File.separatorChar))); 
<|del|>
<|del|>
 entries.add(new ClassEntry(file, null /* jarFile*/, dir, bytes)); 
 if (closeOthers != null) { 
 private final String[] mInputs; private String mOutput; 
 return new JavaResChangedSet(project, "javaRes"); //$NON-NLS-1$ 
<|del|> 
 set.setOutput(path + "/" + AdtConstants.FN_RESOURCES_AP_); 
 private final boolean DEBUG_LOG = "1".equals( //$NON-NLS-1$ System.getenv("ANDROID_VISITOR_DEBUG")); //$NON-NLS-1$ 
<|del|> 
<|del|> 
 return false; 
 set.setOutput(path + '/' + AdtConstants.FN_RESOURCES_AP_); 
 mSettings.mProperties.setProperty( ISettingsPage.KEY_MONITOR_DENSITY, Integer.toString(density)); 
 * When settings have changed: retrieve the new settings, apply them, save them * and notify on-settings-changed listeners. 
 String tooltip = "The hostname or IP of the HTTP & HTTPS proxy server to use (e.g. proxy.example.com). " + "When empty, the default Java proxy setting is used."; 
 String tooltip = "The hostname or IP of the HTTP & HTTPS proxy server to use (e.g. proxy.example.com). " + "When empty, the default Java proxy setting is used."; 
 armeabi(SdkConstants.ABI_ARMEABI), armeabi_v7a(SdkConstants.ABI_ARMEABI_V7A), mips(SdkConstants.ABI_MIPS), x86(SdkConstants.ABI_INTEL_ATOM); 
<|del|> 
<|del|> 
<|del|> 
 public @Nullable String getProperty(@NonNull String name) { 
 String tooltip = "The hostname or IP of the HTTP & HTTPS proxy server to use (e.g. proxy.example.com).\n" + 
<|del|> 
 if ((mKeepAliveSession == null) && (isBehindNAT(determineLocalIp(localProfile), localProfile) 
 if (mSerialNumber != null && mSerialNumber.equals(device.getSerialNumber())) return false; 
 if (mManufacturerName != null && mManufacturerName.equals(f.mManufacturerName)) return false; 
 mClass == -1 || mSubclass == -1 || mProtocol == -1) { 
 * The "contactNumber" is a regular phone number, so use the CallLog * table. Assuming the most recent callLog entry for the phone number * has the most up to date info */ 
 if (c.moveToFirst()) { // we found something 
 info.lookupUri = UriUtils.parseUriOrNull(c .getString(CallLogQuery.CACHED_LOOKUP_URI)); 
 info.lookupUri = UriUtils.parseUriOrNull(c .getString(CallLogQuery.CACHED_LOOKUP_URI)); 
 // nothing of interest 
 } finally { 
 // somthing went south with the query 
 public Image addErrorIcon(@NonNull Image image) { 
 choices.add(Pair.of(Integer.toString(apiLevel), target.getFullName())); 
public class LogCatColorsPage extends FieldEditorPreferencePage implements IWorkbenchPreferencePage { 
 * Copyright (C) 2012 The Android Open Source Project 
 if (e.getParentNode() != null && e.getParentNode().getNodeName().equals(GRID_LAYOUT)) { 
 public static void main(String[] args) { if (args.length == 0){ printHelp(); System.exit(1); } int ret = 0; 
 public static void main(String[] args) { if (args.length == 0){ printHelp(); System.exit(1); } int ret = 0; 
<|del|> 
<|del|> 
 validationError("More than one default state for device " + mDeviceName); 
 File libs = new File(project.getDir(), LIBS_FOLDER); 
 File src = new File(projectDir, SRC_FOLDER); 
 int cnapNamePresentation = PRESENTATION_ALLOWED; 
 * Gets CNAP name associated with connection. 
 NodeList usesSdks = root.getElementsByTagName(NODE_USES_SDK); 
 // ADT R20 changes the attribute type of ATTR_TARGET_MODE to be a string from a bool. // So if parsing as a string fails, attempt parsing as a boolean. 
 "Launch failed on device: " + deviceName); continue; 
 boolean multipleDevices = mode.isMultiDevice(); 
 private static final String SYSTEM_APP = "system"; //$NON-NLS-1$ 
 private void reportAGpsStatus(int type, int status, byte[] ipAddr) { 
 "This wizard depends on templates distributed with the Android SDK Tools.\n" + 
 if (DEBUG) Log.d(TAG, "mAGpsDataConnectionAddr " + mAGpsDataConnectionAddr.toString()); 
<|del|> 
 @Override 
 listener.mListener.onFirstFix(mTimeToFirstFix); 
 synchronized (mListeners) { 
 private boolean newlineAfterElementClose(Element element, int depth) { 
 // element. See frameworks/base/core/java/android/text/Html.java and look for // HtmlToSpannedConverter#handleStartTag. 
<|del|> 
 private String mPreviousSearchText; 
<|del|> 
 boolean hasText = !mSearchText.getText().isEmpty(); 
<|del|> 
 mLog.conflict(Severity.INFO, 
 // process shortly anyway if the depdendent ContentProvider dies. 
<|del|> 
 public static class Builder { 
 protected Device(Builder b) { 
 mSoftware = Collections.unmodifiableList(b.mSoftware); mState = Collections.unmodifiableList(b.mState); 
 boolean isCardValid() { return this != CARDSTATE_INVALID; 
 if (TextUtils.isEmpty(opNames[0])) { newSS.setOperatorName(null, opNames[1], opNames[2]); 
 if (mSerialNumber != null && mSerialNumber.equals(device.getSerialNumber())) return false; 
 if (mManufacturerName != null && mManufacturerName.equals(f.mManufacturerName)) return false; 
 boolean result = DeviceSchema.validate(xml, baos, null); String output = baos.toString().trim(); 
 return FaceliftFilter.isPresent(); 
 assertTrue(Arrays.equals(new String[] { "/foo", "/bar:baz" }, Iterables.toArray(AdtUtils.splitPath("/foo;/bar:baz"), String.class))); 
 2, 
 // Used to check whether an activity, service or broadcast receiver is exported. 
<|del|> 
 c.surfaceCreated(mSurfaceHolder); 
 * Copyright (C) 2012 The Android Open Source Project 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 offset = -offset; 
 builder.append("GMT"); 
<|del|> 
 return firstLine != null && firstLine.startsWith("---") && //NON-NLS-1$ firstLine.contains("PRIVATE KEY"); //NON-NLS-1$ 
 return firstLine != null && firstLine.startsWith("---") && //NON-NLS-1$ firstLine.contains("PRIVATE KEY"); //NON-NLS-1$ 
 return firstLine != null && firstLine.startsWith("---") && //NON-NLS-1$ firstLine.contains("PRIVATE KEY"); //NON-NLS-1$ 
<|del|>
 return Speed.NORMAL; 
<|del|>
 if (d != null) { 
 && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_PORTRAIT))){ 
 return; } 
 && pm.hasSystemFeature(PackageManager.FEATURE_SCREEN_PORTRAIT))){ 
 if (!mClosed) close(); 
 bitmap.recycle(); 
<|del|> 
 public static AvdManager getInstance(SdkManager sdkManager, ISdkLog log) throws AndroidLocationException { 
 return mkdirs(false); } 
 String status = getResources().getString(R.string.selinux_status_enforcing); setStringSummary(KEY_SELINUX_STATUS, status); 
 * introduced in API level 16 in a backwards compatible fashion. 
 return ActivityOptionsCompatJB.makeThumbnailScaleUpAnimation(source, thumbnail, startX, startY); 
<|del|> 
 if (otherOptions instanceof ActivityOptionsCompatJB) { 
<|del|> 
<|del|> 
 String[] protocols = e.getEnabledProtocols(); StandardNames.assertValidProtocols(StandardNames.SSL_SOCKET_PROTOCOLS, protocols); assertNotSame(protocols, e.getEnabledProtocols()); 
 sRegionNames.put("ZW", "Zimbabwe"); //$NON-NLS-1$ 
 private Collection<IDevice> mDevices = Collections.EMPTY_LIST; 
 mDeviceName = deviceName == null ? "?" : deviceName; //$NON-NLS-1$ 
 if (!file.isFile() || (!LintUtils.endsWith(file.getPath(), "pem") && //NON-NLS-1$ !LintUtils.endsWith(file.getPath(), "key"))) { //NON-NLS-1$ 
 return Speed.NORMAL; 
 for (RemoteAndroidTestRunner runner : runners) { 
<|del|>
 final int initialCapacity = 98; 
 * Restores a file to its default SELinux security context. * If the system is not compiled with SELinux, then true * is automatically returned. * If SELinux is compiled in, but disabled, then true is * returned. * 
 if(!SELinux.restorecon(file)) { return null; } 
 public void testEnded(TestIdentifier test, Map<String, String> ignoredTestMetrics) { 
<|del|> 
<|del|> 
<|del|> 
 * If the system is not compiled with SELinux, then {@code true} * is automatically returned. * If SELinux is compiled in, but disabled, then {@code true} is * returned. 
 * If the system is not compiled with SELinux, then {@code true} * is automatically returned. * If SELinux is compiled in, but disabled, then {@code true} is * returned. 
 * If the system is not compiled with SELinux, then {@code true} * is automatically returned. * If SELinux is compiled in, but disabled, then {@code true} is * returned. 
 * Copyright (C) 2012 The Android Open Source Project 
 private Button mGyro; // hw.sensors.orientation 
 mGyro = generateButton(sensorGroup, "Gyroscope", "Presence of a gyroscope", SWT.CHECK, true, validator); 
 * @param locale the locale to look up a typo database for (should be a * language code (ISO 639-1, two lowercase character names) 
 if (!reference.onList) { 
<|del|> 
 listeners.add(listener); 
 static volatile int refreshNumber = 1; 
 static volatile int refreshNumber = 1; 
 private static final List<Provider> providers = new ArrayList<Provider>(20); 
 public static Provider[] getProviders() { synchronized (providers) { return providers.toArray(new Provider[providers.size()]); } 
 * Typically the caller should call * flushCachesAndRefreshServicesIfNeeded() and invalidate any of * their own caches against the refreshNumber before resorting to * calling this method. 
 public static Provider.Service getService(String key) { synchronized (services) { return services.get(key); } 
 public static void setNeedRefresh() { synchronized (providers) { needRefresh = true; } 
 * Returns true if services contain any provider information. 
 Thread.sleep(sleepMills); 
 int len = ((data.length - 3) < 32) ? (data.length - 3) : 32; System.arraycopy(data, 3, spnData, 0, len); 
 if (mListeners.size() == 0 && mBinderListener != null) { 
<|del|> 
 * Need refresh flag. 
 /** Returns the build API version to use */ 
 * @return reserved space in bytes. 
 menu.add(0, MENU_ADD_SLIDE, 0, R.string.add_slide).setIcon( R.drawable.ic_menu_add_slide); 
 break; 
 } 
 // If it's not properly set, the check will display a dialog to state 
 public void setModel(final UiAutomatorModel model, final File modelFile, final Image screenshot) { 
 removeAllDevices(); } 
 cancel(true); } 
 } catch (Exception e) { 
 finally { 
<|del|> 
 throw new BuildException("UI Automator requires API 16"); 
 String uiAutomatorJar = androidTarget.getPath(IAndroidTarget.UI_AUTOMATOR_JAR); 
 element.setPath(jarPath); 
import java.net.Socket; import java.net.SocketException; import java.net.URI; import java.net.URISyntaxException; import java.net.URL; 
 * Copyright (C) 2012 The Android Open Source Project 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * http://www.apache.org/licenses/LICENSE-2.0 
<|del|> 
 System.err.println(String.format("Error: %1$s", t.getMessage())); 
 * @param msgFormat is a string format to be used with a {@link Formatter}. Cannot be null. 
 printMessage(msg, System.out); } private void printMessage(String msg, PrintStream stream) { 
 for (WifiP2pGroup grp: groups) { 
 ((PersistentGroupInfoListener) listener). onPersistentGroupInfoAvailable(groups); 
<|del|> 
 private int connect(WifiP2pConfig config, boolean tryInvocation) { 
 for (WifiP2pGroup group : groups) { 
<|del|> 
 int firstRightParenthesisIndex = messageBody.indexOf(')', firstLeftParenthesisIndex + 1); 
 firstDoubleHashIndex < firstSingleHashIndex && (firstLeftParenthesisIndex < 0 || firstRigthParenthesisIndex < 0 || firstDoubleHashIndex < firstLeftParenthesisIndex)) { 
<|del|> 
<|del|> 
<|del|> 
 n + 1, pointerIds, pointerCoords, 0, 1.0f, 1.0f, 0, 0, 0, 0); 
 for (int n = points - 1; n > 0; n--) { 
 n + 1, pointerIds, pointerCoords, 0, 1.0f, 1.0f, 0, 0, 0, 0); 
<|del|> 
<|del|> 
 public TouchCalibration getTouchCalibration(String inputDeviceDescriptor, int surfaceRotation) { 
 if (com.android.internal.telephony.Phone.DEBUG_PHONE) { Log.d(TAG, "sendSms: " +" mRetryCount="+tracker.mRetryCount +" mMessageRef="+tracker.mMessageRef +" SS=" +mPhone.getServiceState().getState()); } 
 throw new ParseException("Invalid TOA - high bit must be set. toa = " + toa, offset + OFFSET_TOA); 
 ContentValues values = new ContentValues(); values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName); Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values); 
 if (pointerIndex == -1) { Log.e(TAG, "Invalid pointer index"); 
 if (activePointerIndex == -1) { Log.e(TAG, "Invalid active pointer index"); 
 if (pointerIndex == -1) { Log.e(TAG, "Invalid pointer index"); 
 if (activePointerIndex == -1) { Log.e(TAG, "Invalid active pointer index"); 
 uniqueId = ((DrmInfoEvent)msg.obj).getUniqueId(); eventType = ((DrmInfoEvent)msg.obj).getType(); message = ((DrmInfoEvent)msg.obj).getMessage(); 
 error = new DrmErrorEvent(uniqueId, eventType, message); 
 * Java compilation is not handled but the builder provides the runtime classpath with 
 String[] parts = messageBody.split("( /)|( )", 2); if (parts.length < 2) return; emailFrom = parts[0]; emailBody = parts[1]; isEmail = true; 
 HandlerThread thread = new HandlerThread("IntentService[" + mName + "]", mPriority); 
 * Java compilation is not handled but the builder provides the runtime classpath with 
 if (flavorLocation == null && typeLocation == null && 
 * Returns the location of the lint jar. 
 if (mRenderer != null) mRenderer.setOffset(xOffset, yOffset, xPixels, yPixels); 
 } else { 
 } else { 
 profile.quality <= CamcorderProfile.QUALITY_TIME_LAPSE_VGA) { 
 * @param sourceOutputDir directory where to put this. This is the source folder, not the * package folder. 
 * Holds a BuildType and gives access to its various paths 
 * Provides paths for configuration (either ProductFlavor or BuildType) 
 * Holds a ProductFlavor and gives access to its various paths 
 public DuplicateFileException(@NonNull String archivePath, @NonNull File file1, @NonNull File file2) { 
 return null; 
 return null; 
/** * Implementation of PathProvider for testing that provides the default convention paths. 
 public static final String INTENT_VALUE_ICC_UNKNOWN = "UNKNOWN"; 
 if (storageVolumes.length == 1) { 
 return mStorageManager.getVolumeState( getExternalStoragePath() ); 
 if (supportMultipleStorage()) { 
 mRate = SensorManager.SENSOR_DELAY_NOPOLL; } 
 if (storageVolumes.length == 1) { 
 intent.setAllowFds(false); } 
 mWakeLock = mPowerManager.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP, "usb_lock"); 
 || intent.getAction().equals(Intent.ACTION_CAMERA_BUTTON)) { 
 //here should cancel the dialog, if not, if it is an alertdialog, //it will block thread always. 
 protected String RADIO_RESET_PROPERTY = "gsm.radioreset"; 
<|del|> 
<|del|> 
 if (info == null) return; 
 insert = i + 1; 
 if (endId <= nextRange.endId) { 
 assertEquals("flags after test", FLAG_START_UPDATE_CALLED | FLAG_FINISH_UPDATE_CALLED, testManager.flags); 
 .setNegativeButton(com.android.internal.R.string.no, new DialogInterface.OnClickListener() { 
 } else if (micDev == MIC_HEADPHONE_DEVICE) { 
 if (intent != null) { 
 /** * In case of 3gpp2 we need to find out if subscription used is coming from * NV in which case we shouldn't broadcast any sim states changes if at the * same time ro.config.multimode_cdma property set to false. 
 @Override public void supplyPin2(String pin2, Message onComplete) { 
 if (phone.getIccCard().isApplicationOnIcc(AppType.APPTYPE_USIM)) { 
 if (phone.getIccCard().isApplicationOnIcc(AppType.APPTYPE_USIM)) { 
 protected String mImsi; 
 UiccCardApplication(UiccCard uiccCard, IccCardApplicationStatus as, Context c, CommandsInterface ci) { 
 synchronized (mLock) { if (mDestroyed) { loge("Application updated after destroyed! Fix me!"); return; } 
 private void notifyReadyRegistrantsIfNeeded(Registrant r) { 
 // Don't notify if application is in insane state 
 private void notifyPinLockedRegistrantsIfNeeded(Registrant r) { 
 if (mPin1State == PinState.PINSTATE_ENABLED_VERIFIED || mPin1State == PinState.PINSTATE_DISABLED) { 
 private void notifyNetworkLockedRegistrantsIfNeeded(Registrant r) { 
 * in itself - just get first FileHandler and IccRecords object 
 UiccCardApplication newUiccApplication = mUiccController.getUiccCardApplication(UiccController.APP_FAM_IMS); 
 UiccCardApplication newUiccApplication = 
 && (phone.getCurrentUiccAppState() != 
 if (DBG) log("CSIM_MDN=" + IccUtils.bytesToHexString(data)); // Refer to C.S0065 5.2.35 
 UiccCardApplication newUiccApplication = 
 static GsmMmiCode newFromUssdUserInput(String ussdMessge, GSMPhone phone, UiccCardApplication app) { 
 static GsmMmiCode newFromUssdUserInput(String ussdMessge, GSMPhone phone, UiccCardApplication app) { 
 synchronized (mLock) { if (mUiccCard != null) { return mUiccCard.getApplication(family); } return null; 
 synchronized (mLock) { if (mUiccCard != null) { UiccCardApplication app = mUiccCard.getApplication(family); if (app != null) { return app.getIccRecords(); } 
 * <p>Note that the output of a {@code SecureRandom} instance should never 
 * input, see {@link MessageDigest} which provides one-way hash functions. * For deriving keys from passwords, see 
 throw new IllegalArgumentException("capacity < 0: " + capacity); 
 if (!Build.TYPE.equals("user")) { 
 // 'sync' command always succeeds, and this function returns 0. 
 Slog.e(TAG, "Failed to close sysrq-trigger while triggering crash: " + e); 
 "Implicitly using the default locale is a common source of bugs: " + 
 "Implicitly using the default locale is a common source of bugs: " + 
 mWakeLock.release(); } 
 assertEquals(1, mContentResolver.delete(uri, null, null)); 
 InputStreamReader reader = new InputStreamReader(templateStream); 
 Files.write(content, file, Charsets.UTF_8); 
 if (mAppSearchData != null) { queryExtras.putParcelable(SearchManager.APP_DATA, mAppSearchData); 
 if (mAppSearchData != null) { queryExtras.putParcelable(SearchManager.APP_DATA, mAppSearchData); 
 int rc = doMountVolume(path); if (rc != StorageResultCode.OperationSucceeded) { Slog.w(TAG, "Insertion mount failed : " + rc); 
 int rc = doMountVolume(path); if (rc != StorageResultCode.OperationSucceeded) { Slog.w(TAG, "Insertion mount failed : " + rc); 
 menu.findItem(R.id.download_context_menu_id).setOnMenuItemClickListener( 
 * gets when it calls getIccCard is IccCardProxy. 
 synchronized (mLock) { mPinLockedRegistrants.remove(h); 
 if (oldState != CardState.CARDSTATE_ABSENT && mCardState == CardState.CARDSTATE_ABSENT) { 
<|del|> 
 * Notifies specified registrant, mLock not held. 
 /* we'd love it if this was package-scoped*/ return super.getCurrentUiccAppStateP(); 
 list.addAll(mFlavorConfigs); 
 * The Phone App assumes that there is only one icc card, and one icc application 
<|del|> 
 assertTrue((0.1 <= outMetrics.density) && (outMetrics.density <= 3)); assertTrue((0.1 <= outMetrics.scaledDensity) && (outMetrics.scaledDensity <= 3)); 
 assertTrue((0.1 <= metrics.density) && (metrics.density <= 3)); assertTrue((0.1 <= metrics.scaledDensity) && (metrics.scaledDensity <= 3)); 
 updateSearchEngine(false); 
 updateSearchEngine(false); 
 updateSearchEngine(false); 
 spn = IccUtils.adnStringFieldToString(data, 0, data.length); 
 spn = IccUtils.adnStringFieldToString(data, 0, data.length); 
 /* REMOVE this method once mIccLockEnabled is not needed */ 
<|del|> 
<|del|> 
 /* STOPSHIP: Remove line above and all code associated with setting mIccLockEanbled once all RIL correctly sends the pin1 state. 
 if (DBG) log("supplyNetworkDepersonalization"); 
 if (DBG) log("changeIccLockPassword"); 
 if (cd.isValidUserId()) { return String.format(Locale.US, "%s (%d)", name, cd.getUserId()); } else { return name; } 
 * Copyright (C) 2012 The Android Open Source Project 
 monitor.setDescription("Fetching URL: %1$s", url); 
 // use url suffix to decide whether this is a SysImg or Addon; // see SdkSources.loadUserAddons() for another check like this if (url.endsWith(SdkSysImgConstants.URL_DEFAULT_FILENAME)) { 
 System.err.println("The " + ARG_SOURCES + ", " + ARG_CLASSES + " and " 
<|del|> 
<|del|> 
 listeners.remove(listener); 
 // mNativeSynth is used by TextToSpeechService#onCreate so it must be set prior // to that call. 
 // mNativeSynth is used by TextToSpeechService#onCreate so it must be set prior // to that call. 
 UNKNOWN, 
 if (outGenLocation == null && outResPackageLocation == null) { throw new IllegalArgumentException("no output provided for aapt task"); } 
 * Copyright (C) 2012 The Android Open Source Project 
<|del|> 
 if (mIccFh != null) { mIccFh.dispose();} 
 * correct version of resources. If MCC is 0, MCC and MNC will be ignored (not set). 
 config.mcc = mcc; config.mnc = mnc == 0 ? Configuration.MNC_ZERO : mnc; 
 * Copyright (C) 2012 The Android Open Source Project 
 imageLoader.save(file.getAbsolutePath(), SWT.IMAGE_PNG); 
<|del|> 
 public SymbolWriter(String outFolder, String packageName, SymbolLoader symbols, SymbolLoader values) { 
 file = new File(file, SdkConstants.FN_RESOURCE_CLASS); 
 Closeables.closeQuietly(writer); 
<|del|> 
 manager.add(new Action("Save to File", 
 assert prop != null; if (prop != null) { prop.prettyPrint(pp); } 
 private final String mLineSeparator = SdkUtils.getLineSeparator(); 
 byte[] alpha = new byte[width*height]; 
 responseHeaders.stripContentEncoding(); 
 responseHeaders.stripContentEncoding(); 
<|del|> 
 throw new UnsupportedOperationException(); 
 checkNotStarted(); 
 boolean hasUpper = SdkUtils.hasUpperCaseCharacter(name); 
 * Creates a list of detectors applicable to the given scope, and with the 
 return Collections.emptyList(); 
<|del|> 
<|del|>
<|del|> 
 StringBuilder normal = new StringBuilder(); 
<|del|> 
<|del|> 
<|del|> 
 final int initialCapacity = 116; 
 /** * Extension for library packages. */ public final static String EXT_LIB_ARCHIVE = "aar"; 
<|del|> 
 return NativeCrypto.EVP_PKEY_print_private(key.getPkeyContext()); 
public final class OpenSSLECPublicKey implements ECPublicKey { private static final long serialVersionUID = 3215842926808298020L; 
 return NativeCrypto.i2d_PUBKEY(key.getPkeyContext()); 
<|del|> 
 /** * Used to request EC_GROUP_new_curve_GFp to EC_GROUP_new_curve and other * functions that use "int type" below. */ 
final class OpenSSLECGroupContext { 
public final class OpenSSLECPrivateKey implements ECPrivateKey { 
<|del|> 
 * pick which available space to occupy, and we then subdivide the 
 * pick which available space to occupy, and we then subdivide the 
 (rect.h - height) < bestLongDistance) { 
 if (remainingHeight >= mMinHeight) { 
 public boolean intersects(@Nullable Rect other) { if (other == null) { return false; } 
 } // BEGIN android-added 
// END android-added 
 { // BEGIN android-added 
<|del|> 
 // There's no point in checking trust anchors here, and it will throw off the MD5 check, // so we just hand it the chain without anchors ChainStrengthAnalyzer.check(newChain); 
 final int initialCapacity = 116; 
 try { assertEquals(HARDCODED_ALIASES[i][1], AlgNameMapper.map2AlgName(HARDCODED_ALIASES[i][0])); 
 if (!canScaleNinePatch) { Density density = getDensity(d); if (density == Density.TV || density == Density.LOW) { continue; } 
 if (!canScaleNinePatch && d == Density.TV) { 
 private final ScreenSize mScreenSize; 
 private static final HashMap<Signature, String> sSigSeinfo = 
 private static final HashMap<String, String> sPackageSeinfo = 
 private static final HashMap<String, String> sPackageSeinfo = 
 IOException, XmlPullParserException { 
<|del|> 
 * @return An actual {@link IMenuBarEnhancer} implementation. Can be null on failure. 
 if (hasNestedTransaction()) { 
 mDummyDate.set(mDummyDate.get(Calendar.YEAR), mDummyDate.DECEMBER, 31, 13, 0, 0); 
 PolicyFileDescription(String path, int reqPolicy) { mPath = path; mReqPolicy = reqPolicy; 
 if (mGlVersion != null) { hash = 31 * hash + mGlVersion.hashCode(); 
 if (!isLeft && !isRight) { return; } Project project = context.getMainProject(); if (project.getTargetSdk() >= 14 && project.getBuildSdk() >= 14) { 
 try { // Use open(2) rather than stat(2) so we require fewer permissions. http://b/6485312. 
 int numlines = 0; Cursor c = null; 
 c = db.query("audio_playlists_map", 
 db.endTransaction(); IoUtils.closeQuietly(c); 
 db.endTransaction(); IoUtils.closeQuietly(c); 
 * System.out.println(df.format(new Date(0))); 
<|del|> 
 return Display.getDefault(); 
 * notifications when modifications to the {@link Device} list occur. * 
 diagonalLength.appendChild(doc.createTextNode( String.format(Locale.US, "%1$.2f", diag))); 
<|del|> 
 /** * Whether we flag variable, field, parameter and return type declarations of a type 
 null, null, mAid, response); 
 highOffset, lowOffset, length, null, null, mAid, response); 
 lc.recordSize, null, null, mAid, obtainMessage(EVENT_READ_IMG_DONE, IccConstants.EF_IMG, 0, response)); 
<|del|> 
 try { radioProxy.setPreferredVoicePrivacy(rr.mSerial, enable); } catch (RemoteException | RuntimeException e) { handleRadioProxyExceptionForRR(rr, "setPreferredVoicePrivacy", e); } } 
 throw new IllegalArgumentException("Value doesn't fit in an unsigned byte: " + value); 
 if (map.isEmpty()) { throw new IllegalArgumentException("map is empty"); 
 onDeleteComplete(token, info.cookie, (Integer) info.result); 
 args.result = 0; 
 args.result = 0; 
<|del|> 
 if (TelephonyManager.NETWORK_TYPE_UNKNOWN != mTelephonyManager.getNetworkType()) { 
 Pattern dataPattern = Pattern.compile("(\\d*\\.\\d+)\\s+(\\d*\\.\\d+)\\s+(\\d*\\.\\d+)"); 
 return Boolean.valueOf(prop); 
<|del|> 
 // Seek back past the oecd signature so that we can continue with our search. // Note that we add 4 bytes to the offset to skip past the signature. 
 if (mSpeedUpAudioForMtCall && (curAudioMode != AudioManager.MODE_IN_CALL)) { 
 if (audioManager.getMode() != newAudioMode || mSpeedUpAudioForMtCall) { 
 Rlog.d(LOG_TAG, "Speedup Audio Path enhancement: Context is null"); 
 return mItems.isEmpty(); 
 Node rootNode = document.getDocumentElement(); if (rootNode == null) { return Collections.emptyList(); } 
 // Display list whose index is >= mIndexFirstChangedBlock is valid // but it needs to update its drawing location. mIndexFirstChangedBlock = firstBlock + numAddedBlocks; for (int i = mIndexFirstChangedBlock; i < mNumberOfBlocks; i++) { 
 public int getIndexFirstChangedBlock() { return mIndexFirstChangedBlock; 
 /* * @hide */ public void setIndexFirstChangedBlock(int i) { mIndexFirstChangedBlock = i; } 
 private int mIndexFirstChangedBlock; 
 final boolean blockDisplayListIsInvalid = !blockDisplayList.isValid(); if (i >= indexFirstChangedBlock || blockDisplayListIsInvalid) { 
 // Rebuild display list if it is invalid if (blockDisplayListIsInvalid) { 
 ResourceFile(@NonNull File file, @NonNull List<Resource> items, @Nullable String qualifiers) { 
 folderName = folderName + SdkConstants.RES_QUALIFIER_SEP + qualifiers; 
 Node rootNode = document.createElement(SdkConstants.TAG_RESOURCES); 
 String content = XmlUtils.toXml(document, false /*preserveWhitespace*/); 
 if (ns.equals(attribute.getValue()) && ns.startsWith(SdkConstants.XMLNS_PREFIX)) { 
<|del|> 
 BufferedInputStream stream = new BufferedInputStream(new FileInputStream(mFile)); InputSource is = new InputSource(stream); 
 private final ActivityOptionsCompatJB mImpl; 
 if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Re-adding window at " 
<|del|> 
 if(titleCondensed != null) { EventLog.writeEvent(50000, 0, titleCondensed.toString()); 
 am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, 
 // Count separators int separatorCount = 0; 
 return firstPart.isEmpty() ? EmptyArray.STRING : new String[] { firstPart }; 
 private ViewHolder mViewHolder; 
 private ViewHolder mViewHolder; 
 private TextView mSlideNumberText; 
 private View mView; private TextView mTextView; private ImageView mImageView; 
 mView = view; 
 if (mVolume == null && pm.isStorageLow()) { 
<|del|> 
 int mMaxLength; 
<|del|> 
<|del|> 
 return Objects.equal(mName, that.mName); 
 assertTrue(type.isDebugJniBuild()); assertNotNull(type.getKeystore()); assertTrue(type.getKeystore().isSigningReady()); 
<|del|> 
<|del|> 
 * returned by methods such as {@code X500Principal.getName()}. 
 assertEquals(Arrays.toString(expected), 
 assertEquals(Arrays.toString(expected), 
 // BouncyCastle is broken 
 System.logW(warning); 
 public void enableTlsExtensions(SSLSocket socket, String uriHost) { if (socket instanceof OpenSSLSocketImpl) { 
 return socket instanceof OpenSSLSocketImpl ? ((OpenSSLSocketImpl) socket).getNpnSelectedProtocol() : null; 
 if (socket instanceof OpenSSLSocketImpl) { ((OpenSSLSocketImpl) socket).setNpnProtocols(npnProtocols); } 
 mLogger.error(null, "Process output to error stream but exitCode is " + exitCode); 
 private static File getWrittenResources() throws DuplicateResourceException, IOException, ExecutionException, InterruptedException { 
 + "res/layout/case.xml:18: Warning: Invalid tag <Merge>; should be <merge> [WrongCase]\n" 
<|del|> 
 return FullRevision.parseRevision(value); 
 // This is one of the modes we recognize modemNetworkMode = buttonNetworkMode; 
<|del|> 
 assertTrue(dsaEntry.hasExtensions()); /* TODO: get the OID */ 
 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); try { oos.writeObject(expected); } finally { oos.close(); } 
 public static final ASN1StringType BMPSTRING = new ASN1StringType(TAG_BMPSTRING) {}; 
 int parameterLen = dis.readByte(); 
 if (paramBits <= inStream.available()) { 
 + " had invalid SUBPARAM_LEN " + subparamLen); 
<|del|> 
 Log.e(TAG, e); 
 mHvDevice = device; 
 // BEGIN android-changed 
 * Enables/disables TLS Channel ID for this server socket. 
 public void setChannelIdPrivateKey(ECPrivateKey privateKey) { if (!getUseClientMode()) { throw new IllegalStateException("Server mode"); } 
 if ((data[data.length-2-i] & 0xFF) != padding_length) { 
 if ((data[data.length-2-i] & 0xFF) != padding_length) { 
 * Copyright (C) 2013 The Android Open Source Project 
 * Copyright (C) 2013 The Android Open Source Project 
 * Checks for typos in AndroidManifest files. 
 = "<%1$s> looks like a typo; did you mean <%2$s> ?"; 
 Category.CORRECTNESS, 
 Category.CORRECTNESS, 
 public OpenSSLKey getOpenSSLKey(); 
<|del|> 
 * A Source File processor for Renderscript files. This compiles each Renderscript file * found by the SourceSearcher. 
 if (failed && getActivity() != null && !getActivity().isFinishing()) { 
 private void pause(int state) { 
 /* In passive mode, the mean computed for the deltas should not be smaller 
 boolean available = !(intent.getBooleanExtra( PhoneConstants.NETWORK_UNAVAILABLE_KEY, false)); 
 return name.substring(name.indexOf(':') + 1); 
 @Override public PropertyType getType(Property p) { return PropertyType.INTEGER; } 
 return Ints.tryParse(p.value) != null; 
 StringBuilder sb = new StringBuilder(20); 
<|del|>
 * Execute a shell command. * * The default timeout is 5 secounds. 
 impl.reboot(into); 
 if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) { LogTag.debug("sendReadReport: uri = " + uri); } 
 rm.setRetryCount(2); assertTrue(rm.isRetryForever()); assertTrue(rm.isRetryNeeded()); 
 * Tests that use the public API of the {@link android.drm.DrmManagerClient} class to test the 
 assertTrue(mManager.canHandle(mPathToFLfile, null)); 
 mPathToFLfile = putOnPhoneAndConvert(R.raw.audio_mp3, 
 ContentValues localContent = mManager.getConstraints(mPathToFLfile, DrmStore.Action.PLAY); 
 mManager.getDrmObjectType(mPathToFLfile, null)); 
 private static DownloadManager sManager; 
 * Gets the DownloadCompleteReceiver instance associated with * this FLTestActivity instance. 
 private Hashtable<String, HashSet<String>> mFilesToRemove = new Hashtable<String, HashSet<String>>(); 
<|del|> 
 public final static String putOnPhone(int id, String filename, String foldername, Activity context) throws IOException, IllegalArgumentException { 
 throw new IOException("Failed creating the test file directory: " + foldername); 
 throw new IOException("Could not create the file " + filePath); 
 * Converts an oma drm message file to internal forward lock format. 
 // If you add more versions here, also update #getBuildCodes and // #HIGHEST_KNOWN_API 
 // If you add more versions here, also update #getAndroidName and // #HIGHEST_KNOWN_API 
<|del|> 
<|del|> 
 * Copyright (C) 2013 The Android Open Source Project 
 * @param drmClient A drm manager client. * @return string representing the name of the converted file or null in * case of error. 
 Log.e(DRM_TEST_TAG, "ERROR : could not open the .dm file" + e1.getMessage()); 
 Log.e(DRM_TEST_TAG, "ERROR : could not open the .fl file" + e2.getMessage()); 
 Log.e(DRM_TEST_TAG, "ERROR : could write to the .fl file" + e.getMessage()); 
 /* Handle the drm convert operation in a session. */ 
 * @param drmClient A drm manager client. 
 * @param inBuffer Buffer filled with data to convert. 
 * @param pluginName Name of drm plugin to check. * @param manager {@link DrmManagerClient} instance to look for the plugin * with. 
import java.nio.NioUtils; import libcore.util.MutableInt; import libcore.util.MutableLong; 
 * This method throws a runtime exception if exec() failed, otherwise, this * method never returns. 
 Map<Class<?>, Pair<PkgItem, FullRevision>> toolsCandidates = Maps.newHashMap(); 
 private final List<ArchiveReplacement> mInstalled = Lists.newArrayList(); 
 Provider[] providers = Security.getProviders("KeyFactory.DSA"); 
 private static final int MSG_HIDE = 0; private static final int MSG_SHOW = 1; private static final int MSG_SETNEXT = 2; private static final int MSG_CANCEL = 3; 
 mHandler.removeMessages(MSG_SHOW); mHandler.sendEmptyMessage(MSG_CANCEL); 
 getContentResolver().delete(scanUri, null, null); sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri)); 
 getContentResolver().delete(scanUri, null, null); sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri)); 
 Log.e("DeviceMonitor", "Connection error while monitoring clients."); 
 return getTool(SdkConstants.FN_AIDL); 
<|del|>
 public LogCatMessage(@NonNull LogLevel logLevel, @NonNull String pid, @NonNull String tid, @NonNull String appName, @NonNull String tag, @NonNull String time, @NonNull String msg) { 
 for (LogCatListener l: mListeners) { 
 while (parser.getEventType() != XmlPullParser.END_DOCUMENT) { 
<|del|> 
 * @param log the ILogger object receiving warning/error from the parsing. 
 * @param log the ILogger object receiving warning/error from the parsing. 
 */ @Nullable 
 "AAPT=$SDK/build-tools/3.0.0/aapt, " + "AIDL=$SDK/build-tools/3.0.0/aidl, " + "DX=$SDK/build-tools/3.0.0/dx, " + 
 * Copyright (C) 2013 The Android Open Source Project 
 return ((value<<24 & 0XFF000000) | (value<<8 & 0X00FF0000) | (value>>8 & 0X0000FF00) | (value>>24 & 0XFF)); 
 for (int i = 0; i < 4; i++){ array[index + i] = (byte) (value >> (i * 8)); 
 for (int i = 0; i < 8; i++){ array[index + i] = (byte) (value >> (i * 8)); 
 encode(BASIC_IVF, 
 decode(BASIC_IVF); 
 private void decode(String filename) throws Exception { IvfReader ivf = null; try { ivf = new IvfReader(filename); int frameWidth = ivf.getWidth(); int frameHeight = ivf.getHeight(); int frameCount = ivf.getFrameCount(); 
<|del|> 
 encoder.stop(); encoder.release(); } finally { if (ivf != null) { ivf.close(); } if (rawStream != null) { rawStream.close(); } } 
 for(int i = 0; i < mFrameCount; i++){ 
 return (((value << 24) & 0XFF000000) | ((value << 8) & 0X00FF0000) | ((value >> 8) & 0X0000FF00) | ((value >> 24) & 0X000000FF)); 
 MediaFormat format = MediaFormat.createVideoFormat(VP8_MIME, ivf.getWidth(), ivf.getHeight()); 
 (this == PROTOCOL_ERRORS) || (this == SIGNAL_LOST) || (this == RADIO_POWER_OFF) || (this == TETHERED_CALL_ACTIVE); 
 // 1. The channel distance should be far if the screen size is big. // 2. If the density is big, channel distance is adjusted for density 
 // 1. The channel distance should be far if the screen size is big. // 2. If the density is big, channel distance is adjusted for density 
 private static int sChannelDistance = 16; 
 private static int sChannelDistance = 16; 
<|del|> 
 * Will timeout if there is no ouput for 5 secounds. 
 * @param timeout maximum time to output response 
 "This arg is optional. It specifies the maximum amount of time during which the" + "command can go without any output. A value of 0 means the method" + "will wait forever. The unit of the timeout is millisecond"}, 
 "This arg is optional. It specifies the maximum amount of time during which the" + "command can go without any output. A value of 0 means the method" + "will wait forever. The unit of the timeout is millisecond"}, 
 "This arg is optional. It specifies the maximum amount of time during which the" + "command can go without any output. A value of 0 means the method" + "will wait forever. The unit of the timeout is millisecond"}, 
<|del|> 
 NetworkInfo mmsNetworkInfo = mConnMgr .getNetworkInfo(ConnectivityManager.TYPE_MOBILE_MMS); 
 NetworkInfo mmsNetworkInfo = mConnMgr .getNetworkInfo(ConnectivityManager.TYPE_MOBILE_MMS); 
 // Try to modify byte array. encodedCopy[0] ^= (byte) 0xFF; 
<|del|> 
<|del|> 
 final java.security.cert.Certificate cert = certs.get(i); 
 certificates = sortCertsIfNeeded(unsortedCerts); 
 switch (type) { case PKI_PATH: pkiPathEncoding = encodedPath; break; case PKCS7: pkcs7Encoding = encodedPath; break; default: throw new IllegalArgumentException("unknown encoding type: " + type); 
 if (certs.size() <= 1) { 
 private static List<X509Certificate> sortCertsIfNeeded(List<X509Certificate> certs) { 
 final Set<X500Principal> issuerPrincipals = new HashSet<X500Principal>(certs.size()); for (X509Certificate cert : certs) { issuerPrincipals.add(cert.getIssuerX500Principal()); } 
 final List<X509Certificate> endEntities = new ArrayList<X509Certificate>(); final Map<X500Principal, X509Certificate> issuers = new HashMap<X500Principal, X509Certificate>(); 
 for (X509Certificate cert : certs) { X500Principal currentPrincipal = cert.getSubjectX500Principal(); if (issuerPrincipals.contains(currentPrincipal)) { issuers.put(currentPrincipal, cert); } else { endEntities.add(cert); 
<|del|> 
 certs = Collections.emptyList(); 
 * decoding. 
 throw new CertificateException("Failed to decode CertPath", e); 
 return Collections.emptyList(); 
 return null; 
 final Map<X500Principal, X509Certificate> issuers = new HashMap<X500Principal, X509Certificate>(); 
 mOpenSslPrivateKey.getPkeyContext()); byte[] result; if (actualResultLength == -1) { throw new RuntimeException("Engine returned " + actualResultLength); } else if (actualResultLength == mExpectedResultLength) { 
 throw new InvalidAlgorithmParameterException("No algorithm parameters supported"); 
 Arrays.equals(parameterTypes, rhs.parameterTypes); 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
 NetworkInfo mmsNetworkInfo = null; 
<|del|> 
<|del|> 
<|del|> 
 * Clears the global count of objects allocated. * @see #getGlobalAllocCount() 
<|del|> 
 * Clears the global size of objects allocated. * @see #getGlobalAllocCountSize() 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
import com.android.internal.telephony.dataconnection.DataProfile; import com.android.internal.telephony.dataconnection.DcFailCause; 
 rr.mResult = result; rr.mParcel = Parcel.obtain(); 
 /* == KeyAgreement == */ 
 repositories.add(new File(mPlatformRootFolder + "/prebuilts/sdk/m2repository")); 
<|del|> 
 XmlUtils.nextElement(parser); 
<|del|> 
<|del|> 
 buildStatusPanel(); checkImage(); 
 return config.keyboard == Configuration.KEYBOARD_NOKEYS 
<|del|> 
 * resource qualifier. 0 if undefined. Note that the actual MNC may be 0; in order to check * for this use the {@link #MNC_ZERO} symbol. 
 public static final int MNC_ZERO = 0xffff; 
<|del|> 
<|del|> 
 public boolean hasNinePatchExtension() { return hasNinePatchExtension; 
 if (!isTransparentPixel(pixel)) { 
 boolean hasNinePatchExtension = mFileName.endsWith(NinePatchedImage.NINE_PATCH_EXTENSION); 
 "The file \"%s\" doesn't seem to be a 9-patch file. \n" + "Do you want to convert and save as \"%s\" ?", mFileName, patchedName)); 
 if (hasNinePatchExtension || doConvert) { ImageLoader loader = new ImageLoader(); loader.data = new ImageData[] { mNinePatchedImage.getRawImageData() }; 
<|del|> 
<|del|> 
 char c = imsiDB.charAt(idx); if ((c == 'x') || (c == 'X') || (c == imsiSIM.charAt(idx))) { 
 if ((r.getServiceProviderName() != null) && r.getServiceProviderName().equalsIgnoreCase(mvno_match_data)) { return true; } 
 if (mvnoMatches(r, cursorMvnoType, cursorMvnoMatchData)) { 
 if (parser.getName() == null) { continue; } else { throw new XmlPullParserException("Expected 'apn' tag", parser, null); } 
 } else if (y2 != y1) { 
 /** Write to another stream and track how many bytes have been * written. */ private static class CountOutputStream extends FilterOutputStream { 
 public void write(int b) throws IOException { super.write(b); 
 throws IOException, CertificateEncodingException, OperatorCreationException, CMSException { 
 ContentSigner sha1Signer = new JcaContentSignerBuilder( "SHA1with" + privateKey.getAlgorithm()) .build(privateKey); 
 && (mWindowManagerService.isHardKeyboardAvailable() || (vis & (InputMethodService.IME_VISIBLE)) != 0); 
 && (mWindowManagerService.isHardKeyboardAvailable() 
 private void addExtraListener(JUnitCore testRunner, PrintStream writer, String extraListener) { if (extraListener == null || extraListener.length() == 0) { return; 
 ATTR_PATH, idList); 
 private boolean mHasNinePatchExtension = false; 
 private static final boolean isAsTransparentPixel(int pixel) { /* * Some paint softwares draw transparent color as #00000000. */ return (pixel == ALPHA) || (pixel == ALPHA_WHITE); 
 private int[] mHorizontalPatchPixels = null; private int[] mVerticalPatchPixels = null; 
 private int[] mHorizontalPatchPixels = null; private int[] mVerticalPatchPixels = null; 
 // find patches 
 assertFalse(image.hasNinePatchExtension()); 
<|del|> 
<|del|> 
<|del|> 
 if ((imsiSIM != null) && imsiMatches(mvno_match_data, imsiSIM)) { 
 String gid1 = r.getGid1(); if ((gid1 != null) && gid1.substring(0, 
 if (parser.getEventType() != XmlPullParser.END_DOCUMENT) { ContentValues row = getRow(parser); if (row == null) { 
 private boolean mDirtyFlag = false; 
 private static final String CHECKER_PNG_PATH = "/icons/checker.png"; 
 /** * Similar to a {@code readLine} method, but matches what OpenSSL expects * from a {@code BIO_gets} method. */ public int gets(byte[] buffer) throws IOException { 
 * Note that the object is not fully usable as-is. It must be added to an AssetFile first. 
 static AssetItem create(@NonNull File sourceFolder, @NonNull File file) { 
 item.getKey().replace('/', File.separatorChar)); 
 public void checkValidity() throws CertificateExpiredException, CertificateNotYetValidException { 
 Rlog.d(TAG, "SmsResponse was null"); 
 Rlog.d(TAG, "SmsResponse was null"); 
 Rlog.d(TAG, "sendSms: " + " mRetryCount=" + tracker.mRetryCount + " mMessageRef=" + tracker.mMessageRef + " SS=" + mPhone.getServiceState().getState()); 
 public static OpenSSLX509Certificate fromX509Der(byte[] encoded) { final long certCtx = NativeCrypto.d2i_X509(encoded); 
 "Checks for filename clashes between .png files and nine patch (.9.png) files", 
 try { radioProxy.getDeviceIdentity(rr.mSerial); } catch (RemoteException | RuntimeException e) { handleRadioProxyExceptionForRR(rr, "getDeviceIdentity", e); } } 
 EclipseXmlPrettyPrinter printer = new EclipseXmlPrettyPrinter(prefs, style, lineSeparator); 
 public boolean wpsPbcSupport = false; 
<|del|> 
 // We hit this scenario when a persistent group is reinvoked 
 * http://www.apache.org/licenses/LICENSE-2.0 
<|del|> 
 public static final int TRANSPARENT_TICK = 0x00000000; 
 return (x == 0) ^ (y == 0) ^ (x == mBaseImageData.width - 1) ^ (y == mBaseImageData.height - 1); 
<|del|> 
 * This is for unit test use only. * @see com.android.ide.eclipse.adt.internal.editors.draw9patch.graphics.NinePatchedImageTest 
 * This is for unit test use only. * @see com.android.ide.eclipse.adt.internal.editors.draw9patch.graphics.NinePatchedImageTest 
 if (!"DSA".equals(key.getAlgorithm())) { throw new InvalidKeySpecException("Key must be a DSA key"); } 
 throw new InvalidKeySpecException("Unsupported key type and key spec combination; key=" 
 } else if (key instanceof ECPrivateKey && ECPrivateKeySpec.class.isAssignableFrom(keySpec)) { 
 } catch (Throwable e) { 
 } catch (Throwable e) { 
 private int getZoomedPixelSize(int val) { 
 public void paintControl(PaintEvent pe) { 
 public interface StatusChangedListener { 
<|del|> 
 boolean processFile(@NonNull File dependencyFile); 
 public AndroidDependencyImpl(@NonNull File explodedBundle, @NonNull List<AndroidDependency> dependencies, @NonNull File bundle, @Nullable String name) { 
<|del|> 
 * <pre> * if (Log.isLoggable("MyActivity", Log.DEBUG)) { * Log.d("MyActivity", "Log message"); * } * </pre></p> 
 .query(TABLE_NAME, new String[]{Alarm.Columns._ID}, Alarm.Columns._ID + " = ?", 
 byte[] buf = new byte[sendBufferSize]; 
 mMinuteSpinnerInput.setImeOptions(EditorInfo.IME_ACTION_DONE); 
 this.clientAuth = clientAuth; this.leaf = leaf; 
 return true; 
 if (ekuOids != null) { for (String ekuOid : ekuOids) { // anyExtendedKeyUsage for clients and servers if (ekuOid.equals(EKU_anyExtendedKeyUsage)) { goodExtendedKeyUsage = true; break; } 
 */ @Nullable 
 } if (DEBUG) { System.out.println("<<<"); } 
 * The {@code MANIFEST_VERSION} or {@code SIGNATURE_VERSION} attribute must be set before * calling this method, or no attributes will be written. 
 String seinfo = null; 
<|del|> 
<|del|>
<|del|> 
 public static final byte[] toByteArray(MessageNano msg) { final byte[] result = new byte[msg.getSerializedSize()]; toByteArray(msg, result, 0, result.length); 
 throws CertPathValidatorException { // We only want to validate the EKU on the leaf certificate. 
 * 
 * .setSubject(new X500Principal("CN=myKey")) 
 OutOfSpaceException(int position, int limit) { 
 return ((OpenSSLKeyHolder) KeyFactory.getInstance( "EC", OpenSSLProvider.PROVIDER_NAME).translateKey(key)).getOpenSSLKey(); 
 public final byte[] toByteArray() { final byte[] result = new byte[getSerializedSize()]; toByteArray(result, 0, result.length); 
 @Override public void update(CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException { 
<|del|> 
 MockResponse failFastResponse = failFast ? new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND) : null; setFailFast(failFastResponse); 
 if (inputDev.supportsSource(inputSource)) { 
 builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT)); 
 builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT)); 
 sslSession = (OpenSSLSessionImpl) sessionContext.getSession(sessionId); if (sslSession != null) { 
 if (Character.isDigit(displayedValues[0].charAt(0))) { 
 if (Character.isDigit(displayedValues[0].charAt(0))) { 
 b = new BigInteger(bits, 10, rnd); 
 return true; } 
 * After a load from the blob file, all items have their state set to nothing. 
 * * This will allow the first use of {@link #mergeData(MergeConsumer, boolean)} to add these * to the consumer as if they were new items. * * @see #loadFromBlob(java.io.File, boolean) 
 public void removeItem(@NonNull AssetItem removedItem, @Nullable AssetItem replacedBy) 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 return (system ? ANDROID_NEW_ID_PREFIX : NEW_ID_PREFIX) + "/" + getName(); 
 private final boolean mFramework; 
 public ResourceRepository(boolean isFramework) { mFramework = isFramework; 
 synchronized (mItems) { return Lists.newArrayList(mItems.keySet()); } 
 * SAX handler to parse value resource files. 
 Iterator<String> iterator = Iterators.forArray(folderSegments); 
 final int initialCapacity = 151; 
 Category.ICONS, 
 return value; 
 private void createTextFile(File dir, String filepath, String...lines) throws IOException { File file = new File(dir, filepath); 
 acceptedLids.add(lid); 
<|del|> 
 * direct accessor). This will also set layout direction according to the locale. 
 if (mWifiNative.p2pGroupRemove(mGroup.getInterface())) { transitionTo(mOngoingGroupRemovalState); 
 "Used by: \n - %3$s\n" + "-------------------------------\n" + 
 if (projectName.equalsIgnoreCase(existingProj.getName())) { 
 if (oid == AttributeTypeAndValue.EMAILADDRESS || oid == AttributeTypeAndValue.DC) { // http://www.rfc-editor.org/rfc/rfc5280.txt // says that EmailAddress and DomainComponent should be a IA5String 
 public void hangupWaitingOrBackground (Message result) { RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, result); 
 "A given feature should only be declared once in the manifest.", 
 IMPLEMENTATION).addMoreInfo( "http://developer.android.com/tools/publishing/preparing.html#publishing-configure"); //$NON-NLS-1$ 
 // want to consider adding a specialized image in the -ldrtl folder as well 
 if (cursor != null) { 
 if (cursor != null) { 
 P2pStateMachine.this, mGroup.getInterface()); // TODO: We should use DHCP state machine PRE message like WifiStateMachine mWifiNative.setP2pPowerSave(mGroup.getInterface(), false); 
 private final long address; 
 private final long address; 
 switch (bundle.getType()) { case LINK_LIBRARY: linkProjectAndLibrary((LinkLibraryBundle)bundle, monitor); break; case UNLINK_LIBRARY: unlinkLibrary((UnlinkLibraryBundle) bundle, monitor); break; } 
 switch (bundle.getType()) { case LINK_LIBRARY: linkProjectAndLibrary((LinkLibraryBundle)bundle, monitor); break; case UNLINK_LIBRARY: unlinkLibrary((UnlinkLibraryBundle) bundle, monitor); break; } 
 public void test_Constructor() throws Exception { 
 // Log the problem and return false so we try the next choice. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
public class SSLEngineAppData implements Appendable { 
<|del|> 
<|del|> 
 private Appendable appData; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (cursor.moveToFirst()) { 
<|del|> 
 script_f32.forEach_root(mIn, mOut); 
 //TODO: handle exception 
 handleNetworkConnectionFailure(stateChangeResult.networkId, WifiConfiguration.DISABLED_ASSOCIATION_REJECT); 
 lastWasCR = (ch == '\r'); 
 lastWasCR = (ch == '\r'); 
 case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME; 
 mFields.put(OPP_KEY_CACHING, "1"); 
 /** * Resource ID of the image to be used as a placeholder until the network image is loaded. */ 
<|del|> 
<|del|> 
<|del|> 
 private int mBatchResponseDelayMs = 100; 
 * 2. After a network response returns, only one of the following cases will happen: 
 ImageContainer imageContainer = 
 private void onGetImageSuccess(String cacheKey, Bitmap response) { 
 private void onGetImageError(String cacheKey, VolleyError error) { 
 * Container object for all of the data surrounding an image request. 
 private class BatchedImageRequest { 
 /** List of all of the active ImageContainers that are interested in the request */ 
 public void setBatchedResponseDelay(int newBatchedResponseDelayMs) { 
 private final LinkedList<ImageContainer> mContainers = new LinkedList<ImageContainer>(); 
 throw new IllegalStateException("ImageLoader must be invoked from the main thread."); 
 add32ByteBlocksNative(); 
 "-n \"" + activityPath + "\" " + 
 return ContainerUtil.getFirstItem(variants.values()); 
 private static void setupSystemProperties() { // If defined, AS_UPDATE_URL should point to the *root* of the updates.xml file to use // and patches are expected to be in the same folder. 
 System.setProperty("idea.patches.url", updateUrl); 
<|del|> 
 private static final int MSG_SET_NEXT = 2; 
 batteryTemperature = (short)((batteryLevelInt<<7)>>21); 
 openSslSocketClass = Class.forName( "org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl"); 
<|del|> 
 destinations[1] = formatLtr( 
<|del|> 
 * Listens for Gradle project import start/end events and updates the "Build Variant" tool window when necessary. 
 private static GradleImportNotificationListener ourInstance; 
 return ourInstance != null && ourInstance.myProjectImportInProgress; 
 void setLoading(boolean loading) { myLoading = loading; setPaintBusy(myLoading); 
 if (project != null && Projects.isGradleProject(project)) { GradleImportNotificationListener.attachToManager(); } 
 private static void print(String identifier, Class<?> clazz, Object message, String indentLevel, 
 String fieldName = field.getName(); if ((modifiers & Modifier.PUBLIC) != Modifier.PUBLIC || (modifiers & Modifier.STATIC) == Modifier.STATIC || fieldName.startsWith("_") || fieldName.endsWith("_")) { 
 private static void print(String identifier, Class<?> clazz, Object message, int indentSize, 
 // 
 // BEGIN android-removed // "X509", "IES" // END android-removed // BEGIN android-added "X509" // END android-added 
 image = ImageIO.read(new File(path)); 
 if (indentBuf.length() >= INDENT.length()) { indentBuf.delete(indentBuf.length() - INDENT.length(), indentBuf.length()); 
 protected ApnSetting fetchDunApn() { 
 if (VDBG) log("fetchDunApn: global TETHER_DUN_APN dunSetting=" + dunSetting); return dunSetting; 
 @Override protected boolean mvnoMatches(IccRecords r, String mvno_type, String mvno_match_data) { 
 dunSetting = fetchDunApn(); 
<|del|> 
 for (IMarker marker : markers) { 
 for (IJavaProject javaProject : selectedProjects) { GradleModule module; 
<|del|> 
 // create project folder if it does not exist File projectFolder = checkNewProjectLocation(folderPath); if (projectFolder == null) { 
 if (!extendsClass(cl, superclassName())) { 
 Logger.getInstance(Jdks.class).error(msg); 
<|del|> 
 String path = gradleHomeDir.getAbsolutePath(); String msg = String.format("Unable to obtain Gradle home directory: the path '%1$s' is not a directory", path); 
 @NonNls private static final String JVM_ARG_FORMAT = "-D%1$s=%2$s"; @NonNls private static final String JVM_ARG_WITH_QUOTED_VALUE_FORMAT = "-D%1$s=\"%2$s\""; 
 String format = JVM_ARG_FORMAT; if (value.contains(" ")) { format = JVM_ARG_WITH_QUOTED_VALUE_FORMAT; } return String.format(format, name, value); 
 * Enable the log property for your tag before starting your app: 
 "Use gradle template.", false); 
 "Gradle Android plugin version.", null); 
 private String mySdkPath; private String myPreV22SdkPath; 
 Collection<Constraint> violations = validateStringType(project, module, packageName, value); 
 return getErrorMessageForStringType(project, module, packageName, value.toString()); 
 return properties.getProperty(LocalProperties.SDK_DIR_PROPERTY); 
 * Functionality to help load in templates for AppEngine endpoints module 
 if(mPhone != null) { 
 case EVENT_SERVICE_STATE_CHANGED: // waiting for a special state 
 case EVENT_RIL_API_CALLED: // waiting for a RIL API to be called 
 default: // waiting for the message only 
 * Wait until the handler receives the specific message. 
 * Wait until the handler receives the specific message with specific status. 
 // don't care about the order 
 CdmaCallInfo(boolean isMT, State state, boolean isMpty, String number) { 
 * Creates and holds {@link HandlerThread} on which simulated Telephony FW runs. 
 RILRequest rr = null; 
 return fileValidity; 
 if (fd.folderType != null && fd.folderType != ResourceFolderType.VALUES) { 
 assertEquals(first.key, second.key); 
 private static final int CACHE_MAGIC = 0x20140903; 
 Notification.Builder mBuilder = new Notification.Builder(mContext) 
 private final Project myProject; private RtlSupportManager myRtlManager; 
 mMockDevice.executeShellCommand(EasyMock.eq(expectedCmd), (IShellOutputReceiver) EasyMock.anyObject(), EasyMock.eq(0L), EasyMock.eq(TimeUnit.MILLISECONDS)); 
 throw new IllegalArgumentException(); 
<|del|> 
<|del|> 
 EasyMock.anyObject(), EasyMock.eq(0L), EasyMock.eq(TimeUnit.MILLISECONDS)); 
<|del|> 
<|del|> 
 this.mAlpnProtocols = toLengthPrefixedList(protocols); 
 private Object[] appendBookmarksIfFolder(String selection, String[] selectionArgs) { 
 mProjectRootWarning.setText("WARNING: build.gradle already exists at this location."); 
 sb.append("Export successful.\n\n"); 
 "Different modules have been detected on different drives.\n" + 
<|del|> 
 if (cursor.moveToFirst()) { 
 public static boolean isAndroidProjectWithoutGradleFacet(@NotNull JpsProject project) { return isAndroidProjectWithoutGradleFacet(project.getModules()); 
<|del|> 
 } else if ((res = readThisPrimitiveValueXml(parser, tagName)) != null) { // all work already done by readThisPrimitiveValueXml 
 // List of module facets the given module depends on List<AndroidFacet> facets = AndroidUtils.getAllAndroidDependencies(facet.getModule(), true); 
<|del|> 
<|del|> 
<|del|> 
 li.mOnClickListener.onClick(this); return true; 
 * @param bundleFolder the folder containing the unarchived library content 
<|del|> 
 private static File createTemporaryZipFile() throws IOException { 
 private static ZipOutputStream createZipOutputStream(File f) throws IOException { 
 private static String makeString(int count, String s) { 
 IdManager idManager = IdManager.get(this); if (idManager != null) { idManager.removeComponent(this, true); 
 private static final Pattern ourSourcePropPattern = Pattern.compile("^" + PkgProps.PKG_REVISION + "=(.*)$"); 
<|del|> 
<|del|> 
<|del|> 
 mySdkPath = System.getProperty(AndroidTestCase.SDK_PATH_PROPERTY); 
 AndroidSdkUtils.versionChecker = new NoVersionCheck(); 
 else if (dependency instanceof IdeaSingleEntryLibraryDependency) { 
 FullRevision modelRevision = FullRevision.parseRevision(modelVersion); return modelRevision.compareTo(MINIMUM_SUPPORTED_VERSION) >= 0; 
 sendTerminalResponse(cmdParams.cmdDet, ResultCode.OK, false, 0, null); 
 boolean noAlphaUsrCnf = false; Resources resource = Resources.getSystem(); try { noAlphaUsrCnf = resource.getBoolean( com.android.internal.R.bool.config_stk_noAlphaUsrCnf); } catch (NotFoundException e) { noAlphaUsrCnf = false; } 
 ((CheckBox)mView.findViewById(R.id.wifi_advanced_togglebox)) .setOnCheckedChangeListener(this); 
 ((CheckBox)mView.findViewById(R.id.wifi_advanced_togglebox)) .setOnCheckedChangeListener(this); 
 e.getPresentation().setEnabled(MavenUtils.isMavenProjectWithAppEnginePlugin(project, module)); 
<|del|> 
 VirtualFile mavenRoot = appEngineModuleRootDir .createChildDirectory(null, EndpointsConstants.APP_ENGINE_SRC_DIR) .createChildDirectory(null, EndpointsConstants.APP_ENGINE_MAIN_DIR); VirtualFile javaRoot = mavenRoot.createChildDirectory(null, EndpointsConstants.APP_ENGINE_JAVA_DIR); 
 PsiClass apiAnnotationClass = JavaPsiFacade.getInstance(myProject). findClass(ANNOTATION_API_FQN, new ModuleWithDependenciesScope(myAppEngineModule, ModuleWithDependenciesScope.COMPILE | ModuleWithDependenciesScope.LIBRARIES)); 
 public static Map<String, Object> buildReplacementMap(Project p, MavenProject appEngineMavenProject, File androidLibRootDir, String androidRootPackage, String gcmProjectNumber, Template loadedTemplate) { 
 if (cls.getModifierList().hasExplicitModifier(PsiModifier.PUBLIC)) { 
 private RtlRefactoringType myType = RtlRefactoringType.UNDEFINED; 
 MANIFEST_SUPPORTS_RTL, MANIFEST_TARGET_SDK, LAYOUT_FILE_ATTRIBUTE, STYLE 
 MANIFEST_SUPPORTS_RTL, MANIFEST_TARGET_SDK, LAYOUT_FILE_ATTRIBUTE, STYLE 
<|del|> 
 private static Map<String, String> ourMapMirroredAttributeName = Maps.newHashMapWithExpectedSize(12); 
 final List<UsageInfo> list = new ArrayList<UsageInfo>(); 
 final StringBuilder sb = new StringBuilder(str.length() + 2 * quote.length()).append(quote); 
 assert layoutV17Dir.isDirectory() : layoutV17Dir; 
 final List<PsiFile> files = facet.getLocalResourceManager().findResourceFiles(ResourceFolderType.LAYOUT.getName()); 
 return Collections.emptyList(); 
 LOG.warn("Called getProcessedElementsHeader()"); return "getProcessedElementsHeader()"; 
 myType = type; 
 return new VersionCheckResult(toolsRevision, toolsRevision.compareTo(MIN_TOOLS_REV, FullRevision.PreviewComparison.IGNORE) >= 0); 
<|del|>
 int xmx = executionSettings.getGradleDaemonMaxMemoryInMb(); if (xmx > 0) { jvmArgs.add(String.format((Locale)null, "-Xmx%dm", xmx)); } 
 if (mAccountsUpdatedListeners.containsKey(listener)) { listener.onAccountsUpdated(accountsCopy); } 
<|del|> 
 if (value != null && (value.contains(GRAVITY_VALUE_LEFT) || value.contains(GRAVITY_VALUE_RIGHT))) { 
 messagesByCategory.put(category, message.getText()); 
 Joiner.on("<br>").join(messages); 
 if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0 && 
 uniqueId = info.getUniqueId(); eventType = info.getType(); message = info.getMessage(); 
<|del|> 
<|del|> 
<|del|> 
 /* Worst case is 2 * actual refresh rate, in case when the delay pushes the frame off * VSYNC every frame. */ 
 /* Need to give time based on (frame duration limited by refresh rate + delay given * from the test) */ 
 success = mSemaphore.tryAcquire(addMargin(oneframeMs * mFrames), TimeUnit.MILLISECONDS); 
 success = mSemaphore.tryAcquire(addMargin(oneframeMs * mFrames), TimeUnit.MILLISECONDS); 
 success = mSemaphore.tryAcquire(addMargin(oneframeMs * mFrames), TimeUnit.MILLISECONDS); 
 * Copyright (C) 2013 The Android Open Source Project 
 return key.canParseValue(getArguments(method)); 
 return key.canParseValue(getArguments(method)); 
 protected static final GroovyPsiElement[] EMPTY_ELEMENT_ARRAY = new GroovyPsiElement[0]; protected static final Iterable<GrLiteral> EMPTY_LITERAL_ITERABLE = Arrays.asList(new GrLiteral[0]); 
 protected static @Nullable GrMethodCall getMethodCallByPath(@NotNull GrStatementOwner root, @NotNull String path) { 
 return argList.getAllArguments(); 
 return (gmc.getInvokedExpression() != null && gmc.getInvokedExpression().getText() != null) ? gmc.getInvokedExpression().getText() : ""; 
 GrArgumentList argumentList = gmc.getArgumentList(); if (argumentList == null) { return EMPTY_LITERAL_ITERABLE; } return getLiteralArguments(argumentList); 
 if (myGroovyFile == null) { 
 myString.append(element.getText()); 
<|del|> 
 removeModule(getModulePath(module)); 
 mProguardRules = proguardRules; return this; 
 private static final BasicLruCache<Class, Type[]> genericInterfaces = new BasicLruCache<Class, Type[]>(50); 
<|del|> 
 } if (sci == null) return; 
 m.mHeaders.put(Uri.decode(nameval[0]).toLowerCase(Locale.ROOT), 
 * Get the full screen size directly (including system bar) to calculate 
 } mySettingsFile.addModule(newPath); 
<|del|> 
 remove(module); AndroidGradleFacet androidGradleFacet = Facets.getFirstFacetOfType(module, AndroidGradleFacet.TYPE_ID); 
 remove(module); AndroidGradleFacet androidGradleFacet = Facets.getFirstFacetOfType(module, AndroidGradleFacet.TYPE_ID); 
 msg += String.format("\n\nCurrent user (%1$s) does not have write access to the SDK directory.", SystemProperties.getUserName()); 
 private Call(@NonNull Builder builder, @NonNull Stack<Long> backStack) { 
 @NonNull public Call build(@NonNull Stack<Long> backStack) { 
 private void computePerMethodStats(@NonNull Call top, @NonNull VmTraceData data) { 
<|del|> 
 * Common constants for use by the Cloud Tools plugin 
 if (apiFiles.isEmpty()) { 
 if (baseDir.charAt(baseDir.length() - 1) == File.separatorChar) { 
 File baseDirFile = new File(genDir, baseDir); 
 goalsToRun.add(MAVEN_COMPILE); goalsToRun.add(MAVEN_APP_ENGINE_GET_DISC_DOC); 
<|del|> 
<|del|> 
 // If the library already exists, there is no reason to created it again. 
 ", available = " + available + ", state = " + state); 
 TestSSLContext testSSLContext = createAndRegisterDefaultTestSSLContext(); 
 protected Connection connection; 
 // This behavior is a bit odd (but is probably justified by the 
<|del|> 
 @Override public final void setSelectedProxy(Proxy proxy) { this.selectedProxy = proxy; 
 void setSelectedProxy(Proxy proxy); 
 result.add(new Challenge(scheme, realm)); 
<|del|> 
 myValue = String.format("<a href=\"%1$s\">%2$s</a>", StringUtil.escapeXml(url), text); 
 myValue = String.format("<a href=\"%1$s\">%2$s</a>", StringUtil.escapeXml(url), text); 
 Navigatable openFile = new OpenFileDescriptor(myProject, file, myLine, -1, false); 
 public static String makeHumanReadable(long time, long span, TimeUnit timeUnits) { 
 "You will lose custom project-wide settings. Are you sure you want to continue?"; 
 private static final String TITLE = "Close, Clean and Re-Import Project"; 
 @NonNull private final StringBuilder mStringBuilder; private String mTableDataExtra; 
 mStringBuilder = stringBuilder; 
 * Creates a new image request, decoding to a desired specified width and 
 setRetryPolicy( new DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES, IMAGE_BACKOFF_MULT)); 
 mPhone.notifyDataConnection(null); 
 if (!Projects.isGradleProject(project) || Boolean.getBoolean(SHOW_ALL_CONFIGURABLES)) { 
<|del|> 
 mNewSS.setRoaming(mDataRoaming || (mGsmRoaming && !(isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS)))); 
 private boolean isSameNamedOperators(ServiceState s) { 
 * + Can use mcc or mcc+mnc as item of config_operatorConsideredNonRoaming. * For example, 302 or 21407. If mcc or mcc+mnc match with operator, * don't set roaming state. * 
 if (numericArray.length == 0 || operatorNumeric == null) 
 }; AndroidContentRoot.storePaths(androidProject, storage); moduleInfo.createChild(ProjectKeys.CONTENT_ROOT, contentRootData); 
 for (AndroidLibrary library : libraries) { 
 if (!FileUtilRt.createDirectory(projectRoot)) { 
 && !allLinesTaken 
 } pw.decreaseIndent(); 
<|del|> 
<|del|> 
 mStackedLinks.clear(); mMtu = 1500; 
 return "{" + ifaceName + linkAddresses + routes + dns + domainName + mtu 
 return "{" + ifaceName + linkAddresses + routes + dns + domainName + mMtu + proxy + stacked + "}"; 
<|del|> 
 if (processException(response, (AsyncResult) msg.obj)) { 
 Joiner.on('\n').join(messages); 
 String text = StringUtil.escapeXml(message.getText()); builder.append("- ").append(text); 
<|del|> 
<|del|> 
 return myText; 
<|del|> 
 return vmOptions; 
 return mergeReport.getMergedDocument().get(); 
<|del|>
 if (value instanceof String) { 
 if(mavenHome == null) { 
 baseDir = entries.nextElement().getName(); // get the name of the top-evel directory at the root of the zip (ex: deviceinfoendpoint) 
 public void backendCreated(@NotNull Module androidLibModule, @NotNull Module appEngineModule) { 
 "mode and try again", MESSAGE_TITLE); return false; 
 "Warning", "Continue", "Cancel", Messages.getWarningIcon()); 
<|del|> 
 /** There are no guarantees on what thread this will return */ void moduleCreated(Module appEngineModule); /** There are no guarantees on what thread this will return */ void onFailure(String errorMessage); 
 /** There are no guarantees on what thread this will return */ void moduleCreated(Module appEngineModule); /** There are no guarantees on what thread this will return */ void onFailure(String errorMessage); 
 // TODO: this should be converted to import/check for play services at some point 
 return DEFAULT_IMPORT_PATH; 
 LOG.error("Template generation error", nfe); 
<|del|> 
 /** There are no guarantees on what thread this will return */ void moduleCreated(Module androidLibModule); /** There are no guarantees on what thread this will return */ void onFailure(String errorMessage); 
 /** There are no guarantees on what thread this will return */ void moduleCreated(Module androidLibModule); /** There are no guarantees on what thread this will return */ void onFailure(String errorMessage); 
 /** Generate a Maven App Engine module as a backend for the Cloud Backend Sample */ 
 callback.moduleCreated(myModule); 
<|del|> 
 return null; // to Void 
 /** * Expand out a generated client library into the App Engine module, * This needs to be run on the dispatch thread */ 
 File targetGenSourcesDir = new File(myMavenProject.getBuildDirectory(), GctConstants.API_CLIENT_GENERATED_SOURCES); 
 // We expand the generated sources in "google_generated" in the main project, other can pick it up from here 
 // We expand the generated sources in "google_generated" in the main project, other can pick it up from here 
 // no available dependencies // TODO: make sure we account for this when changing how we deal with java client lib dependencies 
 // Now that we have all of the necessary information, we can go ahead and mutate the Android module 
 /** Set during startHandshake. */ 
 /** Set during startHandshake. */ 
 if (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) { Log.v(TAG, "mId=" + mId); } 
 int yOffset, ClockType renderClock, TimeUnit defaultTimeUnits) { 
 /** * The time unit to use for all operations. Changing this changes the minimum resolution * that can be viewed on the canvas. */ private static final TimeUnit DEFAULT_TIME_UNITS = TimeUnit.NANOSECONDS; 
 return String.format(Locale.US, "%d.%d.%s", myMajorRevision, myMinorRevision, micro); 
 * * <p>This default implementation reads bytes into a temporary buffer. Concrete 
<|del|> 
 * Copyright (C) 2013 The Android Open Source Project 
 AndroidAddStringResourceAction.doInvoke(myFixture.getProject(), myFixture.getEditor(), editedPsiFile, "hello", DIMEN); 
 pattern = pattern.toLowerCase(Locale.US); 
 // Currently there are 9 devices for which we have device art, plus 2 generic/stretchable assertEquals(17, specs.size()); 
 * such as &amp; and &lt;; those are expected to be escaped by the caller (typically 
/** NOTE: Most of the tests for MergedResourceWriterTest are in {@link ResourceMergerTest} */ 
 String urlString = createPathComment(new File(path)).substring(5); // 5: "From:".length() 
<|del|> 
<|del|> 
 * Utility method to parse the {@link PkgProps#PKG_REVISION} property as a no-preview * revision (major.minor.micro integers but no preview part.) 
<|del|> 
 } pkg = createPackage(); setPackage(pkg); 
 assert existing.size() <= 1; 
 List<LocalPkgInfo> list = Lists.newArrayList(); 
 scanBuildTools(subDir, existing); 
 // Just in case, sort them again. 
<|del|> 
 * (SHA256withRSA or SHA1withRSA). Also in JB-MR2, EC keys are supported. 
 * Returns the current IFileOp being used. 
 // Whether we have found a valid pkg or not, this directory has been visited. mVisitedDirs.put(filter, new DirInfo(uniqueDir)); 
 List<LocalPkgInfo> list = Lists.newArrayList(); 
 if (hash != null) { boolean isPlatform = AndroidTargetHash.isPlatform(hash); LocalPkgInfo[] pkgs = getPkgsInfos(isPlatform ? PKG_PLATFORMS : PKG_ADDONS); 
 INCLUSIVE_TIME("Inclusive Time (\u00b5s)", "123,456,789,012"), // \u00b5 = unicode for micro (as in microseconds) 
 private static final char FIGURE_SPACE_CHAR = '\u2007'; // \u2007 = figure space, space the width of a digit 
 StringUtil.repeatSymbol(sb, ' ', (int)(nSpaces * mySpacesPerFigureSpaceChar) + 1); 
 @NotNull NotificationHyperlink... hyperlinks) { 
 File projectDirPath = new File(toSystemDependentName(projectDir.getPath())); 
 if (platformSource.isDirectory()) { 
 return sortAscending ? diff : -diff; 
 public static Sdk chooseOrCreateJavaSdk(@NotNull JavaSdkVersion... jdkVersions) { 
 LocalPkgInfo samples = sdk.getPkgInfo(LocalSdk.PKG_SAMPLES, getAndroidVersion()); 
 /** Intent extra for passing a SmsCbMessage */ 
 * is a rendering. This is necessary because even though the progress icon looks good on some 
 * is a rendering. This is necessary because even though the progress icon looks good on some 
 MessageServiceCategoryAndScope(int serviceCategory, int serialNumber, SmsCbLocation location) { 
 private static final HashSet<MessageServiceCategoryAndScope> sCmasIdSet = new HashSet<MessageServiceCategoryAndScope>(8); 
 MessageServiceCategoryAndScope newCmasId = new MessageServiceCategoryAndScope( message.getServiceCategory(), message.getSerialNumber(), message.getLocation()); 
 MessageServiceCategoryAndScope oldestCmasId = sCmasIdList.get(sCmasIdListIndex); sCmasIdList.set(sCmasIdListIndex, newCmasId); Log.d(TAG, "message ID limit reached, removing oldest message ID " + oldestCmasId); 
 sCmasIdSet.remove(oldestCmasId); 
 myRefreshingAlarm.addRequest(myUpdateRequest, REFRESH_INTERVAL_MS); 
 myRefreshingAlarm.addRequest(myUpdateRequest, REFRESH_INTERVAL_MS); 
 Object value = PLUGIN_CLASSPATH.getValue(args); String s = value != null ? value.toString() : null; 
 protected void setValue(@NotNull Project project, @NotNull GrStatementOwner closure, @NotNull Object value) { throw new UnsupportedOperationException("setValue not implemented for closures for " + toString()); 
public class ModuleDependenciesEditor implements ModuleConfigurationEditor { 
<|del|> 
 return mergeReport.getMergedDocument().get(); 
<|del|> 
 try { newComponent = new NumberComponent(Integer.parseInt(buffer.toString())); } catch(NumberFormatException e) { newComponent = new StringComponent(buffer.toString()); } 
 public static final int PLUS_REV = -1; 
 private final List<Integer> myRevisions = new ArrayList<Integer>(3); 
 public GradleCoordinate(@NonNull String groupId, @NonNull String artifactId, @NonNull Integer... revisions) { 
 myIsAnyRevision = (!myRevisions.isEmpty() && myRevisions.get(0) == PLUS_REV); 
 while (matcher.find()) { 
 while (matcher.find()) { 
 for (int i : myRevisions) { if (revision.length() > 0) { revision.append('.'); 
<|del|> 
 int delta = myRevisions.get(i) - that.myRevisions.get(i); if (delta != 0) { return delta; 
<|del|> 
 public static final String GRADLE_WRAPPER_PATH = "gradle" + File.separator + "wrapper"; 
 public AccessibilityIds getAccessibilityIds() { 
 if (javaHome != null && !javaHome.isEmpty()) { javaHome = FileUtil.toSystemDependentName(javaHome); 
 for (ProductFlavorContainer container : myDelegate.getProductFlavors()) { 
 switch (dependency.type) { 
 return args.length == 1 && args[0] != null && args[0] instanceof GrLiteral; 
 * Enumerates the values we know how to parse out of the build file. This includes values that only occur in one place 
 Object value = PLUGIN_CLASSPATH.getValue(args); String s = value != null ? value.toString() : null; 
 private final String myPath; private final boolean myArgumentIsClosure; 
 private final String myPath; private final boolean myArgumentIsClosure; 
 private BuildFileKey(@NotNull String path) { 
 * <code>a { b { c("value") } }</code> * @param argumentIsClosure true if the value to be found at the given path is expected to itself be a closure. 
 return args.length != 1 && args[0] != null && args[0] instanceof GrLiteral; 
<|del|> 
 String moduleGradlePath = getModuleGradlePath(module); if (moduleGradlePath != null) { addModule(moduleGradlePath); } 
 myModulePath = modulePath; 
 public void disposeUIResources() { Disposer.dispose(myModuleEditor); 
 List<String> leaves = Lists.newArrayList(Splitter.on(':').omitEmptyStrings().split(path)); 
 final ArrayList<AnAction> result = new ArrayList<AnAction>(2); 
 if (name.startsWith("play-services")) { name = name.replaceAll("-", " "); name = "Google " + StringUtil.capitalizeWords(name, true); 
 private static final Logger LOG = Logger.getInstance(ModuleDependenciesPanel.class); 
 private static final Logger LOG = Logger.getInstance(ModuleDependenciesPanel.class); 
 private static final Logger LOG = Logger.getInstance(TemplateParameterStep.class); 
 myTemplateImage.setIcon(previewImage); myCurrentThumb = thumb; 
 /** * Called by update() to write derived values to the template model. */ protected void deriveValues() { } 
 for (Field field : clazz.getFields()) { // Skip "public static final", which gets rid of enums constants and super variables 
<|del|>
 assertNotNull("Path to JDK 1.7 not set, please set JAVA7_HOME", myJdk7HomePath); 
 * Requests a project sync with Gradle. 
 final AtomicBoolean hasUnresolvedDependenciesRef = new AtomicBoolean(false); 
 public void setAt(int i, long value) { 
<|del|> 
<|del|> 
<|del|> 
 public void test_deleteChatAt_lastRange() { 
 // See https://code.google.com/p/android/issues/detail?id=60639 public void test_delete_endsAtLastChar() { 
 } catch (StringIndexOutOfBoundsException expected) { } 
 } catch (StringIndexOutOfBoundsException expected) { } 
 sb.delete(4, 4); 
 /** Compiles Java code and invokes Android build tools. */ MAKE, 
 if (error.getMessage().startsWith("java/")) { 
 * {@link #close()} has been called at least once. 
import javax.crypto.SecretKey; 
 private static final boolean DBG_STATE = false; 
 // The handshake hasn't been started yet, so there's nothing to clean up. // 
 // set the state to STATE_CLOSED. startHandshake will handle all cleanup // after SSL_do_handshake returns, so we don't have anything to do here. 
 List<ImportedProject> selected = new ArrayList<ImportedProject>(); 
<|del|> 
 // The first 3 bytes of mac_material_part are used as a scratch area 
<|del|> 
 stopwatch.stop(); 
 if (text.indexOf('\n') == -1) { 
 Spacer spacer = new Spacer(); myParamContainer.add(spacer, c); 
 // TODO: I'm not sure if the above wait include the wait below, we should look into this MavenProjectsManager.getInstance(myProject).waitForPluginsResolvingCompletion(); 
<|del|> 
 if (dir != null && dir.getName().equals(SdkConstants.FD_RES_MENU)) { 
 if (dir != null && dir.getName().equals(SdkConstants.FD_RES_MENU)) { String resourceName = ResourceHelper.getResourceName(containingFile); State state = new MenuState(resourceName); 
 return result; 
 String nai = SystemProperties.get("persist.radio.cdma.nai", null); if (!TextUtils.isEmpty(nai)) { 
 byte[] encoded = Base64.encodeBase64(nai.getBytes(StandardCharsets.UTF_8)); nai = new String(encoded, StandardCharsets.UTF_8); 
 byte[] encoded = Base64.encodeBase64(nai.getBytes(StandardCharsets.UTF_8)); nai = new String(encoded, StandardCharsets.UTF_8); 
 byte[] encoded = Base64.encodeBase64(nai.getBytes(StandardCharsets.UTF_8)); nai = new String(encoded, StandardCharsets.UTF_8); 
 * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()} 
 List<String> disallowedDefaultCipherSuites = new ArrayList<String>(); 
 assertEquals(Collections.EMPTY_LIST, disallowedDefaultCipherSuites); 
 assertNotNull(cipherSuite); 
 assertTrue(cipherSuite, ((cipherSuite.startsWith("TLS_")) || (cipherSuite.startsWith("SSL_")))); 
 assertTrue(cipherSuite, macDelimiterIndex != -1); 
 assertTrue(cipherSuite, macDelimiterIndex != -1); 
 assertTrue(cipherSuite, withDelimiterIndex != -1); 
<|del|> 
 return IoUtils.readFileAsString(PROC_NET_IF_INET6).split("\n"); 
<|del|> 
 final String[] interfaceList = SYS_CLASS_NET.list(); 
 String[] interfaceNames = SYS_CLASS_NET.list(); 
 return readFileAsBytes(path).toString(StandardCharsets.UTF_8); 
 final byte[] buf = Streams.readFullyNoClose(is); 
<|del|> 
<|del|> 
 if (line1Key != null && line1Number != null) { 
 if (naiKey != null && nai != null) { if (value.indexOf(naiKey) >= 0) { value = value.replace(naiKey, nai); } 
 if (!TextUtils.isEmpty(addendum)) nai = nai + addendum; 
 public static final Icon GradleConsole = load("/icons/gradle_console.png"); // 16x16 
<|del|> 
<|del|> 
 * repeatedly until either the stream is exhausted or we read fewer bytes than 
 return gmc.getInvokedExpression().getText(); 
 public AndroidModuleEditor(@NotNull Project project, @NotNull String moduleName) { 
 public SingleObjectPanel call() { 
 if (myEmptyPanel == null) { myEmptyPanel = new JPanel(); } return myEmptyPanel; 
 if (value instanceof List) { 
 * Whether this cipher needs BEAST mitigation or not. This enabled for CBC * mode ciphers. 
<|del|> 
 private byte[] wrap(byte content_type, DataStream dataStream, int max_len) { byte[] fragment = dataStream.getData(max_len); 
<|del|> 
 if (heightRatio < widthRatio) { 
<|del|> 
 /** * Strip off the end portion of the name. The user might be typing 
<|del|> 
 return getErrorMessageForStringType(project, module, packageName, value.toString()); 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * Unlike the more general {@link Template} which is used to instantiate 
 private Configuration myFreemarker; private String myCurrentExpression; 
 myParamContainer.setLayout(new GridLayoutManager(parameters.size() + 1, 3)); String packageName = myTemplateState.getString(TemplateMetadata.ATTR_PACKAGE_NAME); 
 assertEquals("Foo", stripSuffix("FooBarBar", "Bar", true)); assertEquals("FooBar", stripSuffix("FooBarBar", "Bar", false)); 
 return argList.getAllArguments(); 
 myEditors.add(new GenericEditor<NamedObjectPanel>("Signing", new Callable<NamedObjectPanel>() { 
 private JPanel myEmptyPanel; 
 switch (getKey(i).getType()) { 
 if (o != null && !StringUtil.isEmptyOrSpaces(o.toString())) { o = new File(FileUtil.toSystemIndependentName(o.toString())); } else { o = null; } 
 boolean myModified; 
 return load(name); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // to the superclass constructor, but it doesn't make any 
 super(2, capacity, effectiveDirectAddress); 
<|del|> 
 public static void assertSSLContext(SSLContext sslContext) throws IOException { 
 public static void assertSSLSocketFactory(SSLSocketFactory sslSocketFactory) throws IOException { 
<|del|> 
 myDelegate.openProjectSettings(); 
 private final String jarName; private final Manifest manifest; private final HashMap<String, byte[]> metaEntries; final int mainAttributesEnd; 
 InitManifest im = new InitManifest(buf, mainAttributes); mainEnd = im.getPos(); im.initEntries(entries, chunks); 
 // *AND* it contains signing related information (signature block // files and the signature files). 
 // NOTE: This was the old behavior. A call to closeEntry() before the 
 if (manifest == null || signatures.isEmpty()) { 
 Manifest.Chunk chunk = manifest.getChunk(entry.getKey()); 
 * A container for fields unknown to the message, including extensions. Extension fields can * can be accessed through the {@link getExtension()} and {@link setExtension()} methods. 
 * Gets the value stored in the specified extension of this message. 
 * Sets the value of the specified extension of this message. 
 public int getSerializedSize() { // This is overridden if the generated message has serialized fields. cachedSize = 0; return 0; 
 // Step 1: Scan the central directory for meta entries (MANIFEST.mf // & possibly the signature files) and read them fully. 
<|del|> 
 } else if (name.equals(GET_INSTANCE) || name.equals(CONSTRUCTOR_NAME) || name.equals(WRAP) || name.equals(UNWRAP)) { // For SSLEngine 
 = "https://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html"; 
 "If your application relies on cryptographically secure random number generation " + "you should apply the workaround described in " + BLOG_URL + " .\n" + 
 "cryptographically secure RNG is required, or whether the workaround has already " + "been applied. After reading the blog entry and updating your code if necessary, " + "you can disable this lint issue.", 
 OWNER_SECURE_RANDOM, JAVAX_NET_SSL_SSLENGINE, JAVAX_CRYPTO_SIGNATURE, JAVAX_CRYPTO_CIPHER 
 String message = "Potentially insecure random numbers on Android 4.3 and older. " + "Read " + BLOG_URL + " for more info."; 
 // *AND* it contains signing related information (signature block // files and the signature files). 
 @NotNull private final Key<Key<?>> myContentIdKey = CONTENT_ID_KEY; 
 synchronized (mProxyLock) { 
 synchronized (mProxyLock) { 
 ProxyProperties proxyProperties = new ProxyProperties(data[0], proxyPort, exclusionList); if (!proxyProperties.isValid()) { Slog.e(TAG, "Invalid proxy properties, ignoring: " + proxyProperties.toString()); 
 public void requestProjectSync(@NotNull Project project, @Nullable GradleSyncListener listener) { requestProjectSync(project, true, listener); 
 public void requestProjectSync(@NotNull Project project, @Nullable GradleSyncListener listener) { requestProjectSync(project, true, listener); 
<|del|> 
<|del|> 
<|del|> 
 // NOTE: Required to get tests passing under vogar. Vogar sets // a hardcoded timezone before running every test, so we have to // set it back to the "real" default before we run the test. 
 indentBuf.append(INDENT); 
 /** Path to the directory containing the templates */ 
 public boolean fillHorizontally(boolean inVerticalContext) { return (this == BOTH || this == WIDTH || (inVerticalContext && (this == OPPOSITE || this == WIDTH_IN_VERTICAL))); 
 // Attempt to set fill-properties on newly added views such that for example, // in a vertical layout, a text field defaults to filling horizontally, but not // vertically. 
<|del|> 
 private static boolean isBuildByGradle(@NotNull Project project) { 
 array = new Object[arrayLength * 13]; array2 = new Object[arrayLength * 13]; for (int i = 0; i < arrayLength; i += 13) { 
 if (element instanceof Object[]) { 
 if (e1 instanceof Object[]) { 
 * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. 
 String description = String.format("The project and Android Studio point to different Android SDKs.\n\n" + "Android Studio's default SDK is in:\n" + 
 throw new IOException("Pipe is broken"); 
 // index == index1 from this point on. 
 return first.regionMatches(prevIndex, second, prevIndex, second.length() - prevIndex); 
 interface ParameterizedFoo<T> { 
 protected void populateDirectoryParameters() throws IOException { File projectRoot = new File((String)get(NewModuleWizardState.ATTR_PROJECT_LOCATION)); File moduleRoot = new File(projectRoot, (String)get(NewProjectWizardState.ATTR_MODULE_NAME)); 
 updatePresentation(e); 
 * Copyright (C) 2013 The Android Open Source Project 
<|del|> 
 if (cipherSuite.equals(TLS_EMPTY_RENEGOTIATION_INFO_SCSV)) { 
 // other than Z_FINISH after the deflater has finished. See the error checking // at the start of the deflate function in deflate.c. 
 return getBuildSdkVersion(module) >= RTL_TARGET_SDK_START && getTargetSdkVersion(module) >= RTL_TARGET_SDK_START; 
 AndroidFacet facet = AndroidFacet.getInstance(module); if (facet != null) { AndroidModuleInfo moduleInfo = get(facet.getModule()); if (moduleInfo != null) { return moduleInfo.getBuildSdkVersion(); } 
 private static boolean isColorString(@NotNull String s) { 
 File mainDirPath = new File(moduleRootDirPath, FileUtil.join("build", "classes", "main")); File testDirPath = new File(moduleRootDirPath, FileUtil.join("build", "classes", "test")); 
 for (Sdk sdk : DefaultSdks.getEligibleAndroidSdks()) { AndroidSdkAdditionalData data = (AndroidSdkAdditionalData)sdk.getSdkAdditionalData(); assert data != null; Sdk jdk = data.getJavaSdk(); 
 // This works because it's in java.* and any class in there falls back to toString. 
 @NonNull Collection<ArtifactSourceProviders> getSourceProviders(); 
 private static final int INVALID_BYTE_COUNT = 2; 
 System.out .println("GB18030 is not supported, abort test InputStreamReaderTest.testSpecialCharsetReading()."); 
 private static final int INVALID_BYTE_COUNT_OFFSET = 2; 
 private static final int INVALID_CHAR_COUNT = 2; 
 public IAndroidTarget getHighestApiTarget() { // Note: The target list is already sorted in ascending API order. 
 * Constructs a new {@code LinkAddress} from an {@code InterfaceAddress}. * @param interfaceAddress The interface address. 
 * Constructs a new {@code LinkAddress} from an {@code InterfaceAddress}. * @param interfaceAddress The interface address. 
 * Constructs a new {@code LinkAddress} from an {@code InetAddress} and a prefix length. 
 if (aarDir.getPath().endsWith(DOT_AAR)) { 
import java.util.Arrays; import javax.security.auth.callback.PasswordCallback; import junit.framework.TestCase; import org.apache.harmony.testframework.serialization.SerializationTest; 
 String message = null; 
 String message = null; 
 private ArrayList<SmsMessage> mMessageQueue = null; 
 String message = ""; if (messageChars != null) { message = messageChars.toString(); } 
 if (mMessageQueue.size() == 0) { 
 List<AndroidLibrary> libraries = gradleProject.getSelectedVariant().getMainArtifact().getDependencies().getLibraries(); 
 private void generateDocument(File reportDir, long elapsedTime, Map<String, String> metrics) { 
 return ((File) data).getPath(); 
 Collection<File> getFrameworkSources(); 
 List<String> getProductFlavors(); 
 /** 
 assertEquals(RT_SCOPE_UNIVERSE, new LinkAddress("10.1.2.3/21").getScope()); 
 maybeLog("addressRemoved", iface, address); 
 List<String> productFlavors = selectedVariant.getProductFlavors(); 
 * Action to invoke the Asset Studio. This action is visible * anywhere within a module that has an Android facet. 
 if (module == null) { return; } 
 private static final Logger LOG = Logger.getInstance(AssetSetStep.class); 
<|del|> 
 myFontFamily.setSelectedItem(myWizardState.getString(ATTR_FONT)); 
 * Wizard that allows the user to create various density-scaled assets. 
<|del|> 
<|del|> 
 if (targetResDir == null) { return; } 
<|del|> 
 myModule = module; 
<|del|> 
<|del|> 
 * Custom tree cell renderer for displaying a {@link FileTreeModel} 
 List<String> parts = Lists.newLinkedList(Splitter.on(File.separatorChar).split(s)); 
 public boolean existsOnDisk; 
 model.addFile(createFile("asdfasdfasdf/foo"), icon); 
 //noinspection UndesirableClassUsage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB); 
 if (warning.includesMoreThanExcludes()) { 
 // Perform a constant time comparison to avoid timing attacks. 
 final File projectAndroidHomePath = localProperties.getAndroidSdkPath(); boolean hasProjectSdk = projectAndroidHomePath != null; boolean hasValidProjectSdk = hasProjectSdk && DefaultSdks.validateAndroidSdkPath(projectAndroidHomePath); 
<|del|> 
 Messages.showErrorDialog(String.format(format, projectAndroidHomePath, androidHomePath.getPath()), ERROR_DIALOG_TITLE); 
 String format = "The path\n'%1$s'\ndoes not refer to a valid Android SDK. Would you like to try again?"; 
 if (FileUtil.filesEqual(localProperties.getAndroidSdkPath(), androidHomePath)) { 
 if (FileUtil.filesEqual(localProperties.getAndroidSdkPath(), androidHomePath)) { 
 * Check if an item is in the array. The array of supported key classes * and formats is usually just a length of 1, so a simple array is * faster than a Set. 
 private static final <T> boolean isInArray(T[] itemList, T target) { 
 */ @SuppressWarnings("serial") 
<|del|> 
 in.position(in.position() + data[INPUT_OFFSET] - data[INVALID_CHAR_COUNT]); 
<|del|> 
 return !myOriginalSdkHomePath.equals(getAndroidHomeLocation().getPath()) || !myOriginalJdkHomePath.equals(getJavaHomeLocation().getPath()); 
 File jdkHome = getHomePathOf(jdk); if (jdkHome != null) { return jdkHome.getPath(); } 
 private final String mId; 
 private final String mId; 
 public static final String PREVIEW_ID = "rc"; 
 private final String mString; 
<|del|> 
<|del|> 
<|del|> 
 private UiAutomatorViewer mViewer; 
 private final ArrayList<Provider.Service> services; 
 String name = this.serviceName + "." + algoUC; 
 this.serviceCache = new ServiceCacheEntry(algoUC, provider, newCacheVersion, services); 
 private boolean validateJavaHome() { return myJavaSdk.isValidSdkHome(myJavaHomeLocation.getText()); 
 // Ensure that the library references (which are canonicalized) find this project // if included from multiple locations 
<|del|> 
 if (!isImportIntoExisting()) { createDestDir(destDir, allowNonEmpty); createProjectBuildGradle(new File(destDir, FN_BUILD_GRADLE)); 
 sb.append(NL); 
 // references in project.properties can be relative and can be made canonical; 
 // pick up exact version numbers of popular libraries. // (This list was generated by just looking at some existing projects // and seeing which .jar files they depended on and then consulting available // gradle dependencies via http://gradleplease.appspot.com/ ) 
<|del|> 
 if (ecP == null) { ecP = NISTNamedCurves.getByName(name); } 
 mCanonicalTempDir = new File(mNormalizedTempDir).getCanonicalPath(); 
 * <type>[| <type>...], <protocol>, <roaming_protocol>, <carrierEnabled>, <bearer> * [, <mvnoType>, <mvnoMatchData>] 
<|del|> 
 protected HandshakeProtocol(SSLEngineImpl owner) { if (owner == null) { throw new NullPointerException(); } engineOwner = owner; nonBlocking = true; this.parameters = engineOwner.sslParameters; 
 "AndroidOpenSSL", "AndroidOpenSSL"); 
 SSLContext sslContext = SSLContext.getInstance("SSL", "AndroidOpenSSL"); 
 SSLContext clientContext = createSSLContext(protocol, client.keyManagers, client.trustManagers); SSLContext serverContext = createSSLContext(protocol, server.keyManagers, server.trustManagers); 
<|del|> 
 notifyAsUser(tag, id, notification, UserHandle.myUserHandle()); 
 cancelAsUser(tag, id, UserHandle.myUserHandle()); 
 public Set<String> keySet() { 
<|del|> 
<|del|> 
 * Copyright (C) 2014 The Android Open Source Project 
 public static final TouchCalibration IDENTITY = new TouchCalibration(); 
 } else if (obj instanceof TouchCalibration) { 
 } else { 
 } if (calibration == null) { throw new IllegalArgumentException("calibration must not be null"); } 
 private static final String[] CALIBRATION_NAME = { "x_scale", "x_ymix", "x_offset", "y_xmix", "y_scale", "y_offset" }; 
 return false; } 
 * Endpoint messages bundle. 
 if (ourBundle != null) { bundle = ourBundle.get(); } 
 private static void getUiHierarchyFile(IDevice device, File dst, IProgressMonitor monitor, boolean compressed) { 
 if (compressed){ 
 } else { 
 public static UiAutomatorResult takeSnapshot(IDevice device, IProgressMonitor monitor, boolean compressed) throws UiAutomatorException { 
 private Cursor mCrossCursor; 
 getShell().setCursor(mCrossCursor); 
 Rectangle rect = new Rectangle( uiNode.x, uiNode.y, uiNode.width, uiNode.height); e.gc.setForeground( e.gc.getDevice().getSystemColor(SWT.COLOR_YELLOW)); 
 Rectangle rect = new Rectangle( uiNode.x, uiNode.y, uiNode.width, uiNode.height); e.gc.setForeground( e.gc.getDevice().getSystemColor(SWT.COLOR_YELLOW)); 
 e.gc.drawRectangle(mDx + getScaledSize(rect.x), mDy + getScaledSize(rect.y), 
<|del|> 
 coordinateLabel.setText(String.format("(%d,%d)", x,y)); 
 fd.setFilterExtensions(new String[] {"*.png" }); 
 // both are composites with borders, so that the horizontal divider can be highlighted by // the borders 
 ToolBar searchtoolbar = toolBarManager.createControl(upperRightBase); 
 ToolItem itemPrev = new ToolItem(searchtoolbar, SWT.SIMPLE); itemPrev.setImage(ImageHelper.loadImageDescriptorFromResource("images/prev.png") 
 String term = searchTextarea.getText(); if (!term.isEmpty()) { 
 if (!mSearchResult.isEmpty()) { 
 baseSash.setWeights(new int[] {5, 3 }); 
 return; if(mSearchResult.isEmpty()){ mSearchResult = null; return; } 
 if (mSearchResultIndex < 0){ 
 return; if(mSearchResult.isEmpty()){ mSearchResult = null; return; } 
 float scaleY = (canvas.height - 2 * IMG_BORDER - 1) / (float) image.height; 
 super("&Device Screenshot "+ (compressed ? "with Compressed Hierarchy" : "") +"(uiautomator dump" + (compressed ? " --compressed)" : ")")); 
import com.android.sdklib.xml.ManifestData; 
 } else { 
 // The default flush param is NO_FLUSH so it's up to the deflater to 
 // Delete the file with a timeout of 2 minutes. Cf bug: http://b.android.com/63927 Utils.deleteWithTimeout(file, 120 * 1000); 
 private static void getUiHierarchyFile(IDevice device, File dst, 
<|del|> 
<|del|> 
<|del|> 
 return; } 
 return; } 
 ErrorDialog.openError(Display.getDefault().getActiveShell(), String.format("Error writing %s.uix", filepath), 
 private String mLastSearchedTerm; 
 Status status = new Status(IStatus.ERROR, 
 super("&Device Screenshot "+ (compressed ? "with Compressed Hierarchy" : "") 
 return input.substring(1,input.length() - 1); 
<|del|> 
 /** * Tests {@link EndpointUtilities#removeBeginningAndEndingQuotes(String)} } */ 
 nativeRemove(0L); 
import com.android.tools.idea.templates.recipe.Recipe; import com.android.tools.idea.templates.recipe.RecipeExecutionContext; import com.android.tools.idea.templates.recipe.RecipeRecordingContext; 
 * </pre> * In this example, each of the compile statements would be represented by an instance of an subtype of this class. 
 * elements can be represented by the subtype class {@link UnparseableStatement}, which is a 
 ((PushbackInputStream) in).unread(buf, inf.getCurrentOffset() + GZIP_TRAILER_SIZE, remaining); 
 final byte flags = header[3]; final boolean hcrc = (flags & FHCRC) != 0; 
 return workingString; } 
 return workingString; } 
 public Set<String> keySet() { 
 * <pre> 
 protected void setValue(@NotNull GrStatementOwner closure, @NotNull BuildFileStatement value) { 
 return Collections.emptyList(); 
 return new Repository(Type.URL, s.substring(1, s.length() - 1)); 
 public List<E> getValues(@NotNull GrStatementOwner closure) { 
 private static final String TITLE = "Save Heap Dump"; 
 showError(AndroidBundle.message("android.ddms.actions.dump.hprof.error.unsupported", remoteFilePath)); 
 Notifications.Bus.notify(new Notification("Android", AndroidBundle.message("android.ddms.actions.dump.hprof"), AndroidBundle.message("android.ddms.actions.dump.hprof.saved", myDestination), NotificationType.INFORMATION)); 
 private transient final AtomicLong atomicSeed = new AtomicLong(); 
 atomicSeed.set(seed); 
 char[] chars = new char[8192]; int read = 0; while ((read = reader.read(chars)) != -1) { System.out.print(new String(chars, 0, read)); 
 String line = null; while ((line = reader.readLine()) != null) { System.out.println(line); 
<|del|> 
 return resolved; 
<|del|> 
 Log.w(ADB, "ADB server port for starting AndroidDebugBridge is not set."); //$NON-NLS-1$ return false; 
 private static Integer validateAdbServerPort(@NonNull String adbServerPort, @NonNull String variablePrefix) throws IllegalArgumentException { 
 * Exception thrown when an IOException arises when performing a patch 
 myRetryButton.setEnabled(false); myRetryButton.setVisible(false); 
<|del|> 
 if (executionSettings.isParallelBuild() && !args.contains(PARALLEL_BUILD_OPTION)) { 
 private TouchCalibration[] mTouchCalibration = new TouchCalibration[4]; 
<|del|> 
<|del|> 
<|del|> 
 Log.w(TAG, "Binding time out. InCallUI did not respond in time."); 
 Log.w(TAG, "unbindservice exception", e); 
<|del|> 
 return EndpointBundle.message("api.name.shortName"); 
 String nameValueWithQuotes = annotation.findAttributeValue(API_NAME_ATTRIBUTE).getText(); 
<|del|> 
 return EndpointBundle.message("api.namespace.short.name"); 
 } String ownerDomainWithQuotes = ownerDomainMember.getText(); 
 } String ownerDomainWithQuotes = ownerDomainMember.getText(); 
 PsiAnnotationMemberValue ownerNameMember = annotation.findAttributeValue(API_NAMESPACE_NAME_ATTRIBUTE); if (ownerNameMember == null) { 
 mTelephonyManager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE); mPackageManager = getContext().getPackageManager(); 
 Integer parsedPort = Integer.getInteger(SERVER_PORT_ENV_VAR); if (parsedPort != null) { result = validateAdbServerPort(parsedPort.toString(), "system property variable "); } 
<|del|>
 int handle = dumpCycle(object); 
import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.Map; 
 */ @Deprecated 
 File toolsLib = new File(myLocalSdk.getLocation(), SdkConstants.OS_SDK_TOOLS_LIB_EMULATOR_FOLDER); 
 File f = new File(myLocalSdk.getLocation(), imageSysDir); 
 f = new File(myLocalSdk.getLocation(), imageSysDir); 
<|del|> 
 private final List<LocalSdk> myLocalSdks = Lists.newArrayList(); 
 String hprofConvPath = sdkManager.getLocation() + File.separator + AndroidCommonUtils.toolPath(SdkConstants.FN_HPROF_CONV); 
 String testDataPath = getTestDataPath(); assertSame(sdkData, AndroidSdkData.getSdkData(testDataPath)); 
 /** ISO 15924 English name "Armenian" */ 
 // Tell the tree to ask the TreeCellRenderer for an individual height for each cell. myOutputPreviewTree.setRowHeight(-1); 
<|del|> 
 WallpaperData wallpaper = getWallpaperData(wallpaperUserId); 
 if (FileUtil.filesEqual(sdkData.getLocation(), canonicalLocation)) { 
 public void testEnableCollection_invalid() { 
 // TLSv1.2 cipher suites not supported by the SSLEngine implementation which is the // only user of the CipherSuite class. 
<|del|> 
 " has at least one overload: " + psiMethodName + " and " + seenMethodName, LocalQuickFix.EMPTY_ARRAY); 
 public final long getNativeAsset() { 
 markerJob.setPriority(Job.BUILD); markerJob.setRule(ResourcesPlugin.getWorkspace().getRoot()); 
 public void visitAnnotation(PsiAnnotation annotation) { if (!isEndpointClass(annotation)) { 
import com.intellij.psi.PsiAnnotation; import com.intellij.psi.PsiAnnotationParameterList; import com.intellij.psi.PsiElement; import com.intellij.psi.PsiElementVisitor; 
 "gridlayout_v7", waitForFinish); //$NON-NLS-1$ 
<|del|>
 "appcompat_v7", waitForFinish); // $NON-NLS-1$ 
<|del|>
 Closeables.closeQuietly(out); 
 * CipherInputStream benchmark. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 return new DeviceManager(sdkLocation == null ? null : sdkLocation.getPath(), log); 
 private List<InterfaceAddress> excludeLinkLocal(List<InterfaceAddress> addresses) { ArrayList<InterfaceAddress> filtered = new ArrayList<InterfaceAddress>(addresses.size()); 
 private List<InterfaceAddress> excludeLinkLocal(List<InterfaceAddress> addresses) { ArrayList<InterfaceAddress> filtered = new ArrayList<InterfaceAddress>(addresses.size()); 
 // Don't touch link-local routes, as link-local addresses aren't routable, // kernel creates link-local routes on all interfaces automatically Collection<InterfaceAddress> interfaceAddresses = excludeLinkLocal( 
 protected void onBind(InetAddress localAddress, int localPort) { 
 Long jniSetter = propertyMap.get(mPropertyName); if (jniSetter != null) { mJniSetter = jniSetter; 
 void onConnectStatusChanged(InetSocketAddress address, int status, boolean updateSocketState) { 
<|del|> 
 private long mObject; 
 /** * Test classes for {@link ComputeSerialVersionUIDTest}. Used to ensure * that serial version UIDs are generated correctly for various combinations * of interfaces, fields, constructors and methods. */ 
 public static class TestInterfaces implements java.io.Serializable { 
 // The RI throws an exception at this point. Android ignores the second connect() call. s.connect(datagramSocket2Address); 
 } RuntimeException ex = new RuntimeException(); ex.fillInStackTrace(); mRefStacks.put(id, ex); 
 mRefStacks.put(id, ex); 
 int nativeMode); 
 private static native void nativeCopyPixelsFromBuffer(long nativeBitmap, Buffer src); 
 private static native void nativeSetHasMipMap(long nativeBitmap, boolean hasMipMap); private static native boolean nativeSameAs(long nativeBitmap0, long nativeBitmap1); 
 private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts); 
 int flags = dir == 0 ? 0 : 1; 
 int flags = dir == 0 ? 0 : 1; 
 contextStart, contextEnd, x, y, flags, paint); 
<|del|>
 private LargeBitmap(long nativeLbm) { mNativeLargeBitmap = nativeLbm; 
 private static native Bitmap nativeDecodeRegion(long nativeLbm, 
 private static native int nativeGetWidth(long nativeLbm); private static native int nativeGetHeight(long nativeLbm); private static native void nativeClean(long nativeLbm); 
 long native_a, long native_b); 
 long native_other_matrix); 
 long native_other_matrix); 
 private static native boolean native_invert(long native_object, long native_inverse); 
 private static final LongSparseArray<SparseArray<Typeface>> sTypefaceCache = new LongSparseArray<SparseArray<Typeface>>(3); 
 SparseArray<Typeface> styles = sTypefaceCache.get(ni); 
 styles = new SparseArray<Typeface>(4); 
 // TODO: Change mAtlasMap to long[] to support 64-bit systems atlasMap[mapIndex++] = (int) bitmap.mNativeBitmap; 
 * of the entity or by removing bytes from the end of the entity. See {@link #truncate}, * {@link #position} and {@link #write} for details. The current size can also be queried. 
 throw new UnsupportedOperationException(); 
<|del|> 
 Closeables.closeQuietly(fis); 
 Closeables.closeQuietly(inputStream); 
 Closeables.closeQuietly(is); 
 Closeables.closeQuietly(is); 
 Closeables.closeQuietly(is); 
 Closeables.closeQuietly(reader); Closeables.closeQuietly(isr); Closeables.closeQuietly(contentStream); 
<|del|> 
 assertTrue(channel1.isConnected()); 
 try { s.connect(datagramSocket2Address); fail(); } catch (IllegalStateException expected) {} 
<|del|> 
<|del|> 
<|del|> 
 .append("Any project builds, either from the command line or in other IDE instances, will stop."); 
 * Returns the current position as a positive integer number of bytes from the start of the * entity. 
 * Sets the channel's position to {@code newPosition}. 
<|del|> 
<|del|> 
<|del|> 
 manifestFile.setCharset(Charsets.UTF_8); String contents = VfsUtilCore.loadText(manifestFile); 
 protected static final boolean CAN_SYNC_PROJECTS = false; 
 ProjectStructureSanitizer.getInstance(myProject).cleanUp(); 
 String description = dependency == null ? ": null" : "type: " + dependency.getClass().getName(); throw new IllegalArgumentException("Unsupported dependency " + description); 
 // int y = myState.myBounds.y + myFeedback.dragBaseline; // g.drawLine(myState.myBounds.x, y, myState.myBounds.x + myState.myBounds.width, y); 
 String iconTypeName = element.getAttribute(Template.ATTR_TYPE).toUpperCase(Locale.US); 
<|del|> 
 mDelegateHelper.setSwapXY(!mVertical); 
 try { sc.read(new ByteBuffer[] { readOnly }); fail(); } catch (IllegalArgumentException expected) { } try { 
 * @return the channel. 
 * Returns the current position as a positive number of bytes from the start of the underlying * data source. 
 * @throws IOException if an I/O error occurs. 
 * <p>If the position is currently greater than the given size, then it is set to the new size. * 
 myIoFile = isMergedManifest ? VfsUtilCore.virtualToIoFile(file) : null; 
 private long getLastModified() { return myIsMerged ? myIoFile.lastModified() : myXmlFile.getModificationStamp(); 
 address = normalAddr; port = aPort; 
 // This methods is concrete because it has to be to keep API compatibility. Subclasses // should treat this like an abstract method and manage all fields. 
 // This methods is concrete because it has to be to keep API compatibility. Subclasses // should treat this like an abstract method and manage all fields. 
 // Do not add any code to these methods. They are concrete only to preserve API // compatibility. 
 * If the channel's position is beyond the current end of the underlying data source then 
 * @throws ClosedChannelException * if this channel is closed. * @throws IOException * if another I/O error occurs. 
 dependencySet.add(urlManager.getLibraryCoordinate(SUPPORT_ID_V4)); 
/** Properties that hold a long value. */ 
 return mDefaultValue != null & mDefaultValue.equals(mCurrentValue); 
 /** * Returns whether this report should display info (such as a path to the report) if * no issues were found */ 
 /** * Sets whether this report should display info (such as a path to the report) if * no issues were found */ 
 Projects.enforceExternalBuild(myProject); 
public static final long EGL_DEFAULT_DISPLAY = 0; 
 ); // TODO Unhide the eglGetDisplay(long) API method 
 settingsStep.addSettingsField("Android SDK location:", myAndroidSdkLocationField); 
 mThread.quitSafely(); 
 try { // Either the list will be NULL or empty in length for a valid test assertEquals(getBooleanNames().length, 0); } catch (NullPointerException e) { // expected } 
package com.example.android.demomodecontroller; 
 final int action = event.getAction(); 
 if (action != MotionEvent.ACTION_MOVE) return false; 
 final int hh = (int)x / (w / 12); 
 // We are here because JavaModel has an IdeaContentRoot. 
 providerSupportsAlgorithm = tryAlgorithm(null /* key */, provider, algorithm) != null; 
<|del|> 
<|del|> 
<|del|> 
 mIm.setTouchCalibrationForInputDevice(inputDeviceDescriptor, calibration); 
<|del|> 
 @Override // Binder call public TouchCalibration getTouchCalibrationForInputDevice(String inputDeviceDescriptor) { 
<|del|> 
<|del|> 
 mDataStore.setTouchCalibration(inputDeviceDescriptor, calibration); 
 mTouchCalibration = calibration; return true; 
 /** * @hide 
 throw new RSIllegalArgumentException("Offset must be >= 0."); 
 /** * @hide 
 } 
<|del|> 
 public FileTreeModel(@NotNull File root, boolean hideIrrelevantFiles) { 
 Node n = (Node)parent; if (!myHideIrrelevantFiles) { 
 for (int i = 0; i < n.children.size(); i++) { 
 * <strong>Legacy code; do not use.</strong> On Android, the Preference nodes * corresponding to the "system" and "user" preferences are stored in sections 
 * <strong>Legacy code; do not use.</strong> On Android, the Preference nodes * corresponding to the "system" and "user" preferences are stored in sections 
 if (tmpDir.endsWith(File.separator)) { 
 synchronized public MembershipKey join(InetAddress groupAddress, NetworkInterface networkInterface) throws IOException { 
<|del|> 
<|del|> 
 private static final class Id { 
 if (!(o instanceof Id)) { 
 if (RenderScript.shouldThunk()) { 
 info = ctx.getPackageManager().getApplicationInfo(ctx.getPackageName(), PackageManager.GET_META_DATA); } catch (PackageManager.NameNotFoundException e) { 
 static private int sSdkVersion = -1; static private boolean useIOlib = false; 
 info = ctx.getPackageManager().getApplicationInfo(ctx.getPackageName(), PackageManager.GET_META_DATA); } catch (PackageManager.NameNotFoundException e) { 
 info = ctx.getPackageManager().getApplicationInfo(ctx.getPackageName(), PackageManager.GET_META_DATA); } catch (PackageManager.NameNotFoundException e) { 
 sNative = 0; 
 AndroidFacet facet = AndroidFacet.getInstance(module); if (facet != null) { AppResourceRepository repository = facet.getAppResources(true); if (repository != null) { return repository.hasResourceItem(ResourceType.getEnum(resourceType), name); 
 @Override 
 } 
 if(file.getName().equalsIgnoreCase(whiteList)){ Log.d(TAG,"found whiteList path : " + file.getAbsolutePath()); return true; } 
<|del|> 
 if (regexps != null && location != null) { File file = location.getFile(); String relativePath = context.getProject().getRelativePath(file); boolean checkUnixPath = false; 
 return repository.hasResourceItem(resourceType, name); 
 public static @Nullable EmulatorConsole getConsole(IDevice d) { 
 return defaultValue; 
 private static final String RESPONSE_CONTENT 
 private static final boolean DO_LOG = false; 
 // Call static method to cause implicit clinit. 
 // Call again to make sure we still get the expected error. 
<|del|>
<|del|> 
<|del|> 
 } return result; 
 if (notifyUser) { notifyUser(); 
<|del|>
 File rootFilePath = VfsUtilCore.virtualToIoFile(rootFile); 
<|del|> 
<|del|> 
 myUpdateQueue = new MergingUpdateQueue("asset.studio", 200, true, null, this, null, false); 
<|del|> 
<|del|> 
<|del|> 
 public boolean matches(@NotNull Dependency dependency) { 
 if (s1.startsWith(APPCOMPAT_V7) && s2.startsWith(SdkConstants.SUPPORT_LIB_ARTIFACT)) { 
 if (FileUtil.filesEqual(baseDir, depDir)) { 
 // A 52 bit mantissa isn't sufficient to precisely represent any of these // values, so we will lose some precision, thereby storing it as 
 if (isCleanBuildMode) { // "Clean" also generates sources. 
 private static File[] getAncestorPaths(@NotNull File path) { List<File> paths = Lists.newArrayList(); 
 paths.add(current); 
 @Nullable public static EmulatorConsole getConsole(IDevice d) { 
 */ @NonNull 
 final OpenSSLDigestContext ctxLocal = ctx; NativeCrypto.EVP_DigestUpdate(ctxLocal.getContext(), input, offset, len); 
 OpenSSLDigestContext ctxLocal = new OpenSSLDigestContext(NativeCrypto.EVP_MD_CTX_create()); NativeCrypto.EVP_MD_CTX_init(ctxLocal.getContext()); NativeCrypto.EVP_DigestInit(ctxLocal.getContext(), evp_md); ctx = ctxLocal; 
 final OpenSSLDigestContext ctxLocal = ctx; NativeCrypto.EVP_DigestUpdate(ctxLocal.getContext(), input, offset, len); 
 latch.countDown(); latch.await(); 
 latch.countDown(); latch.await(); 
 * will be reported later on to the user. 
 if (checkIfResolved(library)) { resolved.add(dependency); 
 * @hide for internal use only. 
 throw new ZipException("Empty zip archive not supported"); 
<|del|> 
 private static int findDefaultTrafficStatsTag(String url) { if (!TextUtils.isEmpty(url)) { 
 private static int findDefaultTrafficStatsTag(String url) { if (!TextUtils.isEmpty(url)) { 
 private static int findDefaultTrafficStatsTag(String url) { if (!TextUtils.isEmpty(url)) { 
 UrlParseRequest nullUrl = new UrlParseRequest(null); assertEquals(0, nullUrl.getTrafficStatsTag()); 
 return "main"; 
 // Relabel SELinux contexts. Need this to happen after all seinfo // values have been computed and written out to packages.list. 
/** A run configuration for App Engine modules, calls KickStart directly from the sdk */ 
 RunManagerEx.getInstanceEx(project).createRunConfiguration(module.getName() + " - " + AppEngineRunConfiguration.NAME, getConfigurationFactory()); 
public class AppEngineRunConfigurationType implements ConfigurationType { public static final String ID = "AppEngineRunConfiguration"; 
 return "Run App Engine module on the local development server"; 
 return ID; 
 File toolsJar = new File(path); if(toolsJar.exists()) { return toolsJar; } return null; 
 new File(System.getProperty("user.home"), "/.gradle/appengine-sdk/appengine-java-sdk-1.8.9").getAbsolutePath()); 
 // Commented out for now, ENABLE when AppEngine Gradle facet is ready. // FacetManager facetManager = FacetManager.getInstance(module); // ModifiableFacetModel model = facetManager.createModifiableModel(); 
 * Closes this writer. This implementation flushes the buffer but <strong>does not</strong> * flush the target stream. The target stream is then closed and the resources for the 
<|del|>
 if (!TextUtils.isEmpty(url)) { Uri uri = Uri.parse(url); if (uri != null) { String host = uri.getHost(); if (host != null) { return host.hashCode(); } } 
 * {@link Runnable} because that is simpler than trying to manage a specialized interface. * * @hide 
 // Check to see if the weak reference has been garbage collected. if (reference.get() == null) { System.logI("Sentry object has been freed so assuming CloseGuards have reported" + " any resource leakages"); break; } 
<|del|> 
 int bearerType = getBearerType(apnName); 
 native_agps_data_conn_open(apnName, bearerType); 
 native_agps_data_conn_open(apnName, bearerType); 
 String selection = String.format("current = 1 and apn = '%s' and carrier_enabled = 1", apn); 
<|del|> 
 int bytes = 20 + (2 * minLength); 
 // Can't create negative sized arrays. try { 
 for (int i = 0; i <= maxLength; i += step) { 
 if (gradleSettingsFile == null) { return null; } 
 for (NamedObject namedObject : signingConfigs) { if (!"debug".equals(namedObject.getName())) { continue; } 
 * Copyright (C) 2014 The Android Open Source Project 
 * Copyright (C) 2014 The Android Open Source Project 
<|del|> 
 if (facet != null && !facet.isGradleProject()) { 
 String domain = "u:r:healthd:s0"; String executable = "/sbin/healthd"; 
 /* Debuggerd is always there */ 
 public void testZygoteDomain() throws FileNotFoundException { 
 StringBuilder sb = new StringBuilder(); Scanner tmp = new Scanner(new File(f, "cmdline")); 
 // Visibility set to package-default for testing. Clients should use getFirstRecord(). @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE) 
 dumpHash(SEAPP_HASH_FILE, currentHash); 
 public Collection<VirtualFile> getJavaDirectories() { 
 assertDomainEmpty("u:r:init_shell:s0"); 
import libcore.util.CountingOutputStream; 
 private static final File SEAPP_HASH_FILE = new File(Environment.getDataDirectory(), "system/seapp_hash"); 
 return false; } catch (NoSuchAlgorithmException nsae) { Slog.e(TAG, "Error with hashing seapp_contexts.", nsae); return false; 
 } catch (IOException ioe) { Slog.e(TAG, "Error opening " + SEAPP_HASH_FILE + ". Assuming first boot.", ioe); } catch (NoSuchAlgorithmException nsae) { // won't happen, omit response 
 if (!tmp.renameTo(file)) { throw new IOException("Failure renaming " + file.getCanonicalPath()); } 
 // TODO: i18n 
 private final Map<String, DecisionTreeRecord> mRecords = 
 ADDED, 
 public ActionLocation(@NonNull XmlLoader.SourceLocation sourceLocation, @NonNull PositionXmlParser.Position position) { mSourceLocation = Preconditions.checkNotNull(sourceLocation); mPosition = Preconditions.checkNotNull(position); 
 private final ImmutableList<Invoker.Features> mOptionalFeatures; private final ILogger mILogger; 
 private static byte[] returnHash(File file, boolean takeDigest) throws IOException, NoSuchAlgorithmException { 
 if (instruction.equals(TOOLS_NODE_LOCAL_NAME)) { 
 myTreeModel = new FileTreeModel(resDir, true); 
 myTreeModel.forceAddFile(new File(resDir, filename), ic); 
 public static Iterable<IdeaSourceProvider> getCurrentSourceProviders(@NotNull AndroidFacet facet) { 
<|del|> 
 private void assertDomainOne(String domain, String executable) throws FileNotFoundException { 
 private void assertDomainZeroOrOne(String domain, String executable) 
 assertDomainOne("u:r:ueventd:s0", "/sbin/ueventd"); 
<|del|> 
 this.mLogger = logger; 
 iLogger.error(null /* throwable */,"Element names do not match: " 
 private static final String REFERENCE = "" 
<|del|> 
 final InstallerConnection installer = new InstallerConnection(); installer.waitForConnection(); 
 * Copyright (C) 2014 The Android Open Source Project 
 assertEquals(1, procs.size()); 
<|del|> 
 * PNG Writer. * * A PNG file is simply a signature followed by a number of {@link Chunk}. * * PNG specification reference: http://tools.ietf.org/html/rfc2083 
 boolean getUseAaptPngCruncher(); 
 public void crunchPng(@NonNull File from, @NonNull File to) 
 String getTypeAsString() { 
 private static long computeCrc32(@NonNull byte[] type, @Nullable byte[] data) { 
 ByteBuffer buffer = ByteBuffer.allocate(4 * Integer.SIZE/8); 
 int aa = argb >>> 24; int rr = (argb >> 16) & 0x000000FF; int gg = (argb >> 8) & 0x000000FF; 
 if (isGrayscale && (rr != gg || rr != bb)) { 
 alphaPalette[idx] = (byte) (color & 0xFF); 
<|del|> 
 private static void getHorizontalTicks( 
 @VisibleForTesting int getPixelLocation() { return mPixelLocation; 
 * <p> * Each action generates at least one {@link com.android.manifmerger.ActionRecorder.Record} 
 * containing enough information to generate a machine or human readable report. * <p> 
 * for that particular node. * <p> 
 * This structure will permit displaying logs with co-located decisions records for each element, 
 private ActionRecorder(ImmutableMap<String, DecisionTreeRecord> records) { mRecords = records; } 
 String testSrc = model.getText().getSrc(); if (testSrc != null && testSrc.equals(src.toString())) { 
 hasDupSrc = false; 
<|del|>
 private static final String SEAPP_CONTEXTS_FILE = "/seapp_contexts"; 
 private static final String SEAPP_HASH_FILE = Environment.getDataDirectory().toString() + "/system/seapp_hash"; 
<|del|> 
 storedHash = IoUtils.readFileAsByteArray(SEAPP_HASH_FILE); 
<|del|> 
<|del|> 
 * * @param file The file that receives the byte array content. * @param content A byte array that will be written to the specified file. 
 * * @param file The file that receives the byte array content. * @param content A byte array that will be written to the specified file. 
<|del|> 
 public static void clearCache() { ByteUtils.Cache.getCache().clear(); } 
 mIhdr.write(fos); for (Chunk chunk : mChunks) { chunk.write(fos); } 
 ILogger logger = mergingReport.getLogger(); 
<|del|> 
 if (attributeName.indexOf(XmlUtils.NS_SEPARATOR) == -1) { 
 mLogger.info("Merging flavors and build manifest %s \n", inputFile.getPath()); 
 @NonNull public static MergingReport.Result validate( @NonNull XmlDocument xmlDocument, @NonNull ILogger logger) { 
 // The kernel can round the requested value based on the HZ setting. We allow up to 10ms. assertTrue(Math.abs(expectedTimeoutMillis - wrapping.getSoTimeout()) <= 10); assertTrue(Math.abs(expectedTimeoutMillis - underlying.getSoTimeout()) <= 10); 
 * Returns the ISO 4217 numeric code for this currency. If there is no standard numeric code a * zero is returned. * 
 if (mCurrentUserId == userId) return; 
 * Copyright (C) 2014 The Android Open Source Project 
 public final List<String> source_types; public final List<String> target_types; public final Multimap<String, String> obj_classes; public final String name; public final String type; 
 public final List<String> source_types; public final List<String> target_types; public final Multimap<String, String> obj_classes; public final String name; public final String type; 
 if (xpp.getEventType() != XmlPullParser.START_TAG) { 
 } 
 public static List<SELinuxPolicyRule> readRulesFile(InputStream in) throws IOException, XmlPullParserException { List<SELinuxPolicyRule> rules = new ArrayList<SELinuxPolicyRule>(); 
 fail("checkSELinuxContext should have thrown"); 
 List<String> failedChecks = new ArrayList<String>(); Map<String, Boolean> contextsCache = new HashMap<String, Boolean>(); 
 List<String> failedChecks = new ArrayList<String>(); Map<String, Boolean> contextsCache = new HashMap<String, Boolean>(); 
 List<String> failedChecks = new ArrayList<String>(); Map<String, Boolean> contextsCache = new HashMap<String, Boolean>(); 
 for (SELinuxPolicyRule r : rules) { 
 for (String k : result.failedChecks) { 
 for (String k : failedChecks) { 
 private List<String> failedChecks = new ArrayList<String>(); 
 /* createAvcContext - currently uses class type and perm to determine user, role and mls values. * * @param target - false if source domain, true if target. 
 /* createAvcContext - currently uses class type and perm to determine user, role and mls values. * * @param target - false if source domain, true if target. 
 if (obj_class.equals("filesystem") && perm.equals("associate")) { 
 throw new NullPointerException("charset == null"); 
 Charset charset = this.charset; if ((flags & ZipFile.GPBF_UTF8_FLAG) != 0) { charset = StandardCharsets.UTF_8; 
<|del|> 
 // The comment is not written out until the entry is finished, but it is validated here 
 if (!processor.is9Patch() && processor.size() >= from.length()) { 
 * indicating an unforeseen change of configuration. 
 Preconditions.checkNotNull(logger); return validate(xmlDocument.getRootNode(), actionRecorder, logger); 
 MergingReport.Result result = SUCCESS; 
 if (!isNodeOperationPresent(xmlElement, recorder, ActionType.REJECTED)) { logger.warning("%1$s was tagged at %2$s:%3$d to replace another declaration " 
 if (!isNodeOperationPresent(xmlElement, recorder, ActionType.REJECTED)) { logger.warning("%1$s was tagged at %2$s:%3$d to replace another declaration " 
 if (!isNodeOperationPresent(xmlElement, recorder, ActionType.REJECTED)) { logger.warning("%1$s was tagged at %2$s:%3$d to remove other declarations " 
 ActionRecorder.DecisionTreeRecord record = recorder.getAllRecords().get(xmlElement.getId()); for (ActionRecorder.NodeRecord nodeRecord : record.getNodeRecords()) { if (nodeRecord.getActionType() == action) { 
 && attribute.getNodeValue().equals(REMOVE_OPERATION_XML_MAME)) { 
 if (cleanToolsReferences((Element) node, logger) == ERROR) { return ERROR; 
 // 
 private static int sWidth = ENCODER_PARAM_TABLE[ENCODER_PARAM_TABLE.length-1][1]; private static int sHeight = ENCODER_PARAM_TABLE[ENCODER_PARAM_TABLE.length-1][2]; 
 enforceConnectivityInternalPermission(); 
<|del|> 
 storeRequestMap(msg.arg2, id, clientInfo, msg.what); 
 storeRequestMap(msg.arg2, id, clientInfo, msg.what); 
 storeRequestMap(msg.arg2, id, clientInfo, msg.what); 
<|del|>
 throw new UnsupportedOperationException( "Minus sign spans multiple characters: " + minusSign); 
 "targetActivity", SdkConstants.ATTR_NAME), 
 INSTRUMENTATION(MergeType.MERGE, defaultNameAttributeResolver, SdkConstants.ATTR_NAME), 
 PROVIDER(MergeType.MERGE, defaultNameAttributeResolver, SdkConstants.ATTR_NAME), 
 + ", use tools:replace to override it."; 
 "Node %1$s cannot be present in more than one input file and it's " + "present at %2$s and %3$s", 
 "Node %1$s at %2$s is tagged with tools:node=\"strict\", yet " + "%3$s at %4$s is different : %5$s", 
 String.format("Element names do not match: %1$s versus %2$s", 
 private ImmutableList<XmlElement> initMergeableChildren() { ImmutableList.Builder<XmlElement> mergeableNodes = new ImmutableList.Builder<XmlElement>(); 
 // this will generate an error if the document contains any // placeholders. 
 private final ImmutableMap<String, String> mKeyValues; 
 private static final Pattern mPattern = Pattern.compile("([^\\$]*)\\$\\{([^\\}]*)\\}(.*)"); 
 // if this is a library, ignore the failure MergingReport.Record.Severity severity = mergeType == ManifestMerger2.MergeType.LIBRARY ? MergingReport.Record.Severity.INFO : MergingReport.Record.Severity.ERROR; xmlAttribute.addMessage(mergingReportBuilder, severity, 
public class PlaceholderHandlerTest extends TestCase { 
 final int maxExpectedExtraPackets = 7; 
 * Replaces all placeholders of the form ${name} with a tool invocation provided value 
 result.addNewPkgs(remote); 
 // assertEquals(new Long(-36), format.parseObject("36-")); 
<|del|> 
 // regular expression to recognize placeholders like @{name}, potentially surrounded by a 
 "06_inject_attributes_with_specific_prefix.xml", 
 // If we have more than one launchable activity, then prefer then one with CATEGORY_DEFAULT. 
 Location secondary2 = other.location != null ? other.location.getSecondary() : null; 
 * <b>NOTE: This is not public or final API; if you rely on this be prepared 
 * @param parser the parser to use 
import java.awt.Dimension; 
 !returnType.matchesName(ANDROID_CONTENT_SHARED_PREFERENCES_EDITOR)) { 
 } else if (type == null && next.toString().startsWith("Locale.")) { //$NON-NLS-1$ 
 s = new String(data, offset, length, Charsets.UTF_8); 
 public boolean isPublicNullaryConstructor(PsiMethod method) { if(!method.isConstructor()) { return false; } 
 super("defaultConfig", AndroidVariantContributor.PRODUCT_FLAVOR_FQCN); 
 Properties properties = getProperties(propertiesFile); 
 if (settingsFile != null) { settingsFile.removeModule(oldPath); settingsFile.addModule(newPath); } 
 private boolean myNotificationEnabled = true; 
 final Application app = ApplicationManager.getApplication(); app.invokeLater(new Runnable() { 
 private static final String TASK_NAME = "Gradle-aware Make"; 
 * Merges the two attributes values and returns the merged value. If the values cannot be 
 super(templateName, "Create a new " + templateName, AndroidIcons.Android); 
 private static final Set<String> EXCLUDED_CATEGORIES = ImmutableSet.of("Application", "Applications"); 
 return ArrayUtil.EMPTY_FILE_ARRAY; 
 // Transfer the storage volume to the new intent final StorageVolume storageVolume = getIntent().getParcelableExtra( StorageVolume.EXTRA_STORAGE_VOLUME); intent.putExtra(StorageVolume.EXTRA_STORAGE_VOLUME, storageVolume); 
 if (resTypeDir.isDirectory() && resourceType.equals(ResourceFolderType.getFolderType(resTypeDir.getName()))) { 
 Iterator<SourceProvider> sourceProviderIterator = 
<|del|> 
 @NotNull ResourceFolderType resourceType, @Nullable String name) { 
 @NotNull ResourceFolderType resourceType, @Nullable String name) { 
 if (resTypeDir.isDirectory() && ResourceFolderType.getFolderType(resTypeDir.getName()).equals(resourceType)) { 
 mySourceProvider = Iterators.getNext(IdeaSourceProvider.getSourceProvidersForFile(facet, invocationTarget, null).iterator(), null); 
 Iterator<SourceProvider> sourceProvidersIter = IdeaSourceProvider.getSourceProvidersForFile(facet, myTargetFile, null).iterator(); 
 @Nullable UpdateListener updateListener, 
 "(this can include source sets that do not yet exist on disk).<br>" + 
<|del|> 
 String applicationPackageName = gradleProject.computePackageName(); 
 File srcOut = new File(javaDir, packageName.replace('.', File.separatorChar)); myWizardState.put(ATTR_SRC_OUT, FileUtil.toSystemIndependentName(srcOut.getPath())); 
 File srcOut = new File(javaDir, packageName.replace('.', File.separatorChar)); myWizardState.put(ATTR_SRC_OUT, FileUtil.toSystemIndependentName(srcOut.getPath())); 
 return javaDirectories.isEmpty() ? null : javaDirectories.iterator().next(); 
 if (file.equals(getManifestFile())) { 
 if (file.equals(container.getParent())) { 
 public static boolean isContainedBy(@NotNull SourceProvider provider, @NotNull File targetFolder) { 
 if (FileUtil.filesEqual(provider.getManifestFile(), file)) { 
 if (parent != null && parent.isDirectory() && FileUtil.filesEqual(parent, file)) { 
 public boolean isContainedBy(@NotNull VirtualFile targetFolder) { 
 if (sourceProviderList.isEmpty() && defaultIdeaSourceProvider != null) { sourceProviderList.add(defaultIdeaSourceProvider); 
 @NotNull public static List<SourceProvider> getSourceProvidersForFile(@NotNull AndroidFacet facet, @Nullable VirtualFile targetFolder, @Nullable SourceProvider defaultSourceProvider) { 
 if (sourceProviderList.isEmpty() && defaultSourceProvider != null) { sourceProviderList.add(defaultSourceProvider); 
 } catch (FileNotFoundException fnfe) { // override policy doesn't have to exist so silently ignore } catch (IOException ioe) { Slog.w(TAG, "Skipping override policy " + DATA_MAC_PERMISSIONS, ioe); 
 if (mAwContents != null) { mAwContents.setLayerType(layerType, paint); } else { // AwContents is not initialized, need to set later mLayerPaint = paint; mNeedSetLayerType = true; } 
<|del|> 
 protected volatile int cachedSize = -1; 
 if (unknownFieldData != null) { for (int i = 0; i < unknownFieldData.size(); i++) { FieldData field = unknownFieldData.dataAt(i); size += field.computeSerializedSize(); } 
 new AttributeBasedNodeKeyResolver(SdkConstants.ANDROID_URI, AndroidManifest.ATTRIBUTE_GLESVERSION); 
 AttributeModel.newModel(AndroidManifest.ATTRIBUTE_REQUIRED) .setDefaultValue(SdkConstants.VALUE_TRUE) 
 AttributeModel.newModel(AndroidManifest.ATTRIBUTE_GLESVERSION) 
 private void fullFieldsCalc() { int millis = (int) (time % 86400000); long days = time / 86400000; 
 @NonNull private final Map<String,Set<String>> fieldMap = 
 * Transformer which inserts inserts annotation data (derived from source) into an existing * .jar file. For example it can be used 
 private boolean recordTypedefs(TypeDeclaration declaration) { SourceTypeBinding binding = declaration.binding; 
 return validate(mergingReport, xmlDocument.getRootNode()); 
 * 
 // associate context for items immediately within the android block (android.*) 
 * Common group names used to group Gradle-sync-related messages (by type/category) in the "Messages" tool window. These groups are also * displayed in the tool window. 
<|del|> 
import org.jetbrains.annotations.Nullable; import org.jetbrains.plugins.gradle.settings.GradleSettings; 
 return messages.getErrorCount() > messages.getMessageCount(VARIANT_SELECTION_CONFLICTS); 
 void queryFdn() { 
 CatLog.d(this, "User should clear text..show message forever"); 
 private void fullFieldsCalc() { int millis = (int) (time % 86400000); long days = time / 86400000; 
 } childrenKeys.put(childElement.getId(), childElement); 
 int fieldIndex = ((Field) element).getDexFieldIndex(); 
 catch (IOException exception) { handleImportException(project, exception); 
 throws IOException, ConfigurationException { 
 assertEquals(new Integer(4), Integer.getInteger("testIncInt", 4)); assertEquals(new Integer(4), Integer.getInteger("testIncInt", new Integer(4))); 
<|del|> 
<|del|>
 package com.android.manifmerger; 
 Dex.Section setIn = dex.open(annotationSetOffset); // annotation_set_item String annotationInternalName = InternalNames.getInternalName(annotationClass); 
 Category.CORRECTNESS, 2, Severity.ERROR, IMPLEMENTATION); 
 CatLog.d(this, "User should clear text..show message forever"); 
 CatLog.d(this, "User should clear text..show message forever"); 
 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { // Turn on Server Name Indication (SNI) socketfactory.setHostname(sslSocket, host); } 
 * Parses settings.gradle and obtains module locations. Paths are not validated (e.g. may point to non-existing location or to file * instead of directory) and may be relative or absolute. 
 @TargetApi(17) 
import com.google.common.collect.Lists; 
import javax.swing.JComponent; import javax.swing.JPanel; import javax.swing.JRadioButton; 
<|del|> 
<|del|> 
 private static final TObjectLongHashMap<String> myTimestampMap = new TObjectLongHashMap<String>(); 
 start = myTimestampMap.remove(key); 
 assertTrue("too many non-localhost packets on the sam UID", deltaTxOtherPackets + deltaTxOtherPackets < 20); 
 protected void run(@NotNull Result<Void> result) { 
 mLogger.verbose(annotatedDocument); 
 IAndroidTarget target = mTargetInfo.getTarget(); 
 return ImmutableList.copyOf(repositories); 
<|del|> 
<|del|> 
 @NonNls private static final String USE_IDEA_NEW_PROJECT_WIZARDS = "use.idea.newProjectWizard"; 
 * Contents of the "Project Structure" dialog, for Gradle-based Android projects, in Android Studio. 
<|del|> 
 return String.format("Sources for module '%1$s' were not found", Iterables.getFirst(projects, null)); 
 new Topic<GradleProjectImporter.Callback>("Project sync with Gradle", GradleProjectImporter.Callback.class); 
 myListModel.addElement("SDK Location"); 
 public String getTooltipFor(Object value) { if (value instanceof Module) { return new File(((Module)value).getModuleFilePath()).getAbsolutePath(); } 
 return 0.15f; 
 return "SDK Location"; 
 this.writer = writer; 
 for (int i = 0; i < tries; i++) { 
 inputStream.readFully(bytes); 
 static int $opt$testIfEq1(int a) { if (a + 1 == 43) { 
 final ActivityStack stack = mStackSupervisor.getFocusedStack(); 
 public Map<String, File> getDetectedModuleLocations() { 
<|del|> 
 setNetworkSelectionModeAutomatic((Message) ar.result); Rlog.d(LOG_TAG, "SET_NETWORK_SELECTION_AUTOMATIC: set to automatic"); 
 // prevent duplicate request which will push current PLMN to low priority Rlog.d(LOG_TAG, "SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore"); 
 mMemoryFile = new MemoryFile("Test File", 0); assertEquals(0, mMemoryFile.length()); 
 * @param path the path relative to the Android plugin root; starts with /icons 
 return Objects.hashCode(mSourceFile, mBuildToolsRevision); 
 boolean newItem = (item == null); 
 File projectDirPath = new File(toSystemDependentName(projectDir.getPath())); 
 stringBuilder.append('\t').append(attributeRecords.getKey()).append('\n'); 
 return PositionImpl.UNKNOWN; 
<|del|> 
 sb.append(root.getBounds(relativeto).toString().substring(Rectangle.class.getName().length())); 
 /** * Frees the BIO resource, but never closes the underlying InputStream. */ public void close() { 
 if (firstPortChar >= '0' && firstPortChar <= '9') { 
 if (firstPortChar >= '0' && firstPortChar <= '9') { 
 Messages.showErrorDialog("Please visit \n" + myUrl + "\n to retrieve this value", "Could Not Open Web Browser"); 
public final class OpenSSLBIOSink { 
 public static OpenSSLBIOSink create() { 
 private final ByteBuffer source; 
 public void reset() throws IOException { 
 synchronized (stateLock) { engineState = EngineState.CLOSED; } shutdownAndFreeSslNative(); 
 if (engineState == EngineState.CLOSED_INBOUND) { engineState = EngineState.CLOSED; } else { engineState = EngineState.CLOSED_OUTBOUND; } 
 public void release() { 
 public void release() { 
 newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */ 
 Iterables.addAll(menus, Splitter.on(',').trimResults().omitEmptyStrings().split(commaSeparatedMenus)); 
 String activity = StringUtil.notNullize(myRenderService.getConfiguration().getActivity()); 
 @Nullable final String namespace) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
public final class OpenSSLBIOSink { 
public final class OpenSSLBIOSource { 
public final class OpenSSLBIOSource { 
 * Implements the {@link SSLEngine} API using OpenSSL's non-blocking interfaces. 
<|del|> 
 /* This implementation doesn't use any delegated tasks. */ 
 + " onSSLStateChange"); 
<|del|> 
 return myStatus.severity != ERROR && !myValidating; 
 message = String.format("Unable to find sources for subproject %1$s.", 
 message = String.format("Unable to find sources for subprojects %1$s and %2$s.", upToTwoProjectNames(names), Iterables.getLast(names)); 
 String key = String.format("%1$s#%2$s", name, file == null ? "<null>" : file.getPath()); 
 // JTable may send a null value to the cell editor during initialization final boolean checked = module != null && module.isEnabled(); final String text = module == null ? "<No Module>" : module.name; 
 private int mHits = 0; 
 } else if ("android-library".equals(value)) { 
 * radix. The ASCII characters \u002d ('-') and \u002b ('+') are recognized * as the minus and plus signs. 
 if (StringUtil.isQuotedString(coordinateText)) { coordinateText = StringUtil.stripQuotesAroundValue(coordinateText); 
 @NotNull private static final String FRAME_LAYOUT_XML = 
 return new DomPullParser(frameLayoutDocument.getDocumentElement()).setViewCookies(viewCookies); 
 // Disallow signs if (firstDigit == '-' || firstDigit == '+') { 
 if (nanos != 0) { for (int i = remaining - 1; i < 9; i++) { nanos *= 10; } 
 if (nanos != 0) { for (int i = remaining - 1; i < 9; i++) { nanos *= 10; } 
 public static int parsePositiveInt(String string, int radix) throws NumberFormatException { 
<|del|> 
<|del|> 
 private static final Set<String> FILES_TO_PROCESS = ImmutableSet.of(SdkConstants.FN_SETTINGS_GRADLE, SdkConstants.FN_BUILD_GRADLE, SdkConstants.FN_LOCAL_PROPERTIES, SdkConstants.FN_GRADLE_WRAPPER_PROPERTIES); 
 return files; 
 * Sets the ClassMatch modifier. 
 public static List<AndroidLibrary> getDirectLibraryDependencies(@NotNull Variant variant) { 
 public Collection<String> getVariants() { 
 private boolean myActive = true; 
 return myActive; 
 textRenderer.append(myConflicts.size() == 1 ? "[Conflict]" : " [Conflicts]", attributes); 
 final SelectionConflict myConflict; boolean myFilter; 
 @NotNull final CheckedTreeNode myRoot; 
 boolean myVisible = true; 
<|del|> 
<|del|> 
<|del|> 
 public boolean isSelected() { return mySelected; 
 public void setSelected(boolean selected) { mySelected = selected; 
 "Accessibility in Custom Views", 
 "If a `View` that overrides `onTouchEvent` does not also implement `performClick` and " + "call it, the `View` may not handle accessibility actions properly.", 
 private AbstractInsnNode findMethodCallInstruction( 
 super(type, name, textValue, isFramework); 
<|del|> 
 public static void mergeQueuedMessages(@NotNull Project project) { 
 if (file.exists() && file.isFile()) { 
 } catch (NumberFormatException e) { 
 if (contact.getRawContacts() == null) { Log.w(TAG, "No raw contacts found for contact"); 
<|del|> 
 /** Whether this build type should generate a debuggable apk. */ 
 * Whether this build type is configured to generate an APK with debuggable native code. 
 * Whether the build type is configured to generate an apk with debuggable RenderScript code. 
 /** Whether ProGuard is enabled for this build type. */ 
<|del|> 
 assertEquals(1009835157000L + 123456789 / 1000000, t1.getTime()); 
package libcore.java.util; 
<|del|> 
<|del|> 
 @SuppressWarnings({"unused", "rawtypes"}) 
 ParcelingUtil.writeToParcel(getClass(), this, out); 
 @SuppressWarnings("unchecked") static <T extends MessageNano> T createFromParcel(Parcel in) { 
 static <T extends MessageNano> void writeToParcel(Class<T> clazz, MessageNano message, 
 @SuppressWarnings({"unused"}) public static final Creator<ParcelableExtendableMessageNano<?>> CREATOR = new Creator<ParcelableExtendableMessageNano<?>>() { 
 return myNotificationManager.getMessageCount(null, NOTIFICATION_SOURCE, NotificationCategory.ERROR, GRADLE_SYSTEM_ID); 
<|del|> 
 public static List<File> getTemplatesFromDirectory(@NotNull File externalDirectory, boolean recursive) { 
 * A step that lets you select a Github repository to clone. * TODO: Save previously used URLs * TODO: Allow selection of branches 
 if (!unzippedDir.exists() || (System.currentTimeMillis() - unzippedDir.lastModified()) > TIMEOUT) { 
 returnValue.errorMessage = "Could not download specified project from Github. Check the URL and branchname.\n\n" + e.getMessage(); 
 if (new File(directory, FN_BUILD_GRADLE).exists() || new File(directory, FN_SETTINGS_GRADLE).exists()) { 
 if (file.isDirectory() && recursive) { 
 temporaryCoverageCopy, new File(coverageDir, FILE_COVERAGE_EC).getPath()); device.executeShellCommand("rm " + temporaryCoverageCopy, outputReceiver, 30, TimeUnit.SECONDS); 
 boolean isTestCoverageEnabled(); 
 .add("testCoverageEnabled", mTestCoverageEnabled) 
 String message = "WebView.addJavascriptInterface should not be called"; 
 name = context.getString(R.string.unknown); 
 // Layout of event log entry received from Android logger. // see system/core/include/log/logger.h 
 return mBuffer.getInt(offset); 
 mBuffer.position(offset + DATA_OFFSET); // Just after the tag. 
 assertValidationWarning("A non-empty directory already exists at the specified project location. " + "Existing files may be overwritten. Proceed with caution."); 
 ClassLoader classLoader = ResourceLeakageDetector.class.getClassLoader(); 
<|del|> 
<|del|> 
 if (imageUri == null) { throw new IllegalArgumentException("Image URI must not be null"); } if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) { 
<|del|> 
 (currElapsedTime - mLastWriteElapsedTime.get()) < FILE_WRITE_INTERVAL) { 
 if (dayChanged || forceWriteHistoryStats) { 
<|del|>
 return Objects.toString(this); 
 return Objects.toString(this); 
 if (!src.isAccessible() || !isAccessible()) { throw new IllegalStateException("buffer is inaccessible"); 
 public boolean isFreed() { return address == 0; 
 if (!block.isAccessible()) { 
 protected final long size; private boolean accessible; 
 throw new IllegalStateException("buffer is inaccessible"); 
 throw new IllegalStateException("buffer was freed"); 
 if (uri.toString().startsWith("content://media/external/")) { 
<|del|> 
public class GenerateEndpointAction extends AnAction { 
 String className = String.valueOf(Character.toLowerCase(classType.charAt(0))); if(classType.length() > 1) { className += classType.substring(1); } 
 private Toast mLongPressToast; 
 mLongPressToast = Toast.makeText(getActivity(), R.string.toast_text_copied, Toast.LENGTH_SHORT); 
 mLongPressToast.show(); 
import libcore.io.DropBox; import libcore.util.Base64; 
 void writeTo(T value, CodedOutputByteBufferNano output) throws IOException { if (repeated) { writeRepeatedData(value, output); } else { writeSingularData(value, output); } } protected void writeSingularData(Object value, CodedOutputByteBufferNano out) { 
 context.report(ISSUE, attribute, context.getLocation(attribute), message, null); 
 public Collection<String> getApplicableAttributes() { return Collections.singletonList(PROTECTION_LEVEL); 
 * @param mustCloseOut true if closing this stream should close the wrapped stream 
 * Tests for {@link Base64InputStream}. 
 * Tests for {@link Base64OutputStream}. 
 /** Specialized interface for detectors that scan resource folders (the folder directory * itself, not the individual files within it */ 
 private static final byte[] PKCS7_MARKER = "-----BEGIN PKCS7" .getBytes(StandardCharsets.US_ASCII); 
 private static final byte[] PKCS7_MARKER = "-----BEGIN PKCS7" .getBytes(StandardCharsets.US_ASCII); 
<|del|> 
 } } catch (InterruptedException ex) { threadPool.shutdownNow(); throw new RuntimeException("A thread has been interrupted."); 
 incognito.setEnabled(!(mActivity.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.KITKAT)); 
 public boolean mDexOptNeeded = true; 
 public void run() { 
 if (fqcn.equals(PREFERENCE_ACTIVITY)) { 
 private final CRLReason reason; 
 private final X500Principal authority; 
 // Maps may not be serializable, so serialize it manually. private transient Map<String, Extension> extensions; 
 // Maps may not be serializable, so serialize it manually. private transient Map<String, Extension> extensions; 
 return Collections.unmodifiableMap(extensions); 
 return (Date) revocationDate.clone(); 
 * Tests whether the given mode is a block device. 
 * {@code struct passwd} from {@code &lt;pwd.h&gt;}. 
 * Corresponds to C's {@code struct pollfd} from {@code &lt;poll.h&gt;}. 
 private static final String APP_ENGINE_PLUGIN = "appengine"; 
 headerKeysAndValues[CONTENT_TYPE_VALUE_IDX] = "text/html"; 
 headerKeysAndValues[CONTENT_TYPE_VALUE_IDX] = "text/html"; 
 for (int i = 0; i < headerKeysAndValues.length; i += 2) { 
 return headerFields; 
 return getHeaderField(CONTENT_TYPE_KEY_IDX); 
 return getHeaderField(CONTENT_TYPE_KEY_IDX); 
<|del|> 
 assertEquals(null, Character.UnicodeBlock.of((char) 0x089F)); } 
 // Cannot add ZONE_OFFSET to time as it might overflow int zoneOffset = timeZone.getRawOffset(); 
 // The content-type header field is always at position 0. return getHeaderField(0); 
 int elapsedTime = 0; // elapsed time in seconds 
 // update elapsed time in seconds elapsedTime++; indicator.setText(String.format("Recording...%1$d %2$s elapsed", elapsedTime, StringUtil.pluralize("second", elapsedTime))); 
<|del|> 
 * buffer was made inaccessible (e.g. freed) and should not be used. 
<|del|> 
 request, new MovedError(networkResponse)); 
 if ((statusCode < 200 || statusCode > 299)) { 
 assertCannotParse(Locale.US, fmt, date); 
 int width = totalWidth - RIGHT_GUTTER_SIZE; 
 int heightToDistribute = getBounds().height - INTER_SECTION_SPACING * (myDistributions.size() - 1) - TOP_PADDING; 
 Map<String, VirtualFile> modules = Maps.newHashMap(); 
 private static final ModuleImporter NONE = new ModuleImporter() { 
 super("From Github", "Create a new object from a GitHub repository", GithubIcons.Github_icon); 
<|del|> 
 if (recursive) { File[] files = externalDirectory.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { templates.addAll(getTemplatesFromDirectory(file, true)); } 
 getWindow().setMinimumSize(new Dimension(600, 480)); } else { assert ApplicationManager.getApplication().isUnitTestMode(); 
 setErrorHtml("That is not a GitHub URL"); 
 super("From GitHub", project); 
 if (branch == null || branch.trim().isEmpty()) { 
 if (!unzippedDir.exists() || unzippedDir.lastModified() == 0 || (System.currentTimeMillis() - unzippedDir.lastModified()) > TIMEOUT) { 
 if (recursive) { File[] files = directory.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { samples.addAll(findSamplesInDirectory(file, true)); } 
 if (sourceType == AndroidSourceType.MANIFEST) { 
 @NotNull ViewSettings viewSettings, 
 if (statusCode < 200 || statusCode > 299) { 
 Assert.assertEquals(user3.getEmail(), users.getActiveUser().getEmail()); 
 Assert.assertFalse(users.setActiveUser(user2.getEmail())); Assert.assertTrue(users.setActiveUser(user1.getEmail())); 
 synchronized (this) { 
 synchronized (this) { 
 synchronized (this) { return activeUser; } 
 synchronized (this) { return allUsers.size(); } 
 synchronized (this) { return activeUser != null; } 
<|del|> 
<|del|> 
 if (appEngineModel != null) { 
 private static void addAppEngineGradleFacet(IdeaAppEngineProject ideaAppEngineProject, Module appEngineModule) { 
 } 
<|del|> 
 private final Locale mDefaultLocale; private final TimeZone mDefaultTimeZone; private final String mUserHome; private final String mJavaIoTmpDir; private final HostnameVerifier mHostnameVerifier; private final SSLSocketFactory mSslSocketFactory; 
 File root = findTemplatesDirInPluginJar(CLIENT_TEMPLATES_DIR); 
 public BackendModuleWizardStep(Project project, NewModuleWizardState wizardState, TemplateWizardStep.UpdateListener updateListener, Icon sidePanelIcon) { 
 if (myUpdating) { return; } 
 /** * Returns a copy of the map of the current logged in users. * @return Copy of current logged in users. */ 
<|del|> 
 // TODO: Send message out of changed user 
 // TODO: Send message out of changed user 
 // TODO: Send message out of changed user 
 // TODO: Send message out of changed user 
 private static final String MERGE_BLOB_VERSION = "2"; 
 * Returns the type of View. * @see ViewType 
<|del|> 
 super("From GitHub", "Create a new object from a GitHub repository", AndroidIcons.Wizards.GithubIcon); 
 super("From GitHub", project); 
 "Downloading project from GitHub", 
 public void setUp() throws Exception { super.setUp(); 
 public void tearDown() throws Exception { try { mHandlerThread.quitSafely(); } finally { super.tearDown(); } 
 boolean duplicatesPrevious = false; 
<|del|> 
 // ICU and the RI disagree about character 0x180e. Remove this special case if this changes // or Android decides to follow ICU exactly. 
 String instructionSetDescription = builder.toString(); 
 application.invokeAndWait(promptToLoginTask, ModalityState.defaultModalityState()); 
 * wasn't signed in or canceled signing in. 
 * Loads an image given its filename (with its extension), caches it using the given 
 avdTabItem.setToolTipText(avdTabItem.getText()); 
 devTabItem.setToolTipText(devTabItem.getText()); 
 displayProjectSetupMessages(); 
 return EXT_PRO; 
 consumer.consume(ProguardFileType.INSTANCE, ProguardFileType.EXT_PRO); 
 return "ProGuard File"; 
 VirtualFile vf = project.isDefault() ? null : project.getBaseDir().findChild(SdkConstants.FN_BUILD_GRADLE); 
 private static final String DEFAULT_PROPERTIES_FILE = PROPERTIES_FILE_PREFIX + PROPERTIES_FILE_SUFFIX; 
 FileInputStream stream = null; try { stream = new FileInputStream(file); mProperties.load(stream); } finally { IoUtils.closeQuietly(stream); } 
 // Avoiding initialization of TestKeyStore in the static initializer: it breaks CTS tests // by causing a NetworkOnMainThreadException. 
 public BuildFilePanel(@NotNull Project project, @NotNull String moduleGradlePath) { 
 LOG.info("Unable to find Gradle build file for module " + moduleGradlePath); 
 return new AndroidVersion(api - 1, apiOrPreviewName); 
 } else { unresolved.add(getUnresolvedDependencyName(library)); } 
 private static TestKeyStore sTestKeyStore; 
 private static TestKeyStore sTestKeyStore; 
 String getApiString(); 
 map.put(PH_TARGET_SDK_VERSION, mTargetSdkVersion != null ? mTargetSdkVersion : map.get(PH_MIN_SDK_VERSION)); 
 logger.info("Skipping device '%1$s', due to different API preview '%2$s' and '%3$s'", 
 clonedFlavor.mMinSdkVersion = minSdkVersionOverride != null ? minSdkVersionOverride : 
 clonedFlavor.mTargetSdkVersion = targetSdkVersionOverride != null ? targetSdkVersionOverride : 
 !name.equals(TAG_THUMB) && !name.equals(TAG_ICONS) && !name.equals(TAG_DEPENDENCY) && !name.equals(TAG_FORMFACTOR)) { 
<|del|> 
 String homePath = System.getProperty("user.home"); parentPath = homePath == null ? new File("/") : new File(homePath); 
 public int getSimulatedPlatformVersion() { return mSimulatedPlatformVersion; 
 myAddActivityPath = new AddAndroidActivityPath(null, ImmutableMap.<String, Object>of(), getDisposable()); 
 mySelectedDistribution = myDistributions.get(i); 
 } catch (NumberFormatException e) { 
 apnIpType = APN_IPV6; 
 "Fragment injection gives anyone who can send your PreferenceActivity an intent the " + "ability to load any fragment, with any arguments, in your process.", 
 EnumSet.of(Scope.MANIFEST, Scope.JAVA_FILE))) .addMoreInfo("http://securityintelligence.com/" + "new-vulnerability-android-framework-fragment-injection/#.U4eyrWRdWPc"); 
<|del|> 
 boolean loggedIn = state.logIn(message); IGoogleLoginUpdateUser callback = new IGoogleLoginUpdateUser() { @Override public void updateUser() { uiFacade.notifyStatusIndicator(); } }; 
 for (String scope : storedScopesString.split(DELIMITER)) { storedScopes.add(scope); 
 Splitter splitter = Splitter.on(DELIMITER).omitEmptyStrings(); for (String aUser : splitter.split(allUsersString)) { allUsers.add(aUser); 
 Splitter splitter = Splitter.on(DELIMITER).omitEmptyStrings(); for (String aUser : splitter.split(allUsersString)) { allUsers.add(aUser); 
 private static void addUser(String user) { Preferences prefs = getPrefs(); 
 return; } 
 private final String email; private final String name; private final Credential credential; private final Image image; 
 private final GoogleLoginState googleLoginState; 
 return activeUser; 
 return activeUser != null; 
public class GoogleLoginCopyAndPasteDialog extends DialogWrapper { 
 if(message != null) { setTitle(message); } else { setTitle(TITLE); } 
 return mainPanel; 
<|del|> 
<|del|> 
 public GoogleLoginToolbarButton() { 
 GoogleLoginUsersPanel usersPanel = new GoogleLoginUsersPanel(); ComponentPopupBuilder popup = JBPopupFactory.getInstance().createComponentPopupBuilder(usersPanel, usersPanel.getList()); 
 private static class MyClosePopupChecker implements Computable<Boolean> { 
<|del|> 
 private final Color ACTIVE_COLOR = JBColor.LIGHT_GRAY; 
public class UsersListItem { private final User myUser; 
<|del|> 
<|del|> 
 public boolean isActiveUser() { 
 users.addUser(user1); Assert.assertEquals(user1.getEmail(), users.getActiveUser().getEmail()); users.removeActiveUser(); Assert.assertNull(users.getActiveUser()); Assert.assertFalse(user1.isActive()); 
 System.err.println("Error: abi " + abi + " not supported on this device."); 
 super("Add information to your new project", null, null, disposable); 
<|del|> 
 private static class BrowseFolderListener extends ComponentWithBrowseButton.BrowseFolderActionListener<JTextField> { 
 * Returns the version of the target. This is guaranteed to be non-null. 
 File gradlewFile = new File(projectRoot, GradleUtil.GRADLE_EXECUTABLE_NAME); 
 LOG.error("Could not find gradle wrapper. Command line builds may not work properly."); 
 * Returns the original application ID before any overrides from flavors. * If the variant is a test variant, then the application ID is the one coming from the 
 * Returns the application ID for this variant. This could be coming from the manifest or * could be overridden through the product flavors and/or the build type. * @return the application ID 
<|del|> 
 * Returns the application id override value coming from the Product Flavor and/or the 
 if (DEBUG) Log.d(TAG, "call native_agps_data_conn_open: apnName, " + apnName + "; apnIpType, " + apnIpType); 
 if (DEBUG) Log.d(TAG, "bad ipaddress: " + ipAddr); 
 native_agps_data_conn_open(mAGpsApn, mApnIpType); 
 native_agps_data_conn_open(mAGpsApn, mApnIpType); 
 } } catch (SQLiteException e) { Log.e(TAG, "SQLiteException while querying on APNs"); } catch (Exception e) { Log.e(TAG, "Error encountered on APN query" + e); 
<|del|> 
 String reason = String.format("AVD vendor (%1$s) != AVD target (%2$s)", avdTarget.getVendor(), projectTarget.getVendor()); 
 String reason = String.format("AVD vendor (%1$s) != AVD target (%2$s)", avdTarget.getVendor(), projectTarget.getVendor()); 
 String.format("AVD target name (%1$s) != Project target name (%2$s)", avdTarget.getName(), projectTarget.getName()); 
 append("Yes"); 
 Sets.newHashSet("AES", "DES", "DESede"); //$NON-NLS-1$ 
 Template activityTemplate = templateEntry.getTemplate(); 
 * Copyright 2011 the original author or authors. 
 * Copyright 2011 the original author or authors. 
 * Copyright 2011 the original author or authors. 
 private SensorManager mSensorManager; private Sensor mSensorSignificantMotion; private final TriggerListener mTriggeredListener = new TriggerListener(this); private long mTestStartTimestamp; 
 appendText("Click 'Next' and " + instructions); waitForUser(); 
 if (vibrate) { vibrateDevice(VIBRATE_DURATION_MILLIS); } 
 Thread.sleep(1000); 
 protected void logFail(String message) throws Throwable { throw new Exception("FAIL: " + message); } 
 private GoogleLogin() { this.clientInfo = getClientIdAndSecretFromExtensionPoints(); this.uiFacade = new AndroidUiFacade(); this.users = new Users(); this.dataStore = new AndroidPreferencesOAuthDataStore(); 
 getInstance().logIn(message); } else { throw new InvalidThreadTypeException("promptToLogin"); 
 for (String scope : allUsersString.split(DELIMITER)) { allUsers.add(scope); 
 final URL newUrl = url; ApplicationManager.getApplication().executeOnPooledThread(new Runnable() { @Override public void run() { Image image = Toolkit.getDefaultToolkit().getImage(newUrl); pictureCallback.setProperty(image); } }); 
 * Returns a {@link Credential} object for the fake user. 
 defaultIcon = IconLoader.getIcon(DEFAULT_AVATAR); 
<|del|> 
<|del|> 
 panel.add(nameLabel); 
<|del|>
 ps = new PrintStream(outFile, "UTF-8"); 
 } catch (Exception e) { // Make sure the test log includes exceptions from all parties involved. 
 // Make sure the test log includes exceptions from all parties involved. Log.w(TAG, "Server failed", e); throw e; 
 } catch (Exception e) { // Make sure the test log includes exceptions from all parties involved. 
<|del|> 
 + "new-vulnerability-android-framework-fragment-injection"); 
 CredentialedUser activeUser = GoogleLogin.getInstance().getActiveUser(); if(activeUser == null) { return; } 
public class User { private String name; private Image image; 
 private final CredentialedUser myUser; 
public final class MessageFormat { 
 // TODO: Re-enable DH test. http://b/5513723. 
 @NonNull private String getRunOptions() { 
 public void setRunOptions(@NonNull String options) { 
 String[] segments = line.split("\\|", SEGMENT_COUNT); if (segments.length == SEGMENT_COUNT) { 
<|del|> 
 public int createUserConfig(int userId) { StringBuilder builder = new StringBuilder("mkuserconfig"); 
 if (!dependency.startsWith(SdkConstants.GRADLE_PLUGIN_NAME) || !checkGradlePluginDependency(context, gc, cookie)) { 
 // event should be reported to the host in a timely fashion. 
 * requested first and request will be cancelled * @param vibrate If TRUE, vibration will be concurrent with the test 
<|del|> 
 HashCode hashCode = hashFunction.hashString(inputFile.getAbsolutePath(), Charsets.UTF_16LE); 
 * Binds this channel to the given local socket address. If the {@code localAddr} is set * to {@code null} the socket will be bound to an available local address on any free port of 
 private NetworkInterface ipv6NetworkInterface; 
 RunResult result = new WriteCommandAction.Simple(project) { 
 @NotNull private final List<String> myTaskNames; 
 if (Projects.isGradleProject(myProject)) { AndroidGradleProjectData.save(myProject); } 
 ImmutableSet.of(File.class, Boolean.class, String.class, Collection.class, Map.class, Set.class); 
<|del|> 
 AndroidGradleProjectData data = createFrom(project); if (data != null) { File file = getProjectStateFile(project); file.getParentFile().mkdirs(); data.saveTo(file); } 
 LOG.info("Error while saving persistent state from project", e); 
<|del|> 
 // TODO: Once the application module has a model this needs to be updated. data.addFileDependency(rootDirPath, GradleUtil.getGradleBuildFile(module)); data.addFileDependency(rootDirPath, GradleUtil.getGradleSettingsFile(rootDirPath)); 
 // TODO: Once the application module has a model this needs to be updated. data.addFileDependency(rootDirPath, GradleUtil.getGradleBuildFile(module)); data.addFileDependency(rootDirPath, GradleUtil.getGradleSettingsFile(rootDirPath)); 
<|del|> 
 throw new IllegalStateException("Unsupported generic type: " + genericClass.getCanonicalName()); 
 static boolean isSupported(@NotNull Class<?> clazz) { 
 else { key = file.getAbsolutePath(); } myFileChecksums.put(key, createChecksum(vf)); 
 LOG.warn("Error while trying to save the project state."); 
<|del|> 
<|del|>
 FormFactorApiComboBox.loadInstalledVersions(); 
 private transient boolean validCountry = false; 
 if (validCountry) { 
 if (volume.isMassStorageDevice()) { 
 isUSB = volume.isMassStorageDevice(); 
 /** * Perform the action represented by this operation. Returns true if the thread should * continue. */ 
 return true; 
 final Object lock, Map<Operation, Double> frequencyMap) 
 if (!myGradlePluginVersion.equals(SdkConstants.GRADLE_PLUGIN_MINIMUM_VERSION)) { 
 public static boolean testReflectFieldGetFromAttachedNativeThreadField; 
 private static final boolean ENABLED = !Boolean.getBoolean("studio.disable.synccache"); 
 private static boolean ENABLED = !Boolean.getBoolean("studio.disable.synccache"); 
 if (!(o instanceof NamedObject)) return false; 
 mTargetSdkVersion = AndroidModuleInfo.get(myFacet).getTargetSdkVersion(); 
 myRefreshingAlarm.addRequest(myUpdateRequest, REFRESH_INTERVAL_MS); 
 refreshTable(); 
 panel.setBackground(ANDROID_NPW_TITLE_COLOR); 
 // find "build" folder. 
<|del|> 
 if (path != null && !isDotGradleFolder(path)) { 
<|del|> 
 public void executeTasks(@NotNull final List<String> gradleTasks, @NotNull final List<String> commandLineArguments) { 
 @NotNull List<String> commandLineArguments, 
 boolean useGradleToSign = facets.get(0).isGradleProject(); 
 if (myFacet.isGradleProject()) { 
 if (gradleFacet == null) { 
 Set<String> buildTypes = myIdeaAndroidProject == null ? Collections.<String>emptySet() : myIdeaAndroidProject.getBuildTypes(); for (String buildType : buildTypes) { 
 myApkPathField.setText(ourLastApkFolder.getAbsolutePath()); 
 public final String keyStoreFilePath; public final char[] keyStorePassword; public final String keyAlias; public final char[] keyPassword; 
<|del|> 
 productFlavors = Lists.newArrayList(mergedFlavors); Collections.sort(productFlavors); 
<|del|> 
 * Copyright (C) 2014 The Android Open Source Project 
<|del|> 
 public static final JBColor ANDROID_NPW_TITLE_COLOR = new JBColor(0x689F38, 0xFFFFFF); public static final JBColor ANDROID_NPW_HEADER_COLOR = new JBColor(0x689F38, 0x356822); 
 return UIUtil.isUnderDarcula() ? myDarkIcon : myLightIcon; 
abstract class ChunkHandler { 
 * @param data the data containing the allocation file. 
 * @param data the data containing the allocation file. 
<|del|> 
 byte[] src = new byte[len]; byte[] dst = new byte[len]; 
 short[] src = new short[len]; short[] dst = new short[len]; 
 int[] src = new int[len]; int[] dst = new int[len]; 
 long[] src = new long[len]; long[] dst = new long[len]; 
 float[] src = new float[len]; float[] dst = new float[len]; 
<|del|> 
<|del|> 
 if (mOptionalFeatures.contains(Invoker.Feature.KEEP_INTERMEDIARY_STAGES)) { 
 return createNotification(project, (ExternalSystemException)cause); 
 return computeSingularSerializedSize(value); 
 Extension<?, ?> ext = (Extension<?, ?>) obj; 
 IoUtils.closeQuietly(handle); 
<|del|> 
 ClientData.IAllocationTrackingHandler handler = ClientData.getAllocationTrackingHandler(); 
 public static void setAllocationTrackingHandler(@NonNull IAllocationTrackingHandler handler) { 
 AllocationInfo(int allocNumber, String allocatedClass, int allocationSize, 
 * @param data the data containing the encoded allocations. * See {@link AllocationsParser#parse(java.nio.ByteBuffer)} for parsing this data. 
 ByteBuffer data = putAllocationInfo(new String[0], new String[0], new String[0], new int[0][], new short[0][][]); assertEquals(0, AllocationsParser.parse(data).length); 
 } 
 boolean generateSources = false; projectImporter.importProject(projectName, projectRoot, generateSources, new GradleSyncListener() { 
<|del|> 
 return clazz.cast(data.getValue()); } else if (data.getBytes().length != 0) { 
 return null; 
 private byte[] bytes; private Extension<?, ?> extension; private Object value; 
 private byte[] bytes; private Extension<?, ?> extension; private Object value; 
<|del|> 
 if (bytes != null) { 
 * version. 
 * An arraycopy variant that applies when both input arguments are compatible object arrays. 
 if (src.getClass() != dst.getClass() || dst.getClass() != Object[].class || 
<|del|> 
<|del|>
 private static final int FILE_LENGTH = 0xC000000; // 192 MB 
 * Change the matcher's input after modifying the contents of the buffer. * The current implementation of Matcher causes a copy of the buffer to be taken. 
 * Change the matcher's input after modifying the contents of the buffer. * The current implementation of Matcher causes a copy of the buffer to be taken. 
 Thread.sleep(100); 
 throw new RSRuntimeException("Loading of ScriptIntrinsic failed."); 
 String path = c.getString(c.getColumnIndex(MediaColumns.DATA)); long id = c.getLong(c.getColumnIndex(MediaColumns._ID)); 
 String path = c.getString(c.getColumnIndex(MediaColumns.DATA)); long id = c.getLong(c.getColumnIndex(MediaColumns._ID)); 
 MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI, null, Thumbnails.IMAGE_ID + "=?", new String[] { Long.toString(removedId) }, null); 
 path = c.getString(c.getColumnIndex(MediaColumns.DATA)); 
<|del|> 
 for (String order: new String[] { " ASC", " DESC" }) { 
 public static void putString(@NonNull ByteBuffer buf, @NonNull String str) { 
 if (ResourceFolderManager.EXPLODED_AAR.equals(pathSegments.get(i))) { 
 * Check whether the Scanner will exhaust all heap memory when parsing a * large file. 
 private static final int FILE_LENGTH = 192 * 1024 * 1024; // 192 MB 
<|del|> 
 for (int i = 0; i < 100; i++) { Integer object = objArray[i]; 
 new MapTestSupport(smallMap).runTest(); 
 new Artifact(newMavenArtifactInfo("org.slf4j", "slf4j-android", "1.7.+"), "slf4j"), 
 new Artifact(newMavenArtifactInfo("org.slf4j", "slf4j-android", "1.7.+"), "slf4j"), 
 new Artifact(newMavenArtifactInfo("com.squareup.okhttp", "okhttp", "2.0.+"), "okhttp"), 
 new Artifact(newMavenArtifactInfo("com.squareup.okhttp", "okhttp", "2.0.+"), "okhttp"), 
 obj = null; System.gc(); 
 Runtime.getRuntime().gc(); 
 fos.write(entry.data); fos.getFD().sync(); 
 fos.write(entry.data); fos.getFD().sync(); 
 if (token == 0 && cookie != null && cursor != null && !cursor.isClosed() && cursor.getCount() >= 100) { 
<|del|> 
 } if (bytes != null && other.bytes != null) { // If both objects have byte arrays compare those directly. return Arrays.equals(bytes, other.bytes); } 
<|del|> 
 int max = listModel.getSize() < MAX_VISIBLE_ROW_COUNT ? listModel.getSize() : MAX_VISIBLE_ROW_COUNT; for(int i = 0; i < max; i++){ 
 // Check that the list of locales doesn't contain any of the // "tl" variants. They should've been converted to "fil" // locales. 
 private final PkgType mType; 
<|del|> 
<|del|> 
 Assert.assertEquals("Triggered event type is not Significant Motion", event.sensor.getType(), Sensor.TYPE_SIGNIFICANT_MOTION); 
 private void beep() { 
 private static int sNumPassedTests = 0; 
 // use vibrator to ensure significant motion is not triggered 
 // use vibrator to ensure significant motion is not triggered 
 mSensorManager.requestTriggerSensor(mTriggeredListener, mSensorSignificantMotion); 
 if (mSensorManager != null && mSensorSignificantMotion != null) { 
 if (lp != vlp) { 
 public boolean applyTo(Project project) { 
 * Copyright (C) 2014 The Android Open Source Project 
 String msg = "Your Android Studio installation is corrupt and will not work properly. " + 
 String title = "Corrupt Installation"; 
 String msg = String.format("You are using an unsupported version of Gradle. Please use version %1$s.", GRADLE_LATEST_VERSION); 
 mHandler.sendEmptyMessage(DISABLE_BUTTONS); mHandler.sendMessageDelayed(mHandler.obtainMessage(ENABLE_BUTTONS), 1000); 
 mHandler.sendEmptyMessage(DISABLE_BUTTONS); mHandler.sendMessageDelayed(mHandler.obtainMessage(ENABLE_BUTTONS), 1000); 
<|del|> 
 List<String> parameters = LintUtils.getFormattedParameters(ERROR_MESSAGE_FORMAT, errorMessage); if (parameters.size() == 2 && group <= 2) { return parameters.get(group - 1); 
 if (task.getTopActivity() == null) { // All activities in task are finishing. 
 public static final String GRADLE_MINIMUM_VERSION = "1.12"; public static final String GRADLE_LATEST_VERSION = "1.12"; 
<|del|> 
 public void testPackageNameDeriverSantizesCompanyDomainKey() throws Exception { 
<|del|> 
 String srcMainPath = modulePath + 
 String srcMainPath = modulePath + 
 return !mRevisions.isEmpty() && mRevisions.get(mRevisions.size() - 1).isPreview(); 
 public Locale getLocaleClass() { 
 private static Locale constructLocaleFromString(String localeStr) { 
 private static boolean disableIntrinsic = false; 
<|del|> 
 List<SortKey> keys = sortKeys == null ? new ArrayList<SortKey>() : new ArrayList<SortKey>(sortKeys); // Does secondary sorting (breaks ties) on allocation size 
<|del|> 
 updateSwitchPreference(mBtHciSnoopLog, SystemProperties.getBoolean( BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false)); 
 * Used by the reference processor to determine whether or not the referent * can be immediately returned. Because the referent might get swept during * GC, the slow path, which passes through JNI, must be taken. 
<|del|> 
 private String myErrorMessage; 
 private final String mName; 
 HashMap<Long, String> mClassNames = new HashMap<Long, String>(); 
 return stream.readLong(); 
 root.setHeap(mState.mCurrentHeap); mState.addRoot(root); 
 * Copyright (C) 2014 Google Inc. 
 private static Map<Integer, Type> sTypeMap = Maps.newHashMap(); 
 private static Map<Integer, Type> sTypeMap = Maps.newHashMap(); 
 return sTypeMap.get(id); 
 return this == OBJECT ? sIdSize : mSize; 
 private final Instance instance; 
 String libraryCoordinate = urlManager.getLibraryCoordinate(highest.getArtifactId(), null, false /* No previews */); GradleCoordinate available = GradleCoordinate.parseCoordinateString(libraryCoordinate); 
 private static final RangeMap<Integer, String> SUPPORT_LIBRARY_EXTENSIONS = ImmutableRangeMap.<Integer, String>builder() 
 private static final Map<String, RepositoryLibrary> EXTRAS_REPOSITORY = new ImmutableMap.Builder<String, RepositoryLibrary>() 
<|del|> 
 private static final Predicate<GradleCoordinate> IS_PREVIEW = new Predicate<GradleCoordinate>() { 
 boolean showLoginButton = Boolean.parseBoolean(System.getProperty(SHOW_LOGIN_BUTTON_PROPERTY)); 
 public void test_CSV_inputs() { int totalTests = 0; for (String csvFileName : csvFileNames) { String line = ""; BufferedReader br = null; 
 private static final Predicate<GradleCoordinate> IS_NOT_PREVIEW = new Predicate<GradleCoordinate>() { 
 * Standard single-input test framework for csv math tests 
 tableColumn.setPreferredWidth(Integer.parseInt(columnWidths[column.ordinal()])); 
<|del|> 
 } return defaultWidths; 
 private static final String COLUMN_ORDER_PROPERTY = "android.allocationsview.column.ordering"; private static final String COLUMN_WIDTH_PROPERTY = "android.allocationsview.column.widths"; 
 int remainingWidth = myAllocationsTable.getWidth() - cumulativeWidth; if (remainingWidth > 0) { defaultWidths[Column.ALLOCATION_SITE.ordinal()] = Integer.toString(remainingWidth); 
<|del|> 
 Object enumValue = clazz.getStaticField(Type.OBJECT, "NEW").getValue(); assertTrue(enumValue instanceof ClassInstance); ClassInstance instance = (ClassInstance) enumValue; 
 T result = clazz.cast(Array.newInstance(clazz.getComponentType(), resultSize)); 
 initialCapacity = idealIntArraySize(initialCapacity); 
 int i = binarySearch(fieldNumber); 
 return mData[i]; 
 int i = binarySearch(fieldNumber); 
 return arrayEquals(mFieldNumbers, other.mFieldNumbers, mSize) && arrayEquals(mData, other.mData, mSize); 
 final int width = getWidth(); if (width == 0) { 
 final int cellX = getColumnOffset(column, columns, componentWidth); final int width = getColumnOffset(column + 1, columns, componentWidth) - cellX; 
<|del|> 
 * option will be removed on a future release of CTS. TODO: * remove this option 
<|del|> 
 mSensorStepCounter = mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER); if (mSensorStepCounter != null) { 
 mSensorStepCounter = mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER); if (mSensorStepCounter != null) { 
 + " seconds", compareTimestamps() < MAX_TOLERANCE_STEP_TIME_LATENCY_SECONDS); 
 + " steps while " + mStepsReported + " were expected (within " + tolerance + " steps)"; 
 + " steps while " + mStepsReported + " were expected (within " + tolerance + " steps)"; 
 mInitialStepCount = steps; 
 Assert.assertEquals("Incorrect value[0] in step detector event", event.values[0], 1.0f); 
 reportLine.append("--"); 
 reportLine.append("--"); 
 reportLine.append("--"); 
 public boolean allocatedClassMatches(@NonNull String pattern, @NonNull Locale locale) { return mAllocatedClass.toLowerCase(locale).contains(pattern.toLowerCase(locale)); 
 @NonNull public List<String> getMatchingStackFrames(@NonNull String filter, boolean fullTrace, @NonNull Locale locale) { filter = filter.toLowerCase(locale); List<String> matchingFrames = Lists.newArrayList(); 
 @NonNull public List<String> getMatchingStackFrames(@NonNull String filter, boolean fullTrace, @NonNull Locale locale) { filter = filter.toLowerCase(locale); List<String> matchingFrames = Lists.newArrayList(); 
 public Dominators(@NonNull Snapshot snapshot, @NonNull ImmutableList<Instance> topSort) { mSnapshot = snapshot; mTopSort = topSort; 
 public Dominators(@NonNull Snapshot snapshot, @NonNull ImmutableList<Instance> topSort) { mSnapshot = snapshot; mTopSort = topSort; 
 * the latter we create heaps that are only concerned with connectivity between nodes. 
 for (Class<? extends BaseTask> clazz : allTasks) { currentTasks.add(clazz.getCanonicalName()); 
 newTasks.removeAll(myKnownTasks); 
 if (!allTasks.contains(it.next())) { it.remove(); 
 mySelectedTasks.addAll(newTasks); 
 public List<TaskRunner.TaskResult> performTasks(NavigationUtil navigationUtil, List<String> taskNames) { LinkedHashSet<String> uniqueTaskNames = new LinkedHashSet<String>(); 
 catch(IOException e) { logException(e); 
 private final EvictingQueue<List<TaskResult>> myAllResults = EvictingQueue.create(16); private final HashMap<String, TaskResult> myLastResults = new HashMap<String, TaskResult>(); 
 BaseAction.State s = setupAction(e); List<String> lastTask = Collections.singletonList(s.getLastRanTask()); s.performTasks(lastTask); 
 setVisible(false); 
 setVisible(false); 
 Dimension preferredSize = setGalleryWidth(cellSize.width * 10 / 3); 
 // Less than 2x elements - expand to fill the whole width assertColumnCountForWidth(gallery, COLUMNS, actualCellSize.width * COLUMNS * 3 / 2); 
 List<ErrorTreeElement> messages = Lists.newArrayListWithExpectedSize(myMessages.size()); 
 List<NavigatableMessageElement> children = myGroupNameToMessagesMap.get(((GroupingElement)element).getName()); List<ErrorTreeElement> messages = Lists.newArrayListWithExpectedSize(children.size()); 
 super(StringUtil.capitalize(elementKind.toString().toLowerCase(Locale.getDefault()))); 
 sShell = new Shell(Display.getDefault(), SWT.CLOSE | SWT.TITLE); 
 processEvaluatableChildViews(rootNode); 
 * This class uses the Web Content Accessibility Guidelines (WCAG) 2.0 (http://www.w3.org/TR/WCAG20) * to evaluate the contrast ratio between the text and background colors of a view. 
<|del|> 
 public static final double CONTRAST_RATIO_NORMAL_TEXT = 4.5; public static final double CONTRAST_RATIO_LARGE_TEXT = 3.0; 
 /** Maps an int representation of a {@link Color} to its luminance value. */ 
 /** * Formula derived from http://gmazzocato.altervista.org/colorwheel/algo.php. * More information can be found at http://www.w3.org/TR/WCAG20/relative-luminance.xml. */ 
 final ArrayList<Entry<Integer, Double>> colorsByLuminance = Lists.newArrayList(mLuminanceMap.entrySet()); 
 public ContrastResult getContrastResult() { ContrastResult normalTest = getContrastResultForNormalText(); ContrastResult largeTest = getContrastResultForLargeText(); 
 public ContrastResult getContrastResultForLargeText() { return mContrastRatio >= CONTRAST_RATIO_LARGE_TEXT ? ContrastResult.PASS : ContrastResult.FAIL; 
 public ContrastResult getContrastResultForLargeText() { return mContrastRatio >= CONTRAST_RATIO_LARGE_TEXT ? ContrastResult.PASS : ContrastResult.FAIL; 
 new TreeItem(parent, SWT.NONE).setText("Test: " + model.getContrastResult().name()); 
 item.setText("Normal Text Test: " + model.getContrastResultForNormalText().name()); item.setImage(getResultImage(model.getContrastResultForNormalText())); 
 item.setText("Large Text Test: " + model.getContrastResultForLargeText().name()); item.setImage(getResultImage(model.getContrastResultForLargeText())); 
 @NotNull NotificationHyperlink... hyperlinks) { 
 @NotNull NotificationHyperlink... hyperlinks) { 
 for (NotificationHyperlink hyperlink : hyperlinks) { b.append("<br>\n").append(hyperlink.toString()); 
 for (NotificationHyperlink hyperlink : hyperlinks) { b.append("<br>\n").append(hyperlink.toString()); 
<|del|> 
<|del|> 
 for (int i = 0; i < dsts.length; i++) { 
<|del|> 
 * A cancellable Server Receiver. 
 if (!(indicator instanceof ProgressIndicatorEx)) { return; } 
 if (localreceiver != null) { 
 } 
 // We need to iterate on the dominator computation because the graph may contain cycles. // TODO: Check how long it takes to converge, and whether we need to place an upper bound. 
 // An object reachable via two GC roots, a JNI global and a Thread. Instance instance = snapshot.findReference(0xB0EDFFA0L); assertEquals(Snapshot.SENTINEL_ROOT, dominators.get(instance)); 
 // An object reachable via two GC roots, a JNI global and a Thread. Instance instance = snapshot.findReference(0xB0EDFFA0L); assertEquals(Snapshot.SENTINEL_ROOT, dominators.get(instance)); 
<|del|> 
 if (e.getProject() == null) { state.myStateComponent = ApplicationManager.getApplication().getComponent(ApplicationComponent.class); state.myNavigationHelper = new ApplicationNavigationUtil((JFrame)state.myIdeFrame); 
 if (e.getProject() == null) { state.myStateComponent = ApplicationManager.getApplication().getComponent(ApplicationComponent.class); state.myNavigationHelper = new ApplicationNavigationUtil((JFrame)state.myIdeFrame); 
 try { List<String> lastTask = Collections.singletonList(s.getLastRanTask()); s.performTasks(lastTask); } finally { s.cleanup(); } 
<|del|> 
<|del|> 
 else if (callback != null) { 
 private JTextField myProjectId; private JTextField myVersion; 
 static void Show(final Project project, Module selectedModule) { 
 if (modules.size() == 0) { 
 if (model.getSize() == 1) { 
 if (!GoogleLogin.getInstance().isLoggedIn()) { 
 if (Strings.isNullOrEmpty(myExplodedWarField.getText())) { 
 if (Strings.isNullOrEmpty(mySdkField.getText())) { 
 private final String myRefresh_token; private final String myVersion; private final String myAppEngineProject; 
 final RunnerLayoutUi ui = RunnerLayoutUi.Factory.getInstance(myModule.getProject()) .create("Deploy", "Deploy to AppEngine", "Deploy Application", myModule.getProject()); 
 final RunContentDescriptor contentDescriptor = new RunContentDescriptor(console, processHandler, ui.getComponent(), "Deploy to AppEngine"); 
 private class FilteredOSProcessHandler extends OSProcessHandler { 
public class AndroidProjectTreeBuilder extends ProjectTreeBuilder implements VirtualFilePointerListener { /** Maps VirtualFilePointers to their corresponding tree nodes. */ private Map<VirtualFilePointer,AbstractTreeNode> myFileToNodeMap = Maps.newHashMap(); 
 if (facet == null || facet.getIdeaAndroidProject() == null) { 
 return false; 
 RepeatedExtensions.RepeatedGroup[] groups = {group1, group2}; assertFalse(message.hasExtension(RepeatedExtensions.repeatedInt32)); 
 return myFileToNodeMap.get(file); 
<|del|> 
 * function,expected_output,input,extra_info * e.g. cos,-0x1.0000000000000p+0,0x1.921fb54442d18p+1,cos(pi) 
<|del|>
/** * Tests functions in java.lang.Math 
 /** Stores ulps of error allowed for each function, if not 1 ulp.*/ 
/** * Tests java.lang.StrictMath 
 /** * Runs 2-input test using assertEquals. 
 private static Class<? extends Annotation> loadAnnotationClass(@NotNull Class<? extends Annotation> annotationClass, @NotNull ClassLoader classLoader) throws ClassNotFoundException { 
<|del|> 
 public static Recorder getInstance() { return ourInstance; 
 baseTask.setup(); 
 // Application has died. Receiver doesn't exist. 
<|del|> 
 @NotNull AndroidFacet getAndroidFacet(); @NotNull PsiDirectory[] getDirectories(); 
 for (Module module : modules) { if (ModuleRootManager.getInstance(module).getSourceRoots().length > 0) { moduleNodes.add(new AndroidModuleNode(project, module, settings, myProjectViewPane)); 
 * that was skipped due to a DST transition, will result in a date in 1969 (i.e. -1, or 1 second * before 1st Jan 1970 UTC).</li> 
 * that was skipped due to a DST transition, will result in a date in 1969 (i.e. -1, or 1 second * before 1st Jan 1970 UTC).</li> 
 private boolean parseInternal(String s) { 
 throw new TimeFormatException("String is too short: \"" + s + "\" Expected at least 8 characters."); 
 "String is too short: \"" + s + "\" If there are more than 8 characters there must be at least" + " 15."); 
 throw new AssertionError("GMT not found: \"" + timezoneId + "\""); 
 throw new AssertionError("Error loading timezone: \"" + timezoneId + "\"", e); 
 // If the timezones are the same, we can easily compare the two times. 
 if (sourceType == AndroidSourceType.RES || sourceType == AndroidSourceType.MANIFEST) { 
 if (!myProvider.getManifestFile().getPath().equals(that.myProvider.getManifestFile().getPath())) return false; 
 public Set<VirtualFile> getAssetsDirectories() { 
 if (SdkConstants.FD_MAIN.equals(providerName)) { 
 EnumMap<ResourceFolderType, Set<PsiDirectory>> foldersByResourceType = Maps.newEnumMap(ResourceFolderType.class); 
 } assertTrue(expected.isEmpty()); 
 return NoImagePreloadHolder.defaultLocale; 
 mAttachInfo.mHardwareRenderer.destroyHardwareResources(mView); 
 return NoImagePreloadHolder.defaultLocale; 
 // have serialized the locale we were created with. See b/16502916. 
 Pause.pause(5, TimeUnit.MINUTES); 
 JTextField textField = findTextFieldWithLabel("Application name:"); 
<|del|> 
 public final void addClass(long id, ClassObj theClass) { 
<|del|> 
 assertEquals("Unexpected version code for split: " + entry.getKey(), entry.getValue().intValue(), Integer.parseInt(versionCode)); 
 assertEquals("Unexpected version code for split: " + entry.getKey(), entry.getValue().intValue(), Integer.parseInt(versionCode)); 
 return mString.startsWith(PREVIEW_ID); 
 return !mItems.isEmpty() && mItems.get(mItems.size() - 1).isPreview(); 
 }, LONG_TIMEOUT); 
 private JButton findButtonByText(@NotNull String text) { return robot.finder().find(target, JButtonMatcher.withText(text).andShowing()); 
 minSdkComboBox.setName(formFactor.id + ".minSdk"); 
 arrayDst.array(), dstOffset, dst.remaining(), source.getContext(), 
<|del|> 
 assertTrue("Test requires build-tools 20.0.0", aapt.isFile()); 
 sb.append(Joiner.on(", ").skipNulls().join(qualifier, providerName)); 
 StringBuilder newClasspath = new StringBuilder(jackFilesFolder.getAbsolutePath()); 
<|del|> 
 // We already checked the string, so the exponent must have been out of range for an // int. 
<|del|> 
 void buildFinished(@NotNull Project project, @Nullable BuildMode mode); 
 * acos, asin, atan, cosh, sinh, tanh, exp, expm1, log, log10, log1p, and cbrt * have been implemented with the following license. 
<|del|> 
 myProgressWindow.setText("Examining bitmap"); 
 Assert.assertTrue("Step counter did not increase monotonically: " + String.format("%d", mStepsDetected) + " changed to " + String.format("%d", steps), steps >= mStepsDetected); 
<|del|>
 protected void forEach(int slot, Allocation ain, Allocation aout, FieldPacker v, LaunchOptions sc) { 
 protected void forEach(int slot, Allocation[] ains, Allocation aout, FieldPacker v, LaunchOptions sc) { 
 Assert.assertTrue(String.format("Step counter did not increase monotonically: " + "%d changed to %d", mStepsDetected, steps), steps >= mStepsDetected); 
 Assert.fail("Sensor type " + type + " called when not registered for by this test"); 
 if(v==null) { appendText("Cannot access vibrator for this test...continuing anyway", Color.YELLOW); } else { v.vibrate(pattern, -1); } 
 mHostDevice = "1".equals(getSystemPropertyFromShell("ro.kernel.qemu")) ? HostDevice.EMULATOR : HostDevice.REAL_DEVICE; 
 assert licenseDir.exists() : licenseDir; 
 assert licenseDir.exists() : licenseDir; 
<|del|> 
<|del|> 
 private static final String PROPERTY_GET_PREFIX = "get"; private static final String EMPTY_ARGUMENT_LIST = "()"; 
 private static final String PROPERTY_GET_PREFIX = "get"; private static final String EMPTY_ARGUMENT_LIST = "()"; 
 * @deprecated use {@link java.util.Locale#getScript()} instead. This has been kept * around only for the support library. 
 public boolean getRightAlignedSecondaryActions() { return myRightAlignedSecondaryActions && myOrientation == SwingConstants.HORIZONTAL; 
 public void setRightAlignedSecondaryActions(boolean rightAlign) { myRightAlignedSecondaryActions = rightAlign; 
 addComponent(action, (i == 0) || (i == actions.size() - 1)); 
 if (!getRightAlignedSecondaryActions()) { 
 Rectangle oldBounds = bounds.get(componentIndex); // Check to ensure we are actually moving the component to the right. If it's offscreen, just break if (oldBounds.getX() > rightEdge - oldBounds.width) { 
 Rectangle oldBounds = bounds.get(componentIndex); // Check to ensure we are actually moving the component to the right. If it's offscreen, just break if (oldBounds.getX() > rightEdge - oldBounds.width) { 
<|del|> 
 if (Math.abs(timestamp - eventTimestamp) > MIN_TEST_TIME_MILLIS * 1e6) { 
 in_ids = mInIdsBuffer; 
 */ 
<|del|> 
 mServerSocket = new LocalServerSocket(SOCKET_NAME);// (mPort, 10); 
 Log.e(TAG, "There is an exception when reading socket", e); 
<|del|>
<|del|>
<|del|>
<|del|>
 public void reply(String reply) { 
<|del|>
 if (!switchSensor(sensor.getType(), on).equals("OK")) { 
 throw new IllegalArgumentException("Invalid reply length"); 
<|del|>
 getDevice().waitForDeviceNotAvailable(TIMEOUT_DEVICE_WAIT)); 
 socket.close(); return result; 
 mNameList = getClassNameList(mCookie); 
 Rectangle oldBounds = bounds.get(componentIndex); // Check to ensure we are actually moving the component to the right. If it's offscreen, just break if (oldBounds.getX() > rightEdge - oldBounds.width) { 
 Rectangle oldBounds = bounds.get(componentIndex); // Check to ensure we are actually moving the component to the right. If it's offscreen, just break if (oldBounds.getX() > rightEdge - oldBounds.width) { 
 dir = new DirectDir(new Directory(string, context.getRunnableHooks(), 
 public void setManifestPlaceholders(@NonNull Map<String, String> manifestPlaceholders) { 
 private Map<String, String> mManifestPlaceholders; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private static final Pattern PATTERN = Pattern.compile("([^\\$]*)\\$\\{([^\\}]*)\\}(.*)"); 
 if(DEBUG_TASKS) Slog.i(TAG, "remove RecentTask " + tr + " when finishing user" + userId); 
 if (tr.userId == userId) { if(DEBUG_TASKS) Slog.i(TAG, "remove RecentTask " + tr + " when finishing user" + userId); 
<|del|> 
 public void testNull() throws Exception { // Regression test for https://code.google.com/p/android/issues/detail?id=71197 // @null as a background should not trigger a warning 
 return getClippedValue(rowIndex, columnIndex); } @NotNull public Object getClippedValue(int rowIndex, int columnIndex) { Object value = getValue(rowIndex, columnIndex); 
 // If necessary, grows the table to fill the viewport. // Does not trigger when the user drags a column to resize (taken care of by ColumnResizeListener). 
 private JPanel myContentPane; private JPanel myMainPanel; 
 private JPanel myContentPane; private JPanel myMainPanel; 
 float bufferTimeInSeconds = SAMPLE_FREQUENCY_MS * 1.5f / 1000.f; 
 if (myClient == null || !myClient.isValid()) { 
 allocMb = m.get(ClientData.HEAP_BYTES_ALLOCATED) / (1024.f * 1024.f); freeMb = m.get(ClientData.HEAP_SIZE_BYTES) / (1024.f * 1024.f) - allocMb; 
 private volatile boolean myRunning = true; 
<|del|> 
 private static final int TOP_MARGIN = 40; 
 /** * The time of the sample. In seconds since the start of the sampling. */ final float myDelta; final float[] myValues; 
 this.myDelta = delta; this.myValues = values; 
 mFifoReservedEventCount = mSensorUnderTest.getFifoReservedEventCount(); 
 Assert.assertTrue( "FifoReservedEventCount should be greater than 1 and at most FifoMaxEventCount.", ((mFifoReservedEventCount <= mFifoMaxEventCount) & (mFifoReservedEventCount > 1))); 
 try { Thread.sleep(TWO_SECOND_MILLIS); } catch (InterruptedException e) { Log.e(LOG_TAG, String.format("End of batching test was interrupted"), e); } 
 long maxTimeGapBetweenEventsNanos = 0; long sumTimeGapBetweenEventsNanos = 0; 
 long currentTimeDetected = mSensorEvents.get(i).timestamp; if (currentTimeDetected < lastTimeDetected) { 
 List<Sensor> walkingNeeded = new ArrayList<Sensor>(); walkingNeeded.add(mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER)); walkingNeeded.add(mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_DETECTOR)); 
 String zoneString = formatData.getTimeZoneDisplayName(tz, daylight, style); if (zoneString != null) { buffer.append(zoneString); 
 private long computePresentationTime(int frameIndex) { return 132 + frameIndex * 1000000L / mFrameRate; 
 public EditorFixture enterText(@NotNull final String text) { 
 new ComponentDriver(robot).pressAndReleaseKeys(component, keyCode); 
 * The current maximum range in y-axis units. 
 * The current alpha of markers at even positions. When there are not enough/too many markers, the markers * at even positions are faded in/out respectively. This tracks the animated alpha of such markers. 
 * The current alpha of markers at even positions. When there are not enough/too many markers, the markers * at even positions are faded in/out respectively. This tracks the animated alpha of such markers. 
<|del|> 
public class SensorPowerTestActivity extends BaseSensorSemiAutomatedTestActivity implements PowerTestHostLink.Listener { 
 waitForUser(); } else { throw new IllegalStateException("Attempt to run test twice"); 
import com.android.cts.verifier.sensors.BaseSensorTestActivity.SensorTestResult;/*for Sensor Result definition */ 
 public interface Listener { public void setTestResult(final String testname, final SensorTestResult result, final String message); public void raiseError(final String message) throws Exception; public void waitForUserAcknowledgement(final String message); public void appendText(String text); 
 public interface Listener { public void setTestResult(final String testname, final SensorTestResult result, final String message); public void raiseError(final String message) throws Exception; public void waitForUserAcknowledgement(final String message); public void appendText(String text); 
<|del|> 
<|del|> 
 int bytesRead = streamIn.read(buffer, total, 
 String clientRequest = new String(buffer); 
 } catch (IOException e) { 
 } catch (IOException e) { 
 protected String processClientRequest(String request) throws SettingNotFoundException, Exception { 
 final File projectPath = setUpProject(projectDirName, true); 
 private long myLastRenderTime; private Path2D.Float[] myPaths; 
 Dimension dim = getSize(); 
 for (Path2D.Float myPath : myPaths) { myPath.reset(); 
 if (sample.time > myEndTime) { 
<|del|>
 private final ClassLoader loader; 
 Arrays.equals(args.getResolvedTypes(), that.getActualTypeArguments()); 
 Arrays.equals(args.getResolvedTypes(), that.getActualTypeArguments()); 
 Arrays.hashCode(args.getResolvedTypes()); 
 + "may not be accurate (missing type information from the compiler)"; 
 private Sdk myAndroidJdk; 
 String msg = String.format("Module '%1$s' does not have a Gradle path. It is likely that this module was manually added by the user.", module.getName()); 
 public final TemplateMetadata templateMetadata; public final FormFactorUtils.FormFactor formFactor; 
 private final String myClientSecret; private final String myClientId; private final String myRefreshToken; 
 * This is the Dom for the App Engine config file. 
 private static class ActionButtonMatcher extends GenericTypeMatcher<ActionButton> { 
 private static class DialogTitleMatcher extends GenericTypeMatcher<Dialog> { 
 return WindowFinder.findDialog(new DialogTitleMatcher(title)).withTimeout(GuiTests.LONG_TIMEOUT.duration()).using(robot).target; 
 JButton okButton = robot.finder().find(target, JButtonMatcher.withText("OK")); assertNotNull(okButton); 
 public int chooseRunningDeviceStep(@NotNull String[] deviceNames) { 
 JBTable deviceTable = robot.finder().findByType(target, JBTable.class); assertNotNull(deviceTable); 
 JBTable deviceTable = robot.finder().findByType(target, JBTable.class); assertNotNull(deviceTable); 
 List<Integer> rowsToSelect = Lists.newArrayList(deviceTable.getRowCount()); 
 List<Integer> rowsToSelect = Lists.newArrayList(deviceTable.getRowCount()); 
<|del|> 
 INIT_DATA("Loading string resource data"), 
 new WriteCommandAction.Simple(myProject, "Creating string " + name, resourceFile) { 
 myDdmlib.terminate(); 
 HashSet<String> done; boolean performed = false; 
 publicSrcDir, asecPath, dexCodeInstructionSet, pStats); 
 return allocatedClassMatches(filter, locale) || !getMatchingStackFrames(filter, fullTrace, locale).isEmpty(); 
 final int length = fullTrace ? mStackTrace.length : 1; List<String> matchingFrames = Lists.newArrayListWithExpectedSize(length); 
 XmlTag tag = ((PsiResourceItem) item).getTag(); return tag != null && tag.isValid() ? tag : null; 
<|del|> 
 appendText(" # execute_power_tests.py"); 
<|del|> 
 if (switchSensor(sensor.getType(), on).equals(RESPONSE_ERR)) { 
<|del|> 
 " [--input-list=<file>]\n" + 
 " --input-list: <file> is a list of inputs.\n" + 
 int i = (0x000fffff) >> exp; // careful, should be unsigned 
 Log.d(LOG_TAG, String.format("No default sensor of type %d was found...continuing", sensorType)); 
 "FifoReservedEventCount should be 0 or greater and at most FifoMaxEventCount.", ((mFifoReservedEventCount <= mFifoMaxEventCount) & (mFifoReservedEventCount >= 0))); 
 avgTimeGapBetweenEventsMillis), (maxTimeGapBetweenEventsMillis < MAX_DEVIATION_FROM_AVG * avgTimeGapBetweenEventsMillis), true); 
<|del|> 
 // No need to synchronize because events arrive as they are sampled analyzeData(sensorType, sensorName); 
 appendText(msg + String.format("\nexpected:<%f> but was:<%f>", expected, actual), Color.YELLOW); 
<|del|> 
 ignoreSelection = false; 
 throw new AssertionError("Couldn't find class constructor"); 
 void initializeHeapUpdateStatus() throws IOException { 
<|del|> 
 // TODO: check the user actually moved the device during the test, and // stillness check at start and end of the test 
 /** HostToDeviceInterface implementation **/ 
 throw new TestExecutionException(message); 
import com.android.cts.verifier.sensors.BaseSensorTestActivity.SensorTestResult; 
 public void setTestResult(final String testName, 
 public final String TAG = "PowerTestHostLink"; 
 Log.d(TAG, "localSocketServer accept() failed !!!", e); 
 Log.d(TAG, "getInputStream() failed !!!", e); 
 total += bytesRead; } 
 Log.d(TAG, "Exception on close of server socket", e); 
 String testName = ""; 
 Log.e(TAG, "Invalid RAISE command received (bad arguments): " + request); 
 @NotNull Module module, 
 for (Map.Entry<VirtualFile, String> scriptWithQualifier : scripts.entrySet()) { addPsiFile(children, scriptWithQualifier.getKey(), scriptWithQualifier.getValue()); 
 private Map<VirtualFile, String> getBuildScriptsWithQualifiers() { 
<|del|> 
<|del|> 
 if (config.get(Optimizations.InlineAnnotatedMethods.ENABLE).booleanValue()) { request.addFeature(Optimizations.InlineAnnotatedMethods.class); } 
 for (TracerBrush config : brushes) { config.endTraceMarked(node); 
@Description("Marker for tests about Multiple tracing") 
 private final int MIN_BATCH_TIME_MILLIS = 5000; 
 Thread.sleep((int) (0.5*MIN_BATCH_TIME_MILLIS)); 
 norm += Math.sqrt(event.values[0] * event.values[0] + 
 if ((event.receivedTimestamp - gyrTime) < TIMESTAMP_TOLERANCE) { 
 DialogFixture gradleVersionUpdateDialog = findDialog(withTitle("Gradle Sync")).using(myRobot); 
 * The future representing the task being executed, which will return null upon successful completion. 
 // Rethrow the original cause of the exception on this thread. 
 float bufferTime = SAMPLE_FREQUENCY_MS * 1.5f / 1000.f; 
 private final Future<?> myExecutingTask; 
 @GuardedBy("myLock") private boolean myRunning; 
<|del|> 
 myRunning = true; myExecutingTask = ApplicationManager.getApplication().executeOnPooledThread(this); 
 public HprofParser(HprofBuffer buffer) { mInput = buffer; 
 String s = readNullTerminatedString(); // Version, ignored for now. 
 return UnsignedInts.toLong(mInput.readInt()); 
<|del|> 
 private int mFrameRate; 
 int testFailedCounter = 0; StringBuilder stringBuilder = new StringBuilder(); 
 String testDetails = testCase.getValue().execute(); stringBuilder.append(testDetails + "\n"); 
 Log.e(LOG_TAG, "Exception in test",e); String message = e.getMessage(); if (message == null){ message = "Exception in test run";} setTestResult(testName, SensorTestResult.FAIL, message); stringBuilder.append( message + "\n"); 
 setTestResult(testClassName, overallTestResult, stringBuilder.toString()); 
 return onRun(); 
 public String onRun() throws Throwable { String testDetails = ""; 
 final PowerTestHostLink.PowerTestResult testResult = mHostLink.run(); testDetails = testResult.testDetails; Assert.assertEquals(testDetails, 0, testResult.failedCount ); 
 final PowerTestHostLink.PowerTestResult testResult = mHostLink.run(); testDetails = testResult.testDetails; Assert.assertEquals(testDetails, 0, testResult.failedCount ); 
 @VisibleForTesting MemoryMappedFileBuffer(@NonNull File f, int bufferSize, int padding) throws IOException { mBufferSize = bufferSize; 
 @VisibleForTesting MemoryMappedFileBuffer(@NonNull File f, int bufferSize, int padding) throws IOException { mBufferSize = bufferSize; 
 return (int) (mCurrentPosition % mBufferSize); 
 Collection<Device> deviceCollection = chooser.getDevices(); 
 public Collection<Device> getDevices() { return mDevices; 
 fail("Please specify the path of a local, Gradle 1.12 distribution using the system property " + quote(GRADLE_1_12_HOME_PROPERTY)); 
<|del|> 
 return plugins.contains(GradleDetector.APP_PLUGIN_ID) || plugins.contains(GradleDetector.OLD_APP_PLUGIN_ID) || plugins.contains(GradleDetector.LIB_PLUGIN_ID) || plugins.contains(GradleDetector.OLD_LIB_PLUGIN_ID); 
 static SkinLayoutDefinition loadFromTokens(Iterator<String> tokens) { 
 private void makeString(@NotNull StringBuilder sb, int depth) { 
public class SkinLayoutDefinitionTest { 
 * Shows if this operation should be retried. 
 * @param title user-facing string that will appear in the progress UI 
 public synchronized final void runInBackground(Runnable callback) { assertIsDispatchThread(); 
 public synchronized final void runInBackground(Runnable callback) { assertIsDispatchThread(); 
 public final void runAndWait() { assertIsDispatchThread(); 
<|del|> 
 private static AndroidDebugBridgeService sMyInstance; 
 if (sMyInstance != null) { sMyInstance.terminate(); 
 private final class CreateBridgeTask extends AbstractWaitTask { public CreateBridgeTask(Project project) { 
 AndroidDebugBridge.disconnectBridge(); 
 return Boolean.getBoolean(ENABLE_EXPERIMENTAL_ACTIONS) 
<|del|> 
<|del|> 
 return Boolean.getBoolean("enable.experimental.actions") && SdkUtils.endsWithIgnoreCase(file.getPath(), SdkConstants.EXT_HPROF); 
 public static final Logger LOG_ = Logger.getInstance("com.android.tools.idea.lang.proguard.parser.ProguardParser"); 
 protected static final NotificationHyperlink[] EMPTY = {}; 
 File pathOfBrokenSdk = findPathOfSdkMissingOrEmptyAddonsFolder(project); 
 // This happens when Gradle cannot find the Android Gradle plug-in in Maven Central or jcenter. 
 hyperlinks.add(new OpenUrlHyperlink(GRADLE_PROXY_ACCESS_DOCS_URL, "Learn about configuring HTTP proxies in Gradle")); 
public class ActionButtonFixture extends ComponentFixture<ActionButton> { 
 NEXT_ERROR, PREVIOUS_ERROR, NEXT_METHOD, PREVIOUS_METHOD 
 public RunToolWindowFixture(@NotNull String toolWindowId, @NotNull Project project, @NotNull Robot robot) { super(toolWindowId, project, robot); 
 public ChooseDeviceFixture selectEmulatorStep(@NotNull String deviceName) { 
 * Copyright (C) 2014 The Android Open Source Project 
 "unless they have mutual constraints like `toEndOf`/`toStartOf`.", 
 return !text.startsWith(PREFIX_RESOURCE_REF) && !text.startsWith(PREFIX_THEME_REF); 
 if (mNode.getTagName().equals(VIEW_INCLUDE) || mNode.getTagName().equals(VIEW)) { 
 return mNode.hasAttributeNS(ANDROID_URI, key); 
 return getQualifiedNameSortKey() + "-" + (SdkConstants.FD_MAIN.equals(sourceProviderName) ? "" : sourceProviderName); 
 private final JAnnotation annotation; 
 protected abstract void onCancel(); 
 public InternalWaitTask(@Nullable Project project, @NotNull String title, final boolean background) { 
 public void requestDebugBridge(Function<AndroidDebugBridge, ?> callback) { 
 public static class ProcessListFixture extends JListFixture { 
 if (client.getClientData().getClientDescription() != null && 
 pause(new ProcessListInitializationCondition("Wait for Android tool window to finish initialization.", robot, getContentPanel()), SHORT_TIMEOUT); myProcessListFixture = new ProcessListFixture(robot, robot.finder().findByType(getContentPanel(), JList.class, false)); 
 private JPanel getContentPanel() { 
 AvdComboBox avdComboBox = robot.finder().findByType(AvdComboBox.class); 
 public void setExtendsExpression(@Nonnull Expression<Boolean, Scope> expression) { extendExpression = expression; 
 @Nonnull final Collection<TransformationStep> steps = new ArrayList<TransformationStep>(); 
 T eval(@Nonnull U scope, @Nonnull Context context); 
 T eval(@Nonnull U scope, @Nonnull Context context); 
 public ExtendsScope(@Nonnull JDefinedClassOrInterface classOrInterface) { this.classOrInterface = classOrInterface; 
 public IsNotEmpty(@Nonnull Expression<Collection<?>, T> collectionExpression) { 
 public void push() { outerContext.steps.addAll(steps); 
 public boolean isLoadedFromJackFile() { return loadedFromJackFile; } 
<|del|> 
 super("Open Translation Editor (Preview)", null, StringResourceEditor.ICON); 
 throw new ConfigurationException(String.format("Build file %1$s is not writable", file.getPath())); 
 throw new ConfigurationException(String.format("Build file %1$s is not writable", file.getPath())); 
 mCmdLineRunner); 
 public ImmutableList<APKOutput> getOutputFiles() { ImmutableList.Builder<APKOutput> outputs = ImmutableList.builder(); 
 public enum SplitHandlingPolicy { /** * Any release before L will create fake splits where each split will be the entire * application with the split specific resources. */ PRE_21_POLICY, 
 /** * Android L and after, the splits are pure splits where splits only contain resources * specific to the split characteristics. */ RELEASE_21_AND_AFTER_POLICY 
 new SyncProjectWithExtraCommandLineOptionsHyperlink("Re-download dependencies and sync project (requires network)", "--refresh-dependencies"); 
 super("syncProject", text); 
 File file = VfsUtilCore.virtualToIoFile(vFile); 
 long n = 500000000L; RandomAccessFile raf = new RandomAccessFile(tmpFile, "rw"); raf.setLength(n); raf.write(1); raf.seek(n - 1); raf.write(2); raf.close(); 
 "jack.dex.multidex.legacy", "Enable multidex runtime support for devices that do not have native support") .addDefaultValue(false); 
<|del|> 
@Description( "Indicates that a class or interface must be included in the main dex in multidex mode") 
 * Indicate that the element may be used during the multidex legacy support installation. As such it * must be kept in main dex along with its dependencies. 
public abstract class Location { 
 private JEditorPane myModuleDescriptionText; 
 if(!setSize(176, 144)) return; 
 return isAvcSupportedSize(width, height); 
 /** * Checks whether the given resolution is supported by the AVC codec. */ private static boolean isAvcSupportedSize(int width, int height) { 
 /** the amount of time to wait between unsuccessful prop fetch attempts */ private static final long FETCH_BACKOFF_MS = 3000; // 3 seconds 
 private static enum CacheState { UNPOPULATED, FETCHING, POPULATED } 
 long timeSinceLastAttempt = currentTime - mLastFetchAttemptTime; if (timeSinceLastAttempt < FETCH_BACKOFF_MS) { waitTime = FETCH_BACKOFF_MS - timeSinceLastAttempt; 
 mLastFetchAttemptTime = currentTime; return waitTime; 
 * Waits for appropriate backoff time to prevent constant queries on an unresponsive device 
 return CacheState.POPULATED.equals(mCacheState); 
 String projectName = "SimpleApplication"; 
 String projectName = "SimpleApplication"; 
 String projectName = "SimpleApplication"; 
 String projectName = "SimpleApplication"; 
<|del|> 
 public EmulatorBasicControls runEmulator(@NotNull String... deviceNames) { 
 myLogCatToolWindowFixture.terminateApplication(); 
 selectItemByText(getRunConfigList(), appName); 
<|del|> 
 protected boolean isMatching(JButton component) { return comboBoxButtonClass.isInstance(component); 
 }); assertTrue(appIndex >= 0); 
 readPackage(parser, pb); 
 readPackage(parser, pb); 
 Dimension dim = this.getSize(); 
 Dimension dim = this.getSize(); 
<|del|> 
<|del|> 
<|del|> 
 if (cause != null && cause.startsWith("Could not reserve enough space for object heap")) { 
 newMsg += "\nPlease assign more memory to Gradle in the project's gradle.properties file.\n" + "For example, the following line, in the gradle.properties file, sets the maximum Java heap size to 1,024 MB:\n" + 
 newMsg += "\nPlease assign more memory to Gradle in the project's gradle.properties file.\n" + "For example, the following line, in the gradle.properties file, sets the maximum Java heap size to 1,024 MB:\n" + 
 "<li>The state of a Gradle build process may be corrupt.\n" + 
 "In the case of corrupt Gradle processes, you can also try closing the IDE and then killing all Java processes."; 
 public EmulatorBasicControls runEmulator(@NotNull String[] deviceNames) { 
 public EmulatorBasicControls runEmulator(@NotNull String[] deviceNames) { 
 JPanel runConfigComboPanel = robot.finder().find(actionToolbarContainer, new GenericTypeMatcher<JPanel>(JPanel.class) { 
 return runConfigComboBoxButton.target.isEnabled(); 
 if (myDdmlib.isConnected()) { myResult.set(AndroidDebugBridge.getBridge()); } else { myResult.setException(new CancellationException()); } 
 break; 
 } if (indicator.isCanceled()) { return; } 
 AppEngineSdk mySdk = new AppEngineSdk(mySdkPath); if (mySdk.getToolsApiJarFile() == null) { Messages.showErrorDialog("Cannot start uploading: The tools sdk jar could not be located.", "Error"); return; } 
 public void setEmergencyStatus(boolean status) 
 if (fonts.isEmpty()) { 
 if (SystemInfo.isMac // On Macs, all fonts can display all the characters because the system renders using fallback fonts. || isExtendedAscii(s)) { // Assume that default font can handle ASCII 
 if (s.charAt(i) > 255) { fonts.add(ComplementaryFontsRegistry.getFontAbleToDisplay(s.charAt(i), Font.PLAIN, fontPreferences).getFont()); } 
 if (s.charAt(i) > 255) { fonts.add(ComplementaryFontsRegistry.getFontAbleToDisplay(s.charAt(i), Font.PLAIN, fontPreferences).getFont()); } 
 char[] chars = pattern.toCharArray(); if (chars.length == 0) { 
 while (!myDdmlib.isConnected()) { 
<|del|> 
 public @Nullable String getProperty(@NonNull String name); 
 public @NonNull Future<String> getSystemProperty(@NonNull String name); 
 private final Map<String, String> mCollectedProperties = 
 private final List<PropFuture> mPendingRequests = new LinkedList<PropFuture>(); private final ExecutorService mThreadPool = Executors.newCachedThreadPool(); 
<|del|> 
 CharBuffer formatBuffer = CharBuffer.wrap(pattern); 
 private JButton findToolbarButton(@NotNull final String tooltip) { 
 requireRenderSuccessful(false, false); 
 /** * Asserts that the render was successful with no errors or warnings. Will wait for render to finish first if it's in progress. */ void requireRenderSuccessful(); 
 }, SHORT_TIMEOUT); 
 layout.requireSelectionCount(1); 
 properties.setValue(PROPERTY_APK_PATH, apkFolder); 
 String projectName = "SimpleApplication"; String appName = "app"; 
 ChooseDeviceDialogFixture chooseDeviceDialogFixture = projectFrame.runApp("app"); chooseDeviceDialogFixture.selectEmulator("Nexus7"); chooseDeviceDialogFixture.clickOk(); String appName = projectFrame.scanLogCatOutput(); projectFrame.terminateApp(appName); 
 private void click() throws ClassNotFoundException { 
 JButton comboBoxButton = robot.finder().find(actionToolbarContainer, new GenericTypeMatcher<JButton>(JButton.class) { 
 final JButtonFixture comboBoxButtonFixture = new JButtonFixture(robot, comboBoxButton); pause(new Condition("Wait until comboBoxButton is enabled") { 
 pause(new Condition("Wait until the list is populated.") { 
 protected Object executeInEDT() throws Throwable { return runConfigList.getSelectedValue(); 
 private void selectItemByText(@NotNull final JList list, @NotNull final String text) { 
 ListPopupModel popupModel = (ListPopupModel)list.getModel(); for (int i = 0; i < popupModel.getSize(); ++i) { PopupFactoryImpl.ActionItem actionItem = (PopupFactoryImpl.ActionItem)popupModel.get(i); 
 assertEquals(text, ((PopupFactoryImpl.ActionItem)list.getSelectedValue()).getText()); 
 "jack.dex.output.multidex", "Enable MultiDex output") 
<|del|> 
<|del|> 
 * Convenience method that attempts to retrieve a property via * {@link #getSystemProperty(String)} with minimal wait time, and swallows exceptions. 
<|del|> 
<|del|> 
<|del|> 
 if (netInitiatedListener == null) { throw new IllegalArgumentException("netInitiatedListener is null"); } else { mNetInitiatedListener = netInitiatedListener; } 
 handleNiInEs(notif); 
 // If NI does not need verify or the dialog is not requested // to pop up immediately, the dialog box will not pop up. 
 // If NI does not need verify or the dialog is not requested // to pop up immediately, the dialog box will not pop up. 
<|del|> 
<|del|> 
<|del|> 
 Log.e(TAG, "RemoteException in sendNiResponse"); 
 // handle NI from HAL when the SUPL_ES is enabled private void handleNiInEs(GpsNiNotification notif) { 
 SUPL ES bit is on but UE is not in emergency mode 
 boolean isNiTypeES = notif.niType == GPS_NI_TYPE_EMERGENCY_SUPL ? true : false; if (isNiTypeES != isUEInEmergencyMode) { 
<|del|> 
 int ch = bytes[i] & 0xff; 
 "Enable multidex compatibility support for devices that do not have native runtime support") 
 throw new JackIOException("Failed to close output stream on '" + dexVFile + "'", e); 
 throw new JackIOException("Failed to close output stream on '" + dexVFile + "'", e); 
 return StringsWriteUtils.setAttributeForItems(myFacet.getModule().getProject(), SdkConstants.ATTR_TRANSLATABLE, translatable, Collections.singletonList(item)); 
 if (DEBUG) Log.d(TAG, "onCallStateChanged(): state is "+ state); 
<|del|> 
 boolean isNiTypeES = (notif.niType == GPS_NI_TYPE_EMERGENCY_SUPL); 
 "This can happen if Android Studio is extracted into an existing older version.\n\n" + 
 private static final int CACHE_MAGIC = 0x20140623; 
 private static final int CACHE_MAGIC = 0x20140903; 
 static final int INITIAL_CAPACITY = 215; 
 // so are hard to use without knowing about the folding keyboard shortcut to toggle folding. 
 public static final Icon MemoryMonitor = load("/icons/memory_monitor.png"); // 16x16 public static final Icon MemoryMonitorToolWindow = load("/icons/memory_monitor_tool_window.png"); // 13x13 
<|del|> 
<|del|> 
 new WriteCommandAction<Void>(project, "Update settings.gradle", psiFile) { 
 new WriteCommandAction<Void>(project, "Update settings.gradle", psiFile) { 
 new WriteCommandAction<Void>(project, "Update settings.gradle", settingsFile.getPsiFile()) { 
<|del|> 
<|del|> 
 projectFrame.runApp(appName); ChooseDeviceDialogFixture chooseDeviceDialogFixture = projectFrame.findChooseDeviceDialog(); 
 projectFrame.runApp(appName); ChooseDeviceDialogFixture chooseDeviceDialogFixture = projectFrame.findChooseDeviceDialog(); 
 runApplication("Run", appName); } @NotNull public ChooseDeviceDialogFixture findChooseDeviceDialog() { 
 public void toFront() { GuiActionRunner.execute(new GuiTask() { 
 if (mIsSuplEsEnabled == false) { 
 private static final long BATTERY_TIMEOUT = 2 * 1000; // 2 seconds 
<|del|> 
<|del|> 
 throw new IOException("Failed to delete directory '" + dir.getPath() + "'"); 
 @SuppressFBWarnings("RV_RETURN_VALUE_IGNORED_BAD_PRACTICE") //Ignore delete return value: best effort 
 dir.delete(); 
 public ClientCellRenderer(@NotNull String emptyText) { myEmptyText = emptyText; 
 public DeviceComboBoxRenderer(@NotNull String emptyText) { myEmptyText = emptyText; 
 return label != null ? Arrays.asList(label, dataComponent) : Arrays.asList(dataComponent); 
 if (location.column == 0 && keyComponents.size() == 1 && keyComponents.get(0) instanceof JCheckBox) { 
 String qualifiers = getQualifiers(); 
<|del|>
 "<li>" + buildProjectHyperlink.toHtml() + " to obtain the cause of the error</li>" + "<li>" + openAndroidSdkManagerHyperlink.toHtml() + " to check if there are any missing components</li></ul>"; 
 "<li>" + buildProjectHyperlink.toHtml() + " to obtain the cause of the error</li>" + "<li>" + openAndroidSdkManagerHyperlink.toHtml() + " to check if there are any missing components</li></ul>"; 
 if (AndroidSdkUtils.getDebugBridge(getProject()) == null) return null; 
 JTextComponent directoryField = robot.finder().findByType(parent, JTextComponent.class, true); JTextComponentDriver driver = new JTextComponentDriver(robot); 
 public void createOtherVariation(@NotNull String variation) { 
 && cast.getCastType() instanceof JPrimitiveType) { assert cast.getCastType() != JPrimitiveTypeEnum.VOID.getType(); 
 public void assertCalendarConfigEquals(Calendar a, Calendar b) { 
 mPlaybackView.stopPlayback(); 
<|del|> 
 if (!FileUtil.delete(gradleDirPath)) { // deletion failed. Let sync continue. return; } 
 for (InputVFile currentDex : mainDexList) { try { mergeDex(merger, currentDex); } catch (MergeOverflow e) { throw new JackUserException( "Too many classes in main dex. Index overflow while merging dex files", e); } 
 } finishMerge(merger, outputDex); 
 * Returns the instance of an Addr2Line process for the specified library * and abi. 
 * @param library the library in which to look for addresses. * @param abi the current abi that will indicate which 
 public static Addr2Line getProcess(@NonNull final NativeLibraryMapInfo library, @Nullable String abi) { 
 private boolean start() { 
 @NonNull String symbolSearchPath, @Nullable String abi) { 
 @NonNull String symbolSearchPath, @Nullable String abi) { 
 if (abi == null || abi.startsWith("32")) { 
<|del|> 
 return typeSignature + " not found"; 
 // Make sure it's not the base method, but that it's been defined 
<|del|> 
<|del|>
 Collection<JAnnotationLiteral> getAnnotations(@Nonnull JAnnotation annotationType); 
 annotationLiterals = new ArrayList<JAnnotationLiteral>(1); 
 List<JAnnotationLiteral> getAnnotations(@Nonnull JAnnotation annotationType); 
 // To support apps running with native bridge, the os.arch should be changeable. 
 public @NonNull Future<String> getSystemProperty(@NonNull String name); 
 // The original version of the header for 32 bit processes: 
 * @param abi indicates which underlying addr2line command to use. 
 else { assert component == myTranslation; 
 return StringUtil.containsChar(s, '\n'); 
 * Copyright (C) 2014 The Android Open Source Project 
 Options options = new Options(); options.jarjarRulesFile = new File(TestTools.getJackTestFolder(testName), "jarjar-rules.txt"); 
<|del|> 
 Integer getMaxSdkVersion(); 
 assertTrue("Test requires build-tools 21.0.0", aapt.isFile()); 
 assertTrue("Test requires build-tools 19.1.0", aapt.isFile()); 
 * @param name the property name to retrieve * @return a {@link Future} that can be used to retrieve the prop value 
 * "Next Error/Warning" navigation) with the specified message and tooltip markup over the specified text range. 
 * @param htmlTooltip the tooltip to show (usually the message, but escaped as HTML and surrounded by a {@code <html>} tag 
<|del|> 
 Window activeWindow = WindowManagerEx.getInstanceEx().getMostRecentFocusedWindow(); if (activeWindow == null) { return null; } return CommonDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(activeWindow)); 
 private static final String ADD_ACCOUNT = "Add Account"; private static final String SIGN_IN = "Sign In"; 
 private JBScrollPane myContentScrollPane; private JPanel myBottomPane; 
 private JBScrollPane myContentScrollPane; private JPanel myBottomPane; 
 private class AddAccountListener implements ActionListener { 
 private static class ProjectSelectorWizardBinding extends ScopedDataBinder.ComponentBinding<String, JComponent> { 
 public ElysiumProjectModelItem(@Nullable String description, @NotNull String id) { 
 private volatile boolean myIsSynchronizing; 
<|del|> 
<|del|> 
 public void initialize(@Nullable Image image, @Nullable String userName, @Nullable String email) { 
 public ProjectSelectorErrorItem(@NotNull Color errorForeground) { 
class ProjectSelectorItem extends JBLabel { 
 public ProjectSelectorItem(@NotNull Color backgroundNonSelectionColor, @NotNull Color textSelectionColor, @NotNull Color textNonSelectionColor) { 
 static final private Cursor HAND_CURSOR = Cursor.getPredefinedCursor(Cursor.HAND_CURSOR); static final private Cursor NORMAL_CURSOR = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR); private JPanel myPanel1; 
 static final private Cursor HAND_CURSOR = Cursor.getPredefinedCursor(Cursor.HAND_CURSOR); static final private Cursor NORMAL_CURSOR = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR); private JPanel myPanel1; 
 final private ScheduledExecutorService myLoadingAnimationScheduler = ConcurrencyUtil.newSingleScheduledThreadExecutor("Animations"); final private static Cursor NORMAL_CURSOR = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR); 
 final private ScheduledExecutorService myLoadingAnimationScheduler = ConcurrencyUtil.newSingleScheduledThreadExecutor("Animations"); final private static Cursor NORMAL_CURSOR = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR); 
 myTicker = myLoadingAnimationScheduler.scheduleWithFixedDelay(new Runnable() { 
 myTextField = new JBTextField() { 
<|del|> 
 // Could not obtain plug-in version. Continue. ensureGradleDistributionIsSet(project); 
 public static final int TRANSLATE_NONE = 0; public static final int TRANSLATE_X_ONLY = 1; public static final int TRANSLATE_Y_ONLY = 2; public static final int TRANSLATE_BOTH = 3; 
 public static final int TRANSLATE_NONE = 0; public static final int TRANSLATE_X_ONLY = 1; public static final int TRANSLATE_Y_ONLY = 2; public static final int TRANSLATE_BOTH = 3; 
<|del|>
<|del|>
<|del|>
<|del|>
 catch (UnsupportedMethodException e) { 
 * @param abis a list of ABIs. 
 return splitOutput.getVersionCode() - splitOutput2.getVersionCode(); 
 if (device != myDevicesComboBox.getSelectedItem()) { 
 if (text.startsWith(textToSearchPrefix)) { return consumer.fun(Pair.create(text, lexer)); 
 if (text.startsWith(textToSearchPrefix)) { return consumer.fun(Pair.create(text, lexer)); 
 if (isNotEmpty(revision)) { if (!coordinate.acceptsGreaterRevisions()) { 
 int major = coordinate.getMajorVersion(); int minor = coordinate.getMinorVersion(); if (coordinate.getMicroVersion() == -1 && major >= 0 && minor > 0) { return major + "." + minor + "." + 0; 
<|del|> 
<|del|> 
 * @param privateDir null-ok the private dir to store private data when * running with native bridge. 
 if (node.getParent() != nodes.peek()) { 
 public boolean isNodeValid() { 
<|del|> 
 setDescription(description); setProjectId(id); 
 loadErrorState(ex); Thread.currentThread().interrupt(); 
<|del|> 
<|del|> 
 static private final Cursor NORMAL_CURSOR = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR); static private final Color ERROR_COLOR = JBColor.RED; 
 * @param appDataDir null-ok the data directory of the app. 
 IdeFrameFixture projectFrame = newProject("LayoutPreviewTest3").withActivity("MyActivity").create(); 
 JButton localeChooser = findToolbarButton("Locale to render layout with inside the IDE"); 
 assertFalse(previewManager.hasPreviews()); 
 } assertEquals(titles, previewTitles); 
<|del|> 
 public void putNextEntry(@Nonnull ZipEntry e) throws IOException { 
 if (is == null) { throw new AssertionError(); } CharactersStreamSucker css = new CharactersStreamSucker(is, printStream); 
 css.suck(); 
<|del|> 
 if ((!requireVisible || path.isPathVisible()) && path.containsStep(stepName, requireVisible)) { 
 @Nullable 
 if (hscroll != 0.0f || vscroll != 0.0f) { 
 if (hscroll != 0.0f || vscroll != 0.0f) { 
<|del|> 
 getterName += field.getName(); 
 setterName += field.getName(); 
 String wrapperName = WRAPPER_PREFIX; // It is a temporary deterministic name that will be replace by an index into // InnerAccessorAdder wrapperName += IdentifierFormatter.getFormatter().getName(mthCallReceiverType) + IdentifierFormatter.getFormatter().getName(method) + isSuper; 
 String wrapperName = WRAPPER_PREFIX; // It is a temporary deterministic name that will be replace by an index into // InnerAccessorAdder wrapperName += IdentifierFormatter.getFormatter().getName(mthCallReceiverType) + IdentifierFormatter.getFormatter().getName(method) + isSuper; 
 String wrapperName = WRAPPER_PREFIX; // It is a temporary deterministic name that will be replace by an index into // InnerAccessorAdder wrapperName += IdentifierFormatter.getFormatter().getName(mthCallReceiverType) + IdentifierFormatter.getFormatter().getName(method) + isSuper; 
 private boolean isPublic = true; 
 public static Context get(Context ctx) { ContextWrapper wrappedCtx; synchronized (sLock) { wrappedCtx = sCtxToWrapper.get(ctx); if (wrappedCtx == null) { wrappedCtx = createWrapper(ctx); sCtxToWrapper.put(ctx, wrappedCtx); } 
 public static Context get(Context ctx) { ContextWrapper wrappedCtx; synchronized (sLock) { wrappedCtx = sCtxToWrapper.get(ctx); if (wrappedCtx == null) { wrappedCtx = createWrapper(ctx); sCtxToWrapper.put(ctx, wrappedCtx); } 
 @Override public AssetManager getAssets() { return resources.getAssets(); } @Override 
<|del|> 
 public UploadResult uploadApk(@NotNull IDevice device, @NotNull String localPath, @NotNull String remotePath) 
 public boolean isOpenProjectWizardAlreadyTested() { return myOpenProjectWizardAlreadyTested; 
<|del|> 
 return mySearchBox; 
 if(sample.getDescription() != null) { description.addHtml(sample.getDescription()); } 
 samplesService = myBuilder.build(); 
 if(sampleList.get() == null || sampleList.get().size() == 0) { Messages.showErrorDialog("Failed to download samples list from server", "Sample Import"); 
 public SampleImportTreeManager(@NotNull Tree tree, @NotNull SampleCollection samples) { 
 * @param expand set to {@code true} to expand out all nodes 
 * Return the selected Sample or {@code null} if a non-sample node is selected. 
 * substring matches in their 1. title, 2. categories, 3. description will be returned. 
 * substring matches in their 1. title, 2. categories, 3. description will be returned. 
 for (Sample sample : mySamples.getItems()) { if (sample.getTitle() != null && StringUtil.containsIgnoreCase(sample.getTitle(), keyword)) { filteredSamples.add(sample); 
 for (String category : sample.getCategories()) { if (category != null && StringUtil.containsIgnoreCase(category, keyword)) { filteredSamples.add(sample); break; // done searching categories 
 Messages.showErrorDialog("Failed to create project directory", "Sample Import Failed"); 
 Messages.showErrorDialog("Failed to create project directory", "Sample Import Failed"); 
 Messages.showErrorDialog(downloadResult.errorMessage, "Sample Download Failed"); 
 LOG.error(e); Messages.showErrorDialog("Unable to copy sample into project directory", "Sample Import Failed"); 
 GradleProjectImporter.getInstance().importProject(project.getBaseDir()); // TODO : display the correct starting file for users 
 runToolWindowFixture.getOutputContent(appName).waitForOutput(new PatternTextMatcher(Pattern.compile( 
 private final Font myFont = new Font("Sans", Font.PLAIN, 12); private final Font myFigureFont = new Font("Sans", Font.PLAIN, 10); private final Font myTitleFont = new Font("Sans", Font.BOLD, 16); 
 g2d.setStroke(new BasicStroke(OUTLINE_LINE_WIDTH)); 
 private final Camera myFrontCamera = new Camera(CameraLocation.FRONT, true, true); private final Camera myBackCamera = new Camera(CameraLocation.BACK, true, true); 
<|del|> 
 private final ColumnInfo[] myColumnInfos = new ColumnInfo[] { 
 if (name1 == null || name2 == null || name1.isEmpty() || name2.isEmpty()) { 
<|del|> 
 * A base class for actions that operate on {@link Device}s and can be bound to buttons 
 * Action to edit a given device 
 private long myBytes = 0l; 
 myBytes = 0; 
<|del|> 
 private static final String EXISTING_SDCARD = "existingsdcard"; private static final String NEW_SDCARD = "newsdcard"; 
 private static final String EXISTING_SDCARD = "existingsdcard"; private static final String NEW_SDCARD = "newsdcard"; 
<|del|> 
 private final Border myMargins = IdeBorderFactory.createEmptyBorder(5, 3, 5, 3); 
 setBorder(IdeBorderFactory.createEmptyBorder(10, 10, 10, 10)); 
 private final Border myBorder = IdeBorderFactory.createEmptyBorder(10, 10, 10, 10); 
 * Custom table cell renderer that renders an action panel for a given AVD entry 
 long numLong = Long.parseLong(numString); 
 String candidateBase = String.format("AVD_for_%1$s_by_%2$s", deviceName, manufacturer); 
 candidate = String.format("%1$s_%2$d", candidateBase, i); 
 return String.format("%1$d%2$c", storage.getSizeAsUnit(unit), unit.toString().charAt(0)); 
 JBLabel label = new JBLabel("Your Virtual Devices"); 
 label.setBorder(IdeBorderFactory.createEmptyBorder(18, 12, 12, 12)); 
 super(avdInfoProvider, "Create Virtual Device...", "Create a new Android Virtual Device", AllIcons.General.Add); 
 LOG.warn("Exporting AVD " + getAvdInfo().getName()); throw new UnsupportedOperationException("Exporting AVDs is not yet implemented"); 
 LOG.warn("Repairing AVD " + getAvdInfo().getName()); throw new UnsupportedOperationException("Repairing AVDs is not yet implemented"); 
<|del|> 
<|del|> 
 /* zip = */ false ); 
 /* zip = */ false ); 
<|del|> 
<|del|> 
 public void setText(@NotNull String[] lines, @Nullable String prefix) { 
 public void setText(@NotNull String[] lines, @Nullable String prefix) { 
 public void setText(@NotNull String[] lines, @Nullable String prefix) { 
 public void test_setNan_emptyString() throws Exception { 
 panel.setText("Edit translations for all locales in the translations editor."); 
 Collection<ClassObj> classes = new ArrayList<ClassObj>(); 
<|del|> 
<|del|> 
 androidToolWindowFixture.selectDevicesTab(); AndroidToolWindowFixture.ProcessListFixture processListFixture = androidToolWindowFixture.getProcessList(); processListFixture.waitForProcess(processName); processListFixture.selectItem(processName); androidToolWindowFixture.clickTerminateApplication(); 
 final JList runConfigList = robot.finder().findByType(JBListWithHintProvider.class); 
 return runConfigList.getComponentCount() >= 2; // At least 2, since there is always one option present (the option to edit). 
 private static void selectItemByText(@NotNull final JList list, @NotNull final String text) { 
 if (text.equals(actionItem.getText())) { 
 FileEditorManager manager = FileEditorManager.getInstance(myFrame.getProject()); Editor editor = manager.getSelectedTextEditor(); 
 public RunToolWindowFixture getRunToolWindow() { 
 public DebugToolWindowFixture getDebugToolWindow() { 
 public ContentFixture findContent(@NotNull String appName) { 
 if (countDomainNameLabelsExcludingRoot(cn) <= 1) { return false; // reject matches where the wildcard pattern consists of only one label. 
 * SampleBrowserStep is the first page in the Sample Import wizard that allows the user to select a sample to import 
 * A list of Samples which have substring matches for ALL keywords in any of their 
 Set<Sample> filterSamples(@NotNull String query) { 
 Set<Sample> filterSamples(@NotNull String query) { 
 if (hasKeyword(sample, keyword)) { 
 return hyperlinkLabel.isShowing() && label.equals(Reflection.method("getText").withReturnType(String.class).in(hyperlinkLabel).invoke()); 
 robot.click(link); 
 public TranslationsEditorFixture(@NotNull Robot robot, @NotNull StringResourceEditor target) { 
 @NotNull private static List<String> getColumnHeaderValues(@NotNull final JTable table) { 
/** * An implementation of BaseConfig specifically for sending as part of the Android model * through the Gradle tooling API. 
 } 
 * Tests for {@link com.google.gct.idea.samples.SampleImportTreeManager} 
 public void testFilterSamples_emptySearch() { 
<|del|> 
 // Reverse overlay order because when processing lower order ones, we ignore keys already processed 
 addValues(selectedVariant.getMergedFlavor().getResValues()); 
 hashCode = code; 
 sum ^= type.hashCode(); 
 if (hashCode != otherHashCode) { return false; } List<JType> thisParams = methodId.getParamTypes(); List<JType> otherParams = other.methodId.getParamTypes(); 
 private HashMap<ComparableMethodId, ComparableMethodId> virtualMethods; 
public class VirtualMethodsMarker implements Marker, Iterable<JMethodId>, Cloneable { 
 private static final String appName = "app"; private static final String processName = "com.android.simple.application"; private static final Pattern localPathOutput = Pattern.compile( 
 androidToolWindowFixture.selectProcess(processName).clickTerminateApplication(); 
 selectTab("Devices | logcat"); return this; 
 private void selectTab(@NotNull final String tabName) { 
 // We might have launched the emulator and it could be covering up the IDE. So we need to bring the IDE to the front. 
<|del|> 
<|del|> 
<|del|> 
 Content content = getContent(appName); assertNotNull(content); return new ContentFixture(this, myIdeFrame, myRobot, content); 
 * Implementation of a 2 state boolean latch, which can either be signaled or not. * Thread can block on the signal using the {@link #await()} method, worker threads can * release blocked threads by using the {@link #signal()} method. 
 * Definition of a queued job. A job has a title, a task to execute, a latch to signal its * completion and a boolean result for success or failure. 
 e.printStackTrace(); throw e; 
 File aapt = new File(getSdkDir(), "build-tools/android-5.0/aapt"); 
 } // Handle moved resources if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) { String newUrl = responseHeaders.get("Location"); request.setRedirectUrl(newUrl); } 
<|del|> 
 public final String RESULT_FILE = "ip_compat_result.csv"; 
 try { config.setVersionQualifier(null); return myResources.getMatchingFiles(myFile, getResourceType(), config); } finally { config.setVersionQualifier(versionQualifier); } 
 private static final String APP_NAME = "app"; private static final String PROCESS_NAME = "com.android.simple.application"; private static final Pattern LOCAL_PATH_OUTPUT = Pattern.compile( 
 @NotNull public IdeFrameFixture toFront() { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public MessageFixture findMessageContainingText(@NotNull ErrorTreeElementKind kind, @NotNull final String interestedText) { 
 public MessageFixture findMessageContainingText(@NotNull ErrorTreeElementKind kind, @NotNull final String interestedText) { 
 private static final Notification DUMMY_NOTIFICATION = new Notification("dummy", "dummy", "dummy", NotificationType.ERROR); private static final Object DUMMY_EVENT_SOURCE = new Object(); 
 private final Reporter reporter = ThreadConfig.get(Reporter.REPORTER); 
@HasKeyId public interface Reporter { 
 public void report(@SuppressWarnings("unused") @Nonnull Severity severity, @Nonnull Reportable reportable) { // default behavior logger.log(Level.SEVERE, reportable.getMessage()); 
 String lastUpdateTime = getLastUpdateTime(device, pkgName); 
 // The follow code assumes that the output of "dumpsys package <pkgname>" has at least the following line: 
 return artifact.getAbiFilters(); 
 * Path for creating a plain Java Module 
 String moduleName = WizardUtils.computeModuleName(projectName, getProject()); 
<|del|> 
 if (triggerReflectionOOM()) { System.out.println("Test reflection correctly threw"); 
<|del|> 
 long lastBuildTimestamp = facet != null && facet.isGradleProject() 
<|del|> 
 protected abstract AbstractDirectDir createSubDir(@Nonnull File dir, @Nonnull InputOutputVDir vfsRoot) throws NotFileOrDirectoryException; 
 protected abstract AbstractDirectDir createSubDir(@Nonnull File dir, @Nonnull InputOutputVDir vfsRoot) throws NotFileOrDirectoryException; 
 if (!dir.isDirectory()) { throw new NotFileOrDirectoryException(new DirectoryLocation(dir)); } this.dir = dir; location = new FileLocation(dir); this.vfsRoot = vfsRoot; 
<|del|> 
 super(GctBundle.samplesMsg("sample.browser.title"), GctBundle.samplesMsg("sample.browser.subtitle"), null, parentDisposable); 
 if (StringUtil.isEmpty(name) || name.trim().isEmpty()) { 
 private static Map<String, Reference<ResourceBundle>> ourBundles = new HashMap<String, Reference<ResourceBundle>>(); 
 private static ResourceBundle getBundle() { ResourceBundle bundle = com.intellij.reference.SoftReference.dereference(ourBundle); 
<|del|> 
 public final FieldData clone() { FieldData clone = new FieldData(); 
 if (value instanceof MessageNano) { clone.value = ((MessageNano) value).clone(); 
 cloneArray[i] = valueArray[i].clone(); 
 private JTextField myModuleName; private JPanel myPanel; private JTextField myAppName; private LabelWithEditLink myPackageName; 
 myState.put(WizardConstants.APPLICATION_NAME_KEY, myState.get(WizardConstants.IS_LIBRARY_KEY)? "My Library" : "My Application"); 
 Messages.showErrorDialog(project, "We only support generating an endpoint from Java files with one top level class.", "Error Generating Endpoint"); 
 Messages.showErrorDialog(project, "We only support generating an endpoint from Java files with one top level class.", "Error Generating Endpoint"); 
 Messages.showErrorDialog(project, "This Java file does not contain any classes.", "Error Generating Endpoint"); 
 String fileName = psiJavaFile.getName(); String classType = fileName.substring(0, fileName.lastIndexOf('.')); doAction(project, module, packageName, directory, classType, isObjectifyEntity, idType, idName, idGetterName); } 
 if (servletName.equals(ENDOINTS_SERVLET_NAME) && servletClass.equals(ENDPOINTS_SERVLET_CLASS)) { 
 root = new File("src/test/resources/testData/" + name); 
 public DirectDirOutputVDirCodec(@Nonnull Existence existence) { 
 * one instance can run at most one at a time. A dynamic version can be declared by annotating a * method with no parameter and that return true if that instance needs to be synchronized. 
 * one instance can run at most one at a time. A dynamic version can be declared by annotating a * method with no parameter and that return true if that instance needs to be synchronized. 
 * one instance can run at most one at a time. A dynamic version can be declared by annotating a * method with no parameter and that return true if that instance needs to be synchronized. 
 * one instance can run at most one at a time. A dynamic version can be declared by annotating a * method with no parameter and that return true if that instance needs to be synchronized. 
 + "' cannot have two @" + DynamicValidOn.class.getName() + " ('" + method 
 * @param mainArea The {@link EditableArea} instance where the caption is being displayed. 
 boolean hasFrame = nativeComponent.getRenderedImage() != null && nativeComponent.getRenderedImage().getImageBounds() != null; 
 new AndroidShowNavigationEditor().showNavigationEditor(myRenderingParams.myProject, newModule, DEFAULT_DEVICE_QUALIFIER, NAVIGATION_FILE_NAME); 
 final String relativePathOfNavDir = NavigationEditor.NAVIGATION_DIRECTORY + "/" + moduleName + "/" + deviceQualifier; 
 final String relativePathOfNavDir = NavigationEditor.NAVIGATION_DIRECTORY + "/" + moduleName + "/" + deviceQualifier; 
 Module[] modules = ModuleManager.getInstance(project).getModules(); List<Module> result = new ArrayList<Module>(modules.length); for (Module module : modules) { 
 public static Module findModule(@NotNull Module[] modules, @NotNull String name) { 
 * Copyright (C) 2014 The Android Open Source Project 
 } catch (Exception exc) { 
 public static final String DEFAULT_RESOURCE_FOLDER = SdkConstants.FD_RES_RAW; 
 return get(requestUrl, imageListener, 0, 0, true); 
 setRetryPolicy( new DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES, IMAGE_BACKOFF_MULT)); 
 ScaleType scaleType = ScaleType.CENTER_INSIDE; 
 throw new DexWritingException(e, "Try using multidex"); 
 // 'module' will never be null here. 
 private final Color myActiveColor; private final Color myInactiveColor; 
 private final Color myActiveColor; private final Color myInactiveColor; 
 } catch (IOException | SecurityException e) { 
<|del|> 
import com.intellij.openapi.project.Project; import com.intellij.openapi.ui.DialogWrapper; import com.intellij.openapi.ui.Messages; 
 public Collection<String> getFilterTypes() { ImmutableList.Builder<String> splitTypeBuilder = ImmutableList.builder(); 
 @Nullable public String getDensityFilter() { return densityFilter; 
 * Returns the split dimensions the referenced APK was created with. Each collection's value * is the string representation of an element of the {@see FilterType} enum. 
 public static final Set<String> INVALID_WINDOWS_FILENAMES = ImmutableSet 
 return ValidationResult.error("There must not already be a file at the project location"); 
 public static final int MESSAGE_ID_CMAS_ALERT_PRESIDENTIAL_LEVEL_LANGUAGE = 0x111F; 
 if (!isCdma) { // register Taiwan PWS 4383 also, by default manager.enableCellBroadcast(cmasTaiwanPWS); } 
 private static final Pattern ERROR_LOCATION_PATTERN = Pattern.compile(".* file '(.*)'( line: ([\\d]+))?"); 
 private final ScopedStateStore myState = new ScopedStateStore(ScopedStateStore.Scope.WIZARD, null, null); 
<|del|> 
 .setDisplayName("Default Nexus 5") 
<|del|> 
 JMenuItem createTabletMenuItem = new JMenuItem("Create Default Nexus 7 (Tablet)"); 
 JMenuItem createPhoneMenuItem = new JMenuItem("Create Default Nexus 5 (Phone)"); 
 Messages.showErrorDialog(project, "We only support generating an endpoint from Java files with one top level class.", "Error Generating Endpoint"); 
 if (AnnotationUtil.isAnnotated(psiField, OBJECTIFY_ID_ANNOTATION, false)) { 
 } catch (IOException e) { 
 Preconditions.checkState(templateFile.exists(), "Failed to find client template " + templateName); 
 for (CloudTemplateUtils.TemplateInfo template : myTemplates) { 
 outputReceiver, 
 outputReceiver, 
 (value.startsWith(PREFIX_RESOURCE_REF) || value.startsWith(PREFIX_THEME_REF)) && 
@Description("One dex per type production") 
@Description("One dex per type production") 
 @NonNull private final MainApkOutputFile mainApkOutputFile; 
<|del|> 
<|del|> 
<|del|> 
 /** Returns if a target capable of rendering preferences file is found. */ private static boolean prefCapableTargetInstalled(@NotNull PsiFile file) { 
 builder.add(errorMessage).newline() .addLink("Click ", "here", " to use API 21.", logger.getLinkManager().createRunnableLink(new Runnable() { 
<|del|> 
<|del|> 
 mainPanel.setMinimumSize(isActiveUserSelected ? myActiveMainPanelDimension : myMainPanelDimension); 
 mainPanel.setMinimumSize(isActiveUserSelected ? myActiveMainPanelDimension : myMainPanelDimension); 
 @NonNull OutputFile.OutputType outputType, 
 @NonNull OutputFile.OutputType outputType, 
 * A main variant output, it must be either a {@link com.android.build.OutputFile.OutputType#MAIN} * or {@link com.android.build.OutputFile.OutputType#FULL_SPLIT} 
 * basic variant output information * TODO(jedo): reconcile the numerous subclasses. 
 public boolean supports(@MagicConstant(flagsFromClass = Features.class) int capability) { 
 * Interface implemented by loaders having a library as input. 
 public FullPackageLoader(@Nonnull InputJackLibrary inputJackLibrary, @Nonnull JPhantomLookup lookup) { super(inputJackLibrary, inputJackLibrary.getInputVDir(), lookup, NodeLevel.FULL); 
public class JayceMethodLoader implements MethodLoader, HasInputLibrary { 
public class JaycePackageLoader implements PackageLoader, HasInputLibrary { 
public class JaycePackageLoader implements PackageLoader, HasInputLibrary { 
 public StructurePackageLoader(@Nonnull InputJackLibrary inputJackLibrary, @Nonnull JPhantomLookup lookup) { super(inputJackLibrary, inputJackLibrary.getInputVDir(), lookup, NodeLevel.STRUCTURE); 
 if (value instanceof NoUsersListItem) { 
 if (value instanceof NoUsersListItem) { 
 public File getSkinPath() { 
 setVolumeNative(HeadsetHalConstants.VOLUME_TYPE_SPK, volumeValue); 
 } else if (value instanceof File) { 
 return ValidationResult.error(ValidationResult.Message.ILLEGAL_FILENAME, filename); 
 return ValidationResult.error(ValidationResult.Message.ILLEGAL_FILENAME, filename); 
 warningResult = ValidationResult.warn(ValidationResult.Message.NON_ASCII_CHARS); 
<|del|>
<|del|> 
 String path = getString(mStringAccumulator).replace('/', File.separatorChar); mHardware.setSkinFile(new File(path)); 
 public void setSkinFile(@Nullable File skinFile) { mSkinFile = skinFile; 
 && Objects.equals(mSkinFile, hw.getSkinFile()); 
<|del|> 
 private static final Logger LOG = Logger.getInstance(SampleImportAction.class); 
 return; 
 private static final Logger LOG = Logger.getInstance(SampleImportWizardPath.class); 
 public boolean supportsCapability(@MagicConstant(flagsFromClass = Features.class) int capability) { 
 public static boolean supportsCapability(@NotNull final Module module, @NotNull IAndroidTarget target, @MagicConstant(flagsFromClass = Features.class) int capability) { 
 new OpenUrlHyperlink("http://tools.android.com/tech-docs/project-sync-issues-android-studio", 
 throw new NotBinaryException(v + " is not a binary"); 
 private final String extension; 
 public boolean isBinaryFile(@Nonnull InputVFile v){ return (v.getName().endsWith(getFileExtension())); 
 public boolean isBinaryFile(@Nonnull InputVFile v){ return (v.getName().endsWith(getFileExtension())); 
 @Nonnull public static BinaryKind getBinaryKind(@Nonnull InputVFile v) throws NotBinaryException { for (BinaryKind kind : BinaryKind.values()) { if (kind.isBinaryFile(v)) { return kind; } 
 throw new NotBinaryException(v.getLocation().getDescription() + " is not a binary"); 
 File layoutFile = new File(skinPath, SdkConstants.FN_SKIN_LAYOUT); 
<|del|> 
 return typeParams.length > 0 ? getSimpleName(project, typeParams[0]) + "collection" : null; 
 return "library " + inputLibrary.getInputVDir().getLocation().getDescription(); 
 return "type " + typeName + " in " + inputLibLoc.getDescription(); 
 public final boolean equals(Object obj) { 
 public final int hashCode() { 
 myAvdDisplayList.setBorder(ourDefaultBorder); 
 .addCategory(DumpInLibrary.class); 
 * @param type the type to be evaluated 
<|del|> 
 ResourceValue v = styleValue.getItem(name, itemResourceValue.isFrameworkAttr()); 
<|del|>
 } catch (OutOfMemoryError e) { // Silently ignore OOME since gc stress mode causes them to occur but shouldn't be a // test failure. 
 if (error.equals(REQUEST_CANCELLED_STRING) || error.equals("access_denied")) { 
 private int translate(float tx, float ty) { 
 * @param method the method in which the resource name will be generated from 
 * @param method the method in which the resource name will be generated from 
 PsiType arrayComponentType = ((PsiArrayType) type).getComponentType(); 
<|del|> 
 OutputLibrary ol = Jack.getSession().getOutputLibrary(); assert ol != null; this.outputLibrary = ol; 
 return outputLibrary.needsSequentialWriting(); 
 public OutputVFile getJayceOutputVFile(@Nonnull VPath typePath) throws CannotCreateFileException { return outputVDir.createOutputVFile( new VPath(typePath.getPathAsString('/') + JayceFileImporter.JAYCE_FILE_EXTENSION, '/')); 
 public BinaryDoesNotExistException(@Nonnull Location location, @Nonnull VPath typePath, @Nonnull BinaryKind binaryKind) { this.location = location; this.typePath = typePath; 
 return binaryKind + " binary does not exist for " + typePath.getPathAsString('.') + " in " + location.getDescription(); 
 public InputLibraryLocation getLocation() { 
 private final boolean isIncrementalMode = 
 vFile = outputLibrary.getBinaryOutputVFile( new VPath(BinaryQualifiedNameFormatter.getFormatter().getName(type), '/'), BinaryKind.DEX); 
 public boolean needsSequentialWriting(); 
 public OutputVFile getBinaryOutputVFile(@Nonnull VPath typePath, @Nonnull BinaryKind binaryKind) throws CannotCreateFileException; 
 if (reportable instanceof EcjProblem) { printProblem(reportable.getDefaultProblemLevel(), ecjMessageProvider.getMessage((EcjProblem) reportable)); 
 @Nonnull public ProblemLevel getDefaultProblemLevel(); 
 myInactiveColor = UIUtil.isUnderDarcula() ? UIManager.getColor("darcula.inactiveBackground") : new Color(0xf5f5f5); 
<|del|> 
 // incremental mode is managed by the output library. It is a temporary check until Jack // Incremental will be updated. 
@Description("Jayce format production") 
@Description("Jayce file output") @Name("JayceFileOutput") 
<|del|> 
 myModuleTemplates = Lists.newArrayList((ModuleTemplate)new NewCloudModuleTemplate()); 
 // Do nothing. 
 // This string will not be displayed to the user. 
 for (TemplateInfo template : CLOUD_TEMPLATES) { 
 // Test simple operations on a double array to ensure the register allocator works // properly. 
 private boolean myIsBinary; private boolean myIsStrict; 
 public static Patch create(PatchSpec spec, File patchFile, UpdaterUI ui) throws IOException, OperationCancelledException { 
 private boolean myIsBinary; private boolean myIsStrict; 
 String message = "<html>Some conflicts were found in the installation area.<br><br>"; 
 message += "Some of the conflicts below do not have a solution, so the patch cannot be applied.<br>" + 
 boolean hasError = text != null && text.toLowerCase(Locale.US).contains("error"); 
<|del|> 
<|del|> 
 DefaultActionGroup toolbarActions = new DefaultActionGroup(); ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, toolbarActions, false); 
 panel.updateUI(); Executor defaultExecutor = DefaultRunExecutor.getRunExecutorInstance(); final RunContentDescriptor contentDescriptor = new RunContentDescriptor(consoleView, myProcessHandler, panel, myTitle); 
 switch (myInsertType) { 
 execute(myContext, newRowComponent, myComponents, null); 
 protected static boolean rowExists(@Nullable RadComponent[][] components, int row) { 
 return components != null && row >= 0 && components.length > row; 
 myZipOutputStream.write(bytes); 
 for (int i = 0; i < size; i++) { 
 clone.mSize = size; 
 if (value == null) { // No cloning required. } else if (value instanceof MessageNano) { 
 task.setSendingToBottom(false); 
 // Try to cause a class loading/linking while GC is running. 
 // A class with lots of fields so that the class loading/linking takes a long time. 
<|del|> 
<|del|>
 // nothing to handle for inputs 
 // nothing to handle for inputs 
 zos.putNextEntry(vFile.getZipEntry()); 
 * A directory in an {@link InputOutputZipRootVDir} VFS. 
 case DateFormat.LONG: // CLDR doesn't really have anything we can use to obey the 12-/24-hour preference. 
 throw new JillException("Error writing '" + LIBRARY_PROPERTIES + "' to output zip", e); 
 @NonNls 
 @NonNls 
 private String ignoreAssets; 
<|del|> 
 for (Enumeration<JarEntry> e = jarFile.entries(); e.hasMoreElements();) { JarEntry jarEntry = e.nextElement(); String name = jarEntry.getName(); 
 zipFile = new ZipFile(aarFile); 
 for (Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) { ZipEntry zipEntry = e.nextElement(); String name = zipEntry.getName(); 
 "class files to be transformed contained recursively in directories or in a zip/jar file", metaVar = "FILE|DIRECTORY") 
 * A {@link Reporter} for the SDK. 
 public ProductFlavorCombo(@NonNull GroupableProductFlavor... flavors) { 
 public ProductFlavorCombo(@NonNull Iterable<GroupableProductFlavor> flavors) { 
 @NonNull Iterable<? extends GroupableProductFlavor> productFlavors) { 
 * Describe a {@code PropertyId} category. 
 * Describe the default {@code Category}. 
 public void showWarning(String message) { System.out.println("Warning: " + message); 
 basePlugin.createCheckTasks(!productFlavors.isEmpty(), false /*isLibrary*/); 
<|del|> 
 private static final Logger LOG = Logger.getInstance(HierarchyUtils.class.getName()); 
 private static final Logger LOG = Logger.getInstance(NavigationView.class.getName()); 
 paintConstraint(graphics, constraint.type, sourceNode, sourceBounds, targetNode, targetBounds, allConstraints, false /* highlightTargetEdge */, rtlContext); 
 public static void assertEquals(float expected, float result) { 
 if (Strings.isNullOrEmpty(line) || line.equals("Ready")) { return; } 
 if (Strings.isNullOrEmpty(line)) { return; } 
 boolean isPseudolocalizeEnabled(); 
<|del|> 
 if (FileUtil.filesEqual(skinFolder, NO_SKIN)) { 
 // Sum[i = 0..999](i) = 999 * 1000 / 2 = 499500L. assertEquals(499500L, $opt$LargeFrame()); 
 public int getX(@NotNull TextDirection textDirection, @SuppressWarnings("UnusedParameters") @Nullable RadViewComponent node, @NotNull Rectangle bounds) { 
 protected final TextDirection myTextDirection; 
 ConstraintPainter.paintSelectionFeedback(graphics, parent, childNodes, showDependents, new TextDirection(panel)); 
 private boolean mPseudoLocalesEnabled = false; 
 private boolean pseudoLocalesEnabled; 
 boolean isPseudoLocalesEnabled(); 
<|del|> 
 this.networkTimeMs = networkTimeMs; 
 /* package */ void setNetworkTimeMs(long networkTimeMs) { this.networkTimeMs = networkTimeMs; 
 /* package */ void setNetworkTimeMs(long networkTimeMs) { this.networkTimeMs = networkTimeMs; 
 /* package */ long getNetworkTimeMs() { return networkTimeMs; 
 /* package */ void setNetworkTimeMs(long networkTimeMs) { 
public enum TextDirection { LEFT_TO_RIGHT, RIGHT_TO_LEFT; 
<|del|> 
 for (int retries = 0; retries < 10; retries++) { // createSession will also render the layout for the first time. 
<|del|> 
 " dx --dex [--debug] [--verbose] [--positions=<style>] " + 
 } catch (JayceVersionException e) { 
 * A factory of {@link JayceInternalReader}. 
 "The version of the library is older than the current version but is " 
 "The version of the library is older than the current version but is " 
 sysLog.log(Level.SEVERE, "Fails to parse the property " + Library.KEY_LIB_MINOR_VERSION + " from " + inputJackLibrary.getLocation(), e); throw new LibraryFormatException(inputJackLibrary.getLocation()); 
 public int getMajorVersion(); 
 public int getMajorVersion(); 
 * Reflection support to instantiate {@link InputLibrary} and {@link OutputLibrary}. 
 return location.getDescription() + " is an invalid library: " + super.getMessage(); 
 super(location, " property " + propertyName + " not found"); 
 super(location, " property " + propertyName + " should not be defined."); 
 throw new LibraryIOException(getLocation(), e); 
 throw new LibraryIOException(getLocation(), e); 
 throw new LibraryIOException(getLocation(), e); 
 throw new LibraryIOException(getLocation(), e); 
 throw new LibraryIOException(getLocation(), e); 
 Library.KEY_LIB_EMITTER + "=unknown\n" 
 Library.KEY_LIB_EMITTER + "=unknown\n" 
 Library.KEY_LIB_EMITTER + "=unknown\n" 
<|del|> 
 public Result render() { return render(RenderParams.DEFAULT_TIMEOUT); 
 throws LibraryFormatException { 
<|del|> 
<|del|> 
 if (sourceDirs.isEmpty()) { 
 public static final PrintStream noop = new PrintStream(new OutputStream() { 
 sysLog.log(Level.SEVERE, "Failed to parse the property " + JayceProperties.KEY_JAYCE_MAJOR_VERSION + " from " + inputLibrary.getLocation().getDescription(), e); 
 throw new AssertionError("Library constructor not found for version " + version); 
 throw new AssertionError("Library constructor not found for version " + version); 
 if (features.contains(Resources.class)) { if (targetProduction.contains(DexFileProduct.class)) { planBuilder.append(ResourceWriter.class); } 
 if (features.contains(Resources.class)) { if (targetProduction.contains(DexFileProduct.class)) { planBuilder.append(ResourceWriter.class); } 
 private static Logger logger = LoggerFactory.getLogger(); 
 logger.log(Level.SEVERE, "Library " + inputJackLibrary.getLocation().getDescription() + " is invalid", 
 logger.log(Level.SEVERE, "Library " + inputJackLibrary.getLocation().getDescription() + " is invalid", 
 private static Logger logger = LoggerFactory.getLogger(); 
 logger.log(Level.SEVERE, "Library " + inputJackLibrary.getLocation().getDescription() + " is invalid", e); throw new LibraryFormatException(inputJackLibrary.getLocation()); 
public abstract class JayceWriterFactory extends JayceProcessor { 
 private static Logger logger = LoggerFactory.getLogger(); 
 return location.getDescription() + " is not a jack library"; 
<|del|> 
<|del|> 
 public void addDexFiles(@NonNull File mainDexFolder, @NonNull Collection<File> extraDexFiles) 
 for (File dexFile : extraDexFiles) { addFile(dexFile, String.format(FN_APK_CLASSES_N_DEX, dexIndex++)); 
 if (ATTR_KEEP.equals(attr.getLocalName())) { 
 private void check() throws LibraryException { 
 private JTextArea mySdkManagerOutput; 
 /** * This concrete class is needed as Mockito cannot spy on abstract classes. */ private static class DummySdkLoggerIntegration extends SdkLoggerIntegration { 
 // Needed for mock object 
 outDir = (buildDir == null) ? new File("build/tests") : new File(buildDir, "tests"); 
 assertEquals(2.3f, fields.iF); 
 * Installs the given APK files on the device. It requires a device with API level 21+ otherwise * a {@link com.android.builder.testing.api.DeviceException} will be thrown. * 
 throw new InstallException("Internal error, file a bug, multi-apk applications" + " require a device with API level 21+"); 
 for (File apkFile : apkFiles) { 
 @Override public SSLSocket createSocket(String host,int port, InetAddress localHost, 
 String errOutput = te.endErrRedirection(); Assert.assertTrue(errOutput.contains("is an invalid library")); Assert.assertTrue(errOutput.contains("(Permission denied)")); 
 OutputVFile vFile = outputJackLibrary.createFile(FileType.JAYCE, 
<|del|> 
 public InputVFile getFile(@Nonnull FileType fileType, @Nonnull VPath typePath) 
 public OutputVFile createFile(@Nonnull FileType fileType, @Nonnull VPath typePath) 
 * Exception specifying that an {@link InputVFile} is not supported by the library 
 } } else { currentSectionVFS = new GenericInputVFS(prefixedInputVFS); 
<|del|> 
 return Objects.toStringHelper(this) .add("packageName", mPackageName) .add("versionCode", mVersionCode) .add("versionName", mVersionName) .toString(); 
<|del|> 
<|del|> 
 c = Color.BLACK; 
<|del|> 
 InetAddress localAddress, int localPort) throws IOException { 
 public List<SSLSocket> getCreatedSockets() { 
 DEX("dex", "dex", ".dex", "dex") { 
 if (mItemCount > 0 && targetPosition >= 0 && targetPosition < mItemCount) { scrollToChild(targetPosition - mFirstPosition); 
 if (mItemCount > 0 && targetPosition >= 0 && targetPosition < mItemCount) { scrollToChild(targetPosition - mFirstPosition); 
 throw new Error("Should have gotten a ClassCastException"); 
 private static File getSourceJarForAndroidSupportAar(@NotNull File jarFilePath) { 
 if (ResourceFolderManager.EXPLODED_AAR.equals(pathSegments.get(i))) { 
 File androidHomePath = DefaultSdks.getDefaultAndroidHome(); 
 assertEnabledProtocols(compatibleSocket, "TLSv1", "SSLv3"); 
<|del|> 
 public boolean containsFileType(@Nonnull FileType fileType) { return fileTypes.contains(fileType); 
 return !AndroidPlugin.isGuiTestingMode() && !Boolean.getBoolean(SYSTEM_PROPERTY_DISABLE_WIZARD) && !instance.isSdkUpToDate(); 
 // RFC 2315 section 9.1: if authenticatedAttributes is present, it 
 lp.gravity = Gravity.START | (mButtonGravity & Gravity.VERTICAL_GRAVITY_MASK); 
 public VPath clone() { // no need to clone path fragments, they should be immutable @SuppressWarnings("unchecked") ArrayList<VPathFragment> clonedList = (ArrayList<VPathFragment>) pathFragments.clone(); 
 packagePath == null ? VPath.ROOT : packagePath).list()) { 
 typePath = packagePath.clone(); 
 return "resource"; 
 VPath subPackagePath = getPathFromPackage(simpleName); try { inputJackLibrary.getDir(FileType.JAYCE, subPackagePath); } catch (FileTypeDoesNotExistException e) { throw new JPackageLookupException(simpleName, loading); 
 } } catch (FileTypeDoesNotExistException e) { // It could not append if the library contain jayce files, and because package existence is // checked at construction throw new AssertionError(); 
<|del|> 
 public String toString() { return "rsc"; 
 @Nonnull String extension) { 
 VPath clonedPath = typePath.clone(); clonedPath.addSuffix(fileType.getFileExtension()); clonedPath.prependPath(fileType.getVPathPrefix()); return libraryVDir.getInputVFile(clonedPath); 
 return new InputOutputZipVDir(file, zipFile, new ZipEntry(path.getPathAsString(ZIP_ENTRY_SEPARATOR))); 
 return new InputOutputZipVFile(file, zipFile, new ZipEntry(path.getPathAsString(ZIP_ENTRY_SEPARATOR))); 
 if (ive.isVDir()) { throw new NotFileOrDirectoryException(new DirectoryLocation(pathAsString)); 
 throw new NoSuchFileException(new DirectoryLocation(pathAsString)); 
 for (Iterator<InputRootVDir> iter = session.getPathSources(); iter.hasNext();) { 
 rules.addAll(parseRules(session, inputStream)); 
public abstract class ResourceOrMeta implements HasLocation { 
 return Iterators.emptyIterator(); 
 * Copyright (C) 2014 The Android Open Source Project 
 break; } else if (this.mSubLayer > child.mSubLayer) { continue; 
 is = inputFile.openRead(); os = outputFile.openWrite(); ByteStreamSucker sucker = new ByteStreamSucker(is, os, true /* close */); 
 private AndroidProject execute( 
<|del|> 
<|del|> 
 if (defaultJdk == null) { // Unlikely to happen throw new IllegalStateException("Failed to create IDEA JDK from '" + path.getPath() + "'"); } 
 if (Objects.equal(jdk.getName(), defaultJdk.getName())) { 
 public static void setRandomSeedInternal(long seed) { 
 * Analyzes system state and decides if and how the wizard should be invoked. 
 @NotNull private final FirstRunWizardMode myMode; 
 // Use a different condition to avoid having dx being too clever. 
 private static final String[] TAR_EXTENSIONS = {"tgz", "tar", "tar.gz"}; private static final String[] ZIP_EXTENSIONS = {SdkConstants.EXT_ZIP}; 
 public static ArchiveType fromFileName(@NotNull String fileName) { String lowerCaseName = fileName.toLowerCase(); if (extensionIsOneOf(lowerCaseName, TAR_EXTENSIONS)) { 
 throw new WizardException(String.format("Unrecognized archive file format for file %s", fileName)); 
<|del|> 
<|del|> 
 private boolean mySetupFailed; public FirstRunWizard(@NotNull DynamicWizardHost host, @NotNull FirstRunWizardMode mode) { 
 Class<?> clazz = Class.forName("com.google.annotationresolution.test." + "Annotated"); clazz.getAnnotations(); 
<|del|> 
 private boolean containsRuntimeAnnotation(@Nonnull Collection<JAnnotation> annotationTypes) { for (JAnnotation annotation: annotationTypes) { if (annotation instanceof JDefinedAnnotation && (((JDefinedAnnotation) annotation).getRetentionPolicy() == JRetentionPolicy.RUNTIME)) { 
@Description("Mark runtime visible annotations as MainDexInstaller") 
 transformed != null ? (int) Math.ceil(Layout.getDesiredWidth(transformed, mTextPaint)) : 0, 
 transformed != null ? 
 SdkManager manager = SdkManager.createManager(mySdkLocation.getAbsolutePath(), new LogWrapper(Logger.getInstance(getClass()))); 
 throw new WizardException("Corrupt SDK installation"); 
 * Mark classes annotated by runtime visible annotation as main dex. * See {@link AnnotationWithEnumFinder} for details. 
 // Ignore external types if (type.isExternal()) { return; } if (hasProblematicAnnotation(type)) { 
@Description("Mark runtime visible annotations as MainDexInstaller") 
 * Mark classes as main dex if they are annotated by runtime visible annotation or if one of their * member is. * See {@link RuntimeAnnotationFinder} for details. 
 private boolean hasRuntimeAnnotation(@Nonnull JDefinedClassOrInterface type) { 
 // Tests about bug https://code.google.com/p/android/issues/detail?id=78144 // Dalvik may throw IllegalAccessError when a class is in a different dex than an enum // used in its annotations. 
 GradleUtil.createGradleWrapper(projectDirPath); 
 final List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId); 
 // default, then it is always desirable to pick it. 
<|del|>
 if (isAnnotatedByRuntimeAnnotation(type)) { 
 private boolean isAnnotatedByRuntimeAnnotation(@Nonnull Annotable annotable) { for (JAnnotation annotation: annotable.getAnnotationTypes()) { 
 private boolean isAnnotatedByRuntimeAnnotation(@Nonnull Annotable annotable) { for (JAnnotation annotation: annotable.getAnnotationTypes()) { 
 private boolean isAnnotatedByRuntimeAnnotation(@Nonnull Annotable annotable) { for (JAnnotation annotation: annotable.getAnnotationTypes()) { 
 private final HashMap<HostAndPort, SSLSession> sessionsByHostAndPort = new HashMap<>(); 
 return true; 
 return true; 
 public void testKeyStore_Encrypting_RSA_NONE_NOPADDING() throws Exception { 
 public void testKeyStore_Encrypting_RSA_NONE_NOPADDING() throws Exception { 
 Calendar cal = Calendar.getInstance(); cal.set(1944, 5, 6); 
 if(!rs.usingIO() && (usage & (USAGE_IO_INPUT | USAGE_IO_INPUT)) != 0) { throw new RSRuntimeException("USAGE_IO not supported, Allocation creation failed."); 
 // othe nly 5 lower bits should be used for shifting (& 0x1f). 
 else if (jarName.endsWith(SdkConstants.DOT_JAR)) { 
 public static final int EXPECTED_DEFAULT_SSL_SESSION_CACHE_TIMEOUT = (IS_RI) ? 24 * 3600 : 8 * 3600; 
 sort(coordinates, GradleCoordinate.COMPARE_PLUS_LOWER); 
 return users.isEmpty(); 
 @SuppressWarnings("ConstantConditions") // This suppresses an invalid nullref warning for GoogleLogin.getInstance().getActiveUser(). 
 LOG.error("InterruptedException while saving project: " + ex.toString()); return false; 
 LOG.error("InvocationTargetException while saving project: " + ex.toString()); return false; 
 private static boolean fetchGit(@NotNull final Project project, 
 indicator.setText(GctBundle.getString("uploadsourceaction.addfiles")); 
 indicator.setText(GctBundle.getString("uploadsourceaction.performingcommit")); 
 setTitle(GctBundle.getString("uploadsourceaction.addfilestitle")); 
 } 
 } if (ws.isFullscreen(dw, dh) && ws.isOpaqueDrawn()){ break; } 
 public DST checkString(@Nonnull CodecContext context, @Nonnull String string) 
 * This {@link StringCodec} is used to create an instance of {@link Service} 
 String name = myTemplateDevice.getDisplayName() + " (Edited)"; myState.put(DEVICE_NAME_KEY, getUniqueId(name)); 
 public static DeviceManagerConnection getDeviceManagerConnection(@NotNull LocalSdk sdk) { 
<|del|> 
 @NonNls static final String SETTINGS_JAR_MARKER = "IntelliJ IDEA Global Settings"; 
 * Define a category for version Brest. 
 vmCommandBuilder.vmArgs("-Xverify:none"); vmCommandBuilder.vmArgs("-Xdexopt:none"); 
 message = "An existing Android SDK was detected. The setup wizard will only download missing or outdated SDK components."; 
 message = "An existing Android SDK was detected. The setup wizard will only download missing or outdated SDK components."; 
 if (key.isEmpty()) { 
 if (key.isEmpty()) { 
 if (keyValueSeparator < 0) { continue; } final String key = line.substring(0, keyValueSeparator).trim(); final String value = line.substring(keyValueSeparator + 1).trim(); if (key == "") { continue; } 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 return properties; 
<|del|> 
 if (keyValueSeparator < 0) { continue; } final String key = line.substring(0, keyValueSeparator).trim(); final String value = line.substring(keyValueSeparator + 1).trim(); if (key == "") { continue; } 
 if (keyValueSeparator < 0) { continue; } final String key = line.substring(0, keyValueSeparator).trim(); final String value = line.substring(keyValueSeparator + 1).trim(); if (key == "") { continue; } 
 String androidSdkPath = properties.get("androidsdk.dir"); File androidDest = StringUtil.isEmptyOrSpaces(androidSdkPath) ? null : new File(androidSdkPath); return new InstallerData(getIfExists(properties, "jdk.dir"), getIfExists(properties, "androidsdk.repo"), androidDest); 
 public static String renderColor(Module module, @NotNull Color color) { 
import javax.swing.table.TableModel; public interface CellSpanModel extends TableModel { 
 * A custom combobox that allows the user to select a GoogleLogin and also signin/add-account all within a single control. 
 private JBPopup myPopup; 
 private ProjectSelector myProjectSelector; 
 private static void uploadProjectToGoogleCloud(@NotNull final Project project, @Nullable final VirtualFile file) { 
 final String remoteUrl = GcpHttpAuthDataProvider.getGcpUrl(user, projectId); 
 private static boolean isGitSupported(final Project project) { 
 @NotNull GitRepository repository, @NotNull String remote, final @NotNull String url) { 
 // check if there are no commits 
 @SuppressWarnings("ConstantConditions") // This suppresses an invalid null warning for calling the super with null params. 
<|del|> 
 return ""; } 
 throw new IOException("\"" + file.getPath() + "\" is not a directory neither a zip file"); 
 throw new IOException("\"" + file.getPath() + "\" is not a directory neither a zip file"); 
 throw new FileNotFoundException("File \"" + file.getPath() + "\" not found"); 
 throw new FileNotFoundException("File \"" + file.getPath() + "\" not found"); 
 throw new IOException("Wrong classpath: " + e.getMessage(), e); 
 synchronized DirectClassFile getClass(String path) throws FileNotFoundException { 
 throw new FileNotFoundException("File \"" + path + "\" not found"); 
 jackOptions.setSanityChecks(sanityChecks); 
<|del|> 
 args.add("--output-jack-dir"); 
 public static final String KEY_DEPENDENCIES = "dependencies"; 
<|del|> 
 public static final char MAP_KEY_VALUE_SEPARATOR = ':'; 
 LineParser(@Nonnull String line) { 
 @CheckForNull private String nextToken(char separator) { 
 public static final VPath vpath = new VPath("files", '/'); 
<|del|> 
 writeMapOne2Many(sb, javaFileToTypes); sb.append(Dependency.MAP_SEPARATOR); sb.append("\n"); 
 writeMapOne2Many(sb, javaFileToTypes); sb.append(Dependency.MAP_SEPARATOR); sb.append("\n"); 
 public void read(@Nonnull InputVFile inputVFile) throws CannotReadException { 
 throw new CannotReadException(inputVFile.getLocation(), e); 
 throw new CannotReadException(inputVFile.getLocation(), e); 
 for (Map.Entry<String, Set<String>> entry : javaFileToTypes.entrySet()) { if (entry.getValue().contains(typeName)) { return entry.getKey(); } } return null; 
<|del|> 
 outputVFile = intermediateDexDir.getRootOutputVDir().createOutputVFile(fileDependencyPath); 
 IncrementalException incrementalException = new IncrementalException(e); Jack.getSession().getReporter().report(Severity.FATAL, incrementalException); throw new JackAbortException(incrementalException); 
 IncrementalException incrementalException = new IncrementalException(e); Jack.getSession().getReporter().report(Severity.FATAL, incrementalException); throw new JackAbortException(incrementalException); 
 public void check() { 
 public String buildPropertyName(@CheckForNull String suffix) { return (propertyPrefix + (suffix == null ? "" : suffix)); 
 public VPath buildDirVPath(@Nonnull VPath vpath) { return getPathWithPrefix(vpath); 
 private final Object mTimeProviderLock = new Object(); 
 ws.isDisplayedLw() && winAnim.mSurfaceShown) { 
<|del|> 
 // method ref). 
 ClassDefItem clazz = translateClass(name, bytes, classFile); 
 * return true if the handoff data was updated since the last time wizard ran 
 AndroidFirstRunPersistentData.getInstance().markSdkUpToDate(myMode.getInstallerTimestamp()); 
 AndroidFirstRunPersistentData.getInstance().markSdkUpToDate(myMode.getInstallerTimestamp()); 
 SetPreference setPreference = new SetPreference(myMode.getInstallerTimestamp()); 
 return !myMode.hasValidSdkLocation() && myState.getNotNull(myKeyCustomInstall, true); 
 checkVersion(apk, code, null /* versionName */); 
 @Nullable String versionName) 
 Map<ModeId, Set<Variant>> modeVariants = null; 
 Map<ModeId, Set<Variant>> result = new EnumMap<ModeId, Set<Variant>>(ModeId.class); 
 set = EnumSet.noneOf(Variant.class); 
 // Keep holder alive to make instance OOM happen faster. 
 System.out.println("NEW_ARRAY did not throw OOME"); 
 System.out.println("NEW_INSTANCE (finalize) did not throw OOME"); 
 throw new WizardException("Corrupt SDK installation"); 
 /** Thread pool object used for multi-thread dex conversion (to byte array). 
<|del|> 
 throw new RuntimeException("Timed out waiting for dex writer threads."); 
 throw new RuntimeException("A dex writer thread has been interrupted."); 
 Future<Boolean> res = classDefItemConsumer.submit(new ClassDefItemConsumer( name, cdif, maxMethodIdsInClass, maxFieldIdsInClass)); addToDexFutures.add(res); 
 Arrays.fill(plainText, (byte) 0xFF); 
 public void read(@Nonnull Readable reader) throws IOException { javaFileToTypes = readMapOne2Many(new LineReader(reader)); 
 public void read(@Nonnull Readable readable) throws IOException { LineReader lr = new LineReader(readable); hierarchyDependencies = readMapOne2Many(lr); constantDependencies = readMapOne2Many(lr); codeDependencies = readMapOne2Many(lr); 
 @NonNull Boolean getFunctionalTest(); 
 public void testDensitySplitOutputs() throws Exception { 
 assert prefix.endsWith("" + ZipUtils.IN_ZIP_SEPARATOR); 
 } Iterator<String> names = splitter.split(relativePath).iterator(); 
 // Would throw an ArithmeticException if b were null (hence // the enclosing `try' statement). 
 void delete(@Nonnull VPath path) throws DeleteException; 
 * An {@link Exception} that occurs when a requirement for the support of a specific Java source * version is missing. 
 } catch (NullPointerException expected) { } 
 (HttpsURLConnection) new URL(UNRESOLVABLE_HTTPS_URL).openConnection(); 
<|del|> 
 throw new AssertionError("Failed to obtain okhttp HostnameVerifier", e); 
 * Returns {@code true} iff {@code hostName} matches the domain name {@code pattern}. 
<|del|>
<|del|>
<|del|> 
<|del|> 
<|del|> 
 BrowserUtil.browse("http://tools.android.com/tech-docs/new-build-system/migrating-to-1-0-0"); 
 final Ref<Boolean> atLeastOneUpdated = new Ref<Boolean>(); 
<|del|> 
<|del|> 
 } catch (IOException e) { LOG.warn("Failed to update Gradle version in wrapper", e); } 
<|del|> 
 String msg = "Unable to find any references to the Android Gradle plugin in build.gradle files.\n\n" + 
 "Defines the policy to follow concerning type collision", new EnumCodec<CollisionPolicy>(CollisionPolicy.class, CollisionPolicy.values()).ignoreCase()) 
 "Defines the policy to follow concerning type collision from imported jack libraries", 
 prefix = "Android (on device) tests"; 
 private static final long GET_PROP_TIMEOUT_MS = 100; 
 } else if (expectation.getIsFromExpectationFile()) { // If the expectation is created from a file, make this a warning, to // mimic CTS's behavior. return ResultValue.WARNING; 
<|del|> 
 updateEnabled(); 
<|del|> 
 * A ProcessListener that wraps one or more ProcessListeners and passes on events to them. 
 private static class BufferedProcessListener implements ProcessListener { private static final int BUFFER_SIZE = 100; 
 private final List<ProcessListener> myListeners = Lists.newLinkedList(); private final EvictingQueue<Event> eventBuffer = EvictingQueue.create(100); 
 private final List<ProcessListener> myListeners = Lists.newLinkedList(); private final EvictingQueue<Event> eventBuffer = EvictingQueue.create(100); 
 private final List<ProcessListener> myListeners = Lists.newLinkedList(); private final EvictingQueue<Event> eventBuffer = EvictingQueue.create(100); 
<|del|> 
<|del|> 
 myListeners.add(listener); 
 BrowserUtil.browse(new URI(getUrl())); 
<|del|> 
 assertEquals("Goodbye, World", defaultValuesMap.get(getParameterObject(template, "p4"))); assertEquals("Goodbye, World!", defaultValuesMap.get(getParameterObject(template, "p5"))); } 
 @NonNull 
 // probably a Java-only project. add to the map map.put(path, null); 
 // probably a Java-only project. add to the map map.put(path, null); 
<|del|>
<|del|>
<|del|> 
<|del|> 
 public static final BooleanPropertyId OPTIMIZE_TAIL_RECURSION = BooleanPropertyId.create( "jack.optimization.tail-recursion", "Optimize tail recursive calls") .addDefaultValue(Boolean.FALSE).addCategory(DumpInLibrary.class); 
 public static final BooleanPropertyId OPTIMIZE_TAIL_RECURSION = BooleanPropertyId.create( "jack.optimization.tail-recursion", "Optimize tail recursive calls") .addDefaultValue(Boolean.FALSE).addCategory(DumpInLibrary.class); 
import com.android.sched.util.file.FileOrDirectory.Permission; import com.android.sched.util.file.Files; 
<|del|> 
<|del|> 
 /** * Returns the severity of the issue. */ 
 // Check all the current threads for positive IDs. 
 private final long mDownloadSize; 
 // fails, rather than instantly starting the ping, we'll hold off for a few minutes. 
 return Objects.hashCode(target, systemImage, remotePackage); 
<|del|> 
 if (myState.get(DEFAULT_ORIENTATION_KEY) == null) { 
<|del|> 
<|del|> 
 int resultIndex = 2 * i; result[resultIndex] = (HEX_DIGITS[(b >>> 4) & 0x0f]); result[resultIndex + 1] = (HEX_DIGITS[b & 0x0f]); 
 putProperty(DexProperties.KEY_DEX, String.valueOf(true)); 
 throw new AssertionError("Missing digest algorithm: ", e); 
 // SHA-1 digests are 20 bytes in length and MD5 digests are usually 16 // bytes in length. ByteArrayOutputStream baos = new ByteArrayOutputStream(36); 
 throw new AssertionError("Missing digest algorithm: ", e); 
<|del|> 
 rotateDexFile(); 
 private DexFile dexFile; 
 private DexWriter(DexFile dexFile) { this.dexFile = dexFile; 
 private static ClassDefItem translateClass(byte[] bytes, DirectClassFile cf) { 
 private static boolean addClassToDex(ClassDefItem clazz) { 
<|del|> 
 public int runJUnit(@Nonnull String[] options, @Nonnull String jUnitRunnerName, @Nonnull String[] jUnitTestClasses, @Nonnull File... classpathFiles) throws RuntimeRunnerException { return runJunitOnDevice(options, jUnitRunnerName, jUnitTestClasses, classpathFiles); 
 sb.append(def.getTypeName()); 
 private static Map<AndroidRunConfigurationBase, Map<Module, Integer>> ourChosenConfigurations = Maps.newHashMap(); 
 private AndroidRunConfigurationBase myCurrentRunConfiguration; private Module myCurrentModule; private AndroidFacet myCurrentFacet; private List<? extends CloudTestConfiguration> myTestingConfigurations; private ActionListener myActionListener; private final CloudTestConfigurationProvider myConfigurationFactory; 
 private AndroidRunConfigurationBase myCurrentRunConfiguration; private Module myCurrentModule; private AndroidFacet myCurrentFacet; private List<? extends CloudTestConfiguration> myTestingConfigurations; private ActionListener myActionListener; private final CloudTestConfigurationProvider myConfigurationFactory; 
 public void setConfiguration(AndroidRunConfigurationBase runConfiguration) { if (!Boolean.getBoolean(SHOW_GOOGLE_CLOUD_TESTING_OPTION)) { return; // Running tests in cloud is not enabled! } 
 private AndroidRunConfigurationBase myCurrentRunConfiguration; private Module myCurrentModule; 
 private static Map<AndroidRunConfigurationBase, Map<Module, String>> ourChosenCloudProjects = Maps.newHashMap(); 
 * <p>Note that in Lollipop this could throw an {@code ErrnoException} with {@code EINTR}. 
 return AndroidIcons.Themes; 
<|del|> 
 String accumulativeTitle = "Cumulative".toUpperCase(); String distributionTitle = "Distribution".toUpperCase(); 
 classTranslatorPool = new ThreadPoolExecutor(args.numThreads, args.numThreads, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(2 * args.numThreads, true), new ThreadPoolExecutor.CallerRunsPolicy()); 
 setLayout(new GridBagLayout()); setPreferredSize(new Dimension(MIN_WIDTH, PREFERRED_HEIGHT)); setOpaque(false); 
 add(googleIcon, c); 
 add(signinTextArea, c); 
import com.google.api.client.repackaged.com.google.common.base.Strings; import com.google.common.annotations.VisibleForTesting; 
 @NotNull 
 public void setSelectedUser(@NotNull String selectedUser) { 
 getContentPane().setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER); getContentPane().setViewportView(myJList); 
 @SuppressWarnings("ConstantConditions") // This suppresses a nullref warning for GoogleLogin.getInstance().getActiveUser(). 
 class EmptyMarker { 
 class EmptyMarker { 
 private static void clone(final Project project, @NotNull final Git git, @Nullable final Listener listener, final VirtualFile destinationParent, @NotNull final String sourceRepositoryURL, @NotNull final String directoryName, final String parentDirectory, @Nullable final String gcpUserName) { 
 private static void clone(final Project project, @NotNull final Git git, @Nullable final Listener listener, final VirtualFile destinationParent, @NotNull final String sourceRepositoryURL, @NotNull final String directoryName, final String parentDirectory, @Nullable final String gcpUserName) { 
 private static boolean fetchGit(@NotNull final Project project, 
 splitter.setProportion(SPLIT_PROPORTION); 
 @NotNull private TestDialogManager myDialogManager; private MockGoogleLogin myGoogleLogin; private boolean myDialogShown; 
 @NotNull private TestDialogManager myDialogManager; private MockGoogleLogin myGoogleLogin; private boolean myDialogShown; 
 myDialogManager.registerDialogHandler(SelectUserDialog.class, new TestDialogHandler<SelectUserDialog>() { 
 public void testOnlyForGcp() { 
 public void testForGcpPrompt() throws Exception { 
 if (resources == null || resources.isEmpty()) { 
 } 
 if (!Objects.equal(mySelectedObject, anItem)) { 
 if (myAttributeDefinitions.getAttrDefByName(ANDROID_PREFIX_START.matcher(propertyName).replaceFirst( "")) == null) { 
public class ClickableEditor extends AbstractTableCellEditor implements TableCellRenderer { 
 StringBuilder valueBuilder = new StringBuilder().append(resource.getPrefix()); 
 super("Theme Editor", null, AndroidIcons.Themes); 
 ThemeEditorUtils.openThemeEditor(module); 
 for (ThemeEditorStyle theme : themesRaw) { 
 for (final List<EditedStyleItem> list : classes) { for (final EditedStyleItem wrapper : list) { 
 private static final Logger LOG = Logger.getInstance(AttributesTableModel.class); 
 /** * Returns whether a certain attribute accepts a given attribute format. */ private static boolean acceptsFormat(@Nullable AttributeDefinition attrDefByName, @NotNull AttributeFormat want) { 
 // TODO: can we work out the type by looking at the value? 
 if (myAttributeDefinitions.getAttrDefByName(propertyName.substring(propertyName.indexOf(":")+1)) == null) { 
 mySelectedStyle.setValue(propertyName, strValue); 
 void clicked(EditedStyleItem value); 
 void clicked(EditedStyleItem value); 
<|del|> 
 public String name; public String value; 
 GraphicsUtil.setupAntialiasing(g); 
 LOG.error(String.format("Object passed to ColorRendererEditor has class %1$s instead of ItemResourceValueWrapper", obj.getClass().getName())); 
 * Cell editor used to replace {@link ItemResourceValue} with extracted "simple" value, 
 * Cell renderer used to add tooltips to table cells containing {@link ItemResourceValue} 
<|del|> 
 protected JLabel myReadOnlyLabel = new JLabel(); 
 setLayout(new BoxLayout(this, BoxLayout.LINE_AXIS)); 
 add(myReadOnlyLabel); 
 private final Cache<String, ThemeEditorStyle> myStylesCache = CacheBuilder.newBuilder() 
 public TableLabel(@NotNull String labelName, int rowPosition) { 
 // We currently use the default device. We will dynamically adjust the width and height depending on the size of the window. // TODO: Add configuration chooser to allow changing parameters of the configuration. 
<|del|> 
 myThemeCombo = new ComboBox(); // We have our own custom renderer that it's not based on the default one. //noinspection GtkPreferredJComboBoxRenderer 
 mySubStyleLabel.setText("\\u27A5 " + myCurrentSubStyle.getSimpleName()); 
 .format("<html>The '%1$s' style is Read-Only.<br/>A new style will be created to modify '%2$s'.<br/></html>", selectedStyle.getName(), rv.getName()), EditedStyleItem.getQualifiedName(rv), strValue); 
 .format("<html>The style '%1$s' which references to '%2$s' is also Read-Only.<br/>" + "A new theme will be created to point to the modified style '%3$s'.<br/></html>", 
<|del|> 
 private boolean myAdvancedMode = true; private boolean myLocallyDefinedMode = false; 
 this.myLocallyDefinedMode = local; 
 if (myAdvancedMode) { 
 private static List<EditedStyleItem> resolveAllAttributes(final ThemeEditorStyle style) { final List<EditedStyleItem> allValues = new ArrayList<EditedStyleItem>(); 
 return file instanceof ThemeEditorVirtualFile; 
 return AndroidIcons.Themes; 
 private static final Logger LOG = Logger.getInstance(ThemeResolver.class); 
 private final List<ThemeEditorStyle> myAllThemes; private final List<ThemeEditorStyle> myFrameworkThemes; private final List<ThemeEditorStyle> myProjectThemes; private final List<ThemeEditorStyle> myProjectLocalThemes; 
 /** Renders the Javadoc for a resource of given type and name. If configuration is not null, it will be used to resolve the resource. */ 
 public static String render(@NotNull Module module, @NotNull ResourceType type, @NotNull String name, boolean framework) { 
 public static String render(@NotNull Module module, @NotNull ResourceType type, @NotNull String name, boolean framework) { 
 synchronized(this) { 
 synchronized (mConnectedDevices) { 
<|del|> 
 synchronized (mConnectedDevices) { 
<|del|> 
 return ""; } 
 * Exception to transport {@link Throwable} thrown by 
 * Exception to transport {@link Throwable} thrown by 
 * Exception to transport {@link Throwable} thrown by 
 + getEndLine() + '.' + getEndColumn(); 
 * Implements a reasonable textual representation for all JNodes. The goal is to have a common base * for other specific generations (e.g. {@link JNode#toString()}, {@link JNode#toSource()}, ...). 
<|del|> 
<|del|> 
 if (!myProject.isDefault() && (dataChanged || GradleSyncState.getInstance(myProject).isSyncNeeded() == ThreeState.YES)) { 
 // If the file reported as a manifest is invalid, m will be null. 
 // When the resource resolver is not cached, creating a new resource resolver here can block the UI thread for a considerable amount // of time if the Android SDK is on a network drive. 
 public boolean hasResourceResolverCached() { 
 final LocalResourceRepository resources = AppResourceRepository.getAppResources(myManager.getModule(), false); 
 return resources != null && myCachedGeneration == resources.getModificationCount(); 
 && (!Boolean.getBoolean("google.internal") || configuration.hasResourceResolvedCached())) { 
 if (ideaAndroidProject == null || !Projects.isBuildWithGradle(myFacet.getModule())) { 
 * External/Jar dependencies 
 * Information about a jar dependency as well as its transitive dependencies. 
 factory.setValidating(validateXml); 
<|del|> 
 EnumPropertyId.create("jack.assert.policy", "Assert statement policy", AssertionPolicy.class, AssertionPolicy.values()) .addDefaultValue(AssertionPolicy.DYNAMIC).ignoreCase().addCategory(DumpInLibrary.class); 
 EnumPropertyId.create("jack.assert.policy", "Assert statement policy", AssertionPolicy.class, AssertionPolicy.values()) .addDefaultValue(AssertionPolicy.DYNAMIC).ignoreCase().addCategory(DumpInLibrary.class); 
<|del|> 
 private int report(CategorizedProblem[] problems, Main currentMain) { 
 List<CategorizedProblem> extras = jackBatchCompiler.getExtraProblems(); 
 report(extras.toArray(new CategorizedProblem[extras.size()]), currentMain); 
 Options jackOptions = session.options; Config config = ThreadConfig.getConfig(); 
 "jarFile=" + jarFile + ", compiled=" + compiled + ", packaged=" + packaged + ", dependencies=" + dependencies + ", resolvedCoordinates=" + resolvedCoordinates + 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public static ByteArray decode(Decoder d) throws IOException { 
public class Decoder { @NotNull private final Map<Integer, RpcObject> decoded; @NotNull private final InputStream in; @NotNull private final byte[] buf; 
 this.decoded = new HashMap<Integer, RpcObject>(); this.in = in; this.buf = new byte[8]; 
public abstract class AbstractStreamFile extends FileOrDirectory { 
 protected AbstractStreamFile(@Nonnull String name, 
 protected AbstractStreamFile(int permissions) { 
 if (id.equals(name, argsType, kind)) { 
 @Nonnull MethodKind kind) { if (this.methodKind != kind) { 
<|del|> 
 @CheckForNull private Options options; 
 return !myState.getNotNull(IS_IN_EDIT_MODE_KEY, false); 
 return !myState.getNotNull(IS_IN_EDIT_MODE_KEY, false); 
public abstract class DynamicWizardStepWithHeaderAndDescription extends DynamicWizardStepWithDescription implements Disposable { 
 public static final class WizardStepHeaderSettings { 
public class GetSdkStep extends DynamicWizardStepWithHeaderAndDescription { 
 final int minLengthVarIntSize = computeRawVarint32Size(value.length()); final int maxLengthVarIntSize = computeRawVarint32Size(value.length() * MAX_UTF8_EXPANSION); if (minLengthVarIntSize == maxLengthVarIntSize) { 
 * Base class for wizard pages with title and description labels underneath * the standard wizard banner. 
 * Base class for wizard pages with title and description labels underneath * the standard wizard banner. 
 * @see <a href="http://b.android.com/66626">Bug 66626</a>. 
<|del|>
 private static <T extends List<Integer>> List<Integer> buildList(int arrayListLength, Class<T> listClass) throws Exception { 
 @NotNull private GfxTraceView myView; 
<|del|> 
 private JTextField myAvdDisplayName; private JBLabel mySkinDefinitionLabel; 
 r.resetRestartCounter(); 
 * A {@link com.intellij.codeInspection.ProblemDescriptor} for image and directory files. This is 
 @NotNull private static final String SERVER_HOST = "localhost"; private static final int SERVER_PORT = 6700; private Socket myServerSocket; 
 @NotNull private static final String SERVER_HOST = "localhost"; private static final int SERVER_PORT = 6700; private Socket myServerSocket; 
<|del|> 
 private int myCaptureChangeId = 0; private boolean myIsConnectedToServer = true; 
<|del|> 
 throw new JNodeInternalError(this, "Invalid parent or enclosing method"); 
<|del|> 
<|del|> 
 return mName + " (framework:" + mIsFrameworkAttr + ")"; 
<|del|> 
 @Nonnull ClassDefItem newClassDef, @Nonnull CstIndexMap cstIndexMap) { 
 public void testMultiDex() throws Exception { 
 private TypeList getInterfacesList(@Nonnull DexBuffer dexToMerge, @Nonnull ClassDef classDefToMerge) { 
 vFile = outputLibrary.createFile(FileType.DEX, 
 public static String getJackDexTag() { return JACK_DEX_TAG; 
<|del|> 
 // see plugin.xml for extension name COLLECTOR = new KeyedExtensionCollector<AndroidUsageTracker, String>("com.android.tools.idea.androidUsageTracker"); 
 public List<File> getImportedLibrary(); 
<|del|> 
 public void containsFileWithContent(String path, String content) { 
 if (TextUtils.isEmpty(mServer)) { 
 /** Using drawable rather than mipmap launcher icons */ 
 return thisAsT(); 
 * <li>For access to RAW, uncompressed YUV, or compressed JPEG data in the application: Create an 
 * <li>For access to raw, uncompressed YUV or RAW data, or compressed JPEG data in * the application: Create an 
 PsiElement view = args.get("$view"); MultiMatch.Bindings<PsiElement> bindings = macros.findViewById.match(view); 
 if (DEBUG) LOG.info("Analyser: activityClassName = " + activityClassName); if (DEBUG) LOG.info("Analyser: fragmentClassName = " + fragmentClassName); 
 Extensions.ExtendableMessage clone = message.clone(); 
 super("Emulator Settings"); 
/** * A builder to create a Jack-specific ProcessInfoBuilder 
 return thisAsT(); 
 return thisAsT(); } @SuppressWarnings("unchecked") @NonNull private T thisAsT() { 
 * An executor for external processes. 
<|del|> 
<|del|> 
 // Render the current image on top of the mask using it as the alpha composite 
 * An {@link OutputVFS} which generates a file with message digest of each file in a VFS. 
 * Abstract base class for message digest VFS. 
 * <li> [--] &lt;args for RuntimeInit &gt; 
<|del|> 
 establishInterViewControls(); } } 
 synchronized (MY_LOCK) { try { assert (myContextController.getCurrentCapture() != null); CaptureId captureId = myContextController.getCurrentCapture().getCaptureId(); Long contextId = myContextController.getCurrentContext(); assert (contextId != null); 
public class GfxTraceViewPanel implements Disposable { 
 Future<CaptureId[]> captureFuture = client.GetCaptures(); final CaptureId[] captureIds = captureFuture.get(); 
 setImageBytes(dataBuffer.getData()); 
 Graphics2D graphics = measureImage.createGraphics(); measureLabel.paint(graphics); graphics.dispose(); 
 Graphics2D graphics = measureImage.createGraphics(); measureLabel.paint(graphics); graphics.dispose(); 
 g.fillRect(0, 0, dimension.width, dimension.height); g.dispose(); 
 public NotFileOrDirectoryException(@Nonnull FileOrDirLocation location) { this(location, null); 
 private int myHeight = 0; private boolean myHasPreview = false; 
 catch (Exception e) { // don't add screenshot, cache or cache-loader threw exception 
 private JPanel myDescriptionPanel; private SamplePreviewPanel mySamplePreviewPanel; 
 for (Screenshot screenshot : sample.getScreenshots()) { if(isCancelled()) { return null; } 
 return vfs.getLocation(); 
<|del|> 
 Charset.forName("poop"); fail(); 
 private String mergeXml(String sourceXml, String targetXml, File targetFile) { 
 assert fragment != null : sourceXml + " failed to parse"; 
 // Finally write out the merged file 
 checkArgument(selectedTestArtifactName == AndroidProject.ARTIFACT_ANDROID_TEST || selectedTestArtifactName == AndroidProject.ARTIFACT_UNIT_TEST); 
 private static final char LIST_VALUE_SEPARATOR = ','; 
 private static final char MAP_VALUE_SEPARATOR = ','; 
<|del|> 
 private static final int TEST_LENGTH = 100; 
 Object data[] = new Object[TEST_LENGTH]; for (int i = 0; i < data.length; i++) { 
 data[i] = new Object[TEST_LENGTH]; 
 Object data2[] = (Object[]) data[i]; 
 Object data2[] = (Object[]) data[i]; 
 private static File getDumpFile() { 
 private static File getConvFile() { 
 ApkInfoParser.ApkInfo apkInfo = getApkInfo(apk); 
 IdeaAndroidProject ideaAndroidProject = getAndroidProject(module); assert ideaAndroidProject != null; 
 private static JTree createDependenciesTree(@NotNull Module module, @NotNull IdeaAndroidProject ideaAndroidProject) { 
 private static JTree createDependentsTree(@NotNull Module module, @NotNull IdeaAndroidProject ideaAndroidProject) { 
 // Android Studio : Do not show panel that allows configuring stats upload frequency 
 result.append(getTypeName()); 
 throw new NoSuchElementException(); 
 ps.print(Joiner.on(LIST_VALUE_SEPARATOR).useForNull("").join(list.iterator())); 
 List<String> digestValues = new ArrayList<String>(); String line = lr.readLine(); 
 * For storing additional model information. 
 public SyncIssue hasSingleIssue(int severity, int type) { 
public interface DeviceConfig { 
<|del|> 
 private Schema mySchema; private EnumInfoCache myEnumInfoCache; @GuardedBy("MY_LOCK") private AtomStream myAtomStream; @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") private AtomReader myAtomReader; @SuppressWarnings("FieldAccessedSynchronizedAndUnsynchronized") private ContextController myContextController; 
 public GfxTraceEditor(@NotNull final Project project, @SuppressWarnings("UnusedParameters") @NotNull final VirtualFile file) { 
<|del|> 
<|del|> 
<|del|> 
 /** * Finds the latest atom ID at or prior to the given ID that is a valid draw call/end of frame. 
 * Copyright (C) 2015 The Android Open Source Project 
 public static final SourceLocation UNKNOWN = new SourceLocation("Unknown location", null /* source */); 
 assertEquals(expectedNodeRecords.size(), newActions.getNodeRecords(nodeKey).size()); 
 private BaseVFile changeVFS(@Nonnull BaseVFile file) { 
 private BaseVDir changeVFS(@Nonnull BaseVDir dir) { 
 * An {@link InputVDir} implementation for a {@link GenericInputVFS}. 
 * An {@link InputVFile} implementation for a {@link GenericInputVFS}. 
 * An {@link OutputVDir} implementation for a {@link GenericOutputVFS}. 
 * An {@link OutputVFile} implementation for a {@link GenericOutputVFS}. 
* Copyright (C) 2015 The Android Open Source Project 
* Copyright (C) 2015 The Android Open Source Project 
 addr = Inet6Address.ANY; 
 inclusionCheckBox.setText(inclusionCheckBox.getText() + " (Not Installed)"); } else if (row == 1) { myState.put(FormFactorUtils.getInclusionKey(formFactor), true); 
 return new Predicate<Package>() { 
 private static void setDefaultChangeableProperties(Properties p) { 
 private static class NoImagePreloadHolder { 
 * @param resName * @param bitcode32 * @param bitcode64 
 private AtomStream myAtomStream; 
<|del|> 
<|del|> 
 myAtomController.initializeData(enumInfoCache, hierarchy); 
 if (selectedId - 1 > Integer.MAX_VALUE) { 
<|del|> 
<|del|> 
 myImageFetcher.prepareFetch(myEditor.getDeviceId(), myEditor.getCaptureId(), myEditor.getContext()); final ABGRImageFetcher finalImageFetcher = myImageFetcher; final boolean wireframeFirst = myIsWireframeMode; 
 ABGRImageFetcher.ImageFetchHandle colorHandle1 = finalImageFetcher.queueColorImage(atomId, colorRenderSettings); 
 public void commitData(@Nullable List<ScrubberFrameData> cache) { myCachedLabelData = cache; 
 // A is M*M if (adim != bX) { throw new RSRuntimeException("Called TRSM with invalid matrix dimensions"); } 
 if (digest.equals("") || digestToCompare.equals("") || !digest.equals(digestToCompare)) { 
 * {@code aPort} on the local host using a wildcard address. Valid values for {@code aPort} are 
 * inclusive. If {@code address} is {@code null} the address is set to a * wildcard address. 
 * @param address the address of the socket endpoint. * @param port the port number of the socket endpoint. 
<|del|> 
 client.setSocketFactory(getSocketFactory()).setConnectionPool(mConnectionPool); 
 Map<String, List<String>> requestHeaders) throws IOException { 
 // This can occur if the cache failed to lazily initialize. 
 List<Module> modules = getGradleModules(); 
 @NotNull final String description; 
 * @param port the port number of the socket endpoint. 
 * the address on the multihomed local host to bind to. 
<|del|> 
 inclusionCheckBox.setText(inclusionCheckBox.getText() + " (Not Installed)"); } else if (row == 1) { myState.put(FormFactorUtils.getInclusionKey(formFactor), true); 
 rootDir = vfs.getRootDir().createVDir(prefix); 
 return vfs.getPath(); 
 private Map<VirtualFile, String> getBuildScriptsWithQualifiers() { 
 " proguard-rules.pro (ProGuard Rules for app)\n" + " proguard.cfg (ProGuard Rules for lib)\n" + 
 * Copyright (C) 2015 The Android Open Source Project 
 return new ParentVDir(this, parent, name); 
 super("Wrong format in " + location.getDescription()); 
 super("'" + vfs.getDescription() + "' VFS format in " + location.getDescription() 
 if (inputLibrary.getLocation().equals(outputJackLibrary.getLocation())) { 
 public final boolean equals(Object obj) { 
 public final int hashCode() { return getVFSLocation().hashCode(); } 
 context.report(ISSUE, node, context.getLocation(node.astArguments().last()), "Reading app signatures from getPackageInfo: The app signatures " + "could be exploited if not validated properly; " + "see issue explanation for details."); 
 context.report(ISSUE, node, context.getLocation(node.astArguments().last()), "Reading app signatures from getPackageInfo: The app signatures " + "could be exploited if not validated properly; " + "see issue explanation for details."); 
 ResolvedNode resolvedNode = context.resolve(expression); if (resolvedNode instanceof ResolvedField) { Object value = ((ResolvedField) resolvedNode).getValue(); 
<|del|> 
 BinaryOperator operator = binaryExpression.astOperator(); 
<|del|> 
 /** * Checks if the target configuration passes all registered filters. * @return {@code true} if the configuration should be kept, {@code false} otherwise. */ public static boolean isAccepted(@NotNull ConfigurationFromContext configuration) { 
 * a ITestRunListener of the results. We may not prefer to parse xml result file. Because xml result * file is generated at the end of all tests, and we can't check the progress of test. 
 void createEmptyDependencyIfNeeded(@Nonnull JType type) { 
<|del|> 
 public final int tag; 
 /** * Writes the value of this argument, if any, to the provided parcel. */ 
 @Override 
 @Override 
 public static final int KM_TAG_SINGLE_USE_PER_BOOT = KM_INT | 404; 
<|del|> 
 private void clear() { for (BaseController controller : myBaseControllers) { controller.clear(); } 
 clear(); 
 // Since gfx context is dependent on capture, this needs to synchronize against it. final int closedCaptureChangeId = myCaptureChangeId; clear(); 
 for (BaseController controller : myBaseControllers) { controller.commitData(state); } 
 assert (!ApplicationManager.getApplication().isDispatchThread()); 
<|del|> 
 public void initialize() { 
 if (devices.contains(previouslySelected)) { deviceToSelect = previouslySelected; 
 Object[] boxedContextList = Longs.asList(contextList).toArray(); 
 private String myTargetUrl; 
 @NotNull private final ImageInfo myImageInfo; @NotNull private final Binary myBinary; @NotNull private final DepthConversionMode myDepthConversionMode = DepthConversionMode.GO_CLIENT; 
<|del|> 
 ImageIcon color = null; ImageIcon wireframe = null; ImageIcon depth = null; 
 atom = atomReader.read(this.myId); 
 if (cachedComponent != null) { // Caching fixes an issue with Swing rendering. 
<|del|> 
 final ImageIcon finalImageIcon = imageIcon; 
 private WorkItem(@NotNull Callable<T> callable, @Nullable WorkCallback<T> callback, @Nullable Runnable errorHandler) { myHandle = WorkerExecutor.this.generateId(); 
 "^([\\w_:]+)\\s+([\\w_]+)\\s+(\\d+)\\s+(\\d+)\\s+(\\p{Graph}+)$", 
 public abstract int getDeviceConfigurationCount(); 
 SHOW_DIALOG, EMULATOR, USB_DEVICE, CLOUD_TEST_OPTION 
 @NotNull private List<GfxController> myControllers = new ArrayList<GfxController>(); 
 @NotNull private List<GfxController> myControllers = new ArrayList<GfxController>(); 
 myWorker = new WorkerExecutor("GfxTraceEditor worker thread for " + SERVER_HOST); myWorker.startThread(); 
 catch (IOException e) { LOG.error(e); 
<|del|> 
 @NotNull private ImageInfoId myImageInfoId; private ImageInfo myImageInfo; private Binary myBinary; 
<|del|> 
 @NotNull private Map<String, EnumInfo> myEnumLookup; 
 @NotNull private Map<String, EnumInfo> myEnumLookup; 
 public static abstract class Task<T> { 
<|del|> 
 public void onDone(@SuppressWarnings("UnusedParameters") @Nullable T result) { 
 return AndroidFakeFileSystem.constructPathForFile(getName(), myFacet.getModule()); 
@ImplementationName(iface = JaycePackageLoader.class, name = "type", description = "when possible, read only minimal information from jayce files") 
 public final boolean generateSourcesOnSuccess; public final boolean importingExistingProject; 
 return "zip archive writer"; 
 return "zip archive reader"; 
 @Nullable public static String findInstrumentationRunner(@NotNull AndroidFacet facet) { 
 this(kind, text, null /* sourcePath */, new SourceFragmentPositionRange(), text); 
 public boolean parse(@NotNull String line, @NotNull OutputLineReader reader, @NotNull List<GradleMessage> messages, @NotNull ILogger logger) 
 public boolean parse(@NotNull String line, @NotNull OutputLineReader reader, @NotNull List<GradleMessage> messages, @NotNull ILogger logger) 
 } else { //noinspection SpellCheckingInspection 
 public boolean parse(@NotNull String line, @NotNull OutputLineReader reader, @NotNull List<GradleMessage> messages, @NotNull ILogger logger) 
 else { //noinspection SpellCheckingInspection 
 } catch (NumberFormatException e) { 
 } finally { 
 LOG.info("The following user(s) had expired authentication scopes: " 
 flagValue = Boolean.parseBoolean((String) value); 
 @NonNull 
 // CHECK-START: int Main.div() licm (after) // CHECK-DAG: Div ( loop_header:null ) 
<|del|> 
 // CHECK-START: int Main.innerDiv() licm (after) // CHECK-DAG: Div ( loop_header:null ) 
<|del|> 
 // CHECK-DAG: [[NullCheck:l\d+]] NullCheck ( loop_header:{{B\d+}} ) // CHECK-DAG: ArrayLength [ [[NullCheck]] ] ( loop_header:{{B\d+}} ) 
 // CHECK-START: int Main.arrayLength(int[]) licm (after) // CHECK-DAG: [[NullCheck:l\d+]] NullCheck ( loop_header:null ) // CHECK-DAG: ArrayLength [ [[NullCheck]] ] ( loop_header:null ) 
 * Copyright (C) 2015 The Android Open Source Project 
 return Boolean.getBoolean(ENABLE_EXPERIMENTAL_ACTIONS) && SdkUtils.endsWithIgnoreCase(file.getPath(), "gfxtrace"); 
 assert (!newContext.equals(myCurrentContext)); 
 final ImageFetcher imageFetcher = myImageFetcher; 
 FetchedImage colorImage = imageFetcher.resolveImage(wireframeFirst ? colorHandle1 : colorHandle0); 
 return "zip archive writer that uses a temporary directory"; 
 if (!closed) { 
 closed = true; 
 fileDependencies = getFileDependencies(incrementalInputLibrary); typeDependencies = getTypeDependencies(incrementalInputLibrary); 
 * Returns whether the IDE supports assets. This is used to determine if error messages should * be thrown. 
 VirtualFile asset = assetDir.findFileByRelativePath(path); if (asset != null) { 
 return asset.getInputStream(); 
 } } private static void testMethodTracing() throws Exception { File tempFile = createTempFile(); 
 private static final Color DEFAULT_PARAM_COLOR = new JBColor(new Color(240, 40, 240), new Color(240, 40, 240)); private static final Color DROPDOWN_PARAM_COLOR = new JBColor(new Color(0, 240, 0), new Color(0, 240, 0)); 
 this.myId = id; 
 private void queueInvalidateCache() { 
"always read full information") 
"start by always reading strcuture information (ie members, annotations, markers etc...)") 
"start by only reading type and name information") 
 final String NAME = "Lollipop - Android 5.0 (API 21)"; 
<|del|> 
 assertTrue(hashCodes.add(s.hashCode())); 
 return inputVFS.getRootInputVDir().getInputVFile(clonedPath); 
 return Collections.emptyList(); 
 bufferOrder[0] = BufferType.DEPTH_BUFFER; bufferOrder[1] = wireframeFirst ? BufferType.COLOR_BUFFER_WIREFRAME : BufferType.COLOR_BUFFER; bufferOrder[2] = wireframeFirst ? BufferType.COLOR_BUFFER : BufferType.COLOR_BUFFER_WIREFRAME; 
 for (int i = 0; i < BufferType.length; ++i) { myIconCache[i] = null; 
 private enum BufferType { 
<|del|> 
 archiveNeedsZip64EocdRecord = true; return; 
 * * @hide 
 private class FocusableHyperlinkLabel extends HyperlinkLabel { FocusableHyperlinkLabel(String text, Icon icon) { 
 private static class JLabelTextAccessor implements TextAccessor { 
 throw new ZipException("Invalid zip64 eocd record offset, sig=" + Integer.toHexString(signature) + " offset=" + eocdRecordOffset); 
 throw new ZipException("Spanned archives not supported :" + " numEntries=" + numEntries + ", totalNumEntries=" + totalNumEntries + ", diskNumber=" + diskNumber + ", diskWithCentralDirStart=" + diskWithCentralDirStart); 
 // optionally contain a zip64 extended information extra entry. 
 if (ze.size == MAX_ZIP_ENTRY_AND_ARCHIVE_SIZE) { 
 // The local header offset is significant only in the central directory. It makes no sense // within the local header itself. if (fromCentralDirectory) { 
 // We have to check that the compressedSize / size / localHeaderRelOffset values 
 final byte[] output; // Note that we add 4 to ZIP64_EXTENDED_INFO_MIN_SIZE to account for // the 2 byte header and length. 
 while (extras.hasRemaining()) { if (extras.getShort() == ZIP64_EXTENDED_INFO_HEADER_ID) { 
 throw new IllegalStateException("Zip64 entry has no available extras: " + ze); 
 throw new IllegalStateException("Zip64 entry extras has no zip64 extended info record: " + ze); 
 * to the start of the current entry header is > 0xFFFFFFFF. 
 * This of course implies that the {@code currentEntryNeedsZip64} and 
 * This of course implies that the {@code currentEntryNeedsZip64} and 
 private final boolean forceZip64; 
 // The comment is not written out until the entry is finished, but it is validated here 
 archiveNeedsZip64EocdRecord = true; return; 
<|del|> 
 myGraphicsLayoutRenderer.setSize(getSize()); 
"start by always reading structure information (ie members, annotations, markers etc)") 
"start by always reading structure information (ie members, annotations, markers etc...)") 
 throw new IllegalArgumentException("Repeatable tags must use getInts: " + tag); 
 public static final int KM_TAG_MAX_USES_PER_BOOT = KM_INT | 404; 
 if (state == FLUSHED) { 
 new MapCodec<String>(new StringValueCodec("property"))).addDefaultValue(""); 
<|del|> 
 new DirectoryCodec(Existence.MUST_EXIST, Permission.WRITE | Permission.READ)); 
<|del|> 
<|del|> 
 new DirectoryCodec(Existence.MUST_EXIST, Permission.WRITE | Permission.READ)); 
 "Use annotation processor classpath for annotation processor loading") 
 new InputFileOrDirectoryCodec()) 
 private final ListCodec<Entry<String, T>> listParser; 
 public void clip(@Nullable Shape s) { 
 public void setClip(@Nullable Shape sh) { 
 public void setTransform(@Nullable AffineTransform Tx) { 
 * This method is a no-op if the encoder has already been flushed. 
 throw new Error("Expected 0, got " + result); 
 } } else { refValue = refEncodedValuesIterator.next(); candValue = candEncodedValuesIterator.next(); 
<|del|> 
<|del|> 
 public static CaptureService getInstance(@NotNull Project project) { 
 public Multimap<CaptureType, Capture> getCapturesByType() { 
 public abstract String createCaptureFileName(); 
 protected abstract Capture createCapture(@NotNull VirtualFile file); 
<|del|> 
 private final List<CaptureNode> myCaptureNodes; 
 "Similarly, note that to use 3 letter region codes, you have to use " + 
 assertEquals(false, lq.checkAndSet("abcd", config)); //$NON-NLS-1$ assertEquals(false, lq.checkAndSet("en-USofA", config)); //$NON-NLS-1$ 
 public interface ThemePropertyChangedListener { void attributeChanged(final EditedStyleItem attribute, final String newValue); 
 public static String getQualifiedItemName(@NotNull ItemResourceValue item) { 
 * Interface for a test project. 
 void write(@NonNull File projectDir, @Nullable String buildScriptContent) throws IOException; 
 public void write(@NonNull File projectDir, @Nullable String buildScriptContent) throws IOException { 
 " compileSdkVersion " + DEFAULT_COMPILE_SDK_VERSION + "\n" + " buildToolsVersion '" + DEFAULT_BUILD_TOOL_VERSION + "'\n" + 
 private final File moduleDir; private final String gradlePath; 
 private final File moduleDir; private final String gradlePath; 
 public static long parseZip64EocdRecordLocator(RandomAccessFile raf, long eocdOffset) throws IOException { 
 // We add 4 to ZIP64_EXTENDED_INFO_MIN_SIZE to account for the 2 byte header and length. 
 // Data descriptor signature and CRC are 4 bytes each for both zip and zip64. 
 // NOTE: This field might include this entry's zip64 extended info record. 
 // CHECK: BoundsCheck // CHECK: ArraySet 
 // CHECK: BoundsCheck // CHECK: ArraySet 
<|del|> 
 } 
 final AttributesTableModel model = new AttributesTableModel(attributes, labels, selectedStyle, parentStyle == null ? null : parentStyle.getName()); 
 void write(@NonNull File projectDir, @Nullable String buildScriptContent) throws IOException; 
public class AndroidJarTask extends Jar implements BinaryFileProviderTask { 
 @NonNull 
 public Artifact(@NonNull BinaryArtifactType binaryArtifactType, @NonNull File artifactFile) { 
 if (new File(FileUtil.toSystemDependentName(path)).getName().startsWith("mockable-android")) { // PathsList stores strings - use the one that's actually stored there. 
 } else if (iv != null && iv.length != expectedIvLength) { throw new InvalidAlgorithmParameterException("expected IV length of " + expectedIvLength + " but was " + iv.length); 
 * <li>Yesterday, 12:20 PM</li> 
 // YEAR_IN_MILLIS considers 364 days as a year. However, since this // constant comes from public API in DateUtils, it cannot be fixed here. 
 // 'relative' defaults to true as we are generating relative time span // string. It will be set to false when we try to display strings without // a quantity, such as 'Yesterday', etc. 
 } // Fall back to show something like "2 days ago". 
 int days = Math.abs(FormatUtils.dayDistance(timeCalendar, nowCalendar)); 
 private static int julianDay(com.ibm.icu.util.TimeZone icuTimeZone, long time) { long utcMs = time + icuTimeZone.getOffset(time); return (int) (utcMs / DAY_IN_MS) + EPOCH_JULIAN_DAY; 
 candValue = getNextEncodedValueOfMemberClassAnnotation(candEncodedValuesIterator); 
 * The minimum timespan to report is set to {@link #MINUTE_IN_MILLIS}. 
 return RelativeDateTimeFormatter.getRelativeTimeSpanString(Locale.getDefault(), TimeZone.getDefault(), time, now, minResolution, flags); 
import static libcore.icu.RelativeDateTimeFormatter.getRelativeDateTimeString; import static libcore.icu.RelativeDateTimeFormatter.getRelativeTimeSpanString; import static libcore.icu.RelativeDateTimeFormatter.FORMAT_ABBREV_RELATIVE; 
 TimeZone utc = TimeZone.getTimeZone("Europe/London"); 
 str = getFormatter(icuLocale, style, capitalizationContext) .format( com.ibm.icu.text.RelativeDateTimeFormatter.Direction.LAST_2, com.ibm.icu.text.RelativeDateTimeFormatter.AbsoluteUnit.DAY); 
 // Show "Yesterday / Tomorrow" instead of "1 day ago / in 1 day". aunit = com.ibm.icu.text.RelativeDateTimeFormatter.AbsoluteUnit.DAY; 
 synchronized (CACHED_FORMATTERS) { com.ibm.icu.text.RelativeDateTimeFormatter formatter = getFormatter(icuLocale, style, capitalizationContext); if (relative) { return formatter.format(count, direction, unit); } else { return formatter.format(direction, aunit); 
<|del|> 
 throw new NullPointerException("locale == null"); 
 Calendar timeCalendar = FormatUtils.createIcuCalendar(icuTimeZone, icuLocale, time); Calendar nowCalendar = FormatUtils.createIcuCalendar(icuTimeZone, icuLocale, now); 
 // We always use fixed flags to format the date clause. User-supplied // flags are ignored. if (timeCalendar.get(Calendar.YEAR) != nowCalendar.get(Calendar.YEAR)) { 
<|del|> 
 Calendar cal = Calendar.getInstance(tz, en_US); 
 for (int i = 0; i < myBufferScrollPanes.length; ++i) { 
 public enum BufferType { 
 myComponent = new ThemeEditorComponent(myConfiguration, module); 
<|del|> 
 // Fall back to show something like "2 days ago". Reset the // capitalization setting. capitalizationContext = UDISPCTX_CAPITALIZATION_NONE; 
<|del|> 
 long now, long minResolution, int flags, DisplayContext displayContext) { 
<|del|> 
 Calendar timeCalendar = DateUtilsBridge.createIcuCalendar(icuTimeZone, icuLocale, time); Calendar nowCalendar = DateUtilsBridge.createIcuCalendar(icuTimeZone, icuLocale, now); 
 myTree.getEmptyText().setText(StatusText.DEFAULT_EMPTY_TEXT); 
 myList.getEmptyText().setText(StatusText.DEFAULT_EMPTY_TEXT); 
 private TableRowSorter<AttributesTableModel> myAttributesSorter; private final SimpleModeFilter mySimpleModeFilter; 
 assertNull(themeResolver.getTheme("@style/Theme.Holo.Light")); // It's system theme and we're not specifying namespace so it will fail. 
 p.pkgFlags |= pkgFlags & ApplicationInfo.FLAG_SYSTEM; p.pkgPrivateFlags |= pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; 
 TimeZone.getDefault(), time, now, minResolution, flags); 
 assertEquals("in 1 minute", DateUtils.getRelativeTimeSpanString(ONE_MINUTE_IN_MS, 0, 
 public void selectedDevicesChanged() { myLaunchEmulatorRadioButton.setSelected(!myDeviceChooser.hasDevices()); myChooserRunningDeviceRadioButton.setSelected(myDeviceChooser.hasDevices()); 
 public final ParentAttribute parentAttribute = new ParentAttribute(); private final List<RowContents> mySpecialRows = ImmutableList.of( new ThemeNameAttribute(), parentAttribute ); 
 final ThemeEditorStyle selectedStyle = getUsedStyle(); 
 return "Trace_" + (new SimpleDateFormat("yyyy.MM.dd_HH.mm.ss").format(new Date())) + DOT_TRACE; 
 mQueue = new LinkedList<Item>(); mSemaphore = new Semaphore(0); mByte = new byte[1]; mSource = new Writer(); 
 updateEnabled(); 
 mySelectedAppFilter = null; 
 return AndroidBundle.message("android.profiler.hprof.actions.conv.contextmenu"); 
 @NotNull public static final DataKey<Capture[]> CAPTURE_ARRAY = DataKey.create("CaptureArray"); 
 static final void enableDdms() { 
 static final void enableDdms() { 
 myComponent = new ColorComponent(table.getBackground(), table.getFont().deriveFont(Font.BOLD), table.getSelectionBackground()); 
 myComponent = new ColorComponent(table.getBackground(), table.getFont().deriveFont(Font.BOLD), table.getBackground()); 
<|del|> 
 * Enable DDMS. 
import com.android.tools.idea.monitor.AndroidToolWindowFactory; 
 String sdkLocation = sdk.getPath(); 
 throw new UnsupportedOperationException( 
 iLogger, new WorkQueueContext(), "execRecordWriter", 1, Float.MAX_VALUE); 
<|del|> 
<|del|> 
 boolean mUseIncSupp = rs.isUseNative() && android.os.Build.VERSION.SDK_INT < INTRINSIC_API_LEVEL; 
 boolean mUseIncSupp = rs.isUseNative() && android.os.Build.VERSION.SDK_INT < INTRINSIC_API_LEVEL; 
<|del|> 
 return Collections.emptyList(); 
 if (DexWriter.isJackDexTag(stringsIt.next())) { 
 private static final String JACK_DEX_TAG_HEADER = "emitter: " + Jack.getEmitterId(); 
 public void setBounds(int x, int y, int width, int height) { Dimension previousSize = getSize(); 
 @Nullable 
 if (!StringUtil.isEmpty(value) && Character.isLetter(value.charAt(0))) { return value; 
 } else if (TAG_EAT_COMMENT.equals(subTagName)) { 
 } else if (TAG_EAT_COMMENT.equals(subTagName)) { 
 myComponent.configure(item, color); myComponent.setBorder(isSelected ? mySelectedBorder : myUnselectedBorder); 
 public AttributeDefinitionsImpl getAllAttrDefs(@NotNull final Project project) { 
 File batFile = new File(source, "silent_install.bat"); return new GeneralCommandLine(batFile.getAbsolutePath(), "-m", String.valueOf(memorySize)).withWorkDirectory(source); 
 System.err.println("Unsupported private key algorithm: " + javaKey.getAlgorithm()); 
 System.err.println("Exception while ciphering message with " + javaKey.getAlgorithm() 
 return Platform.wrapRsaKey(key); 
 @CheckForNull 
 public PrefixedFS(@Nonnull BaseVFS<? extends BaseVDir, ? extends BaseVFile> vfs, @Nonnull String prefix) throws CannotCreateFileException { 
<|del|> 
 private boolean mCleartextTrafficPermitted = true; 
 private boolean mCleartextTrafficPermitted = true; 
 * Checks whether cleartext network traffic (e.g., HTTP, WebSockets, XMPP, IMAP, SMTP -- without * TLS or STARTTLS) is permitted for this process. 
 public boolean isCleartextTrafficPermitted() { 
<|del|> 
<|del|> 
<|del|> 
 public static RenderTask createRenderTask(@NotNull EditableArea area) { 
 return createRenderTask(file, configuration); 
 protected RenderTask createRenderTask(VirtualFile file, Configuration configuration) throws IOException { 
 RenderResult result = task.render(); RenderResult render = renderOnSeparateThread(task); 
 public static RenderResult renderOnSeparateThread(@NotNull final RenderTask task) { 
 ApplicationManager.getApplication().runWriteAction(new Runnable() { @Override public void run() { NewProjectImportGradleSyncListener.createTopLevelModule(project); } }); 
 String attrGroup = ""; 
 if (def != null) { def.setAttrGroup(attrGroup); } } else if (tagName.equals(TAG_DECLARE_STYLEABLE)) { StyleableDefinitionImpl def = parseDeclareStyleableTag(tag, parentMap); if (def.getName().equals("Theme")) { 
<|del|> 
 else if (TAG_EAT_COMMENT.equals(subTagName)) { attrGroup = getCommentBeforeEatComment(subTag); 
<|del|> 
 new Recorder.Property(SpanRecorders.VARIANT, variantData.getName())); 
 if (isBuildWithGradle(project)) { 
 setUpGradleSettings(newProject); // This allows to customize UI when android project is opened inside IDEA with android plugin. ProjectTypeService.setProjectType(newProject, AndroidModuleBuilder.ANDROID_PROJECT_TYPE); 
 @SuppressWarnings("FieldCanBeLocal") private String myGradlePluginVersion = GRADLE_PLUGIN_RECOMMENDED_VERSION; 
 if (isAndroidStudio()) { final File ideSdkPath = getDefaultAndroidHome(); 
 File rootDirPath = new File(toSystemDependentName(getProjectBasePath(project))); 
 ensureExists(file.getParentFile()); 
 File rootDirPath = new File(getProjectBasePath(project)); 
 if (isGradleProjectModule(module)) { 
 File buildFolderPath = getBuildFolderPath(projectModule); 
 return new File(buildFolderPath, join(FD_INTERMEDIATES, STATE_FILE_NAME)); 
 return new File(virtualToIoFile(project.getBaseDir()), join(BUILD_DIR_DEFAULT_NAME, FD_INTERMEDIATES, STATE_FILE_NAME)); 
 if (isAncestor(rootDirPath, file, true)) { key = getRelativePath(rootDirPath, file); 
 VirtualFile vf = findFileByIoFile(file, true); 
 delete(stateFile); 
 if (!myGradlePluginVersion.equals(GRADLE_PLUGIN_RECOMMENDED_VERSION)) { 
public class NinePatchAsyncAaptProcessTest extends NinePatchAaptProcessorTest { 
 logger.severe("Internal Error : mixed records in profiling stack"); 
 * or one of the following names: 
 * accordingly, while its mark and limit will be intact. * <p> * If the encoder already has been flushed, then this is a no-op. 
 * accordingly, while its mark and limit will be intact. * <p> * If the encoder already has been flushed, then this is a no-op. 
 // Seek back past the eocd signature so that we can continue with our search. 
 * the standard zip format or if we exceeded the maximum number of entries allowed * in the standard format. 
<|del|> 
 if (!CloudTestConfigurationProvider.isEnabled()) { 
 public static boolean isEnabled() { CloudTestingConfigurable.cloudTestingState cloudTestingState = CloudTestingSettings.getInstance().getState(); return cloudTestingState != null && cloudTestingState.enableCloudTesting; 
 public static boolean isEnabled() { CloudTestingConfigurable.cloudTestingState cloudTestingState = CloudTestingSettings.getInstance().getState(); return cloudTestingState != null && cloudTestingState.enableCloudTesting; 
<|del|> 
 String getName(); 
 * Initializes the provider. This will be called by the android gradle plugin before any other * method (except {@link #getName()}). 
 * If the provider is not configured, the <code>${providername}AndroidTest</code> task will * still be created, but it will be disabled. 
 * This could be called from multiple threads. * * @param testData The tests to run on the remote devices. * @return a map from remote device identifier to multi-line instrumentation output. 
 * This could be called from multiple threads. * * @param testData The tests to run on the remote devices. * @return a map from remote device identifier to multi-line instrumentation output. 
 Map<String, List<String>> runTests(TestData testData, File testApk); 
<|del|> 
 public void uploadApks( @NonNull String variantName, 
<|del|> 
<|del|> 
 // Allows for colored background 
<|del|> 
 @Nonnull File dest) throws IOException { 
<|del|> 
 Toolchain toolchain = AbstractTestTools.getReferenceToolchain(); 
 Toolchain toolchain = AbstractTestTools.getReferenceToolchain(); 
 public String parseString(@Nonnull CodecContext context, @Nonnull String string) { 
 public String parseString(@Nonnull CodecContext context, @Nonnull String string) { 
 public String checkString(@Nonnull CodecContext context, @Nonnull String string) { 
 public String formatValue(@Nonnull String data) { 
 public void checkValue(@Nonnull CodecContext context, @Nonnull String data) { 
 public EnumPropertyId<T> withCategory(@Nonnull Category category) { 
 if (Boolean.getBoolean(ENABLE_EXPERIMENTAL_ACTIONS)) { Content cpuContent = createCpuContent(layoutUi, project, deviceContext); layoutUi.addContent(cpuContent, 3, PlaceInGrid.center, false); } 
 * Copyright (C) 2015 The Android Open Source Project 
 private static void validateConfiguration() { 
<|del|> 
 * Allows tests to be run on an externally managed collection of remote test runners. 
<|del|> 
import static com.android.tools.idea.gradle.util.Projects.getUserDefinedProjectView; import static com.android.tools.idea.gradle.util.Projects.open; import static com.android.tools.idea.gradle.util.Projects.setUserDefinedProjectView; 
 float cappedMax = Math.min(myData.getMaxTotal(), myAbsoluteMax); if (cappedMax > myCurrentMax) { myCurrentMax = lerp(myCurrentMax, cappedMax, myFirstFrame ? 1.f : .95f); 
 * Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 public NetlinkSocketAddress(int nlPortId) { this(nlPortId, 0); 
 RC("rc") 
 public FullRevision(int major, int minor, int micro, @NonNull PreviewType previewType, int preview, @NonNull String previewSeparator) { 
 if (pt.name.equals(previewTypeName)) { 
 myComboBox.setModel(comboBoxModel); 
<|del|> 
 * will take the naive path: execute kernels one by one in the 
<|del|> 
 if (pt.name.equals(previewTypeName)) { 
 executeProjectChangeAction(true, new DisposeAwareProjectChange(project) { 
 executeProjectChangeAction(true, new DisposeAwareProjectChange(project) { 
 * @param ideaModuleModel modifiable root module of the module to customize. The caller is responsible to commit the changes to model * and the customizer should not call commit on the model. 
 return Joiner.on(" or ").join( Collections2.transform(codecList, new Function<StringCodec<? extends T>, String>() { @Override public String apply(StringCodec<? extends T> codec) { return codec.getUsage(); } })); 
 return new JayceClassOrInterfaceLoader(inputJackLibrary, loading, simpleName, (InputVFile) sub, lookup, defaultLoadLevel).load(); 
 public ShowJavadocAction(@NotNull JTable attributesTable) { 
<|del|> 
 hint.show(new RelativePoint(myAttributesTable.getParent(), ORIGIN)); 
 @NotNull private final Semaphore myDataSemaphore; 
 protected abstract void sample(boolean requested) throws InterruptedException; 
 @NotNull protected final TimelineData myData; 
 } Engine.door.renumProviders(); 
 * Copyright (C) 2015 The Android Open Source Project 
 @Mock private Network mMockNetwork; 
<|del|> 
<|del|> 
 new InputVFSCodec()).addDefaultValue(""); 
 //STOPSHIP: fix this? It does not fail anymore as expected because we now allow Jars, but since 
 protected static final String STANDARD_ERROR_NAME = "--"; 
 protected static final String STANDARD_ERROR_NAME = "--"; 
 } if (value.equals(STANDARD_ERROR_NAME)) { throw new ParsingException( getStandardStreamDescription(StreamKind.STANDARD_ERROR) + " can not be used"); } 
<|del|> 
 switch (stream.getStreamKind()) { case FILE: { return stream.getPath(); 
 protected AbstractStreamFile(int permissions) { 
 public OutputStreamFile(@Nonnull StreamKind streamKind) { super(streamKind, Permission.WRITE); 
 "jack.legacy.visibilitybridges", "Generate visibility bridges").addDefaultValue( 
import static com.android.SdkConstants.EXT_JAR; import static com.android.SdkConstants.EXT_ZIP; import static com.android.SdkConstants.FD_RES; import static com.android.SdkConstants.FN_ANNOTATIONS_ZIP; 
 writeRegister(writer, instruction.getRegisterParameterD()); 
<|del|> 
 /** * Creates a renderer suitable for the given resource type */ 
 "jack.import.meta", "Meta to import", "meta dir", new DirectoryInputVFSCodec()).addDefaultValue(Collections.<InputVFS>emptyList()); 
 "jack.import.meta", "Meta to import", "meta dir", new DirectoryInputVFSCodec()).addDefaultValue(Collections.<InputVFS>emptyList()); 
 File logFile = new File(incrementalFolder.getPath(), 
 "jack.legacy.runtime.visibilitybridges", "Generate visibility bridges").addDefaultValue( 
 Api01Config setMetaDirs(@Nonnull List<File> metaDirs) throws ConfigurationException; 
 Api01Config setMetaDirs(@Nonnull List<File> metaDirs) throws ConfigurationException; 
 Api01Config setResourceDirs(@Nonnull List<File> resourceDirs) throws ConfigurationException; 
 Api01Config setResourceDirs(@Nonnull List<File> resourceDirs) throws ConfigurationException; 
 Api01Config setIncrementalDir(@Nonnull File directory) throws ConfigurationException; 
 Api01Config setImport(@Nonnull List<File> libraryFiles) throws ConfigurationException; 
 Api01Config setIncrementalDir(@Nonnull File incrementalDir) throws ConfigurationException; 
 Api01Config setOutputDexDir(@Nonnull File outputDexDir) throws ConfigurationException; 
 Api01Config setOutputJackFile(@Nonnull File outputJackFile) throws ConfigurationException; 
 Api01Config setJarJarConfigFile(@Nonnull File jarjarConfigFile) throws ConfigurationException; 
 Api01Config setJarJarConfigFile(@Nonnull File jarjarConfigFile) throws ConfigurationException; 
 Api01Config setProguardConfigFiles(@Nonnull List<File> proguardConfigFiles) throws ConfigurationException; 
 Api01Config setProguardConfigFiles(@Nonnull List<File> proguardConfigFiles) throws ConfigurationException; 
 Api01Config setMultiDexKind(@Nonnull MultiDexKind multiDexKind) throws ConfigurationException; 
 Api01Config setProcessorNames(@Nonnull List<String> processorNames) throws ConfigurationException; 
 Api01Config setProcessorPath(@Nonnull List<File> processorPath) throws ConfigurationException; 
 public String getParentName() { return myParentName; 
 * Returns the ports that are sent with the message, or null if no port * is sent. 
 * have a WebMessageListener to receive web messages. The messages are queued until * a WebMessageListener is set. 
 * have a WebMessageListener to receive web messages. The messages are queued until * a WebMessageListener is set. 
 public static abstract class WebMessageListener { 
 * ports that represent the endpoints of this message channel. The HTML5 message 
 if (TRACE) Log.d(LOGTAG, "postMessageToMainFrame. TargetOrigin=" + targetOrigin); 
<|del|> 
 "jack.import.meta", "Meta to import", "dir", 
 @Nonnull String currentPath) throws ResourceImportConflictException { 
 return "a path to a directory (" + getUsageDetails() + ")"; 
<|del|> 
 Api01Config setTypeImportCollisionPolicy(@Nonnull CollisionPolicy typeImportCollisionPolicy) throws ConfigurationException; 
 Api01Config setJavaSourceVersion(@Nonnull JavaSourceVersion javaSourceVersion) throws ConfigurationException; 
 Api01Config setObfuscationMappingOutputFile(@Nonnull File obfuscationMappingOuputFile) 
 Api01Config setSourceEntries(@Nonnull List<File> sourceEntries) throws ConfigurationException; 
 void setImportedJackLibraryFiles(@Nonnull List<File> importedJackLibraryFiles) throws ConfigurationException; 
 void setJavaSourceVersion(@Nonnull JavaSourceVersion javaSourceVersion) 
 throw new TestConfigurationException("Jack API v01 not supported", e); 
 InputStream is = new BufferedInputStream(fileIndex.getInputStream()); 
 for (Future<?> f : results) { 
 } catch (ExecutionException e) { System.out.println("KLKLE"); 
 super(libraryProperties); inputVFS = new GenericInputVFS(vfs); 
 // This shouldn't filter our custom component 
 * Returns the location of the external annotations zip file (which may not exist) 
import javax.swing.table.DefaultTableCellRenderer; import javax.swing.table.TableColumn; 
 protected final TextFieldWithAutoCompletion<String> myTextField; 
 EnumPropertyId.create("jack.assert.policy", "Assert statement policy", AssertionPolicy.class, AssertionPolicy.values()) .addDefaultValue(AssertionPolicy.DYNAMIC).ignoreCase().addCategory(DumpInLibrary.class); 
 return 0; 
 return 0; 
 return "a path to an unsupported library"; 
 return 0; 
 return "a path to a Jar"; 
 : String.format("API %1$d: Android %2$s (%3$s)", api, getVersionString(api), codeName); 
 // Sort types alphabetically so they're always printed in the same order, whichever // tool generated the DEX file of the test. 
 // Sort types alphabetically so they're always printed in the same order, whichever // tool generated the DEX file of the test. 
 } // Sort types alphabetically so they're always printed in the same order, whatever // tool generates the DEX file of the test. 
 } // Sort types alphabetically so they're always printed in the same order, whatever // tool generates the DEX file of the test. 
 // CHECK-NOT: UShr 
 apiV01Config.setProperty(Options.DEX_OUTPUT_CONTAINER_TYPE.getName(), Container.ZIP.name()); apiV01Config.setProperty(Options.GENERATE_DEX_FILE.getName(), "true"); 
 Log.v(LOGTAG, "compute Droid in" + ((System.nanoTime() - time) / 1E9f) + "seconds"); 
<|del|>
 gridLayoutManager.setVGap(10); 
 .withDescription("enable experimental opcodes to be disassembled, even if they aren't necessarily supported in the Android runtime yet") 
 IGET_VOLATILE((short)0xe3, "iget-volatile", minApi(9), ReferenceType.FIELD, Format.Format22c, Opcode.ODEX_ONLY | Opcode.ODEXED_INSTANCE_VOLATILE | Opcode.CAN_THROW | Opcode.CAN_CONTINUE | Opcode.SETS_REGISTER), 
 //if the instruction is experimental (not potentially supported by Android runtime yet) 
 " aren't necessarily supported by the Android runtime yet") 
 * The file or directory must exists and be readable. 
 .or(REPORTER.getClazz().isImplementedBy(SdkReporter.class))).withCategory(Brest.get()); 
 * it will switch to either the actual image or the error image. * @param view The imageView that the listener is associated with. 
public class AndroidThemePreviewPanel extends AndroidPreviewPanel implements RenderContext { 
 result = myRenderSession != null ? myRenderSession.getResult() : null; 
 Location location = stream.getLocation(); if (location.equals(StandardOutputKind.STANDARD_OUTPUT.getLocation()) && !allowStandardIO) { 
 } else if (location.equals(StandardOutputKind.STANDARD_ERROR.getLocation()) 
 * Class describing a standard error. 
 */ // STOPSHIP see https://android-review.googlesource.com/#/c/120553/17 
<|del|> 
 public PairCodec<T, U> on(@Nonnull String separator) { 
 int endKey = string.indexOf(separator); if (endKey == -1) { throw new ConfigurationError("Missing '" + separator + "' in '" + string + "'"); } 
 @Nonnull String string) 
 int endKey = string.indexOf(separator); if (endKey == -1) { exceptions.appendException(new ParsingException("Missing '" + separator + "' in '" + string + "'")); 
 String key = string.substring(0, endKey); String valueString = string.substring(endKey + separator.length()); 
 String key = string.substring(0, endKey); String valueString = string.substring(endKey + separator.length()); 
 String key = string.substring(0, endKey); String valueString = string.substring(endKey + separator.length()); 
 sb.append(" and where <value> is "); 
 sb.append(" and where <value> is "); 
 sb.append(" and where <value> is "); 
 throw new RuntimeException("RenderTask should have PsiFile to render menu files"); 
 throw new RuntimeException("RenderTask always should always have PsiFile when it has ResourceFolderType"); 
 throw new RuntimeException("createRenderSession shouldn't be called on RenderTask without PsiFile"); 
 throw new IllegalStateException("createRenderSession shouldn't be called on RenderTask without PsiFile"); 
<|del|> 
 assertTrue(wizard.containsStep(NewCloudModuleDynamicWizardStep.STEP_NAME, true)); 
 assertTrue(wizard.containsStep(NewCloudModuleDynamicWizardStep.STEP_NAME, true)); } finally { Disposer.dispose(wizard.getDisposable()); } 
 // Sets group for attribute, for example: sets "Button Styles" group for "buttonStyleSmall" attribute 
 // Only "Theme" Styleable has attribute groups if (def != null && def.getName().equals("Theme")) { 
 public static final String TEST_CAUGHT_EXCEPTION_SIGNAL = "CAUGHT"; 
<|del|> 
 return reply.getNextValueAsLocation(); 
 String expectedThrowLocationClassSignature = getThrowLocationMethodClassSignature(fromNative); 
 if (debuggeeClassID != throwLocation.classID || debuggeeThrowMethodID != throwLocation.methodID) { StringBuilder builder = new StringBuilder("Invalid method for throw location:"); builder.append(" expected "); 
 if (debuggeeClassID != catchLocation.classID || debuggeeThrowMethodID != catchLocation.methodID) { StringBuilder builder = new StringBuilder("Invalid method for catch location:"); builder.append(" expected "); 
 // to check that we properly compute the catch location. We insert a native // frame by using reflection in the code. To insert an interpreter frame, 
 // to check that we properly compute the catch location. We insert a native // frame by using reflection in the code. To insert an interpreter frame, 
 if (debuggeeClassID != throwLocation.classID || debuggeeThrowMethodID != throwLocation.methodID) { StringBuilder builder = new StringBuilder("Invalid method for throw location:"); builder.append(" expected "); 
 public final JackApiToolchain setErrorStream(@Nonnull OutputStream errorStream) { 
 final private static Set<String> ourWhitelistedOverloadedMethods = Sets.newHashSet("android.widget.Toast.makeText"); private static boolean hasMethodOnlyOverloadedWithOneIntParameter(final PsiMethod method, int index) { 
import java.awt.*; 
 setRepeatingRequest(mHdrBuilder.build(), mCaptureCallback, mReadyHandler); 
<|del|> 
<|del|> 
 // // Limit modifier bits to the ones that toString should return for fields. 
 // Limit modifier bits to the ones that toString should return for constructors and methods, // e.g. excluding "bridge". 
 http://b/18488857 assertEquals( "public int java.lang.String.compareTo(java.lang.Object)", 
 new StringValueCodec("annotation processor option name"), new StringValueCodec("annotation processor option value"))))) 
 if (item != null && item.isOverriding(((AttributesTableModel) table.getModel()).getSelectedStyle())) { 
 String commaSeparatedMenus = xmlFile == null ? null : AndroidPsiUtils.getRootTagAttributeSafely(xmlFile, ATTR_MENU, TOOLS_URI); 
 String navMode = StringUtil.notNullize(xmlFile == null ? null : AndroidPsiUtils.getRootTagAttributeSafely(xmlFile, ATTR_NAV_MODE, TOOLS_URI)).trim(); 
 private static JackConfigProvider configProvider; 
<|del|> 
 mBuffer[0] = (byte)((v >>> 0) & 0xff); mBuffer[1] = (byte)((v >>> 8) & 0xff); 
 byte[] b = new byte[20]; 
 ExecuteFile exec = new ExecuteFile(commandLineArgs.toArray(new String[commandLineArgs.size()])); exec.setErr(err); exec.setOut(out); 
 } if (suckOut != null) { suckOut.join(); } if (suckErr != null) { suckErr.join(); } ret = proc.exitValue(); proc.destroy(); return ret; 
 public JPopupMenu getPopupMenuAtCell(int row, int column) { 
 final List<EditedStyleItem> rawAttributes = ThemeEditorUtils.resolveAllAttributes(mySelectedStyle); 
 private Directory(@Nonnull File file, 
 @Nullable 
 if (DEBUG_APP_TRANSITIONS || DEBUG_WALLPAPER) Slog.v(TAG, "*** WALLPAPER DRAW TIMEOUT"); 
 for (int curTokenIndex = mWallpaperTokens.size() - 1; curTokenIndex >= 0 && wallpaperGoodToGo; curTokenIndex--) { 
 for (int curTokenIndex = mWallpaperTokens.size() - 1; curTokenIndex >= 0 && wallpaperGoodToGo; curTokenIndex--) { 
 if (DEBUG_APP_TRANSITIONS || DEBUG_WALLPAPER) Slog.v(TAG, 
 if (DEBUG_APP_TRANSITIONS || DEBUG_WALLPAPER) Slog.v(TAG, 
 protected WithLocationException(@CheckForNull Location location, @CheckForNull Throwable cause) { 
 throw new AssertionError(); 
 int modifiers = Modifier.getDeclarationFieldModifiers(Modifier.fieldModifiers()); 
 + "libcore.java.lang.reflect.FieldTest$ClassWithATransientField" 
 // Note that it checks that "STRICT" is rendered as "strictfp" (for other modifiers, // the displayed name is the same as the lowercase constant name). 
 // Note that it checks that "STRICT" is rendered as "strictfp" (for other modifiers, // the displayed name is the same as the lowercase constant name). 
 apiV01Config.setProcessorOptions(annotationProcessorOptions); 
<|del|> 
 options.addAnnotationProcessorOption(entry.getKey(), entry.getValue()); 
<|del|> 
 i |= (mBuffer[0] & 0xff) << 0; i |= (mBuffer[1] & 0xff) << 8; i |= (mBuffer[2] & 0xff) << 16; i |= (mBuffer[3] & 0xff) << 24; 
 commandLineArgs.add("-jar"); 
 EditedStyleItem editedStyleItem = new EditedStyleItem(resourceValue, getSelectedStyle()); assert editedStyleItem.getValue() != null; myCurrentSubStyle = myStyleResolver.getStyle(editedStyleItem.getValue()); 
 private InputZipFile(@Nonnull File file, @Nonnull FileLocation location, 
 protected StreamFile(@Nonnull File file, 
 static void doStuff(AbstractClass c) { 
 config.setSourceEntries(Arrays.asList(new File(args[1]))); 
 * // Note that guard could be null if the constructor threw. 
 * // Note that guard could be null if the constructor threw. 
 protected static int runJack(@Nonnull PrintStream err, @Nonnull Options options) { 
 protected static int runJack(@Nonnull PrintStream err, @Nonnull Options options) { 
<|del|> 
 options.setWorkingDirectory(pwd); options.setStandardError(err); options.setStandardOutput(out); 
 assert confProvider.isSupportedConfig(config); 
<|del|> 
 // Variant selection conflicts are not considered project structure errors. return errorCount > 0 && errorCount > messages.getMessageCount(VARIANT_SELECTION_CONFLICTS); 
 public ScreenshotComparisonPanel(ScreenshotComparisonDialog parent, @Nullable ScreenshotComparisonPanel clonedPanel, 
<|del|>
 private static String renderColor(Module module, @NotNull Color color) { 
<|del|> 
 return render.substring(0, bodyIndex + bodyTag.length()) + doc + render.substring(bodyIndex + bodyTag.length()); 
 public Set<String> AFTER_SYNC_TASK_NAMES = Sets.newHashSet(); 
<|del|> 
 if (!modifiers.isEmpty()) { sb.append(modifiers).append(' '); 
 Modifier.getDeclarationFieldModifiers(getModifiers())); 
 Modifier.getDeclarationMethodModifiers(getModifiers())); 
 if (workingDirectory != null && !fileWithoutWorkingDir.isAbsolute()) { 
 subReleaseKind = SubReleaseKind.valueOf(SubReleaseKind.class, prop.getProperty("jack.version.sub-release.kind")); 
 return JackLibraryFactory.getOutputLibrary(vfs, Jack.getEmitterId(), Jack.getVersion() .getVerboseVersion()); 
 /** Protocol. An Ethernet protocol type, e.g., {@code ETH_P_IPV6}. */ 
 public int getInterfaceIndex() { 
 public short getHardwareType() { 
 public byte getPacketType() { 
 public byte[] getAddress() { 
 public short sll_protocol; 
 return Collections.unmodifiableList((List<TestSensorEvent>) mCollectedEvents.clone()); 
 return "Environment variable '" + missingVariable + "' is undefined"; 
public class ServerExitStatus extends ExitStatus { /** * Jack jar not found. */ public static final int FAILURE_JACK_JAR_NOT_FOUND = -1; 
 if (jackJarPath == null) { throw new MissingEnvException("JACK_JAR"); } new InputStreamFile(jackJarPath); 
 if (jackJarPath == null) { throw new MissingEnvException("JACK_JAR"); } new InputStreamFile(jackJarPath); 
 return new Entry(tokenizer.sval, new LineLocation(sources.getCurrentLocation(), 
 short result = (Short) m.invoke(null); 
 * Right borders for each span. * <p>For <b>i-th</b> item start is {@link #mCachedBorders}[i-1] + 1 
<|del|>
 public final short sll_protocol; 
 text.append(".)"); 
<|del|> 
 // Classes probably have changed so reload the custom components and support library classes. myPreviewPanel.reloadComponents(); myPreviewPanel.revalidate(); myPreviewPanel.repaint(); 
 public final static String STYLE_NAME = "style-name"; public final static String PROPORTION = "proportion"; 
 @Nullable public String getThemeName() { 
 result = 31 * result + (mySubStyleName != null ? mySubStyleName.hashCode() : 0); result = 31 * result + (myProportion != null ? myProportion.hashCode() : 0); 
 * A help panel that displays help text and error messaging for AVD options. 
 myErrorInstructionsLink.setVisible(hasLink); 
 return "HAXM Installation"; 
 if (!myCurrentProgressIndicator.compareAndSet(null, progressIndicator)) { throw new IllegalStateException("Submitting an operation while another is in progress."); } 
 protected Map<T, U> convert(@Nonnull List<Entry<T, U>> list) { 
 protected MessageDigestFactory convert(@Nonnull Service service) { 
<|del|> 
 @Override public String toString() { return label; 
<|del|> 
<|del|> 
 VirtualFile layout = myFixture.copyFileToProject("themeEditor/theme_preview_layout.xml", "res/layout/theme_preview_layout.xml"); Configuration configuration = myFacet.getConfigurationManager().getConfiguration(layout); 
<|del|> 
 hashCode = hash(declaringClass) ^ hash(name) ^ hash(signature); 
 private static byte[] stringToUtf8Bytes(String string, int utf8Len) { 
 protected void tearDown(){ if (mWakeLock != null && mWakeLock.isHeld()) { mWakeLock.release(); } 
 void setVerbose(boolean isVerbose) throws ConfigurationException; 
 void setInputJavaBinaryFile(@Nonnull File input) throws ConfigurationException; 
 void setOutputJackFile(@Nonnull File output) throws ConfigurationException; 
 * This class provides the version 01 implementation of Jill API. 
 void setOutputJackFile(@Nonnull File outputJackFile) throws ConfigurationException; 
 //new ComponentDefinition("Switch", ComponentGroup.BUTTONS, SWITCH).setText(""), 
<|del|> 
<|del|> 
<|del|> 
 protected final CustomPrintWriter writerByDefault = ThreadConfig.get(REPORTER_WRITER) .getPrintWriter(); 
 protected final PrintWriter reporterStream = ThreadConfig.get(REPORTER_WRITER).getPrintWriter(); 
 printFilteredProblem(problemLevel, message, null); 
 printFilteredProblem(problemLevel, message, null); 
 @Nonnull String message, @CheckForNull Location location); 
import javax.swing.BorderFactory; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComboBox; import javax.swing.JComponent; import javax.swing.JPanel; import javax.swing.ListSelectionModel; import javax.swing.ScrollPaneConstants; 
 * @throws IllegalStateException If the translation task is run more than once 
 return Jill.getVersion().getSubReleaseCode(); 
 if (!input.getAbsoluteFile().isFile()) { 
 setErrorState("RAM must be a numeric (integer) value of at least 128MB. Recommendation is 1GB.", myMemoryAndStorageLabel, myRamLabel, myRamStorage); 
 return new File(mBundleFolder, FN_PUBLIC_TXT); 
 if (mPolicy.isKeyguardLocked()) { // If the screen is locked and no top system window is requesting an orientation, // we should return the orientation of the show-when-locked app (if there is any) // or the orientation of the keyguard. 
 req = mLastKeyguardForcedOrientation; 
 } 
 public static final String[] JACK_DEFAULT_LIB_PATH = new String[]{"jack-default-lib/"}; 
<|del|> 
<|del|> 
 "jack.cfg.removed-basic-blocks", "Unaccessible basic blocks removed", 
<|del|> 
 assertEquals(doc, ansDoc); 
<|del|> 
<|del|> 
 assertNotNull(theme); 
<|del|> 
 if (TextUtils.equals(value, getPersistedString(null))) { 
 } catch(NullPointerException expected) { 
 * {@link #FLAG_FULL_BACKUP_ONLY}, {@link #FLAG_MULTIARCH}. 
<|del|> 
<|del|> 
<|del|> 
 } if (!foundBootART) { fail("expected to find boot.art"); } bufReader.close(); reader.close(); ins.close(); 
 InputStream smaliStream = RoundtripTest.class.getClassLoader(). 
 @Nonnull protected String getInputFilename(@Nonnull String testName) { return String.format("%s%s%sInput.smali", testDir, File.separatorChar, testName); 
 mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler); 
 public final int hashCode() { 
<|del|> 
 * Specialization of the {@link FileSupplier} interface for split APKs. 
 @SuppressWarnings("ConstantNamingConvention") private static final Logger LOG = Logger.getInstance(AndroidThemePreviewPanel.class); 
 private final static Logger LOG = Logger.getInstance(EditedStyleItem.class); private final static String DEPRECATED = "deprecated"; 
 if (!isNullOrEmpty(additionalParameters)) { 
 public void additionalParameters(@NonNull String param) { 
 @Optional @Input 
 final private String myText; 
 + "strings that look like integers can drop leading zeroes. See issue " 
<|del|> 
 private static List<File> splitDexPath(String path) { return splitPaths(path, null, false); 
 private static final VPathFragment INTERNAL_SEPARATOR_FRAGMENT = new VPathFragment(String.valueOf(INTERNAL_SEPARATOR), INTERNAL_SEPARATOR); 
 "jack.cfg.removed-basic-blocks", "Unaccessible basic blocks removed", 
 @CheckForNull 
 protected WithLocationException(@Nonnull HasLocation locationProvider, 
 * Exception when a file or directory can not be cleared of the expected permission. 
 code = service.run(out, err, new File(workingDir), args); 
 * Exception when a file or directory can not be cleared to the expected permission. 
<|del|> 
 // TODO: We shouldn't assume that we know default linker search logic. 
 BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader; ldLibraryPath = dexClassLoader.getLdLibraryPath(); dexPath = dexClassLoader.getDexPath(); 
 private static native String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath, String dexPath); 
 return UCharacter.isUpperCase(codePoint); 
<|del|> 
 /// CHECK-START: long Main.$noinline$OrSame(long) instruction_simplifier (after) 
 @Nonnull 
 @Nonnull 
<|del|> 
 * Truth support for aar files. 
 public IterableSubject<? extends IterableSubject<?, String, List<String>>, String, List<String>> entries( String conformingTo) throws IOException { 
<|del|> 
 if (((changingConfigurations&~(FONT_SCALE_CONFIG | DENSITY_CONFIG | SPEC_PUBLIC)) & ~allowVarying) != 0) { 
 private final static A a = new A(); 
 // a single view in the cache, but it's larger than the max memory limit 
<|del|> 
<|del|> 
 // If checkInput is false, getErrorText will be not null. //noinspection ConstantConditions return new ValidationInfo(myResourceNameValidator.getErrorText(newStyleName), myStyleNameTextField); 
 private ArrayList<V>[] values = new ArrayList[0]; 
 @SuppressWarnings("unchecked") @Nonnull 
 @SuppressWarnings("unchecked") @Nonnull 
 int positionToInsertNext = 0; 
 private final Box myBox = new Box(BoxLayout.LINE_AXIS); 
 myBox.add(myTextField); myBox.add(Box.createHorizontalGlue()); 
 myItem = (EditedStyleItem)value; 
 return myBox; 
 private final HashSet<String> mySelectedFlags = new HashSet<String>(); 
 if (!StringUtil.isEmpty(value)) { for (String flag : Splitter.on("|").split(value)) { mySelectedFlags.add(flag); } 
 if (!StringUtil.isEmpty(value)) { for (String flag : Splitter.on("|").split(value)) { mySelectedFlags.add(flag); } 
 JCheckBox checkbox = (JCheckBox)e.getSource(); 
 } else { 
<|del|> 
 for (String flagName : flagNames) { JCheckBox flag = new JCheckBox(flagName); if (mySelectedFlags.contains(flagName)) { 
 for (String flagName : flagNames) { JCheckBox flag = new JCheckBox(flagName); if (mySelectedFlags.contains(flagName)) { 
 public void setManifest(@NonNull File manifest) { 
<|del|> 
 public void setRenderer(@NonNull AndroidAsciiReportRenderer renderer) { 
 filterDatas = persistence.load(new FileReader(metadataFile)); 
 return Iterables.getOnlyElement(testedApkFiles); 
 InputStream getInputStream() throws WrongPermissionException; 
 OutputStream getOutputStream() throws WrongPermissionException; 
 PrintStream getPrintStream() throws WrongPermissionException; 
 void adjustBounds(boolean inTransaction) { 
 mDimSurface.setSize(dw, dh); 
public class SigningConfigAdaptor implements com.android.builder.model.SigningConfig { 
 printTasksDependencies(); 
 private void printTasksDependencies() { 
 lookup.addType(loaded); 
<|del|> 
 OutputVFile vFile; 
 public void writeJNodeTypeInfo(@Nonnull JDefinedClassOrInterface jnode) throws IOException { 
 IDX("jayce", "index", ".idx", "index") { 
 return Jack.getUnmodifiableCollections().getUnmodifiableCollection(types.values()); 
 url.openConnection().getContent(); fail(); 
 private volatile boolean mCleartextTrafficPermitted = true; 
 * without TLS or STARTTLS) is permitted for this process. 
 * without TLS or STARTTLS) is permitted for this process. 
 * FTP stacks, {@code WebView}, {@code MediaPlayer}) will refuse this process's requests to use * cleartext traffic. Third-party libraries are encouraged to honor this setting as well. 
 private void adjustBounds() { 
 createZipFile(1, 4294967410L, false /* setEntrySize */); 
 AttributeDefinition attrDefinition = StyleResolver.getAttributeDefinition(selectedStyle.getConfiguration(), value.getItemResourceValue()); 
 AttributeDefinition attrDefinition = StyleResolver.getAttributeDefinition(item.getSourceStyle().getConfiguration(), item.getItemResourceValue()); 
 for (String flagName : flagNames) { JCheckBox flag = new JCheckBox(flagName); if (mySelectedFlags.contains(flagName)) { 
 List<File> filesToOpen = myState.get(FILES_TO_OPEN_KEY); assert filesToOpen != null; // This path must exist in a wizard that supports a list of files to open on completion filesToOpen.addAll(activityTemplate.getFilesToOpen()); 
 "5 seconds and ensure that they repeat at most every 60 seconds.\n" + "\n" + "If you really need to do work sooner than 5 seconds, post a delayed message " + "or runnable to a Handler.", 
 String message = String.format("Value will be forced up to %d as of Android 5.1; " 
 String message = String.format("Value will be forced up to %d as of Android 5.1; " 
 public void prepare(@Nonnull Collection<CstString> cstStrings, @Nonnull Collection<CstFieldRef> cstFieldRefs, @Nonnull Collection<CstMethodRef> cstMethodRefs, @Nonnull Collection<CstType> cstTypes) { 
 private File createZipFile(int numEntries, long entrySize, boolean setEntrySize) 
 // CHECK-DAG: Return [ [[Static]] ] 
 // CHECK-DAG: Return [ [[Class]] ] 
 final Dimension size = AndroidRootComponent.this.getSize(); 
 VMRuntime.getRuntime().requestConcurrentGC(); 
 File getJavaResourcesFolder(); 
 fifoMaxEventCount * maximumExpectedSamplingPeriodUs; 
<|del|> 
 * Handles execution either on a remote target device, or on a local host computer. 
 // Force an update of static JBColor.DARK. This is required to show the correct color after a LookAndFeel change. JBColor.setDark(UIUtil.isUnderDarcula()); 
 if (errorCode != android.security.KeyStore.NO_ERROR) { 
 * RS_* objects: opaque handles with implementation dependent 
 if (nfcBarcode != null && nfcBarcode.getType() == NfcBarcode.TYPE_KOVIO) { 
 JackApiToolchainBase toolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class); 
 * Test that Jack is neither failing nor dropping warnings while ecj frontend is subject to skip 
 IToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class); 
 warnIndex = errString.indexOf("WARNING:", warnIndex + 1); Assert.assertTrue(warnIndex != -1); Assert.assertTrue(errString.indexOf("WARNING:", warnIndex + 1) == -1); 
<|del|> 
 checkOffset(offset); 
 } catch (ReflectiveOperationException e) { // Can't access the Android framework NetworkSecurityPolicy. To be backward compatible, // assume that cleartext traffic is permitted. Android CTS will take care of ensuring // this issue doesn't occur on new Android platforms. 
 boolean cleartextTrafficPermitted = mSystemFacade.isCleartextTrafficPermitted(mInfo.mUid); 
 if (ArrayUtils.isEmpty(packageNames)) { 
 // getting Variable Table 
 // TODO check that we find every variable 
 // Wait for debuggee to start. 
 // Check every local variable of every method. 
 // Remove the breakpoint. 
 // Check every local variable of every method. 
 boolean firstSuspension) { 
 assertNotNull("Cannot find frame for method " + testMethodName, testMethodFrame); 
 // TODO specialize between GetValues and SetValues tests. 
 public VariableNameAndTag(String testVariableName, byte testVariableJdwpTag) { 
 * to suspend the debuggee. 
 String varSignatures[] = { "Lorg/apache/harmony/jpda/tests/jdwp/StackFrame/StackTraceDebuggee;", "Z", "I", "Ljava/lang/String;" }; 
 // release debuggee 
 // prints variables info, checks signatures protected static boolean checkVarTable(LogWriter logWriter, VarInfo[] varInfos, 
<|del|> 
 if (!varSignatures[index].equals(varInfos[i].getSignature())) { 
 if (!varNames[index].equals(varInfos[i].getName())) { 
 if (existingNode instanceof JMethod) { if (transform(methods, existingNode, (JMethod) newNode, transformation)) { return; 
 * Copyright (C) 2015 The Android Open Source Project 
 * Copyright (C) 2015 The Android Open Source Project 
 * Copyright (C) 2015 The Android Open Source Project 
@Transform(remove = {ReferencedFromInnerClassMarker.class}) 
<|del|> 
 // Fields which can't be resolved have a null type. if (field.getType() != null && field.isAnnotationPresent(ExportedProperty.class)) { 
<|del|> 
<|del|> 
 } else if (opResult.resultCode != KeyStore.NO_ERROR) { 
 JackApiToolchainBase toolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class); 
 String.format("Artifact with name %1$s already registered.", name)); 
 * For sensors with other reporting modes, this is the maximum integer * {@link Integer#MAX_VALUE} as they can report no events for long * periods of time. 
 * For sensors with other reporting modes, this is the maximum integer * {@link Integer#MAX_VALUE} as they can report no events for long * periods of time. 
 if (Objects.equal(projectSystemId, targetProjectSystemId) || Objects.equal(projectSystemId, ProjectSystemId.IDE)) { 
 } else if (opResult.resultCode != KeyStore.NO_ERROR) { 
<|del|> 
 if (!AnnotationUtil.isAnnotated(otherParameter, SUPPORT_ANNOTATIONS_PREFIX + "StringRes", false, false)) { 
 public ThemeEditorToolTip(@NotNull JComponent component) { myComponent = component; 
 @NonNull File javaResourcesFolder, 
 private final File javaResourcesFolder; 
 @NonNull File javaResourcesFolder, 
<|del|> 
<|del|> 
 @Nullable 
 public void setVariants(Set<BaseVariantData> variants) { this.variants = variants; 
<|del|> 
 "will override near-future and high-frequency alarm requests, delaying the alarm " + "at least 5 seconds into the future and ensuring that the repeat interval is at " + "least 60 seconds.\n" + 
<|del|> 
 // Do not test AndroidKeyStore's KeyGenerator. It cannot be initialized without // providing AndroidKeyStore-specific algorithm parameters. // It's OKish not to test AndroidKeyStore's KeyGenerator here because it's tested // by cts/tests/test/keystore. 
 * All features before this map to the ones in {@link Capability}. Any feature greater than this * is guaranteed to be not supported by a LayoutLib using the older api. 
 private JAnnotationType getJAnnotationType(@Nonnull Class<? extends Annotation> clazz) { 
 private final JAnnotationType signatureAnnotationType; 
 @Nonnull JDefinedClassOrInterface loaded, @Nonnull JAnnotationType annotationType) { 
 JAnnotationType installerAnnotationType = 
 * @since 1.2, it was only in AndroidArtifact before. 
 - mService.mDisplayFreezeTime); // We are assuming the hosting process is dead or in a zombie state. 
<|del|> 
<|del|> 
<|del|> 
 return null; 
 // Try to use the one which is closest to top. ActivityRecord r = stack.mResumedActivity; 
 public void prepare(@Nonnull Collection<CstString> cstStrings, @Nonnull Collection<CstFieldRef> cstFieldRefs, @Nonnull Collection<CstMethodRef> cstMethodRefs, @Nonnull Collection<CstType> cstTypes) { 
 myModuleTypesCombo.setSelectedIndex(0); 
<|del|> 
<|del|> 
 if (FileUtil.isAncestor(folderPath, generatedSourceFolder, false)) { 
 // We're not compiling this method because we consider it huge. 
 return l999; 
final class TransactionAbortError extends InternalError { 
 private TransactionAbortError(String detailMessage) { 
 } else if (!allowRestart) { 
 if (!AnnotationUtil.isAnnotated(otherParameter, STRING_RES_ANNOTATION, false, false)) { 
 private GlobalScope globalScope; 
<|del|> 
 mResourceVisibility = mClient.getResourceVisibilityProvider().get(project, variant); 
 private final Object myLock = new Object(); 
 } }; 
 private final Object myTaskLock = new Object(); 
 String getShortDescription(); 
 String getListDescription(); 
 * compatibility with the older {@link LocalSdkParser} class. 
 // BEGIN android-removed 
<|del|> 
 private static final HashMap<String, Integer> runtimeStatsMap = new HashMap<>(); 
 * @return the value of the runtime statistic. 
 Integer statId = runtimeStatsMap.get(statName); 
 for (String name : runtimeStatsMap.keySet()) { int id = runtimeStatsMap.get(name); 
<|del|> 
 assert !JackIrBuilder.hasError(typeDecl); 
 assert !JackIrBuilder.hasError(typeDecl); 
 Process proc = Runtime.getRuntime().exec("/bin/ps ux"); 
 Process proc = Runtime.getRuntime().exec("/bin/ps -C ibus-daemon"); 
 // prevNumberofSpans was > 0, therefore spans != null Arrays.fill(spans, numberOfSpans, prevNumberOfSpans, null); 
 if (!DefaultDebugExecutor.EXECUTOR_ID.equals(executorId) && !DefaultRunExecutor.EXECUTOR_ID.equals(executorId)) { return false; } if (!(profile instanceof AndroidRunConfigurationBase)) { return false; } return ((AndroidRunConfigurationBase)profile).usesSimpleLauncher(); 
public class GlobalScope { @NonNull 
public interface TaskConfigAction<T> extends Action<T> { /** * Return the name of the task to be configured. */ 
 @NonNull 
 @NonNull 
<|del|> 
<|del|> 
 runner.start(); 
 private TestProject testProject = null; 
 return new GradleTestProject( name, testProject, experimentalMode, experimentalMode ? GRADLE_EXP_TEST_VERSION : GRADLE_TEST_VERSION, captureStdOut, captureStdErr); 
 * weaknesses due to which ciphertext may leak information about plaintext. For example, if a * given plaintext always produces the same ciphertext, an attacker may see the repeated * ciphertexts and be able to deduce something about the plaintext. 
<|del|> 
<|del|> 
 true /*isTest*/, 
<|del|> 
import java.awt.Component; 
 return baz(denominator); 
 if (!(ex instanceof NullPointerException)) { 
 if (!(ex instanceof ArrayIndexOutOfBoundsException)) { 
 if (!(ex instanceof ArithmeticException)) { 
 this.mappingConfiguration = configuration; dependsOn(configuration); 
 this.classesConfiguration = configuration; dependsOn(configuration); 
<|del|> 
 private static final List<Group> GROUPS = Arrays.asList( 
 * @param other a configuration created by another producer. 
 private PsiMethod createMethodWithShortClassReferences(@NotNull String text) { 
<|del|> 
 return new String[]{String.format("%1$s.%2$s(%3$s);\n", parcelVariableName, myWriteMethodName, field.getName())}; 
<|del|> 
 if (!mService.isSleeping()) { // Avoid recursion among check for sleep and complete pause during sleeping. // Because activity will be paused immediately after resume, just let pause // be completed by the order of activity paused from clients. 
 returnedComponent.setForeground((item != null && !item.isPublicAttribute()) ? JBColor.GRAY : table.getForeground()); 
 ignoredProducers = RunConfigurationProducerService.getInstance(project).getIgnoredProducers(); 
 public <T> void bind(@NotNull Property<T> dest, @NotNull ObservableValue<T> src, @NotNull ObservableValue<Boolean> enabled) { release(dest); 
 private void adjustModuleStructures() { 
 private static void adjustInterModuleDependencies(@NotNull ModuleRootManager moduleRootManager) { 
 public static void setModuleCompiledArtifact(@NotNull Module module, @Nullable LibraryDependency compiledArtifact) { module.putUserData(MODULE_COMPILED_ARTIFACT, compiledArtifact); 
 assertEquals(new ULocale("nn"), matcher.getBestMatch("no")); // Google patch" prefer "no" over "nb" 
 * stored coordinate) followed by the binary representation of the {@code x} coordinate. * See {@code ISO 18033-2} section {@code 5.4.3}. 
<|del|> 
<|del|> 
 * Gets the set of digest algorithms with which the key can be used. 
 myNonEmptyMinimumSize = new Dimension(0, getFontMetrics(getFont()).getHeight()); 
 * Determines whether the prefix contains the specified address. 
 public boolean contains(InetAddress address) { byte[] addrBytes = (address == null) ? null : address.getAddress(); if (addrBytes == null || addrBytes.length != this.address.length) { 
 private static InetAddress Address(String addr) { 
<|del|> 
 * Custom Renderer and Editor for the theme parent attribute. * Uses a dropdown to offer the choice between Material Dark, Material Light or Other. * Deals with Other through a separate dialog window. 
 public ParentRendererEditor(@NotNull Configuration configuration) { 
 // in case this is a nightly (e.g. "2.4-20150409092851+0000"). 
 gradleInvoker.compileJava(modules, TestCompileType.JAVA_TESTS); 
<|del|> 
 return getRuntimeStatInternal(statId); 
 int id = runtimeStatsMap.get(name); String value = values[id]; map.put(name, value); 
 scrollPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE)); 
 myPreviewPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE)); 
 return myGraphicsLayoutRenderer.getPreferredSize(); 
<|del|> 
 private final static class CustomTimeZoneParser { 
 private CustomTimeZoneParser() {} 
 * Sets the set of digests with which the key can be used when signing/verifying. Attempts 
<|del|> 
 0, // purposes null, // digests null, // encryption paddings null, // signature paddings null, // block modes false, // randomized encryption required 0, // user authenticators -1 // user authentication validity duration (seconds) ); 
 StreamTokenizer tokenizer = sources.getCurrentTokenizer(); 
<|del|> 
 private @NotNull List<Color> myColors = Collections.emptyList(); 
<|del|> 
 final int cellSize = height - 2 * STATES_PADDING; 
 myColors = ImmutableList.copyOf(colors); 
import java.awt.BorderLayout; import java.awt.Color; import java.awt.Font; 
 public ColorComponent(@NotNull final Color backgroundColor) { super(new BorderLayout(0, PADDING)); 
import java.awt.Dimension; 
 * @param address An {@link InetAddress} to test. 
 @Override public void beforeCheckProject(@NonNull Context context) { 
 .getNodeName().equals(NODE_ACTION)) { 
 * Return the first service instance for the requested service type or * {@link Optional#absent()} if none exist. 
 return Files.readLines(rFile, Charsets.UTF_8, new LineProcessor<Collection<String>>() { Collection<String> idNames = new ArrayList<String>(); @Override public boolean processLine(@NotNull String line) throws IOException { 
 return Files.readLines(rFile, Charsets.UTF_8, new LineProcessor<Collection<String>>() { Collection<String> idNames = new ArrayList<String>(); @Override public boolean processLine(@NotNull String line) throws IOException { 
 public static final String NULLABLE_ANNOTATION = SUPPORT_ANNOTATIONS_PREFIX + "Nullable"; //$NON-NLS-1$ 
 private static final char BANG = '!'; 
 assert entry.getName().indexOf(BANG) == -1; return new URL("ziploader", "", -1, file.getName() + BANG + entry.getName(), handler); 
<|del|> 
 private static final class UnknownReferencedTypeException extends Exception { 
 return "Unknown referenced type '" + UserFriendlyFormatter.getFormatter().getName(phantomClOrI) 
 private static final Set<String> THEME_WHITELIST = ImmutableSet .of("Theme.Material.NoActionBar", "Theme.Material.Light.NoActionBar", "Theme.AppCompat.NoActionBar", "Theme.AppCompat.Light.NoActionBar"); 
 JackRouter protocolVersion = 
 if (!context.getResources().getBoolean(R.bool.use_localized_digits)) { locale = new Locale.Builder() 
 mReplacementMap.put(Integer.toString(i), String.valueOf((char) (i + zeroDigit))); 
 if (!getResources().getBoolean(R.bool.use_localized_digits)) { 
 final char zeroDigit = symbols.getZeroDigit(); 
<|del|> 
 return (ThemeEditorStyle)item; 
 } filters.addAll(super.getApplicableFilters()); 
 String prefix = (ns != null ? (ns + ":") : ""); attributes.put(prefix + key, value); 
 // We have our own custom renderer that it's not based on the default one. //noinspection GtkPreferredJComboBoxRenderer myPanel.getThemeCombo().setRenderer(new StyleListCellRenderer(myThemeEditorContext)); myPanel.getThemeCombo().addActionListener(new ActionListener() { 
 myAttributesTable.setModel(myModel); myAttributesTable.setRowSorter(myAttributesSorter); myAttributesTable.updateRowHeights(); 
 // First remove the table editor so that it won't be called after // objects it relies on, like the module, have themselves been disposed myAttributesTable.removeEditor(); myThemeEditorContext.dispose(); 
 LocalResourceRepository repository = AppResourceRepository.getAppResources(myConfiguration.getModule(), true); assert repository != null; 
 if (myStyleParentName != null) { if (comboBoxModel.getIndexOf(myStyleParentName) != -1) { comboBoxModel.removeElement(myStyleParentName); } comboBoxModel.insertElementAt(myStyleParentName, 0); 
 int low = 0, mid = list.size(), high = mid - 1, result = 1; 
<|del|> 
 } else { 
<|del|> 
<|del|> 
<|del|> 
<|del|>
 public void setResourcePickerListener(ResourcePickerListener resourcePickerListener) { myResourcePickerListener = resourcePickerListener; 
 if (myResourcePickerListener != null) { myResourcePickerListener.resourceChanged(resource); 
<|del|> 
 throw new DexWritingException(e); 
 throw new DexWritingException(e); 
 Collections.synchronizedSet(new HashSet<CstFieldRef>()); 
 String.format("%1$s %2$s %3$s", d.getDisplayName(), systemImageDescription.getVersion(), systemImageDescription.getAbiType()); 
 private void readIndex(@Nonnull InputStream in, @Nonnull InputJackLibrary inputJackLibrary, @Nonnull JSession session) throws IndexReadingException, LibraryReadingException { 
 JDefinedClassOrInterface loaded = (JDefinedClassOrInterface) lookup.getCachedType(curSig); 
 } catch (IOException e) { 
<|del|> 
 * Converts a color to hex-string representation, including alpha channel. * If alpha is FF then the output is #RRGGBB with no alpha component. 
 longColor |= (long)color.getAlpha() << 24; 
 static class FormatterCache extends BasicLruCache<String, DateFormat> { 
 // Show "Yesterday / Tomorrow" instead of "1 day ago / In 1 day". 
 private static boolean isBrowsable(Element e) { 
 static final int INITIAL_CAPACITY = 216; 
<|del|> 
<|del|> 
<|del|> 
 float f = 0; 
 f = -f; 
 double d = 0; 
 d = -d; 
 public ColorPicker(@NotNull Disposable parent, @Nullable Color color, boolean enableOpacity, ColorPickerListener[] listeners) { this(parent, color, true, enableOpacity, listeners, false); } 
 public ColorPicker(@NotNull Disposable parent, @Nullable Color color, boolean enableOpacity, ColorPickerListener[] listeners) { this(parent, color, true, enableOpacity, listeners, false); } 
 return (doc != null && StringUtil.containsIgnoreCase(doc, DEPRECATED)); 
 public final Type type; public final String filename; public final byte[] data; 
 public HprofData(@NonNull String filename) { 
 checkGradleCompatibility = gradleVersion.compareTo(new PreciseRevision(2, 4, 0), PreviewComparison.IGNORE) >= 0; 
 FullRevision oneDotTwoModelVersion = new PreciseRevision(1, 2, 0); 
 catch (UnsupportedCharsetException ignore) { 
 OpenUrlHyperlink openDocHyperlink = new OpenUrlHyperlink("http://tools.android.com/knownissues/encoding", "More Info..."); 
 append(styleName, SimpleTextAttributes.REGULAR_ATTRIBUTES); 
 return sql.replaceAll("[\\s]*\\n+[\\s]*", " "); 
public interface QueueThreadContext<T> { 
<|del|> 
 IdeSdks.setJdkPath(jdkPath); 
 to++; 
 * @return A non-null, possibly empty Set of update candidates. 
 * @return A non-null, possibly empty Set of new install candidates. 
 public final static long DEFAULT_EXPIRATION_PERIOD_MS = TimeUnit.DAYS.toMillis(1); 
<|del|> 
 @GuardedBy("itself") private final EnumMap<SdkSourceCategory, ArrayList<SdkSource>> mySources = 
 * Plugin to set up the android sdk {@link com.intellij.ide.externalComponents.UpdatableExternalComponent} and * {@link com.android.tools.idea.updater.configure.SdkUpdaterConfigurable}. 
 * Retrieves information on updates available from the {@link RemoteSdk}. 
 if (remote ? info.hasRemote() : info.hasLocal()) { result.add(new UpdatablePackage(info.getRemote().getPkgDesc())); 
 * An {@link UpdatableExternalComponent} that corresponds to an * {@link IPkgDesc} for a local or remote package. 
<|del|> 
<|del|> 
 private class DownloadSdkNotification extends EditorNotificationPanel { 
 if (strValue.equals(rv.getValue())) { 
 private ColorInfo myEditorValue = null; 
 private final static String DEPRECATED = "deprecated"; 
 @Nullable 
 */ @NonNull 
 * Plugin to set up the android sdk {@link UpdatableExternalComponent} and 
<|del|> 
 super.mouseReleased(e); if (e.getClickCount() < 2) { return; } 
 raf.getChannel().size(); fail(); 
<|del|> 
 * * Closing the channel closes the RandomAccessFile as well. The instance * of FileChannel returned is always the same even if the RandomAccessFile * or the FileChannel have been closed. * 
<|del|> 
 else { temporarySet.addAll(foundThemes); 
 assert file.getParent() != null : file; 
<|del|> 
 ClassObj clazz = this; 
<|del|> 
 assertEquals("method java.lang.String.charAt! argument 1 has type int, got java.lang.String", iae.getMessage()); 
 return dx; 
 succeeded = setAttributeValue(value.toString(), false); 
<|del|> 
<|del|> 
 public static String getExemplarLocation(Locale locale, TimeZone timeZone) { 
 // We don't need to use ICU for GMT or GMT(+-) zones because TimeZone.getDisplayName creates // names on demand using the timezone data. This way we will never rely on ICU calculating // the zone offset correctly. 
 if (inlineTrue()) { 
 if (inlineFalse()) { 
 if (mPos >= BUFFER_LEN) { 
 mySourceXmls = Collections.EMPTY_LIST; 
 mySourceXmls = new ArrayList<WeakReference<XmlTag>>(sourceXmls.size()); 
 // If no SDK packages were found, skip the wizard this time around. // This can happen if the user has no internet or if the sdk site is down. 
 public void loadState(@Nullable State state) { if (state == null) { state = new State(); 
 "the Google AppIndexing API.", Category.USABILITY, 5, Severity.ERROR, IMPLEMENTATION); 
 return builder.build(); 
 return myExisting != null && myExisting.contains(resourceName); 
 @NotNull List<String> dirNames) { if (dirNames.isEmpty()) { 
 @NotNull List<String> dirNames) { if (dirNames.isEmpty()) { 
<|del|> 
<|del|>
 private final void writeEscaped(String s, int quot) throws IOException { int unescapedStart = 0; 
 protected CompositeException checkForSettingsDamage() throws Exception { // For this test we don't care about checking for settings damage. 
 public boolean isThemeParentRow(int row) { 
 public PsiElement getNamePsiElement() { List<XmlTag> sourceXmls = getSourceXmls(); if (sourceXmls.isEmpty()){ 
 // Any sourceXml will do to get the name attribute from final XmlAttribute nameAttribute = sourceXmls.get(0).getAttribute("name"); if (nameAttribute == null) { 
 XmlAttributeValue attributeValue = nameAttribute.getValueElement(); if (attributeValue == null) { 
 // BEGIN android-changed 
<|del|> 
import org.jetbrains.android.util.AndroidResourceUtil; 
 // GVN is limited to a maximum loop depth of 6. To track whether dependent passes are // correctly turned off, test some very simple, but deeply nested loops. 
 } return false; 
<|del|> 
<|del|> 
 public void addChangeListener(@NotNull Runnable changeListener) { 
<|del|> 
 assert false : "Invalid state selected: " + node.getCurrentState(); 
 public UpdatablePkgInfo getPkg() { return myPkg; } public SelectedState getState() { return myState; } public void setState(SelectedState state) { myState = state; } 
 public UpdatablePkgInfo getPkg() { return myPkg; } public SelectedState getState() { return myState; } public void setState(SelectedState state) { myState = state; } 
<|del|> 
 append(" xmlns"); 
 public static boolean inlinePhi(boolean x, boolean y, boolean z) { 
 TimeZone tz = TimeZone.getDefault(); Calendar cal = new GregorianCalendar(tz, Locale.US); cal.setTimeInMillis(milliseconds); 
 TimeZone tz = TimeZone.getDefault(); Calendar cal = new GregorianCalendar(tz, Locale.US); cal.setTimeInMillis(milliseconds); 
 private static Object findAvdWithName(@NotNull JComboBox avdCombo, @NotNull String avdName) { 
 myAttributesTable.updateRowHeights(); myPreviewPanel.invalidateGraphicsRenderer(); myPreviewPanel.revalidate(); myAttributesTable.repaint(); 
<|del|> 
 myProcess.getStateController().deleteBreakpoint(myProcess.getProcessState(), breakpointId); 
 for (final Breakpoint serverBreakpoint : serverBreakpoints) { if (serverBreakpoint.getIsFinalState() == Boolean.TRUE || myIdeBreakpoints.containsKey(serverBreakpoint.getId())) { 
 private final List<CloudBreakpointListener> myBreakpointListChangedListeners = new ArrayList<CloudBreakpointListener>(); private XBreakpointHandler<?>[] myXBreakpointHandlers; 
 private Timer myListBreakpointsJob; private volatile Breakpoint myCurrentSnapshot; 
 private Timer myListBreakpointsJob; private volatile Breakpoint myCurrentSnapshot; 
 for (Breakpoint breakpoint : currentList) { final XBreakpoint breakpointHit = getBreakpointHandler().getEnabledXBreakpoint(breakpoint); 
 if (breakpoint.getIsFinalState() == Boolean.TRUE && (breakpoint.getStatus() == null || breakpoint.getStatus().getIsError() != Boolean.TRUE)) { 
 if (breakpoint.getIsFinalState() == Boolean.TRUE && (breakpoint.getStatus() == null || breakpoint.getStatus().getIsError() != Boolean.TRUE)) { 
 private final ConcurrentHashMap<String, Breakpoint> myFullFinalBreakpoints = new ConcurrentHashMap<String, Breakpoint>(); private final ProjectRepositoryState myProjectRepositoryState = new ProjectRepositoryState(); private String myUserEmail; 
 private final ConcurrentHashMap<String, Breakpoint> myFullFinalBreakpoints = new ConcurrentHashMap<String, Breakpoint>(); private final ProjectRepositoryState myProjectRepositoryState = new ProjectRepositoryState(); private String myUserEmail; 
 private volatile List<Breakpoint> myCurrentServerBreakpointList = ContainerUtil.immutableList(new ArrayList<Breakpoint>()); 
<|del|> 
<|del|> 
 @Nullable public ListenableFuture<Breakpoint> resolveBreakpointAsync(@NotNull final String id) { 
 @Nullable public ListenableFuture<Breakpoint> resolveBreakpointAsync(@NotNull final String id) { 
 return null; 
 SwingUtilities.invokeLater(new Runnable() { @Override public void run() { future.set(resultingBreakpointRef.get()); } }); 
 LOG.error("IOException hydrating a final snapshot ", e); future.setException(e); 
 LOG.warn("could not resolve breakpoint " + id); 
 if (!Strings.isNullOrEmpty(getUserEmail()) && myCloudDebuggerClient == null) { CredentialedUser user = GoogleLogin.getInstance().getAllUsers().get(getUserEmail()); 
 LOG.warn("Error connecting to Cloud Debugger API", ex); 
 try { //System.out.println("debuggees().breakpoints().delete at " + System.currentTimeMillis()); 
 catch (IOException ex) { LOG.warn("exception deleting breakpoint " + breakpointId, ex); 
 catch (IOException ex) { LOG.warn("exception deleting breakpoint " + breakpointId, ex); 
 public String getUserEmail() { return myUserEmail; 
 * @return The waitToken for use during serialization. 
 * Sets the wait token (called during serialization). * @param waitToken 
 * * @return True if there are detected changes. 
 HashSet<String> toRemoveSet = new HashSet<String>(); 
 private SyncResult(boolean invalidDebuggee, boolean needsStash, boolean needsSync, boolean isDeterminable, @Nullable String targetSyncSHA, @Nullable GitRepository targetRepository) { 
<|del|> 
<|del|> 
 * * @param executor the execution mode selected by the user (run, debug, profile etc.) 
 * * @param executor the execution mode selected by the user (run, debug, profile etc.) 
 } catch (Throwable ignore) { assert false : "A SdkSource.ChangeListener failed with an exception: " + ignore.toString(); } 
 private UpdaterTreeNode myPlatformDetailsRootNode; private UpdaterTreeNode myPlatformSummaryRootNode; 
 myStateHolder.setState(getInitialState()); 
 public void doRun() { 
<|del|> 
 private boolean myModified = false; 
<|del|> 
 orderedDensities.add(NO_FILTER); 
 public static final Splitter QUALIFIER_SPLITTER = Splitter.on('-'); 
 return getConfigFromQualifiers(QUALIFIER_SPLITTER.split(qualifierString)); 
 private final TestRule mRule; 
 public DisableOnAndroidDebug(TestRule rule) { mRule = rule; 
import com.android.sched.util.codec.PairCodec.Pair; import com.android.sched.util.collect.Lists; import com.android.sched.util.log.BaseNameLoggerFilter; 
 protected List<Pair<LoggerFilter, Level>> getLevels() { List<Pair<LoggerFilter, Level>> setup = new ArrayList<Pair<LoggerFilter, Level>>(); setup.add(new Pair<LoggerFilter, Level>(new BaseNameLoggerFilter(""), Level.SEVERE)); 
 } @Override @Nonnull protected List<String> getBaseLoggersNames() { return Lists.create("", "com.android.sched"); } 
<|del|> 
 List<Pair<LoggerFilter, Level>> levelsReverse = Lists.reverse(configuration.getLevels()); 
 List<Pair<LoggerFilter, Level>> levelsReverse = Lists.reverse(configuration.getLevels()); 
 public final void resetState() { 
 private void serializeRandomXml(Constructor<? extends XmlSerializer> ctor, long seed) throws Exception { 
<|del|> 
 public void timeKxml(int reps) throws Exception { internalTimeSerializer(kxmlConstructor, reps); 
 public void timeFast(int reps) throws Exception { internalTimeSerializer(fastConstructor, reps); 
 append('>'); 
 kxmlConstructor = (Constructor) Class.forName("org.kxml2.io.KXmlSerializer") .getConstructor(); 
<|del|> 
 assertEquals(intList1.size() + intList2.size() + 1, list.size()); 
 String folder = SdkConstants.FD_RES + "/" + ResourceFolderType.DRAWABLE.getName(); return folder + "/" + name + ".xml"; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } catch (Exception e) { // Some implementations seem to return null on failure, // others throw an exception. We want to return null. 
<|del|> 
<|del|> 
 Collection<NativeToolchain> getNativeToolchains(); 
 * * A native library "libfoo.so" would have the name of "foo". * 
 boolean isFrameworkStyle = qualifiedStyleName.startsWith(SdkConstants.ANDROID_STYLE_RESOURCE_PREFIX); if (isFrameworkStyle) { qualifiedStyleName = qualifiedStyleName.substring(SdkConstants.ANDROID_STYLE_RESOURCE_PREFIX.length()); 
 StyleResourceValue style = configuration.getResourceResolver().getStyle(qualifiedStyleName, isFrameworkStyle); 
 public static boolean isProjectStyleResource(@NotNull StyleResourceValue style, @NotNull Module module) { 
 // Classes probably have changed so reload the custom components and support library classes. myPreviewPanel.reloadComponents(); myPreviewPanel.revalidate(); myPreviewPanel.repaint(); 
 * Changes the parent of the themes in all the xml files 
 mySubStyleName = parent.getQualifiedName(); 
<|del|> 
<|del|> 
 LOG.error("ResourceResolver is null"); 
 // Create all the PNG files and duplicate the XML into folders with the version qualifier. 
@Transform(add = {KeepMarker.class, PartialTypeHierarchy.class}) 
@Constraint(need = {KeepMarker.class, PartialTypeHierarchy.class}) 
 + Jack.getUserFriendlyFormatter().getName(shrinkedMethod) + "' from '" + Jack.getUserFriendlyFormatter().getName(shrinkedMethod.getEnclosingType()) + "'"; 
 + Jack.getUserFriendlyFormatter().getName(shrinkedMethod) + "' from '" + Jack.getUserFriendlyFormatter().getName(shrinkedMethod.getEnclosingType()) + "'"; 
 ShrinkingException reportable = new ShrinkingException( new UnknownReferencedTypeException(pth.getUnknownType(), method)); Jack.getSession().getReporter().report(Severity.FATAL, reportable); throw new JackAbortException(reportable); 
 ShrinkingException reportable = new ShrinkingException( new UnknownReferencedTypeException(pth.getUnknownType(), method)); Jack.getSession().getReporter().report(Severity.FATAL, reportable); throw new JackAbortException(reportable); 
 ShrinkingException reportable = new ShrinkingException( new UnknownReferencedTypeException(pth.getUnknownType(), method)); Jack.getSession().getReporter().report(Severity.FATAL, reportable); throw new JackAbortException(reportable); 
 for (VirtualFile file : sdkModificator.getRoots(OrderRootType.SOURCES)) { if (file.equals(virtualFile)) { return; } 
 for (VirtualFile file : sdkModificator.getRoots(OrderRootType.SOURCES)) { if (file.equals(virtualFile)) { return; } 
 /** * End visit of a {@link JAnnotation}. 
 this(/* needLoading =*/ true); 
 private static BufferedImage getSvgImage(@NotNull String path) throws IOException { String xmlFileContent = generateVectorXml(new File(path)); BufferedImage image = VdPreview.getPreviewFromVectorXml(SVG_PREVIEW_WIDTH, xmlFileContent); 
<|del|> 
 File file = new File(targetResDir, SdkConstants.FD_RES_DRAWABLE + File.separator + xmlFileName + SdkConstants.DOT_XML); 
 private static String generateVectorXml(@NotNull File inputSvgFile) { 
public class VectorAssetSetStep extends CommonAssetSetStep { 
 private JRadioButton myLocalSvgFilesRadioButton; private JRadioButton myGoogleSvgIconRepositoryRadioButton; 
 if (s.charAt(0) == 'z' || s.charAt(0) == 'Z') { 
 return "Shrinking: force to keep members of '" 
 requested.add(PkgDesc.Builder.newSource(platform.getApiVersion(), new MajorRevision(FullRevision.NOT_SPECIFIED)).create()); 
<|del|> 
 * Reload SDK information and update the source root of the SDK. 
 * Reload SDK information and update the source root of the SDK. 
 panel.setText("Sources for '" + jdkOrderEntry.getJdkName() + "' not found."); 
<|del|> 
 File path = new File(toSystemDependentName(sdkPath)); 
 } retainInstalledPackages(packagesToDelete); 
 filterNonExistentPackages(packagesToDelete); 
<|del|> 
<|del|> 
<|del|> 
 String sdkHome = sdk.getHomePath(); if (sdkHome == null) { 
 } EditorNotificationPanel panel = new EditorNotificationPanel(); 
 updateSdkSourceRoot(sdk); 
 updateSdkSourceRoot(sdk); 
 if (isAndroidSdk(jdkOrderEntry.getJdk())) { return jdkOrderEntry; 
<|del|> 
 ScriptC_double s_double = new ScriptC_double(mRS); 
 builder.addKernel(s_double.getKernelID_doubleKernel(), connectType, 
<|del|> 
 public void refreshSources() { 
 if (notify) { 
 * IDE mode. Errors should not be breaking and should generate a SyncIssue instead. 
<|del|>
<|del|>
 int size = 1024 * 1024; 
 Collection<NativeLibrary> getNativeLibraries(); 
<|del|> 
 String getToolchainName(); 
 // CHECK: name "B3" // CHECK-NOT: end_block 
 if (y) { live1 = e; 
 myDominatorPanel = new JPanel(new BorderLayout()); myDominatorPanel.setBorder(new EmptyBorder(0, 2, 0, 0)); 
 else if (isCacheMissingModels(moduleDataNode, module)) { return true; 
 "App Indexing for Google search.", 
 "App Indexing for Google search.", 
 "App Indexing for Google search.", 
 "App Indexing for Google search.", 
 "Ensures the app can correctly handle deep links and integrate with " + 
 "Ensures the app can correctly handle deep links and integrate with " + 
 .addMoreInfo("https://g.co/AppIndexing"); 
 // If this activity is an action view, is browsable, but has neither a // URL nor mimeType, it may be a mistake and we will report warning. 
 // If this activity is an action view, is browsable, but has neither a // URL nor mimeType, it may be a mistake and we will report warning. 
 context.report(ISSUE_ERROR, e, context.getLocation(e), "URL should be set for the intent filter"); 
 context.report(ISSUE_ERROR, e, context.getLocation(e), "URL should be set for the intent filter"); 
 "Activity supporting ACTION_VIEW is not set as BROWSABLE"); 
 // If this activity is an ACTION_VIEW action with category BROWSABLE, but doesn't // have data node, it may be a mistake and we will report error. 
 context.report(ISSUE_ERROR, intent, context.getLocation(intent), 
 context.report(ISSUE_ERROR, intent, context.getLocation(intent), 
 // path, pathPrefix and pathPattern should starts with /. 
 attr.getName() + " cannot be empty"); 
 "Missing URL for the intent filter?"); 
 } // Newly installed system apps that have a launcher icon are uninstalled unless they are in // the required apps lists. 
 private void removeNonInstalledPackages(Set<String> packages) { 
 public CloudDebuggingTargetChooser(@NotNull String cloudDeviceSerialNumber) { myCloudDeviceSerialNumber = cloudDeviceSerialNumber; 
 public CloudDebuggingTargetChooser(@NotNull String cloudDeviceSerialNumber) { myCloudDeviceSerialNumber = cloudDeviceSerialNumber; 
 public ColumnTreeBuilder setTreeSorter(@NotNull TreeSorter sorter) { 
<|del|> 
 * Find latest build tools revision. Versions compatible with the selected platforms will be installed by the platform components. * @return The FullRevision of the latest build tools package, or null if no remote build tools packages are available. 
 // If we don't have anything to install, show as unchecked and not editable. 
 return WireFormatNano.EMPTY_BYTES; 
 private static boolean hasActionView(Element intent) { NodeList children = intent.getChildNodes(); for (int j = 0; j < children.getLength(); j++) { Node child = children.item(j); 
 // URL nor mimeType, it may be a mistake and we will report error. 
 "Missing URL for the intent filter?"); 
 // Each part of the URL should not have illegal character. 
 for (int i = 0; i < children.getLength(); i++) { Node child = children.item(i); 
 for (int i = 0; i < children.getLength(); i++) { Node child = children.item(i); 
<|del|> 
 return Arrays.asList(new PackageLevel("", Level.SEVERE)); 
 return Arrays.asList(new PackageLevel("", Level.FINE), new PackageLevel("com.android.sched", Level.WARNING)); 
 private static class NamedParser extends KXmlParser { 
 @Override public void update(AnActionEvent e) { e.getPresentation().setVisible( "true".equals(System.getProperty("testvectorassetstudio")) && isAvailable(e.getDataContext())); // from superclass } 
 return getIconFolder(options) + '/' + getIconName(options, name); 
 } else { assert actionBarOptions.theme == Theme.HOLO_DARK; 
 } else if (SVG_HEIGHT.equals(name)) { 
 String attr = "\n " + vectorDrawableAttr + "=\"#00000000\""; sb.insert(0, attr); 
 @Override 
//import com.glavsoft.viewer.Viewer; 
 private final Map<String, XBreakpoint> myIdeBreakpoints = new ConcurrentHashMap<String, XBreakpoint>(); 
 public void registerBreakpoint(@NotNull XLineBreakpoint<CloudLineBreakpointProperties> xIdeBreakpoint) { if (xIdeBreakpoint.getSourcePosition() == null || !xIdeBreakpoint.isEnabled() || !(xIdeBreakpoint.getType() instanceof CloudLineBreakpointType)) { 
 com.intellij.debugger.ui.breakpoints.Breakpoint cloudIdeBreakpoint = BreakpointManager.getJavaBreakpoint(xIdeBreakpoint); if (!(cloudIdeBreakpoint instanceof CloudLineBreakpointType.CloudLineBreakpoint)) { 
 public void registerBreakpoint(@NotNull XLineBreakpoint<CloudLineBreakpointProperties> xIdeBreakpoint) { if (xIdeBreakpoint.getSourcePosition() == null || !xIdeBreakpoint.isEnabled() || !(xIdeBreakpoint.getType() instanceof CloudLineBreakpointType)) { 
 com.intellij.debugger.ui.breakpoints.Breakpoint cloudIdeBreakpoint = BreakpointManager.getJavaBreakpoint(xIdeBreakpoint); if (!(cloudIdeBreakpoint instanceof CloudLineBreakpointType.CloudLineBreakpoint)) { 
 cloudIdeLineBreakpoint.setVerified(true); cloudIdeLineBreakpoint.setErrorMessage(null); 
 public void unregisterBreakpoint(@NotNull XLineBreakpoint<CloudLineBreakpointProperties> xIdeBreakpoint, boolean temporary) { 
 for (final Breakpoint serverBreakpoint : serverBreakpoints) { if (serverBreakpoint.getIsFinalState() == Boolean.TRUE || myIdeBreakpoints.containsKey(serverBreakpoint.getId())) { 
 if (existingXIdeBreakpoint != null) { 
 if (state instanceof CloudDebugProcessState) { 
 this.toRemove = toRemove; 
 // URL nor mimeType, it may be a mistake and we will report error. 
 if (Binder.getCallingUid() != Process.SYSTEM_UID) { throw new SecurityException("Only SYSTEM_UID can create user directories"); } 
 if (Binder.getCallingUid() != Process.SYSTEM_UID) { throw new SecurityException("Only SYSTEM_UID can create user directories"); } 
 * Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 assert firstStatement != null; 
 assert !seenNonMarkedType; 
 private static HashMap<String, Integer> sortingMap; 
 myProperties.setProperty(JVM_ARGS_PROPERTY_NAME, jvmArgs); 
<|del|> 
 // Only the 5 lower bits should be used for shifting (& 0x1f). 
 // Exercise some special cases handled by backends/simplifier. 
 // Exercise some special cases handled by backends/simplifier. 
<|del|> 
 @Nonnull private static File compileProcessorsToDir(@Nonnull File outputDir) throws ExecFileException { 
 "Failed to open log file(s) for pattern '" + logFilePattern + "'"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // Check that we received all expected events. 
 assert !seenNonMarkedType; 
 assert !seenNonMarkedType; 
<|del|> 
<|del|> 
 synchronized (this) { if (thrown != null) { throw thrown; } 
 assert !finished; 
 mergeAnnotations(dexToMerge, classDefToMerge, newClassDef, cstIndexMap); 
 public void setValue(@NotNull final String attribute, @NotNull final String value) { 
 null /*testedProjectPath*/); 
 taskManager.resolveDependencies( variantDep, null /*testedVariantDeps*/, testedProjectPath); 
 // CHECK-DAG: [[Convert:i\d+]] TypeConversion [[Const33]] // CHECK-DAG: Return [ [[Convert]] ] 
<|del|> 
 // This method is used in the layout editor to support the multi-preview. The theme editor doesn't support it. throw new UnsupportedOperationException("Configuration can not be changed on AndroidThemePreviewPanel"); 
 return LocalQuickFix.EMPTY_ARRAY; 
 public List<String> getEnabledExternalUpdateSources() { return myState.enabledExternalComponentSources; } 
 if ("myDeprecated".equals(item.getName())) { 
<|del|> 
 public static boolean canEnable() { CloudConfigurationProvider provider = getExtension(); 
 public static boolean canEnable() { CloudConfigurationProvider provider = getExtension(); 
 * Returns whether this provider can currently be enabled. * This could, for example, query the cloud to determine this result. 
 return getExtension(); 
<|del|> 
 public static void setupClass() { 
 private static void addFilesToZip(ZipOutputStream zip, File file, String entryPath) throws IOException { 
 // CHECK-DAG: [[ConstMax:f\d+]] FloatConstant 1e+34 
 // CHECK-DAG: [[ConstMax:i\d+]] IntConstant 2147483647 
 double imm = Double.NaN; 
 double imm = -Double.NaN; 
 long imm = 34L; 
 long imm = 34L; 
 public boolean checkAccepted(@Nullable File sdkRoot) { if (sdkRoot == null) { return false; } 
<|del|> 
 .getResourceSets(generatedResFolders, includeDependencies); 
 .getResourceSets(generatedResFolders, includeDependencies); 
 * Returns a set of {@link UpdatablePackageInfos} representing all known local and remote packages. Remote packages corresponding * to local packages will be represented by a single item containing both the local and remote info. * @return 
 * @param indicator A {@code ProgressIndicator} that can be updated to show progress, or can be used to cancel the process. 
 packageHtmlBuilder.listItem().add(desc.getListDescription()); 
 private long computeDownloadSize(List<IPkgDesc> packages) { 
 * * @param indicator A {@link ProgressIndicator} that can be updated to show progress, or can be used to cancel the process. * @param updateSettings The current UpdateSettings 
 Collection<UpdatableExternalComponent> getAvailableVersions(@Nullable ProgressIndicator indicator, @Nullable UpdateSettings updateSettings); 
 ArrayList<Instance> instances = mInstances.get(heapId); if (instances == null) { instances = new ArrayList<Instance>(); mInstances.put(heapId, instances); 
 } else if (!apiTarget.isPlatform()) { 
 } 
<|del|> 
<|del|> 
 Element build(@NotNull Document document) { 
 @Override @NotNull 
 myValidator = ResourceNameValidator.create(false, AppResourceRepository.getAppResources(module, true), ResourceType.COLOR); 
<|del|> 
 "Failed to open log file(s)"); 
 Set<String> packagesToRetain = getCurrentAppsWithLauncher(); packagesToRetain.addAll(getDisallowedApps()); packagesToDelete.retainAll(packagesToRetain); 
 public LayoutComponent(@NonNull ValuedTreeNode data) { 
 public void insert(@NotNull AllocationInfo alloc) { 
 myAlarm = new Alarm(project); 
<|del|> 
 @SuppressWarnings("MethodMayBeStatic") 
 synchronize(true); 
 synchronize(true); 
 synchronize(true); 
 .addDefaultValue(false); 
 return String.format("...<more instances (%d of %d remaining)>...", myTotal - myStartIndex, myTotal); 
 public @interface IncludeTestGroups { 
 private Timer myWatchTimer = null; 
 private Timer myWatchTimer = null; 
<|del|> 
 DateFormat df = new SimpleDateFormat("hh:mm:ssa MM/dd"); 
 private ProjectRepositoryState myProjectRepositoryState; 
 LOG.warn("Error connecting to Cloud Debugger API", ex); 
<|del|> 
 SetBreakpointResponse addResponse = myCloudDebuggerClient.debuggees().breakpoints().set(getDebuggeeId(), serverBreakpoint).execute(); 
 private static final int COLUMN_MARGIN_PX = 1; private static final int WINDOW_WIDTH = 200; private static final int WINDOW_HEIGHT = 8 * JBTable.PREFERRED_SCROLLABLE_VIEWPORT_HEIGHT_IN_ROWS; 
 private static final DateFormat ourDateFormat = new SimpleDateFormat("hh:mm:ssa MM/dd"); private static final DateFormat ourDateFormatToday = new SimpleDateFormat("hh:mm:ssa"); 
 private static final DateFormat ourDateFormat = new SimpleDateFormat("hh:mm:ssa MM/dd"); private static final DateFormat ourDateFormatToday = new SimpleDateFormat("hh:mm:ssa"); 
 private static final int CONNECTION_TIMEOUT = 120 * 1000; 
 @Nullable String userEmail, 
import com.android.tools.idea.tests.gui.framework.IdeGuiTest; 
 Sdk workingSdk = findSuitableAndroidSdk("android-21"); 
 updateSdkSourceRoot(workingSdk); 
<|del|> 
 DialogFixture downloadDialog = findDialog(withTitle("SDK Quickfix Installation")) 
 DialogFixture downloadDialog = findDialog(withTitle("SDK Quickfix Installation")) 
 clearLocalPkgInfo(workingSdk); 
 AndroidSdkAdditionalData data = getAndroidSdkAdditionalData(sdk); 
 VersionQualifier qualifier = new VersionQualifier(apiLevel); config.setVersionQualifier(qualifier); 
 public void testNonFrameworkAttribute() { doTestForAttributeApi("myAttribute", "apiTestAfter1"); 
 * Sets ProGuard configuration files. 
 * Sets the JarJar configuration files to use for repackaging. * @param jarjarConfigFiles The JarJar configuration files 
 * Sets a ProGuard configuration files. * @param proguardConfigFiles The ProGuard configuration files 
 private static final long serialVersionUID = 1L; 
 private static final long serialVersionUID = 1L; 
 return "Package renaming with " + ruleFileLocation.getDescription() + ": " 
 * by {@link #getOutputSizeForUpdate(int)}. The return value must be the * number of bytes processed and placed into {@code output}. On error, an * exception must be thrown. 
 private final EVP_CIPHER_CTX cipherCtx = new EVP_CIPHER_CTX( NativeCrypto.EVP_CIPHER_CTX_new()); 
 if (mode != Mode.CBC) { throw new NoSuchAlgorithmException("Unsupported mode " + mode.toString()); 
<|del|> 
 // TODO: find out who uses this 
 if ("default".equals(heap.getName()) && heap.getClasses().isEmpty() && heap.getInstances().isEmpty()) { 
 public int getTypeId() { return mId; } 
 final String[] subtags = normalizedValue.split("-"); final char normalizedKey = Character.toLowerCase(key); 
import javax.swing.JPopupMenu; 
 add(scrollPanel); 
 handlePlatformJar(classPath, platform, (JavaArtifact) testArtifact); 
 /*instance =*/ null, methodCall.getReceiverType(), idReplacement, methodCall.getType(), /*isVirtualDispatch =*/ false); 
<|del|> 
<|del|> 
 * Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 * Copyright (C) 2015 The Android Open Source Project 
 @Nonnull public static final NeedsRethising INSTANCE = new NeedsRethising(); private NeedsRethising() { } 
 return this; 
 * Copyright (C) 2015 The Android Open Source Project 
 oldId.getParamTypes(), MethodKind.STATIC); if (oldId.getKind() == MethodKind.STATIC) { 
<|del|> 
 @BelongsToTestGroups({PROJECT_SUPPORT}) 
<|del|> 
 for (VirtualFile f : mySdk.getRootProvider().getFiles(OrderRootType.CLASSES)) { if (f.getUrl().startsWith(SdkConstants.EXT_JAR)) { 
 if (otherToolchain == Toolchain.GCC) { 
<|del|> 
 assertDesiredMinimum(new Point(w, h), min); 
 assertDesiredMinimum(new Point(min.x / 2, h), min); 
 assertDesiredMinimum(new Point(w, min.y / 2), min); 
 private void assertDesiredMinimum(Point suggestedSize, Point minSize) { 
 if (!flagAdded) { wait(expected ? 0 : WAIT_TIMEOUT); 
<|del|> 
 * Task provider that creates task to sync and build App Engine Gradle projects before they're run. 
 return false; 
<|del|> 
 public ApkInstallation(@NotNull String path, @NotNull String applicationId) { 
 myApplicationId = applicationId; 
 throw new InvalidAlgorithmParameterException("EC_GROUP_new_arbitrary returned NULL"); 
 throw new InvalidAlgorithmParameterException("EC_GROUP_new_arbitrary returned NULL"); 
 * Utility methods for SDK paths. 
 @NotNull protected Class<?> defineClassAndPackage(@Nullable String name, @NotNull byte[] b, int offset, int len) { 
<|del|> 
 * 
 AnAction compileDirty = ActionManager.getInstance().getAction(COMPILE_DIRTY_ACTION_ID); 
 /* @hide 
 public static Abi getByName(@NonNull String name) { 
 public static Toolchain getByName(@NonNull String toolchainName) { 
 getTree().logErrorLine("Unsupported URL value: " + value, getDocumentNode(), 
 // Keep a reference to the tree in order to dump the error log. 
<|del|> 
 for (String log: mErrorLines) { 
<|del|> 
 vdErrorLog.append("Exception while parsing XML file:\n" + e.getMessage()); 
 if (expected == null && actual == null) { return; 
 fail(message, "expected " + expected + " but was " + actual + "; delta=" + delta); 
 fail(message, "expected " + expected + " but was " + actual + "; delta=" + delta); 
 fail(message, "expected " + expected + " but was " + actual + "; delta=" + delta); 
// See NOTICE file in junit project. 
 import android.support.annotation.Nullable; 
 */ @Deprecated 
 onView(withId(drawerLayoutId)).perform(open(gravity)); 
import android.support.test.espresso.matcher.BoundedMatcher; 
<|del|> 
<|del|> 
 for (Instance instance : theClass.getHeapInstances(getId())) { 
 public static final Icon CLOUD_DEBUG_SAVE_EXIT = load("/icons/debugsaveexit.png"); public static final Icon CLOUD_DEBUG_REACTIVATE_BREAKPOINT = load("/icons/debugreactivatebreakpoint.png"); public static final Icon CLOUD_DEBUG_DELETE_ALL_BREAKPOINTS = load("/icons/debugdeleteall.png"); 
 * xIdeBreakpoint : these are {@link XBreakpoint} types that intelliJ defines and are sealed. * cloudIdeBreakpoint: these are our IDE defined customized breakpoints 
 // The local IDE project that contains the source code running in the debuggee. 
 public static String getCloudPathFromJavaFile(PsiJavaFile javaFile) { return javaFile.getPackageName().replace('.', '/') + "/" + javaFile.getName(); } 
<|del|> 
<|del|> 
<|del|>
 Messages.showErrorDialog( project, String.format("Infer Nullity Annotations requires the project sdk level be set to %1$d or greater.", MIN_SDK_WITH_NULLABLE), "Infer Nullity Annotations"); 
<|del|> 
 public static final String TAG_MANIFEST = "manifest"; //$NON-NLS-1$ 
 HeapData heapData = mHeapData.get(heapId); if (heapData == null) { heapData = new HeapData(); mHeapData.put(heapId, heapData); } heapData.mInstances.add(instance); heapData.mShallowSize += instance.getSize(); 
 * Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 List<File> getJarJarRuleFiles(); 
 flavor.setJarJarRuleFiles(ImmutableList.<File>builder() .addAll(overlay.getJarJarRuleFiles()) 
<|del|> 
 ActionToolbarImpl toolbar = findComponentOfType(myContent.getComponent(), ActionToolbarImpl.class); 
@BelongsToTestGroups({TestGroup.UNIT_TESTING, TestGroup.PROJECT_SUPPORT}) 
 public void unitTestingSupport() throws IOException { 
 PROCESS_JAVA_RESOURCES, 
<|del|> 
 client.debuggees().breakpoints().list(state.getDebuggeeId()).setIncludeInactive(Boolean.TRUE).setAction("CAPTURE") .setStripResults(Boolean.TRUE).setWaitToken(tokenToSend).execute(); 
 assertFalse("/dev/socket/fota", new File("/dev/socket/fota").exists()); 
<|del|> 
 return GctBundle.getString("sample.import.progress.title"); 
<|del|> 
<|del|> 
<|del|> 
 } 
 /** * NB: All tests not annotated with @MediumTest will be ignored as the InstrumentationTestRunner * is passed the custom argument of "size medium". */ 
 * <p/> 
public abstract class TypedCellEditor<I, O> extends AbstractTableCellEditor { public abstract Component getEditorComponent(JTable table, I value, boolean isSelected, int row, int column); public abstract O getEditorValue(); 
 private static final TvContentRating US_TV_PG_DL = TvContentRating.createRating( "com.android.tv", "US_TV", "US_TV_PG", "US_TV_D", "US_TV_L"); 
 }); getInstrumentation().waitForIdleSync(); 
 if (ProjectBuilder.getInstance(myProject).isSourceGenerationEnabled()) { 
 if (args.length > 0 && args[args.length - 1].equals("--secondary")) { 
 // Read /proc/self/cmdline to find the invocation command line (so we can fork another runtime). 
 Log.w(TAG, "Bad URI " + url + ": " + ex.getMessage()); Toast.makeText(HTMLViewerActivity.this, R.string.cannot_open_link, Toast.LENGTH_SHORT).show(); 
 Toast.makeText(HTMLViewerActivity.this, R.string.cannot_open_link, Toast.LENGTH_SHORT).show(); 
 Toast.makeText(HTMLViewerActivity.this, R.string.cannot_open_link, Toast.LENGTH_SHORT).show(); 
 mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "com/android/ide/common/rendering/api/LayoutLog", "error", errorMethodDescription, false); 
 private String mySuperName; 
 mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, myClassName, name + ORIGINAL_SUFFIX, desc, false); 
 if (REPLACED_VIEW_METHODS.contains(name+desc)) { MethodVisitor originalMethod = super.visitMethod(access, name + "_Original", desc, signature, exceptions); 
 if (REPLACED_VIEW_METHODS.contains(name+desc)) { MethodVisitor originalMethod = super.visitMethod(access, name + "_Original", desc, signature, exceptions); 
 if (ThemeEditorProvider.THEME_EDITOR_ENABLE) { result.add(getClass().getClassLoader().getResource("androidWidgets/studio-android-widgets.jar")); } 
 mw.visitMethodInsn(Opcodes.INVOKEVIRTUAL, myClassName, name + ORIGINAL_SUFFIX, desc, false); 
<|del|> 
 List genres = Arrays.asList(Genres.decode(ENCODED_GENRE_STRING)); assertEquals(11, genres.size()); 
 private static final TvContentRating RATING_DUMMY = TvContentRating.createRating( 
 private static final TvContentRating DUMMY_RATING = TvContentRating.createRating( 
 try { mManager.isParentalControlsEnabled(); } catch (Exception e) { fail(); } 
 try { mManager.registerCallback(mCallabck, new Handler()); mManager.unregisterCallback(mCallabck); } catch (Exception e) { fail(); } 
 return session != null && session.mKeyMultipleCount > 0; 
 public void verifyCommandDispatchKeyDown() { resetCounts(); 
 mTvView.dispatchGenericMotionEvent(event); 
<|del|> 
 public boolean setAll(@NotNull Collection<? extends E> c) { 
<|del|>
 private ObservableList myList; private ListBinding myBinding; 
 myList = list; myBinding = binding; 
 return srcElement.toUpperCase(Locale.US); 
 public SizeExpression(@NotNull ObservableList<?> list) { 
 expectNotThrows(t, "TestSub.foo"); 
<|del|> 
 public Class<?> findClass(@NonNull String name) throws ClassNotFoundException { 
 public Class<?> loadClass(@NotNull String className) throws InconvertibleClassError { 
 final Bundle bundle = new Bundle(); final TvTrackInfo info = new TvTrackInfo.Builder(TvTrackInfo.TYPE_AUDIO, "id_audio") 
 if (!(parent instanceof JExpression || parent instanceof JThrowStatement || parent instanceof JNameValuePair || parent instanceof JReturnStatement || parent instanceof JFieldInitializer)) { 
 "jack.android.remove-typedef", "Removes @StringDef, @IntDef and all annotations annotated with them") .addDefaultValue(false); 
 * A {@link Feature} allowing to remove @StringDef, @IntDef and all annotations annotated with * them. 
 return "Annotation @" + Jack.getUserFriendlyFormatter().getName(typeDef) 
 @Input 
 private static StringBuffer getPathFromDirInternal(@Nonnull CachedParentVDir baseDir, 
 checkZipLocations(ioVFS2); 
 private final String prefix; 
 private final String suffix; 
 private final String suffix; 
 PROCESS_JAVA_RESOURCES, 
 * Tests about '!' simplifier optimization using comparison with bounds values or not of types. 
 // CHECK: InstanceOf must_do_null_check:0 
 Preconditions.checkState(testedVariantData != null, "Internal error: tested variant must be created before test variant."); 
 final NativeLibrarySpec library = specs.create( ndkConfig.getModuleName(), NativeLibrarySpec.class); 
 return binary.getBuildType().getName().equals(buildType.getName()) && (binary.getFlavor().getName().equals(flavorGroup.getName()) || (productFlavors.isEmpty() && binary.getFlavor().getName().equals("default"))); 
 return binary.getBuildType().getName().equals(buildType.getName()) && (binary.getFlavor().getName().equals(flavorGroup.getName()) || (productFlavors.isEmpty() && binary.getFlavor().getName().equals("default"))); 
 || config.getNdkConfig().getAbiFilters().isEmpty() || config.getNdkConfig().getAbiFilters().contains( binary.getTargetPlatform().getName()))); 
<|del|> 
 return (ndkHandler.getToolchain().equals(Toolchain.GCC) ? new GccNativeToolSpecification(buildType, platform) 
 * of a {@link CloudExecutionStack}. * <p/> 
 return Module.EMPTY_ARRAY; 
 "Permission Denial: Accessing service " + r.record.name 
 private Map<Pair<Toolchain, Abi>, PreciseRevision> defaultToolchainVersions = Maps.newHashMap(); 
 PreciseRevision defaultVersion = defaultToolchainVersions.get(Pair.of(toolchain, abi)); 
 private static class StubConnectionCallback extends MediaBrowser.ConnectionCallback { 
 volatile int mConnectionSuspendedCount; 
 private static final BreakpointComparer DEFAULT_INSTANCE = new BreakpointComparer(); 
<|del|> 
 private static final int NODES_PER_EXPANSION = 100; 
 @Nullable private Comparator<DebuggerTreeNodeImpl> myComparator; @NotNull private SortOrder mySortOrder = SortOrder.UNSORTED; 
 @Nullable private Comparator<DebuggerTreeNodeImpl> myComparator; @NotNull private SortOrder mySortOrder = SortOrder.UNSORTED; 
 sortTree(debuggerTreeNode); 
 sortTree(parentNode); 
 ArrayList<DebuggerTreeNodeImpl> builtChildren = Collections.list(e); 
 new PollingCheck(TIME_OUT_MS) { 
 int size = mKeyguardStateCallbacks.size(); boolean simPinSecure = mUpdateMonitor.isSimPinSecure(); for (int i = size - 1; i >= 0; i--) { try { 
<|del|> 
 private byte[] asRawByteArray(int elementCount) { 
 char[] stringChars = charBufferArray.asCharArray(MAX_VALUE_TEXT_LENGTH); 
 private void add(PathId id, String... leaves) { StringBuilder sb = new StringBuilder(256); for (String leaf : leaves) { 
 private void add(PathId id, String... leaves) { StringBuilder sb = new StringBuilder(256); for (String leaf : leaves) { 
 private void add(PathId id, String... leaves) { StringBuilder sb = new StringBuilder(256); for (String leaf : leaves) { 
 File binFolder = new File(buildToolDir, "bin"); if (!binFolder.isDirectory()) { 
<|del|> 
 public boolean accept(@NotNull VirtualFile file) { 
<|del|> 
 public boolean accept(@NotNull VirtualFile file) { 
 ExtensionPointName<CaptureType> EP_NAME = ExtensionPointName.create("com.android.captureType"); 
 private HyperlinkLabel myMoreErrors; private MoreErrorHyperlinkAdapter myMoreErrorHyperlinkAdapter = new MoreErrorHyperlinkAdapter(); 
 for (String log : mErrorLines) { 
 serializer.startDocument("utf-8", true); 
 * @param serverBreakpoint The server breakpoint representation * @return the local IDE representation in x-breakpoint form 
 private static final Logger LOG = Logger.getInstance(CloudDebugGlobalPoller.class); 
 myXBreakpointHandlers = new XBreakpointHandler<?>[]{new CloudBreakpointHandler(this)}; 
 ListenableFuture<Breakpoint> future = getStateController().resolveBreakpoint(id); 
 DateFormat df = new SimpleDateFormat(GctBundle.getString("cloud.debug.datetimeformat")); 
 DateFormat df = new SimpleDateFormat(GctBundle.getString("cloud.debug.datetimeformat")); 
 public void setCurrentServerBreakpointList(ImmutableList<Breakpoint> newBreakpointList) { 
 throw new IllegalStateException(); 
 throw new IllegalStateException(); 
 future.set(resultingBreakpointRef.get()); 
 if (myState == null) { LOG.error("no state available attempting to checkForChanges"); 
 * Compares the current source tree with the state described by the Cloud Debugger api. 
 return new SyncResult(/*isinvalid*/true, /*needsstash*/ false, /*needssync*/ false, /*isdeterminable*/ true, /*target SHA*/ null, /*target repo*/ null); 
 return new SyncResult(/*isinvalid*/true, /*needsstash*/ false, /*needssync*/ false, /*isdeterminable*/ true, /*target SHA*/ null, /*target repo*/ null); 
 LOG.warn("Error detecting server side source context", ex); 
 if (!Strings.isNullOrEmpty(targetLocalRepo.getCurrentRevision()) && !Strings.isNullOrEmpty(cloudRepo.getRevisionId()) && 
 final GitLineHandler handler = new GitLineHandler(project, root, GitCommand.STASH); handler.addParameters("apply"); handler.addParameters("--index"); addStashParameter(project, handler, targetStash.get().getStash()); 
 String date = new SimpleDateFormat(GctBundle.getString("clouddebug.stashdateformat")) .format(new Date()); 
 int selection = -1; 
 new LoggerWrapper(getLogger())), testData)); 
 testConnectedCheck.configure(tasks, new Action<Task>() { 
 " using provider: " + StringHelper.capitalize(deviceProvider.getName())); 
<|del|> 
 ConventionMappingHelper.map(task, "adbExec", new Callable<File>() { @Override public File call() { 
 File rootDirPath = new File(homeDirPath, join("androidStudio", "gui-tests")); 
 myScreenshotTaker.saveDesktopAsPng(screenshotFilePath.getPath()); System.out.println("Screenshot of failed test taken and stored at " + screenshotFilePath.getPath()); 
 StringBuilder builder = new StringBuilder(6 + charLength); builder.append(" \""); if (charLength == MAX_VALUE_TEXT_LENGTH) { builder.append(stringChars, 0, charLength - 1).append("..."); 
 fastForward(); 
 rewind(); 
 next(); 
 previous(); 
 static class Adjuster extends JVisitor { 
<|del|> 
 public NeedsDispatchAdjustment(@Nonnull JMethodId replacementId, boolean needsThis) { 
 * Copyright (C) 2015 The Android Open Source Project 
 remove = {ThreeAddressCodeForm.class, NewInstanceRemoved.class}) 
<|del|> 
 vfs = new CaseInsensitiveFS(directFS, /* nbGroup = */ 2, /* szGroup = */ 2, new MessageDigestFactory(service), /* debug = */ false); 
 * Copyright (C) 2015 The Android Open Source Project 
 return new CaseInsensitiveFS(codec.checkString(context, string), /* nbGroup = */ 2, /* szGroup = */ 2, new MessageDigestFactory(service), /* debug = */ false); 
 * TODO: Most of this should go away. 
 public int getJayceCount() { 
 writeDebugEnd(currentClass, currentLine); 
 * Created by amulyau on 5/26/15. * This is a sample menu item (text boxes) plug in code that will show an input dialog asking for * name and message dialog with a simple hello message. 
 public static int BREAKPOINT_CATCH_LINE = 50; 
<|del|> 
 * method, then verifies that the requested BREAKPOINT event occurs on a catch statement 
 // Execute the breakpoint. 
 assertEquals("Invalid number of events:", 1, parsedEvents.length); assertEquals("Invalid request ID:", requestID, parsedEvents[0].getRequestID()); 
 // Install breakpoint on the expected line. 
 public static class BreakpointOnCatchDebuggeeException extends Exception { public BreakpointOnCatchDebuggeeException(String detailMessage) { super(detailMessage); } } 
 int recursiveDepth = MAX_AUTO_EXPANSION_DEPTH; 
 sb.append(" <string name=\"").append(entry.getKey()).append("\">") .append(entry.getValue()).append("</string>\n"); 
<|del|> 
 mWaitLock.wait(TIME_OUT_MS); 
 synchronized (mMediaBrowser) { mOnChildrenLoaded = false; 
<|del|> 
 mv.visitMaxs(2, 3); 
 mv.visitMaxs(0, 3); 
 // Callers of this method that format strings and expect them to be parseable by 
 bootClassPathUrlHandlers = createBootClassPathUrlHandlers(); 
 bootClassPathUrlHandlers = createBootClassPathUrlHandlers(); 
 * Copyright (C) 2015 The Android Open Source Project 
 throw new RuntimeException("Invalid entry name", e); 
 /// CHECK-START: void Main.testInstanceFieldGetSimpleRemove() instruction_simplifier_after_types (before) /// CHECK: CheckCast 
 /// CHECK-START: void Main.doTopCall() inliner (before) /// CHECK: InvokeStaticOrDirect dex_file_index:2 
 private static final long WAIT_TIME_FOR_CHECKING_NO_RESPONSE_MS = 500L; 
 public void testDelayedNotifyChildrenChanged() throws Exception { 
 final String id = "test-id"; final String key = "test-key"; final String val = "test-val"; 
 /** * @see FileEditor#selectNotify(). */ public void selectNotify() { reload(myThemeName, mySubStyleName); subscribeResourceNotification(); } 
 /** * @see FileEditor#selectNotify(). */ public void selectNotify() { reload(myThemeName, mySubStyleName); subscribeResourceNotification(); } 
<|del|> 
 * The tag that is used by {@code ReferencedOuterFieldExposer} and * {@code MethodCallDispathAdjuster} to express the need for a separation. 
 tr.append(new AppendMethodParam(method, thisParam)); 
 * A {@code TransformationStep} allowing to add a {@code JExpression} * as the last argument of a {@code JMethodCall} 
 * {@link PackageManager#FEATURE_NFC_HOST_CARD_EMULATION} 
<|del|> 
<|del|> 
<|del|> 
 public int getMaxNumOfRegisterableSystemCodes() { 
 if (systemCode.length() != 4) { Log.e(TAG, "System Code " + systemCode + " is not a valid System Code."); 
 } catch (NumberFormatException e) { Log.e(TAG, "System Code " + systemCode + " is not a valid System Code."); 
 if (nfcid2.length() != 16) { Log.e(TAG, "NFCID2 " + nfcid2 + " is not a valid NFCID2."); 
 } catch (NumberFormatException e) { Log.e(TAG, "NFCID2 " + nfcid2 + " is not a valid NFCID2."); 
<|del|> 
<|del|> 
 if (!FileUtil.isAncestor(javaSourceRoot, javaSourcePackageRoot, false)) { 
 getInstrumentation().waitForIdleSync(); 
 synchronized (mWaitLock) { 
 mWaitLock.wait(TIME_OUT_MS); 
 StubMediaBrowserService.MEDIA_ID_CHILDREN_DELAYED); 
 public void testDelayedNotifyChildrenChanged() throws Exception { 
 StubMediaBrowserService.MEDIA_ID_CHILDREN_DELAYED); 
 assert (mPendingResult == null); 
 + " protected void test1() {\n" 
 KEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT, currentUserId); 
 // We never want to push preview platforms on users if (fullRevision == null || fullRevision.isPreview()) { continue; } if (revision == null || fullRevision.compareTo(revision) > 0) { 
 @NotNull 
 mWaitLock.wait(TIME_OUT_MS); assertTrue(mOnChildrenLoaded); 
 private static final long TIME_OUT_MS = 3000L; 
 static final String MEDIA_ID_CHILDREN_DELAYED = "test_media_id_children_delayed"; 
 } else if (MEDIA_ID_CHILDREN_DELAYED.equals(parentMediaId)) { Assert.assertNull(mPendingResult); 
 mLogger.warning("\n%1$s > %2$s[%3$s] \033[33mSKIPPED \033[0m\n%4$s", test.getClassName(), test.getTestName(), mDeviceName, getModifiedTrace(trace)); 
<|del|> 
 if (value instanceof InstanceNode) { Instance instance = ((InstanceNode)value).getInstance(); if (instance != null) { append(String.valueOf(instance.getSize()), SimpleTextAttributes.REGULAR_ATTRIBUTES); } setTextAlign(SwingConstants.RIGHT); 
 MediaSessionCallback callback = new MediaSessionCallback(waitLock); 
 synchronized (waitLock) { 
 synchronized (waitLock) { 
 waitLock.wait(TIME_OUT_MS); 
 setPassState(mVerifyGlobalSearchItem, result); 
 /* package-private */ static final String CHANNEL_NUMBER = "999-0"; /* package-private */ static final String CHANNEL_NAME = "Dummy"; 
 /* package-private */ static final String PROGRAM_TITLE = "Dummy Program"; /* package-private */ static final String PROGRAM_DESCRIPTION = "Dummy Program Description"; 
 /* package-private */ static final String PROGRAM_TITLE = "Dummy Program"; /* package-private */ static final String PROGRAM_DESCRIPTION = "Dummy Program Description"; 
 * @param context The context object to be used for getting content resolver 
 } finally { provider.release(); 
 Set<String> tvSearchablePackageCandidates = new HashSet<>(); 
 for (SearchableInfo info : SearchUtil.getSearchableInfos(context)) { 
 public Void call() throws Exception { 
 public boolean isAnonymous() { return TypeName.getSimpleName(this).isEmpty(); 
 assert facet != null : String.format("Module %s is not an Android module", module.getName()); 
 public JComboBoxFixture getThemesComboBox() { 
import javax.crypto.spec.PBEParameterSpec; import javax.crypto.spec.PSource; 
 if (!keySupported) { throw new InvalidKeyException("No provider supports the provided key"); 
<|del|> 
 public static long $noinline$FloatConvert(boolean flag) { 
 public static long $noinline$DoubleConvert(boolean flag) { 
 * cannot be used to predict how many bytes can be read from * {@link #getInputStream()} for compressed streams. Instead, read that stream * until it is exhausted, i.e. when {@link InputStream#read} returns -1. 
 public static double ceil(double d) { 
 public static double ceil(double d) { 
 int j = lowBits + (0x1 << (0x34 - exp)); // careful, should be unsigned 
 private int myWidth; private int myHeaderAlignment; 
 * Copyright (C) 2015 The Android Open Source Project 
 // test adjustVolume mCallback.reset(); 
 synchronized (mWaitLock) { mCallback.reset(); 
<|del|> 
 throw new IllegalStateException("InvalidKeyException thrown when key == null", e); 
 throw new IllegalStateException("InvalidKeyException thrown when key == null", e); 
 boolean keySupported = false; 
 throw new IllegalStateException("InvalidKeyException thrown when key == null", e); 
<|del|> 
 output.println("--language-level <level> : Java source language level, typically 1.6 (default) or 1.7"); 
 if (inputDev.supportsSource(inputSource)) { 
 DEFAULT_META_STATE, DEFAULT_PRECISION_X, DEFAULT_PRECISION_Y, getInputDeviceId(inputSource), DEFAULT_EDGE_FLAGS); 
 return url == null ? item.getRawXmlValue() : url.toString(); 
 private static final long WAIT_TIME_FOR_NO_RESPONSE_MS = 500L; 
<|del|> 
 /** * Add to the list of objects that references this Instance. * * @param reference another instance that references this instance */ public void addReference(@NonNull Instance reference) { if (reference.getIsSoftReference()) { 
 mSnapshot = new SnapshotBuilder(10, 2) 
<|del|> 
 mCallback.reset(); 
 lowBits = j; 
 int j = (int)(lowBits + (1 << (0x34 - exp))); 
<|del|> 
 private final JSession session; 
import javax.swing.JTable; import javax.swing.SwingUtilities; import java.awt.Color; import java.awt.Component; 
 // Restore the old value in the properties model 
<|del|> 
 ResourcesCompletionProvider completionProvider = new ResourcesCompletionProvider(myThemeEditorContext); myGoToListener = new GoToListener() { 
import com.intellij.openapi.application.ApplicationManager; import com.intellij.openapi.application.ModalityState; 
<|del|> 
 Set<String> tvPackages = new HashSet<>(); 
 for (SearchableInfo info : globalSearchableInfos) { if (tvPackages.contains(info.getSearchActivity().getPackageName())) { 
interface ComponentVersionReader { ComponentVersionReader GRADLE = new GradleVersionReader(); ComponentVersionReader ANDROID_GRADLE_PLUGIN = new AndroidGradlePluginVersionReader(); 
 * the double value whose ceiling will be computed. * @return the ceiling of the argument. 
 * the double value whose ceiling will be computed. * @return the ceiling of the argument. 
 int highBits = highBits(bits); // high word of d int lowBits = lowBits(bits); // low word of d 
 else if (exp < 20) { 
 * the double value whose floor will be computed. * @return the floor of the argument. 
<|del|> 
 public boolean commitStep() { // This code is duplicated from LafManager.initComponent(). But our Welcome Wizard is started // AFTER that call so we repeat it here. 
 return !(name.equalsIgnoreCase(".DS_Store") || name.equalsIgnoreCase("thumbs.db") || name.equalsIgnoreCase("desktop.ini")); 
<|del|> 
 localLongNamesAreAmbiguous = true; 
 myModel = new AttributesTableModel(selectedStyle, getSelectedAttrGroup(), configuration, myThemeEditorContext.getProject()); myModel.setGoToDefinitionListener(myGoToListener); 
<|del|> 
<|del|> 
<|del|> 
 // Forces rules for binaries to run so that the variants are created. registry.realizeNode(new ModelPath("binaries")); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 List<RemotePkgInfo> result = new SmartList<RemotePkgInfo>(); 
 * Revision spaces are replaced by underscores for ease of use in command-line. * Preview versions will have -preview appended. The RC number is not included. 
 StyleResourceValue style = getStyleResourceValue(); return style == null ? null : StyleResolver.getQualifiedStyleName(style); 
<|del|> 
 public void timeCeilOverInterestingValues(int reps) { 
 public void timeFloorOverInterestingValues(int reps) { 
 public void timeFloorOverInterestingValues(int reps) { 
 "Cannot find the jack tool, disable jack and file a bug"); 
 "Cannot find the jack tool, disable jack and file a bug"); 
 if (!job.await()) { 
<|del|> 
 @NotNull private static String determineGradlePluginVersion(@Nullable Project project) { String gradlePluginVersion = SdkConstants.GRADLE_PLUGIN_RECOMMENDED_VERSION; 
 public boolean isReadyForDebugging(@NotNull ClientData data, @Nullable ProcessHandler processHandler) { 
 NotificationHyperlink upgradeAndroidPluginHyperlink = new FixGradleModelVersionHyperlink(false); 
 "<li>The build file may be missing a Gradle plugin.\n" + applyGradlePluginHyperlink.toHtml() + "</li>"; 
 assertEquals("Targets", execute(new GuiQuery<Object>() { @Override protected Object executeInEDT() throws Throwable { TargetsRootNode node = (TargetsRootNode)treeModel.getChild(treeModel.getRoot(), 0); return node.getUserObject(); } })); 
 execute(new GuiTask() { @Override protected void executeInEDT() throws Throwable { input.setSelectedItem(text); } }); 
 return isAncestor(androidProject.getBuildFolder(), virtualToIoFile(file), false); 
 * @return a non-null collection of files. 
 * * <p>Can only be used with Jack toolchain. * 
 * * <p>Can only be used with Jack toolchain. * 
 DynamicPopup popup = new DynamicPopup(myTree, this); popup.addAction(new EditMultipleSourcesDynamicAction()); 
 Main[] array = { this, this, this }; Arrays.binarySearch(array, 0, 3, this /* value */, this /* comparator */); return passed; 
 public void resetZoom() { 
 // move the parameter to ECX, and therefore overwrite the ART 
 /// CHECK-NOT: Invoke{{.*}} 
 public IPkgDesc getItemDesc() { return getItem().getPkgDesc(myIncludePreview); 
 return ((PlatformDetailsTreeNode)node).getItemDesc().getPreciseRevision(); 
 StyleResourceValue style = getStyleResourceValue(); return style == null ? null : StyleResolver.getQualifiedStyleName(style); 
 if (buildToolInfo.getRevision().getMajor() < 23 || Boolean.valueOf(System.getenv("DISABLE_JACK_API"))) { 
 if (Boolean.valueOf(System.getenv("DISABLE_JACK_API")) || androidBuilder.getTargetInfo().getBuildTools().getRevision().getMajor() < 23) { 
 private void doTest(@NotNull String makeStepName, @NotNull String path, @NotNull String testClass) throws Exception { 
<|del|> 
<|del|> 
 findAndClickButton(dialogFixture, "Next"); findAndClickButton(dialogFixture, "Next"); 
 VirtualFile projectDir = ideFrameFixture.getProject().getBaseDir(); assertNotNull(projectDir.findFileByRelativePath("mylibrary/src/main")); assertNull(projectDir.findFileByRelativePath("mylibrary/src/test")); 
 private void selectItemInGallery(@NotNull Dialog dialog, final int selectedIndex) { 
 findAndClickButton(dialogFixture, "Next"); findAndClickButton(dialogFixture, "Next"); 
 VirtualFile projectDir = ideFrameFixture.getProject().getBaseDir(); assertNotNull(projectDir.findFileByRelativePath("mylibrary/src/main")); assertNull(projectDir.findFileByRelativePath("mylibrary/src/test")); 
 } outputOffset += NativeCrypto.EVP_CipherUpdate(cipherCtx, output, outputOffset, input, inputOffset, inputLen); calledUpdate = true; return outputOffset - intialOutputOffset; 
 @NotNull public final Module dependency; @NotNull public final String dependent; 
 String msg = String.format("Ignoring dependency of module '%1$s' on module '%2$s'. %3$s", dependency.dependent, dependency.dependency.getName(), dependency.detail); VirtualFile buildFile = getBuildFile(dependency.dependency); 
import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.Shape; 
<|del|> 
 public static Provider getExternalProvider(String algorithm) { Provider selectedProvider = null; 
 signature.initSign(javaKey); break; 
 c = Cipher.getInstance(transformation, p); c.init(Cipher.DECRYPT_MODE, javaKey); } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException e) { 
 throw new AssertionError("Could not create rsc dir"); 
 throw new AssertionError("Could not create meta dir"); 
<|del|> 
<|del|> 
 this.testVariantConfig = checkNotNull(testVariantConfig); 
 this.testVariantConfig = checkNotNull(testVariantConfig); 
 * and read the reply of the invoke. 
 * and read the reply of the invoke. 
 // including event thread #1. This helps us check that the debugger is not blocked waiting for 
 // Create test thread but do not start it now. It will be started by the invoke from 
<|del|> 
 .contains("[NewAppTheme]", atIndex(0)) .contains("Rename NewAppTheme", atIndex(7)); 
 ThemeEditorFixture themeEditor = ThemeEditorTestUtils.openThemeEditor(projectFrame); 
 public String getSimpleName() { return mySimpleName; 
 * Copyright (C) 2015 Google Inc. 
 private final String long1 = "Ahead-of-time compilation is possible as the compiler may just" 
 TaggedObject invokeNewObject = reply.getNextValueAsTaggedObject(); assertEquals(JDWPConstants.Tag.OBJECT_TAG, invokeNewObject.tag); assertFalse("Invalid exception object id", invokeNewObject.objectID == 0); 
 TaggedObject invokeException = reply.getNextValueAsTaggedObject(); assertEquals(JDWPConstants.Tag.OBJECT_TAG, invokeException.tag); assertEquals("Invalid exception object id", 0, invokeException.objectID); 
 public static DisposeDuringInvokeDebuggee thisObject; 
import com.android.builder.model.JavaArtifact; 
 private static boolean configurationTypeIsSupported(@NotNull RunConfiguration runConfiguration) { 
 private static boolean isUnitTestConfiguration(@NotNull RunConfiguration runConfiguration) { 
 " not contain the method (e.g. 'testCompile' was added in 1.1.0).\n", 
 return fromBuildFile.compareTo(PreciseRevision.parseRevision(GRADLE_PLUGIN_RECOMMENDED_VERSION)) >= 0; 
 return fromBuildFile.compareTo(PreciseRevision.parseRevision(GRADLE_PLUGIN_RECOMMENDED_VERSION)) >= 0; 
 } return false; 
 * Test if the customized enum support is workable when * application enum is used on switch statement. 
 * Copyright (C) 2015 The Android Open Source Project 
 * Copyright (C) 2015 The Android Open Source Project 
 * Copyright (C) 2015 The Android Open Source Project 
 * Copyright (C) 2015 The Android Open Source Project 
 * Copyright (C) 2015 The Android Open Source Project 
 metaVar = "[error | warning | info | debug | trace]") protected VerbosityLevel verbose = VerbosityLevel.WARNING; 
 * Copyright (C) 2015 The Android Open Source Project 
 * Copyright (C) 2015 The Android Open Source Project 
 private JDefinedClass noSuchFieldErrorType; 
 public void waitForThemeSelection(@NotNull final String themeName) { 
<|del|> 
 new String(long1), // force execution of code beyond reference equality check "----" + long1, long1 + long1, long1 + "12345678", "android Runtime" + long1 
<|del|> 
 LayoutlibCallbackImpl layoutlibCallback = new LayoutlibCallbackImpl(null, layoutLib, appResources, module, facet, logger, credential, null) { @Override public ActionBarCallback getActionBarCallback() { return actionBarCallback; } }; 
<|del|> 
 throw new AssertionError("type does not exist"); 
 throw new AssertionError("type does not exist"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 mySubStyleName = value.getValue(); 
 // FINDBUGS Fields are initialized by init() 
 // FINDBUGS Fields are initialized by init() 
 this.version = "Unknown"; this.releaseName = "Unknown"; 
 assert versionFileVersion >= 1; 
 g2d.drawString("HAXM is required for running", PADDING, infoSegmentY); infoSegmentY += stringHeight; g2d.drawString("x86 System Images", PADDING, infoSegmentY); 
 @NotNull 
 if (config.getPackageBuildConfig() != null) { throw new InvalidUserDataException( "Applications always package the generated BuildConfig class, " + "so packageBuildConfig = false can only be used for libraries."); } 
 myComponent = ScrollPaneFactory.createScrollPane(myTree); 
 myComponent = ScrollPaneFactory.createScrollPane(myTree); 
 * @param args To be handled as command line arguments. 
 * @param args To be handled as command line arguments. 
 * Redirect Jack's error output to the given stream. 
 * Redirect Jack's standards output to the given stream. 
 public SeparatedListBuilder<T> separator() { 
 public SeparatedListBuilder<T> add(T element) { 
 final int displayId = w.getDisplayId(); 
 MagnificationSpec spec = mService.mAccessibilityController.getMagnificationSpecForWindowLocked(w); 
 private static void assertBuildFileContains(@NotNull IdeFrameFixture projectFrame, @NotNull String relativePath, @NotNull String content) { String newBuildFileContent = getFileContent(new File(projectFrame.getProjectPath(), relativePath).getPath()); 
 myLastSelectedDevice = getPersistableName(selectedDevice); myLastSelectedProcess = getPersistableName(selectedClient); 
 UserConsentDialog.newInstance(UserConsentDialog.PROFILE_OWNER, false /* showFrpWarning */) 
 public String getEditorValue() { 
<|del|> 
 myComponent.configure(item, color); myComponent.setBorder(isSelected ? mySelectedBorder : myUnselectedBorder); 
 checkNoErrors(projectFrame); 
 ((ApkVariantOutputData) variantOutputData).splitZipAlign.getAbiInputFiles().addAll( 
 @NonNls public static final String DEFAULT_ASSOCIATED_EXTENSION = SdkConstants.EXT_AIDL; 
 "Hello my name is ", // constant "What's your name?", "Android Runtime", "v3ry Cre@tiVe?****", "!@#$%^&*()_++*^$#@" 
 public static void main(String[] args) {} 
// protected p1.PackagePrivateA.method. 
 // access to it. 
<|del|> 
 */ 
 protected static class ActivityNameException extends Exception { public ActivityNameException(String message) { super(message); } 
 for (int i = 0, len = nodes.size(); i < len; ++i) { BasicBlock block = nodes.get(i); 
 DefaultNativeToolSpecification.INSTANCE.apply(binary); 
 new DependencySpec("service", "org.gradle.test.classifiers", "1.0", "jdk15", "jar")}, 
 new DependencySpec("service", "org.gradle.test.classifiers", "1.0", "jdk15", "jar")}, 
<|del|> 
 * Binds one value to another. Whenever the source value changes, the destination value will 
 TwoWayBinding<?> binding = i.next(); if (binding.myLhs == first && binding.myRhs == second) { binding.dispose(); 
 ArrayList<RunningTaskInfo> stackTaskList = new ArrayList<RunningTaskInfo>(); 
 * Returns the fully qualified launcher activity name. 
 protected abstract String getQualifiedActivityName() throws ActivityLocatorException; 
 public abstract void validate() throws ActivityLocatorException; 
 // Prefer the launcher which has the CATEGORY_DEFAULT intent filter. // There is no such rule, but since Context.startActivity() prefers such activities, we do the same. // https://code.google.com/p/android/issues/detail?id=67068 
<|del|> 
 // Up to this point, we record that the lower bound (inclusive) is 3. // The next instruction will record that the lower bound is 1. 
 // would be 3). 
 */ 
 private static final IFileElementType AIDL_FILE_ELEMENT_TYPE = new IFileElementType(AidlFileType.INSTANCE.getLanguage()); 
import com.intellij.ui.AnActionButton; import com.intellij.ui.AnActionButtonRunnable; import com.intellij.ui.CheckBoxList; import com.intellij.ui.CollectionListModel; import com.intellij.ui.ToolbarDecorator; 
 if (!StringUtil.isEmpty(predefinedValue)) { 
<|del|> 
 public void addModuleComboActionListener(@NotNull ActionListener actionListener) { 
<|del|>
 if (resourceName.isEmpty()) { 
 else if (fileName.isEmpty()) { 
 } else if (resourceName.equals(ResourceHelper.prependResourcePrefix(myModule, null))) { 
 /** * @see CreateXmlResourceDialog#getPreferredFocusedComponent() */ 
 if (name.isEmpty() || name.equals(ResourceHelper.prependResourcePrefix(myModule, null))) { 
public class AndroidUnresolvedReferenceQuickFixProvider extends UnresolvedReferenceQuickFixProvider<PsiJavaCodeReferenceElement> { 
 ? new File(javaResourcesLocation) : Iterables.getOnlyElement(packagedJars)); 
 // we have a duplicate but it might be the same source file, in this case, // we just ignore the duplicate, and of course, we don't add it again. 
 * A filter to filter out binary files like .class or .dex 
 return parentFilter.checkEntry(archivePath) && !archivePath.endsWith(".class"); 
 * Returns the {@link SignedJarBuilder.IZipEntryFilter} instance 
 // the fact we use a SET is not right, we should have an ordered list of jars... // VariantConfiguration.getPackaged|ProvidedJars should use List<> 
 processJarEntry(jarFile, jarEntry, outputFolder); 
 if (inputStream != null) { inputStream.close(); 
<|del|> 
 } else if (!appSupportedDomain.isEmpty()) { 
 return Allocation.createTyped(mRS, b.create(), Allocation.USAGE_SCRIPT); 
<|del|> 
<|del|> 
<|del|> 
 allFilters.addAll( variantData.getFilters(com.android.build.OutputFile.FilterType.DENSITY)); allFilters.addAll( variantData.getFilters(com.android.build.OutputFile.FilterType.LANGUAGE)); 
 myAttributesSorter.setSortKeys(ImmutableList.of(new RowSorter.SortKey(0, SortOrder.ASCENDING))); 
 myPanel.getPalette().setModel(new AttributesModelColorPaletteModel(myConfiguration, myModel)); 
 final Module contextModule = findModuleForPsiElement(reference); 
 * Quickfix to add dependency to another module in gradle.build file and sync the project. * Duplicated from {@link com.intellij.codeInsight.daemon.impl.quickfix.AddModuleDependencyFix} except the * {@link AddGradleProjectDependencyFix#addDependencyOnModule} method 
 private final Set<Module> myModules = Sets.newHashSet(); 
 PsiElement psiElement = reference.getElement(); Project project = psiElement.getProject(); JavaPsiFacade facade = JavaPsiFacade.getInstance(project); ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex(); 
 if (virtualFile == null) { continue; } 
 if (virtualFile == null) { continue; } 
 Module module = getFirstItem(myModules); assert module != null; 
 Module module = getFirstItem(myModules); assert module != null; 
 Module module = getFirstItem(myModules); assert module != null; addDependencyOnModule(project, editor, module); 
 Runnable doit = new Runnable() { 
 PsiElement psiElement = reference.getElement(); 
 * Filter to detect duplicate entries 
 // utility to create and allocation of a given dimension 
 // utility to create and allocation of a given dimension 
 // Compare two images ensuring returning false if error is greater than 2 // so that it can support integer and float non identical versions 
 // Porter/Duff xor compositing 
 Script.LaunchOptions opt = new Script.LaunchOptions(); // unclipped but with options 
 // Compare two images ensuring returning false if error is greater than 2 // so that it can support integer and float non identical versions 
 // Build a test pattern to be the source pattern designed to provide a wide range of values 
 // dst = dst + src 
 // dst = dst * src 
 // Sets dst = src 
 // dst = src * dst.a 
 // Sets dst = dst - src 
<|del|> 
 FileUtils.emptyFolder(outFolder); 
 if (!folder.delete()) { throw new IOException(String.format("Could not delete folder %s", folder)); } 
 public CanvasFinalizer(long nativeCanvas) { mNativeCanvasWrapper = nativeCanvas; 
 mNativeChunk = 0; 
 mNativeRegion = 0; 
 // create expression representing call to synthetic switch map initializer JExpression getSwitchMapInvocExpr = new JMethodCall(switchStmt.getSourceInfo(), null /*static method*/, switchMapClass, syntheticSwitchmapInitializer.getMethodId(), syntheticSwitchmapInitializer.getType(), 
 // create expression representing call to synthetic switch map initializer JExpression getSwitchMapInvocExpr = new JMethodCall(switchStmt.getSourceInfo(), null /*static method*/, switchMapClass, syntheticSwitchmapInitializer.getMethodId(), syntheticSwitchmapInitializer.getType(), 
@Constraint(need = {JSession.class, JDefinedClass.class, JDefinedEnum.class}) @Transform(add = {SwitchEnumUsageMarker.class}) 
 if (Jack.getSession().containsMarker(ShrinkMarker.class) && !method.containsMarker( KeepMarker.class)) { 
 // add the enclosing class into user set. This information will be // used later 
<|del|> 
 throw new AssertionError("No EnumUsageMarker is attached to enum: " + enumType); 
 private Color myPrimaryColor; private static AccentPaletteModel ourAccentPaletteModel = null; 
 this.myPrimaryColor = primaryColor; if (ourAccentPaletteModel == null) { 
<|del|> 
 private static ImmutableList<Color> ourPrimaryColorsList; 
import javax.swing.JComponent; 
<|del|> 
 private final Color myPrimaryColor; private static ImmutableMap<Color, Color> ourPrimaryDarkColorsList = null; 
 this.myPrimaryColor = primaryColor; 
 return positionMap.containsKey(primaryColor); 
 return positionMap.containsKey(primaryColor); 
<|del|> 
 private final Color myPrimaryColor; private final ImmutableList<Color> myAccentColorsList; 
 if (PRIMARY_MATERIAL.equals(attributeName)) { 
 public void setRecentColors(@NotNull List<Color> colorList) { 
 private int cell_dimension = 52; //Needed to allocate space for the component before calling paint 
 myPrimaryColor = primaryColor; 
 return Collections.emptyList(); 
 /** * @see CreateXmlResourceDialog#doValidate() */ 
 throw new ComponentLookupException(String.format("More than one Hprof editor for file '%s' found", hprofFileName)); 
 throw new ComponentLookupException(String.format("Cannot find any open Hprof editors for file '%s'", hprofFileName)); 
 throw new ComponentLookupException(String.format("More than one Hprof editor pane for file '%s' found", hprofFileName)); 
<|del|> 
<|del|> 
 private static final String CAPTURES_APPLICATION = "CapturesApplication"; 
 final MessageBusConnection connection = module.getMessageBus().connect(); connection.subscribe(ProjectTopics.MODULES, new ModuleAdapter() { 
 connection.disconnect(); 
<|del|> 
 // "@+id/" names found before processing the view tag corresponding to the id. Set<String> pendingResourceIds = Sets.newHashSet(); 
 // If the attribute is not android:id, and an item for it hasn't been created yet, add it to 
 pendingResourceIds.remove(id); 
 // warning for separate if branches suppressed because to do. 
 } return style; 
 myThemeList = ImmutableList.copyOf(temporarySet); mySizeBeforeExtraOptions = myThemeList.size(); 
<|del|> 
 // TODO: Use mouse clicks instead of the keyboard when the fixture responds correctly to double clicks, // as this will better model how users interact with the feature in practice. 
 assert themeEditorStyle != null : "Style with name " + value.getName() + " doesn't exist"; 
 private final boolean mValidateEnabled; 
 private Alarm myAlarm; private final JBTable myInfoTable; 
 int height; Camera camera = null; 
 for (Camera.Size size : previewSizes) { 
 } if (camera != null) { camera.release(); } 
<|del|> 
 Collection<ThemeEditorStyle> editableThemes = themeResolver.getLocalThemes(); Collection<ThemeEditorStyle> readOnlyLibThemes = new HashSet<ThemeEditorStyle>(themeResolver.getProjectThemes()); readOnlyLibThemes.removeAll(editableThemes); 
 mVerify.set_gAllowedIntError(2); // this will allow for less strict implementation 
 * * <b>Note:</b> this is NOT the Porter/Duff XOR mode; this is a bitwise xor. * 
 getReportLog().printArray("Elapsed time for query (channels): ", 
 try (Cursor c = mContentResolver.query(channelUri, null, null, null, null)) { 
 try (Cursor c = mContentResolver.query(programUri, null, null, null, null)) { 
 response.setContentType(TextPlain.CONTENT_TYPE_NAME + "; Charset=" + TextPlain.getCharset(expectedContentType).name()); out = response.getPrintStream(); 
 response.setContentType(TextPlain.CONTENT_TYPE_NAME + "; Charset=" + charset.name()); 
 response.setContentType(TextPlain.CONTENT_TYPE_NAME + "; Charset=" + charset.name()); 
<|del|> 
 int selectedRow = myInfoTable.getSelectedRow(); if (selectedRow < 0) { return null; 
 for (Camera.Size size : previewSizes) { 
 for (Camera.Size size : previewSizes) { 
<|del|> 
<|del|> 
<|del|> 
 minDiff = curDiff; 
<|del|> 
<|del|> 
 /// CHECK: pAputObject 
 sources.push(new NoLocation()); 
 private AccentPaletteModel myAccentPaletteModel = new AccentPaletteModel();; 
<|del|> 
<|del|> 
import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.Set; import java.util.TreeSet; 
 ImmutableMap.Builder<String, Integer> builder = ImmutableMap.builder(); builder.put("colorPrimary", 1); builder.put("colorPrimaryDark", 2); builder.put("colorAccent", 3); 
import java.awt.Color; import java.util.ArrayList; 
import java.awt.Color; import java.util.ArrayList; 
<|del|> 
 return false; 
 assertFalse(isWear(tv1080p)); assertFalse(tv1080p.isScreenRound()); 
 * http://www.apache.org/licenses/LICENSE-2.0 
<|del|> 
<|del|> 
 private Map<Class<?>, Integer> myRowHeights; 
 sortTree(myRoot); myTreeModel.nodeStructureChanged(myRoot); 
 final JCheckBox noQualifierCheckBox = myCheckBoxes.get(myFolderType.getName()); if (noQualifierCheckBox != null) { noQualifierCheckBox.setSelected(true); 
 if (err == -EACCES) { 
 // TODO alias to openDrawer before 3.0 and deprecate this method. 
 // TODO alias to closeDrawer before 3.0 and deprecate this method. 
 // TODO alias to closeDrawer before 3.0 and deprecate this method. 
 public void testWithInputType_ReturnsFalseIf_IncorrectInput() { 
 public void testWithInputType_ShouldNotCrashIf_InputTypeIsNotRecognized() { 
 this(module, resourceType, defaultFile); 
 PsiFile psiFile = AndroidPsiUtils.getPsiFileSafely(myProject, virtualFile); if (psiFile instanceof XmlFile) { 
 XmlTag rootTag = ((XmlFile)psiFile).getRootTag(); if (rootTag != null) { 
 PsiFile psiFile = AndroidPsiUtils.getPsiFileSafely(project, virtualFile); if (psiFile instanceof XmlFile) { 
 myAttributesTable.setDefaultRenderer(Color.class, new DelegatingCellRenderer(new ColorRendererEditor(myThemeEditorContext, myPreviewPanel, false))); 
 return getThemes(repository.getConfiguredResources(ResourceType.STYLE, myConfiguration.getFullConfig()), false /*isFramework*/); 
<|del|> 
 return getThemes(repository.getConfiguredResources(myConfiguration.getFullConfig()), true /*isFramework*/); 
 private List<StyleResourceValue> resolveProjectThemes() { LocalResourceRepository repository = AppResourceRepository.getAppResources(myConfiguration.getModule(), true); 
 return getThemes(repository.getConfiguredResources(myConfiguration.getFullConfig()), false /*isFramework*/); 
 return getThemes(repository.getConfiguredResources(myConfiguration.getFullConfig()), false /*isFramework*/); 
 private List<StyleResourceValue> getThemes(@NotNull Map<ResourceType, Map<String, ResourceValue>> resources, 
 private List<StyleResourceValue> getThemes(@NotNull Map<ResourceType, Map<String, ResourceValue>> resources, 
 private final Multimap<String, VdIcon> mAllIconCategoryMap = TreeMultimap.create(); 
 return mName.compareTo(other.mName); 
<|del|> 
 } @Override public int hashCode() { return Arrays.hashCode(sun_path); } @Override public String toString() { return "UnixSocketAddress{" + "sun_path=" + Arrays.toString(sun_path) + '}'; } 
public class LambdaTest { 
 AbstractTestTools.getTestRootDir("com.android.jack.java8.lambda.test008"), "com.android.jack.java8.lambda.test008.jack.Tests"); 
 AbstractTestTools.getTestRootDir("com.android.jack.java8.lambda.test010"), "com.android.jack.java8.lambda.test010.jack.Tests") .addProguardFlagsFileName("proguard.flags"); 
<|del|> 
<|del|> 
 Assert.assertEquals(10, Lambda.testGet10()); 
 * Test target typing with overloading methods. 
 for (NetworkInterface nif : Collections.list(NetworkInterface.getNetworkInterfaces())) { 
 return myRobot.finder().findByType(component, JTree.class); 
 private static StyleResourceValue getStyleResourceValue(@NotNull Configuration configuration, @NotNull String qualifiedStyleName) { 
 final ThemeEditorStyle selectedStyle = getUsedStyle(); 
<|del|> 
 /** * Stores {@link ThemeEditorStyle#mySourceModule} of a ThemeEditorStyle currently being edited */ private @Nullable Module mySelectedStyleSourceModule; 
 return myConfiguration.getResourceResolver().getStyle(myStyleName, isFrameworkStyle); 
 assertEquals("<html><font color='#ff0000'><left>'"+badText+"' is not a valid resource name character</left></b></font></html>", dialog.getError()); 
 } else if (errorFlag == -ENODEV) { 
 } else if (errorFlag == ALREADY_EXISTS) { 
<|del|> 
 private static SettingsController ourSettingsController = SettingsController.getInstance(); 
 throw new InvalidKeyException( "No provider offers " + transformation + " for " + key.getAlgorithm() + " key of class " + key.getClass().getName() + " and export format " + key.getFormat()); 
 if (key == null) { 
 throw new InvalidKeyException("No provider supports the provided key"); 
<|del|> 
 myColorWheel.setHue(value.intValue()/255.0f); 
<|del|> 
import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; 
 for (StateListState state: colorStates) { ResourceComponent stateComponent = createStateComponent(state); stateComponent.addActionListener(new StateActionListener(state)); 
 ChooseResourceDialog dialog = ThemeEditorUtils.getResourceDialog(myItem, myContext, allowedTypes.toArray(new ResourceType[allowedTypes.size()])); 
 private static final String[] HOST_JARS = new String[] { "core-libart-hostdex", 
 && s.mScreenRound == mScreenRound && s.mChin == mChin; 
 sb.append(mScreenRound); sb.append(", mChin="); sb.append(mChin); 
 private static final String[] DEVICE_JARS = new String[] { "core-libart", 
 @NotNull private final Color myPrimaryColor; 
 public List<Color> suggestColor() { 
<|del|> 
<|del|> 
 .resolveColor(styleResourceResolver, style.getItemResourceValue(PRIMARY_MATERIAL, myItem.isFrameworkAttr())); 
<|del|> 
import java.awt.Color; 
<|del|> 
 } 
 e.printStackTrace(); 
 if (index >= actions.size()) { throw new ArrayIndexOutOfBoundsException("Index '" + index + "' is out of bounds (size: " + actions.size() + ")"); } 
 if (myStateList.getType() == ResourceFolderType.COLOR) { 
<|del|> 
import com.intellij.openapi.actionSystem.DefaultActionGroup; import com.intellij.openapi.actionSystem.IdeActions; 
<|del|> 
 String attributeName = myItem.getName().toLowerCase(); if (attributeName.contains("color") || !ThemeEditorUtils.acceptsFormat(attrDefinition, AttributeFormat.Reference)) { 
 if (c.isEnabled() && border != null && c instanceof AbstractButton && ((AbstractButton)c).isContentAreaFilled()) { 
 if (contents instanceof AttributesTableModel.AttributeContents) { final AttributesTableModel.AttributeContents attribute = (AttributesTableModel.AttributeContents) contents; final EditedStyleItem item = attribute.getValueAt(1); if (item == null) { 
 return String.class; 
 return WIDE_CLASSES.contains(getCellClass(column)) || column == 1; 
<|del|> 
 // TODO: Add tests for other architectures. 
 * <ul> * <li>75% saturation and 100% brightness</li> * <li>100% saturation and original brightness of the colour</li> * </ul> 
 * <ul> * <li>75% saturation and 100% brightness</li> * <li>100% saturation and original brightness of the colour</li> * </ul> 
 * <ul> * <li>75% saturation and 100% brightness</li> * <li>100% saturation and original brightness of the colour</li> * </ul> 
 private AccentPaletteModel myAccentPaletteModel = new AccentPaletteModel(); 
 myPrimaryColor = primaryColor; 
 private final ImmutableMap<Color, Color> myPrimaryDarkColorsList; 
 @NotNull ResourceType[] allowedTypes) { 
<|del|> 
 private static ImmutableList<PrimaryAccentPair> primaryAccentList; private static final HashMap<Color, Integer> positionMap = new HashMap<Color, Integer>(); private static final ImmutableList.Builder<PrimaryAccentPair> builder = ImmutableList.builder(); 
 public static void initializePrimaryAccentList() { 
 builder.add(primaryAccentPair); 
 return null; 
 myPrimaryColor = primaryColor; 
<|del|> 
 return (ThemeEditorStyle)item; 
 actual = (Integer)getOffset.invoke(field); 
<|del|> 
 void themeChanged(@NotNull String name); 
 public void themeChanged(@NotNull String name) { 
 private static final int ICON_SIZE = 20; 
 private ColorPalette myColorPalette=null; 
 public void setValues(@NotNull Color primaryColor, @NotNull Color primaryDarkColor, @NotNull Color accentColor) { 
<|del|> 
 myStyleNameTextBuilder.append(parentName + "."); myStyleNameTextBuilder.append(styleName.substring(parentName.length() + 1)); 
<|del|> 
<|del|> 
<|del|> 
 public StyleListPaletteCellRenderer(@NotNull ThemeEditorContext context, @NotNull ThemeEditorComponent.ThemeChangedListener themeChangedListener) { 
<|del|> 
 public ColorPalette(@NotNull Color primaryColor, @NotNull Color primaryDarkColor, @NotNull Color accentColor) { 
 private final File mGeneratedFile; 
 * A path is a collection of one or more steps, and wizards contain one or more paths. Furthermore, * different wizards may share (their own instances of) the same path class. 
 * "NPW" is short for "New Project Wizard", and this package is a collection of wizards that 
 assertEquals("lib3", WizardUtils.computeModuleName("Lib", getProject())); 
 } catch (InterruptedException ex) { 
 } catch (InterruptedException ex) { 
 waiter.join(); 
 assertTrue(module.getName() + " at " + contentRoot.getPath() + " should be an Android library.", AndroidFacet.getInstance(module).isLibraryProject()); 
 } if (!isBrowsable) { context.report(ISSUE, child, context.getLocation(child), "Activity supporting ACTION_VIEW is not set as browsable"); } 
<|del|> 
<|del|> 
<|del|> 
 throw new IllegalStateException("Could not find matching mockable platform jar."); 
 private static void checkForTestRoots(final Module srcModule, final Set<VirtualFile> testFolders, final Set<Module> processed) { 
 Node getDetailsXml(Document document) { 
import javax.swing.JPanel; import javax.swing.JTextField; import javax.swing.SwingUtilities; 
import javax.swing.JPanel; import javax.swing.JTextField; import javax.swing.SwingUtilities; 
 private static final String STATE_NAME_PREFIX = "state_"; 
 void run(@Nonnull Map<String, Object> parameters) throws ServerException, InterruptedException; 
 * Copyright (C) 2015 The Android Open Source Project 
 forkResourceValue(startElement.getProject(), tag, file, facet, dir, true); 
 private final @NotNull Color myPrimaryColor; 
<|del|> 
 private static boolean modelVersionIsAtLeast(@NotNull IdeaAndroidProject androidProject, @NotNull String revision) { 
 return modelVersion.compareTo(FullRevision.parseRevision(revision), FullRevision.PreviewComparison.IGNORE) >= 0; 
<|del|> 
 private static final int ICON_SIZE = JBUI.scale(20); 
<|del|> 
<|del|> 
 public static final String ADMIN_CHANNEL_PARAMETER = "admin.channel"; @Nonnull public static final String SERVER_VERSION_PARAMETER = "server.version"; 
 public void testColorWheelResizeAndSelect() { 
 public void testColorWheelResizeAndSelect() { 
 assertEquals(expectedColor, colorWheel.getColor()); 
 // Sync data and metadata with every write 
<|del|> 
 com.ibm.icu.text.Normalizer.Mode getIcuForm() { return this.icuForm; } 
 private final com.ibm.icu.text.Normalizer.Mode icuForm; 
 return icuForm; 
 getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND)); 
<|del|> 
 sThreadPoolSize = sThreadPoolSize; 
 for (int index = 0; index < myParent.getChildCount(); index++) { 
 }; renderer.setBorder(BorderFactory.createEmptyBorder(1, 1, 1, 1)); setCellRenderer(renderer); 
 * Image for the {@link DragGestureEvent#startDrag} method 
 private Image dragImage; 
<|del|> 
 try { Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadClass " + line); 
<|del|> 
<|del|> 
<|del|> 
 try { Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartServices"); 
<|del|> 
 private static String generateVectorXml(@NotNull File inputSvgFile, StringBuilder error) { 
 @Nullable StringBuilder errorLog) { 
 String sdk = System.getenv("ANDROID_SRC"); 
 static class SaturationBrightnessComponent extends JComponent { 
 final AndroidFacet facet = AndroidFacet.getInstance(contextModule); if (facet == null) { 
<|del|> 
 List<BuildFileStatement> dependencies = Lists.newArrayList(gradleBuildFile.getDependencies()); 
 List<BuildFileStatement> dependencies = Lists.newArrayList(gradleBuildFile.getDependencies()); 
 // We only allow entries from the running JDK, to keep existing crypto extensions working. 
 private SwitchEnumOptStrategy switchEnumOptimizationStrategy = null; 
 IDNA.Info info = new IDNA.Info(); converter.nameToASCII(input, result, info); if (info.hasErrors()) { throw new IllegalArgumentException("Invalid input to toASCII: " + input); } 
 this.densities = EnumSet.noneOf(Density.class); for (Density density : Density.values()) { if (density.isRecommended()) { this.densities.add(density); } } 
 private File getGeneratedResourcesDir(String name) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * This {@link Marker} holds the thrown exception types. 
import com.android.jack.jayce.v0003.io.JayceInternalWriterImpl; 
 public static final int CURRENT_MINOR = 0; 
 append(" DEFAULT", SimpleTextAttributes.GRAY_ATTRIBUTES, list.getWidth()-10, SwingConstants.RIGHT); 
 private final @NotNull ThemeEditorComponent.ThemeChangedListener myThemeChangedListener; private final @NotNull ThemeEditorContext myContext; 
<|del|> 
<|del|> 
 if (srv.isFramework() && (name.equals(THEME_NAME) || name.startsWith(THEME_NAME_DOT))) { 
 public void testCreateNewThemeSelection() throws IOException { 
 myGraphicsLayoutRenderer.setSize(width, 1); 
<|del|> 
 @Nullable Color primaryColor) { //The current primaryColor is passed in order to generate material suggestions based on it 
<|del|> 
<|del|> 
 myModel = (AttributesTableModel) table.getModel(); 
 private static final ImmutableMap<Color, Integer> POSITION_MAP; private static final ImmutableList<Color> PRIMARY_COLOR_LIST; 
<|del|> 
 private int cell_dimension = 42; //Needed to allocate space for the component before calling paint private int myWidth = 0; private int myHeight = 0; 
 private int cell_dimension = 42; //Needed to allocate space for the component before calling paint private int myWidth = 0; private int myHeight = 0; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Check whether the input conforms to BiDi rules. * @hide 
 * Check whether the input conforms to CONTEXTJ rules. 
 * Check whether the input conforms to CONTEXTO rules, 
 * @param flags Define the rules for parsing internationalized domain names. * This can take the values of the constants defined in this class. 
 * @param flags Define the rules for parsing internationalized domain names. * This can take the values of the constants defined in this class. 
 * Also ensure that accept is called before data is retrieved from a source that has text flavor but no designer flavor. 
<|del|> 
 throw new AssertionError( String.format("Problem with drop: dragged.size(%1$d) != components.size(%1$d)", dragged.size(), components.size())); 
 * such that we can access either instance in code common for the 2 cases. * <p/> * <p>Also ensure that accept is called before data is retrieved from a source that has text flavor but no designer flavor.</p> 
 private boolean myStatusSpecified; 
 } catch (UnsupportedFlavorException ex) { LOG.warn(ex); 
 if (myCurrentInteraction == null) { NlDropEvent event = new NlDropEvent(dragEvent); 
 // that reflects the users choice i.e. controlled by the modifier key. 
<|del|> 
<|del|> 
 // that reflects the users choice i.e. controlled by the modifier key. 
<|del|> 
 for (int index = 0; index < dragged.size(); index++) { 
 for (int index = 0; index < dragged.size(); index++) { 
 ApplicationManager.getApplication().assertReadAccessAllowed(); 
<|del|> 
<|del|> 
 /// CHECK-DAG: StaticFieldGet loop:{{B\d+}} /// CHECK-DAG: StaticFieldGet loop:{{B\d+}} 
 private class SamNotFoundException extends Exception { 
 private JMethod getSamMethod(@Nonnull JClass jlo) throws SamNotFoundException { JMethod samMethod = null; 
 throw new SamNotFoundException(); 
 if (mth1Params.size() != mth2Params.size()) { 
 for (JVariableRef usedVarRef : uvm.getUsedVariables()) { UseDefsMarker udm = usedVarRef.getMarker(UseDefsMarker.class); assert udm != null; 
 public void setSyntheticInitializerCreationFlag(boolean flag) { this.isSyntheticInitializerCreated = flag; 
<|del|> 
 String fieldName = OptimizationUtil.getSyntheticSwitchMapFieldName(enumType); JField syntheticMapField = new JField(SourceInfo.UNKNOWN, fieldName, switchMapClass, supportUtil.getPrimitiveIntType().getArray(), JModifier.PRIVATE | JModifier.STATIC | JModifier.SYNTHETIC); 
<|del|> 
 private void fillSyntheticSwitchMapInitializer(@Nonnull TransformationRequest 
 public JDefinedClass getOrCreateRelatedSyntheticClass( @Nonnull JDefinedEnum enumType, boolean createIfNotExist) { 
 return cls.getName().startsWith(SyntheticSwitchmapClassNamePrefix); 
 sourceSyntheticClass = initializeSyntheticClass(enclosingPackage, syntheticClassShortName); 
<|del|> 
 syntheticClassShortName, JModifier.PUBLIC | JModifier.FINAL | JModifier.SYNTHETIC, enclosingPackage, NopClassOrInterfaceLoader.INSTANCE); 
 private static final RuleBasedCollator collator = (RuleBasedCollator) Collator.getInstance(Locale.US); 
 private final com.ibm.icu.text.CollationElementIterator icuIterator; 
 /// CHECK-DAG: ArrayGet loop:{{B\d+}} /// CHECK-DAG: ArraySet loop:{{B\d+}} 
 * Whether the updater will allow patch updates to cross major version boundaries. 
<|del|> 
 throw new java.io.IOException("absolutePath is not readable"); 
 throw new ServerException("Problem while opening admin port", e); 
 logger.log(Level.SEVERE, "Cannot close the service processor: ", stopException); 
 logger.log(Level.SEVERE, "Cannot close the admin processor: ", stopException); 
 @NotNull protected TimelineData myTimelineData; 
 int apiLevel = client.getDevice().getApiLevel(); if (apiLevel <= 0) { 
 int apiLevel = client.getDevice().getApiLevel(); if (apiLevel <= 0) { 
 return "M".equals(versionString) ? M_API_LEVEL : 22; 
 public static Document parseVdStringIntoDocument(@NotNull String xmlFileContent, @Nullable StringBuilder errorLog) { 
 errorLog.append("Invalid size " + myContext.getVectorWidth() + " X " + myContext.getVectorHeight()); 
<|del|> 
 String getVectorWidth(); 
 String getVectorHeight(); 
 * If one incoming generator is null, then a new one will be generated * inside this function. * There is no functional difference if the generators are null * or not. 
 return true; 
 if (!mHasFeature | !mHasNfcFeature) { 
 if (!mHasFeature | !mHasNfcFeature) { 
 "testNfcShareDisabled", mUserId)); assertTrue(runDeviceTestsAsUser(MANAGED_PROFILE_PKG, ".NfcTest", "testNfcShareEnabled", 0)); 
 /// CHECK: If /// CHECK: Goto 
 @Nullable public static DependencyManager getDependencyManager(@NotNull Project project) { if (Projects.isBuildWithGradle(project)) { return GradleDependencyManager.getInstance(project); 
 @Nullable public static DependencyManager getDependencyManager(@NotNull Project project) { if (Projects.isBuildWithGradle(project)) { return GradleDependencyManager.getInstance(project); 
 return null; // other implementations here 
 @NotNull public abstract List<String> findMissingDependencies(@NotNull Module module, @NotNull Iterable<String> androidDependencies); 
 public List<String> findMissingDependencies(@NotNull Module module, @NotNull Iterable<String> androidDependencies) { 
 @Nullable final PsiReference reference, 
 @Nullable final PsiReference reference, 
 private void createOrUpdateSyntheticInitializer(@Nonnull TransformationRequest transformRequest) { 
 * switchmap = new int[enum.values().length]; * switchmap[Enum1.ordinal()] = compileTimeOrdinal1; * switchmap[Enum2.ordinal()] = compileTimeOrdinal2; * ... * return switchmap; 
 @Nonnull LocalVarCreator localVarCreator, @Nonnull JBlock initializerMethodBlock) { 
 JLocal switchmapLocal = createSwitchmapArrayStatement(localVarCreator, transformRequest, initializerMethodBlock, valuesLength); 
 private void createStatementsInitializingSwitchMapArrayField( 
 private JLocal createSwitchmapArrayStatement( @Nonnull LocalVarCreator localVarCreator, @Nonnull TransformationRequest transformRequest, @Nonnull JBlock block, @Nonnull JExpression capacityExpr) { 
 SourceInfo.UNKNOWN, JBinaryOperator.ASG, new JLocalRef(SourceInfo.UNKNOWN, switchMapLocal), 
<|del|> 
 if (optimizationStrategy == SwitchEnumOptStrategy.FEEDBACK) { assert enumUsageMarker != null; 
 final boolean isValidSerial = androidSerialsEnv != null && !androidSerialsEnv.isEmpty(); 
 final boolean isValidSerial = androidSerialsEnv != null && !androidSerialsEnv.isEmpty(); 
<|del|>
<|del|> 
<|del|> 
 File f = new File(PathManager.getTempPath(), "AndroidStudio." + UUID.randomUUID().toString()); f.createNewFile(); 
 * @return this returns a string representing the content * * @throws IOException thrown if the content can not be created 
 * @return this returns a string representing the content * * @throws IOException thrown if the content can not be created 
import com.android.ide.common.util.AssetUtil.Effect; import com.android.ide.common.util.AssetUtil.FillEffect; 
 sb.append(" can throw"); 
 assertTrue(parts.length >= 7); assertNotNull(parts[4]); // Kernel wakelock 
<|del|> 
 * Copyright (C) 2015 The Android Open Source Project 
 if (!mHasFeature || !mHasNfcFeature) { 
 return Preconditions.checkNotNull(super.getVariantName(), "Test server task must have a variant name."); 
 task.setOutputFile(scope.getMockableAndroidJarFile()); 
 public List<String> getLibraries() { return myLibraries; } 
 return myLibrariesUsed; 
 myLibrariesUsed.addAll(item.getLibraries()); 
 @NonNull private final Disposable myDisposable; 
 private boolean checkForNewMissingDependencies() { Module module = getModule(); 
 private boolean checkForNewMissingDependencies() { Module module = getModule(); 
 return content instanceof NlPaletteItem ? (NlPaletteItem)content : null; 
<|del|> 
 throw new IllegalStateException("Unexpected error: Build API level '" + apiString + "' is not an integer: "); 
 @NotNull ThemeEditorContext context) { 
 myAttributesSorter.setSortKeys(ImmutableList.of(new RowSorter.SortKey(0, SortOrder.ASCENDING))); 
 myAttributesSorter.setSortKeys(ImmutableList.of(new RowSorter.SortKey(0, SortOrder.ASCENDING))); 
<|del|>
public interface AndroidModel { /** * @return the currently selected main Android artifact produced by this Android module. */ 
public interface AndroidModel { /** * @return the currently selected main Android artifact produced by this Android module. */ 
 /** * @return the current package name/application ID. * NOTE: Formerly computePackageName. * Question: relationship to * {@link IdeaAndroidProject#overridesManifestPackage()}? One goes through artifact, the * other through product flavors. */ 
 /** * @return all the application IDs of artifacts this Android module could produce. * {@link org.jetbrains.android.actions.AndroidProcessChooserDialog#collectApplicationIds(IdeaAndroidProject, Set)} */ 
 Collection<String> getAllApplicationIds(); 
<|del|> 
 assertTrue(parts.length >= 7); assertNotNull(parts[4]); // Kernel wakelock 
 assertTrue(parts.length >= 7); assertNotNull(parts[4]); // Kernel wakelock 
// test that it does inline it. 
// test that it does inline it. 
<|del|> 
 return getName().compareTo(that.getName()); 
 String getPackageName(); 
 * TODO: To be build-system-agnostic, simplify source provider usage. * {@link org.jetbrains.android.facet.AndroidFacet#getMainSourceProvider()} 
<|del|> 
 List<SourceProvider> getActiveSourceProviders(); 
 */ @Deprecated 
 */ @Deprecated 
 */ @Deprecated 
<|del|> 
 if (mIdle) { 
 // do nothing 
 if (skin.getPath().endsWith(File.separator + path.getPath())) { 
<|del|> 
<|del|> 
<|del|> 
 public static final String EXTRA_USER_REQUESTED_SHUTDOWN = "android.intent.extra.USER_REQUESTED_SHUTDOWN"; 
<|del|>
 IDNA converter = com.ibm.icu.impl.UTS46.getUTS46Instance(flags); StringBuilder result = new StringBuilder(); converter.nameToASCII(input, result, new IDNA.Info()); return result.toString(); 
 IDNA converter = com.ibm.icu.impl.UTS46.getUTS46Instance(flags); StringBuilder result = new StringBuilder(); converter.nameToASCII(input, result, new IDNA.Info()); return result.toString(); 
<|del|> 
<|del|> 
 throw new IllegalArgumentException(); 
<|del|> 
 resourceDialog = new CreateXmlResourceDialog(module, ResourceType.STYLE, themeName, " ", false); 
 Module module = myContext.getCurrentContextModule(); 
 Module module = myContext.getCurrentContextModule(); 
 final ThemeResolver resolver = new ThemeResolver(style.getConfiguration()); return Collections2.filter(ThemeEditorUtils.resolveAllAttributes(style, resolver), new Predicate<EditedStyleItem>() { 
 // Rules class is used by Gradle's component model. Suppress unused warning. @SuppressWarnings("unused") 
 @NonNull private static String getAssembleTaskName(@NonNull Named dimension) { 
 if (mDisallowByPolicy) { mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent, UserManager.DISALLOW_OUTGOING_BEAM); } 
 // We *should* attempt to look in the extended info if the local file header / central 
 String[] command = Splitter.on(" +").trimResults().omitEmptyStrings().splitToList(cli) .toArray(new String[0]); 
 private static final String LongerPrefix = "-get"; 
 return NamingTools.getStrictNonSourceConflictingName("get" + enumName + Suffix); 
 NamingTools.getStrictNonSourceConflictingName(enumName + "SwitchesValues"); 
 /// CHECK: <<t1:i\d+>> Add [<<Arg>>,<<Const1>>] {{.*->r([5-8]|10|11)}} 
 String defaultColor = UIUtil.isUnderDarcula() ? "#A5D6A7" : "#4CAF50"; append(" Default", new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, Color.decode(defaultColor)), true); 
 try { File f = new File(PathManager.getTempPath(), String.format("%s.%s", System.getProperty(PLATFORM_PREFIX_PROPERTY), UUID.randomUUID().toString())); if (f.createNewFile()) { 
 this.markers = markers; 
 String attributeGroup = args[i + 1]; 
 /** * Creates a Bitmap image that contains red on white text with a specified margin. * @param text Text to be displayed in the image. * @return A Bitmap image with the above specification. */ 
 mTests.add(mWorkAppVisibleTest); mTests.add(mWorkNotificationBadgedTest); 
 * It is intended to be used from the platform, which cannot have any dependencies on the android plugin. 
 String desc = prefix + t.getClass().getSimpleName() + sourceLocation; 
 private static List<IdeaSourceProvider> createAll(@NotNull List<SourceProvider> providers) { 
 addCustomExtensionInvocations.add(ext_type); 
 * Returns all the style attributes and its values. For each attribute, multiple {@link ConfiguredElement} can be returned 
// test that it does not inline it. 
 public static final AtomicLong ourStudioActionCount = new AtomicLong(0); 
 private static final Map<Class<?>,Boolean> ourActionsExcludedFromTracking; static { ourActionsExcludedFromTracking = new IdentityHashMap<Class<?>, Boolean>(); ourActionsExcludedFromTracking.put(BackspaceAction.class, Boolean.TRUE); } 
 * Configuration Action for a JavaCompile task. 
 Preconditions.checkState(file != null); return !FN_FRAMEWORK_LIBRARY.equals(file.getName()); 
 return scope.getGlobalScope().getProject().files(classpaths); 
 return scope.getGlobalScope().getProject().files(classpaths); 
<|del|> 
 myGraphicsLayoutRenderer.setSize(width, 1); 
 myGraphicsLayoutRenderer.setSize(width, 1); 
<|del|> 
 return ""; 
 return ""; 
<|del|> 
 JLabel label = new JLabel(String.format(ThemeEditorConstants.ATTRIBUTE_LABEL_TEMPLATE, ColorUtil.toHex(ThemeEditorConstants.RESOURCE_ITEM_COLOR), "Theme parent")); 
 hasNotItem = ConfiguredElement.create(defaultConfig, 
 * @return the version code associated with the merged flavor of the selected variant, or {@code null} if none have been set. 
 * @return the version code associated with the merged flavor of the selected variant, or {@code null} if none have been set. 
<|del|> 
<|del|> 
 return currentTheme == null ? false : isAppCompatTheme(currentTheme); 
 private static final int PADDING = JBUI.scale(2); 
 append(" Default", new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, new JBColor(0xFF4CAF50, 0xFFA5D6A7)), true); 
 @NotNull ItemHoverListener itemHoverListener, 
 public final boolean checkJni; 
<|del|> 
 return new ValidationInfo(String.format(API_ERROR_TEXT, alphaApi), component.getAlphaComponent()); 
<|del|> 
<|del|> 
<|del|> 
 /** * Action to perform in dumb mode */ 
 * THIS FILE WAS GENERATED BY codergen. EDIT WITH CARE. 
 * THIS FILE WAS GENERATED BY codergen. EDIT WITH CARE. */ package com.android.tools.idea.editors.gfxtrace.service; 
public final class ServiceClientRPC extends ServiceClient { 
 * THIS FILE WAS GENERATED BY codergen. EDIT WITH CARE. */ package com.android.tools.idea.editors.gfxtrace.service; 
 return (myStart >= 0) && (myStart < myEnd); 
 void itemHovered(@NotNull String name); 
<|del|> 
 long subGroupFirst = subGroup.getRange().getStart(); 
 if (pos1 != null) { 
 if (pos2 != null) { 
 return ((EditedStyleItem)o1).compareTo((EditedStyleItem)o2); 
<|del|> 
 ChooseResourceDialog dialog = ThemeEditorUtils.getResourceDialog(myItem, myContext, allowedTypes); dialog.enableColorSuggestions(primaryColor, myItem.getName()); 
 @Nullable ResourceHelper.StateList stateList) { 
 // Monochromatic 
 // Analogous 
<|del|> 
 @Nullable String attributeName, @Nullable Color primaryColor) { 
<|del|> 
 public static final String PRIMARY_MATERIAL_ATTR = "colorPrimary"; public static final String PRIMARY_DARK_MATERIAL_ATTR = "colorPrimaryDark"; public static final String ACCENT_MATERIAL_ATTR = "colorAccent"; 
 if (suggestedColors != null) { 
 @NotNull private ServiceClient myClient; 
 * In server mode this is the data to be sent. * It should be a TLS encoded {@code SignedCertificateTimestampList} as * described by RFC6962 section 3.3.1. 
 * {@link sctExtensionData} is not null and the client has requested it. 
<|del|> 
<|del|> 
 throw new IllegalStateException("Cannot set SCT extension data in client mode."); 
 ClientHooks clientHooks = new ClientHooks(); ServerHooks serverHooks = new ServerHooks(); 
 float lastSampleTime = lastSample != null ? lastSample.time : 0.0f; float[] lastValues = lastSample != null ? lastSample.values : new float[streamSize]; assert streamSize == lastValues.length; float period = time - lastSampleTime; 
 float lastSampleTime = lastSample != null ? lastSample.time : 0.0f; float[] lastValues = lastSample != null ? lastSample.values : new float[streamSize]; assert streamSize == lastValues.length; float period = time - lastSampleTime; 
 // Gets every stream's ending time point and ending value. float[] endTimes = new float[streamSize]; float[] endValues = new float[streamSize]; 
 float[] sampleValues = new float[streamSize]; 
 sampleValues[j] = lastValues[j] - (lastValues[j] - endValues[j]) * sampleTime / endTimes[j]; if (sampleValues[j] < 0) { sampleValues[j] = 0.0f; 
 sampleValues[j] = lastValues[j] - (lastValues[j] - endValues[j]) * sampleTime / endTimes[j]; if (sampleValues[j] < 0) { sampleValues[j] = 0.0f; 
 } Sample[] samples = new Sample[sampleList.size()]; return sampleList.toArray(samples); 
 switch (capability) { case CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR: manualSensor = true; break; case CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS: readSensorSettings = true; break; default: break; 
 fireTableCellUpdated(0, 0); 
 fireTableCellUpdated(0, 0); 
 fireTableCellUpdated(0, 0); 
 * Class that wraps the display text of a variant and the folder configuration associated to it. 
 * Class that contains any object that has a {@link FolderConfiguration} associated. This class is used to contain 
 private ConfiguredElement(@NotNull FolderConfiguration folderConfiguration, @NotNull T value, @NotNull ThemeEditorStyle sourceStyle) { 
<|del|> 
 public static final String CURRENT_VARIANT_TEMPLATE = "<html><nobr><font color=\"#%1$s\">%2$s"; 
 public static final String ATTRIBUTE_LABEL_TEMPLATE = "<html><nobr><b><font color=\"#%1$s\">%2$s"; 
<|del|>
<|del|> 
 return "M".equals(versionString) ? MSampler.MIN_API_LEVEL : 22; 
 public static final int SAMPLE_BUFFER_SIZE = 2048; public static final int MIN_API_LEVEL = 16; 
 public static final int SAMPLE_BUFFER_SIZE = 2048; public static final int MIN_API_LEVEL = 16; 
 * Get the time the app took to issue draw commands. 
 return GpuSampler.decodeApiLevel(client) >= MIN_API_LEVEL; 
 void setClient(@Nullable Client client); 
 for (GfxinfoHandler handler : myGfxinfoHandlers) { if (handler.accept(client)) { createNewTimelineData = true; break; } 
 // Add 'null' as a marker for "all the rest of the objects". 
 if (hasNonZeroEntry(snapshot, heap, config, elements)) { heaps.add(heap); 
 printClassInstanceFields(doc, (ClassInstance)inst); 
 printArrayElements(doc, (ArrayInstance)inst); 
<|del|> 
 // Returns the stack depth of this site in the stack whose id is returned // by getStackId(). public int getStackDepth() { return mStackDepth; } 
<|del|> 
 private RuleBasedCollator traditionalSpanishColl; 
 // TODO: Once ICU4J is exposed, make this point directly to ICU4J's constant. 
 return com.ibm.icu.text.CollationElementIterator.primaryOrder(order); 
 return (short) com.ibm.icu.text.CollationElementIterator.secondaryOrder(order); 
 return (short) com.ibm.icu.text.CollationElementIterator.tertiaryOrder(order); 
 // TODO: when ICU4J is exposed update this constant to the ICU4J equivalent. 
 com.ibm.icu.text.Collator icuColl; 
 Collator(com.ibm.icu.text.Collator icuColl) { 
 ParseException pe = new ParseException(e.getMessage(), -1); pe.initCause(e); throw pe; 
<|del|> 
 RuleBasedCollator(com.ibm.icu.text.RuleBasedCollator wrapper) { super(wrapper); 
 Assert.assertEquals(Long.numberOfLeadingZeros(1L << (Long.SIZE-1)), 0); Assert.assertEquals(Long.numberOfLeadingZeros($noinline$return_long_zero()), Long.SIZE); 
 private com.ibm.icu.text.RuleBasedCollator collAsICU() { 
<|del|> 
 return collAsICU().getRules(); 
 return icuColl.hashCode(); 
<|del|> 
<|del|> 
 clone.icuColl = (com.ibm.icu.text.Collator) icuColl.clone(); 
 com.ibm.icu.text.Collator.getInstance(locale)); 
<|del|> 
 return new CollationElementIterator(collAsICU().getCollationElementIterator(source)); 
 return new CollationKeyICU(source, icuColl.getCollationKey(source)); 
 if (startValues[i] * maxInterval / 2 < areas[i]) { nonZeroIntervalsForStreams[i] = maxInterval; endValuesForStreams[i] = areas[i] * 2 / maxInterval - startValues[i]; 
 nonZeroIntervalsForStreams[i] = maxInterval; endValuesForStreams[i] = 0; 
 // startValues[i] should be non-zero to be greater than areas[i]. nonZeroIntervalsForStreams[i] = areas[i] * 2 / startValues[i]; endValuesForStreams[i] = 0; 
 for (float interval : ascendingIntervals) { 
 sampleList.add(new Sample(interval + startTime, type, sampleValues)); if (interval == maxInterval) { break; } 
public class InvokeMethodAfterMultipleThreadSuspensionTest extends JDWPInvokeMethodSuspendedTwiceTestCase { 
public class NewInstanceAfterMultipleThreadSuspensionTest extends JDWPInvokeMethodSuspendedTwiceTestCase { 
<|del|> 
 assertTrue("Invalid exception object id", invokeNewObject.objectID != 0); 
 assertTrue("Invalid exception object id", invokeNewObject.objectID != 0); 
public class InvokeMethodAfterMultipleThreadSuspensionTest extends JDWPInvokeMethodSuspendedTwiceTestCase { 
<|del|> 
 // Send command but does not read the reply yet. That invoked method starts another thread 
 // Check that we do not receive any reply. 
 catch (InterruptedException e) { 
 return Math.max(height/reqHeight, width/reqWidth) + 1; 
 InputStream input = getActivity().getContentResolver().openInputStream(uri); BitmapFactory.Options options = new BitmapFactory.Options(); 
 InputStream input = getActivity().getContentResolver().openInputStream(uri); BitmapFactory.Options options = new BitmapFactory.Options(); 
 }catch(IOException e){ Log.e(TAG, "Cannot get image.", e); Toast.makeText(getActivity(),R.string.provisioning_byod_capture_image_error, Toast.LENGTH_SHORT).show(); 
 * Copyright (C) 2015 The Android Open Source Project 
 if (Math.abs((v - pi2 * x)/v) > .000001) { 
 * {@link #cancelCaptureFile(CaptureHandle) finalizeCaptureOnError}, * and {@link #finalizeCaptureFile(CaptureHandle, FutureCallback, Executor) finalizeCapture} to work with this handle. * <p/> * MUST be called on event dispatch thread. 
 myAsyncWriterDelegate.queueWrite(captureHandle, Arrays.copyOf(data, data.length)); 
 public void cancelCaptureFile(@NotNull final CaptureHandle captureHandle) { finalizeCaptureFileAsynchronous(captureHandle, null, null); 
 public void notifyCaptureReady(@NotNull final Capture capture) { 
 static final long sInitialValue_int64_t = 0x12345678abcdef1L; 
 public void testLauncherCallbackPackageRemovedMainUser() throws Exception { 
 native void rsnScriptReduce(long con, long id, int slot, long ain, long aout, 
 } myWriteQueue.clear(); 
 return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" .getBytes(StandardCharsets.US_ASCII); 
 // Bit masks for the 4 output 6-bit values from 3 input bytes. 
 private Base64() {} 
 int outputLen = computeEncodingOutputLen(len); 
 byteTripletAsInt |= in[i + 1] & 0xff; 
 byteTripletAsInt |= in[i + 2] & 0xff; 
 (byteTripletAsInt & FIRST_OUTPUT_BYTE_MASK) >>> 18]; 
 return new String(output, StandardCharsets.US_ASCII); 
 // Need 3 6-bit characters as to express the last 16 bits, plus 1 padding. outputLen += 4; 
 try { while (pos[0] < inLength) { int byteTripletAsInt = 0; 
 private static final byte WHITESPACE_AS_BYTE = -2; private static byte base64AlphabetToNumericalValue(byte c) throws InvalidBase64ByteException { 
 } if (c == '/') { 
 private boolean mHasLiveTvFeature; 
 int g = myField3; // ESI (by spilling ESI-EDI, see below) 
 int g = myField3; // ESI (by spilling ESI-EDI, see below) 
 if (result.diffPercent >= 0.0001 && result.aveDiff > 5) { 
 if (id > 0 && Resources.resourceHasPackage(id) && r != null) { 
<|del|> 
 container = primaryContainer; 
 container = registry.get(value); if (container == null) { logger.log(Level.FINE, "No route for '" + parameter + "' with value '" + value + "'"); container = primaryContainer; } 
<|del|> 
 throw new ConfigurationException("'" + getNewName() + "' is not a valid identifier"); 
 throw new ConfigurationException("'" + getNewName() + "' is not a valid identifier"); 
 Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartService " + name); 
 Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "OnBootPhase " + phase); 
 private static final float SENSITIVITY_ERROR_MARGIN_RATE = 0.03f; // 3%, Approximation. 
 private static final float SENSITIVITY_ERROR_MARGIN_RATE = 0.03f; // 3%, Approximation. 
 long expTimeDelta = request - result; 
 float sensitivityDelta = (float)(request - result); float sensitivityErrorMargin = request * SENSITIVITY_ERROR_MARGIN_RATE; 
<|del|> 
<|del|>
 .put(PERMISSION_CAMERA, HARDWARE_FEATURE_CAMERA) .put(PERMISSION_RECORD_AUDIO, HARDWARE_FEATURE_CAMERA) 
<|del|> 
 if (!mHasLeanbackSupport && context.isEnabled(MISSING_LEANBACK_SUPPORT) && mManifestLocation != null) { 
 UNSUPPORTED_TV_HARDWARE, location, "Expecting `" + PREFIX_ANDROID + ATTRIBUTE_REQUIRED + "=\"" + false + "\"` for this hardware feature that is unsupported by TV."); 
 if (NODE_CATEGORY.equals(intentFilterChild.getNodeName()) && CATEGORY_LEANBACK_LAUNCHER .equals(intentFilterChild.getAttributeNS(ANDROID_URI, ATTR_NAME))) { 
 if (NODE_CATEGORY.equals(intentFilterChild.getNodeName()) && CATEGORY_LEANBACK_LAUNCHER .equals(intentFilterChild.getAttributeNS(ANDROID_URI, ATTR_NAME))) { 
 private static final StatisticId<Counter> SIMPLIFIED_USE_DEF_SYNTH = new StatisticId<Counter>( 
 for (JVariableRef varRefOfa : varsUsedBys1.toArray(new JVariableRef[varsUsedBys1.size()])) { List<DefinitionMarker> defsOfa = UseDefHelper.getUsedDefinitions(varRefOfa); 
 // Setting a null element is OK. ReplyPacket checkedReply = setArrayValue(arrayID, VALID_INDEX, JDWPTestConstants.NULL_OBJECT_ID); checkReplyPacket(checkedReply, THIS_COMMAND_NAME, JDWPConstants.Error.NONE); 
 Dex merged = new DexMerger(dexes.toArray(new Dex[dexes.size()]), CollisionPolicy.FAIL).merge(); return merged.getBytes(); 
 i + 1, 
 * Merges already-sorted sections, reading one value from each dex into memory 
 TreeMap<T, List<Integer>> values = new TreeMap<T, List<Integer>>(); 
 private int readToBuffer(Dex.Section in, IndexMap indexMap, int index, TreeMap<T, List<Integer>> values, int dex) { 
 private int readToBuffer(Dex.Section in, IndexMap indexMap, int index, TreeMap<T, List<Integer>> values, int dex) { 
 l.add(new Integer(dex)); 
 if (p.mCerts.isEmpty()) { 
 public DocString append(String text) { 
 while (i < inLength) { c = base64AlphabetToNumericalValue(in[i]); if (c != WHITESPACE_AS_BYTE && c != PAD_AS_BYTE) { return null; } 
 /** * The field on TestGroup which has the list of classes in it. */ private static final Field classesToTest; 
 /** * The field on TestGroup which has the list of classes in it. */ private static final Field classesToTest; 
<|del|> 
 static { // Find the field, and complain if it is not where we expected it to be. 
 public static Set<IcuTestWrapper> findWrapBaseTests() { return findWrapBaseTests(new String[]{"com.ibm.icu.dev.test.TestAll"}); 
 * class). This will return a set of individual tests, any TestGroup's found will be recursively * processed to extract base classes out of them, and those tests wrapped for running. 
 public static Set<IcuTestWrapper> findWrapBaseTests(String[] classNames) { 
 private static final class FailTest implements IcuTestWrapper { 
<|del|> 
 private final String name; 
public final class IcuTestRunner extends MonitoringInstrumentation { 
public final class IcuTestRunner extends MonitoringInstrumentation { 
 if (debug) { Debug.waitForDebugger(); } 
 if (performHomogeneousSpaceCompact()) { 
 if (!performHomogeneousSpaceCompact()) { 
 // We are at a pad character, consume and look for the second one. 
<|del|> 
 while (pos[0] < inLength) { c = base64AlphabetToNumericalValue(in[pos[0]]); if (c != WHITESPACE_AS_BYTE) { return c; } 
 while (pos[0] < inLength) { c = base64AlphabetToNumericalValue(in[pos[0]]); if (c != WHITESPACE_AS_BYTE) { return c; } 
 * Calculates the numeric value (6-bit, 0 <= x <= 63) of the next Base64 encoded byte in 
<|del|> 
<|del|> 
<|del|> 
 out.write(base64Encoder.encode(key.getEncoded())); out.write(EOL); 
<|del|> 
 currentUser = getCurrentUser(serverDir); 
 throw new IOException("'" + file.getPath() + "' is not owned by '" + currentUser + "' but by '" + ownerAttribute.getOwner().getName() + "'"); 
 throw new IOException("'" + file.getPath() + "' must have permission " + PosixFilePermissions.toString(check) + " but have " + PosixFilePermissions.toString(permissions)); 
<|del|> 
 Context ctx = getContext(); File pocdir = new File(ctx.getFilesDir(), "pocs"); pocdir.mkdir(); 
 String name = ctx.getResources().getResourceEntryName(rid); File pocfile = new File(pocdir, name + ".mp4"); extractRaw(ctx, rid, pocfile); 
 boolean safe = stagefrightTest(pocfile.getPath()); 
 boolean safe = stagefrightTest(pocfile.getPath()); 
 // Unlikely to return if failed, but check just in case 
 // Unlikely to return if failed, but check just in case 
<|del|> 
 "insecure network traffic due to trusting arbitrary TLS/SSL " + "certificates presented by peers"); 
public class UnsafeBroadcastReceiverDetector extends Detector implements ClassScanner, XmlScanner { 
 "BroadcastReceivers that declare an intent-filter for a protected-broadcast action " + "string must check that the received intent's action string matches the expected " + 
 "BroadcastReceivers that declare an intent-filter for a protected-broadcast action " + "string must check that the received intent's action string matches the expected " + 
 "BroadcastReceivers that declare an intent-filter for a protected-broadcast action " + "string must check that the received intent's action string matches the expected " + 
 "BroadcastReceiver for SMS_DELIVER or SMS_RECEIVED doesn't require that the caller " + "has BROADCAST_SMS permission", 
 private static final String[] PROTECTED_BROADCASTS = new String[] { 
 private Set<String> receiversWithProtectedBroadcastIntentFilter = new HashSet<String>(); 
<|del|> 
 // Search for "void onReceive(android.content.Context, android.content.Intent)" method 
 if (!"onReceive".equals(method.name) || !"(Landroid/content/Context;Landroid/content/Intent;)V".equals(method.desc)) { 
 if ("android/content/Intent".equals(node.owner) && "getAction".equals(node.name)) { 
 context.report(ACTION_STRING, method, null, location, report); 
 context.report(ACTION_STRING, method, null, location, report); 
 if (TAG_RECEIVER.equals(tag)) { 
 name = name.replace('.', '/'); 
 else if (PROTECTED_BROADCAST_SET.contains(actionName)) { receiversWithProtectedBroadcastIntentFilter.add(name); 
 assertEquals("ab%2F$%C4%82%2512", CODEC.encode("ab/$\u0102%12", StandardCharsets.UTF_8)); 
 } catch (IOException | KeyStoreException | NoSuchAlgorithmException | CertificateException 
<|del|> 
 if (width * height * 4 > bufferValues.length) { // Wrong Bitmap.Config 
 else if (width * height * 4 != bufferValues.length) { // Wrong Bitmap.Config 
<|del|> 
<|del|> 
 ClassInstance result = (ClassInstance)fieldValue; String className = result.getClassObj().getClassName(); if ("android.graphics.Bitmap".equals(className)) { return result; } 
 ClassInstance result = (ClassInstance)fieldValue; String className = result.getClassObj().getClassName(); if ("android.graphics.drawable.BitmapDrawable$BitmapState".equals(className)) { return result; } 
<|del|> 
 "This check looks for X509TrustManager implementations whose `checkServerTrusted` or " + "`checkClientTrusted` methods do nothing (thus trusting any certificate chain) " + 
 "Unsafe Protected BroadcastReceiver", 
 private Set<String> mReceiversWithProtectedBroadcastIntentFilter = new HashSet<String>(); 
 if (permission == null || permission.isEmpty()) { 
<|del|> 
 logger.log(Level.SEVERE, "Exception while writing response: ", e); 
 int index = builder.indexOf(inputEol); while (index >= 0) { 
<|del|> 
 // Fetch the next value of the dexes we just polled out offsets[dex] = readIntoMap(dexSections[dex], sections[dex], indexMaps[dex], indexes[dex], values, dex); 
<|del|> 
 * Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 OpenSSLX509Certificate copy = new OpenSSLX509Certificate(NativeCrypto.X509_dup(mContext)); NativeCrypto.X509_delete_ext(copy.getContext(), oid); return copy; 
 cert.getTBSCertificate())); 
 public OpenSSLX509Certificate withDeletedExtension(String oid) { OpenSSLX509Certificate copy = new OpenSSLX509Certificate(NativeCrypto.X509_dup(mContext)); NativeCrypto.X509_delete_ext(copy.getContext(), oid); return copy; 
 // values contains one value from each dex, sorted for fast retrieval of // the smallest value. The list associated with a value has the indexes // of the dexes that had that value. 
 offsets[i] = readIntoMap( dexSections[i], sections[i], indexMaps[i], indexes[i], values, i); 
 offsets[dex] = readIntoMap(dexSections[dex], sections[dex], indexMaps[dex], indexes[dex], values, dex); 
 private int readIntoMap(Dex.Section in, TableOfContents.Section section, IndexMap indexMap, int index, TreeMap<T, List<Integer>> values, int dex) { 
 SortableType sortableType = indexMap.adjust( new SortableType(buffer, indexMap, classDef)); 
 * This test tries to merge given dex files at random, a first pass at 2 by 2, followed by * a second pass doing multi-way merges. 
 try { commandOut.close(commandStatus); } catch (IOException e) { logger.log(Level.SEVERE, "Exception while writing response: ", e); response.setStatus(Status.INTERNAL_SERVER_ERROR); return; 
 System.out.println("Byte length=" + length + " ns/op=" + (double) elapsed / reps); checkEq(value, reps * (long) (bytes[0] + bytes[length - 1])); 
 System.out.println("Short length=" + length + " ns/op=" + (double) elapsed / reps); checkEq(value, reps * (long) (shorts[0] + shorts[length - 1])); 
 if (findEntryWithDirectoryFallback(jarFile, entryName) != null) { 
<|del|> 
 // Cases that actually go out of bounds. These test cases // ensure the exceptions are thrown at the right places. 
 private static void lowerOOB(int[] x) { 
 System.out.println("Time for " + ITERATIONS + " x old hash processing: " + oldTime.toString()); System.out.println("Time for " + ITERATIONS + " x new hash processing: " + newTime.toString()); 
 // Reference type propagation (RTP) used to assume that if a class is final, // then the type must be exact. This does not hold for arrays which are always 
 boolean expectTrue; 
 // path unconditionally save its live registers. 
 System.err.println("NOTE: verifying using public key from " + certPath); 
public class SerializationUtils { private SerializationUtils() {} 
 * @throws SerializationException if EOF is encountered, or if {@code width} is negative or * greater than 4 
 return Streams.readFully(openTestFile(name)); 
 if (knownLogs == null) { knownLogs = KnownLogs.DEFAULT_KNOWN_LOGS; } for (CTLogInfo log: knownLogs) { if (Arrays.equals(logId, log.getID())) { return log; } } return null; 
 * @param suspensionMethodInfo * an instance providing the local variables (and their value) for the method * used for suspension. This is a special method because we do not update variables, * we only suspend the current thread. 
<|del|> 
 public static void accessMethod() { 
 Class<?> testClass = null; 
 * <ANDROID_HOST_OUT>/bin/aapt * <ANDROID_HOST_OUT>bin/adb * <ANDROID_HOST_OUT>/bin/dx * <OUT_DIR>/target/common/obj/JAVA_LIBRARIES/core-libart_intermediates/classes.jar 
 String outDir = System.getenv("OUT_DIR"); if (outDir == null || outDir.length() == 0) { outDir = "./out"; 
 vmCommand.add(hostOut + "/bin/" + run.vmCommand); 
 requests.add(Request.aClass(testClass)); } else { System.err.println("Error: wrong format, '#' found more than once in '" + test + "'"); System.exit(ExitStatus.BAD_ARGUMENTS); 
 requests.add(Request.aClass(testClass)); } else { System.err.println("Error: wrong format, '#' found more than once in '" + test + "'"); System.exit(ExitStatus.BAD_ARGUMENTS); 
 Serialization.writeNumber(output, version, CTConstants.VERSION_LENGTH); Serialization.writeNumber(output, CTConstants.SIGNATURE_TYPE_CERTIFICATE_TIMESTAMP, 
 Serialization.writeNumber(output, timestamp, CTConstants.TIMESTAMP_LENGTH); certEntry.encode(output); Serialization.writeVariableBytes(output, extensions, CTConstants.EXTENSIONS_LENGTH_BYTES); 
 } catch (NoSuchAlgorithmException e) { // SHA-256 is guaranteed to be available 
 public CTResults verifySignedCertificateTimestamps(OpenSSLX509Certificate[] chain, byte[] tlsData, byte[] ocspData) throws CertificateEncodingException { List<SignedCertificateTimestamp> scts = new ArrayList(); 
 List<SignedCertificateTimestamp> embeddedScts = getSCTsFromX509Extension(chain[0]); if (embeddedScts != null) { scts.addAll(embeddedScts); 
 } /** * Get the AhatSnapshot for the test dump program. */ public AhatSnapshot getAhatSnapshot() { 
 // AccDefaultMethod conflicts with static_init, move it into another place 
 public void testStagefright_cve_2015_3867() throws Exception { doStagefrightTest(R.raw.cve_2015_3867); } 
 // May occur while trying to allocate the exception. 
 } catch (OutOfMemoryError ignored) { // An OOME may be thrown if allocating the InterruptedException failed. 
 testOatFilesUnloaded(getPid()); // Test that objects keep class loader live for sticky GC. testStickyUnload(constructor); 
 private static void stressTest(Constructor<?> constructor) throws Exception { 
<|del|> 
<|del|> 
<|del|> 
 private transient boolean hasValidCountry = false; 
 // TODO: Once there is a public API in ICU to get this data, use that instead of the impl // class. A ticket was filed requesting this: http://bugs.icu-project.org/trac/ticket/11915. 
<|del|> 
 private static final int IMAGE_THRESHOLD = 2; 
 private static int getAlphaScaledBlue(final int color) { return (color & 0x000000FF) * getAlpha(color) / 255; 
 return (color & 0xFF000000) >>> 24; 
 List<String> interfaces = classDef.getInterfaces(); 
 * @return A list of the interfaces that this class implements 
 @Nonnull @Override public ImmutableList<String> getInterfaces() { return interfaces; } 
<|del|> 
 hasValidCountry = country.length() == 0 || isValidBcp47Alpha(country, 2, 2) // Alpha 2 (ISO 3166-1) || isUnM49AreaCode(country); // Digit 3 (UN M.49) 
 hasValidCountry = country.length() == 0 || isValidBcp47Alpha(country, 2, 2) // Alpha 2 (ISO 3166-1) || isUnM49AreaCode(country); // Digit 3 (UN M.49) 
<|del|> 
 } if (issuerKeyHash != null && issuerKeyHash.length != CTConstants.ISSUER_KEY_HASH_LENGTH) { 
 public static CertificateEntry createForPrecertificate(OpenSSLX509Certificate leaf, OpenSSLX509Certificate issuer) throws CertificateException { 
 throw new SerializationException("Number too large, " + value + 
 // Java behaves weirdly if shifting by more than the variable's size if (shift < Long.SIZE) { 
 if (version != Version.V1.ordinal()) { 
 // We search the current class, its direct interfaces then its superclass 
 /// CHECK-START: int Main.whole_switch_dead(int) dead_code_elimination_final (after) /// CHECK-NOT: PackedSwitch public static int whole_switch_dead(int j) { 
 /// CHECK-START: int Main.constant_switch() dead_code_elimination_final (after) /// CHECK-NOT: PackedSwitch public static int constant_switch() { 
 public static int $inline$method() { 
 } public static void loadLibrary(String name) { System.loadLibrary(name); } 
 boolean isIKept = false; 
 boolean isIRenamed = false; 
 * Check that shrink keeps method that overrides a default method that is called 
 * Check that default method can be obfuscated. 
 * Check that default method can be obfuscated. 
 testCases.add(new TestCase("PackedSwitch key INT_MAX", "PackedSwitch", "packedSwitch_INT_MAX", new Object[]{123}, null, 123)); 
 throw new IllegalArgumentException("address or byteCount less than zero. address=" + address + " byteCount=" + byteCount); 
 int userId = UserHandle.USER_OWNER; 
 private boolean cancelled = false; private long scheduledExecutionTime = 0; private boolean scheduled = false; // Lock for protecting access to members. private final Object lock = new Object(); 
 public static int constantSwitch_InRange() { 
 public static int constantSwitch_AboveRange() { 
 public static int constantSwitch_BelowRange() { 
 * Copyright (C) 2015 The Android Open Source Project 
 /* LambdaTest.class, */ EcjInterfaceMethodsTest.class, StaticMethodTest.class, DefaultMethodTest.class 
 * JUnit test for compilation of static method. 
 /// CHECK-NOT: test /// CHECK: ReturnVoid 
 ((languageTag.length() == 3) || (languageTag.charAt(3) == '-'))) { 
 // TODO: Once there is a public API in ICU to get this data, use that instead of the impl // class. A ticket was filed requesting this: http://bugs.icu-project.org/trac/ticket/11915. 
 log == null) { 
<|del|> 
<|del|> 
 public SCTVerificationResult.Status verifySingleSCT(SignedCertificateTimestamp sct, CertificateEntry entry) { if (!Arrays.equals(sct.getLogID(), getID())) { return SCTVerificationResult.Status.UNKNOWN_LOG; } 
 // Leave precertEntry as null, we handle it just below 
 if (data == null) { return Collections.EMPTY_LIST; } 
 INVALID_SCT 
 INVALID_SCT 
 private OpenSSLX509Certificate CA; private OpenSSLX509Certificate CERT; private OpenSSLX509Certificate CERT_EMBEDDED; private CTVerifier CT_VERIFIER; 
 private OpenSSLX509Certificate CA; private OpenSSLX509Certificate CERT; private OpenSSLX509Certificate CERT_EMBEDDED; private CTVerifier CT_VERIFIER; 
 assertEquals(1, results.getInvalidSCTs().size()); assertEquals(SCTVerificationResult.Status.INVALID_SIGNATURE, results.getInvalidSCTs().get(0).status); 
<|del|> 
 * 0xc0 0x80 . This avoids the presence of bytes 0 in the output. * * @hide 
 if (shortLength && counter > 0xffff) { throw new UTFDataFormatException( "Size of the encoded string doesn't fit in two bytes"); 
 int i = in[offset] & 0xff; 
 if (!com.google.common.base.Strings.isNullOrEmpty(buildRoot)) { tmpJarPath = buildRoot + "/prebuilts/sdk/current/android.jar"; 
 outDir = "/out/"; 
 throw new RuntimeException("Couldn't derive Android home from " + dx); 
 throw new RuntimeException("Couldn't derive Android home from " + dx); 
 * Check that a ConditionalSelect is generated from a 'if' diamond on X86 * and X86-64. 
 compilerArgs.add( new File(TestsProperties.getJackRootDir(), "jack-tests/libs/jsr305-lib.jar").getPath()); 
 private static void addFilesToZip(ZipOutputStream zip, File file, String entryPath) throws IOException { 
 public static final int ISSUER_KEY_HASH_LENGTH = 32; 
 private final List<VerifiedSCT> validSCTs = new ArrayList(); private final List<VerifiedSCT> invalidSCTs = new ArrayList(); 
 public void addResult(VerifiedSCT result) { if (result.status == VerifiedSCT.Status.VALID) { 
 public List<VerifiedSCT> getValidSCTs() { 
 sctList = Serialization.readList(data, CTConstants.SCT_LIST_LENGTH_BYTES, CTConstants.SERIALIZED_SCT_LENGTH_BYTES); 
 property = Security.getProperty(propertyName + ".*"); 
 TestConnection connection = new TestConnection(new X509Certificate[] { CERT, CA }, CERT_KEY); connection.doHandshake(); 
 * if the field cannot be found. * @throws NullPointerException * if name is null. 
 } hasValidCountry = countryCode.length() == 0 || isValidBcp47Alpha(countryCode, 2, 2) // Alpha 2 (ISO 3166-1) || isUnM49AreaCode(countryCode); // Digit 3 (UN M.49) 
<|del|> 
 SSLParametersImpl sslParameters = getContextSSLParameters(context); 
 String pattern = outDir + "target/common/obj/JAVA_LIBRARIES/%s_intermediates/classes.jar"; 
 pattern = outDir + "host/common/obj/JAVA_LIBRARIES/%s_intermediates/classes" 
 // server-side only. SCT and OCSP data to send to clients which request it private byte[] sctExtension; private byte[] ocspResponse; 
<|del|> 
 boolean isPrivApp, 
 boolean isPrivApp, 
<|del|> 
<|del|> 
<|del|> 
 * Create an arbitrary window into the base allocation. 
 public static void main(String[] args) { } 
 // Checks for calls to "new AllowAllHostnameVerifier()" // and use of ALLOW_ALL_HOSTNAME_VERIFIER 
 "could cause insecure network traffic due to trusting TLS/SSL " + "server certificates for wrong hostnames"); 
 // ---- Implements JavaScanner ---- // // Checks for calls to setHostnameVerifier(new AllowAllHostnameVerifier()) // and setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER) 
 // Only resume home activity if isn't finishing. 
 public boolean isStaticallySynchronized() { 
 public Method getDynamicallySynchronizedMethod() { 
 assertTrue(t.purge() <= 50); 
 assertTrue(t.purge() <= 50); 
 * Class to format a {@link Long} representing a duration as a {@link String}. 
 * Class to format a {@link Long} representing a duration as a {@link String}. 
 double u = (double) ns / ref.convert(1, unit); 
 * This {@link Formatter} is used to format a instance of {@link Number} as a {@link String}. 
 if (!StandardNames.IS_RI) { throw e; } 
 Thread.sleep(1000); 
 UriCodec.decode("ab%2f$%C4%82%25%e0%a1%80%p"); 
 public StatisticModel apply(@Nonnull Statistic data) { 
 private static class SynchronizedModel implements DataModel { 
 .addField("constraints", DataType.STRUCT) 
 .addField("constraints", DataType.STRUCT) 
<|del|> 
<|del|> 
 public int getWordCount() { 
 private static final int ALLOW_SHRINKING = 0x0001; private static final int ALLOW_OBFUSCATION = 0x0002; 
<|del|> 
 // Into Format 25x closure is not included into registerCount, but nevertheless it must be taken 
 // Into Format 25x closure is not included into registerCount, but nevertheless it must be taken 
 // Into Format 25x closure is not included into registerCount, thus remove it from 
 public void addAnnotate(@Nonnull JAnnotationType toAdd, @Nonnull Collection<?> collection) { 
 char[] array = descriptor.toCharArray(); array[0] = 'L'; descriptor = new String(array); 
 if (!isReference() && !isClosure()) { 
 throw new MappingCollisionException( new LineLocation(new FileLocation(mappingFile), lineNumber), method, newName); 
 return "Mapping collision: " + location.getDescription() + ": " + node.getName() 
 return "Mapping collision: " + location.getDescription() + ": " + node.getName() 
<|del|> 
 } 
 private Allocation testAllocation1, testAllocation2; 
 int X = 1024; int Y = 1024; 
 s.invoke_entrypoint(testAllocation1, testAllocation2); s.invoke_entrypoint(testAllocation1, testAllocation1); 
 return location.getDescription() + ": " + node.getName() 
 return location.getDescription() + ": \'" + node.getName() + "\' could not be renamed to \'" + newName + "\' since the name was already used"; 
 // Use IPv4 to ensure we do not depend on IPv6 to run these tests. // TODO(25178637): Use InetAddress.getLoopbackAddress() instead. 
 int Y = 768; 
 "src/test/pkg/WorldWriteableFile.java:41: Warning: Setting file permissions to world-readable can be risky, review carefully [SetWorldReadable]\n" + 
 Boolean.TRUE.equals(ConstantEvaluator.evaluate(context, node.astArguments().first())) && Boolean.FALSE.equals(ConstantEvaluator.evaluate(context, node.astArguments().last()))) { 
 * A {@link TransformationStep} allowing to remove one {@link JDefinedClassOrInterface}. 
<|del|> 
 Log.i(TAG, "Closing vpn connection failed. Caught exception: ", e); populateInfo(R.string.device_owner_vpn_connection_close_failed); 
<|del|>
 Log.i(TAG, "Test succeeded: descriptor is null"); 
 Log.w(TAG, "vpn connection established, not expected, test case fails"); 
 Log.i(TAG, "Test succeeded: caught exception: ", e); 
 Log.i(TAG, "Test succeeded: caught exception: ", e); 
<|del|>
 private static final int KEYCHAIN_TIMEOUT_MS = 6*60*1000; 
 "TLS/SSL certificates presented by peers. This method should be " + "avoided unless needed for a special circumstance such as " + "debugging. Instead, `SSLCertificateSocketFactory.getDefault()` " + "should be used.", 
 private static final String INET_ADDRESS_CLASS = 
 private static final String SSL_CERTIFICATE_SOCKET_FACTORY_CLASS = 
 return Arrays.asList("createSocket", "getInsecure"); 
 INamedCallback got = service.GetOtherTestService("Smythe"); mLog.log("Received test service"); String name = got.GetName(); 
 INamedCallback got = service.GetOtherTestService("Smythe"); mLog.log("Received test service"); String name = got.GetName(); 
 INamedCallback got = service.GetOtherTestService("Smythe"); mLog.log("Received test service"); String name = got.GetName(); 
 // The following tests make sure that we inline methods used inside try and catch // blocks, provided they meet other inlining criteria. To do that, we rely on 
 public interface TableConfig<T> { String getHeapsDescription(); long getSize(T element, Heap heap); List<ValueConfig<T>> getValueConfigs(); 
 // Sleep a while to let the JIT compile things. // TODO(ngeoffray): Remove the sleep. b/25414532 
 private final AtomicInteger progressCounter = new AtomicInteger(0); 
<|del|> 
 try { // Use non-blocking poll to avoid FinalizerWatchdogDaemon communication // when busy. 
 private void requestPermissionAndLoad() { 
<|del|> 
 private static final int REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT = 3; private static final int REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT = 4; 
 private static final int REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT = 3; private static final int REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT = 4; 
 SubsetSelector<Site.ObjectsInfo> selector = new SubsetSelector(query, OBJECTS_ALLOCATED_ID, infos); 
 ensureInitialized(); if (mConfigs != null) { for (Pair<Domain, NetworkSecurityConfig> entry : mConfigs) { if (!entry.second.isCleartextTrafficPermitted()) { return false; } 
 Set<X509Certificate> getCertificates(); 
 this.hostname = hostname.toLowerCase(Locale.US); 
 private final int mHashCode; 
 throw new RuntimeException("Failed to load trust anchors from id " + mResourceId, e); 
 certificates.add((X509Certificate) cert); indexLocal.index((X509Certificate) cert); 
 mIndex = indexLocal; mContext = null; 
 * {@link CertificateSource} based on the system trusted CA store. 
 throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e); 
 throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e); 
 * {@link CertificateSource} based on the user-installed trusted CA store. 
 throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e); 
 throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e); 
 // In case wifi is not already enabled, wait for it to come up if (!mWifiManager.isWifiEnabled()) { mWifiManager.setWifiEnabled(true); enabledLatch.await(); } } finally { mContext.unregisterReceiver(watcher); 
 // STOPSHIP: Need to adapt tracer to support lambda 
 if (!mMidi && (mode & MODE_DATA_MASK) == MODE_DATA_MIDI) { 
<|del|>
 Rop.BRANCH_NONE, "liberate-lambda"); 
<|del|> 
 callOp = Rops.opInvokeLambda(prototype); 
 for (JExpression exprArg : methodCall.getArgs()) { sources.set(paramIndex++, getRegisterSpec(exprArg)); } 
 assert firstChar == '\\'; 
 private static final X509Certificate[] EMPTY_ISSUERS = new X509Certificate[0]; 
 * Lower case hostname for this domain rule. 
 // reading the current time here, since that involves a kernel call per object. We // limit fast path communication with FinalizerWatchDogDaemon to what's unavoidable: A 
 new Main().ensureCaller(true, 0); new Main().ensureCaller(false, 0); 
 FinalizerReference<?> finalizing = FinalizerDaemon.INSTANCE.finalizingObject; sleepFor(NANOS_PER_SECOND); // Recheck to make it less likely we report the wrong object. if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) { return finalizing; } 
 if (invocationCount < NUMBER_OF_INVOCATIONS) { 
 if (invocationCount < NUMBER_OF_INVOCATIONS) { 
 if (invocationCount < NUMBER_OF_INVOCATIONS) { 
 static final int NITERS = 2 * 1000 * 1000; 
 // Recheck to make it even less likely we report the wrong finalizing object in // the case which a very slow finalization just finished as we were timing out. if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) { 
 // Recheck to make it even less likely we report the wrong finalizing object in // the case which a very slow finalization just finished as we were timing out. if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) { 
 // Recheck to make it even less likely we report the wrong finalizing object in // the case which a very slow finalization just finished as we were timing out. if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) { 
 private static final String TEST_SUMMARY_URL = "http://www.google.com?q=android"; 
 private NoClassDefFoundError(String detailMessage, Throwable throwable) { super(detailMessage, throwable); 
<|del|> 
 * Supports treating a class as a Caliper benchmark. 
<|del|> 
 * backend implementations that know how to run specific types of tests. 
<|del|> 
 * aspect of the specified class, and then creates such an instance. 
 @Override 
 * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at 
 private long closure; // native pointer to art::lambda::Closure. // The closure is deleted by (native) lambda::BoxTable after it detects the LambdaProxy was GCd. 
 private long closure; // native pointer to art::lambda::Closure. // The closure is deleted by (native) lambda::BoxTable after it detects the LambdaProxy was GCd. 
 private long closure; // native pointer to art::lambda::Closure. // The closure is deleted by (native) lambda::BoxTable after it detects the LambdaProxy was GCd. 
 private static Class<?> getLambdaProxyClass(ClassLoader loader, Class<?> iface) { 
 boolean isLambdaProxy) { 
 } // else ... Lambda proxies have a cache in the (native) runtime which does same as above. 
 private static final float DECELERATION_RATE = 20000f; 
 private static final long ZOOM_CORRECTION_DELAY = 600L; 
 // This will succeed if the constructor is declared in NoClassDefFoundError. klass.getDeclaredConstructor(String.class, Throwable.class); 
 * At first, the test starts the debuggee. Then request a breakpoint and wait for it. 
<|del|> 
 return mHashCode; 
 return mHashCode; 
 private final int mResourceId; private final boolean mDebugBuild; 
 private final int mResourceId; private final boolean mDebugBuild; 
 boolean seenTrustAnchors = false; boolean defaultOverridePins = configType == CONFIG_DEBUG; 
 String tagName = parser.getName(); // TODO: Support nested domain-config entries. 
 parseTrustAnchors(parser, defaultOverridePins)); 
 // Exhaustively test valid and invalid calls to rs_* creation functions. (These tests don't // walk the created allocations, though.) 
 public final FileDescriptor[] createRawFileDescriptorArray() { 
 String dateTimeString = getAttribute(TAG_DATETIME); if (dateTimeString == null || !sNonZeroTimePattern.matcher(dateTimeString).matches()) return -1; 
<|del|> 
 writeRawFileDescriptor(value[i]); 
 put("TrustManagerFactory.PKIX", PREFIX + "RootTrustManagerFactorySpi"); 
 parseTrustAnchors(parser, defaultOverridePins)); 
 ensureAccountsQueried(); 
<|del|> 
 decoder = MediaCodec.createByCodecName(codec_decoder); 
 (resolvedClass.matches(SYSTEM_CLASS))) { 
 private Set<X509Certificate> mCertificates; 
 String alias = en.nextElement(); if (!mKeyStore.isCertificateEntry(alias)) { continue; } X509Certificate cert = (X509Certificate) mKeyStore.getCertificate(alias); 
 * {@link ConfigSource} with a single default config based on a {@link KeyStore} and no per domain * configs. 
 * {@link ConfigSource} with a single default config based on a {@link KeyStore} and no per domain * configs. 
 public void engineInit(ManagerFactoryParameters spec) 
 // If we see the same certificate in two TrustAnchors, one with overridesPins and one // without, the one with overridesPins wins. 
 boolean equalsOnsl = onsl != null && spn != null && !spn.isEmpty() && spn.equalsIgnoreCase(onsl); boolean equalsOnss = onss != null && spn != null && !spn.isEmpty() && spn.equalsIgnoreCase(onss); 
 private final X509TrustManager mTrustManager; private final Method mCheckServerTrusted; private final Method mIsUserAddedCertificate; 
 if (mDelegate != null) { return mDelegate.checkServerTrusted(chain, authType, host); 
 private final X509TrustManager mDelegate; // Methods to use when mDelegate is not a TrustManagerImpl and duck typing is being used. private Method mCheckServerTrusted; private Method mIsUserAddedCertificate; 
 checkRequiredMethodsPresent(tm); 
 throw new CertificateException("checkServerTrusted failed", e.getCause()); 
 throw new RuntimeException("isUserAddedCertificate failed", e.getCause()); 
 private void checkRequiredMethodsPresent(X509TrustManager tm) 
 mCheckServerTrusted = tm.getClass().getMethod("checkServerTrusted", 
 mIsUserAddedCertificate = tm.getClass().getMethod("isUserAddedCertificate", 
 "Required method isUserAddedCertificate(X509Certificate) missing"); 
 List<X509Certificate> trustedChain = mDelegate.checkServerTrusted(certs, authType, host); 
<|del|> 
 @Nonnegative 
<|del|> 
<|del|> 
<|del|> 
 ArrayList<String> mWarnings; boolean mConfigured; 
 mWarnings = new ArrayList<String>(); mConfigured = false; 
 if(mConfigured) { Log.i(TAG, "stop"); mCodec.stop(); mConfigured = false; } 
 if (!zipFiles) { 
 * http://www.apache.org/licenses/LICENSE-2.0 
<|del|> 
class ClassImplementsInterfaceA extends ClassSuper implements InterfaceA {} 
 * Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 } 
 * 
 * constraints are run. * - Ask the tester to unplug the phone, and verify that jobs with charging constraints will * not run. 
 // Time in milliseconds to wait after power is connected for the phone // to get into charging mode. 
 private static final int STATE_WAITING_TO_START_ON_CHARGING_TEST = 1; private static final int STATE_ON_CHARGING_TEST_PASSED = 2; 
 mTestState = STATE_WAITING_TO_START_ON_CHARGING_TEST; showWaitingForStableChargingViews(); 
 mTestState = STATE_WAITING_TO_START_ON_CHARGING_TEST; showWaitingForStableChargingViews(); 
 private void showWaitingForStableChargingViews() { mWaitingForChargingProgressBar.start(WAIT_FOR_CHARGING_DURATION, 1000, new TimerProgressBar.TimerExpiredCallback(){ @Override public void onTimerExpired() { mProblemWithChargerTextView.setVisibility(View.VISIBLE); } 
 private void showWaitingForStableChargingViews() { mWaitingForChargingProgressBar.start(WAIT_FOR_CHARGING_DURATION, 1000, new TimerProgressBar.TimerExpiredCallback(){ @Override public void onTimerExpired() { mProblemWithChargerTextView.setVisibility(View.VISIBLE); } 
<|del|> 
 "[sid=\"mysid\";$Path=\"/\";$Domain=\"a.com\", " + "theme=\"dark\";$Path=\"/\";$Domain=\"a.com\"]", 
 "[theme=\"dark\";$Path=\"/\";$Domain=\"a.com\", " + "sid=\"mynewsid\";$Path=\"/\";$Domain=\"a.com\"]", 
@Description("Force a parameter to be turn into a closure") 
<|del|> 
<|del|> 
 // when the the HttpCookie was created to determine cookie age. 
 public SshTarget(Log log, String hostAndPort) { 
 String[] sshProcessPrefix = {"ssh", "-p", Integer.toString(port), host, "-C"}; 
/** * Test the behaviour of the {@link DeviceRuntime} class when run with {@link AdbTarget}. 
 public PartParserRouter(@Nonnull String partName, 
<|del|>
 /// CHECK-START-ARM64: void Main.$opt$validateExtendByteHelper1(byte, byte) instruction_simplifier_arm64 (after) /// CHECK-NOT: TypeConversion public static void $opt$validateExtendByteHelper1(byte a, byte b) { 
 /// CHECK-START-ARM64: void Main.$opt$validateShiftInt(int, int) instruction_simplifier_arm64 (after) /// CHECK-NOT: Shl /// CHECK-NOT: Shr /// CHECK-NOT: UShr 
 /// CHECK-START-ARM64: void Main.$opt$validateShiftLong(long, long) instruction_simplifier_arm64 (after) /// CHECK-NOT: Shl /// CHECK-NOT: Shr /// CHECK-NOT: UShr 
 assertLongEquals(10000 - 3, $opt$noinline$translate(10000L, (byte)3)); assertLongEquals(-10000 - -3, $opt$noinline$translate(-10000L, (byte)-3)); 
 List<Size> testSizes = testSizes = CameraTestUtils.getSortedSizesForFormat(id, mCameraManager, 
 // Add path to system libraries to libPaths; // Access to system libs should be limited // to bundled applications libPaths.add(System.getProperty("java.library.path")); 
 PrivateKeyInfo pki; try (ASN1InputStream bIn = new ASN1InputStream(new ByteArrayInputStream(spec.getEncoded()))) { pki = PrivateKeyInfo.getInstance(bIn.readObject()); } 
 public static void $opt$noinline$testGetLong() { 
 public static void $opt$noinline$testPutLong() { 
 // Sort types and methods to make this visitor deterministic for (JMethod method : methodOrdering.sortedCopy(type.getMethods())) { 
 for (JClassOrInterface innerType : typeOrdering.sortedCopy(type.getMemberTypes())) { 
 public synchronized void run(@Nonnull JDefinedClassOrInterface type) throws Exception { // Start visit on outer types for a deterministic visit order. 
<|del|>
 public static void $opt$validateExtendByteHelper1(int a, byte b) { 
 public static void $opt$validateExtendByte(int a, byte b) { 
 assertLongEquals(10000L - 3L, $opt$noinline$translate(10000L, (byte)3)); assertLongEquals(-10000L - -3L, $opt$noinline$translate(-10000L, (byte)-3)); 
 /// CHECK: Arm64DataProcWithShifterOp /// CHECK: Arm64DataProcWithShifterOp /// CHECK: Arm64DataProcWithShifterOp 
 /// CHECK: Arm64DataProcWithShifterOp /// CHECK: Arm64DataProcWithShifterOp 
 /// CHECK-START-ARM64: void Main.$opt$validateExtendLong(long, long) instruction_simplifier_arm64 (after) /// CHECK: TypeConversion /// CHECK: TypeConversion /// CHECK: TypeConversion /// CHECK: TypeConversion /// CHECK-NOT: TypeConversion 
 private static class IncrementCounterTaskAndPossiblyThrowAfter extends TimerTask { 
 if(!latch.await(millis, TimeUnit.MILLISECONDS)) { throw new AssertionError("Expected exception thrown from timer thread"); 
 t.scheduleAtFixedRate(task1, 1 /* delay */, 10 /* period */); 
 // not invalidate the cache when reinitialized with different // parameters. 
<|del|> 
 public synchronized void run(@Nonnull JDefinedClassOrInterface type) throws Exception { // Start visit on outer types for a deterministic visit order. 
 int xBytesSize = mType.getX() * mType.getElement().getBytesSize(); mByteBuffer = mRS.nAllocationGetByteBuffer(getID(mRS), xBytesSize, mType.getY(), mType.getZ()); 
 try { if (listVersion) { 
<|del|> 
 private static void assertExceptionInPrincipal(String dn) { 
 private static X509Certificate createStubCertificate(final String subjectName) { 
 private static X509Certificate createStubCertificate(final String subjectName) { 
 // Updating the process state to BACKGROUND will trigger profile saving. 
 * Returns the directory where the VM stores its dexopt files. 
 static String escape(String token) { 
 builder.append('\\'); 
 ensureInitialized(); java.security.cert.TrustAnchor anchor = mIndex.findBySubjectAndPublicKey(cert); if (anchor == null) { return null; 
 synchronized (mLock) { ensureInitialized(); java.security.cert.TrustAnchor anchor = mIndex.findBySubjectAndPublicKey(cert); if (anchor == null) { return null; } return anchor.getTrustedCert(); 
 * {@link CertificateSource} based on a directory where certificates are stored as individual files * named after a hash of their SubjectName for more efficient lookups. 
 private final File mDir; 
<|del|> 
 private Set<X509Certificate> mCertificates; 
 boolean match(X509Certificate cert); 
 if (!new File(mDir, fileName).exists()) { 
 private X509Certificate readCertificate(String file) { 
<|del|> 
 try { TrustedCertificateStoreAdapter certStore = new TrustedCertificateStoreAdapter(config); // Provide an empty KeyStore since TrustManagerImpl doesn't support null KeyStores. // TrustManagerImpl will use certStore to lookup certificates. 
 * Create a {@link RegisterSpec} representing the variable {@code this}. * @param jThis The {@link JThis} we want the {@link RegisterSpec} for. * @return The built {@link RegisterSpec}. 
 * Create a {@link RegisterSpec} representing the variable {@code this}. * @param jThis The {@link JThis} we want the {@link RegisterSpec} for. * @return The built {@link RegisterSpec}. 
@Transform(modify = {JLocal.class, JThis.class}) 
@Transform(modify = {JLocal.class, JThis.class}) 
<|del|> 
 private static int $noinline$foo(int x) { if (doThrow) { throw new Error(); } 
 private static int $noinline$foo(int x) { if (doThrow) { throw new Error(); } 
<|del|> 
 final Thread reporterThread = new Thread(new RunReporter(), "Jack reporter"); 
<|del|> 
<|del|> 
 logger.log(Level.FINE, "Reporter thread '" + Thread.currentThread().getName() + "' was interrupted"); 
 Assert.assertEquals("SimpleB", new com.android.jack.java8.gwt.test029.jack.package3.SimpleC().m()); Assert.fail(); 
 Log.d(TAG, "Skipping test as network location is not supported"); 
<|del|> 
 + input.getPath() + "'"); 
 if (!listVersion && listVersionCode == null) { printUsage(System.err); return FAILURE_USAGE; } else { 
 if (!Arrays.equals(input, output)) { 
 public final int errorCode; 
 assert !this.castTypes.isEmpty(); 
<|del|> 
 mWindowManagerFuncs.lockDeviceNow(); 
<|del|> 
 /// CHECK-NOT: InvokeStaticOrDirect 
 /// CHECK: <<Ror:i\d+>> Ror [<<ArgValue>>,<<Const2>>] 
 writeCastOperation(Token.DYNAMIC_CAST_OPERATION, frame, descriptor, TOP_OF_STACK); 
 private final Object lock = new Object(); 
 * a synthetic variable if debug information on local variable are emitted. 
 } catch (IOException ignored) { 
 if (mState.mNetwork.equals(network)) { 
 private void maybeWaitForPreviousThread() { BackgroundTestingThread previousThread; synchronized (mLock) { previousThread = mTestingThread; } 
 private void maybeWaitForPreviousThread() { BackgroundTestingThread previousThread; synchronized (mLock) { previousThread = mTestingThread; } 
<|del|> 
 if (minDuration <= (frameDurationRange[0] + MIN_FRAME_DURATION_ERROR_MARGIN)) { return size; 
 * Returns whether cleartext network traffic (e.g. HTTP, FTP, XMPP, IMAP, SMTP -- without TLS or * STARTTLS) is permitted for this process. 
<|del|> 
<|del|> 
 private static final long MIN_SCREEN_OFF_MS = 1000 * (30 + (long) new Random().nextInt(51)); 
 if (network.equals(mState.mNetwork)) { 
 if (network.equals(mState.mNetwork)) { 
 final int CONNECTIVITY_CHECKING_INTERVAL_MS = 1000 + 100 * (new Random().nextInt(11)); 
 return isRunning.get(); 
 * @param parent the parent class loader * * @deprecated Use #DexClassLoader(String dexPath, String optimizedDirectory, * String librarySearchPath, String libraryPermittedPath, ClassLoader parent) instead 
 * @param parent the parent class loader * * @deprecated Use #DexClassLoader(String dexPath, String optimizedDirectory, * String librarySearchPath, String libraryPermittedPath, ClassLoader parent) instead 
 /// CHECK-DAG: ArraySet // 
 * Returns {@code true} if cleartext traffic is permitted for this application, which is the * case only if all configurations permit cleartext traffic. For finer-grained policy use * {@link #isCleartextTrafficPermitted(String)}. 
 * Returns {@code true} if cleartext traffic is permitted for this application, which is the * case only if all configurations permit cleartext traffic. For finer-grained policy use * {@link #isCleartextTrafficPermitted(String)}. 
 * Returns {@code true} if cleartext traffic is permitted for this application when connecting * to {@code hostname}. 
 * Returns {@code true} cleartext traffic is permitted for this application, which is the case * only if all configurations permit cleartext traffic. For finer-grained policy use * {@link isCleartextTrafficPermitted(String)}. 
 ensureInitialized(); if (mConfigs != null) { for (Pair<Domain, NetworkSecurityConfig> entry : mConfigs) { if (!entry.second.isCleartextTrafficPermitted()) { return false; } 
<|del|> 
 // Bug: https://b.corp.google.com/issues/25819476 
 // Add path to system libraries to libPaths; // Access to system libs should be limited // to bundled applications libPaths.add(System.getProperty("java.library.path")); 
<|del|>
 final int CONNECTIVITY_CHECKING_INTERVAL_MS = 1000 + 100 * (new Random().nextInt(20)); 
 synchronized (mLock) { mTestingThread = null; } 
 if (previousThread != null) { 
 if (mTestingThread != previousThread && mTestingThread != null) { 
 public final boolean equals(@CheckForNull Object obj) { 
 @Nonnull JClassOrInterface mthCallReceiverType) { 
<|del|> 
 * A {@link Feature} specifying that experimental opcodes * will be generated to support lambda expressions. 
<|del|> 
<|del|> 
<|del|> 
 public static File createTempFile(@Nonnull String prefix, @Nonnull String suffix) throws CannotCreateFileException, CannotSetPermissionException, WrongPermissionException { File tmp = Files.createTempFile(prefix, suffix); 
 FileOrDirectory.setPermissions(tempDir, location, Permission.WRITE, ChangePermission.NOCHANGE); FileOrDirectory.checkPermissions(tempDir, location, Permission.WRITE); 
 FileOrDirectory.setPermissions(tempDir, location, Permission.WRITE, ChangePermission.NOCHANGE); FileOrDirectory.checkPermissions(tempDir, location, Permission.WRITE); 
 @Description("Jack IR can contains cast with intersection type") public static class WithIntersectionType implements Tag { 
 @Description("Jack IR can contains cast with intersection type") public static class WithIntersectionType implements Tag { 
 @Description("Jack IR can contains cast with intersection type") public static class WithIntersectionType implements Tag { 
 private final List<JType> castTypes; 
 public List<JType> getTypes() { 
 .requiredIf(Options.JAVA_SOURCE_VERSION.is(JavaVersion.JAVA_8)); 
 String binaryName = remapper.mapValue(formatter.getName(type)); 
 private int mAmbientLightHorizon; 
 private static int sWeightingIntercept; 
<|del|> 
 private final boolean isSuper; 
 * A {@link Feature} specifying that experimental opcodes * will be generated to support lambda expressions. 
 @Rule public InterceptOutputStreams ios = new InterceptOutputStreams(Stream.OUT); 
 State state = new State(stream); 
 private final ByteArrayOutputStream baos; private final Stream stream; 
<|del|> 
 System.out.println(getVersion("jack")); 
 System.out.println(getVersion("jill")); 
 // Add this test into fillRtTestInfos when @KnownIssue will be removed 
 } catch (VerifyError e) { /* ignore */ } catch (Error e) { System.out.println(e.getClass() + " " + e.getClass().getClassLoader()); } 
 } catch (VerifyError e) { /* ignore */ } catch (Error e) { System.out.println(e.getClass() + " " + e.getClass().getClassLoader()); } 
 if (result.diffPercent >= 0.0001 && result.aveDiff > 5) { 
 exec.setErr(bos); 
 private boolean isSharingRuntime(ApplicationInfo appInfo) { 
 * Returns {@code true} if cleartext network traffic (e.g. HTTP, FTP, XMPP, IMAP, SMTP -- * without TLS or STARTTLS) is permitted for all network communications of this process. 
 * Returns {@code true} if cleartext network traffic (e.g. HTTP, FTP, XMPP, IMAP, SMTP -- * without TLS or STARTTLS) is permitted for communicating with {@code hostname} for this * process. 
 private static void setupJitProfileSupport(LoadedApk loadedApk, File cacheDir) { 
 // Permissions: read-write for user. fd = Os.open(profileFile.getAbsolutePath(), OsConstants.O_CREAT, 0500); Os.fchmod(fd, 0500); Os.fchown(fd, appInfo.uid, appInfo.uid); 
 IoUtils.closeQuietly(fd); 
 public static File createTempDir(@Nonnull String prefix) throws CannotCreateFileException, CannotSetPermissionException, WrongPermissionException { 
 new HashMap<JFieldId, Integer>(); 
 if (staticField1 == 2) { 
 setMatchParent(mWebView); 
 AccountUtilsTest.removeAllAccountsForType(mAccountManager, ACCOUNT_TYPE_1); AccountUtilsTest.removeAllAccountsForType(mAccountManager, ACCOUNT_TYPE_2); mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, UserManager.DISALLOW_MODIFY_ACCOUNTS); 
@Description("Never check assert statements") 
@Description("Dynamically check assert statements") 
 // Note that we match `LE` from Select because there are two identical // LessThanOrEqual instructions. 
 // Note that we match `LE` from Select because there are two identical // LessThanOrEqual instructions. 
 setMatchParent((View) mWebView.getParent()); 
 if (local != null) 
 throw new Error("Cannot happen"); 
 public boolean createBondOutOfBand(int transport, OobData oobData) { 
 * Copyright (C) 2016 The Android Open Source Project 
 * Out Of Band Data for Bluetooth device. 
 if (len-1 != SECURITY_MANAGER_TK_SIZE) { Log.i(TAG, "BT OOB: invalid size of SM TK, should be " + SECURITY_MANAGER_TK_SIZE + " bytes."); 
 if (len-1 != SECURITY_MANAGER_TK_SIZE) { Log.i(TAG, "BT OOB: invalid size of SM TK, should be " + SECURITY_MANAGER_TK_SIZE + " bytes."); 
 byte[] securityManagerTK = new byte[len - 1]; 
 byte[] securityManagerTK = new byte[len - 1]; 
 for (int i = 0; i < reversedTK.length; i++) { securityManagerTK[i] = reversedTK[securityManagerTK.length - 1 - i]; 
 return new MockSocketImpl(); 
 // // cache1/2 usage is explained in the lookup method // 
 q = scan(p, n, L_ALPHANUM | L_DASH | L_UNDERSCORE, H_ALPHANUM | H_DASH | H_UNDERSCORE); 
 return (Integer)value; 
 private static void leadsToOutOfMemoryTest() throws Exception { 
 wait(timeout); } catch (InterruptedException e) { // Note: doesn't guard for spurious wakeup. 
 private Client searchForClient(IDevice device) { 
 private boolean isTargetClient(Client c) { 
 } catch (InterruptedException exc) { 
 /** * Find the device with the given serial. Give up after the given timeout (in milliseconds). */ public static IDevice findDevice(String serial, int timeout) { WaitForDevice wfd = new WaitForDevice(serial, timeout); 
 } catch (InterruptedException e) { // Ignore spurious wakeup. 
 if (device == null) { try { wait(timeout); } catch (InterruptedException e) { // Ignore spurious wakeups. } device = wfdl.getDevice(); } AndroidDebugBridge.removeDeviceChangeListener(wfdl); 
 return new Hprof(HPROF_TIMEOUT); 
 + " classes, would you like to save to disk?", "Save?"); 
<|del|> 
 * 
 // List all classes. 
 // For array classes, we *need* the signature directly. 
 // 36 bytes is an empirically determined approximation. 
 excludeList.add(JillBasedToolchain.class); excludeList.add(JackApiV01.class); 
 // The RFCs don't permit underscores in hostnames, but URI has to because a certain 
 /// CHECK: ArrayGet 
 put("Alg.Alias.Signature.2.16.840.1.101.3.4.2.4with1.2.840.113549.1.1.14", 
 private HashMap<String, String> internalProperties = new HashMap<>(); 
 try { configHooks.runHooks(); } catch (Error | RuntimeException hooksExn) { // Ignored since already logged by RunnableHooks. } 
<|del|> 
 Socket scSocket = sc.socket(); InputStream is = scSocket.getInputStream(); assertTrue(sc.isOpen()); assertFalse(scSocket.isClosed()); is.close(); assertFalse(sc.isOpen()); assertTrue(scSocket.isClosed()); ss.close(); 
class Net { // package-private 
 Log.i(TAG, "stop"); mCodec.stop(); mConfigured = false; 
 outState.putString(STATE_CALL_ID, mCallId); outState.putString(STATE_POST_CHARS, mPostDialStr); 
 + " failed: " + e.getMessage()); 
 n = (n % 100) + ((n / 100) * 60); // eg "GMT-0430" 
 int permissions = 0600; // read-write for user. fd = Os.open(profileFile.getAbsolutePath(), OsConstants.O_CREAT, permissions); Os.fchmod(fd, permissions); 
<|del|> 
 ByodHelperActivity.ACTION_CLEAR_USER_RESTRICTION); allowAppsControlIntent.putExtra( 
 private void setupCheckDisabledAppStorageButtonsTest(ArrayTestListAdapter adapter) { 
 int size = (int)Math.min((maxMem - start) / 32, Integer.MAX_VALUE / 4); 
 int size = (int)Math.min((maxMem - start) / 32, Integer.MAX_VALUE / 4); 
 long expected = 4 * size; if (Math.abs(change - expected) > 0.2 * expected) { System.out.println(String.format( "Expected totalMemory increased by around %,d, but found an increase of %,d", expected, change)); 
 public static void tearDown() throws Exception { 
 @Nonnull 
 throw new Error("Expected to fail"); } catch (ReflectiveOperationException e) { 
 q = scan(p, n, L_ALPHANUM | L_DASH | L_UNDERSCORE, H_ALPHANUM | H_DASH | H_UNDERSCORE); 
 private final HashMap<Integer, byte[]> mT3tIdentifiers = new HashMap<Integer, byte[]>(); 
 private void notifyHostEmuActivated(int technology) { mListener.onHostCardEmulationActivated(technology); 
 mIsHceCapable = 
 final EnabledNfcFServices mEnabledNfcFServices; 
 return mEnabledNfcFServices.registerEnabledForegroundService(service, 
 public void onEnabledForegroundNfcFServiceChanged(ComponentName service) { mT3tIdentifiersCache.onEnabledForegroundNfcFServiceChanged(service); mHostNfcFEmulationManager.onEnabledForegroundNfcFServiceChanged(service); 
 public void onEnabledForegroundNfcFServiceChanged(ComponentName service) { mT3tIdentifiersCache.onEnabledForegroundNfcFServiceChanged(service); mHostNfcFEmulationManager.onEnabledForegroundNfcFServiceChanged(service); 
 public void onEnabledForegroundNfcFServiceChanged(ComponentName service) { mT3tIdentifiersCache.onEnabledForegroundNfcFServiceChanged(service); mHostNfcFEmulationManager.onEnabledForegroundNfcFServiceChanged(service); 
<|del|> 
 final HashMap<String, NfcFServiceInfo> mForegroundT3tIdentifiersCache = new HashMap<String, NfcFServiceInfo>(); 
 ComponentName mEnabledForegroundService; 
 T3tIdentifier(String systemCode, String nfcid2) { 
 expectEquals(415, dynamicBCEAndConstantIndicesAllPrimTypes(x, x1, x2, x3, x4, x5, x6, x7, x8, 0, 10)); 
<|del|> 
<|del|> 
 int z; 
 public final static int DEFAULT_TIMEOUT_MILLIS = 10 * 1000; 
 public final static int HPROF_TIMEOUT_MILLIS = 120 * 1000; 
 * Implementors must tolerate a null device (for example, with a no-op). This includes calling * any methods before setDevice has been called. 
<|del|> 
<|del|> 
 toolchainBuilders.put("jack-api-v02", new JackApiV02ToolchainBuilder()); toolchainBuilders.put("jack-api-inc-v02", new JackApiV02IncrementalToolchainBuilder()); toolchainBuilders.put("jack-api-2steps-v02", new JackApiV02TwoStepsToolchainBuilder()); 
 protected void buildJackCall(@Nonnull List<String> args) { 
 protected void buildJackCall(@Nonnull List<String> commandLine) { 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 // let's find why this library is invalid 
 CodecContext context = new CodecContext(); InputJackLibrary inputLib = codec.checkString(context, tempFile.getPath()); if (inputLib == null) { inputLib = codec.parseString(context, tempFile.getPath()); } 
 CodecContext context = new CodecContext(); InputJackLibrary inputLib = codec.checkString(context, tempFile.getPath()); if (inputLib == null) { inputLib = codec.parseString(context, tempFile.getPath()); } 
 if (cause instanceof LibraryVersionException || cause instanceof LibraryFormatException) { 
 assertEquals(0L, $noinline$divLong(1L)); assertEquals(1L, $noinline$remLong(1L)); 
 return getInstance(currencyCode); 
 hooks = new RunnableHooks(); 
 // Prevent HSelect simplification by having a branch with multiple instructions. System.nanoTime(); 
 long nativePtr = allocator.allocate(); if (nativePtr == 0) { cleaner.clean(); return null; } thunk.setNativePtr(nativePtr); 
 Runtime.getRuntime().gc(); 
 private class AnnotableVisitor extends JVisitor { 
 public JavaVersionPropertyId addCategory(@Nonnull Class<? extends Category> category) { super.addCategory(category); 
 } catch (IllegalArgumentException ex) { return; 
 /// CHECK-START: void Main.dynamicBCEAndIntrinsic(int) BCE (before) // Array reference mA[i] 
 addContainerAnnotationIfNeeded(tr, jMethod); 
<|del|> 
<|del|> 
 protected void fillDexLists(@Nonnull List<InputVFile> mainDexList, 
 protected void fillDexLists(@Nonnull List<InputVFile> mainDexList, 
 break; default: assert false : "Unknown Choice: " + choice; 
 // not moved to the proper loop preheader, the wrong values 
<|del|> 
 return (octets.size() > 0) ? out : null; 
 // Array references mA[i] and ..[j] both in inner loop. 
 c.getMethod("compareNewInstance").invoke(null, (Object[]) null); 
 c.getMethod("compareNewInstance").invoke(null, (Object[]) null); 
 * Implementation of {@link TextOutput} which computes a digest of the textual representation 
 public void print(@Nonnull char[] s) { 
 * Schedulable which adds the {@link OriginDigestMarker} 
 * Schedulable which adds the {@link OriginDigestMarker} 
<|del|> 
 return (algo.equals(marker.algo) && descriptor.equals(marker.descriptor) && Arrays.equals(digest, marker.digest)); 
<|del|> 
 private static OriginDigestElement[] values; 
 private static Set<OriginDigestElement> lastSet = EnumSet.noneOf(OriginDigestElement.class); 
 rb = ResourceBundle.getBundle(resourceBundleName, Locale.getDefault(), cl); 
 rb = ResourceBundle.getBundle(resourceBundleName, Locale.getDefault(), cl); 
public interface MultiDexWritingTool { 
 Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("+00:00")); 
 case PATTERN_STANDALONE_MONTH: // 'L'. 
 throw new AssertionError("Unknown choice: " + choice); 
 return new Integer(42); 
 IoBridge.connect(fd, addr, 7, timeout); 
 IoBridge.connect(fd, addr, 7, timeout); 
 if (doThrow) { throw new Error(); } 
 /// CHECK-DAG: <<Constant:i\d+>> IntConstant 42 /// CHECK-DAG: Return [<<Constant>>] 
 new UserHandle(mCurrentUserId)); 
<|del|> 
<|del|> 
<|del|> 
 return (Long)value; 
 for (ClassInstance.FieldValue field : ((ClassInstance)inst).getValues()) { 
 * Disables the service for the specified Activity. 
<|del|> 
 private static OriginDigestElement[] values; 
<|del|> 
 if (transformation == null || transformation.isEmpty()) { 
 static final Cipher createCipher(String transformation, Provider provider) 
 tryCombinations(null /*params*/, provider, tokenizedTransformation); } catch (InvalidKeyException | InvalidAlgorithmParameterException e) { // Shouldn't happen. throw new IllegalStateException("Key/Algorithm excepton despite not passing one", e); 
 tryCombinations(null /*params*/, provider, tokenizedTransformation); } catch (InvalidKeyException | InvalidAlgorithmParameterException e) { // Shouldn't happen. throw new IllegalStateException("Key/Algorithm excepton despite not passing one", e); 
 tryCombinations(null /*params*/, provider, tokenizedTransformation); } catch (InvalidKeyException | InvalidAlgorithmParameterException e) { // Shouldn't happen. throw new IllegalStateException("Key/Algorithm excepton despite not passing one", e); 
 void updateProviderIfNeeded() { 
* Copyright (C) 2016 The Android Open Source Project 
 // Ignore 
 } catch (ListDirException e) { throw new JillException(e); 
 } catch (ListDirException e) { throw new JillException(e); 
 public void checkValidity() throws IllegalOptionsException, ListDirException { 
 private void checkBinaryFileValidity() throws IllegalOptionsException, ListDirException { 
 throws ListDirException { 
 throw new ConcurrentIOException(new ListDirException(dir)); 
 throw new ConcurrentIOException(new ListDirException(dir)); 
 private final DirectoryLocation directoryLocation; 
 return x ? field : 43; 
 return x ? 43 : field; 
 argsOut = new FileWriter(tmpArgs); 
 public static ApplicationConfig getApplicationConfigForPackage(Context context, String packageName) throws PackageManager.NameNotFoundException { 
 * Copyright (C) 2016 The Android Open Source Project 
 if (first_api_level && first_api_level < min_api_level) { return false; } else { 
<|del|> 
<|del|> 
 public static final ReflectFactoryPropertyId<ScheduleInstance> DEFAULT_RUNNER = ReflectFactoryPropertyId.create( "sched.runner", "Set kind of runner for runnable", ScheduleInstance.class) .addArgType(Plan.class).addDefaultValue("multi-threaded"); 
 public <X extends VisitorSchedulable<T>, U extends Component> void process(@Nonnull T component) 
 // Permit only requests permitted by NetworkSecurityPolicy. 
 private static final class CleartextURLFilter implements URLFilter { 
<|del|> 
<|del|> 
<|del|> 
 Intent intent = new Intent(TelecomManager.ACTION_ONGOING_CALL) .putExtra(TelecomManager.EXTRA_ONGOING_CALL_SHOW, show); 
 public long instanceLongField = 0; // Overwritten by setters. 
 public static float staticFloatField = 0.0f; // Overwritten by setters. 
 /// CHECK-DAG: <<Invoke:l\d+>> InvokeStaticOrDirect [<<Ignored>>,<<Value>>,<<ClinitCk>>] /// CHECK-DAG: Return [<<Invoke>>] 
<|del|> 
 // Use the installed NetworkSecurityPolicy to determine which requests are permitted over // http. 
 throw new SocketException("bad argument for IP_MULTICAST_IF2"); if (o instanceof NetworkInterface) { o = new Integer(((NetworkInterface)o).getIndex()); } 
<|del|> 
 put("CertPathBuilder.PKIX", "sun.security.provider.certpath.SunCertPathBuilder"); 
 * * <p>The offset in milliseconds can be computed using: * {@code mRawOffset + mOffsets[type] * 1000} * 
 final long longWallTimeSeconds = calendar.getTimeInMillis() / 1000; 
 MockContentProvider.checkError(fd); 
 * in the tests are updated. 
<|del|> 
 "JackProvider could not be loaded. Ensure Jack is present on classpath or prebuilt is" + " specified in configuration file", e); 
 // Check that we generate CMOV for long on x86_64. 
 // Check that we generate CMOV for int on x86_64. 
 if (i == 0) { // 0% for volume 0 
 } } else if ((device & mFullVolumeDevices) != 0) { index = (mIndexMax + 5)/10; 
 boolean rehash = oldAltHashing ^ useAltHashing; if (rehash) { hashSeed = sun.misc.Hashing.randomHashSeed(this); } 
 X509Certificate[] chain, String authType, Class<?> argumentClass, Object argumentInstance) throws CertificateException { 
 X509Certificate[] chain, String authType, Class<?> argumentClass, Object argumentInstance) throws CertificateException { 
 X509Certificate[] chain, String authType, Class<?> argumentClass, Object argumentInstance) throws CertificateException { 
 checkTrusted(chain, authType, session, parameters, true /* client auth */); 
 checkTrusted(chain, authType, session, engine.getSSLParameters(), false /* client auth */); 
 /// CHECK-DAG: <<Five:f\d+>> FloatConstant 5 /// CHECK-DAG: <<Zero:i\d+>> IntConstant 0 /// CHECK-DAG: <<MinusOne:i\d+>> IntConstant -1 
 // is thrown during the initialization of ssl.ServerSocketFactory.provider. 
 if ($noinline$returnDouble() != Double.longBitsToDouble(0xF000000000001111L)) { throw new Error("Unexpected return value "); 
 * Sets the base directory all relative paths will be based on. 
 void setBaseDirectory(@Nonnull File baseDir) throws ConfigurationException; 
 void setBaseDirectory(@Nonnull File baseDir) throws ConfigurationException; 
 * A configuration implementation for API level 02 of the Jack compiler. 
<|del|> 
 private static void checkPatternOnFixedDate(String pattern, String expectedOutput) 
 private static void checkPatternOnFixedDate(String pattern, String expectedOutput, String input) 
 } 
<|del|> 
 printExceptionMessage(err, e, "Virtual machine error: " + e.getClass().getName() + "."); 
 default: { 
 default: { throw new ConfigurationException("Resource collision policy '" + resourceImportCollisionPolicy.toString() + "' is unsupported"); } 
 "Failed to close input stream on " + source.getLocation().getDescription(), e); 
 throw new AssertionError("Not yet implemented (" + from.getClass().getName() + ")"); 
 throw new ParseException("Unexpected token " + String.valueOf(currentTokenId) + " while token " + expected.toString() + " was expected"); 
<|del|> 
 Base() { intField = 0; // Unnecessary IPUT. doubleField = 0.0; // Unnecessary IPUT. objectField = null; // Unnecessary IPUT. } 
 @Nonnull private final String receiverName; 
 * Construct the exception with a {@link String} message. 
 * A reporter formatting in a JSON-like structure. 
 * A reporter formatting in a JSON-like structure. 
 * This level is deprecated, it sets the level to {@link VerbosityLevel#INFO}. 
 public static void SimdMulAdd(int[] array1, int[] array2) { 
 array2[j] += 12345 * array1[j]; 
 throw new IllegalStateException("Unexpected IOException" , e); 
 private static Pattern ethernetNamePattern = Pattern.compile("^(eth|wlan)[0-9]+$"); private static boolean isEthernet(String ifName) throws Exception { 
 for (NetworkInterface nif : Collections.list(NetworkInterface.getNetworkInterfaces())) { 
 public String testLambdaRedefiningADefault() throws Exception { Foo<String> foo = (t) -> { return "lambda : " + t; }; return (((Foo) foo).bar("String")); } 
 * Test lambda that redefine a default. 
 /// CHECK: Deoptimize /// CHECK: Deoptimize 
 /// CHECK: Deoptimize /// CHECK: Deoptimize 
<|del|> 
 if (!request.httpUrl().rfc2732host().equals(address.getRfc2732Host()) 
 @Param private MyBufferType srcBufferType; @Param private MyBufferType dataBufferType; 
 this.position(this.position() + n); 
 if (clientSession instanceof ExtendedSSLSession) { assertTrue(sess instanceof ExtendedSSLSession); assertExtendedSSLSessionsEqual((ExtendedSSLSession) clientSession, (ExtendedSSLSession) sess); } else { assertSSLSessionsEqual(clientSession, sess); } 
<|del|> 
 private Task newCreateDexJarTask(Classpath classpath, File classpathElement, String name, 
 addCreateDexJarAndPushTasks(result, run.basenameOfJar(classpathElement), classpathElement, null); 
<|del|> 
 // TODO(jack-team): JMethod must be replace by a JCallable 
 public List<JMethodIdWithReturnType> getBridgeMethodIds() { 
 public void addBridgeMethodId(@Nonnull JMethodIdWithReturnType bridgeMethodId) { this.bridges.add(bridgeMethodId); 
 JMethodIdWithReturnType methodIdToImplement = 
 METHODID_WITH_RETURN_TYPE("method-id-with-return-type", NodeLevel.STRUCTURE) { 
 JMethod mthToImplement = createMethod(lambdaImplClass, mthIdToImplement, /* isBridge= */ false); 
 // Body is already transform, remove it lambdaMethod.setBody(null); JBlock blockOfBodytoImplement = lambdaBody.getBlock(); 
 // Body is already transform, remove it lambdaMethod.setBody(null); JBlock blockOfBodytoImplement = lambdaBody.getBlock(); 
 for (JMethodIdWithReturnType bridgeMthIdWithReturnType : lambdaExpr.getBridgeMethodIds()) { JMethod bridge = createMethod(lambdaImplClass, bridgeMthIdWithReturnType, /* isBridge= */ true); 
<|del|> 
 // System.arraycopy is intrinsified by art and therefore tiny bit faster than memmove 
 File tmpFile = File.createTempFile("MappedByteBufferTest", ".tmp"); 
<|del|> 
 if (patterns == null) { return null; } else { return createFromPatterns(patterns); } 
 return wrapSSLSessionIfNeeded(session); 
 while (!isInOsrCode("$noinline$returnDouble")) {} 
 while (!isInOsrCode("$noinline$inlineCache")) {} 
<|del|> 
 System.err.println("exception while transforming jack file from jar " 
<|del|> 
 if (generateLibFromIncrementalDir) { 
 // http://b/27197633 // GeneralName san3 = new GeneralName(new X400Address(new byte[8])); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Copyright (C) 2016 The Android Open Source Project 
 return "Property '" + propertyName + "' is missing from library " + location.getDescription(); 
 // Distinct from Quiet NaN. 
 errorLog("Unable to write Java protobuf to file descriptor."); 
 try { enableTimeoutDelay = Integer.parseInt(timeout) + UI_OVERHEAD_DELAY; } catch (NumberFormatException nfe) { debugLog("Custom timeout could not be set " + nfe.getMessage()); } 
<|del|> 
 * Copyright (C) 2015 The Android Open Source Project 
 * Copyright (C) 2015 The Android Open Source Project 
 // http://b/27197633 (Missing replacement for ORAddress) 
 // http://b/27197633 (Missing replacement for ORAddress) 
 if ("2.5.29.30".equals(oid)) { 
 // Quiet NaN. 
 Log.e(TAG, "getSystemService(Context.TELEPHONY_SERVICE) failed, " + "cannot register for SubscriptionInfo changes"); 
 Log.e(TAG, "mTelephonyManager is null, " + "cannot start listening for phone state changes"); 
 Log.e(TAG, "mTelephonyManager is null, " + "cannot send request to stop listening for phone state changes"); 
 Log.e(TAG, "mTelephonyManager is null, " + "cannot send request to stop listening for phone state changes"); 
 Assert.assertEquals(Math.round(Float.intBitsToFloat(0x3EFFFFFF)), (int)+0.0f); Assert.assertEquals(Math.round(16777215.0f), 16777215); // 2^24 - 1 
 jniCriticalThread.join(); runGcThread.join(); 
<|del|> 
 Assert.assertEquals(StrictMath.round(Float.intBitsToFloat(0x3EFFFFFF)), (int)+0.0f); 
 private static final int SECURITY_PATCH_MONTH = 02; 
 // If other app of this uid have NETWORK permissions and the original // is NETWORK permissions, do not update, return. 
<|del|> 
<|del|> 
 // Unpack each classpath entry into resourcesDir. 
 // Signaling NaN. 
 static final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss"); 
 List<Long> lastScansTimestamp = new ArrayList<Long>(NUM_SCAN_DURATIONS_KEPT + 1); 
 seenFinalMethods.add(entry); 
 return InvokeMethodDebuggee.class.getName(); 
 String debuggeeClassSig = getClassSignature(InvokeMethodDebuggee.class); 
 packet.setNextValueAsByte(EventMod.ModKind.ClassOnly); // class-only modifier. 
 String debuggeeInterfaceSig = getClassSignature(InvokeMethodTestInterface.class); long debuggeeInterfaceTypeID = debuggeeWrapper.vmMirror.getInterfaceID(debuggeeInterfaceSig); 
 String debuggeeInterfaceSig = getClassSignature(InvokeMethodTestInterface.class); long debuggeeInterfaceTypeID = debuggeeWrapper.vmMirror.getInterfaceID(debuggeeInterfaceSig); 
 String debuggeeInterfaceSig = getClassSignature(InvokeMethodTestInterface.class); long debuggeeInterfaceTypeID = debuggeeWrapper.vmMirror.getInterfaceID(debuggeeInterfaceSig); 
 long targetMethodID = debuggeeWrapper.vmMirror.getMethodID(debuggeeInterfaceTypeID, "testInvokeMethodStatic1"); 
 Value throwValue = new Value(shouldThrow); 
 if (shouldThrow) { assertEquals("Invalid returned value,", 0, returnValue.getIntValue()); logWriter.println(" InterfaceType.InvokeMethod: returnValue.getIntValue()=" + returnValue.getIntValue()); 
 // Let's resume application suspended on the METHOD_ENTRY event. 
 // Let's resume application suspended on the METHOD_ENTRY event. 
 * Used for InterfaceType.InvokeMethodTest 
<|del|> 
 synchronizer.receiveMessageWithoutException( "org.apache.harmony.jpda.tests.jdwp.InterfaceType.InvokeMethodDebuggee(#2)"); 
 packet.setNextValueAsInt(1); // number of arguments 
 assertEquals("Invalid returned value,", InvokeMethodTestInterface.RETURN_VALUE, returnValue.getIntValue()); 
 return InvokeMethodTestInterface.RETURN_VALUE; 
 c = Class.forName( packageName + "ObjectReference.InvokeMethodDefault002Debuggee$TestClass"); 
 c = Class.forName( packageName + "ObjectReference.InvokeMethodDefaultDebuggee$TestClass"); 
 logWriter.println(" EVENT_THREAD event: suspendPolicy=" + suspendPolicy + " events=" + events); 
 long receiverFieldID = debuggeeWrapper.vmMirror.getFieldID(debuggeeTypeID, "invokeReceiver"); assertTrue("Failed to find receiver field", receiverFieldID != 0L); 
 long targetMethodID = debuggeeWrapper.vmMirror.getMethodID(interfaceTypeID, "testDefaultMethod"); assertTrue("Failed to find method", targetMethodID != 0L); 
 if (view instanceof CompoundButton) { ((CompoundButton) view).setOnCheckedChangeListener(null); 
 public void testParcelDoS() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, RemoteException { 
 fail("Issue with MotionEvent::readFromParcel(): the system will stop responding and" + "after 1 min will crash and restart"); 
 public void raiseExploit() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, RemoteException { 
 MotionEvent event = MotionEvent.obtain(1, 1, 1, 1, pointerProperties, pointerCoordseses, 1, 1, 1, 1, 1, 1, 1, 1); 
 jackToolchain.addProperty( Options.ANDROID_MIN_API_LEVEL.getName(), String.valueOf(AndroidCompatibilityChecker.N_API_LEVEL)); 
 List<Long> lastScanTimestamps = new ArrayList<Long>(NUM_SCAN_DURATIONS_KEPT + 1); 
 Date timestamp = new Date(scanStats.lastScanTimestamps.get(i)); 
 * Used for InterfaceType.InvokeMethodTest.testInvokeMethodStatic 
<|del|> 
 synchronizer.receiveMessageWithoutException( packageName + "ObjectReference.InvokeMethodDefault002Debuggee(#2)"); 
 synchronizer.receiveMessageWithoutException( packageName + "ObjectReference.InvokeMethodDefault002Debuggee(#2)"); 
 String debuggeeClassSig = getDebuggeeClassSignature(); 
 event.getNextValueAsLocation(); // location 
 // Get InvokeMethodDefaultDebuggee.TestInterface class ID. 
 // Get InvokeMethodDefaultDebuggee.TestInterface.testDefaultMethod method ID. 
 c = Class.forName( packageName + "ObjectReference.InvokeMethodDefaultDebuggee$TestClass"); 
 synchronizer.receiveMessageWithoutException( packageName + "ObjectReference.InvokeMethodDefaultDebuggee(#2)"); 
 synchronizer.receiveMessageWithoutException( packageName + "ObjectReference.InvokeMethodDefaultDebuggee(#2)"); 
 String debuggeeClassSig = getDebuggeeClassSignature(); 
<|del|> 
<|del|> 
<|del|> 
 assertNotNull("Test string must not be null", testString); assertEquals("Test string does not match", TEST_STRING, testString); 
 assertNotNull("Test string must not be null", testString); assertEquals("Test string does not match", TEST_STRING, testString); 
 ParcelUuid currSrvcUuid = null; int currSrvcType = 0; int currSrvcInstId = 0; ParcelUuid currCharUuid = null; int currCharInstId = 0; 
 if (DBG) Log.d(TAG, "onGetGattDb() - address=" + address); 
 * Helper class for passing gatt db elements between java and JNI, equal to 
<|del|> 
 /** * Detector that looks for leaked credentials in strings. */ 
 "AuthLeak", "Code might contain an auth leak", 
 "for code which looks like it may contain an url with a username and password", Category.SECURITY, 6, Severity.WARNING, new Implementation(StringAuthLeakDetector.class, Scope.JAVA_FILE_SCOPE)); 
 private final JavaContext mContext; 
 mContext.report(AUTH_LEAK, node, location, "Possible credential leak"); 
 } if (config.get(AndroidCompatibilityChecker.CHECK_COMPATIBILITY).booleanValue()) { 
 "jack.android.dex.check-compatibility", "Check compatibility with the Dex output") 
 "jack.android.dex.check-compatibility", "Check compatibility with the Dex output") 
 ArrayList<Integer> list = new ArrayList<>(); 
 ArrayList<Integer> list = new ArrayList<>(); 
 assertEquals(list, output); 
 assertEquals(list, output); 
 assertEquals(new ArrayList<>(collection), output); 
 setOutput.clear(); map.keySet().forEach((k) -> setOutput.add(k)); assertEquals(map.keySet(), setOutput); 
 map.forEach((k, v) -> output.put(k,v)); assertEquals(map, output); 
<|del|>
@Description("Adds the AbortMarker that will be used by the Aborter.") 
 assertEquals("Invalid long value", longVal, expectedValue); 
 if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); 
 * or array element within the given object {@code o} * at the given {@code offset}. 
<|del|> 
<|del|> 
<|del|> 
 } catch(ConcurrentModificationException expected) {} assertEquals(1, processed.size()); 
 } catch(ConcurrentModificationException expected) {} // We should get a CME and DO NOT continue forEach evaluation assertEquals(1, outputHt.size()); 
<|del|>
<|del|> 
 public <T> T parseAs(@Nonnull String string, @Nonnull PropertyId<T> propertyId) { 
 Consumer<String> alwaysFail = s -> fail(); 
 Function<String, Optional<String>> alwaysFail = s -> { fail(); return Optional.empty(); }; 
<|del|>
<|del|>
<|del|>
 return result; 
 Iface b = a; 
<|del|> 
 long duration; 
 } lastScans.add(scan); 
 synchronized(contextMap.mScanEvents) { if (contextMap.mScanEvents.size() == NUM_SCAN_EVENTS_KEPT) contextMap.mScanEvents.remove(0); contextMap.mScanEvents.add(scanEvent); 
 minScanTime = Math.min(scanDuration, minScanTime); maxScanTime = Math.max(scanDuration, maxScanTime); totalScanTime += scanDuration; 
 long scanDuration = 0; 
 */ // @HotSpotIntrinsicCandidate 
 */ // @HotSpotIntrinsicCandidate 
 if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY) || !doesSupportedMMS()) { Log.i(TAG, "testSendMmsMessage skipped: no telephony available or MMS not supported"); 
 if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY) || !doesSupportedMMS()) { Log.i(TAG, "testSendMmsMessage skipped: no telephony available or MMS not supported"); 
 private static boolean doesSupportMMS() { 
<|del|> 
<|del|>
<|del|> 
 .srcToLib(libLib, /* zipFiles = */ true, new File (testRootDir,"lib")); 
<|del|> 
 private final void $noinline$infinite() { 
<|del|> 
 @Nonnull 
 return "Obfuscation: force to keep package name '" + Jack.getUserFriendlyFormatter().getName(pack) 
<|del|>
 * AppScanStats class helps keep track of information about scans 
 public static <T> void test_forEachRemaining_NPE_list(Collection<T> collection, T[] initialData) throws Exception { 
<|del|> 
 private boolean testLocal; 
 private boolean testRemote; 
 private boolean fullSignatures; 
<|del|> 
<|del|> 
 * classpath 
 private void remapPhantom( @Nonnull JPhantomClassOrInterface type, @Nonnull PackageRemapper remapper, @Nonnull JSession session, @Nonnull JPhantomLookup lookup) { 
<|del|> 
 "changing to all enabled by default: " + ap.getParameterMask()); 
<|del|> 
 contactCursor.close(); contactCursor = null; 
<|del|> 
 Assert.assertTrue( String.format("improper test case: adjusted test duration (%d) < sampleUs (%d)", adjustedTestDurationUs, sampleUs), adjustedTestDurationUs >= sampleUs); long expectedMinNumEvent = adjustedTestDurationUs / sampleUs; 
import static junit.framework.Assert.*; import static junit.framework.Assert.assertEquals; 
 public static <T> void runBasicIterationTests(Spliterator<T> spliterator, ArrayList<T> expectedElements) { ArrayList<T> recorder = new ArrayList<T>(expectedElements.size()); Consumer<T> consumer = (T value) -> recorder.add(value); 
 public static <T> void runBasicIterationTests_unordered(Spliterator<T> spliterator, ArrayList<T> expectedElements, Comparator<T> comparator) { 
 if (lastScans.isEmpty()) return; 
 if (lastScans.isEmpty()) return; 
 // Primary -> managed intent: request to capture and check a video without custom output path 
 private static final int REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT = 3; private static final int REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT = 4; 
 int videoCaptureRequestId = REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT; 
 private static final Unsafe unsafe = getUnsafe(); 
 Class<?> unsafeClass = Unsafe.class; 
 } contactCursor = mResolver.query(myUri, PHONES_CONTACTS_PROJECTION, CLAUSE_ONLY_VISIBLE, null, orderBy); 
 } contactCursor = mResolver.query(myUri, PHONES_CONTACTS_PROJECTION, CLAUSE_ONLY_VISIBLE, null, orderBy); 
 private void snapChildInstantly(final View view) { 
 boolean animate = mIsExpanded || isPinnedHeadsUp(child); mSwipeHelper.snapChildIfNeeded(child, animate); 
 boolean animate = mIsExpanded || isPinnedHeadsUp(child); mSwipeHelper.snapChildIfNeeded(child, animate); 
 register_native_free.invoke(runtime, size); System.out.println("Expected exception, but none thrown."); 
 videoCaptureRequestId = REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT; 
 // Build lib2 with lib1NoJarjar in the classpath File lib2NoJarjar; 
 // Build lib2 with lib1NoJarjar in the classpath File lib2NoJarjar; 
 .libToLib(lib2NoJarjar, lib2Jarjar, /* zipFiles */ true); 
 // Build dex files File lib1Dex = AbstractTestTools.createTempFile("jarjar006", "lib1.dex.zip"); 
<|del|> 
<|del|> 
 assertSame(comparator, comparator.reversed().reversed()); 
 private static final long data1[] = {2, -5, 7, -1, 1, 0, 100}; private static final long data2[] = {1, 3, 2, 1, 7}; 
 assertEquals(9.833333, lssCombined.getAverage(), 1E-6); 
 private static final double data1[] = {22.4, -53.4, 74.8, -12.4, 17, 0, 100}; private static final double data2[] = {1.2, 3.5, 2.7, 1, 7.6}; 
 public void test_empty() { 
 public void test_empty() { 
 DoubleSummaryStatistics dss1 = getDoubleSummaryStatisticsData1(); 
 private static DoubleSummaryStatistics getDoubleSummaryStatisticsData2() { 
 private static int data1[] = {2, -5, 7, -1, 1, 0, 100}; private static int data2[] = {1, 3, 2, 1, 7}; 
 * Copyright (C) 2016 The Android Open Source Project 
 LongSummaryStatistics lss1 = getLongSummaryStatisticsData1(); assertEquals(-5L, lss1.getMin()); 
 LongSummaryStatistics lss1 = getLongSummaryStatisticsData1(); assertEquals(100L, lss1.getMax()); 
<|del|> 
 String[] elements = { "a", "b", "c", "d", "e", "f", "g", "h", 
 private static class PrimitiveIntArrayList { 
 SpliteratorTester.testSpliteratorNPE(values.spliterator()); assertTrue(values.spliterator().hasCharacteristics(Spliterator.SIZED | Spliterator.DISTINCT)); SpliteratorTester.runSizedTests(values.spliterator(), 16); SpliteratorTester.runDistinctTests(values); 
<|del|> 
 private static class PrimitiveIntArrayList { 
 public static void setSecurityManager(final SecurityManager s) { if (s != null) { 
 * @return {@code null} in Android 
 // Browse methods of duplicateId and assign 'keptId' as their id. 
 private static final boolean SYSTEM = Boolean.TRUE; private static final boolean NETWORK = Boolean.FALSE; 
 if (currentPermission == SYSTEM) { return currentPermission; 
<|del|> 
 * @param s a security manager * @throws SecurityException always, unless {@code sm == null} 
 private static final String[] WEEKDAYS = {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"}; private static final String EXPECTED = "[Mon,Tue,Wed,Thu,Fri,Sat,Sun]"; 
 private static final String[] WEEKDAYS = {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"}; private static final String EXPECTED = "[Mon,Tue,Wed,Thu,Fri,Sat,Sun]"; 
 fail(); } catch (NullPointerException expected) {} 
<|del|> 
 int expectedLength = 2 /* prefix and postfix */ + 3 * (i + 1) /* length of elements */ + i /* length of separators, one less than number of elements */; assertEquals(expectedLength, sj.length()); 
 + "' existing: " + existingNode.getClass().getName() + ", new: " + (newNode == null ? "<null>" : "of class " + newNode.getClass().getName())); 
 // remove(K, V) conflicts with a Map method added in 1.8. http://b/27426743 
 // remove(K, V) conflicts with a Map method added in 1.8. http://b/27426743 
 for (Supplier<Collection<Integer>> impl : collectionImpls) { Collection<Integer> collection = impl.get(); collection.removeIf(truth); assertTrue(collection.isEmpty()); } 
 for (Supplier<Collection<Integer>> impl : collectionImpls) { try { Collection<Integer> c = impl.get(); c.removeIf(null); fail(); } catch (NullPointerException expected) { } 
<|del|> 
 * Pre-scale volume at lowest volume steps 1 2 and 3. 
 } Arrays.parallelSort(reversedArray); assertTrue(Arrays.equals(sortedArray, reversedArray)); 
 assertTrue(256 * 64 > Arrays.MIN_ARRAY_SORT_GRAN); test_parallelSort$B(256 * 64); 
 int endIndex = 100 + mul256Count * 256; 
 } System.arraycopy(reversedArray, 0, originalReversedArray, 0, size); 
 } catch (NullPointerException expected) { 
<|del|> 
<|del|> 
 } catch (NullPointerException expected) { 
 } catch (NullPointerException expected) { 
 * This assumes the given cursor is sorted by CONTACT_ID. 
 + (newNode == null ? "<null>" : newNode.getClass().getName())); 
 } try { Arrays.setAll((String[]) null, x -> "a" + x); fail(); } catch (NullPointerException e) { // expected } } 
 !isLeanbackOnly(); // Workaround for b/27433759. 
 final PackageManager pm = this.getPackageManager(); return (pm != null && pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)); 
 final PackageManager pm = this.getPackageManager(); return (pm != null && pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)); 
 // compatible with the Java-7 version of this class. Several new methods were added 
 // Workaround for http://b/26422335 , http://b/26889631 
 // assertForbiddenHeader("\r"); 
 final Boolean permission = highestPermissionForApp(mApps.get(appUid), appName); 
 final PackageInfo app = mPackageManager.getPackageInfo(name, GET_PERMISSIONS); final boolean isNetwork = hasNetworkPermission(app); final boolean isSystem = hasSystemPermission(app); 
 private static final Boolean SYSTEM = Boolean.TRUE; private static final Boolean NETWORK = Boolean.FALSE; 
 private Boolean highestPermissionForUid(Boolean currentPermission, String name) { 
 if (currentPermission != null && currentPermission == SYSTEM) { 
 compareValue = searchValue.trim().toLowerCase(); 
<|del|> 
 private void test_parallelSort$B(int size) { if (size % 256 != 0) { fail("test_parallelSort$B size needs to be dividable by 256"); } int mul256Count = size / 256; 
 assertTrue(256 * 64 > Arrays.MIN_ARRAY_SORT_GRAN); test_parallelSort$B(256 * 64); 
 int endIndex = size - 100; 
 int endIndex = size - 100; 
 rs.nContextSetCacheDir(RenderScript.getCachePath()); 
 !isLeanback(); // Workaround for b/27433759. 
 !isLeanback(); // Workaround for b/27433759. 
 Assert.assertTrue(errOut.toString().contains( "Local variable value defined in an enclosing scope must be final or effectively final")); 
 AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeClazz); 
 return "UNKNOWN STATE: " + state; 
<|del|> 
<|del|> 
<|del|> 
 // Insert a bunch of arbitrary integers. 
 if (mMnsClient == null) { 
 if (mObserver != null) { 
 if (status != -1 && mMnsRecord != null) { 
 if (status != -1 && mMnsRecord != null) { 
 MnsSdpSearchInfo (boolean isSearchON, int masId, int notification) { 
 public boolean isSearchInProgress() { 
 public void setIsSearchInProgress(boolean isSearchON) { 
 if (isValidMnsRecord()) { 
 return (mMnsRecord != null); 
 public void setMnsRecord(SdpMnsRecord mnsRecord) { if (V) Log.v(TAG, "setMNSRecord"); if (isValidMnsRecord()) { 
 public void setMnsRecord(SdpMnsRecord mnsRecord) { if (V) Log.v(TAG, "setMNSRecord"); if (isValidMnsRecord()) { 
 public void setMnsRecord(SdpMnsRecord mnsRecord) { if (V) Log.v(TAG, "setMNSRecord"); if (isValidMnsRecord()) { 
 public void setMnsRecord(SdpMnsRecord mnsRecord) { if (V) Log.v(TAG, "setMNSRecord"); if (isValidMnsRecord()) { 
 if (!isValidMnsRecord()) { 
 mHandler.sendMessageDelayed(msgReg, MNS_NOTIFICATION_DELAY); 
 if (V) Log.v(TAG, "No last saved MNSSDPInfo to handle"); 
 if (V) Log.v(TAG, "No last saved MNSSDPInfo to handle"); 
 public void testSubListAtomicAdds() throws Exception { testAddAllIsAtomic(new CopyOnWriteArrayList<Object>().subList(0, 0)); } 
<|del|> 
 // classes to work around CTS issues: // LinkedTransferQueueBlockingQueueTest.java // LinkedTransferQueueCollectionTest.java 
 return DEFAULT_RETURN_VALUE; 
 Object invocationHandlerReturnValue = new Object(); // Just always return the different object. InvocationHandler handler = (o, m, oa) -> invocationHandlerReturnValue; 
 assertEquals(invocationHandlerReturnValue, dm.test()); 
 // FINDBUGS Fields are initialized by initWithInputStream() 
 * <p>The returned string will be empty unless this instance was constructed using * {@link #RuleBasedCollator(String)}. 
<|del|> 
 * Gets the path to the code cache. This method requires a RenderScript object to call, * hence non-static. Even though mCachePath itself is static, its intialization is during * the creation of the RenderScript object. 
 static final Object DEFAULT_RETURN_VALUE = new Object(); 
 // These methods produce long-to-float Dex instructions. 
 public void test_unmodifiableMap_getOrDefault() { 
 public void test_unmodifiableMap_putIfAbsent() { 
 MapDefaultMethodTester.test_replace$K$V$V(new ConcurrentHashMap<>()); 
 MapDefaultMethodTester.test_replace$K$V(new ConcurrentHashMap<>(), false); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 mConnectivityChangedReceiver, UserHandle.ALL, intentFilter, null, BackgroundThread.getHandler()); 
 mConnectivityChangedReceiver, UserHandle.ALL, intentFilter, null, BackgroundThread.getHandler()); 
 } 
// ReachingDefsMarker is no longer valid after this optimization, thus remove it directly 
 ArrayList<BluetoothGattDescriptor> descs = in.createTypedArrayList(BluetoothGattDescriptor.CREATOR); 
 in.createTypedArrayList(BluetoothGattIncludedService.CREATOR); 
 public void onSearchComplete(String address, List<BluetoothGattService> services, int status) { 
 ArrayList<BluetoothGattService> includedServices = new ArrayList(fixedService.getIncludedServices()); 
public class BluetoothGattIncludedService implements Parcelable { 
<|del|> 
public class BluetoothGattService implements Parcelable { 
 BluetoothGattIncludedService[] includedServices = new BluetoothGattIncludedService[mIncludedServices.size()]; 
 includedServices[i] = new BluetoothGattIncludedService(s.getUuid(), s.getInstanceId(), s.getType()); 
 for (BluetoothGattCharacteristic chrc : chrcs) { 
 for (BluetoothGattCharacteristic chrc : chrcs) { 
 BluetoothGattIncludedService[] inclSvcs = in.createTypedArray(BluetoothGattIncludedService.CREATOR); 
 for (BluetoothGattIncludedService isvc : inclSvcs) { mIncludedServices.add(new BluetoothGattService(null, isvc.getUuid(), isvc.getInstanceId(), isvc.getType())); 
 for (BluetoothGattIncludedService isvc : inclSvcs) { mIncludedServices.add(new BluetoothGattService(null, isvc.getUuid(), isvc.getInstanceId(), isvc.getType())); 
 for (BluetoothGattIncludedService isvc : inclSvcs) { mIncludedServices.add(new BluetoothGattService(null, isvc.getUuid(), isvc.getInstanceId(), isvc.getType())); 
<|del|> 
 Class.forName("TestCase").getMethod("topLevel").invoke(null); 
 if (!(e.getCause() instanceof NullPointerException)) { throw new Error("Expected NullPointerException"); } 
 HashMap<Integer, Double> hashMap = new HashMap(); 
 public void test_computeIfAbsent() { MapDefaultMethodTester.test_computeIfAbsent(new HashMap<>(), true/*acceptsNullKey*/); } 
<|del|> 
<|del|> 
 public class MapDefaultMethodTester { 
 public class MapDefaultMethodTester { 
 HashMap<Integer, Double> hashMap = new HashMap(); 
<|del|> 
 public static void test_replace$K$V$V(Map<Integer, Double> m, boolean acceptsNullKey, boolean acceptsNullValue) { // For unmapped key assertFalse(m.replace(1, 1.0, 2.0)); assertFalse(m.containsKey(1)); 
<|del|> 
 public static void test_computeIfPresent(Map<Integer, Double> m, boolean acceptsNullKey) { // For an unmapped key assertNull(m.computeIfPresent(1, (k, v) -> 5.0 * k + v)); 
 return null; // failure if this is reached 
 AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeClazz); 
 AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeClazz); 
 AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class, excludeClazz); 
 AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class, excludeClazz); 
 AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class, excludeClazz); 
 AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class, excludeClazz); 
 AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludeClazz); 
 public void testAddTestAccount() { Account account = new Account(TEST_ACCOUNT_NAME, TEST_ACCOUNT_TYPE); AccountManager.get(getContext()).addAccountExplicitly(account, null, null); } 
 final long timeOutMs = System.currentTimeMillis() + durationMs + 5 * 1000; // add 5 sec 
 List<Class<? extends IToolchain>> excludeClazz = new ArrayList<Class<? extends IToolchain>>(1); 
 List<Class<? extends IToolchain>> excludeClazz = new ArrayList<Class<? extends IToolchain>>(1); 
 List<Class<? extends IToolchain>> excludeClazz = new ArrayList<Class<? extends IToolchain>>(1); 
 List<Class<? extends IToolchain>> excludeClazz = new ArrayList<Class<? extends IToolchain>>(1); 
 // Ignore 
 } catch (UnsupportedOperationException expected) { 
 } catch (UnsupportedOperationException expected) { 
 false /*doesNotAcceptNullKey*/); 
 MapDefaultMethodTester.test_getOrDefault(new HashMap<>(), true /*acceptsNullKey*/); 
<|del|> 
 /* * A normal Unix pathname does not contain consecutive slashes and does not end * with a slash. The empty string and "/" are special cases that are also * considered normal. */ 
 // This method returns {@code null} if all tests pass, or a non-null String containing // failure details if an error occured. private static native String nativeTestNativeThreadNames(); 
 zip(new String[] { "foo", "bar", "baz" }, new byte[] { 0, 0, 0, 1, 1, 1 }))); 
 Streams.readFullyNoClose(zis); 
 /// CHECK-START: void Main.testArraySetCheckCastNull(Main$Element[]) instruction_simplifier (after) /// CHECK-NOT: CheckCast /// CHECK-START: void Main.testArraySetCheckCastNull(Main$Element[]) prepare_for_register_allocation (before) 
 HashMap<Integer, Double> hashMap = new HashMap<>(); 
 false /*doesNotAcceptNullKey*/, false /*doesNotAcceptNullValue*/); 
 public static void test_getOrDefault(Map<Integer, Double> m, boolean acceptsNullKey, boolean acceptsNullValue) { // Unmapped key assertEquals(-1.0, m.getOrDefault(1, -1.0)); 
 HashMap<Integer, Double> hashMap = new HashMap<>(); 
 assertEquals(20.0, replica.get(2)); assertEquals(2, replica.size()); 
 Map<String, String> m = new LinkedHashMap<>(8, .75f, true /*accessOrder*/); 
 Map.Entry<String, String> newest = null; 
 Map<String, String> m = new LinkedHashMap<>(8, .75f, true /*accessOrder*/); 
 Map.Entry<String, String> newest = null; 
 Map<String, String> m = new LinkedHashMap<>(8, .75f, true /*accessOrder*/); 
<|del|> 
 // Null pointer exception for empty function try { m.forEach(null); } catch (NullPointerException expected) { } 
 public static void test_replace$K$V$V(Map<Integer, Double> m, boolean acceptsNullKey, boolean acceptsNullValue) { // For unmapped key assertFalse(m.replace(1, 1.0, 2.0)); assertFalse(m.containsKey(1)); 
 * Copyright (C) 2016 The Android Open Source Project 
 mWakeLock.acquire(StkApp.UI_TIMEOUT); 
<|del|> 
 private static boolean doesSupportedMMS() { 
 private static boolean doesSupportMMS() { 
 if (sAuthenticator == null) { sAuthenticator = new AccountAuthenticator(context.getApplicationContext()); 
 if (sAuthenticator == null) { sAuthenticator = new AccountAuthenticator(context.getApplicationContext()); 
<|del|> 
 assertEquals(1.0F, $noinline$longToFloat()); 
 /// CHECK-DAG: Arm64DataProcWithShifterOp [<<Not>>,<<Get>>] kind:And+LSL shift:2 
 /** * Versions currently supported. */ static final String [] VERSIONS_SUPPORTED = { "035", "037", "038" }; 
 /** * Versions currently supported. */ static final String [] VERSIONS_SUPPORTED = { "035", "037", "038" }; 
 for (String supported : VERSIONS_SUPPORTED) { if (version.equals(supported)) { return API_CURRENT; } } if (version.equals(VERSION_FOR_API_13)) { 
<|del|> 
 private int mergeApiLevels() { 
<|del|> 
<|del|> 
<|del|> 
 /* The constructors for the derived classes (including ScriptIntrinsic 
 * to the end of each derived class constructor. 
 */ public static final String VERSION_CURRENT = "037"; 
 fail(ex.getMessage()); 
 assertEquals(0, dst.position()); dc.close(); 
 private static int $noinline$BitCountBoolean(boolean x) { if (doThrow) { throw new Error(); } // Try defeating inlining. 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 if (OsConstants.ENOTCONN != expected.errno) { killerThreadException.set(expected); } 
 killerThreadException.set(ex); 
 int minFrameRate = vcaps.getSupportedFrameRatesFor(minWidth, minHeight) 
 return initiator; 
 if (!lastScans.isEmpty()) { LastScan curr = lastScans.get(lastScans.size() - 1); curr.timeout = true; } 
 if (!lastScans.isEmpty()) { LastScan curr = lastScans.get(lastScans.size() - 1); curr.timeout = true; } 
<|del|> 
 * Returns the desired key size. 
 /*package*/ BluetoothGattCharacteristic getCharacteristicByHandle(int handle) { 
 /*package*/ BluetoothGattDescriptor getDescriptorByHandle(int handle) { 
 // we should use stream duration 
 // we should use stream duration 
 // rtTestInfos.add(TEST003); // KnownIssue rtTestInfos.add(TEST004); 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 testThread.join(20 * 1000); // 20s timeout. 
 AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, excludedToolchains); 
 File sourceDir = AbstractTestTools.getTestRootDir("com.android.jack.java8.lambda.test040.lib"); toolchain.addToClasspath(defaultClasspath).srcToLib(lib, /* zipFiles = */ true, 
<|del|> 
 try (DatagramChannel dc = DatagramChannel.open(MockProtocolFamily.MOCK)) { 
 try (DatagramChannel dc = DatagramChannel.open(MockProtocolFamily.MOCK)) { 
public enum RunnerType { /** * Runs JUnit classes and classes with a main(String[] args) method. */ DEFAULT, 
<|del|> 
 } else if (runnerType == RunnerType.JUNIT) { 
 static Allocation createFromAllocation(RenderScript rs, Allocation alloc) { 
 MediaStorageScan(mContext, file); return file.getAbsolutePath(); 
 assertTrue("Required minimum psnr = " + String.format("%.02f; ", minimumPSNR) + "Actual psnr = " + String.format("%.02f", psnr), 
<|del|> 
<|del|> 
 options.targetApiLevel = apiLevel; 
 this.stream = new QueryableOutputStream(new FileOutputStream(file, append)); this.writer = getCustomPrintWriter((OutputStream) this.stream); 
<|del|> 
<|del|> 
 private View mParantalControlsSwitchYesItem; private View mParantalControlsSwitchNoItem; 
 private View mParantalControlsSwitchYesItem; private View mParantalControlsSwitchNoItem; 
 * Call this to create alternative choice for the previous test step. 
<|del|> 
public class CombinedCondition { 
 static final long EXCESSIVE_SCANNING_PERIOD_MS = 10 * 1000; 
 if (!lastScans.isEmpty()) { LastScan curr = lastScans.get(lastScans.size() - 1); curr.timeout = true; } 
 synchronized boolean isScanningTooFrequen() { 
 assertFalse("should not fail with good OCSP status", goodStatus); 
 DEFAULT(false, true, true), 
 CALIPER(true, false, false), 
 } if (runnerType.supportsJUnit()) { runnerFactories.add(new JUnitRunnerFactory()); } if (runnerType.supportsMain()) { runnerFactories.add(new MainRunnerFactory()); } runnerFactory = new CompositeRunnerFactory(runnerFactories); 
<|del|> 
 // For this test we need an inlined loop and have DCE re-run loop analysis // after inlining. This code is copy-pasted from 480-checker-dead-blocks. 
 assert cst != null; CstLiteral32 lit = (CstLiteral32) cst; int value = lit.getIntBits() & 0b11111; if (value != lit.getIntBits()) { cst = CstInteger.make(value); 
 assert cst != null; CstLiteral32 lit = (CstLiteral32) cst; int value = lit.getIntBits() & 0b11111; if (value != lit.getIntBits()) { cst = CstInteger.make(value); 
 assert cst != null; CstLiteral64 lit = (CstLiteral64) cst; int value = lit.getIntBits() & 0b111111; if (value != lit.getIntBits()) { cst = CstInteger.make(value); 
 * Copyright (C) 2016 The Android Open Source Project 
@RunWith(AndroidJUnit4.class) public class RepeatActionUntilViewStateIntegrationTest { 
 @Rule public ActivityTestRule<SwipeActivity> activityTestRule = new ActivityTestRule<>(SwipeActivity.class); 
 .perform(repeatedlyUntil(swipeUp(), hasDescendant(withText("Position #2")), 10)) 
 .check(matches(hasDescendant(withText("Position #0")))) .perform(repeatedlyUntil(swipeUp(), hasDescendant(withText("Position #200")), maxRepeats)); 
 * Copyright (C) 2016 The Android Open Source Project 
 int noOfRepeats = 1; for (; !mDesiredStateMatcher.matches(view) && noOfRepeats <= mMaxRepeats; noOfRepeats++) { mAction.perform(uiController, view); 
 public static ViewAction repeatedlyUntil(final ViewAction action, final Matcher<View> desiredStateMatcher, final int maxRepeats) { 
 public static ViewAction repeatedlyUntil(final ViewAction action, final Matcher<View> desiredStateMatcher, final int maxRepeats) { 
 public static ViewAction repeatedlyUntil(final ViewAction action, final Matcher<View> desiredStateMatcher, final int maxRepeats) { 
 Espresso.setFailureHandler(new DefaultFailureHandler(getTargetContext())); 
 * "Child 4"), repeat action can be used as follows : * <p><br/><br/>int maxRepeats=10;<br/> 
 * "Child 4"), repeat action can be used as follows : * <p><br/><br/>int maxRepeats=10;<br/> 
 * desired {@code Matcher<View>}. It will repeat the action given number of times until view * matches the desired {@code Matcher<View>} or PerformException will be thrown if the max repeat * number is reached without a match 
 mCurrAddrPlayerID = NO_PLAYER_ID; 
 private static final EventBus requestBus = new EventBus(Jack.class.getSimpleName()); 
 + " compatible with current config ''{3}''", 
 private static final EventBus requestBus = new EventBus(Jack.class.getSimpleName()); 
import android.util.ArrayMap; import com.android.internal.os.PathClassLoaderFactory; 
 // We should not judge SHORT_PRESS by ACTION_UP event repeatCount, because it always // return 0. 
 * Copyright (C) 2016 The Android Open Source Project 
 private static final NativeAllocationRegistry registry = new NativeAllocationRegistry( 
 private static final NativeAllocationRegistry registry = new NativeAllocationRegistry( 
 private static final NativeAllocationRegistry registry = new NativeAllocationRegistry( 
 private static final NativeAllocationRegistry registry = new NativeAllocationRegistry( 
 private static final NativeAllocationRegistry registry = new NativeAllocationRegistry( 
 * <p><br/><br/>int maxAttempts=10;<br/> 
 * } * </pre></blockquote> 
 * .perform(repeatedlyUntil(swipeUp(), hasDescendant(withText("Child 4")), maxAttempts), 
 * } * </pre></blockquote> 
 public static final BooleanPropertyId SHRINKING_ENABLED = BooleanPropertyId.create("jack.shrink", "Enable shrinking feature") 
 logger 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * The Keeper puts markers on the IR outside of the class or interface it runs on, which * necessitates for the shrinkers to wait for the Keeper to finish visiting all types before using * the markers. 
 * The Keeper puts markers on the IR outside of the class or interface it runs on, which * necessitates for the shrinkers to wait for the Keeper to finish visiting all types before using * the markers. 
 value[j] = s.charAt(i); } 
 if (s instanceof String) { 
 /** Per-thread task counter */ 
 description.appendText("has background with drawable ID: " + drawableId); 
 index = (int)(mIndexMax * 0.5)/10; 
 public void testHasBackgroundWhenBackgroundIsNotSet() { View view = new View(context); view.setBackground(null); assertFalse(hasBackground(R.drawable.drawable_1).matches(view)); 
 description.appendText("has background with drawable ID: " + drawableId); 
 description.appendText("has background with drawable ID: " + drawableId); 
 *<p> 
 private static boolean assertDrawable(Drawable actual, int expectedId, View v) { 
 if (expectedBitmap != null) { 
 // http://b/26105053 - corner case: Long.MIN_VALUE / (-1) overflows a long 
<|del|> 
<|del|> 
 * <p> 
 context = InstrumentationRegistry.getContext(); 
 try { assertFalse(HasBackgroundMatcher.compareBitmaps(bitmap1, bitmap2)); } finally { bitmap1.recycle(); bitmap2.recycle(); bitmap1 = null; bitmap2 = null; } 
/** * Matcher to match {@link android.view.View} based on background resource. */ public final class HasBackgroundMatcher extends TypeSafeMatcher<View> { 
 @Override public void describeTo(Description description) { description.appendText("has background with drawable ID: " + drawableId); } static boolean compareBitmaps(Bitmap img1, Bitmap img2) { 
 Part forcePart = request.getPart("force"); assert forcePart != null; 
 private static final String PREFIX = "jacksimple-"; 
 File dex = new File(srcDir, "loading-test-for-opt-test.dex"); copyResource("loading-test.dex", dex); 
 mInstrumentation = getInstrumentation(); mDevice = UiDevice.getInstance(mInstrumentation); mCrashWatcher = new CrashWatcher(mDevice, mInstrumentation.getTargetContext().getExternalFilesDir(null)); // Read a testing Google account credential 
 mInstrumentation = getInstrumentation(); mDevice = UiDevice.getInstance(mInstrumentation); mCrashWatcher = new CrashWatcher(mDevice, mInstrumentation.getTargetContext().getExternalFilesDir(null)); // Read a testing Google account credential 
<|del|> 
<|del|> 
 mDevice.findObject(new UiSelector().className("android.widget.ImageView")).click(); 
 AppLauncher.launch(mInstrumentation, "Contacts"); 
<|del|> 
<|del|> 
public class LockScreenWatcherTest extends AbstractSystemImageTestCase { 
<|del|> 
 int[] array = new int[1]; Assert.assertEquals(-1, UnaryDecrement.setValueAndGetDecrementedIndex(array, 0)); Assert.assertEquals(0, array[0]); 
 (byte) 0, (byte) 0, (byte) 0, (byte) 0}); 
 try { bitmap = BitmapFactory.decodeResource( context.getResources(), android.R.drawable.alert_dark_frame); 
 Bitmap bitmap1 = null; Bitmap bitmap2 = null; 
 try { bitmap1 = BitmapFactory.decodeResource( context.getResources(), android.R.drawable.alert_dark_frame); bitmap2 = BitmapFactory.decodeResource( context.getResources(), android.R.drawable.alert_light_frame); 
 recycle(bitmap1); recycle(bitmap2); 
 */ @Beta 
 if (expectedBitmap != null) { 
 jackServer.resetMaxServiceStat(); 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 if (mFilterBuilder == null) return; 
<|del|>
 mActivityProvider = activityProvider; 
 mActivityProvider = activityProvider; 
 instrumentation.useActivityProvider(activityProvider(mock(SomeOtherActivity.class), SomeOtherActivity.class)); 
 } catch (Exception ex) { fail(ex.getMessage()); 
 private <T extends Activity> ActivityProvider<T> activityProvider( final T activity, final Class<T> activityClass) { 
/** * An interface that can be implemented to provide instance of a particular Activity class. This can * be used by {@link MonitoringInstrumentation#newActivity(ClassLoader, String, Intent)} to provide * custom implementation of Activity under test. 
 private volatile ActivityProvider<?> mActivityProvider; 
 return mInterceptingActivityFactory.shouldIntercept(cl, className, intent) ? mInterceptingActivityFactory.create(cl, className, intent) : super.newActivity(cl, className, intent); 
 return mInterceptingActivityFactory.shouldIntercept(cl, className, intent) ? mInterceptingActivityFactory.create(cl, className, intent) : super.newActivity(cl, className, intent); 
 Checks.checkNotNull(activityProvider); mActivityProvider = activityProvider; 
 mActivityProvider = null; 
 BitmapFactory.decodeStream(exploitImage); 
<|del|> 
 public Location getParentLocation() { return parentLocation; 
 public Boolean telephonyIsRadioOn() { 
 Jack.getUnmodifiableCollections().getUnmodifiableList( 
 public static List<JDefinedClass> getDirectlyDerivedClasses(@Nonnull JDefinedClass clazz) { 
 public static boolean hasDirectlyDerivedClasses(@Nonnull JDefinedClass clazz) { 
/** Provides DirectlyDerivedClassesMarker on defined classes */ @Description("Provides DirectlyDerivedClassesMarker on defined classes") 
@Use(EffectivelyFinalMarker.class) @Transform() 
@Description("Tighten 'final' modifiers on methods.") 
 compression), 
 // another arbitrary calculation that results in Long.MAX_VALUE + 1 // via a different route 
 private static class StandaloneResourceLocation extends StandaloneResOrMetaLocation { 
 if (first_api_level && first_api_level < min_api_level) { return false; } else { 
<|del|> 
<|del|> 
 Class<?> c = Class.forName("IrreducibleLoop"); // Note that we don't actually enter the loops in the 'liveness' // method, so this is just a sanity check that part of the code we // generated for that method is correct. 
 } if (!secure && length > 0) { 
<|del|> 
<|del|> 
 Integer.parseUnsignedInt("123", 2); fail(); 
 assertEquals(dividend.longValue(), uq * divisor.longValue() + ur); 
 Long.parseUnsignedLong("123", 2); fail(); 
 } // Behavior is not defined by Java API specification if the radix falls outside of valid // range, thus we don't test for such cases. 
 * <li>Obtain a new instance of the engine. Engine instances are stateful and thus cannot be used * for signing multiple APKs.</li> 
public interface ApkSignerEngine extends Closeable { 
 void inputApkSigningBlock(DataSource apkSigningBlock) throws IllegalStateException; 
 InputJarEntryInstructions inputJarEntry(String entryName) throws IllegalStateException; 
 * Returns JAR entries that must be added to the output APK. 
 static void expectedVideoAspectRatio(View postTarget, Runnable successCallback) { 
 Log.w(TAG, "The width or height of the selected video track is invalid."); 
 import android.app.Instrumentation; import android.support.test.runner.AndroidJUnit4; import android.support.test.uiautomator.By; import android.support.test.uiautomator.UiDevice; import android.support.test.uiautomator.UiObject; import android.support.test.uiautomator.UiSelector; 
 * Returns the API level on the device or emulator. 
 void inputApkSigningBlock(DataSource apkSigningBlock) throws IllegalStateException; 
 InspectJarEntryRequest outputJarEntry(String entryName) throws IllegalStateException; 
 InputJarEntryInstructions.OutputPolicy inputJarEntryRemoved(String entryName) throws IllegalStateException; 
<|del|> 
 throw new IOException("Failed to read APK being signed", e); 
import javax.annotation.CheckForNull; 
import javax.annotation.CheckForNull; 
import android.support.test.filters.SdkSuppress; 
import android.support.test.filters.SdkSuppress; import android.support.test.uiautomator.By; import android.support.test.uiautomator.UiSelector; import android.support.test.uiautomator.Until; 
 * <p> 
 System.out.println("Found constructors with " + exceptions.length + " exceptions"); 
 Object[] exceptions = constructor.getExceptionTypes(); System.out.println("Found constructors with " + exceptions.length + " exceptions "); 
 Log.e(TAG, "exception during decode: " + e); 
 Log.d(TAG, "exception during decode: " + e); 
<|del|> 
<|del|> 
 protected void fillRtTestInfos() {} 
<|del|> 
<|del|> 
<|del|> 
 boostClass = lookup.getClass(lockTypeSig); 
<|del|> 
<|del|> 
 * This {@link StringCodec} is used to check that the string is a valid method name 
 if (!NamingTools.isValidJavaIdentifier(string)) { 
 super("Android MeasureSpec"); 
 System.out.println("Found constructors with " + exceptions.length + " exceptions"); 
 } catch (Exception e) { System.out.println("Unexpected failure occured"); e.printStackTrace(); } 
 System.out.println("Found constructors with " + exceptions.length + " exceptions "); 
<|del|> 
<|del|> 
 .setVideoWidth(704) .setVideoHeight(480) .setVideoPixelAspectRatio(0.909f) 
<|del|> 
 .setVideoWidth(2000) .setVideoHeight(750) 
 notifyTrackSelected(TvTrackInfo.TYPE_VIDEO, sDummyVideoTrack.getId()); 
<|del|> 
<|del|> 
<|del|> 
 * Checks network status. If the emulator is conencted to the internet via WiFi or mobile data. * <p> * The emulator returns to the home screen for either case. 
<|del|> 
<|del|> 
<|del|> 
 * Copyright (C) 2016 The Android Open Source Project 
/** Provides DirectlyDerivedClassesMarker on defined classes */ @Description("Provides DirectlyDerivedClassesMarker on defined classes") 
 final long startTime = SystemClock.elapsedRealtime(); long nextTimeout = GET_PROVIDER_TIMEOUT_MILLIS; 
 while ((nextTimeout > 0) && mSemaphore.tryAcquire(nextTimeout, TimeUnit.MILLISECONDS)) { 
 nextTimeout = startTime + GET_PROVIDER_TIMEOUT_MILLIS - SystemClock.elapsedRealtime(); 
 private MonitoringInstrumentation mInstrumentation; 
 private final Class<T> mActivityClassToIntercept; 
 checkNotNull(activityClassToIntercept); mActivityClassToIntercept = checkNotNull(activityClassToIntercept); 
 private Uri getUriForCurrSubId(Uri uri) { 
 .create("jack.optimization.method-finalizer", "Detect effectively final methods, add modifiers when possible") .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class) .addCategory(PrebuiltCompatibility.class) .addCategory(Private.class); 
 .create("jack.optimization.method-finalizer", "Detect effectively final methods, add modifiers when possible") .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class) .addCategory(PrebuiltCompatibility.class) .addCategory(Private.class); 
 .report(Severity.FATAL, new BadBoostLockedRegionPriorityConfigurationException(prop, e)); 
 super(cause); this.prop = prop; 
 return getCause().getMessage() + "\n Please verify the property: " + prop.getName() + " is correct."; 
 mSurface = surface; if (surface != null) { draw(); } 
 nextTimeout = startTime + GET_PROVIDER_TIMEOUT_MILLIS - SystemClock.elapsedRealtime(); 
 * block but this is much easier to get at.) 
 byte[] byteArray = new byte[10]; for (int i = 0; i < byteArray.length; ++i) { byteArray[i] = (byte) i; 
 fos.write(byteArray); 
 "f3199c228aced7858b75a8070b8358c155ae0149"); 
 TreeSet<String> notProcessedFields = new TreeSet<String>(validators.keySet()); 
 PrintStream getErrPrintStream(); 
<|del|> 
 assc.accept(null /* attachment */, acceptCompletionHandler); 
 assertEquals(asc.provider(), AsynchronousChannelProvider.provider()); 
 assertNotNull(asc.getLocalAddress()); assertEquals(asc.getLocalAddress(), s.getRemoteSocketAddress()); assertNotNull(asc.getRemoteAddress()); assertEquals(asc.getRemoteAddress(), s.getLocalSocketAddress()); 
 asc.close(); assertFalse(asc.isOpen()); 
 // Small message, won't block on write sss.getOutputStream().write(sendData.array(), sendData.arrayOffset(), messageSize); 
 FutureLikeCompletionHandler<Void> connectCompletionHandler = new FutureLikeCompletionHandler<>(); Object attachment = new Integer(1); asc.connect(ss.getLocalSocketAddress(), attachment, connectCompletionHandler); 
 // Shutdown output, expect ClosedChannelException from write 
/** A CompletionHandler that behaves like a Future and enables compact, single-threaded tests. */ public class FutureLikeCompletionHandler<V> implements CompletionHandler<V, Object> { 
 synchronized (this) { if (done) { e = new IllegalStateException("CompletionHandler used twice"); } 
 assertIllegalStateException(msg, () -> createAesCipher(opmode).update( new byte[2 * bs] /* input */, bs /* inputOffset */, 0 /* inputLen */)); 
 * <li><tt>DH</tt></li> * <li><tt>DSA</tt></li> 
 * <li><tt>DH</tt></li> * <li><tt>DSA</tt></li> 
 * and the following <code>CertPath</code> encodings: 
 if (runnerType.supportsCaliper()) { 
 digits = symbolData.digits.clone(); 
 assertTrue(assc.isOpen()); assertNull(assc.getLocalAddress()); 
 public void test_bind() throws Exception { 
 assertNotNull(asc.getRemoteAddress()); assertTrue(connectFuture.isDone()); 
 // Small message, won't block on write sss.getOutputStream().write(sendData.array(), sendData.arrayOffset(), messageSize); 
 // Small message, won't block on write sss.getOutputStream().write(sendData.array(), sendData.arrayOffset(), messageSize); 
<|del|> 
 * <li><tt>DH</tt></li> * <li><tt>DSA</tt></li> 
 BooleanPropertyId.create("jack.shrob.shrink", "Enable shrinking feature") 
 BooleanPropertyId.create("jack.shrob.obfuscate", "Enable obfuscation feature") 
 } if (lockClass == null || requestClass == null || resetClass == null || requestMethodId == null || resetMethodId == null) { return; } 
 return getCause().getMessage() + " needed by property " + prop.getName(); 
 return getCause().getMessage() + " needed by property " + prop.getName(); 
<|del|> 
 Jack.getUnmodifiableCollections().getUnmodifiableList( 
public class DirectlyDerivedClassesProvider implements RunnableSchedulable<JDefinedClassOrInterface> { 
<|del|> 
 implements RunnableSchedulable<JField> { 
 throw new AssertionError(); 
 PrintStream getErrPrintStream(); 
 // Maximum time to wait in seconds for the termination. 
 int invalidPoolSize = -1; AsynchronousChannelGroup acg = AsynchronousChannelGroup.withFixedThreadPool( invalidPoolSize, new TestThreadFactory()); 
 AsynchronousChannelGroup.withCachedThreadPool(Executors.newFixedThreadPool(5), -1); // Close the channel. acg.shutdownNow(); 
 // It should not be possible to bind a new channel. 
<|del|> 
 Thread t = new Thread(r); t.setDaemon(false); return t; 
 Thread t = new Thread(r); t.setDaemon(false); return t; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 "gaccount"); 
 * Network utility that verifies network status. 
 * System utility that provides Android OS level information. 
 * This watcher should cover all kinds of cling, overlay, popup, etc. that show just after clicking * the launcher for the first time. Because a dismissing button has a very general text like "OK" 
 private final UiDevice mDevice; 
 * This watcher should cover all kinds of cling, overlay, popup, etc. that show just after the 
 private final UiDevice mDevice; 
 System.exit(0); 
 if (ams == null || throwable == null || boostMethodId == null || resetMethodId == null) { return false; 
 "android.bluetooth.input.profile.action.IDLE_TIME_CHANGED"; 
 String getCanonicalName(); 
<|del|> 
 "gaccount"); 
 device.findObject(new UiSelector().text("Remove account")) 
 * Static utility methods pertaining to network status. 
 * Static utility methods pertaining to system information. 
 private SystemUtil() { throw new AssertionError(); } 
 DEFAULT_SWIPE_STEPS); 
@ExclusiveAccess(JSession.class) 
 * Returns the features that are active for the given configuration. 
 * Returns the productions that are active for the given configuration. 
 * Returns a reflection manager used to discover plug-in components (markers, features, ...). 
 * <td>DSA</td> * <td>1+</td> 
 * <td>OAEP</td> 
 * <td>Collection</td> 
@Filter(TypeWithoutPrebuiltFilter.class) // Adds anonymous inner to the outer class and adds type to JSession.typesToEmit. 
// This schedulable removes some types and updates the hierarchy 
// This schedulable removes some methods 
<|del|> 
 // The connection will continue in the onClientRegistered callback 
 return oldName + " was renamed to " + newName 
 public Iterator<String> iterator(@Nonnull String oldName); 
 return level; 
 } while (foundName); 
 // Android-changed: We don't have Unsafe.copyMemory yet, so we use putByte. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * <td>AES/CTR/NoPadding</td> * <td>1+</td> 
 * <td>DES/CTR/NoPadding</td> * <td>1+</td> 
 * <td>DES/CTS/PKCS5Padding</td> * <td>1+</td> 
 return CstBoolean.make(vR); 
 * x = y ^ true; 
 new JBooleanLiteral(condVar.getSourceInfo(), true)))))); 
 private String getHostCoreImagePathNoArch() { return androidHostOut + "/framework/core.art"; 
 printPluginsList(standardOutput, options); 
<|del|> 
 cryptoProxy.getIsCryptoSupported(cryptoSchemeUUID); cryptoProxy.createPlugin(cryptoSchemeUUID, null); 
<|del|> 
 private Context context; 
 rename(fieldId, name); 
 public boolean hasAlternativeName(@Nonnull String oldName); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
@Access(JSession.class) // Access implements 
<|del|> 
 } else if (pref.equals(mCarrierEnabled) || pref.equals(mBearerMulti) || pref.equals(mProtocol) || pref.equals(mRoamingProtocol)) { 
 public static final String staticField = null; 
 public void recoveryFromExceptionOnMainThreadLoopMainThreadUntilIdle() throws Exception { 
<|del|> 
 GenericSignatureParser.PARSER.parseClassSignature(cn.signature); 
 private static final int MAX_BROADCAST_WAIT_TIME_MILLIS = 10000; 
<|del|> 
 // Some runners to insert, get the first one, and remove it 
 logger.log(Level.FINER, "Rejecting runner ''{0}'' because produce superfluous {1}", 
 id = new StatisticId<Percent>("sched.amender.even-simpler." + name + ".constraint.satisfied", "Number of times '" + name + "' has all its constraints satisfied", 
 "Number of times '" + name + "' has produced productions already produced", 
 "Number of times '" + name + "' has produced productions already produced", 
 "Number of times '" + name + "' has produced productions already produced", 
public final class ZipFileTest extends AbstractZipFileTest { 
 // that doesn't use unlink before closing the file. 
<|del|> 
 id = new StatisticId<Counter>("sched.amender.even-simper." + name + ".production.superflous", "Number of time '" + name + "' has all their constraints satisfied", 
<|del|> 
@Constraint(need = {JIfStatement.class}) @Transform( add = {JBitXorOperation.class, JBooleanLiteral.class, JAsgOperation.class, JVariableRef.class} ) 
 private static final String BROADCAST_IDLE_CHECK_CMD = "dumpsys activity broadcasts | grep 'Active Ordered Broadcast background' | wc -l"; 
 Thread.sleep(BROADCAST_WAIT_TIME_MILLIS); 
 while (millis > 0 && !"0".equals(remainBroadcasts)){ Thread.sleep(1000); remainBroadcasts = getDevice().executeShellCommand(BROADCAST_IDLE_CHECK_CMD).trim(); millis -= 1000; 
 * Set up server side JDWP connection before launching the debuggee. 
 * 
 "[SYNC] Illegal port number in socket address: " + address, e); 
 // a different file (/dev/null) after preClose0. 
<|del|> 
 } if (instr instanceof TwoRegisterInstruction) { 
import com.android.jack.ir.ast.MethodKind; 
 for (int i = 0; i < appWidgetIds.length; i++) { 
 return ((1 + startLine) * (1 + endLine) * 13) ^ parentLocation.hashCode(); 
 * loads a corrupt JPEG Image on an ImageView. On a patched device 
 } 
 if (!preserveReflections) { 
 @Constraint(need = { ThreeAddressCodeForm.class }) @Transform(add = { NotEffectivelyFinalField.class }) public static class CollectionPhase 
 private Visitor(@Nonnull JMethod method) { 
 private final boolean preserveJls = ThreadConfig.get(Optimizations.FieldFinalizer.PRESERVE_JLS).booleanValue(); 
 private State(@Nonnegative int size) { 
 for (JField field : fields) { if (!field.isFinal() && !field.isVolatile() && NotEffectivelyFinalField.checkIfCanBeFinal(field)) { this.field2id.put(field, new Integer(this.field2id.size())); } 
 public boolean isEmpty() { return field2id.isEmpty(); 
 } } 
 EffectivelyFinalFieldMarker.markAsEffectivelyFinal(field); if (!preserveReflections) { field.setFinal(); tracer.getStatistic(FIELDS_FINALIZED).incValue(); 
 private static boolean isConstructor(@Nonnull JMethod method) { 
 if (method.getMethodIdWide().getKind() == MethodKind.INSTANCE_VIRTUAL) { 
 BluetoothProfile profile = mBluetoothPan.getAndSet(null); if (profile != null && adapter != null) { adapter.closeProfileProxy(BluetoothProfile.PAN, profile); 
@Constraint( no = {SideEffectOperation.class, InitInNewArray.class, JSwitchStatement.SwitchWithEnum.class, JCastOperation.WithIntersectionType.class, JSwitchStatement.SwitchWithString.class}) 
@Constraint(need = {JSwitchStatement.class, NoImplicitBlock.class}) 
 fail("Able to send broadcast which can be received by any app which has registered " + "broadcast for action 'android.intent.action.stk.command' since it is not " + "protected with any permission. Device is vulnerable to CVE-2015-3843."); 
 /* Pass the Test case: App should not be able to send broadcast using action * 'android.intent.action.stk.command' as it is protected by permission in * patched devices 
 return new ExpectedResults(testRunnerRule.testClass(), ios, 
 filter = new Function<String, String>() { 
 filter = new Function<String, String>() { 
<|del|> 
/** * A suite that runs long running tests that are used to verify behavior of timeout. 
 /** * A test case that is used to verify behavior of timeout. */ 
 /** * A test case that contains multiple tests that will timeout which is used to verify behavior of * timeout that occurs while running tests within a single class. */ 
 * Tests for using TestRunner to run JUnit 3 classes. 
 throw new IllegalStateException("This exception should not be thrown because the" + " enclosing test is annotated with @Ignore"); 
 * Tests for using TestRunner to run JUnit 4 classes. 
 * Verify that the locale is reset to Locale.US before/after each test is run. 
 if (obj instanceof SuperClass) { // We used to wrongly type obj as an exact SuperClass from this point, // meaning we were startically determining that the following instanceof // would always fail. 
<|del|> 
 for (i = -100000000; i < 20; i+=10000000) { 
 for (i = -100000000; i < 20; i+=10000000) { 
 i2 = 0; while (i2++ < 1) { if (i3 >= 0 && i3 < n) { k += c[i3]; 
 import android.app.Instrumentation; import android.support.test.runner.AndroidJUnit4; import android.support.test.uiautomator.By; import android.support.test.uiautomator.UiDevice; import android.support.test.uiautomator.UiObject; import android.support.test.uiautomator.UiSelector; 
 * </pre> * <p/> * This test does not run on API 18 due to RsHelloCompute app crashing on API 18. 
 boolean mustBeKept(@Nonnull JAnnotation annotation) { 
 true /* keepSystemAnnotations */); 
 JMethodIdWide methodId = receiver.getOrCreateMethodIdWide(name, Collections.<JType>emptyList(), 
 @Nonnull JAnnotationType receiver) 
 * Copyright (C) 2016 The Android Open Source Project 
 public void shouldScrollToBottomHeaderTextOfListView() { 
 public void shouldScrollToBottomFooterTextOfListView() { 
 private static class Visitor extends JVisitor { 
 this.field2id.put(field, Integer.valueOf(this.field2id.size())); 
 /** Third phase: mark fields effectively final */ 
 private static boolean isConstructor(@Nonnull JMethod method) { 
 superClass == null || TypeToBeEmittedMarker.isToBeEmitted(superClass)) { 
 logger.log(Level.WARNING, 
 MethodNameValue(@Nonnull String value) { 
 * Android-changed: Removed code that tried to establish proxy connection if * ProxySelector#getDefault() is not null. 
 // http://b/28964300 public void testJNIAccessByAddress() throws Exception { 
 assertEquals(addressDB + SizeOf.CHAR, addressCB); 
<|del|> 
 new IvParameterSpec(iv)); 
 } catch (GeneralSecurityException e) { 
 // http://b/28964300 public void testJNIAccessByAddress() throws Exception { 
 // http://b/28964300 public void testJNIAccessByAddress() throws Exception { 
 assertEquals(addressDB + SizeOf.CHAR, addressCB); 
 this.address = bb.address + off; 
 * Example showing how to decrypt data that was encrypted using SHA1PRNG. 
 * There was an usual anti-pattern of using that algorithm to derive keys. See * <a href="http://android-developers.blogspot.co.uk/2013/02/using-cryptography-to-store-credentials.html"> * here</a> for details. 
 * There was an usual anti-pattern of using that algorithm to derive keys. See * <a href="http://android-developers.blogspot.co.uk/2013/02/using-cryptography-to-store-credentials.html"> * here</a> for details. 
 * Method used to derive an <b>insecure</b> key by emulating the SHA1PRNG algorithm from the 
 try (FileOutputStream fos = openFileOutput(fileName, Context.MODE_PRIVATE)) { 
 throw new RuntimeException("Couldn't read from " + fileName, e); 
 throw new RuntimeException("Couldn't read from " + fileName, e); 
 * This algorithm was sometimes incorrectly used to derive keys. See 
public class JUnitUtils { private JUnitUtils() {} 
 if (device.hasObject(By.res(Res.CHROME_WELCOME_TITLE_RES)) && acceptButton.exists()) { 
 if (device.hasObject(By.res(Res.CHROME_WELCOME_TITLE_RES)) && acceptButton.exists()) { 
 * <li>Parameter 1: index ({@code 0}-based) of the certificate in the signer's list of 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 printFilteredProblem(problemLevel, message, /* location = */ null); 
 if (startLine > 0) { 
 public ColumnAndLineLocation(@Nonnull Location parentLocation, int line) { assert line != UNKNOWN; 
 * <p>On Android, the returned string will be empty unless this instance was * constructed using {@link #RuleBasedCollator(String)}. 
 * Copyright 2008 Google Inc. 
 public ConcurrentLiteralValueListTracker(@Nonnegative int size) { 
 @CheckForNull @Override JValueLiteral getRawValue(@Nonnegative int index) { 
 @Override void mergeWith(@Nonnegative int index, @CheckForNull JValueLiteral literal) { 
 // Value already exists, if it's already a non-single value 
 @Nonnull JExpression expr, @Nonnull JValueLiteral value, 
 @Nonnull JExpression expr, @Nonnull JValueLiteral value, 
 stmtAssignment.setCatchBlocks(new ArrayList<>(stmt.getJCatchBlocks())); 
 abstract JValueLiteral getRawValue(@Nonnegative int index); 
 public SimpleLiteralValueListTracker(@Nonnegative int size) { 
 ControlFlowGraph cfg = method.getMarker(ControlFlowGraph.class); assert cfg != null; return cfg; 
 ControlFlowGraph cfg = method.getMarker(ControlFlowGraph.class); assert cfg != null; return cfg; 
 ((JValueLiteral) value).isDefaultTypeValue()) { 
@Constraint(need = { FieldSingleValueMarker.class, ThreeAddressCodeForm.class, TypeToBeEmittedMarker.class }) @Transform(add = JValueLiteral.class) @Use({ ExpressionReplaceHelper.class, JlsNullabilityChecker.class }) 
 if (OptimizerUtils.isInAssignmentPosition(ref)) { 
 JExpression instance = ref.getInstance(); assert instance != null; jlsNullabilityHelper.addNullCheckIfNeeded(instance, request); 
 @Transform(add = { JAlloc.class, JAsgOperation.NonReusedAsg.class, JLocalRef.class }) 
 long byteBufferBasePointer = NIOAccess.getBasePointer(directByteBuffer); long charBufferBasePointer = NIOAccess.getBasePointer(charBuffer); assertEquals(byteBufferBasePointer, charBufferBasePointer); 
 // Check if the NIOAccess method adds up the current position value. intBuffer.put(1); assertEquals(intBufferBasePointer + SizeOf.INT, NIOAccess.getBasePointer(intBuffer)); 
 long byteBufferAddress = NIOAccess.getBasePointer(directByteBuffer); long charBufferAddress = NIOAccess.getBasePointer(charBuffer); 
 long byteBufferAddress = NIOAccess.getBasePointer(directByteBuffer); long doubleBufferAddress = NIOAccess.getBasePointer(doubleBuffer); 
 long byteBufferAddress = NIOAccess.getBasePointer(directByteBuffer); long doubleBufferAddress = NIOAccess.getBasePointer(doubleBuffer); 
 // There are only two possibilities for the type of ByteBuffer "bb", viz, DirectByteBuffer and 
 // Use JUnit infrastructure to run the tests. 
 * Copyright (C) 2016 The Android Open Source Project 
<|del|> 
<|del|> 
 File lib1 = createLib("jack.lib1"); File lib2 = createLib("jack.lib2"); 
 String message = description + " failed to be closed"; 
 * <strong>WARNING:</strong> On Android, the Preference nodes 
 private static final String CERT_ASSET_NAME = "myCA.cer"; 
 alertDialogBuilder.setPositiveButton(getResources().getString(R.string .hifi_ultrasound_test_ok), new DialogInterface.OnClickListener() { 
 interrupted(); // Clear interrupt flag if execute called exit. 
 File actual = AbstractTestTools.createTempFile("method-actual", ".dalvik"); 
<|del|> 
<|del|> 
 JAsgOperation.NonReusedAsg.class, 
 // NOTE: the code below relies on exact structure of the returned // array, it should consist of three expressions, the last of // which is the resulting exception instance we are throwing assert expressions.length == 3; 
 public static boolean isAssigned(@Nonnull JExpression expr) { 
 JEnumLiteral aEnum = (JEnumLiteral) a; JEnumLiteral bEnum = (JEnumLiteral) b; 
 @Nonnull JMethodCall call, @Nonnull JConstructor constructor) { 
@Constraint(need = { ControlFlowGraph.class, JMethodCall.class }) 
<|del|> 
<|del|> 
<|del|> 
 valuesPropagated.incValue(); 
 private final TypePackageAndMethodFormatter formatter = 
 return method.removeMarker(TaintedMethodMarker.class) != null; 
 /** * Creates a new marker with calculated set of tainted * methods and sets it on the type */ 
 @Nonnull String signature, @Nonnull List<JExpression> args, @Nonnull JMethodCall.DispatchKind dispatchKind) { ConcurrentMap<String, LiteralValueListTracker> map = dispatchKind == JMethodCall.DispatchKind.VIRTUAL ? virtual : direct; 
 /** Marks a call on the receiver type, creates the marker if needed */ 
<|del|> 
 ConstructorAnalyzer(@Nonnull JMethod constructor) { this.constructor = constructor; for (JField field : constructor.getEnclosingType().getFields()) { if (field.isStatic() == constructor.isStatic()) { 
<|del|> 
 JStatement nullCheck = jlsNullabilityHelper .createNullCheckIfNeeded(instance, request); if (nullCheck != null) { JStatement stmt = instance.getParent(JStatement.class); request.append(new AppendBefore(stmt, nullCheck)); } 
<|del|> 
<|del|> 
 // Use JUnit infrastructure to run the tests. 
 newlineEndOffset = i + 1; break; 
 // It emulates a situation where we saved some data in the past, 
 // Copy the example content (one test=test1 entry) to a storage file 
 // Any exception from reading the file will be swallowed and ignored, // only result we will see is a lack of requested key-value pair. 
 // (may be a text data, new-line for example). 
 XmlSupport.importMap(fis, m); } 
 // (may be a text data, new-line for example). 
 // Android added, android xml serializer generates one-char Text nodes with a single 
 // Android added, android xml parser generates one-char Text nodes with a single // new-line character between expected Element nodes. openJdk code wasn't // expecting anything else than Element node. 
<|del|> 
 public boolean gattClientCharacteristicSetWriteType( @RpcParameter(name = "gattIndex") Integer gattIndex, 
 HashSet<String> objLoadedElements = new HashSet<>(); objLoadedElements.addAll(objLoaded); assertEquals(objToSaveElements, objLoadedElements); 
 HashSet<String> objLoadedElements = new HashSet<>(); objLoadedElements.addAll(objLoaded); assertEquals(objToSaveElements, objLoadedElements); 
 // java.io.ObjectOutputStream.writeObject(java.util.Collections.UnmodifiableCollection) 
 new RuntimeTestHelper(TEST005) .addIgnoredCandidateToolchain(JillBasedToolchain.class) .compileAndRunTest(); 
 .create("jack.annotation.parameter.source-retention", 
<|del|> 
 childByText = appList.getChildByText( 
 UiDevice mdevice = testFramework.getDevice(); if (!"google_apis".equals(testFramework.getTag())) { return; } 
 fileSystem.close(); fail(); 
<|del|> 
 AbstractTestTools.createFile(new File(helper.getJackFolder(), JAYCE_SECTION_PATH), "jack.incremental", "A.jayce", "corrupted"); 
<|del|> 
 if (device.hasObject(By.res(Res.CHROME_WELCOME_TITLE_RES)) && acceptButton.exists()) { 
 throw new TestConfigurationException( "No runtime has been provided. Set property 'jack.test.runtime.tolerant' to 'true'" + " to allow it."); 
 assertTrue("Cannot find Google Play services", childByText.exists()); 
 mdevice.findObject(new UiSelector().descriptionContains("More options")).click(); //Google Services Framework is not shown until "Show system" is clicked from //"More options" drop down 
 new UiSelector().className(Res.ANDROID_WIDGET_TEXTVIEW), 
 new UiSelector().className(Res.ANDROID_WIDGET_TEXTVIEW), 
 "com.google.android.googlequicksearchbox\\d*:id/decline_button"; 
 "com.google.android.googlequicksearchbox\\d*:id/decline_button"; 
 res[i++] = ps.name; 
 return mTelephonyManager.setRadioPower(turnOn); 
 /** Updates tracked values with the new expression list */ 
 /** Updates tracked values with the new values from another tracker */ 
 return aEnum.getType().isSameType(bEnum.getType()) && aEnum.getFieldId().getName().equals(bEnum.getFieldId().getName()); 
 MethodCallArgumentsMarker marker = method.removeMarker(MethodCallArgumentsMarker.class); return marker == null ? null : marker.args; 
 * This {@link StringCodec} is used to make a {@link MethodNameValue} object to/from {@link String} * representing a fully qualified method name 
 private static final String PACKAGE_SEPARATOR = "."; 
 private static final String PACKAGE_SEPARATOR = "."; 
 // Class name name = parts.get(parts.size() - 1); if (name.isEmpty()) { throw new ParsingException(MESSAGE + "class name is empty"); } if (!isJavaValidIdentifier(name)) { 
 * Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 UiAutomatorPlus.findObjectByRelative( instrumentation, By.clazz("android.widget.Switch"), By.text("Automatic date & time"), By.clazz("android.widget.ListView")).click(); 
 By.clazz("android.widget.ListView")); assertTrue((switchWidget).isChecked()); 
 public void verifyGoogleApps() throws Exception{ 
 new UiSelector().className(WIDGET_TEXT_VIEW_CLASS), 
 "com.google.android.googlequicksearchbox\\d*:id/decline_button"; 
 public static CyclicBarrier barrier = new CyclicBarrier(3); 
 try { barrier.await(); } catch (Exception e) { } 
<|del|> 
 return new CloneExpressionVisitor().cloneExpression(expr); 
<|del|> 
 private static final String APP_IMAGE_SETTINGS_ID = "com.android.settings:id/advanced"; 
<|del|>
 public static final String NOW_SIGNIN_DECLINE_BUTTON_RES = "com.google.android.googlequicksearchbox\\d*:id/decline_button"; public static final String NOW_SIGNIN_SCREEN_RES = "com.google.android.googlequicksearchbox\\d*:id/header_title"; 
 } 
 private TestSSLContext createAndRegisterDefaultTestSSLContext() { 
 /// CHECK-START: int Main.$noinline$AndAllOnes(int) instruction_simplifier (before) 
 getLooper().quit(); 
 Locale separatorLocale = (l != null) ? l : Locale.getDefault(); LocaleData localeData = LocaleData.get(separatorLocale); sb.append(f.contains(Flags.UPPERCASE) ? localeData.exponentSeparator.toUpperCase(separatorLocale) : localeData.exponentSeparator.toLowerCase(separatorLocale)); 
 */ // Needed because this class contains PropertyIds 
<|del|> 
 TypeAndMemberWriter writer = ThreadConfig.get(TYPE_AND_MEMBER_WRITER); 
 productionSet.add(StructurePrinting.class); 
 productionSet.add(StructurePrinting.class); 
 void write(@Nonnull JField field); 
 void write(@Nonnull JMethod method); 
 void write(@Nonnull JMethod method); 
 assert removed; type.setToEmit(false); 
 private TestSSLContext createDefaultTestSSLContext() { 
 for (JExpression capturedVar : lambdaExpr.getCapturedVariables()) { createFieldAndAssignment(lambdaImplCons, capturedVar); } 
 public static final String NOW_SIGNIN_DECLINE_BUTTON_RES = "com.google.android.googlequicksearchbox\\d*:id/decline_button"; public static final String NOW_SIGNIN_SCREEN_RES = "com.google.android.googlequicksearchbox\\d*:id/header_title"; 
 PackageInfo pi = mPM.getPackageInfo(packageName, flags, mContext.getUserId()); 
 * A property containing the file (or stdout, stderr) where the printing will be done. 
 "jack.samples.structure-printer.file", 
 @Nonnull // We store the writer file and not the PrintWriter to avoid creating an empty file in case // the schedulable is not executed. private final WriterFile writerFile; 
 writerFile = ThreadConfig.get(StructurePrinter.STRUCTURE_PRINTING_FILE); 
 // In this case, the output should not contain all the required // "Finishing worker" lines. Main.printThrowable(t); 
 public Barrier(int initialCount) { count = initialCount; } 
<|del|> 
 private int count; 
<|del|>
 // the Thread or from the DEBUG output. // Note that the Thread creation may fail repeatedly, // preventing the runner from making any progress, // especially if the number of daemons is too high. 
 public Barrier(int initialCount) { count = initialCount; } 
 public void testSupressedExceptions() 
 throw new AssertionError(e); 
 itemList.getChildByText(new UiSelector().className("android.widget.TextView"), "All").clickAndWaitForNewWindow(); 
<|del|> 
<|del|> 
 /// CHECK-DAG: <<Arg:l\d+>> ParameterValue klass:SubclassA // Note: The ArtMethod* (typed as int or long) is optional after sharpening. 
<|del|> 
 fail("Device is likely vulnerable to Bug - 13225149. For more information, see " + 
 fail("Device is likely vulnerable to Bug - 13225149. For more information, see " + 
 UiDevice device = UiDevice.getInstance(instrumentation); 
 assertFalse("Cellular data is enabled.", NetworkUtil.hasCellularNetworkConnection(instrumentation)); 
 UiDevice device = UiDevice.getInstance(instrumentation); 
 UiDevice device = UiDevice.getInstance(instrumentation); 
 assertTrue("Cellular data is disabled.", NetworkUtil.hasCellularNetworkConnection(instrumentation)); 
 // Scroll to the last tab for all the system apps for APIs <= 22 
 if (f.getName().equals(lf.getName()) && f.getSignature().equals(lf.getSignature()) { 
<|del|> 
 String nativePath = getApplicationInfo(packageName).nativeLibraryDir; if (nativePath == null) { throw new IllegalStateException("No native path path found for " + packageName); 
 return nativePath; 
 return nativePath; 
 * <p>RunnerParams can be used to configure {@link RunnerBuilder} instances. RunnerBuilder doesn't * have a method that allows parameters so they must be passed, for example, as a constructor * argument to the RunnerBuilder implementation. 
 * <p>RunnerParams can be used to configure {@link RunnerBuilder} instances. RunnerBuilder doesn't * have a method that allows parameters so they must be passed, for example, as a constructor * argument to the RunnerBuilder implementation. 
 process.waitFor(500, null); fail(); 
 System.out.println(klass.get()); System.out.println(klass2.get()); 
 // If loaded was unloded too early due to races, just pass the test. boolean isNull = loader.get() == null && o != null; 
 assertEquals(4, osc.getFields().length); 
 WeakReference<Class> klass2 = setUpUnloadClassWeak(constructor); 
 Object o = testNoUnloadHelper(loader); return new Pair(o, loader); } private static void testNoUnloadInstance(Constructor<?> constructor) throws Exception { Pair p = testNoUnloadInstanceHelper(constructor); 
 // If the class loader was unloded too early due to races, just pass the test. boolean isNull = p.classLoader.get() == null; 
<|del|> 
<|del|> 
 private boolean mFdnDialDirectlySupported = false; 
 && mFdnDialDirectlySupported); 
 && mFdnDialDirectlySupported); 
 SelectionPopUpMenu menu = new SelectionPopUpMenu(this, v, position); 
 ProcessBuilder pb = new ProcessBuilder("ls", "with\u0000inside"); 
 Thread.currentThread().interrupt(); 
 while (mRenderer != null) { 
 private static BigDecimal bigMultiply(long a, long b) { 
<|del|> 
 URI lower, mixed; lower = URI.create("http://www.example.com/%2b"); mixed = URI.create("http://wWw.ExAmPlE.com/%2B"); 
 /// CHECK: InvokeStaticOrDirect intrinsic:SystemArrayCopy 
 n = socketRead(fd, b, off, length, timeout); 
 /// CHECK-START: void Main.testInlineInterfaceCall() inliner (before) /// CHECK: InvokeStaticOrDirect method_name:Main.methodWithInvokeInterface 
 /// CHECK-START: void Main.testInlineInterfaceCall() inliner (after) 
 /// CHECK-START: void Main.testInterfaceToVirtualCall() inliner (after) 
 static void inlinedForNull(Iterable<?> it) { 
 public void $noinline$doCall() { 
 if (BinarySignatureFormatter.getFormatter() .getName(annotation.getType()) .equals(NamingTools.getTypeSignatureName(ForceInline.class.getName()))) { 
 private CandidateInfo( @Nonnull JMethod callSiteMethod, @Nonnull JMethodCall callSite, @Nonnull JMethod target) { 
 callSiteStmt = callSite.getParent(JExpressionStatement.class); 
 private PrologueInfo(@Nonnull CandidateInfo candidate) { 
 private EpilogueInfo(@Nonnull CandidateInfo candidate) { 
 @Nonnull JMethod callSiteMethod, @Nonnull JMethodCall callSite, @Nonnull JMethod target, @Nonnull TransformationRequest tr) { 
 inlineBody(candidate, prologue, epilogue, tr); 
 src, 
 public void run(JMethod jm) { if (jm.isNative() || jm.isAbstract()) { return; } TransformationRequest tr = new TransformationRequest(jm); new Visitor(jm, tr).accept(jm); 
 // Test case for having enough registers on x86 for the arraycopy intrinsic. 
 System.arraycopy(a, 0, b, 1, 3); if (doThrow) { throw new Error(); } 
 System.arraycopy(a, 0, b, 1, 3); if (doThrow) { throw new Error(); } 
<|del|> 
 private static void testNoUnloadInstance(Constructor constructor) throws Exception { 
 private static Matcher<Intent> isSameIntent(final Intent expectedIntent) { 
 // no instance 
 public static Matcher<? super ActivityResult> hasResultData(final Matcher<Intent> intentMatcher) { return new TypeSafeMatcher<ActivityResult>(ActivityResult.class) { 
 public static Matcher<? super ActivityResult> hasResultCode(final int resultCode) { return new TypeSafeMatcher<ActivityResult>(ActivityResult.class) { 
@RunWith(AndroidJUnit4.class) @SmallTest 
 public ActivityTestRule<PickActivity> rule = new ActivityTestRule<PickActivity>(PickActivity.class); 
 assertThat(rule.getActivityResult(), hasResultData(IntentMatchers.hasExtraWithKey(PickActivity.EXTRA_PICKED_NUMBER))); 
import static android.support.test.internal.util.Checks.checkState; 
 * @return the ActivityResult that was set most recently 
 * @return the ActivityResult that was set most recently 
 Field resultCodeField = Activity.class.getDeclaredField(FIELD_RESULT_CODE); 
 Field resultCodeField = Activity.class.getDeclaredField(FIELD_RESULT_CODE); 
 Field resultCodeField = Activity.class.getDeclaredField(FIELD_RESULT_CODE); 
 Field resultDataField = Activity.class.getDeclaredField(FIELD_RESULT_DATA); 
 Thread.sleep(3000); 
 "Prevents field writes removal of object values that can affect object lifetime") 
 public final boolean preserveNullChecks = 
<|del|> 
 * directory. 
 // Launch the Settings app. 
 } else { 
 Assert.assertTrue("Result of the ls -l command is empty.", result.stderr.length() == 0); 
 synchronized (mLock) { 
 /// CHECK-DAG: <<Array:l\d+>> ParameterValue 
 /// CHECK-NEXT: cmp [<<BaseReg:\w+>> + 8], <<IndexReg:\w+>> 
public class DescriptionComparator implements Comparator<Description> { 
 private ParentRunnerHelper() { } 
 * Runs a {@link Statement} that represents a leaf (aka atomic) test, allowing the test or 
 * <p>This does not throw an {@link InitializationError} during construction if a test method, i.e. * one marked with {@link org.junit.Test @Test} annotation, is not valid. Instead it waits until the 
public class ValidateTestMethodWhenRunBlockJUnit4ClassRunner 
<|del|> 
 public static Matcher<View> hasTextColor(final int colorResId) { return new BoundedMatcher<View, TextView>(TextView.class) { private Context context = null; 
 public static Matcher<View> hasTextColor(final int colorResId) { return new BoundedMatcher<View, TextView>(TextView.class) { private Context context = null; 
<|del|> 
 String colorId = String.valueOf(colorResId); if (context != null) { colorId = context.getResources().getResourceName(colorResId); } description.appendText("has color with ID " + colorId); 
 // Three HDeoptimize will be added. Two for the index and one for null check on array. Then // simplification removes one redundant HDeoptimize. 
 /// CHECK-DAG: SuspendCheck /// CHECK: irreducible:false /// CHECK-NOT: irreducible:true 
 System.out.println(staticField); testSwitch(args); System.out.println(staticField); 
 int a = 42; 
public class SocketTest extends junit.framework.TestCase { 
 return new InetAddress[] { address }; 
 throw new SocketException("Impossible: empty address list"); } 
 bind(localAddr); } 
 try { // Android-changed: // Do not call #close, classes that extend this class may do not expect a call // to #close coming from the superclass constructor. 
 throw e; } 
 ActivityResult activityResult = new ActivityResult(1, intent); assertThat(ActivityResultMatchers.hasResultData(isSameIntent(intent)) .matches(activityResult), is(true)); 
 if (position.getErrorIndex() != -1) { // No style parsed correctly, return error. 
 if (!isDst || dstAmount != 0) { 
 * @return a copy of the {@code double[]} array supplied to the constructor or the most recent * call to {@link #setChoices(double[], String[])}. 
 * @return a copy of the {@code double[]} array supplied to the constructor or the most recent * call to {@link #setChoices(double[], String[])}. 
 * @return a copy of the {@code String[]} array supplied to the constructor or the most recent * call to {@link #setChoices(double[], String[])}. 
 * @return a copy of the {@code String[]} array supplied to the constructor or the most recent * call to {@link #setChoices(double[], String[])}. 
 private static final StatisticId<Counter> OPENED_WRITING_FILES = new StatisticId<Counter>( "sched.vfs.cached-dir.opened-for-writing-files", "Physical files opened for writing (cached)", 
 private static final StatisticId<Counter> OPENED_READING_FILES = new StatisticId<Counter>( "sched.vfs.cached-dir.opened-for-reading-files", "Physical files opened for reading (cached)", 
 "sched.vfs.dir.opened-for-writing-files", "Physical files opened for writing", 
 "sched.vfs.dir.opened-for-reading-files", "Physical files opened for reading", 
 private static final StatisticId<Counter> OPENED_ZIP_ENTRIES = new StatisticId<Counter>( "sched.vfs.zip.opened-for-reading-entries", "Zip entries opened for reading", 
<|del|> 
 expectedNiNames.add(split[1]); 
 Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces(); Set<String> actualNiNames = new HashSet<>(); Collections.list(nifs).forEach(ni -> actualNiNames.add(ni.getName())); 
 } else { 
 Assert.assertTrue("Result of the ls -l command is empty.", result.stderr.length() == 0); 
 * <p>This class makes no effort to check the correctness, verification nor benefit of inlining the 
 mPassthroughInputList.get(i % mPassthroughInputList.size()); 
 // Step #1: Check the first branch. Follow its successor chain as long as they are a single // GOTO. int target = traceEmptyGoto(blocks.get(successors.get(0))); 
 // TODO(JUnit4.10) - super.validateFields() is private in JUnit 4.10 - so inline method RULE_VALIDATOR.validate(getTestClass(), errors); 
 // is not available in JUnit 4.10. That means that it is not possible to 
 public boolean isSingleGoto() { 
 try { 
 // no camera, and no frame update, so just complete here. mLatch.countDown(); return; 
 final String INITIAL_VALUE = "'foo'"; final String OTHER_VALUE = "'bar'"; final ThreadLocal<String> l1 = ThreadLocal.withInitial(() -> INITIAL_VALUE); 
 l1.set(OTHER_VALUE); assertSame(OTHER_VALUE, l1.get()); 
 threadValue.set(l1.get()); 
 assertSame(INITIAL_VALUE, threadValue.get()); 
 // Android-changed: Pass read-only buffer, so the encoder can't alter it 
 * <p> * goto X: 
 * <p> * Which will be further optimized by {@link IdenticalBlockCombiner}. 
 @Nonnull private final List<SsaBasicBlock> blocks; 
 private void pruneRedundantConditionalBranch(@Nonnull SsaBasicBlock block) { 
<|del|>
 private int traceEmptyGoto(@Nonnull SsaBasicBlock block) { 
 private int traceEmptyGoto(@Nonnull SsaBasicBlock block) { 
 block = block.getPrimarySuccessor(); 
<|del|> 
 if (cons == null) { cons = Console.console(); } 
 * goto X: * </pre> 
 if (slast == null) { 
 public void testStandaloneWeekdayParsing() throws Exception { 
 // http://b/30323478 public void testStandaloneWeekdayFormatting() throws Exception { 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 // This hostname is required to resolve to 127.0.0.1 and ::1 for all tests to pass. private static final String ALL_LOOPBACK_HOSTNAME = "loopback46.unittest.grpc.io"; 
 // This hostname is required to resolve to 127.0.0.1 and ::1 for all tests to pass. private static final String ALL_LOOPBACK_HOSTNAME = "loopback46.unittest.grpc.io"; 
 assertTrue(canConnect(loopbackHost, port)); 
<|del|> 
 extension = extension.toLowerCase(Locale.US); 
 * @return True if a MIME type has been registered for the given case insensitive file extension. 
 // Android-changed: Remove adapter cache. We're not dynamically generating any // adapters at this point. 
 // Android-changed: These methods aren't needed on Android and are unused within the JDK. 
 * @return The MIME type has been registered for * the given case insensitive file extension or null if there is none. 
 "Generate tracer files in an additional sub-directory named after the configuration") 
 private static final long serialVersionUID = 8506210602917522861L; 
 if (doThrow) throw new Error(); 
 0, 0L, // Integral values on the stack. 
 /// CHECK: ParallelMove {{.*#1->.*#2->.*#3\.3->.*#4\.4->.*}} 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public abstract boolean isCertificateTransparencyVerificationRequired(String hostname); 
 List<BasicBlock> filteredSuccessors = new ArrayList<BasicBlock>(Math .max(successors.size() - 1 /* means branch to the exit node */, SIZE_WHEN_NO_CATCH)); 
 assertTrue(waitForActivityToHaveFocus(5000 /* ms = 5s */)); 
 expectEquals32(2147483520, round32(Math.nextAfter(2147483648.0f, Float.NEGATIVE_INFINITY))); expectEquals32(2147483647, round32(2147483648.0f)); expectEquals32(2147483647, round32(Math.nextAfter(2147483648.0f, Float.POSITIVE_INFINITY))); 
 // Near minlong. 
 round64(Math.nextAfter(9223372036854775808.0, Double.NEGATIVE_INFINITY))); expectEquals64(9223372036854775807L, round64(9223372036854775808.0)); 
 case TOTAL_SPACE_NUM: return stat.f_frsize * stat.f_blocks; case FREE_SPACE_NUM: return stat.f_frsize * stat.f_bfree; case USABLE_SPACE_NUM: return stat.f_frsize * stat.f_bavail; 
<|del|> 
 "jack.nnode-to-jnode.body", "Body converted from a NNode in a JNode", 
 public static final StatisticId<Percent> SKIPPED_TYPE_STRUCTURE = new StatisticId<Percent>( "jack.jayce-to-nnode.ndeclaredtype.skipped", "Type structure reading skipped by the reader", 
 public static final StatisticId<Percent> SKIPPED_TYPE_STRUCTURE = new StatisticId<Percent>( "jack.jayce-to-nnode.ndeclaredtype.skipped", "Type structure reading skipped by the reader", 
 "jack.jayce-to-nnode.body.skipped", "Method body reading skipped by the reader", 
 // All variables which do no have LocalVariableNode are marked synthetic 
 setInfoResources(R.string.ble_insecure_client_test_list_name, R.string.ble_insecure_client_test_list_info, -1); 
 Intent intent = new Intent(BleInsecureConnectionPriorityClientTestActivity.this, BleConnectionPriorityClientService.class); 
 Toast.makeText(BleInsecureEncryptedServerTestActivity.this, R.string.bt_open_failed_message, Toast.LENGTH_SHORT).show(); 
 * Copyright (C) 2016 The Android Open Source Project 
 * Copyright (C) 2016 The Android Open Source Project 
 compileAndValidate(testPackage, properties, validators); 
 * Copyright (C) 2016 The Android Open Source Project 
 * Indicate that a method should always be inlined for testing purposes. 
 .addDefaultValue(Boolean.TRUE) 
 .addDefaultValue(Boolean.TRUE) 
@Description("Inline methods annotated with @ForceInline") 
 if (formatter.getName(annotation.getType()).equals(FORCE_INLINE_ANNOTATION)) { 
 foundForceInline = true; break; 
 return true; 
 public void run(JMethod method) { if (method.isNative() || method.isAbstract() || !filter.accept(this.getClass(), method)) { 
 * This class is used to make a clone of a method body in order to inline it into the caller 
 * It makes use of {@link CloneStatementVisitor} but it produces a clone with some modification. 
 public InlineMarker(@Nonnull JMethod target) { 
 final static String TEST_DIR = "testDir"; 
 * Simple statistic storing a {@link String} when statistic is not enabled. 
 * with {@code true} argument will cause it to throw an * {@code UnsupportedOperationException}. 
 * with {@code true} argument will cause it to throw an * {@code UnsupportedOperationException}. 
 int savedTargetSdkVersion = VMRuntime.getRuntime().getTargetSdkVersion(); try { // Test N and later behavior VMRuntime.getRuntime().setTargetSdkVersion(24); Annotation classRetentionAnnotation = RetentionAnnotations.class.getAnnotation(ClassRetentionAnnotation.class); 
 assertEquals(hex, hex1); 
<|del|> 
 "jack.jayce-to-nnode.structure.skipped", "Type structure reading skipped by the reader", 
 .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class) .addCategory(PrebuiltCompatibility.class); 
 // http://b/31039416. Android supports cookie "expires" values without a // "GMT" prefix on the timezone. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public final ActivityTestRule<ScaledViewActivity> activityRule = new ActivityTestRule<>(ScaledViewActivity.class); 
<|del|> 
<|del|> 
 // Android-changed: sm is always null // final SecurityManager sm = System.getSecurityManager(); 
 // Android-changed: Removed AccessController.doPrivileged cons.setAccessible(true); 
 * Indicate that a method should always be inlined for testing purposes. 
 * return should remain as a return. * @param parameterMap Maps the parameter to the temporary local variable that stores the value of * the arguments. 
 @Nonnull private final JMethodCall callSite; 
 @Nonnull private final JExpressionStatement callSiteStmt; 
 callSiteStmt = callSite.getParent(JExpressionStatement.class); 
 @Nonnull private final Map<JParameter, JLocal> parameterMap = Maps.newHashMap(); @CheckForNull private final JExpression targetThis; @CheckForNull private JLocal targetThisLocal; 
 * body should branch on JReturn statements. 
 @CheckForNull JStatement next = ControlFlowHelper.getNextStatement(candidate.callSiteStmt); 
 InlineMarker marker = jmc.removeMarker(InlineMarker.class); 
 inline(enclosingMethod, jmc, marker.getTarget(), tr, lvc); 
 * the {@code char} value at the given index is returned 
 final int sourceLength = source.length(); final int targetLength = target.length(); if (fromIndex >= sourceLength) { return (targetLength == 0 ? sourceLength : -1); 
 final int sourceLength = source.length(); final int targetLength = target.length(); int rightIndex = sourceLength - targetLength; 
 * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved. 
 function.apply(entry.key, entry.value)); 
 * InstrumentationTestCase for launching servlet on emulator and use Android SDK. 
<|del|> 
 Assert.assertTrue("Result of the ls -l command is empty.", result.stderr.length() == 0); 
 AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class, excludeList); 
 try (InputJackLibrary compilerStateLib = AbstractTestTools.getInputJackLibrary(lib)) { 
 assertTrue("Cannot find location toggle button", device.findObject( new UiSelector().className("android.widget.Switch")).exists()); 
 "jack.cfg.created-basic-blocks", "Basic blocks created", 
 "jack.cfg.created-basic-blocks", "Basic blocks created", 
 public static final StatisticId<Counter> REMOVED_BASIC_BLOCK = new StatisticId<>( "jack.cfg.removed-basic-blocks", "Basic blocks removed", 
 public static final StatisticId<Counter> REMOVED_BASIC_BLOCK = new StatisticId<>( "jack.cfg.removed-basic-blocks", "Basic blocks removed", 
 this.pathList = new DexPathList(this, dexPath, librarySearchPath, optimizedDirectory); 
 private final String zipDir; 
<|del|> 
 assertEquals("java.util.Map$Entry", c.getName()); // redundant, but can't hurt: 
<|del|> 
 public static <T extends Annotation> T[] getDirectOrIndirectAnnotationsByType( AnnotatedElement element, Class<T> annotationClass) { 
 // Android-changed: Implemented in AbstractMethod instead. throw new UnsupportedOperationException( "Executable.getGenericParameterTypes() not implemented"); 
 // Android-changed: Uses AnnotatedElements instead. return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass); 
 // Android-changed: Uses AnnotatedElements instead. return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass); 
 "jack.cfg.removed-basic-blocks", "Unaccessible basic blocks removed", 
<|del|> 
<|del|> 
 // This callback was called from the jni_workqueue thread. If we make request to the stack // on the same thread, it might cause deadlock. Schedule request on a new thread instead. 
 // This callback was called from the jni_workqueue thread. If we make request to the stack // on the same thread, it might cause deadlock. Schedule request on a new thread instead. 
 // Android changed start // Several apps try to parse the output of toString(). This is a really 
 // Post N-MR1 (> 25) 
 // Android changed end 
 // Android changed end 
 if (numEglConfigs[0] <= 0) { 
 sourceInfo = sourceInfoFactory.create(columnProblem, SourceInfo.UNKNOWN_COLUMN_NUMBER, lineProblem, SourceInfo.UNKNOWN_LINE_NUMBER, String.valueOf(problem.getOriginatingFileName())); 
 sourceInfo = sourceInfoFactory.create(lineProblem, SourceInfo.UNKNOWN_LINE_NUMBER, 
 @Nonnull public FileTime getLastModified() throws CannotGetModificationTimeException { 
 * Copyright (C) 2016 The Android Open Source Project 
 } assertTrue(dir.delete()); 
 * Helper to construct a new DexImageClassLoader via indirect * ByteBuffer instances. 
 String result = (String) createLoaderDirectAndCallMethod("test2.Target2", "frotz", dex1, dex2); 
<|del|> 
 * Copyright (C) 2016 Google Inc. * 
 * Copyright (C) 2016 Google Inc. * 
 } return v; 
 ColumnSourceInfo newInstance = new ColumnSourceInfo((LineSourceInfo) si, startCol, endCol); 
 auth_rsp = null; 
 int v = 0; String s; 
 // Deliberately obscured to make optimizations less likely s = (rep >= 0) ? "hello, world!" : null; v += s.length(); 
 // Deliberately obscured to make optimizations less likely. String s = (rep >= 0) ? "hello, world!" : null; 
 // If your environment already provides encrypted storage which is only decryptable with a // key bound to another credential provided by the user, you may initialize the Keystore // immediately and get a waiver for this test. 
 .create("sched.filter.skip-adapters", "Skip adapters as soon as possible") 
 sb.append(" and unique"); 
<|del|> 
 logger.log(Level.WARNING, "Prebuilts from libraries are not used due to usage of jarjar"); 
 assertEquals("HmacSHA224", 
 assertEquals("HmacSHA224", 
 for (int i = 0; i < count; i++) { 
<|del|> 
 KeyStore.SecretKeyEntry ksSKE = new KeyStore.SecretKeyEntry(sk, attributeSet); Set<KeyStore.Entry.Attribute> returnedAttributeSet = ksSKE.getAttributes(); 
 Set<KeyStore.Entry.Attribute> returnedAttributeSet = ksTCE.getAttributes(); 
 assertFalse(principalC.implies(subject)); assertFalse(principalC.implies(null)); 
 if (testFramework.getApi() >= 24 && testFramework.isGoogleApiImage()) { 
 if (DeveloperOptionsManager.isDeveloperOptionsEnabled(instrumentation)) { 
 * Launches Settings and get the item list as a @{code UiScrollable}, ready to search for 
 * Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 private final A first; private final B second; Pair(A first, B second) { this.first = first; this.second = second; 
 private final A first; private final B second; Pair(A first, B second) { this.first = first; this.second = second; 
 private final A first; private final B second; Pair(A first, B second) { this.first = first; this.second = second; 
 HashMap<String, String> hashExpectedResult = new HashMap<String, String>(); 
<|del|> 
 public static final StatisticId<Counter> REMOVED_BASIC_BLOCK = new StatisticId<>( "jack.cfg.removed-basic-blocks", "Basic blocks removed", 
 // Jack defines unknown line by UNKNOWN_LINE_NUMBER, but dx requires to use -1. 
 // have a pointer to DexData otherwise it will prevent 
 return new File(file.getParent(), file.getName() + "[" + ((HasCharset) file).getCharset().name() + "]"); 
 * {@code @CriticalNative} (including usually-fast but generally unbounded methods)! * </p> 
 * <p> * <b>Deadlock Warning:</b> As a rule of thumb, do not acquire any locks during a critical native * call if they aren't also locally released [before returning to managed code]. * </p> 
 * Normal natives don't have the issue since once it's executing in native code, 
 * CriticalNative natives however don't do the state transition done by the normal natives. 
 // Callback when advertise parameters are set. 
<|del|>
 * Applied to native methods to enable an ART runtime built-in optimization: * methods that are annotated this way can speed up JNI transitions for methods that contain no * objects (in parameters or return values, or as an implicit {@code this}). 
 * This annotation has no effect when used with non-native methods. * The runtime must throw a {@code VerifierError} upon class loading if this is used with a native * method that contains object parameters, an object return value, or a non-static. 
 import static java.nio.charset.StandardCharsets.US_ASCII; 
<|del|> 
 /** * Checks decoding of bytes containing a value outside of the allowed * {@link #TABLE_1 "basic" alphabet}. */ 
 /** * Checks decoding of bytes containing a value outside of the allowed * {@link #TABLE_2 url alphabet}. */ 
 private static void checkDecoder_nonPrintableBytes_table1(Decoder decoder) throws Exception { 
 private static void checkDecoder_nonPrintableBytes_table1(Decoder decoder) throws Exception { 
 /** * Tests {@link Decoder#decode(byte[], byte[])} for correctness as well as * for consistency with other methods tested elsewhere. */ public void testDecoder_decodeArrayToArray() { 
 // Empty input assertEquals(0, decoder.decode(new byte[0], new byte[0])); 
 // Test data for non-empty input 
 // Non-empty input: output array too short 
 // Non-empty input: output array too long 
 // Non-empty input: output array size just right 
<|del|> 
 private static void checkDecoder_nullArgs(Decoder decoder) { 
 private static void checkEncoder_nullArgs(Encoder encoder) { 
 /** * Tests {@link Decoder#decode(byte[], byte[])} for correctness. */ public void testEncoder_encodeArrayToArray() { 
 private static void checkRoundTrip_empty(Encoder encoder, Decoder decoder) { 
 // Line lengths <= 3 mean no wrapping; the separator is ignored in that case. 
 /** * Checks round-trip encoding/decoding of all byte values 0..255 for * the case where the Encoder doesn't add any linebreaks. */ private static void checkRoundTrip_allBytes_singleLine(Encoder encoder, Decoder decoder) { 
 /** * Checks round-trip encoding/decoding of all byte values 0..255 for * the case where the Encoder doesn't add any linebreaks. */ private static void checkRoundTrip_allBytes_singleLine(Encoder encoder, Decoder decoder) { 
 private static void checkRoundTrip_variousSizes(Encoder encoder, Decoder decoder) { 
 assertEquals(255, in.read()); assertEquals(-1, in.read()); 
 private static void checkWrapOutputStreamConsistentWithEncode(Encoder encoder) throws Exception { 
 * Checks round-trip encoding/decoding of {@code plain}. * * @param plain an ASCII String * @return the Base64-encoded value of the ASCII codepoints from {@code plain} 
 private static void assertDecodeThrowsIAe(Decoder decoder, String invalidEncoded) throws Exception { 
 /** Asserts that actual equals the first len bytes of expected. */ 
<|del|> 
 String[] xattrs = Libcore.os.listxattr("/proc/version"); assertEquals(0, xattrs.length); 
 * Represents a single entry in the translations editor. 
 private String myKey; private ResourceItem myDefaultValue; private boolean myTranslatable; private Map<Locale, ResourceItem> myLocaleToTranslationMap; 
 StringResource(@NotNull String key, @Nullable ResourceItem defaultValue, boolean translatable, @NotNull Map<Locale, ResourceItem> localeToTranslationMap) { 
 StringResource(@NotNull String key, @Nullable ResourceItem defaultValue, boolean translatable, @NotNull Map<Locale, ResourceItem> localeToTranslationMap) { 
 StringResource(@NotNull String key, @Nullable ResourceItem defaultValue, boolean translatable, @NotNull Map<Locale, ResourceItem> localeToTranslationMap) { 
 myLocaleToTranslationMap = localeToTranslationMap; 
 void addTranslation(@NotNull Locale locale, @NotNull ResourceItem translation) { myLocaleToTranslationMap.put(locale, translation); 
<|del|> 
<|del|> 
 myKeys = keys; myKeyToResourceMap = keyToResourceMap; 
 StringResource stringResource = getStringResource(key); 
 StringResource stringResource = getStringResource(key); ResourceItem item = stringResource.getDefaultValue(); 
 StringResource stringResource = getStringResource(key); ResourceItem item = stringResource.getDefaultValue(); 
 StringResource stringResource = getStringResource(key); ResourceItem item = stringResource.getDefaultValue(); 
 StringResource stringResource = getStringResource(key); ResourceItem item = stringResource.getDefaultValue(); 
<|del|> 
 stringResource.removeTranslation(locale); 
 stringResource.addTranslation(locale, item); 
 Collection<Locale> localesWithTranslation = stringResource.getTranslatedLocales(); if (!localesWithTranslation.isEmpty()) { 
 StringResource stringResource = getStringResource(key); 
 throw new IllegalArgumentException("No StringResource for key " + key); 
 public Collection<StringResource> getResources() { return myKeyToResourceMap.values(); 
 SortedMap<String, StringResource> keyToResourceMap = new TreeMap<>(); 
 new CountDownTimer(millisInFuture, 1000) { 
 mCountdownTimer = new CountDownTimer(millisInFuture, 1000) { 
 // onFinish() cannot be used to determine accurate reset timing // because onFinish() may be called up to 2 seconds after last onTick(). 
 /// CHECK-NOT: bic{{(\.w)?}} /// CHECK-NOT: ubfx 
 Throwable exception = null; 
<|del|> 
 void setTranslation(@NotNull Locale locale, @NotNull ResourceItem translation, @NotNull String translationString) { myLocaleToTranslationMap.put(locale, new ResourceItemEntry(translation, translationString)); 
 StringResource stringResource = new StringResource(key); 
 assertNull(data.getStringResource("key1").getTranslation(Locale.create("hi"))); assertEquals("Key 2 hi", data.getStringResource("key2").resourceToString(Locale.create("hi"))); 
 assertNull(data.getStringResource(key).getTranslation(locale)); 
 "jack.jayce.cache.hit", "NNode cache hit", PercentImpl.class, Percent.class); 
 public NNodeId(@Nonnull String sessionId, @CheckForNull String digest, @Nonnull String fqName) { 
<|del|> 
<|del|> 
<|del|> 
 myKey = key; myDefaultValue = new ResourceItemEntry(); 
 ResourceItem getDefaultValueAsResourceItem() { 
 void setDefaultValue(@NotNull ResourceItem resourceItem, @NotNull String string) { myDefaultValue = new ResourceItemEntry(resourceItem, string); 
 void setDefaultValue(@NotNull ResourceItem resourceItem, @NotNull String string) { myDefaultValue = new ResourceItemEntry(resourceItem, string); 
 void setDefaultValue(@NotNull ResourceItem resourceItem, @NotNull String string) { myDefaultValue = new ResourceItemEntry(resourceItem, string); 
 myDefaultValue = new ResourceItemEntry(); 
 ResourceItem getTranslationAsResourceItem(@NotNull Locale locale) { 
 myString = string; 
 myString = string; 
 myString = string; 
 myString = string; 
<|del|> 
 @NotNull Map<String, StringResource> keyToResourceMap) { 
 throw new IllegalArgumentException("The old key \"" + oldKey + "\" doesn't exist."); 
 throw new IllegalArgumentException("The new key \"" + newKey + "\" already exists."); 
 List<String> keys = new ArrayList<>(myKeyToResourceMap.keySet()); Collections.sort(keys); return keys; 
<|del|> 
 * function signature. As an additional limitation, the method must be explicitly registered with 
 * {@literal @}{@link FastNative} instead of this. 
 * it is considered suspended from the runtime's point of view. 
 private final NetworkEvaluator[] mEvaluators = new NetworkEvaluator[MAX_NUM_EVALUATORS]; 
 public static final EllipticCurve X25519 = new EllipticCurve(29, "x25519"); public static final EllipticCurve X448 = new EllipticCurve(30, "x448"); 
 "arbitrary_explicit_prime_curves"); 
 case 0xFF01: return ARBITRARY_PRIME; case 0xFF02: return ARBITRARY_CHAR2; 
 StringBuilder sb = new StringBuilder(name); sb.append(" ("); sb.append(type); 
<|del|> 
 public static final EllipticCurve X25519 = new EllipticCurve(29, "x25519"); public static final EllipticCurve X448 = new EllipticCurve(30, "x448"); 
 name = "arg" + nameIdx; 
 @Test 
 * PrivilegedActionException's constructor argument may be rethrown by getException() or * getCause(). 
 cleanJacks(EnumSet.of(Category.CODE, Category.MEMORY), Collections.<Impact>emptySet()); 
 cleanJacks(EnumSet.of(Category.CODE, Category.MEMORY), EnumSet.of(Impact.LATENCY)); 
 * Server has no currently running task but it may require a delay to start new tasks, 
 * Server has no currently running task and may require a delay to start new tasks, task 
 private final Map<Locale, ResourceItemEntry> myLocaleToTranslationMap = new HashMap<>(); 
 cleanJacks(EnumSet.of(Category.CODE, Category.MEMORY), EnumSet.of(Impact.LATENCY, Impact.PERFORMANCE)); 
<|del|> 
 private final HashMap<String, WifiP2pDevice> mDevices = new HashMap<String, WifiP2pDevice>(); private Object mDeviceMapLock = new Object(); 
<|del|> 
 return myDefaultValue.myString; 
 return resourceItemEntry == null ? "" : resourceItemEntry.myString; 
 assertFalse(method1P0.equals(method0P0)); assertTrue(method0P0.equals(method0P0)); 
// See the definition of the jcaJceHelper field for details. 
 // We need to pass one instance of JcaJceHelper in the constructor of the former class. 
 // of the jcaJceHelper field for details. 
 private void sendScanResultBroadcast(boolean scanSucceeded) { 
 @NotNull 
 c.postResponse(RESPONSE_PEERS, listener, peerList); 
 mWifiKeyStore, mWifiConfigStore, mWifiConfigStoreLegacy); mNetworkScoreManager = (NetworkScoreManager) mContext.getSystemService(Context.NETWORK_SCORE_SERVICE); 
 mManager = new PasspointManager(mContext, mWifiNative); 
<|del|> 
 ExternalScoreEvaluator externalScoreEvaluator = new ExternalScoreEvaluator(context, mConfigManager, mClock, mLocalLog); mNetworkSelector.registerNetworkEvaluator(externalScoreEvaluator, 
 private final NetworkEvaluator[] mEvaluators = new NetworkEvaluator[MAX_NUM_EVALUATORS]; 
 } else if (app.killed) { 
 private final JcaJceHelper jcaJceHelper = new BCJcaJceHelper(); 
<|del|> 
 mLinkProperties, 60); 
<|del|> 
 * <td>1&ndash;22</td> 
 * The set of name types accepted when parsing time zone names. 
 * The set of name types accepted when parsing time zone names. 
 * Parse the time zone string using the ICU4J class {@link TimeZoneNames}. 
 text.regionMatches(true /* ignoreCase */, start, UTC, 0, UTC.length())) { 
<|del|> 
 * Parses the time zone string using the information in {@link #formatData}. 
 for (WifiP2pDevice d : source.getDeviceList()) { mDevices.put(d.deviceAddress, new WifiP2pDevice(d)); 
 d.groupCapability = groupCapab; 
 d.status = status; 
 Thread.sleep(TEST_END_SLEEP_MSEC); // put a gap in the tone sequence 
<|del|> 
 if (TEST_IS_LOW_RAM_DEVICE && (TEST_CHANNELS > 4 || TEST_SR > 96000)) { 
 if (TEST_IS_LOW_RAM_DEVICE) Thread.sleep(200 /* millis */); else Thread.sleep(50 /* millis */); 
 } 
 Thread.sleep(TEST_END_SLEEP_MSEC); 
<|del|> 
<|del|> 
 return GetValues006Debuggee.class.getName(); 
 assertTagEquals("Invalid value tag is returned,", JDWPConstants.Tag.INT_TAG, fieldTag); 
 /** Try up to 3 times to negotiate a connection with each server. */ 
<|del|> 
 // Normal native. 
 * class to provide generic functionality to start alarm which * starts other RPC calls in other facade 
public class AlarmManagerFacade extends RpcReceiver { private final Service mService; private FacadeManager mFacadeManager; private AlarmManager mAlarmManager; private AlarmListener mAlarmListener; 
 AlarmManager.ELAPSED_REALTIME_WAKEUP, elapsedRealtime + startTime*1000, PendingIntent.getBroadcast((Service) mService, 0, 
 * constructor * * @param manager - FacadeManager object is provided by sl4a 
 @RpcParameter(name = "methodArgs") String methodArgs) 
<|del|> 
 * class to provide generic functionality to start alarm which * starts other RPC calls in other facade 
public class AlarmManagerFacade extends RpcReceiver { private final Service mService; private FacadeManager mFacadeManager; private AlarmManager mAlarmManager; private AlarmListener mAlarmListener; 
 alarmIntent, 0)); 
 * constructor * * @param manager - FacadeManager object is provided by sl4a 
 @RpcParameter(name = "methodArgs") String methodArgs) 
<|del|> 
 if (layoutDirection != mLayoutDirection && isLayoutDirectionResolved()) { mLayoutDirection = layoutDirection; if (mIndentLines > 0) { // Invalidate layout. setHint(getHint()); } 
 RunnableHooks hooks = new RunnableHooks(); boolean processedWithoutError = false; 
 RunnableHooks hooks = new RunnableHooks(); boolean processedWithoutError = false; 
<|del|> 
 // TODO(paulduffin): b/31542223 - Work out why this is failing in CTS, fix and reenable. 
 logger.log(Level.SEVERE, "Uncaught exception during RunnableHook", e); 
 if (getLayoutDirection() == LAYOUT_DIRECTION_RTL) { 
 String unsuccess_caption = mContext.getResources().getQuantityString( 
public class DescribableComparator implements Comparator<Describable> { 
public class DescribableComparator implements Comparator<Describable> { 
 return descriptionComparator.compare(d1.getDescription(), d2.getDescription()); 
 public DescribableStatement createTest( Class<? extends TestCase> testClass, String methodName, Annotation[] annotations) { 
 private T createTest( Class<? extends TestCase> testClass, String methodName, Annotation[] annotations) { 
 throw new AssertionFailedError("Class " + testClass.getName() + " is not public"); 
@Retention(RetentionPolicy.SOURCE) 
<|del|> 
 .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class) 
 add = {JLocal.class, JLocalRef.class, JAsgOperation.NonReusedAsg.class, JExpressionStatement.class, JLabeledStatement.class}) 
 ArrayList<String> availableList = new ArrayList<String>(); ArrayList<String> activeList = new ArrayList<String>(); ArrayList<String> erroredList = new ArrayList<String>(); 
 assertTrue(fCpu.canRead()); 
 } AppLauncher.launch(instrumentation, "RsHelloCompute"); assertTrue(testFramework.getDevice().findObject(new UiSelector().resourceId( Res.APP_IMAGE_VIEW_ID)).exists()); 
 private static final String NAME = "WifiExternalScoreEvaluator"; private static final String TAG = "ExternalScoreEvaluator: "; 
<|del|> 
 * Returns the available external network score or null if no score is available. 
<|del|> 
 public static final int EXTERNAL_SCORED_NONE = 0; public static final int EXTERNAL_SCORED_SAVED_NETWORK = 1; public static final int EXTERNAL_SCORED_UNTRUSTED_NETWORK = 2; private int mBestCandidateType = EXTERNAL_SCORED_NONE; 
 public static final int EXTERNAL_SCORED_NONE = 0; public static final int EXTERNAL_SCORED_SAVED_NETWORK = 1; public static final int EXTERNAL_SCORED_UNTRUSTED_NETWORK = 2; private int mBestCandidateType = EXTERNAL_SCORED_NONE; 
<|del|> 
 * ephemeral networks are allowed * @param scoreCache score cache for WiFi networks 
 * ephemeral networks are allowed * @param scoreCache score cache for WiFi networks 
 private boolean isCurrentNetworkSufficient(WifiConfiguration network) { 
 // Android-changed: Fix unsafe publication http://b/31467561 // Fixed in OpenJDK 9: http://hg.openjdk.java.net/jdk9/dev/jdk/rev/29ecac30ecae 
<|del|> 
 * Thrown when the requested Jack configuration for a given API version is not supported because it * is unknown to this Jack. 
 private final static SortedMap<String, MethodDescriptor> sRpcs = new TreeMap<String, MethodDescriptor>(); 
<|del|> 
 mInstrumentation.waitForIdleSync(); 
 /** Boot-relative timestamp when the last candidate scanresult was received, used to calculate RSSI deltas. -1 designates no candidate scanResult being tracked */ private long mScanResultRssiTimestampMillis = -1; 
 List<WifiMetricsProto.RssiPollCount> rssiDeltas = new ArrayList<>(); 
 // Generate a single delta 
 /** * Tests that Rssi Delta events whose scanResult and Rssi Poll come too far apart, timeout, * and are not logged. */ @Test public void testRssiDeltasTimeout() throws Exception { // Create timed out rssi deltas 
 MethodHandles.Lookup defaultLookup = MethodHandles.lookup(); assertSame(MethodHandlesTest.class, defaultLookup.lookupClass()); assertEquals(ALL_LOOKUP_MODES, defaultLookup.lookupModes()); 
 return; 
 protected String cloneLocalName(@Nonnull String orgName) { 
 add = {JLocal.class, JLocalRef.class, JAsgOperation.NonReusedAsg.class, JExpressionStatement.class, JLabeledStatement.class}) 
 JLocal local = lvc.createTempLocal(params.get(i).getType(), src, tr); 
 @Nonnull String name) { 
 public static boolean getBooleanValueFromAnnotation(@Nonnull JAnnotation annotation, @Nonnull String name, boolean defaultValue) { boolean value = defaultValue; 
 if (removeAfterValuePair != null && removeAfterValuePair.getValue() instanceof JBooleanLiteral) { value = ((JBooleanLiteral) removeAfterValuePair.getValue()).getValue(); } return value; 
 if (hasPolymorphicSignature.isUndefined()) { UserFriendlyFormatter formatter = UserFriendlyFormatter.getFormatter(); 
 assertEquals(2, mDeserializedWifiMetrics.rssiPollDeltaCount.length); 
 assertEquals(2, mDeserializedWifiMetrics.rssiPollDeltaCount.length); 
 ScanResult scanResult = mock(ScanResult.class); when(networkSelectionStat.getCandidate()).thenReturn(scanResult); 
 WifiMetrics.ConnectionEvent.FAILURE_NONE, 
 // reset the input reader to null. This would still allow ready() 
<|del|> 
 // reset the output writer to null. This would still allow write() 
 // reset the output writer to null. This would still allow write() 
 // Android-changed: made final private static final int DEFAULT_BUFFER_SIZE = 8192; 
 tmpFile = File.createTempFile("jackserver-", file.getName(), file.getParentFile()); 
<|del|> 
 l.get(1000L, TimeUnit.MILLISECONDS); 
<|del|> 
<|del|> 
 assertEquals(2, l.get(MIN_FIND_WAIT_MS, TimeUnit.MILLISECONDS).intValue()); 
 l.get(MIN_FIND_WAIT_MS, TimeUnit.MILLISECONDS); 
 final int uncryptTimeoutError = 100; 
 callingPackage); 
<|del|> 
 sendMessage(CMD_CLIENT_INTERFACE_DOWN, networkInterface); 
 mImpl = new RttServiceImpl(getContext(), mHandlerThread.getLooper(), WifiInjector.getInstance()); 
 e.printStackTrace(); // TODO: Dialog 
public class TelephonyProviderTest extends TestCase { 
<|del|> 
 private InMemoryTelephonyProviderDbHelper mDbHelper; 
 String timeoutMessage = String.format("uncrypt_time: %d\n" + "uncrypt_error: %d\n", 
 String timeoutMessage = String.format("uncrypt_time: %d\n", "uncrypt_error: %d\n", MAX_UNCRYPT_WAIT_TIME / 1000, uncryptTimeoutError); 
 if (trackerHook != DEFAULT_TRACKER || tracker != DEFAULT_TRACKER) { throw new IllegalStateException( "Cannot set tracker as it is already in use: " + trackerHook); } trackerHook = tracker; 
 public static Boolean[] wrapArray(@NonNull boolean[] array) { 
import java.util.Arrays; 
 final int n = array.length; Boolean[] wrappedArray = new Boolean[n]; for (int i = 0; i < n; ++i) { wrappedArray[i] = array[i]; } 
 } 
 * 
 * <p>If the underlying method is static, then the specified {@code receiver} 
 * this object on {@code receiver} with parameters 
 UNKNOWN_PID, uid, "WifiP2pService"); 
<|del|> 
 String sessionName = getSessionId(); String sessionPostfix = TextUtils.isEmpty(sessionName) ? "" : ": " + sessionName; 
 } 
 * * @hide 
 * either a regular method or a constructor. * * @hide 
 void checkChainPinning(String hostname, List<X509Certificate> chain) throws CertificateException; 
 assertTrue(manager.called); 
 mCurrentState.volteAvailable = mImsRegistered && mVolteEnabled; 
 && pr.curReceivers.isEmpty()) { 
 receivingQueues.add(r.queue); 
 receivingQueues.add(r.queue); 
 } else if (isReceivingBroadcastLocked(app, queues)) { 
 if (app.waitingToKill != null && app.curReceivers.isEmpty() 
 && app.curReceivers.isEmpty() && app.services.size() == 0) { 
 final ArraySet<BroadcastRecord> curReceivers = new ArraySet<BroadcastRecord>();// receivers currently running in the app 
 for (int i=0; i < curReceivers.size(); i++) { pw.print(prefix); pw.print(" - "); pw.println(curReceivers.valueAt(i)); 
 for (int i=0; i < curReceivers.size(); i++) { pw.print(prefix); pw.print(" - "); pw.println(curReceivers.valueAt(i)); 
 if (type >= OPEN_SSL_WITH_OCSP) { 
<|del|> 
 private static volatile Tracker trackerHook = DEFAULT_TRACKER; 
 * Returns {@link #setTracker(Tracker) last Tracker that was set}, or otherwise a default * Tracker that does nothing. 
 * first parameter owns and throw a {@link AssertionError} if that does not match the * expected number of resources specified by the second parameter. 
 public final class RandomAccessFileTest extends TestCase { 
public abstract class TestCaseWithRules extends TestCase { 
 * Provides support for testing classes that own resources which must not leak. 
 } 
<|del|> 
<|del|> 
import libcore.io.IoBridge; import libcore.io.IoTracker; 
 protected ZygoteConnection createNewConnection(LocalSocket socket, String abiList) throws IOException { 
 * name. If a time zone is found, the internal calendar is set to that timezone and the index of * the first character after the time zone name is returned. Otherwise, returns {@code 0}. 
 * Parses the time zone string using the ICU4J class {@link TimeZoneNames}. 
 * runtest --path tests/src/com/android/providers/telephony/TelephonyProviderTest.java \ 
<|del|> 
 // Generic tag for all Telecom logging 
 private static boolean sIsUserExtendedLoggingEnabled = false; 
 private static boolean sIsUserExtendedLoggingEnabled = false; 
 private static long sUserExtendedLoggingStopTime = 0; 
 public static void startSession(String shortMethodName, String callerIdentification) { getSessionManager().startSession(shortMethodName, callerIdentification); 
 if (sessionId == null) { 
 * (if more than one detour has been installed for it). 
 mDeathRecipient.unlinkToDeath(); unregisterObserver(); 
 unregisterObserver(); 
 mIfaceIsUp = false; InterfaceConfiguration config = null; try { config = mNwService.getInterfaceConfig(mApInterface.getInterfaceName()); } catch (RemoteException e) { } if (config != null) { onUpChanged(config.isUp()); } 
 // The lines below must set the Locales in this order because setDefault(Locale) // overwrites the other ones. Locale.setDefault(locales.uncategorizedLocale); 
 // The lines below must set the Locales in this order because setDefault(Locale) // overwrites the other ones. Locale.setDefault(locales.uncategorizedLocale); 
 Log.i("Zygote", "Process: zygote socket " + socketAddress + " opened, supported ABIS: " + abiListString); 
 ArrayList<String> argsForZygote = new ArrayList<String>(); 
<|del|> 
 // TODO: Use preload information to setup the ClassLoader. 
<|del|> 
<|del|> 
 return handlePreloadPackage(parsedArgs.preloadPackage, parsedArgs.preloadPackageLibs); 
 throw new IllegalArgumentException( "Unexpected arguments after --preload-package."); 
 private static volatile Tracker currentTracker = DEFAULT_TRACKER; 
 static void setTracker(Tracker tracker) { 
 currentTracker = tracker; 
<|del|> 
 * Runs bisection bug search. 
<|del|> 
 // notify simRecordsLoaded registrants for cdmaLte phone r.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null); 
<|del|> 
 if (isCustomSubclass()) { 
 if (isCustomSubclass()) { 
<|del|> 
 * |encodedKey| will be skipped. Since a PrivateKey can only be constructed with 
 } catch (CertificateEncodingException e) {} 
 if (length == 0) { 
 // This will create a new marker_fd for the new process which is required to pre-close the // sockets. PlainSocketImpl.socketSetNewAndCloseLastMarkerFD(); 
 doStagefrightTestMediaPlayer(R.raw.bug_14388161); 
<|del|> 
 IoBridge.connect(fd, addr, 7 /* Echo-protocol port */, timeout); 
 } catch (CertificateEncodingException e) { /* empty, write null. */ } 
 if (length == 0) { 
 try (ZipInputStream zis = new ZipInputStream(in)) { while ((zentry = zis.getNextEntry()) != null) { zentry.getName(); } 
 // This will throw a ZipException if nothing is written to the ZipOutputStream. 
 if (threshRsrp.length > 5 && mLteRsrp > threshRsrp[5]) rsrpIconLevel = -1; 
 public static OutputVFSPropertyId create( @Nonnull String name, @Nonnull String description, @Nonnull OutputVFSCodec codec) { 
 @Nonnull Directory baseDir) 
 int uid = mHmap.size() + 1; mHmap.put(uid, mediaId); return intToByteArray(uid); 
 iis.reset(); fail("Should throw IOException"); } catch (IOException e) { // correct 
 byte[] decompressed = new byte[32]; byte[] compressed = deflate(new byte[] { 1, 2, 3 }, null); assertEquals(11, compressed.length); 
 inputs.add(emptyInputStream); 
 assertEquals(-1, sequenceInputStream.read(buf, 0, 10)); 
<|del|> 
 if (testFramework.getApi() >= 24 && testFramework.isGoogleApiImage()) { 
 if (testFramework.getApi() >= 24 && testFramework.isGoogleApiImage()) { 
 String[] allOpenSSLCipherSuites = get_cipher_names("ALL:-GENERIC"); 
 static { // Suppress TLS 1.3's generic AEAD-only ciphers for now. They will be restored once TLS 1.3 // support is enabled. 
 // OAEP padding modes change the output and block size. SHA-1 is the default. setExpectedBlockSize("RSA/ECB/OAEPPadding", Cipher.ENCRYPT_MODE, 214); 
 static private final Boolean DEBUG = false; 
<|del|> 
 @Nonnull private final JAnnotationType forceInlineAnnotationType; 
 @Nonnull private final InlineVisitor inlineVisitor = new InlineVisitor(); 
 public InlineAnnotatedMethods() { forceInlineAnnotationType = getJAnnotationType(ForceInline.class); } private class InlineVisitor extends JVisitor { 
 public InlineAnnotatedMethods() { forceInlineAnnotationType = getJAnnotationType(ForceInline.class); } private class InlineVisitor extends JVisitor { 
 List<JAnnotation> annotationList = target.getAnnotations(forceInlineAnnotationType); 
 public void run(@Nonnull JMethod method) { 
 inlineVisitor.accept(method); 
 private void internalCloneBlock(@Nonnull JBlock newBlock, @Nonnull JBlock orgBlock) { 
 assert targetInstanceVar != null; expression = targetInstanceVar.makeRef(ref.getSourceInfo()); 
 JVariableRef targetThis = (JVariableRef) candidate.callSite.getInstance(); this.targetThis = targetThis == null ? null : targetThis; 
 JVariableRef targetThis = (JVariableRef) candidate.callSite.getInstance(); this.targetThis = targetThis == null ? null : targetThis; 
 @CheckForNull 
 private Visitor(@Nonnull TransformationRequest tr) { 
 public boolean visit(@Nonnull JMethod jm) { 
 public void run(@Nonnull JSession session) { 
 @Nonnull protected String cloneLocalName(@Nonnull String orgName) { 
 Handle(long[] apkHandles, boolean multiArch, boolean extractNativeLibs, boolean debuggable) { 
 boolean active = TextUtils.equals(currentBssid, scanResult.BSSID); 
 && TextUtils.equals(currentBssid, scanResult.BSSID); 
 l.add(new Object()); l.add(new Integer(1)); 
<|del|> 
 private final boolean removeAfterDefault; 
 REMOVE_AFTER_ANNOTATION, removeAfterDefault) && target.getEnclosingType().isToEmit()) { target.addMarker(RemoveInlinedMarker.INSTANCE); 
 REMOVE_AFTER_ANNOTATION, removeAfterDefault) && target.getEnclosingType().isToEmit()) { target.addMarker(RemoveInlinedMarker.INSTANCE); 
 return Jack.getSession().getLookup().getAnnotationType(signature); 
 statement = updateCatchBlockList(newBlock, orgBlock); return false; 
@Description("Marker instruct Jack to inline a specific method.") 
 JExpression instance = candidate.callSite.getInstance(); this.targetThis = instance == null ? null : ((JVariableRef) instance).getTarget(); 
 private final JLocal returnLocal; 
<|del|> 
<|del|> 
 * Copyright (C) 2016 The Android Open Source Project 
 // Allow some initial jitting of classpath methods to be finished. 
@Constraint(no = {DefinitionMarker.class, UseDefsMarker.class}, need = AnnotationMethodDefaultValue.class) 
<|del|> 
@ExclusiveAccess(JSession.class) public class JMethodInliner implements RunnableSchedulable<JMethod> { 
 public void run(JMethod jm) { if (jm.isNative() || jm.isAbstract()) { return; } TransformationRequest tr = new TransformationRequest(jm); new Visitor(jm, tr).accept(jm); 
 cleanExternalMediaFile(file.getAbsolutePath()); 
 } else if (sleep) { // Make it easier to be suspended here by doing a sleep so we can test // suspending and deopting another thread. 
 ensureJitCompiled(Main.class, "testNoOverrideLoop"); ensureJitCompiled(Main.class, "calcValue"); 
 } } catch (IOException | RuntimeException | Error e) { if (!tmpOut.delete()) { logger.log(Level.SEVERE, "Failed to delete temp file '" + tmpOut.getPath() + "'"); } throw e; 
 return (homeSp == null ? that.homeSp == null : homeSp.equals(that.homeSp)) && (credential == null ? that.credential == null : credential.equals(that.credential)); 
 try { iis.read(outBuf, -1, 10); fail("should throw IOOBE."); } catch (IndexOutOfBoundsException e) { // expected; } 
 try { iis.read(); fail("IOException expected."); } catch (IOException ee) { // expected } 
<|del|> 
 NativeCrypto.setEnabledProtocols(sslNativePointer, filteredProtocols); 
 private NumberFormat formatter; 
 expected += 1; } 
@Constraint(no = {DefinitionMarker.class, UseDefsMarker.class}) 
 List<JAnnotation> annotationList = target.getAnnotations(forceInlineAnnotationType); if (!annotationList.isEmpty()) { call.addMarker(new InlineMarker(target)); } 
 static boolean sIsOptimizing = true; static boolean sHasJIT = true; static volatile boolean sOtherThreadStarted; 
<|del|> 
 return (ks = keySet) != null ? ks : (keySet = new KeySetView<K,V>(this, null)); 
 } if (name == null) { throw new NullPointerException("name == null"); } 
 static void testOverride(boolean createMain2, boolean wait) { if (createMain2 && (sIsOptimizing || sHasJIT)) { 
 throw new SSLHandshakeException("No enabled protocols; " + NativeCrypto.OBSOLETE_PROTOCOL_SSLV3 + " is no longer supported and was filtered from the list"); 
 return enabledProtocols.clone(); 
 LambdaInterfaceSignature.forLambda(lambda, /* normalize = */ false).getUniqueId(); 
 "HmacSHA256", 
 "HmacSHA256", 
 // The returned object is still an instance of KeySetView. 
<|del|> 
 if ((ks = keySet) != null) return ks; return keySet = new KeySetView<K,V>(this, null); 
 //@sun.misc.Contended // android-removed 
 * See {@link #keySet() keySet()}, * {@link #keySet(Object) keySet(V)}, 
 * components (such as {@link java.nio.channels.CompletionHandler}) 
 if (!streams.isClosed()) { return false; } 
 static void potentialInfiniteLoop(int n) { 
 /// CHECK-DAG: Return loop:none // /// CHECK-START: int Main.periodicReturned9() instruction_simplifier$after_bce (after) /// CHECK-DAG: <<Int:i\d+>> IntConstant 1 /// CHECK-DAG: Return [<<Int>>] loop:none 
 /** * Invoked when the end of the XML element is detected. Used for further processing * of the text enclosed within this XML element. Invoked by {@link XMLParser#endElement}. */ 
 TextUtils.equals(mText, that.mText) && 
 TextUtils.equals(mText, that.mText) && 
 if (lastUserSelectedNetworkId != WifiConfiguration.INVALID_NETWORK_ID && lastUserSelectedNetworkId == network.networkId) { 
<|del|> 
 Socket theSocket = new Socket(); theSocket.close(); try { theSocket.sendUrgentData(0); fail("IOException was not thrown."); } catch (IOException ioe) { //expected 
 // Either of the getInputStream() or the read(...) call can time out. 
<|del|> 
 Class<?> refc, Class<?> specialCaller) throws IllegalAccessException { 
 Class<?> refc, Class<?> specialCaller) throws IllegalAccessException { 
 server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE)); server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE)); server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE)); 
 try (ZipFile zip = new ZipFile(zipFile)) { 
 try (InputStream resourceStream = zip.getInputStream(entry)) { 
 Assert.assertTrue("Cannot detect sensor reconnection.", mCallback.waitForConnection(mSensorId)); 
 if (mExpectSensorId == null || mExpectSensorId == sensor.getId()) { 
 if (mExpectSensorId == null || mExpectSensorId == sensor.getId()) { 
 Security.insertProviderAt(new OpaqueProvider(), 1); 
 final TestSSLContext c = TestSSLContext.create(keyStore, TestKeyStore.getServer()); SSLContext clientContext = SSLContext.getInstance("TLS"); 
 put("Signature.NONEwithRSA", OpaqueSignatureSpi.RSA.class.getName()); put("Signature.NONEwithECDSA", OpaqueSignatureSpi.ECDSA.class.getName()); put("Cipher.RSA/ECB/NoPadding", OpaqueCipherSpi.class.getName()); 
 tmpdir, 
<|del|> 
 assertNull(((ConcurrentHashMap.KeySetView) map.keySet()).getMappedValue()); 
<|del|> 
 return allClosed; 
 parent.addChild(mCurrent); } 
 mCurrent); } 
 private final Instrumentation mInstrumentation = InstrumentationRegistry.getInstrumentation(); private final UiDevice mDevice = UiDevice.getInstance(mInstrumentation); private final Context mContext = mInstrumentation.getTargetContext(); 
<|del|> 
<|del|> 
 public String getSmsTextMessage() { return smsTextMessage; } 
 private static final String SMS_ADDRESS_COLUMN = "address"; private static final String SMS_BODY_COLUMN = "body"; private static final String SMS_SERVICE_PATH = "/SmsManagerService"; private static final String ACTION = "String"; private final Context mContext; 
 private static final String SMS_ADDRESS_COLUMN = "address"; private static final String SMS_BODY_COLUMN = "body"; private static final String SMS_SERVICE_PATH = "/SmsManagerService"; private static final String ACTION = "String"; private final Context mContext; 
 result.setDescription(Log.getStackTraceString(e)); 
 return smsAddress; 
 return smsTextMessage; 
<|del|> 
 // Forward specific parameters to Caliper. 
 // This configuration runs about 15x faster than not having this configuration. 
 */ try { socketPreClose(); } finally { socketClose(); } fd = null; return; } else { /* 
 static final int S_IAMB = get_S_IAMB(); 
 DirectoryStream<Path> ds_path_dir1 = ds_path_root.newDirectoryStream(path_root. relativize(path_dir1))) { ds_path_dir1.forEach(path -> pathsSet.add(path)); assertEquals(expectedPathsSet, pathsSet); 
 DirectoryStream<Path> ds_path_dir1 = ds_path_root.newDirectoryStream(path_root. relativize(path_dir1))) { ds_path_dir1.forEach(path -> pathsSet.add(path)); assertEquals(expectedPathsSet, pathsSet); 
<|del|> 
 if (config.has(WifiEnterpriseConfig.EAP_KEY)) { 
 @Test 
 public static Object $noinline$newObject() { 
 if (removeAfterValuePair != null && removeAfterValuePair.getValue() instanceof JBooleanLiteral) { value = ((JBooleanLiteral) removeAfterValuePair.getValue()).getValue(); } return value; 
 for (int i = 0; i < expectedMap.size(); ++i) { final Map.Entry<Integer, String> e = entries[i]; assertEquals(expectedMap.get(e.getKey()), e.getValue()); 
 // http://b/32294038, Test ArrayMap.entrySet().toArray() public void restEntrySetArray() { 
 ArrayMap<Integer, String> testMap = new ArrayMap<>(); 
 testMap.entrySet().toArray(null); fail(); 
 assertSame(entries, testMap.entrySet().toArray(entries)); assertEntriesEqual(testMap, entries); 
 assertEntriesEqual(testMap, entries); 
 Map.Entry<Integer, String>[] entries = testMap.entrySet().toArray(new Map.Entry[10]); 
 Map.Entry<Integer, String>[] entries = testMap.entrySet().toArray(new Map.Entry[10]); 
 Map.Entry<Integer, String>[] otherEntries = otherMap.entrySet().toArray(new Map.Entry[1]); 
 Map.Entry<Integer, String>[] otherEntries = otherMap.entrySet().toArray(new Map.Entry[1]); 
<|del|> 
 AC.finishAllocationCopyTests(); assertTrue(mRanErrorHandler); 
 @SuppressWarnings("unchecked") T[] newArray = (T[]) Array.newInstance(array.getClass().getComponentType(), N); 
 for (int i=0; i < N; i++) { 
 assertTrue("Could not delete symlink: " + path, new File(path).delete()); 
 assertTrue("Could not delete symlink: " + path, new File(path).delete()); 
 * Called periodically (POLL_RSSI_INTERVAL_MSECS) about every 3 seconds. 
 if (mScreenBrightnessDarkConfig > screenBrightnessSettingMinimum) { 
 public class TransportControlsImpl implements MediaController.TransportControls { 
 /// CHECK-START: java.lang.Object Main.newObject() prepare_for_register_allocation (after) 
 public static void main(String[] args) { newFinalizableMayThrow(); newObject(); } 
 s = "Test"; 
 } AclFileAttributeView aclView = Files.getFileAttributeView(file.toPath(), AclFileAttributeView.class); if (aclView != null) { return new AclFileAccess(file, aclView); } throw new UnsupportedFileSystemAccessException(file); 
 public UnsupportedFileSystemAccessException(@Nonnull Path path) { this.path = path; 
 @Mock WifiConfigManager mWifiConfigManager; @Mock WifiInfo mWifiInfo; 
<|del|> 
 * Test for operation with null NetworkAgent 
 wifiMetrics); // TODO: make sure wifiMetrics has been updated 
 public final int hashCode() { 
 public final boolean equals(Object obj) { 
 public String getNewName(@Nonnull Key key) { 
 private final int mBadLinkSpeed24; // 6 Mbps private final int mBadLinkSpeed5; // 12 Mbps private final int mGoodLinkSpeed24; // 24 Mbps private final int mGoodLinkSpeed5; // 36 Mbps 
 + " score=" + Integer.toString(wifiInfo.score) // Previous score 
 // TODO: switch to the new method name if it doesn't break any tools b/32380868 
 if (info == null) { 
 return mAssistUtils.getAssistComponentForUser(KeyguardUpdateMonitor.getCurrentUser()); 
 private void checkAccessRight(@Nonnull File file) throws IOException { FileAccess fileAccess = FileAccess.get(file.toPath()); 
 Set<PosixFilePermission> invalidPerimissions = view.readAttributes().permissions(); 
 public static FileAccess get(@Nonnull Path path) throws IOException { 
 private static <T> void assertEntriesEqual(Map<Integer, String> expectedMap, T[] entries) { 
 public void testEntrySetArray() { 
 final int N = colGetSize(); 
 mWifiScoreReport = new WifiScoreReport(mContext, wifiConfigManager); 
<|del|> 
 throws NotFileException, WrongPermissionException, NoSuchFileException, NotJarFileException { this(getFileFromWorkingDirectory(workingDirectory, path), new FileLocation(path)); 
 protected JarFile processZip(@Nonnull File file) throws ZipException { 
 * Check to see if the service provider name expression from the XML matches the * CarrierIdentifier. 
 private static Logger logger = LoggerFactory.getLogger(); 
 logger.log(Level.WARNING, "Failed to open resource '" + name + "' from " 
 logger.log(Level.WARNING, "Failed to load class '" + name + "' from " 
 ServiceLoader.load(type, new URLClassLoader(new URL[] {jar.getFile().toURI().toURL()}, 
 return null; } catch (NotFileOrDirectoryException | NoSuchFileException e) { return null; 
 public DirectFSCodec() { 
 if (!(thatObject instanceof PasspointConfiguration)) { 
 if (!(thatObject instanceof CertificateCredential)) { 
 if (!(thatObject instanceof SimCredential)) { 
 if (!(thatObject instanceof Credential)) { 
 if (!(thatObject instanceof HomeSP)) { 
 * Copyright (C) 2016 The Android Open Source Project 
 netWrote = NativeCrypto.ENGINE_SSL_write_BIO_heap(sslNativePointer, networkBio, src.array(), src.arrayOffset() + pos, len, this); 
 System.out.println("Unexpected return type for handle: " + handle + " [ " + handle.type() + "]"); 
 System.out.println("Unexpected return type for handle: " + handle + " [ " + handle.type() + "]"); 
 * @return shortest representation of {@code uuid} as bytes. * @throws IllegalArgumentException If the {@code uuid} is null. 
 * @return shortest representation of {@code uuid} as bytes. * @throws IllegalArgumentException If the {@code uuid} is null. 
 getBassBoost(getSessionId()); 
 public boolean wifiScannerSetAlwaysAvailable( 
 * Change rev/d1c04dac850d upstream addresses the case of the string CN=prefix\<>suffix. 
 logger.log(Level.WARNING, "Uploaded jar does not contain a supported Jack"); 
 Visitor v = null; do { TransformationRequest tr = new TransformationRequest(jm); v = new Visitor(jm, tr); v.accept(jm); tr.commit(); } while (v.inlined); 
 List<AclEntry> keptAcl = new ArrayList<>(1); // Tests showed that getAcl is returning all ACEs: inherited ACEs and explicit ACEs. 
 public InputJarFile(@Nonnull String path) throws WrongPermissionException, NotFileException, NoSuchFileException, NotJarFileException { this(new File(path), new FileLocation(path)); 
 // Sleep for 2 seconds to give JIT a chance. 
<|del|> 
 if (testFramework.getApi() >= 24) { 
 response.setStatus(Status.BAD_REQUEST); 
 byteBuffer = ByteBuffer.allocateDirect(4).put(byteBuffer); byteBuffer.flip(); byteBuffer.position(2); assertChecksumFromByteBuffer(0xc0008, byteBuffer); 
 byteBuffer = ByteBuffer.allocateDirect(4).put(byteBuffer); byteBuffer.flip(); byteBuffer.position(2); assertChecksumFromByteBuffer(0xc0008, byteBuffer); 
 Adler32 checksum = new Adler32(); try { 
 // Heap ByteBuffer ByteBuffer byteBuffer = ByteBuffer.wrap(new byte[] {1,2,3,4}); byteBuffer.position(2); assertChecksumFromByteBuffer(0xc0008, byteBuffer); 
 directByteBuffer.flip(); directByteBuffer.position(2); assertChecksumFromByteBuffer(0xc0008, directByteBuffer); 
 // Heap ByteBuffer ByteBuffer byteBuffer = ByteBuffer.wrap(new byte[] {1,2,3,4}); byteBuffer.position(2); assertChecksumFromByteBuffer(0x6d998525, byteBuffer); 
 public static final String EXTRA_IDLE_TIME = "android.bluetooth.BluetoothInputDevice.extra.IDLE_TIME"; 
 private boolean leakageDetectionEnabledForTest; 
 * <p>The above tests will work on the reference implementation as this method does nothing * when {@code CloseGuard} is not supported. 
 * {@code CloseGuard} objects owned by the resource, and on which it calls * {@code CloseGuard.warnIfOpen()} in its {@link #finalize()} method; usually 1. 
 if (leakageDetectionEnabledForTest) { FINALIZER_CHECKER.accept(owner, expectedCount); } else { 
 + vfs.getLocation().getDescription(), e); 
<|del|> 
 /** * Test a openJdk8 fix for case where GZIPInputStream.readTrailer may accidently 
 public void testNoCloseInReadTrailerDueToRead() throws IOException { final int numBytes = 128; byte[] data = new byte[numBytes]; 
 final byte[] compressedData = byteArrayOutputStream.toByteArray(); InputStream byteArrayInputStream = new ByteArrayInputStream(compressedData) { 
 assertEquals(numBytes, in.skip(numBytes+1)); 
 void setImsVolteProvisionedState(boolean state) { 
 private static final int HOME_VISIBLE_NETWORK_MAX_COUNT = 6; 
 * Test for score reporting * * The score should be sent to both the NetworkAgent and the * WifiMetrics 
 * Test for operation with null NetworkAgent 
 verify(mWifiMetrics, times(8)).incrementWifiScoreCount(anyInt()); 
<|del|> 
 if (mVpnPreference != null) { mVpnPreference.checkRestrictionAndSetDisabled(UserManager.DISALLOW_CONFIG_VPN); } 
 if (mVpnPreference != null) { mVpnPreference.checkRestrictionAndSetDisabled(UserManager.DISALLOW_CONFIG_VPN); } 
 if (mVpnPreference != null) { mVpnPreference.checkRestrictionAndSetDisabled(UserManager.DISALLOW_CONFIG_VPN); } 
 if (RestrictedLockUtils.hasBaseUserRestriction(context, UserManager.DISALLOW_NETWORK_RESET, UserHandle.myUserId())) { result.add(KEY_NETWORK_RESET); } 
 setEmptyView(getEmptyTextView()); 
<|del|> 
 if (retries == 0) { fail(String.format("Timed out waiting the value to change to %s (actual=%s)", canOpen, successToOpen)); 
<|del|> 
 try (FileChannel fc = fos.getChannel()) { 
 @Parameters(method = "parameters_test_newFileChannel_NoSuchFileException") public void test_newFileChannel_NoSuchFileException(Set<? extends OpenOption> openOptions) 
 synchronized (mLock) { for (String addr : mConnectedDevicesByAddress.keySet()) { if (!Objects.equals(addr, excludeAddress)) { result = addr; } 
 // is initialized. This happens in the default constructor only. 
 k = a[i] + a[i - 1]; 
 Log.e(TAG, "Trying to use a null config for registration"); 
 try (InputStream inputStream = uc.getInputStream()) { 
<|del|> 
 mWifiScoreReport = new WifiScoreReport(mContext, mWifiConfigManager); 
 * Test for operation with null NetworkAgent * * Expect to not die, and to calculate the score and report to metrics. 
 * One score is calculated 
 mWifiScoreReport.reset(); assertEquals(0, mWifiScoreReport.getLastBadLinkspeedcount()); 
 assertEquals(0, mWifiConfiguration.numUserTriggeredWifiDisableLowRSSI); 
 assertEquals(String.format("Timed out waiting the value to change to %s (actual=%s)", canOpen, successToOpen), canOpen, successToOpen); 
 void setImsVoLteProvisionedState( boolean state ) { log(String.format("toggle VoLTE provisioned: %s", ((state) ? "on":"off"))); 
 // Check if this is 802.1x or 802.11x config. if (config.has(WifiEnterpriseConfig.EAP_KEY)) { 
 // Check if this is 802.1x or 802.11x config. if (config.has(WifiEnterpriseConfig.EAP_KEY)) { 
 k = a[i] + a[i - 1]; 
 mDevice.setPairingConfirmation(false); finish(); return; 
<|del|> 
 protected class SetupAllocationCopyTests { 
 new FileLocation(tmpdir + File.separator + prefix + "*" + suffix), e); } catch (FileAlreadyExistsException e) { throw new AssertionError(e); 
 new FileLocation(tmpdir + File.separator + prefix + "*" + suffix), e); } catch (FileAlreadyExistsException e) { throw new AssertionError(e); 
 // The 'values()' method must be traced if present (for the switches on enum support) 
<|del|> 
 case IDLE: case SCANNING: case CONNECTING: case AUTHENTICATING: case OBTAINING_IPADDR: case SUSPENDED: case FAILED: case BLOCKED: case VERIFYING_POOR_LINK: 
 // TODO(b/32714185): revisit this when integrating the new Passpoint implementation and add 
 // TODO(b/32714185): revisit this when integrating the new Passpoint implementation and add 
 // Android-changed: Force to false. private static final boolean inhibitZip64 = false; // Boolean.parseBoolean( // java.security.AccessController.doPrivileged( // new sun.security.action.GetPropertyAction( // "jdk.util.zip.inhibitZip64", "false"))); 
 public int protocol; public ArrayList<Integer> keyManagement; public ArrayList<Integer> pairwiseCipher; public int groupCipher; public boolean isESS; public boolean isPrivacy; 
 Log.v(TAG, "Scan results access denied: Calling Uid and app package do not have" 
 + "does not have INTERACT_ACROSS_USERS_FULL permission"); 
 * No security key management scheme. 
 WeakReference<ResourcesImpl> weakImplRef = mResourceImpls.valueAt(i); ResourcesImpl r = weakImplRef != null ? weakImplRef.get() : null;; 
 "Number of method call arguments does not match the number of call site parameters"); 
 "Number of method call arguments does not match the number of call site parameters"); 
 // Workaround for non-zero field ids offset in dex file with no fields. Bug: 18051191 
 Class<?> refc, Class<?> specialCaller) throws IllegalAccessException { 
 * Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 RN = new Random(seed); // So that we can have offsets that will be invalid in another // dimension Width = RN.nextInt(size/2)+size/2; Height = RN.nextInt(size/2); 
 RN = new Random(seed); // So that we can have offsets that will be invalid in another // dimension Width = RN.nextInt(size/2)+size/2; Height = RN.nextInt(size/2); 
 } else { assertTrue(aIn.getElement().getDataType() == Element.DataType.SIGNED_16); 
<|del|> 
 * 2D copy - with legitimiate arguments 
 SetupAllocationCopyTests AC = new SetupAllocationCopyTests(1, 512, (RenderScript rs)-> new Type.Builder(rs, Element.I8(rs)), 0x172d8abd); 
 Soob.set_xCount(AC.Width - Offset + 1); // Invalid count by 1 
 Soob.set_xCount(AC.Width - Offset + 1); // Invalid count by 1 
 Soob.set_srcXOff(AC.Width); // Invalid src offset 
 SetupAllocationCopyTests AC = new SetupAllocationCopyTests(2, 128, (RenderScript rs)-> new Type.Builder(rs, Element.I16(rs)), 0x172d8ac0); 
 Soob.set_xCount(xCount); // Legitimate X count Soob.set_yCount(AC.Height - yOff + 1); // Invalid Y count by 1 
 Soob.set_xCount(xCount); // Legitimate X count Soob.set_yCount(AC.Height - yOff + 1); // Invalid Y count by 1 
 mVpnPreference.setDependency(KEY_TOGGLE_AIRPLANE); 
 final boolean isVpnDisallowed = um.hasUserRestriction( UserManager.DISALLOW_CONFIG_VPN); 
<|del|> 
<|del|> 
 final char c = '0'; String s = string36; for (int i = 0; i < count; ++i) { $noinline$indexOf(s, c); } 
 if (argumentIdx >= numArgs || argumentIdx == (RETURN_VALUE_IDX + 1)) { 
 final Class<?> expectedType = (argumentIdx == RETURN_VALUE_IDX) ? 
 argumentIdx = RETURN_VALUE_IDX; // Position the cursor appropriately. The return value is either the last element // of the references array, or the last 4 or 8 bytes of the stack frame. 
 frameBuf.putInt((int) value); 
<|del|> 
 array[0] = "42"; array[1] = "48"; array[2] = "54"; 
 String[] array = new String[3]; 
 description = "one lambda class for all lambdas inside a top-level type") TYPE, 
 * This annotation holds name and description for enum fields used by {@link EnumCodec} 
 if (isUidDeviceOwner || isUidProfileOwner || hasConfigOverridePermission) { 
 } 
 assertEquals(orgTime, zentry.getLastModifiedTime().toMillis()); 
 // these cases would behave differently. 
 ZipEntry zipEntry; 
 ZipEntry zipEntry; 
<|del|> 
<|del|> 
 mLog.tC("Denied: no network permission and no location permission"); 
 mLog.tC("Denied: WIFI_SCAN not allowed"); 
 mLog.tC("Denied: User or profile not current " + "and No INTERACT_ACROSS_USERS_FULL permission"); 
<|del|> 
 public static int inlinedFunction(int x, int y) { 
 // We simply repeat for 10 times without verification. Will improve if it causes flakiness. for (int i = 0; i < 10; i++) { 
 uid, Build.VERSION_CODES.N + 2); 
 if (mLastPacketCountUpdateTimeStamp != RESET_TIME_STAMP && mLastPacketCountUpdateTimeStamp < timeStamp 
 ResourcesImpl r = weakImplRef != null ? weakImplRef.get() : null; 
 Float value = (Float) mh.invokeExact(0.33f); 
 fail("Unexpected float value from invokeExact " + value.floatValue()); 
 // Non-existent 
 fail("Unexpected empty string constructor result: '" + s + "'"); 
 // Obtain a big-endian and little-endian copy of the source array. ByteBuffer bigEndian = byteBuffer.duplicate().order(ByteOrder.BIG_ENDIAN); ByteBuffer littleEndian = byteBuffer.duplicate().order(ByteOrder.LITTLE_ENDIAN); 
 k += s.indexOf(t); 
 try { indexOfExceptions(ABC, null); throw new Error("Expected: NPE"); } catch (NullPointerException e) { } expectEquals(598, indexOfExceptions(ABC, XYZ)); 
 Log.d(TAG, "onDelayReport: address: " + Utils.getAddressStringFromByte(address) + 
 ", delay (in 1/10 of ms): " + delay); 
 * 2D copy - with legitimate arguments 
 if (TextUtils.isEmpty(currentSP)) { 
 assertEquals(Arrays.asList("test.txt", "Test.txt", "TEST.TXT"), names); 
 assertEquals(Arrays.asList("test.txt", "Test.txt", "TEST.TXT"), names); 
 // Set last access time and test that calling setTime with value > 
 return time + (xdostime >> 32); 
 // Android-changed: cast year to long. Otherwise in case where (year - 1980) // is >= 64, ((year - 1980) << 25) will become a negative int, and when it's 
 mLog.tC("Denied: no location permission"); 
 mLog.tC("Denied: app wifi scan not allowed"); 
 mLog.tC("Profile denied"); 
 session.abortEventually(); 
 * A test that checks that the inliner does not inline functions that contain * a loop with no exit. This because the incremental update to 
 /// CHECK-NOT: InvokeVirtual intrinsic:StringIndexOf /// CHECK-NOT: InvokeVirtual intrinsic:StringIndexOfAfter /// CHECK-NOT: InvokeVirtual intrinsic:StringStringIndexOf /// CHECK-NOT: InvokeVirtual intrinsic:StringStringIndexOfAfter 
 assertTrue("getRsrq() out of range | Integer.MAX_VALUE, rsrq=" + rsrq, rsrq == Integer.MAX_VALUE || (rsrq >= MIN_RSRQ && rsrq <= MAX_RSRQ)); 
 AccessibilityService.GLOBAL_ACTION_HOME); 
 mLog.tC("Denied: Profile not permitted"); 
 dataFormat >= IFD_FORMAT_BYTES_PER_FORMAT.length || numberOfComponents < 0) { 
 dataFormat >= IFD_FORMAT_BYTES_PER_FORMAT.length || numberOfComponents < 0) { 
 Log.e(TAG, "Failed to initialize the list of messages: " + e.toString()); 
 while (!sucessfullyReadChildInos && System.nanoTime() < endTimeNanos) { 
 // We must skip empty buffers as BIO_write will return 0 if asked to write // something 
 sslSession = sslParameters.setupSession(sslSessionCtx, sslNativePointer, sslSession, 
 sslWrote = NativeCrypto.ENGINE_SSL_write_heap( sslNativePointer, src.array(), src.arrayOffset() + pos, len, this); 
 sslRead = NativeCrypto.ENGINE_SSL_read_heap( sslNativePointer, dst.array(), dst.arrayOffset() + pos, len, this); 
 bioRead = NativeCrypto.ENGINE_SSL_read_BIO_heap(sslNativePointer, networkBio, dst.array(), dst.arrayOffset() + pos, pending, this); 
 private static final boolean ALWAYS_USE_ENGINE_SOCKET = Boolean.parseBoolean(System.getProperty("org.conscrypt.alwaysUseEngineSocket")); 
<|del|> 
<|del|> 
 // We need to copy 5 bytes into a temporary buffer so we can parse out the packet length // easily. ByteBuffer tmp = ByteBuffer.allocate(5); 
 return PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT); 
 /** * An Activity for provisioning a Hotspot 2.0 Release 1 configuration. */ 
 /** * Create a dialog that guides the user through Hotspot 2.0 Release 1 configuration file * installation. */ 
 Toast.LENGTH_LONG).show(); 
 /** * Delete the file specified by the given URI. * * @param uri The URI of the file * @param context The context of the current application */ 
 Log.w(TAG, "Skip the tag entry since number of components is invalid: " + numberOfComponents); 
 // of the two different strings were the same). System.out.println("hello"); 
 if (tile.isAvailable()) { if (DEBUG) Log.d(TAG, "Adding " + tile); tile.removeCallbacks(); newTiles.put(tileSpec, tile); } else { tile.destroy(); } 
 // The object is the only thing preventing the class loader from being unloaded. 
 Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket 
 //Note: This RIL request has not been renamed to ICC, // but this request is also valid for SIM and RUIM RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result); 
 notifyUserSwitched(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0)); 
 // TODO(b/32883320): use the new API for adding Passpoint configuration. 
 } catch (RemoteException | RuntimeException e) { mOemHookProxy = null; riljLoge("OemHookProxy getService/setResponseFunctions: " + e); 
 } } 
 final String[] waitForActivitiesVisible = new String[] {TEST_ACTIVITY_NAME, LAUNCH_TO_SIDE_ACTIVITY_NAME}; 
 final String[] waitForActivitiesVisible = new String[] {targetActivityName, LAUNCH_TO_SIDE_ACTIVITY_NAME}; 
 String[] waitForActivitiesVisible = new String[] {LAUNCH_TO_SIDE_ACTIVITY_NAME, TEST_ACTIVITY_NAME}; 
 String[] waitForActivitiesVisible = new String[] {LAUNCH_TO_SIDE_ACTIVITY_NAME, TEST_ACTIVITY_NAME}; 
 * Stores information about a thread's point of entry that should persist until that thread exits. 
 // getTime should be rounded down to a multiple of 2s 
 if (tag == null || dataFormat <= 0 || dataFormat >= IFD_FORMAT_BYTES_PER_FORMAT.length 
import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; 
<|del|> 
<|del|> 
<|del|> 
 // configurations cause them to attempt to renegotiate during 
 try { tmp.put(buffer); } finally { // Restore the original indices. buffer.limit(limit); buffer.position(pos); } 
 localType = type; 
 if (!maybeSendVoicemailNotificationUsingDefaultDialer(0, null, null, false, userHandle)) { 
 List<UserInfo> users = mUserManager.getUsers(true /* excludeDying */); 
 private boolean maybeSendVoicemailNotificationUsingDefaultDialer(Integer count, String number, 
 private boolean maybeSendVoicemailNotificationUsingDefaultDialer(Integer count, String number, 
<|del|> 
<|del|> 
 ReleasedLevel(@Nonnegative int level) { 
 * Only {@link #NONE} is garanteed to not disappear. 
 * Only {@link #NONE} is garanteed to not disappear. 
 ProvisionalLevel(@CheckForNull AndroidApiLevel.ReleasedLevel level) { 
 keyManagement.add(ScanResult.KEY_MGMT_EAP); 
 public static final int KEY_MGMT_NONE = 0; 
 public static class CipherSpiWithGrowingOutputSize extends MockCipherSpi { public int expectedOutputSize = 100; 
 int outputOffset) throws ShortBufferException { 
 super.sort(new Comparator<Item>() { 
 * Only {@link #NONE} is guaranteed to not disappear. 
 // http://b/31039416. Android supports cookie "expires" values without a // "GMT" prefix on the timezone. 
 // This should work till year 6830 ((10000 - 6830) years ~= 10^11s) 
 // Android-changed: Use libcore.net.http.HttpDate for parsing. 
 // Android-changed: not used. /*private long expiryDate2DeltaSeconds(String dateString) { 
 logger.log(Level.SEVERE, "A Key id named ''{0}'' already exists in {1}", 
 * Copyright (C) 2016 The Android Open Source Project 
<|del|> 
import com.android.tradefed.device.ITestDevice; import com.android.tradefed.testtype.DeviceTestCase; 
 } 
 } 
 bootTime = System.currentTimeMillis()/1000 - Integer.parseInt(getDevice().executeShellCommand("cut -f1 -d. /proc/uptime").trim()); 
<|del|> 
<|del|> 
 private final UserReceiver mUserReceiver; 
 return inputLen + outputSizeDelta; 
<|del|> 
 // of the type index as the hash into DexCache types array. // Note: n == n + 1024 (mod 2^10), n + 1 != n + 1023 (mod 2^10). 
 Class<?> returnType() default CallSite.class; Class<?>[] argumentTypes() default {}; 
 String name(); Class<?> returnType() default void.class; Class<?>[] argumentTypes() default {}; 
 Class<?> type() default CallSite.class; 
<|del|> 
 Thread.sleep(1000); disks = getDevice().executeShellCommand("sm list-disks adoptable"); 
<|del|> 
 com.android.sched.filter.AllTests.class, 
// Android-changed: top-level documentation substantially changed/rewritten. 
 /** The mDNS service types supported */ 
 VendorNameFilter(@NonNull Set<String> vendorNames) { 
 * @param context The context the plugin runs in * @param name The user friendly name of the print service * @param packageName The package name of the print service 
 @NonNull String name, @NonNull CharSequence packageName, @NonNull List<String> mDNSNames) { mName = context.getResources().getIdentifier(name, null, "com.android.printservice.recommendation"); 
class PrinterFilterMopria implements MDNSFilteredDiscovery.PrinterFilter { 
 static final Set<String> MOPRIA_MDNS_SERVICES = new HashSet<String>() {{ 
class PrinterFilterSamsung implements MDNSFilteredDiscovery.PrinterFilter { 
 mMDNSFilteredDiscovery = new MDNSFilteredDiscovery(context, ALL_MDNS_SERVICES, (NsdServiceInfo nsdServiceInfo) -> mPrinterFilterSamsung.matchesCriteria(nsdServiceInfo) || mPrinterFilterMopria.matchesCriteria(nsdServiceInfo)); 
<|del|> 
 private final @NonNull PrinterFilter mPrinterFilter; 
 private @Nullable PrintServicePlugin.PrinterDiscoveryCallback mCallback; 
 private final @NonNull NsdResolveQueue mResolveQueue; 
 @NonNull Set<String> serviceTypes) { 
 maxAgeInSeconds = (date.getTime() - cookie.whenCreated) / 1000; // If "expires" is in the past, remove the cookie. if (maxAgeInSeconds < 0) { maxAgeInSeconds = 0; } 
 public void sendSMSExpectMoreResponse(RadioResponseInfo responseInfo, SendSmsResult var2) {} 
 public void setCallForwardResponse(RadioResponseInfo responseInfo) {} 
 public void stopDtmfResponse(RadioResponseInfo responseInfo) {} 
 public void setCdmaBroadcastConfigResponse(RadioResponseInfo responseInfo) {} 
 public void writeSmsToRuimResponse(RadioResponseInfo responseInfo, int var2) {} 
 rr.mParcel.writeInt(2); rr.mParcel.writeString(success ? "1" : "0"); rr.mParcel.writeString(ackPdu); 
 public MDNSFilterPlugin(@NonNull Context context, @NonNull String name, @NonNull CharSequence packageName, @NonNull List<String> mDNSNames) { 
 * Describes an annotation that allows passing a constant extra argument to a linker method. 
 out.annotate(0, " extra_args: " 
 // // Hold the creation time (in seconds) of the http cookie for later 
 if (config.get(Options.EMIT_CLASS_FILES).booleanValue()) { 
 BridgeAnnotationsTests.class, 
 mWifiLogger.captureBugReportData(WifiLogger.REPORT_REASON_AUTH_FAILURE); 
 * Check if domain is either the same or a sub-domain of any of the domains in the * domain tree in this matcher, i.e. all or a sub-set of the labels in domain matches 
 * Check if domain is either the same or a sub-domain of any of the domains in the * domain tree in this matcher, i.e. all or a sub-set of the labels in domain matches 
 * Returns the {@code MethodType} that the frame was created for. 
 throw new IllegalArgumentException("target does not have array as last parameter"); 
 // not have comments for classes from .class files but we do know whether a class is marked 
 // not have comments for classes from .class files but we do know whether a field is marked 
 /// CHECK-NEXT: {{adds|subs}} r{{\d+}}, #{{4294967295|1}} 
 assertTrue("Did not find any synthetic field", foundSyntheticField); 
 assertTrue("Did not find any synthetic method", foundSyntheticMethod); 
 && mParams.deviceAdminDownloadInfo != null) { 
 // scan the aliases, we were picking it as the canonical OID for AES. See: 
 // scan the aliases, we were picking it as the canonical OID for AES. See: 
 Log.always(" --android-root=<dir> : Set path where dalvikvm should look for binaries."); Log.always(" Use this when pushing binaries to a custom location."); 
 /** Public for layoutlib only. */ 
 /** Public for layoutlib only. */ 
 public void test_closeGuardSupport() throws IOException { 
 public void test_closeGuardSupport() throws IOException { 
 public void test_closeGuardSupport() throws IOException { 
 ServerSocket server1 = new ServerSocket(0)) { 
 "127.0.0.1", server1.getLocalPort()); 
 protected void finalize() throws Throwable { try { guard.warnIfOpen(); // fd is null if constructor threw exception if (fd != null) close(); } finally { super.finalize(); } 
 protected void finalize() throws Throwable { try { guard.warnIfOpen(); // fd is null if constructor threw exception if (fd != null) close(); } finally { super.finalize(); } 
 protected void finalize() throws Throwable { try { if (guard != null) { guard.warnIfOpen(); } 
 protected void finalize() throws Throwable { try { if (guard != null) { guard.warnIfOpen(); } close(); } finally { super.finalize(); 
<|del|> 
<|del|> 
 enableAdbRoot(getDevice()); 
 kernelStartTime = System.currentTimeMillis()/1000 - 
 //TODO:(badash@): Watch for other things to track. Specifically time when app framework starts 
 mDevice.executeAdbCommand("root"); 
 * Makes sure the phone is online, and the ensure the current boottime is within 2 seconds * (due to rounding) of the previous boottime to check if The phone has crashed. 
 return new Messenger(mClientHandler); } else { loge("WifiScanningServiceImpl trying to get messenger w/o initialization"); return null; 
 * Uninstall the current timezone update in /data, returning the device to using data from * /system. Returns {@code true} if uninstallation was successful, {@code false} if there was * nothing installed in /data to uninstall. 
<|del|> 
<|del|> 
 // The instructions vary in size, so we have to find the last instruction in the block in a // few tries. 
 // Since we are not parsing the section, ensure that the last byte is DBG_END_SEQUENCE. 
 Log.errorAndQuit("Could not adb push program to device."); 
 ui.action(ComputeThresholdXAction.class); ui.input(it.next()); 
 public void testAddNetworkWithProxyWithConfOverride() { verifyAddOrUpdateNetworkWithProxySettingsAndPermissions( 
 private NetworkUpdateResult verifyAddOrUpdateNetworkWithProxySettingsAndPermissions( 
 if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + cid + " " + reason); 
 * Transient as this field has native components and is a logical part of the 'Class' type. 
 * Transient as this field contains native pointers and is a logical part of the 'Class' type. 
 fail("Failed to set device owner"); 
 mConnecting = false; mConnectedAgent = null; 
 private static final String TAG = BuiltInPrintService.class.getSimpleName(); private static final boolean DEBUG = false; 
 mDiscovery = new MultiDiscovery(this, new WifiMonitor.Factory(), new MdnsDiscovery(this), 
<|del|> 
 /** Center horizontally based on the orientation */ 
<|del|> 
 fail("Failed to set device owner"); 
 private static final String TAG = BuiltInPrintService.class.getSimpleName(); private static final boolean DEBUG = false; 
<|del|> 
 private static final String TAG = LocalDiscoverySession.class.getSimpleName(); private static final boolean DEBUG = false; 
 void handlePrinter(LocalPrinter localPrinter) { 
 void handlePrinter(LocalPrinter localPrinter) { 
<|del|> 
<|del|> 
 private void handleCapabilities(LocalPrinterCapabilities capabilities) { 
 /** When tracking a printer, wait this long between capability refresh attempts */ 
 mPrinterId, mDiscoveredPrinter.name, idle ? PrinterInfo.STATUS_IDLE : PrinterInfo.STATUS_UNAVAILABLE) .setDescription(description); 
 mSession.isPriority(mPrinterId), this); 
 long now = mClock.getElapsedSinceBootMillis(); sb.append(" expires in ").append(Utils.toHMS(mExpiryTime-now)).append(' '); 
 mLastSweep = mClock.getElapsedSinceBootMillis(); 
 if (!accountsToDelete.isEmpty()) { 
 mPopup = new SelectionPopupMenu(this, v, position); mPopup.showPopUp(); 
<|del|> 
 private WifiLog mLog; 
 if (DEBUG) Log.d(TAG, "Already have the reported printer, ignoring"); 
 private static final String TAG = MdnsDiscovery.class.getSimpleName(); private static final boolean DEBUG = false; 
<|del|> 
 private static final String TAG = MultiDiscovery.class.getSimpleName(); private static final boolean DEBUG = false; 
<|del|> 
 private static final String TAG = NsdResolveQueue.class.getSimpleName(); private static final boolean DEBUG = false; 
 if (DEBUG) Log.d(TAG, "Adding resolve of " + serviceInfo.getServiceName() + 
 private static final String TAG = Backend.class.getSimpleName(); private static final boolean DEBUG = false; 
 private AsyncTask<Void, Void, Integer> mStartTask; 
 Context context = mContext.get(); if (context != null) { try { FileUtils.deleteAll( new File(context.getFilesDir(), Backend.TEMP_JOB_FOLDER)); } catch (IOException ignored) { 
 sendMessage(sendingChannel, msg2, groupSocketAddress); blockUntilAvailableOrTimeout(receivingChannel.socket(), 1000); 
 private static void blockUntilAvailableOrTimeout(DatagramSocket s, int timeout) { 
 mWifiKeyStore, mWifiConfigStore, mWifiConfigStoreLegacy); mNetworkScoreManager = (NetworkScoreManager) mContext.getSystemService(Context.NETWORK_SCORE_SERVICE); 
 final String encoded = Base64.getEncoder().encodeToString(mSigHashes.get(i)); 
 // Throws IllegalArgumentException if hash is invalid base64 data final byte[] decoded = Base64.getDecoder().decode(hash); hashes.add(decoded); 
 holder[count++] = new Object[1025]; // A bit over one page. 
<|del|> 
 return mSimActivationTracker; 
 private Phone mPhone; 
<|del|> 
 mWifiKeyStore, mWifiConfigStore, mWifiConfigStoreLegacy); mNetworkScoreManager = (NetworkScoreManager) mContext.getSystemService(Context.NETWORK_SCORE_SERVICE); 
 * Listen for changes to the sim activation state, including both data and voice * @see SimActivationState * {@more} * Example: SimActivationState#STATE_ACTIVATED indicates service has been fully activated 
<|del|> 
<|del|> 
 * Carrier apps could be signalled to set activation state to deactivated if detected * deactivated sim state and set it back to activated after successfully run activation service. 
 private static String toString(int state) { 
 private static String toString(int state) { 
 public static boolean isValidActivationState(int state) { 
 return mVoiceActivationState.compareAndSet(mVoiceActivationState.get(), state); 
<|del|> 
 mCurrAddrPlayerID = NO_PLAYER_ID; 
 public void testFailedBrowseStart() { Context mockContext = mock(Context.class); AudioManager mockAudioManager = mock(AudioManager.class); PackageManager mockPackageManager = mock(PackageManager.class); 
 return TextUtils.equals(that.mSSID, mSSID) && that.mBSSID == mBSSID && that.mHESSID == mHESSID && that.mAnqpDomainID == mAnqpDomainID; 
<|del|> 
 * Verify that BufferUnderflowException will be thrown when reading an integer from a buffer * that contained less data than needed. 
 * Verify that IllegalArgumentException will be thrown when reading an integer that exceeds * the maximum integer size. 
 mVoiceActivationState = SIM_ACTIVATION_STATE_UNKNOWN; mDataActivationState = SIM_ACTIVATION_STATE_UNKNOWN; 
 setVoiceActivationState(SIM_ACTIVATION_STATE_UNKNOWN); setDataActivationState(SIM_ACTIVATION_STATE_UNKNOWN); 
<|del|> 
 // http://b/33383388 // getCurrentSpi throws a NPE on a Signature that was obtained via a provider that has that // algorithm registered for a SignatureSpi. public void testSignature_getCurrentSpi_Success() throws Exception { 
 Signature signature = Signature.getInstance("ABC", provider); assertNotNull(signature.getCurrentSpi()); assertEquals(MySignatureSpi.class, signature.getCurrentSpi().getClass()); 
 Signature signature = Signature.getInstance("ABC", provider); assertNotNull(signature.getCurrentSpi()); assertEquals(MySignatureSpi.class, signature.getCurrentSpi().getClass()); 
 * Wait for some event on a file descriptor, blocks until the event happened or timeout period * passed. See poll(2) and @link{android.system.Os.Poll}. 
 String msg2 = "Hello2"; blockUntilAvailable(receivingChannel.socket(), 1000); 
 int v6Availability = ipField & IPV6_AVAILABILITY_MASK; 
 int v4Availability = (ipField >> 2) & IPV4_AVAILABILITY_MASK; 
 // TODO: Check if calType can be passed via keyword on loc parameter instead. public static String getDateTimeFormatString(ULocale loc, String calType, int dateStyle, 
 private static PatternData make(ULocale loc, String calType) { 
 MtpServer.configure(ptpEnabled); // tell MediaProvider MTP is configured so it can bind to the service context.getContentResolver().insert(Uri.parse( "content://media/none/mtp_connected"), null); 
 /** Public for layoutlib only. */ public MemoryMappedFile(long address, long size) { 
 private ScoredNetwork mValidScoredNetwork; private WifiNetworkScoreCache mScoreCache = 
 private ScoredNetwork mValidScoredNetwork; private WifiNetworkScoreCache mScoreCache = 
 private static ScoredNetwork buildScoredNetwork(WifiKey key, RssiCurve curve) { 
 ScoredNetwork noCurve = buildScoredNetwork(VALID_KEY, null /* rssiCurve */); mScoreCache.updateScores(ImmutableList.of(noCurve)); 
<|del|> 
 isFullScan = source.isFullScan; channelSettings = new ArrayList<>(source.channelSettings); hiddenNetworks = new ArrayList<>(source.hiddenNetworks); 
 assertActiveNetworkMetered(false); // Sanity check. return true; 
<|del|> 
<|del|> 
<|del|> 
 public JMethod getMethod(@Nonnull JMethodId methodId) throws JMethodLookupException { JMethodIdWide methodIdWide = methodId.getMethodIdWide(); return getMethod(methodIdWide.getName(), methodId.getType(), methodIdWide.getParamTypes()); 
 public JMethod getMethod(@Nonnull JMethodId methodId) throws JMethodLookupException { JMethodIdWide methodIdWide = methodId.getMethodIdWide(); return getMethod(methodIdWide.getName(), methodId.getType(), methodIdWide.getParamTypes()); 
 public JMethod getMethod(@Nonnull JMethodId methodId) throws JMethodLookupException { JMethodIdWide methodIdWide = methodId.getMethodIdWide(); return getMethod(methodIdWide.getName(), methodId.getType(), methodIdWide.getParamTypes()); 
<|del|> 
<|del|> 
 this(in.readDouble(), in.readDouble()); 
<|del|> 
 closePage(); 
<|del|> 
 Looper looper, FrameworkFacade framework, Notification.Builder builder, WifiInjector wifiInjector) { 
 public static native void SSL_do_handshake( 
<|del|> 
 private final Notification.Builder mNotificationBuilder; 
 /** Verifies that a notification is not displayed for bad networks. */ 
 WifiNetworkSelector networkSelector, 
<|del|> 
<|del|> 
 if (numOpenNetworks > 0) { 
 if (numOpenNetworks > 0) { 
 /// CHECK-START: int Main.poly2(int) loop_optimization (after) /// CHECK-NOT: Phi 
<|del|> 
 LocalLog localLog) { 
 private static final TimeZoneNames.NameType[] TYPES = new TimeZoneNames.NameType[] { 
 String region = ULocale.getRegionForSupplementalData(ulocale, /* inferRegion */ true); 
 // Android changed: Removed ZoneInfo support/workaround. 
 } private CalendarAccessControlContext() { } 
 // Android changed: removed ZoneInfo support. 
 * <h3><a name="week_and_year">Week Of Year and Week Year</a></h3> 
 // BEGIN Android-changed: implement using android.icu.text.TimeZoneNames 
 int bestScore = Byte.MIN_VALUE; 
 mWifiConfigManager, wifiInfo, mWifiNetworkSelector, mWifiLastResortWatchdog, mWifiMetrics, mWifiStateMachineHandlerThread.getLooper(), mClock, hasConnectionRequests, mFrameworkFacade, mSavedNetworkEvaluator, mExternalScoreEvaluator, mRecommendedNetworkEvaluator); 
 for (TracerBrush brush : brushes) { brush.endTraceSeed(type); 
 for (TracerBrush brush : brushes) { brush.endTraceSeed(method); 
 Libcore.os.symlink(xs, path.getPath()); assertEquals(xs, Libcore.os.readlink(path.getPath())); 
 Libcore.os.symlink(xs, path.getPath()); assertEquals(xs, Libcore.os.readlink(path.getPath())); 
 // The sub plan that write dex files representing type must not be split in order to remove dx 
 delayUs = SensorCtsHelper.clamp(delayUs, minDelayUs, maxDelayUs); 
 ZoneInfo zoneInfo = createZoneInfo(transitions, types, secondsInMillis(-1) /* currentTimeMillis */); 
 public ZoneInfoDataBuilder setTransitionsAndTypes( int[][] transitionPairs, int[][] typePairs) { 
<|del|> 
<|del|> 
<|del|> 
 @GuardedBy("this") private int mCounter = 0; @GuardedBy("this") private WifiConfiguration mLastRecommended = null; 
 // and class loading that overrides a method can invalidate compiled code. // Also create a proxy method such that a proxy method's frame is visited // during stack walking. 
 // Create another thread that calls a proxy method. 
// Put createMain2() in another class to avoid class loading due to verifier. 
 if (!TextUtils.isEmpty(hn)) addTlv(buf, DHCP_HOST_NAME, hn); 
 taskRunner.executeTask("Register deleter of '" + replacedServerJar.getPath() + "'", 
 mContext = context; 
 if (mListener != null) { mListener.post(networks); 
 /// CHECK-DAG: <<Div:i\d+>> Div [<<Int1>>,<<Int2>>] loop:none /// CHECK-DAG: <<Add:i\d+>> Add [<<Div>>,<<Zero>>] loop:none /// CHECK-DAG: Return [<<Add>>] loop:none 
 public void start(HandlerThread handlerThread, WifiAwareStateManager awareStateManager) { 
 public WifiAwareStateManager() { // empty 
 synchronized (mListener) { mListener = listener; } 
 mContext = context.getApplicationContext(); 
 mContext = context.getApplicationContext(); 
 if (networks == null || networks.isEmpty()) { 
 Log.d(TAG, "updateScores list size=" + networks.size()); 
 void post(List<ScoredNetwork> updatedNetworks) { 
 try { mLatch.await(1, TimeUnit.SECONDS); // wait for listener to be executed } catch (InterruptedException e) { fail("Interrupted Exception while waiting for listener to be invoked."); } 
<|del|> 
 heightSpec = mDropDownHeight; 
 "Length of blob is longer than available: " + length + " > " + buf.remaining()); 
 * Copyright (C) 2016 The Android Open Source Project 
 java.util.Random rand = new java.util.Random(0xcafebabe); 
 private CertInstallerHelper mCertHelper; 
 // TODO Revisit with b/33616143 // TODO Uncomment this once either b/33630159 or b/33616143 are resolved. 
 // TODO This doCall function is a very temporary fix until we get either deoptimization near // runtime frames working, forcing current method to be always read from the stack or both // working. 
 // TODO This doCall function is a very temporary fix until we get either deoptimization near // runtime frames working, forcing current method to be always read from the stack or both // working. 
 public static final int SYMMETRIC_LINK_MASK = 1 << 2; 
 private static final int MAX_LOAD = 256; 
 mDownlinkLoad * 100.0 / MAX_LOAD, mUplinkLoad * 100.0 / MAX_LOAD, 
 synchronized (mCacheLock) { if (mListener != null) { 
@SmallTest public class MediaProviderPermissionsTest { 
@SmallTest public class MediaProviderPermissionsTest { 
 @Before public void setUp() throws Exception { mContext = InstrumentationRegistry.getContext(); 
 @Before public void setUp() throws Exception { mContext = InstrumentationRegistry.getContext(); 
 Assert.assertNotNull(surfaceFlinger); 
 Assert.assertTrue(dev_mtp.exists() || ffs_mtp.exists()); 
 int hotnessCounter = getHotnessCounter(c, "errMethod"); if (hotnessCounter != 0) { throw new RuntimeException("Unexpected hotnessCounter: " + hotnessCounter); } 
 if (hotnessCounter != 0) { throw new RuntimeException("Unexpected hotnessCounter: " + hotnessCounter); } 
 /** Make the code Java debuggable by turning off some optimizations. */ 
 /** Make the code Java debuggable by turning off some optimizations. */ 
<|del|> 
 @Nullable @GuardedBy("mCacheLock") 
 private final BasicLruCache<String, ZoneRules> cache = new ZoneRulesCache(8); 
 private final BasicLruCache<String, ZoneRules> cache = new ZoneRulesCache(8); 
 // DOW is unspecified in the documentation and seems to never be used. throw new ZoneRulesException("Date rule type DOW is unsupported"); 
 if (config.has(WifiEnterpriseConfig.EAP_KEY)) { 
 private final BasicLruCache<String, ZoneRules> cache = new ZoneRulesCache(8); 
<|del|> 
 Set<String> availableZoneIds = ZoneRulesProvider.getAvailableZoneIds(); assertFalse("no zones returned", availableZoneIds.isEmpty()); 
 argsForZygote.add("--java-debuggable"); 
<|del|> 
 synchronized (mLock) { final String methodStr = "setBtCoexistenceScanModeEnabled"; if (!checkSupplicantStaIfaceAndLogFailure(methodStr)) return false; SupplicantStatus status = mHidlSupplicantStaIface.setBtCoexistenceScanModeEnabled(enable); return checkStatusAndLogFailure(status, methodStr); } 
<|del|> 
<|del|> 
 mPasspointNetworkEvaluator); 
 config.SSID = ScanResultUtil.createQuotedSSID(scanDetail.getSSID()); 
 assertDrop(program, packet.array(), ageLimit); 
 * Cell broadcast additional channels enbled by the carrier 
 //builder.append(String.format("%02x", b)); 
 } gotMac.value = builder.toString(); 
 return gotMac.value; 
 length += bytesRead; bytesRead = is.read(unused, 0, 4096); 
 final List<ExtractedDex> files = new ArrayList<ExtractedDex>(totalDexNumber - 1); 
 URL fileUrl = getFileUrlWithCredentials(VALID_USER, VALID_PASSWORD, FILE_PATH); 
 // If value is a optimized conditional, it was already converted by the second call to // generateImplicitConversion below. In this case, don't generate again the implicit // conversion. 
 if (stat.getBlockSizeLong() * (stat.getAvailableBlocksLong() - 4) < length) { 
 TimeUnit.MILLISECONDS.toSeconds(transition.getTime()), 
 TimeUnit.MILLISECONDS.toSeconds(transition.getTime()), 
 TimeUnit.MILLISECONDS.toSeconds(transition.getTime()), 
 AnnualTimeZoneRule rule, int dstSavingMillisBefore) { 
 int dayOfMonthIndicator; 
 case DateTimeRule.DOM: // Transition always on a specific day of the month. 
 // Nothing to do, ICU representation matches java.time representation. 
 // Cast to int is save, as input is int. int secondOfDay = (int) TimeUnit.MILLISECONDS.toSeconds(dateTimeRule.getRuleMillisInDay()); 
 private static class ZoneRulesCache extends BasicLruCache<String, ZoneRules> { 
 String canonicalCldrId = ZoneMeta.getCanonicalCLDRID(zid); if (canonicalCldrId != null) { return canonicalCldrId; 
 // Android changed: Android doesn't have long names for GMT/UTC as of 2017. 
 if (value < 0) { return null; } String[] names = getNames(id, field, style, locale); if (value >= names.length) { return null; } return names[value]; 
 for (Pair<ScanDetail, Pair<PasspointProvider, PasspointMatch>> candidate : networkList) { ScanDetail scanDetail = candidate.first; PasspointProvider provider = candidate.second.first; PasspointMatch match = candidate.second.second; 
<|del|> 
 * Copyright (C) 2017 The Android Open Source Project 
 private static final int BITRATE_1080p = 20000000; 
 * Carrier Action Agent(CAA) paired with CarrierSignalAgent * {@link com.android.internal.telephony.CarrierSignalAgent}, 
 * Each CarrierActionAgent is associated with a phone object. 
<|del|> 
<|del|> 
 if (DBG) log("CarrierSignalAgent receiver action: " + action); 
 continue; 
 continue; 
 s = s.toLowerCase(); List<ComponentName> componentList = cachedConfigs.get(s); if (componentList == null) { componentList = new ArrayList<>(); cachedConfigs.put(s, componentList); } componentList.add(componentName); 
 s = s.toLowerCase(); List<ComponentName> componentList = cachedConfigs.get(s); if (componentList == null) { componentList = new ArrayList<>(); cachedConfigs.put(s, componentList); } componentList.add(componentName); 
 s = s.toLowerCase(); List<ComponentName> componentList = cachedConfigs.get(s); if (componentList == null) { componentList = new ArrayList<>(); cachedConfigs.put(s, componentList); } componentList.add(componentName); 
 s = s.toLowerCase(); List<ComponentName> componentList = cachedConfigs.get(s); if (componentList == null) { componentList = new ArrayList<>(); cachedConfigs.put(s, componentList); } componentList.add(componentName); 
 List<ComponentName> receiverList; 
 receiverList = mCachedWakeSignalConfigs.get(intent.getAction().toLowerCase()); if (!ArrayUtils.isEmpty(receiverList)) { broadcast(intent, receiverList, WAKE); } 
<|del|> 
 * Runnable to show Failed To Connect notification. 
<|del|> 
 for (Pair<ScanDetail, Pair<PasspointProvider, PasspointMatch>> candidate : networkList) { ScanDetail scanDetail = candidate.first; PasspointProvider provider = candidate.second.first; PasspointMatch match = candidate.second.second; 
 * Carrier Action Agent(CAA) paired with * {@link com.android.internal.telephony.CarrierSignalAgent CarrierSignalAgent}, 
 * {@link android.telephony.TelephonyManager#carrierActionSetRadioEnabled(int, boolean) * carrierActionSetRadioEnabled} for example. 
 /** carrier actions, true by default */ private Boolean mCarrierActionOnMeteredApnEnabled = true; private Boolean mCarrierActionOnRadioEnabled = true; 
 .create("jack.dex.parameter.annotations", "Emit parameter annotations") 
@Description("Parameter metadatas annotations added.") 
@ValidOn({JLocalRef.class, JParameterRef.class}) 
<|del|> 
 lookupEnvironment.getType(TypeConstants.JAVA_LANG_STRING), JModifier.SYNTHETIC | JModifier.NAME_PRESENT); createParameter(info, method, "$enum$ordinal", TypeBinding.INT, JModifier.SYNTHETIC | JModifier.NAME_PRESENT); 
 if ((state != BluetoothAdapter.STATE_TURNING_ON) && (state != BluetoothAdapter.STATE_ON)) { Log.w(TAG, state + " RFCOMM listener failed as BT is being " + "turned off"); 
 if ((state != BluetoothAdapter.STATE_TURNING_ON) && (state != BluetoothAdapter.STATE_ON)) { Log.w(TAG, state + " RFCOMM listener failed as BT is being " + "turned off"); 
 if ((state != BluetoothAdapter.STATE_TURNING_ON) && (state != BluetoothAdapter.STATE_ON)) { Log.w(TAG, state + " RFCOMM listener failed as BT is being " + "turned off"); 
<|del|> 
 private Bitmap mNotificationBadgeBitmap; 
 mNotificationBadgeBitmap = mWifiNotificationHelper.createNotificationBadgeBitmap( mRecommendedNetwork, scanResults); if (++mNumScansSinceNetworkStateChange >= NUM_SCANS_BEFORE_ACTUALLY_SCANNING && mNotificationBadgeBitmap != null) { 
 mRecommendedNetwork = null; mNotificationBadgeBitmap = null; 
 this, getContentResolver(), mHandler, mNetworkScoreManager, mProvider, getSystemService(WifiManager.class), getSystemService(NotificationManager.class)); 
 NetworkScoreManager networkScoreManager, CachedScoredNetworkProvider cachedScoredNetworkProvider, WifiManager wifiManager, 
 /** * implement Parcelable interface * |flags| is ignored. */ 
<|del|> 
 result.ssid = in.createByteArray(); if (in.dataAvail() != 0) { Log.e(TAG, "Found trailing data after parcel parsing."); } 
 /** * implement Parcelable interface * |flags| is ignored. */ 
 in.readTypedList(result.channelSettings, ChannelSettings.CREATOR); in.readTypedList(result.hiddenNetworks, HiddenNetwork.CREATOR); if (in.dataAvail() != 0) { Log.e(TAG, "Found trailing data after parcel parsing."); 
 BooleanPropertyId.create("jack.class-file", "Generate class files") 
<|del|> 
 assertEquals(intArgumentCaptor.getValue().intValue(), restrictedState[1]); 
 final Instant start = LocalDateTime.of(1900, Month.JANUARY, 1, 12, 0) 
 final Instant end = LocalDateTime.of(2100, Month.DECEMBER, 31, 12, 0) 
 private static boolean isIcuOnlyTransition(TimeZoneTransition transition) { 
 dayOfMonthIndicator = -month.maxLength() + dateTimeRule.getRuleDayOfMonth() - 1; 
 intervalMs = source.intervalMs; min2gRssi = source.min2gRssi; min5gRssi = source.min5gRssi; if (source.pnoNetworks != null) { pnoNetworks = new ArrayList<>(source.pnoNetworks); } 
 result.pnoNetworks = new ArrayList<PnoNetwork>(0); 
 (display == null || display.trim().isEmpty()); 
 Rlog.e(TAG, "load carrier config failure with un-configured key: " + intent.getAction()); 
 // case 1: config {actionIdx1, actionIdx2...} both arg1 and arg2 must be null 
 String[] splitStr = config.trim().split(INTER_GROUP_DELIMITER, 2); 
 WifiManager wifiManager = getSystemService(WifiManager.class); Resources resources = getResources(); ContentResolver contentResolver = getContentResolver(); 
 if (wifiConfiguration.useExternalScores) { continue; // Ignore externally scored networks. 
 * Copyright (C) 2017 The Android Open Source Project 
 mSharedPreferences.getStringSet(KEY_SHOWN_SSIDS, Collections.<String>emptySet()); 
 mContext.registerReceiver(mBroadcastReceiver, INTENT_FILTER, null /* broadcastPermission*/, mHandler); 
 // The ClinitCheck may (PIC) or may not (non-PIC) be merged into the LoadClass. // (The merging checks for environment match but HLoadClass/kBootImageAddress // used for non-PIC mode does not have an environment at all.) 
 Thread.currentThread().sleep(delta); 
 * Copyright (C) 2017 The Android Open Source Project 
 for (int i = 0; i < Options.divergenceRetry + 1; i++) { 
 excludeList); 
 // delimiters for parsing carrier configs of the form "arg1, arg2 : action1, action2" 
 // delimiters for parsing carrier configs of the form "arg1, arg2 : action1, action2" 
 // return an empty list if no match found List<Integer> actionList = new ArrayList<>(); 
 // return an empty list if no match found List<Integer> actionList = new ArrayList<>(); 
 // parse each config until find the matching one matchConfig(config, arg1, arg2, actionList); 
 // parse each config until find the matching one matchConfig(config, arg1, arg2, actionList); 
 // parse each config until find the matching one matchConfig(config, arg1, arg2, actionList); 
 return actionList; 
 this.apSsid = ssidValue; 
 @Mock private SynchronousNetworkRecommendationProvider mNetworkRecommendationProvider; 
 runOnTargetSdk(25, () -> { // Nougat MR1 / MR2 
 * other than the current one (e.g. between releases). 
 // Compatibility behavior for API <= 25. http://b/33482884 
 // API version > 25. 
 aospSeappFile = copyResourceToTempFile("/general_seapp_contexts"); 
<|del|> 
 if (mListening == listening) { mContext.unregisterReceiver(mNfcReceiver); return; } 
<|del|> 
 mAdapter = NfcAdapter.getNfcAdapter(mContext); 
 final int timeoutMs = 150; mCm.requestNetwork(nr, networkCallback, timeoutMs); 
 final int requestTimeoutMs = 100; mCm.requestNetwork(nr, networkCallback, requestTimeoutMs); 
 final int assertTimeoutMs = 150; networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, assertTimeoutMs); 
 unitTests.add(new UT_multi_kernel(this, mCtx)); unitTests.add(new UT_multi_input(this, mCtx)); 
 Uri defaultRingtoneUri; if (UserManager.get(contextToUse).isUserUnlocked(contextToUse.getUserId())) { defaultRingtoneUri = RingtoneManager.getActualDefaultRingtoneUri(contextToUse, RingtoneManager.TYPE_RINGTONE); } else { defaultRingtoneUri = Settings.System.DEFAULT_RINGTONE_URI; } 
 public static final int WIFI_FEATURE_AP_STA = 0x8000; // AP STA Concurrency 
 public static final int WIFI_FEATURE_CONFIG_NDO = 0x200000; // ND offload 
 public static final int WIFI_FEATURE_CONTROL_ROAMING = 0x800000; // Control firmware roaming 
 public static final int WIFI_FEATURE_IE_WHITELIST = 0x1000000; // Probe IE white listing 
 public static final int WIFI_FEATURE_SCAN_RAND = 0x2000000; // Random MAC & Probe seq 
 public static final int WIFI_FEATURE_SCAN_RAND = 0x2000000; // Random MAC & Probe seq 
 String imei = mTelephonyManager.getImei(); if (mTelephonyManager.getSimState() == TelephonyManager.SIM_STATE_ABSENT && imei == null) { // If no SIM card is present, IMEI can be null. return; } 
 if (doThrow) { throw new Error(); } 
 private static final WatchEvent.Kind<?>[] ALL_EVENTS_KINDS = {ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY}; 
 public final FilesSetup filesSetup = new FilesSetup(); 
 this.expectedKind = expectedKind; this.expectedCount = 0; 
 // TODO: Fix this (b/35190858). 
 // Android-changed BEGIN: Android specific time zone logic 
 if (stat.getBlockSizeLong() * (stat.getAvailableBlocksLong() - 4) < length) { 
 static ZoneRules generateZoneRules(String zoneId) { 
 * Tests that the device properly reports either a valid IMEI if GSM or null. 
 * Tests that the device properly reports either a valid IMEI if GSM or null. 
 new DatagramPacket(smallPacketBytes, smallPacketBytes.length); 
 byte[] largePacketBytes = "0123456789".getBytes("UTF-8"); DatagramPacket largerPacket = new DatagramPacket(largePacketBytes, largePacketBytes.length); sds.send(largerPacket); 
 assertPacketDataEquals(largerPacket, p); 
 * The time this credential will expire. It is in the format of number 
<|del|> 
<|del|> 
<|del|> 
 connectivityService.prepareVpn(null, VpnConfig.LEGACY_VPN, userId); 
<|del|> 
public final class ParcelableException extends RuntimeException implements Parcelable { 
 int activationType, int activationState) { 
 private final Map<String, List<ComponentName>> mCachedWakeSignalConfigs = new HashMap<>(); 
 private final Map<String, List<ComponentName>> mCachedNoWakeSignalConfigs = new HashMap<>(); 
 private final Set<String> mCarrierSignalList = new HashSet<>(Arrays.asList( 
 Map<String, List<ComponentName>> cachedConfigs) { 
 // Android-changed: s/deprecated/deprecation @SuppressWarnings("deprecation") // avoids initialization cycles. 
 * Integer value used for indicating null value in the Parcel. 
 } // Fall through 
 } // An IMEI is not required for PHONE_TYPE_NONE or non-LTE PHONE_TYPE_CDMA 
<|del|> 
 mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who); 
 if (size == NULL_VALUE) { 
 if (size == NULL_VALUE) { 
 dest.writeInt(NULL_VALUE); 
 dest.writeInt(NULL_VALUE); 
 * {@link ConnectionService} to place a call or the service has indicated that is has an incoming 
 * the {@link PhoneAccount} has {@link PhoneAccount#CAPABILITY_SELF_MANAGED} and the calling app 
public final class InMemoryDexClassLoader extends ClassLoader { 
<|del|> 
 Log.i(TAG, "Received SIM change for invalid sub id."); 
 private final int mNumSlots; 
 // List index corresponds to Slot Id, Maps ImsFeature.FEATURE->bound ImsServiceController // Locked on mBoundServicesLock 
 // List index corresponds to Slot Id, Maps ImsFeature.FEATURE->bound ImsServiceController // Locked on mBoundServicesLock 
 public IImsServiceController getImsServiceController(int slotId, @ImsFeature.Feature int feature, IImsServiceFeatureListener callback) { if (slotId < 0 || slotId >= mNumSlots || feature <= ImsFeature.INVALID || feature >= ImsFeature.MAX) { 
 synchronized (mBoundServicesLock) { 
 System.out.println("Loading invalid library 'libinvalid.so' from Java, which will fail."); 
 mHandlerThread.quitSafely(); 
 * Copyright (C) 2017 The Android Open Source Project 
 // TODO: Find a more accurate method name (startDHCPv4()?). mNMService.startTethering(cfg.dhcpRanges); 
 pw.println(" - lastError = " + tetherState.mLastError); 
 disableTracing(); mLastMileLogForLastFailure = readTrace(); 
<|del|> 
 mNetworkScoreManager = mContext.getSystemService(NetworkScoreManager.class); 
 if (filename.getBytes().length > OPP_LENGTH_OF_FILE_NAME) { 
 if (filename.getBytes().length > OPP_LENGTH_OF_FILE_NAME) { 
 Log.i(TAG, "Extraction " + (isExtractionSuccessful ? "succeeded" : "failed") + 
 extractedDexId++; 
<|del|> 
 public IImsServiceController getImsServiceController(int slotId, @ImsFeature.Feature int feature, IImsServiceFeatureListener callback) { if (slotId < 0 || slotId >= mNumSlots || feature <= ImsFeature.INVALID || feature >= ImsFeature.MAX) { 
 if (slotId < 0 || slotId >= mNumSlots || feature <= ImsFeature.INVALID || feature >= ImsFeature.MAX) { Log.w(TAG, "removeImsController received invalid parameters - slot: " + slotId + ", feature: " + feature); 
 Optional<ImsServiceController> o = getControllerByServiceInfo(mActiveControllers, info); 
 case CMD_TETHER_MODE_REQUESTED: { 
 case CMD_TETHER_MODE_REQUESTED: { 
 } mIPv6TetheringCoordinator.removeActiveDownstream(who); 
 intent.setClassName(PAIRING_REQUEST_PACKAGE, PAIRING_REQUEST_CLASS); 
 debugLog("aclStateChangeCallback: State:Disconnected to device:" + device); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Log.d(TAG, "BleAdaptor is NOT enabled, enable now"); mBluetoothAdapter.enable(); 
 * Method to receive the broadcast from Python client or AlarmManager 
 * Method to process parameters from Python client 
 if (!extras.containsKey("LdacPlaybackQuality")) { 
 private boolean prepare(int codecType, int sampleRate, int bitsPerSample, long codecSpecific1, long codecSpecific2, long codecSpecific3, long codecSpecific4, 
 // If value is an optimized conditional, it was already converted by the second call to 
 // Android-changed: date/time patterns changed in new CLDR; adapt to UK locale. 
 // Android-changed: upstream tests expect title case names for pt_BR, but CLDR has lower 
 // Android-changed: allResults contains narrow values. //assertTrue(allResult.size() <= shortResult.size() // + longResult.size()); 
 // Android-changed: Android has traditionally treated ALL_STYLES as SHORT, even though // it's not documented to be a valid value for style. 
 // Android-changed: 3 is not a valid base style (1, 2 and 4 are, though), throw if used. 
 // Android-changed: 3 is not a valid base style (1, 2 and 4 are, though), throw if used. 
<|del|> 
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved. 
 // Android-changed: Use provided locale instead of default, if it is non-null. 
 mUpstreamNetworkMonitor.start(); mOffloadController.start(); 
 } for (int tetherType : tethered) { startProvisionIntent(tetherType); } 
 public void dumpDoesNotClearPendingConnectionTrace() throws Exception { 
 // Fix up upstream interface types for DUN or mobile. NOTE: independent // of the value of |requiresDun|, cell data of one form or another is // *always* an upstream, regardless of the upstream interface types // specified by configuration resources. 
 return matchesDownstreamRegexs(iface, tetherableWifiRegexs); 
<|del|> 
 this.revision = validate3DigitVersion(revision); 
 public static BundleVersion fromBytes(byte[] bytes) throws BundleException { 
 public byte[] toBytes() { return toBytes(formatMajorVersion, formatMinorVersion, rulesVersion, revision); 
 /** * Validates and parses a zero-padded three-digit String value. */ private static int from3DigitVersionString(String versionString) throws BundleException { 
 public static boolean isDeferredForProvision(Context context, Intent intent) { 
 List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) { 
<|del|> 
<|del|> 
<|del|> 
 int key = storePendingResponseMessage(response); 
 ArrayList<Integer> tethered = new ArrayList<>(); 
 tethered.add(interfaceType); 
 mSimAbsentSeen = true; 
 public static final int SMS_RECORD_LENGTH = 176; 
 Log.d(TAG, "Ignore unsupported EAP method parameter: " + child.getName()); 
 * The name of the application used to generate the password. 
 * * The Policy specifies additional criteria for Passpoint network selections, such as preferred * roaming partner, minimum backhaul bandwidth, and etc. It also provides the meta data for * updating the policy. * 
<|del|> 
 javaIoPrintStreamClass, printlnMethodId, true /* virtual method */); 
 eq(""), mServiceNotificationCaptor.capture()); // act: get the service started (which happens even when service was already up) mServiceNotificationCaptor.getValue().onRegistration(IWifi.kInterfaceName, "", true); // verify: wifi initialization sequence 
<|del|> 
<|del|> 
<|del|> 
 mBluetoothAdapter.enable(); if (!mBluetoothAdapter.isEnabled()) { Log.e(TAG, "Can't enable Bluetooth"); return; } 
<|del|> 
 * Create a STA interface if possible. Changes chip mode and removes conflicting interfaces if * needed and permitted by priority. 
 * @return A newly created interface - or null if the interface could not be created. 
 * @return A newly created interface - or null if the interface could not be created. 
 * @return A newly created interface - or null if the interface could not be created. 
 * @return A newly created interface - or null if the interface could not be created. 
 * only be valid if the interface creation was successful - i.e. a non-null was returned. 
 * Removes (releases/destroys) the given interface. Will trigger any registered 
 * was created - allowing non-creators to monitor interface status. 
 * was created - allowing non-creators to monitor interface status. 
 * only be valid if the interface creation was successful - i.e. a non-null was returned. 
 * - Called at most once 
 public static final int EMERGENCY_MMTEL = 0; public static final int MMTEL = 1; 
<|del|>
 if (DBG) Rlog.d(LOG_TAG, "notifying listener: " + cw.listener.getClass().toString() + " for token: " + token + mCallerInfo); 
 public IpSecAlgorithm(String algorithm, byte[] key) { 
 public IpSecAlgorithm(String algorithm, byte[] key) { 
 mKey = key.clone(); mTruncLenBits = Math.min(truncLenBits, key.length * 8); 
 mKey = key.clone(); mTruncLenBits = Math.min(truncLenBits, key.length * 8); 
<|del|> 
 synchronized (mEntriesMap) { // Locking to ensure that the background handler does not mutate // the size of AppEntries used for ordering while sorting. 
 synchronized (mEntriesMap) { // Locking to ensure that the background handler does not mutate // the size of AppEntries used for ordering while sorting. 
 Pair<String, Integer> openChannelArgs = (Pair<String, Integer>) request.argument; 
 @ @param p2 P2 paramter (described in ISO 7816-4). Default value: 0x00 
 * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 
 /** {@code non-null;} common comparison instance used while interning */ private static final ForComparison theInterningItem = new ForComparison(); 
 throw new BundleException("Expected 1 <= value <= 999, was " + value); 
 BundleVersion bundleVersion = new BundleVersion(BundleVersion.CURRENT_FORMAT_MAJOR_VERSION, BundleVersion.CURRENT_FORMAT_MINOR_VERSION, "2016c", 1); 
 private String mSimFullReceiverClass; 
 eq(""), mServiceNotificationCaptor.capture()); // act: get the service started (which happens even when service was already up) mServiceNotificationCaptor.getValue().onRegistration(IWifi.kInterfaceName, "", true); // verify: wifi initialization sequence 
 if (carrierImsPackage.equals(info.serviceInfo.packageName)) { 
 Context.CARRIER_CONFIG_SERVICE); 
 protected static final boolean VDBG = false; 
 private static final String CARRIER_IMS_PACKAGE_KEY = "config_ims_package_override_string"; /** Return a Carrier-overridden IMS package, if it exists and is a CarrierSmsFilter 
 * @param context calling context * @param phone object from telephony * @param intent that should match a CarrierSmsFilter * @return the name of the IMS CarrierService package 
 * @param context calling context * @param phone object from telephony * @param intent that should match a CarrierSmsFilter * @return the name of the IMS CarrierService package 
 * @param context calling context * @param phone object from telephony * @param intent that should match a CarrierSmsFilter * @return the name of the IMS CarrierService package 
 "android.telephony.ims.EMERGENCY_MMTEL_FEATURE"; public static final String METADATA_MMTEL_FEATURE = "android.telephony.ims.MMTEL_FEATURE"; public static final String METADATA_RCS_FEATURE = "android.telephony.ims.RCS_FEATURE"; 
 public static final String METADATA_EMERGENCY_MMTEL_FEATURE = "android.ims.EMERGENCY_MMTEL_FEATURE"; public static final String METADATA_MMTEL_FEATURE = "android.ims.MMTEL_FEATURE"; 
 "display_originating_addr TEXT);" // email address if from an email gateway, otherwise same as address ); 
 copyRange = EmulatedStackFrame.Range.of(delegate.type(), 0, arrayOffset); writer = new StackFrameWriter(); reader = new StackFrameReader(); 
<|del|> 
 request.result = null; 
 // Android-changed: upstream tests expect title case names for pt_BR, but CLDR has lower 
 // Android-changed: allResults contains narrow values. // assertDisplayNameMap(values, allResult, 0); 
 // Android-changed: allResults contains narrow values. //assertTrue(allResult.size() <= shortResult.size() // + longResult.size()); 
 // Android-changed: "ji" isn't correctly aliased to "yi", see http//b/8634320. 
 // Android-changed (http://b/33197219): TimeZone.getDisplayName() for 
 // Android-changed: disable test as it doesn't assert anything and produces a lot of output. 
 // Android-changed: This test assumes that the system classloader sees all test classes. // That assumption is untrue, when run in CTS. Use this class's classloader instead. 
 mUpstreamNetworkMonitor.start(); mOffloadController.start(); 
 Pair<String, Integer> openChannelArgs = (Pair<String, Integer>) request.argument; 
 * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 
 rr.mParcel.writeString(AID); rr.mParcel.writeByte(p2); 
 * @param p2 P2 parameter (described in ISO 7816-4). Default value: 0x00 
 "display_originating_addr TEXT);" // email address if from an email gateway, otherwise same as address ); 
 Log.e(TAG, "[upgradeDatabaseToVersion66] Exception adding column " + "display_originating_addr;" + e); 
 + "display_originating_addr; " + e); 
 * @param address originating address * @param displayAddress email address if this message was from an email gateway, otherwise same * as originating address 
 public boolean putCertsInKeyStore(String name, Certificate[] certs) { 
 // the object returned. We also need to omit the leading reference, which is // nominally the type of the object being constructed. 
 @Nonnull Frame<BasicValue> rhsFrame; 
 private long mDiscoveryEndMs; //< Time (ms since epoch) that discovery ended or will end. 
 long discoveryEndMillis() { return mDiscoveryEndMs; 
<|del|> 
<|del|> 
 if (config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) && config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) { 
 if (config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) && config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) { 
 if (config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) && config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) { 
 // If library is well formed this exception cannot be triggered 
 // If library is well formed this exception cannot be triggered 
 * Copyright (C) 2017 The Android Open Source Project 
 * {@link Exception} when a {@link VFS} does not match the expected VFS type, but may be a valid VFS * of another type. 
<|del|> 
<|del|> 
 mUsbAlsaManager.setPeripheralMidiState(mMidiEnabled && mConfigured, mMidiCard, mMidiDevice); 
 mKey = in.createByteArray(); 
/** * IpSecAlgorithm specifies a single algorithm that can be applied to 
 // Parcelable Methods public boolean hasFeature(int featureBits) { return (features & featureBits) == featureBits; 
 } 
 IpSecConfig() {} 
 public void addTransportModeTransform(IpSecTransform tranform) 
 fd = Libcore.rawOs.socket(AF_INET, SOCK_DGRAM, 0); return Libcore.rawOs.ioctlFlags(fd, name); 
 mUpstreamNetworkMonitor.start(); mOffloadController.start(); 
<|del|> 
<|del|> 
 mWifiMonitor.broadcastPnoScanResultEvent(mClientInterfaceName); 
 when(mWifiNative.getInterfaceName()).thenReturn("mockWlan"); when(mWifiNative.enableSupplicant()).thenReturn(true); when(mWifiNative.disableSupplicant()).thenReturn(true); 
<|del|> 
 try { hasSourceInfo = HasSourceInfo.class.isAssignableFrom(getNNodeClass()); } catch (InvalidTokenException e) { hasSourceInfo = false; } finally { hasSourceInfoBeenRequested = true; } 
 try { hasSourceInfo = HasSourceInfo.class.isAssignableFrom(getNNodeClass()); } catch (InvalidTokenException e) { hasSourceInfo = false; } finally { hasSourceInfoBeenRequested = true; } 
 @Nonnull public Class<? extends NNode> getNNodeClass() throws InvalidTokenException { throw new InvalidTokenException("No node coresponding to token " + this.toString()); 
 public final boolean hasSourceInfo() throws InvalidTokenException { 
 public Class<? extends NNode> getNNodeClass() { throw new JayceFormatException("Unexpected node '" + toString() + "'"); 
 /// CHECK: mov x17, #<<Offset:0x[0-9a-f]{4}>> /// CHECK: add x16, {{x\d+}}, x17 /// CHECK: ldar {{w\d+}}, [x16] 
 public class InnerClass { 
 * defaults to {@code ":"} on Android. * @param optimizedDirectory this parameter is deprecated and has no effect 
 * defaults to {@code ":"} on Android. * @param optimizedDirectory this parameter is deprecated and has no effect 
 * defaults to {@code ":"} on Android. * @param optimizedDirectory this parameter is deprecated and has no effect 
 * defaults to {@code ":"} on Android. * @param optimizedDirectory this parameter is deprecated and has no effect 
 * defaults to {@code ":"} on Android. * @param optimizedDirectory this parameter is deprecated and has no effect 
<|del|> 
 if (grantResults.length == 0 || grantResults[0] != PackageManager.PERMISSION_GRANTED) { 
 if (DBG) Rlog.d(LOG_TAG, "notifying listener: " + cw.listener.getClass().toString() + " for token: " + token + mCallerInfo); 
<|del|>
 private static final Set<String> ALL_ALGOS = new HashSet<>(Arrays.asList(ALGO_AES_CBC, ALGO_HMAC_MD5, ALGO_HMAC_SHA1)); 
<|del|> 
 } 
 throws SocketNotBoundException, TransformCollisionException, InsufficientPermissionException { 
 throws SocketNotBoundException, TransformCollisionException, 
 throws SocketNotBoundException, InsufficientPermissionException { 
 } 
 IpSecConfig() {} 
 DatagramChannel serverChannel = DatagramChannel.open()) { 
<|del|> 
 guard.open("close"); 
<|del|> 
 // Android-changed: "ji" isn't correctly aliased to "yi", see http//b/8634320. 
 // Android-changed (http://b/33197219): TimeZone.getDisplayName() for 
<|del|> 
<|del|> 
 public static final int CS_REJECT_CAUSE_NOTIFICATION = 111; // Id to update and cancel MM // rejection cause 
 final int PREFIX_VALID_LIFETIME = 200; final int PREFIX_PREFERRED_LIFETIME = 100; 
 if (regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED 
 * Selects the resource ID, which depends on the rejection cause that is sent by the network * when CS registration is rejected. 
<|del|> 
<|del|> 
 nullToEmpty(device.getProperty(entry.getValue()))); 
 * // Yes this version of OptionalLong is not compatible with the real one but since it isn't used * // for anything in the runtime initialization it should be fine. 
 * // Make sure we have a <clinit> function since the real implementation of OptionalLong does. 
 } 
<|del|> 
 //TODO: hook this up to ConnectivityService#startNattKeepalive 
 public void setVoiceActivationState(int state) { mSimActivationTracker.setVoiceActivationState(state); 
 private final LocalLog mVoiceActivationStateLog = new LocalLog(10); private final LocalLog mDataActivationStateLog = new LocalLog(10); private final BroadcastReceiver mReceiver; 
 private final LocalLog mVoiceActivationStateLog = new LocalLog(10); private final LocalLog mDataActivationStateLog = new LocalLog(10); private final BroadcastReceiver mReceiver; 
 if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)){ 
 if (DBG) log("onSimAbsent, reset activation state to UNKNOWN"); 
<|del|> 
<|del|> 
 // otasp call follows with CDMA OTA PROVISION STATUS update which signals activation result 
 return (mMultinetworkPolicyTracker == null) || mMultinetworkPolicyTracker.getAvoidBadWifi(); 
 return (mMultinetworkPolicyTracker == null) || mMultinetworkPolicyTracker.getAvoidBadWifi(); 
 * * @param nc The superseding {@code NetworkCapabilities} instance. 
<|del|> 
 mKey = in.createByteArray(); 
 } else if (name.startsWith("Jit thread pool worker")) { 
 } else if (name.startsWith("Jit thread pool worker")) { 
<|del|> 
<|del|> 
 * Save the ScanDetail to the ScanDetailCache of the given network. This is used 
 @Test @Runtime 
 @Test @Runtime 
 @Test @Runtime 
 public void testLamba044_ByTestClass() throws Exception { 
<|del|> 
 public static final int CS_REJECT_CAUSE_NOTIFICATION = 111; // Id to update and cancel MM // rejection cause 
 if (regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED 
 * Selects the resource ID, which depends on the rejection cause that is sent by the network * when CS registration is rejected. 
<|del|> 
 mWifiP2pNative.setSupplicantStaIfaceHal(mSupplicantStaIfaceHal); 
public class WificondControlTest { private WifiInjector mWifiInjector; 
 private ConnectivityManager mCM; private NetworkCallback mListenAllCallback; 
<|del|> 
 verify(mHalDeviceManager).isReady(); verify(mHalDeviceManager).isStarted(); 
 // set the retry boolean to true if we need to go around again due to jit code being GCd. 
 // set the retry boolean to true if we need to go around again due to jit code being GCd. 
 return Form4rcc.THE_ONE; 
 mISupplicant = null; mISupplicantStaIface = null; 
<|del|> 
 if (DBG) Log.i(TAG, "Registering ISupplicant service ready callback."); 
 if (DBG) { Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting); } 
<|del|> 
<|del|> 
 // This object is going to be used by both WifiService, so we may 
 // This object is going to be used by both WifiService, so we may 
 mInitializationComplete = false; 
 mInitializationComplete = false; 
 if (!initSupplicantService() || !initSupplicantStaIface()) { 
 + e); supplicantServiceDiedHandler(); 
 boolean hasIface = false; 
 /** * Signals whether Initialization completed successfully. Only necessary for testing, is not * needed to guard calls etc. */ public boolean isInitializationComplete() { return mInitializationComplete; 
 boolean isReady = mHalDeviceManager.isReady(); boolean isStarted = mHalDeviceManager.isStarted(); if (DBG) { Log.i(TAG, "Device Manager onStatusChanged. isReady(): " + isReady + "isStarted(): " + isStarted); } 
 boolean isReady = mHalDeviceManager.isReady(); boolean isStarted = mHalDeviceManager.isStarted(); if (DBG) { Log.i(TAG, "Device Manager onStatusChanged. isReady(): " + isReady + "isStarted(): " + isStarted); } 
 DatagramChannel serverChannel = DatagramChannel.open()) { 
 intent.setClassName(PAIRING_REQUEST_PACKAGE, PAIRING_REQUEST_CLASS); 
 * defaults to {@code ":"} on Android. * @param optimizedDirectory this parameter is deprecated and has no effect 
 * @return True if roaming is enabled; false otherwise. 
 * @param roaming 1: Enable data roaming; 0: Disable data roaming. * @return True for setting roaming mode successfully; false otherwise. 
<|del|> 
 guard.open("close"); 
 guard.open("close"); 
 int featureMask = IpSecConfig.FEATURE_TRANSPORT_MODE | IpSecConfig.FEATURE_SELECTOR; if (!config.hasFeature(featureMask)) { 
 if (!config.hasFeature(IpSecConfig.FEATURE_ENCRYPTION) 
 if (isStatusBarEnabled()) { 
<|del|> 
<|del|> 
 // Skip JIT thread pool. It may or may not be there depending on configuration. 
 // Filter out JIT thread. It may or may not be there depending on configuration. 
 if (!supportsSplitScreenMultiWindow()) { 
 newRssi = pollResult.currentRssi; newLinkSpeed = pollResult.txBitrate; newFrequency = pollResult.associationFrequency; 
 WifiNative.TxPacketCounters counters = mWifiNative.getTxPacketCounters(); if (counters != null) { info.txgood = counters.txSucceeded; info.txbad = counters.txFailed; 
 @Nonnull CharStream inputStream) throws RecognitionException { 
<|del|> 
 // Android-changed: Using initializer method for GET_TARGET // rather than complex static initializer. 
<|del|> 
 if (carrierImsPackage != null || callingUid == mContext.getPackageManager().getPackageUid( 
 void socketBind(InetAddress address, int port) throws IOException { if (fd == null || !fd.valid()) { throw new SocketException("Socket closed"); } 
<|del|> 
 .create("jack.plan-amender.force", "Force plan amender") .addDefaultValue(false) .addCategory(Private.class); 
 .create("jack.plan-amender.force", "Force plan amender") .addDefaultValue(false) .addCategory(Private.class); 
 UiObject okButton = device.findObject(new UiSelector().text("OK")); okButton.waitForExists(TimeUnit.SECONDS.toMillis(3L)); okButton.click(); 
 initializeGetTarget(); 
 if (tasks == null) { 
 if (tasks == null) { 
 return env.getTypeUtils().getDeclaredType(getTypeElement(), env.getTypeUtils().getWildcardType(null, null)); 
 static boolean field; static boolean doThrow = false; 
 // Don't skip Empty Line. 
 if (V) Log.v(TAG,"outputsize 0"); 
 return new String(line, "UTF-8"); 
 return new String(line, "UTF-8"); 
 if (line == null || line.length == 0) return null; return new String(line, "UTF-8"); 
<|del|> 
 Log.e(TAG, "Can't enable Bluetooth"); 
 sampleRate, bitsPerSample, channelMode, 
 Log.e(TAG, "mBluetoothA2dp is null. Codec is not set"); 
 if (change.equalsIgnoreCase("Activate")) { 
 if (change.equalsIgnoreCase("Activate")) { 
 return new Gson().toJson(new RestServiceModel( POST, "/GeoManagerService", new GeoManagerModel("String").toString())); 
 mDevice.findObject(new UiSelector().text(Constants.TIP_BUTTON_OK)) .clickAndWaitForNewWindow(); 
 mDevice.findObject(new UiSelector().text(Constants.TIP_BUTTON_OK)) .clickAndWaitForNewWindow(); 
 return new Gson().toJson(new RestServiceModel( POST, "/OrientationManagerService", new OrientationManagerModel("String").toString())); 
 "(com.android.launcher\\d*:id|com.google.android." + "googlequicksearchbox\\d*:id|com.google.android.apps." + "nexuslauncher\\d*:id)/(all_apps_container|apps_customize_pane_content|apps_list_view)"; 
 if (immediateHalFailure) { // short-circuit the rest of this test verifyNoMoreInteractions(mMockNative, mMockCm); return; 
 // Length of the SSID: 0x0b or 11. 
<|del|> 
 public String nonAscii = "Sigma (\u01a9) is not ASCII"; public String embeddedZero = "embedded\0..."; // Non-ASCII for string compression purposes. 
 public String nonAscii = "Sigma (\u01a9) is not ASCII"; public String embeddedZero = "embedded\0..."; // Non-ASCII for string compression purposes. 
 public boolean needsInput() { return len <= 0; 
<|del|> 
 * Waits for a predicate to return {@code true} within the specified timeout. Uses the 
 private static final String SUITE_PLAN = "verifier"; 
 private static final String REPORT_DIRECTORY = "verifierResults"; 
 URL fileUrl = getFileUrlWithCredentials(VALID_USER, VALID_PASSWORD, filePath); 
<|del|> 
 return result > 0; 
 if (TextUtils.isEmpty(bssid)) { return doBooleanCommand("WPS_PBC"); 
 throw new RuntimeException("buildInfo is null"); 
 // at 1/2 interval have the system simulate transmitting a queued message over-the-air if (i % 2 == 1) { 
 verify(mockSessionCallback, times(numOfFailuresInternalFailure)).onMessageSendFail(anyInt(), eq(NanStatusType.INTERNAL_FAILURE)); verify(mockSessionCallback, times(numOfFailuresNoOta)).onMessageSendFail(anyInt(), eq(NanStatusType.NO_OTA_ACK)); 
 private final Map<Integer, Integer> mRetryLimit; 
 private final Map<Integer, Integer> mTriesUsedByMid = new HashMap<>(); // mid -> # of retx 
 mQueue.addLast(transactionId); 
 * Processes the first message in the queue: i.e. responds as if sent over-the-air 
 mTriesUsedByMid.put(mid, currentRetries + 1); 
 * @param networkCallback The {@link NetworkCallback} to be utilized for this * request. Note the callback must not be shared - they * uniquely specify this request. 
 return new String(chars.asRawByteArray(/* offset */ 0, length), StandardCharsets.US_ASCII); 
 // Test the case where input is null and reason is not null. 
<|del|> 
<|del|> 
 Path stubPath = mock(Path.class); BasicFileAttributes stubAttributes = mock(BasicFileAttributes.class); SimpleFileVisitor<Path> fileVisitor = new TestSimpleFileVisitor(); 
 assertEquals(FileVisitResult.CONTINUE, fileVisitor.postVisitDirectory(stubPath, null)); 
 assertEquals(FileVisitResult.CONTINUE, fileVisitor.postVisitDirectory(stubPath, null)); 
 /** * SimpleFileVisitor only has a protected constructor so we use a basic subclass for tests. */ private static class TestSimpleFileVisitor extends SimpleFileVisitor<Path> { 
 /** * SimpleFileVisitor only has a protected constructor so we use a basic subclass for tests. */ private static class TestSimpleFileVisitor extends SimpleFileVisitor<Path> { 
 MethodType mt = MethodType.methodType(int.class, long.class, String.class); assertEquals(int.class, mt.returnType()); 
 public void removeTransportTransform(IpSecTransform transform) throws SocketNotBoundException, InsufficientPermissionException { int transformId; synchronized (transform) { transformId = transform.getTransformId(); transform.setTransformId(IpSecTransform.INVALID_TRANSFORM_ID); } 
 throw new IllegalArgumentException("invalid voice activation state: " + state); 
 throw new IllegalArgumentException("invalid data activation state: " + state); 
 assertNotNull(fs.provider()); 
 assertNotNull(fs.provider()); 
 Map<String, String> stubEnv = new HashMap<>(); 
 if (!mSupplicantP2pIfaceHal.initialize()) { return false; 
 public void fileServicesUpdated(List<FileServiceInfo> services) { 
<|del|> 
 System.out.println("Another Instance"); 
 networkList, deserializeData(xmlData, false /* shared */)); 
 public void testFallThroughCaseWithPhi() { 
<|del|> 
 private static void edgeSplitMoveExceptionsAndResults(@Nonnull SsaMethod ssaMeth) { 
<|del|> 
<|del|> 
 // This appears to never be an issue in Jack nor DX as far as we can tell. 
 * Test that parsing a typical colon-delimited MAC address works. 
 * Test that conversion of byte array of mac address to typical colon-delimited MAC address 
 * Copyright (C) 2017 The Android Open Source Project 
 * Convert the byte array list to string. * * @return the string decoded from UTF_8 byte values in byteArrayList. * @throws IllegalArgumentException if a null byte array list is sent. 
 if (i != 0) sb.append(":"); sb.append(new String(HexEncoding.encode(macArray, i, 1))); 
 return sb.toString(); 
 return sb.toString(); 
<|del|> 
 public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws Zygote.MethodAndArgsCaller { if (RuntimeInit.DEBUG) { Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from zygote"); } 
<|del|> 
 format.setInteger(MediaFormat.KEY_BIT_RATE, MediaCodec.createByCodecName((new MediaCodecList(MediaCodecList.REGULAR_CODECS)).findEncoderForFormat(format)).getCodecInfo().getCapabilitiesForType(MIME_TYPE).getVideoCapabilities().getBitrateRange().clamp(bitRate)); 
<|del|> 
 Class<?> AnotherClass = (Class<?>)DexFile_loadClass.invoke(dexFile, "Another", Main.class.getClassLoader()); 
 // Check that table size is >= min expected size. Due to a bug in 
 public static final boolean VERBOSE = false; 
 * Converts an ssid string to an arraylist of UTF_8 byte values. * These forms are acceptable: * a) ASCII String encapsulated in quotes, or * b) Hex string with no delimiters. 
 * Converts an ssid string to an arraylist of UTF_8 byte values. * These forms are acceptable: * a) ASCII String encapsulated in quotes, or * b) Hex string with no delimiters. 
 * Converts an ssid string to an arraylist of UTF_8 byte values. * These forms are acceptable: * a) ASCII String encapsulated in quotes, or * b) Hex string with no delimiters. 
 } return hexStringFromByteArray(ssidArray); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public static final Map<String,Set<String>> PROVIDER_ALGORITHMS = new HashMap<String,Set<String>>(); 
 WifiStatus status; kilroy(); 
<|del|> 
<|del|> 
 Calendar.Builder builder = new Calendar.Builder(); GregorianCalendar expected = new GregorianCalendar(); expected.clear(); assertEquals(expected, builder.build()); 
 fail("Should not accept second setCalendarType() call"); } catch (IllegalStateException expected) {} 
 fail("Should not accept second setCalendarType() call"); } catch (IllegalStateException expected) {} 
 assertEquals(expected, builder.build()); 
 public void test_setFields_after_setInstant() { Calendar.Builder builder = new Calendar.Builder(); 
 public static final boolean VERBOSE = false; 
 * Tests connection to a specified network, with a triggered disconnect. 
 int connectedNetworkId = ROAM_NETWORK_ID; String roamBssid = ROAM_BSSID; 
 roamNetworkId = connectedNetworkId + 1; 
 if (mHasVending) { mRecommendedServicesAdapter = new RecommendedServicesAdapter(); } else { mNoPrintServiceMessageAdapter = new NoPrintServiceMessageAdapter(); } 
 // Ceiling bitshift amount for service query timeout, calculated as: // 2^mImsServiceRetryCount * IMS_RETRY_STARTING_TIMEOUT_MS, where // mImsServiceRetryCount  [0, CEILING_SERVICE_RETRY_COUNT]. private static final int CEILING_SERVICE_RETRY_COUNT = 6; 
 // Be sure to lock on mFeatures before accessing this method 
 static void inlinedForNull(Iterable<?> it) { 
<|del|> 
<|del|>
 if (ssid != null) { wifiSsid.octets.write(ssid, 0/* the start offset */, ssid.length);; } 
<|del|> 
<|del|> 
 sendInternalMessage(SWITCH_BASELINE_ROUTE); 
 .setMessage(getString(R.string.intent_not_resolved_info, message)) 
 private boolean mShowCellSignal; 
 FileSystems.newFileSystem(testPath.toUri(), stubEnv, mockClassLoader); 
 * Validate that when no chip info is found an empty list is returned. 
 Log.e(TAG, "setBrowsedPlayer: " + mPackageName + "no Session token"); 
 @RpcParameter(name = "ping") @RpcOptional String pingType) { 
<|del|> 
 private void serializeAndDeserializePasspointConfiguration(PasspointConfiguration testConfig) 
 public void broadcastSupplicantConnectionEvent(String iface) { sendMessage(iface, SUP_CONNECTION_EVENT); 
 public void broadcastSupplicantDisconnectionEvent(String iface) { sendMessage(iface, SUP_DISCONNECTION_EVENT); 
 * @param iface Name of iface on which this occurred. * @param networkId ID of the network in wpa_supplicant. * @param bssid BSSID of the access point. * @param newSupplicantState New supplicant state. 
 mHandlerSpy = spy(new Handler(mLooper.getLooper())); 
 private static final CyclicBarrier barrier = new CyclicBarrier(NUMBER_OF_THREADS); 
 * Additional tests for {@link Chronology}. * * @see tck.java.time.chrono.TCKChronology 
 chronologies.add(new DummyChronology("aaa", "z aaa")); chronologies.add(new DummyChronology("zzz", "a zzz")); 
 private static void assertComparesAccordingToId(Chronology c1, Chronology c2) { 
 * Copyright (C) 2017 The Android Open Source Project 
 ZonedDateTime result = IsoChronology.INSTANCE 
 ZonedDateTime result = IsoChronology.INSTANCE 
 // year 1 in Minguo calendar is 1912 in ISO calendar. 
 // year 2543 in Thai Buddhist calendar is 2000 in ISO calendar. 
 deserializeData(xmlString.getBytes(StandardCharsets.UTF_8), true /* shared */); 
 deserializeWifiEnterpriseConfig(xmlString.getBytes(StandardCharsets.UTF_8)); 
 unlockData = Boolean.valueOf(args[3]); 
 public void broadcastAnqpDoneEvent(String iface, AnqpEvent anqpEvent) { sendMessage(iface, ANQP_DONE_EVENT, anqpEvent); 
 public void notifyANQPDone(AnqpEvent anqpEvent) { 
 { ChronoField.YEAR_OF_ERA, Year.MAX_VALUE + 1 }, { ChronoField.YEAR, Year.MIN_VALUE - 1 }, { ChronoField.YEAR, Year.MAX_VALUE + 1 }, 
 fail("ym.with(" + field + ", " + value + ") should have failed."); 
 long value = invalidField.range().getMinimum(); 
 "must run in the untrusted_app_25 selinux domain.", 
 "must run in the untrusted_app selinux domain.", 
 if (!isValidAlgorithm(algorithm, truncLenBits)) { 
<|del|> 
 String addrString = in.readString(); if (addrString == null) { return null; } 
 final int transformId; 
 /** * Retrieve an instance of an IpSecManager within you application context * * @param context the application context for this manager */ 
<|del|> 
 private final HashMap<Integer, IpSecTransformInfo> mTransformInfo = new HashMap<>(); 
 // We should get onAvailable(), onCapabilitiesChanged(), onLinkPropertiesChanged(), // and onNetworkSuspended() in rapid succession. 
 * Magic version number for a current development build, which has not * yet turned into an official release. This number must be larger than * any released version in {@code android.os.Build.VERSION_CODES}. 
 * @param targetSdkVersion A value {@code 1 <= targetSdkVersion <= SDK_VERSION_CUR_DEVELOPMENT} 
 * @param targetSdkVersion A value {@code 1 <= targetSdkVersion <= SDK_VERSION_CUR_DEVELOPMENT} 
 List<MediaSession.QueueItem> selected = items.subList((int) startItem, (int) Math.min(items.size(), endItem + 1)); if (selected.isEmpty()) { Log.i(TAG, "itemsSubList is empty."); return null; 
 * functionality. Must be able to handle emergency calls at any time as well. 
 if (mBinder != null) { 
 } 
 if (!isBinderAlive()) { 
 JSONArray interval = j.getJSONArray("DiscoveryWindowInterval"); if (interval.length() != 2) { 
 AnqpEvent anqpEvent = null; // If there are no errors fetch the ANQP elements from wpa_supplicant, otherwise return // empty ANQP elements. 
 // Subtracting a negative Duration is the same as adding the negated value. 
 // Adding a negative duration is the same as subtracting the negated value. 
 Set<Integer> anqpIds = new TreeSet<>(); Set<Integer> hs20Subtypes = new TreeSet<>(Arrays.asList(3, 7)); 
 Set<Integer> anqpIds = new TreeSet<>(); Set<Integer> hs20Subtypes = new TreeSet<>(Arrays.asList(3, 7)); 
 private boolean mVerboseLoggingEnabled = false; 
 * SHA1 HMAC Authentication/Integrity Algorithm. This algorithm is not recommended for use in 
 public int getTruncationLengthBits() { 
 if (transformId < 0) { throw new ErrnoException("addTransform", -transformId).rethrowAsIOException(); } 
 transform.startKeepalive(mContext); // Will silently fail if not required transform.setTransformId(transformId); Log.d(TAG, "Added Transform with Id " + transformId); } 
 Log.d(TAG, "Removing Transform with Id " + transformId); 
<|del|> 
 public IpSecManager(Context context, INetworkManagementService service) { 
 mService = checkNotNull(service, "missing service"); 
 * For direction-specific attributes of an IpSecTransform, indicates that an attribute applies * to traffic from the host. 
 assertFalse(mTelecomManager.getPhoneAccount(TestUtils.TEST_PHONE_ACCOUNT_HANDLE) .isEnabled()); 
 Log.d(TAG, "onAcceptFailed() calling shutdown..."); 
<|del|> 
 + mClusterHigh + ", mDiscoveryWindowInterval=" 
 if (mDiscoveryWindowInterval[NAN_BAND_5GHZ] != DW_INTERVAL_NOT_INIT && 
public final class IpSecAlgorithm implements Parcelable { 
 out.writeString((localAddress != null) ? localAddress.getHostAddress() : null); 
 /** @hide */ private static final int MODE_TUNNEL = 0; /** @hide */ private static final int MODE_TRANSPORT = 1; 
 public static final int ENCAP_ESPINUDP = 1; 
 /** @hide */ @IntDef(value = {ENCAP_ESPINIP, ENCAP_ESPINUDP, ENCAP_ESPINUDP_NONIKE}) 
 if (mConfig.getNattKeepaliveInterval() == 0) { 
 /** Add an encryption algorithm to the transform. */ public IpSecTransform.Builder setEncryption( @TransformDirection int direction, IpSecAlgorithm algo) { mConfig.flow[direction].encryptionAlgo = algo; return this; 
<|del|> 
 * Sets a connection active, and verifies TelecomManager thinks we're in call but not in a * managed call. 
 public Call waitForCallAdded() { 
<|del|> 
 * don't do anything */ 
 final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback(); 
 // Request a NetworkCapabilities update; only the requesting callback is notified. // TODO: Delete this together with Connectivity{Manager,Service} code. 
 * {@link MATCH_PARENT}, or {@link WRAP_CONTENT}. 
 "Invalid height. Must be a positive value, MATCH_PARENT, or WRAP_CONTENT."); 
<|del|> 
 * * @param height Height of the popup window must be a positive value, * {@link MATCH_PARENT}, or {@link WRAP_CONTENT}. * 
 if (height < 0 && ViewGroup.LayoutParams.WRAP_CONTENT != height && ViewGroup.LayoutParams.MATCH_PARENT != height) { 
 "Height of the popup window must be a positive value: " + height); 
 /** from --target-sdk-version. */ int targetSdkVersion; 
 public void onRttInitiationFailure(Call call, int reason) {} 
 Message reply = mWsmAsyncChannel.sendMessageSynchronously(WifiManager.CONNECT_NETWORK, 0); 
<|del|> 
<|del|> 
<|del|> 
 private final int sendVcardListingXml( AppParamValue appParamValue, Operation op, int needSendBody, int size) { 
<|del|> 
 throw new RuntimeException("Error while parsing results directory", e); 
 * This class contains methods for managing IPsec sessions, which will perform kernel-space 
 public void test_newFileSystem$URI$Map$ClassLoader() throws Exception { 
 // Verify the Thread's classloader cannot load mypackage.MockFileSystem. try { Thread.currentThread().getContextClassLoader().loadClass( "mypackage.MockFileSystem"); fail(); } catch (ClassNotFoundException expected) {} 
 // Verify the Thread's classloader cannot load mypackage.MockFileSystem. try { Thread.currentThread().getContextClassLoader().loadClass( "mypackage.MockFileSystem"); fail(); } catch (ClassNotFoundException expected) {} 
 // Verify the Thread's classloader cannot load mypackage.MockFileSystem. try { Thread.currentThread().getContextClassLoader().loadClass( "mypackage.MockFileSystem"); fail(); } catch (ClassNotFoundException expected) {} 
 FileSystem fs = FileSystems.newFileSystem(stubURI, stubEnv, fileSystemsClassLoader); assertEquals("mypackage.MockFileSystem", fs.getClass().getName()); 
 FileSystem fs = FileSystems.newFileSystem(stubURI, stubEnv, fileSystemsClassLoader); assertEquals("mypackage.MockFileSystem", fs.getClass().getName()); 
 public void test_newFileSystem$Path$ClassLoader() throws Exception { 
 assertTrue( Math.abs(((float) timeElapsed / TIMEOUT) - 1) < 0.05); // Allow some error. 
 /// CHECK-START-ARM: long Main.$noinline$LongEqNonmatCond_LongVarVar(long, long, long, long) disassembly (after) /// CHECK: Select /// CHECK-NEXT: cmp {{r\d+}}, {{r\d+}} 
 } 
<|del|> 
import java.io.IOException; import java.util.Calendar; import java.util.concurrent.atomic.AtomicLong; 
 if (VERBOSE) { Log.v(TAG, "setPhonebookAccessPermission(ACCESS_REJECTED)=" + result); 
 * This implementation stores only enough ModuleResult information to return empty modules * of the correct ids (names and abis) upon {@link IInvocationResult}'s getModules() method. 
 results.add(new LightInvocationResult(result)); result = null; // ensure all references are removed to free memory 
 // How many times an APF program had an actual lifetime shoter than // APF_PROGRAM_EVENT_LIFETIME_THRESHOLD. 
 public void test_newFileSystem$Path$ClassLoader() throws Exception { 
 * The method creates a custom classloader for the mock FileSystem and FileSystemProvider * classes. The custom classloader is created by providing filesystemtest.jar which contains 
 Log.v(this, "onRttInitiationSuccess: %s", callId); 
 adapter.onRttInitiationFailure(callId, reason, Log.getExternalSession()); 
<|del|> 
<|del|> 
 radioProxy.sendDeviceState(rr.mSerial, stateType, state); 
 protected static final boolean DBG = false; /* STOPSHIP if true */ 
<|del|> 
 final IntentFilter filter = new IntentFilter(); 
 return mIsPowerSaveOn || (!mIsCharging && !mScreenState && !mIsTetheringOn); 
 return mIsPowerSaveOn || (!mIsCharging && !mIsTetheringOn && !mScreenState); 
 if (!shouldTurnOffSignalStrength()) { 
 if (newFilter != mUnsolicitedResponseFilter) { mLocalLog.log("old filter: " + mUnsolicitedResponseFilter + ", new filter: " + newFilter); 
 final PowerManager pm = (PowerManager) mPhone.getContext().getSystemService( 
 final BatteryManager bm = (BatteryManager) mPhone.getContext().getSystemService( 
 final PowerManager pm = (PowerManager) mPhone.getContext().getSystemService( 
 public void sendDeviceState(int stateType, boolean state, 
 ", ndpId=").append(ndpId).append(", peerDataMac=").append( 
 * status change, and when the update completes. A handler can be supplied * to control which thread runs the callback, or null. 
 /* Reset the flag */ mSdpInitiated = false; 
 protected final HashMap<Integer, Message> mPendingResponses = new HashMap<>(); 
<|del|> 
 synchronized (mPendingResponses) { mPendingResponses.put(key, msg); 
<|del|> 
 Message response = retrievePendingResponseMessage(msg.arg2); 
 mSelectedDevice = null; 
<|del|> 
<|del|> 
 Network getNetwork() { 
 super(msg + "(spi: " + spi + ")"); 
 public void releaseOutboundSpi(InetAddress remoteAddr, int spi) {} 
 * @throws IOException in the event that no more Transforms may be allocated 
 * that port. 
 * This class represents an IpSecTransform, which encapsulates both properties and state of IPsec. 
 * For direction-specific attributes of an IpSecTransform, indicates that an attribute applies * to traffic towards the host. 
 * For direction-specific attributes of an IpSecTransform, indicates that an attribute applies * to traffic from the host. 
 /** @hide */ public static final int ENCAP_NONE = 0; 
 * (of '0'-value bytes) that prevents traffic from being interpreted as IKE or as ESP over UDP. * * @hide 
 * @see Builder#buildTransportModeTransform(InetAddress) 
 * @see Builder#buildTransportModeTransform(InetAddress) 
 * * <p>If encryption is set for a given direction without also providing an SPI for that * direction, creation of an IpSecTransform will fail upon calling a build() method. * 
 * * <p>If authentication is set for a given direction without also providing an SPI for that * direction, creation of an IpSecTransform will fail upon calling a build() method. * 
 * * <p>Unless an SPI is set for a given direction, traffic in that direction will be * sent/received without any Ipsec applied. * 
 * @param intervalSeconds the maximum number of seconds between keepalive packets, no less * than 20s and no more than 3600s. 
 * IPsec tunnel. This is almost certainly an address belonging to the {@link Network} * that will originate the traffic, which is set as the {@link #viaNetwork}. 
 * @return the reserved SecurityParameterIndex * @throws ResourceUnavailableException indicating that too many SPIs are currently allocated for this user * @throws SpiUnavailableException indicating that a particular SPI cannot be reserved 
 public SecurityParameterIndex reserveOutboundSpi(InetAddress remoteAddr, int requestedSpi) throws ResourceUnavailableException { return new SecurityParameterIndex(mContext, remoteAddr, requestedSpi); 
 UserManager userManager = getApplicationContext().getSystemService(UserManager.class); if (!userManager.isPrimaryUser()) { 
 * Tests socket timeout behavior for various different socket types. 
 private static final int TIMEOUT_MILLIS = 500; 
 = new InetSocketAddress("192.0.2.0", 0); // RFC 5737 
 Math.abs(((float) timeElapsed / TIMEOUT_MILLIS) - 1) < 0.2); // Allow some error. 
 Math.abs(((float) timeElapsed / TIMEOUT_MILLIS) - 1) < 0.2); // Allow some error. 
 // TODO(yikong), http://b/35867657: // Add tests for SocksSocketImpl once a mock Socks server is implemented. 
 Log.i(TAG, "Handling user unlock before loading from store."); 
<|del|> 
 private Insn makeInvokePolymorphicInsn(Rop rop, SourcePosition pos, RegisterSpecList sources, TypeList catches, Constant cst) { CstMethodRef cstMethodRef = (CstMethodRef) cst; 
 private Insn makeInvokePolymorphicInsn(Rop rop, SourcePosition pos, RegisterSpecList sources, TypeList catches, Constant cst) { CstMethodRef cstMethodRef = (CstMethodRef) cst; 
 * @return the comment as a string. 
 * An instruction with multiple constant arguments in addition 
 RegisterSpecList registers, Constant[] constants) { 
 if (!hasIndex(position)) { throw new IllegalStateException("index not yet set for constant " 
 throw new IllegalStateException("index already set"); 
 throw new IllegalStateException("class index not yet set"); 
 * @param index {@code index >= 0;} the constant pool index of the class 
 throw new IllegalStateException("class index already set"); 
 for (int i = 0; i < m.getNumberOfConstants(); i++) { 
 private static void assignIndices(MultiCstInsn insn, DalvCode.AssignIndicesCallback callback) { 
 insn.setClassIndex(index); 
 if (rop.getBranchingness() != Rop.BRANCH_THROW) { throw new RuntimeException("Expected BRANCH_THROW got " + rop.getBranchingness()); } else if (!rop.isCallLike()) { throw new RuntimeException("Expected call-like operation"); 
 if (!unsignedFitsInShort(methodIdx) || !unsignedFitsInShort(protoIdx)) { 
 if (!(methodRef instanceof CstMethodRef)) { 
 if (!(protoRef instanceof CstProtoRef)) { 
 certCredential.setCertType(Credential.CertificateCredential.CERT_TYPE_X509V3); 
 boolean result = (resultMsg.arg1 == SUCCESS); 
 * href="https://tools.ietf.org/html/rfc3948">RFC3498</a>. * * @hide 
 * sent/received without any IPsec applied. 
 mConfig.encapType = ENCAP_ESPINUDP; mConfig.encapLocalPort = localSocket.getPort(); // TODO: plug in the encap socket 
 * created. Note, this should happen very rarely if the SPI is chosen to be sufficiently random * or reserved using reserveSecurityParameterIndex. 
 * created. Note, this should happen very rarely if the SPI is chosen to be sufficiently random * or reserved using reserveSecurityParameterIndex. 
 * @param destinationAddress SPIs must be unique for each combination of SPI and destination * address. Thus, the destinationAddress to which the SPI will communicate must be * supplied. 
<|del|> 
<|del|> 
 * @throws ResourceUnavailableException indicating that too many SPIs are currently allocated * for this user 
 return new SecurityParameterIndex(mContext, destinationAddress, requestedSpi); 
 * @param socket a socket that previously had a transform applied to it. 
 * the caller. This provides safe access to a socket on a port that can later be used as a UDP * Encapsulation port. 
 * @return a {@link UdpEncapsulationSocket} that is bound to the requested port for the lifetime * of the object. 
 * @return a {@link UdpEncapsulationSocket} that is bound to the requested port for the lifetime * of the object. 
 * Open a socket that is bound to a port selected by the system. 
 * the caller. This provides safe access to a socket on a port that can later be used as a UDP * Encapsulation port. 
 * sent/received without any IPsec applied. 
 * sent/received without any IPsec applied. 
 * IPsec operates at the IP layer, this 32-bit identifier uniquely identifies packets to a * given destination address. 
 * sent/received without any IPsec applied. 
 * @param spi a unique {@link IpSecManager.SecurityParameterIndex} to identify transformed * traffic 
 public IpSecTransform.Builder setUnderlyingNetwork(Network net) { 
 * Exception. 
 * user this operation will fail and throw ResourceUnavailableException. To avoid these * exceptions, unused Transform objects must be cleaned up by calling {@link * IpSecTransform#close()} when they are no longer needed. 
 * that will originate the traffic, which is set as the {@link #setUnderlyingNetwork}. * @param remoteAddress the {@link InetAddress} representing the remote endpoint of this * IPsec tunnel. 
 * that will originate the traffic, which is set as the {@link #setUnderlyingNetwork}. * @param remoteAddress the {@link InetAddress} representing the remote endpoint of this * IPsec tunnel. 
<|del|> 
 final String value = (query != null ? query.trim() : "") + "*"; 
 * access WifiNative. It starts with firmware roaming. TODO(b/34819513): Move operations * such as connection to network and legacy framework roaming here. 
 public boolean getFirmwareRoamingInfo() { 
 if (mFirmwareRoamingSupported) { return mMaxNumBlacklistBssid; } else { Log.e(TAG, "Firmware roaming is not supported"); return -1; } 
 mWifiConnectivityHelper.getFirmwareRoamingInfo(); assertTrue(mWifiConnectivityHelper.isFirmwareRoamingSupported()); 
<|del|> 
 * This will be consistent with the usage of the term "alias" in {@link WifiEnterpriseConfig}. 
 mNetworkSelector.selectNetwork(scanDetails, buildBssidBlacklist(), mWifiInfo, 
 BssidBlacklistStatus status = mBssidBlacklist.get(bssid); if (status == null) { // First time for this BSSID status = new BssidBlacklistStatus(); mBssidBlacklist.put(bssid, status); } 
 BssidBlacklistStatus status = mBssidBlacklist.get(bssid); if (status == null) { // First time for this BSSID status = new BssidBlacklistStatus(); mBssidBlacklist.put(bssid, status); } 
 if (status.isBlacklisted) { if (currentTimeStamp - status.blacklistedTimeStamp >= BSSID_BLACKLIST_EXPIRE_TIME_MS) { 
 if (bssidBlacklist.contains(scanResult.BSSID)) { 
 * or is a non-Passpoint network. 
 Log.d(TAG, "Filtering out " + numFilteredScanResults + " scan results."); 
 * <code>getTimeZone</code>. * @hide unsupported on Android 
 private boolean mIsScreenStateOn; 
 log("DeviceStateMonitor mIsPowerSaveOn=" + mIsPowerSaveOn + ",mIsScreenStateOn=" + mIsScreenStateOn + ",mIsCharging=" + mIsCharging, false); 
 private boolean mIsScreenState; 
 @RpcOptional String passphrase) { 
 private String mDeviceAndroidRootDir; private PathPair mTestRootDir; private PathPair mSystemDir; private PathPair mDataDir; 
 private String executeCommandOnDeviceRaw(String command) throws DeviceNotAvailableException { return getDevice().executeShellCommand(command); 
 private void createDeviceDirectory(PathPair dir) throws DeviceNotAvailableException { executeCommandOnDeviceRaw("mkdir -p " + dir.devicePath); 
 // throw new java.io.InterruptedIOException(); 
 // BEGIN Android-changed: Just wrap synchronization around Map.super implementations. // Upstream uses different overridden implementations. 
 mErrLog.err("% failed %") 
 mErrLog.i("Vendor Hal started successfully"); 
 mErrLog.i("Vendor Hal stopped"); 
 mErrLog.info("Driver: % Firmware: %").c(mDriverDescription).c(mFirmwareDescription).flush(); 
 try { // Resource loading involves a blocking operation and will throw a RuntimeException // here. 
 * Setup wifi native for Client mode operations. * * 1. Starts the Wifi HAL and configures it in client/STA mode. * 2. Setup Wificond to operate in client mode and retrieve the handle to use for client * operations. * 
 assertNotNull("Did not receive NetworkCallback#onAvailable for INTERNET", 
 assertNotNull("Did not receive NetworkCallback#onAvailable for INTERNET", 
 fail("NetworkCallback wait was interrupted."); 
 assertTrue("Did not receive NetworkCallback#onUnavailable", 
 fail("NetworkCallback wait was interrupted."); 
 return mUnavailableLatch.await(2, TimeUnit.SECONDS); 
 } catch (IllegalArgumentException e) { 
 // END Android-changed: lower buffer size. 
 Intent editIntent = new Intent(Intent.ACTION_EDIT, url); 
 FileUtil.recursiveDelete(resultsDir); 
 // Ensure that BoringSSL throws an exception if you try to manually trigger // SSL renegotiation, which is what we expect 
 fail(); } catch (SSLException expected) { 
 fail(); } catch (SSLException expected) { 
 private boolean updateBssidBlacklist(String bssid, boolean enable, int reasonCode) { 
<|del|> 
<|del|> 
 * can be thrown, although the exception is never thrown. Code compiled against a newer SDK does * not need to catch the exception and will be binary compatible with older versions of Android. 
<|del|> 
 int ta = gsm.GetCellSignalStrength().getTimingAdvance(); 
 static private final int WAIT_FOR_AWARE_CHANGE_SECS = 10; 
 mContext.registerReceiver(receiver, intentFilter); 
 IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED); 
 mContext.registerReceiver(receiver2, intentFilter); mWifiManager.setWifiEnabled(true); 
 assertTrue("Wi-Fi Aware is not available (should be)", mWifiAwareManager.isAvailable()); 
 assertTrue("Wi-Fi Aware is not available (should be)", mWifiAwareManager.isAvailable()); 
<|del|> 
 // // Upstream code was: // compare(key, key); // type (and possibly null) check 
 mContentObserver = observerCaptor.getValue(); 
<|del|> 
 return foundOptional.orElse(null); 
 * Test that enter does not log when verbose logging is not enabled 
 @Override 
 "https://acumos.org/to-be-determined", 
 * Used to call methods from BE project to mvnrepodao project which is a 
<|del|> 
<|del|> 
 "Apache 2.0 License", // License "http://www.apache.org/licenses/LICENSE-2.0"); // License URL 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Copyright (C) 2017 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 * Copyright (C) 2017 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
<|del|> 
<|del|> 
import java.io.Serializable; 
 /** * * * */ 
 }catch(Exception ex){ logger.error("--------- Exception in TOSCA Model Generator Client ----------- "+ex); 
 private static final long serialVersionUID = 4530782972295996554L; 
 private String temp; 
 private static final long serialVersionUID = 2155426559340261877L; /** * */ 
 private static final long serialVersionUID = -5121422162614046666L; 
 private static final long serialVersionUID = 3529235743112597750L; 
 private static final long serialVersionUID = 8483844197295612388L; 
 private static final long serialVersionUID = 7215402687596230670L; 
 private static final long serialVersionUID = 5973109889778398211L; 
 private static final long serialVersionUID = 5637513244290307708L; 
 private static final long serialVersionUID = -2733793486307877528L; 
 private static final long serialVersionUID = 2032008896009138659L; 
 } catch (Exception ex) { logger.error("Failed", ex); throw ex; 
 private String cmnDataSvcEndPoinURL = "http://cognita-dev1-vm01-core.eastus.cloudapp.azure.com:8002/ccds"; 
 private static final long serialVersionUID = 1136087024327606271L; 
 private static final long serialVersionUID = 565058291617565696L; 
 private static final long serialVersionUID = 1915608769079919859L; 
 private static final long serialVersionUID = -1288328507537289159L; 
 private static final long serialVersionUID = 4430756495417649713L; /** * */ 
 /** * */ private static final long serialVersionUID = -8446568394003104679L; 
 private static final long serialVersionUID = -972174523695525071L; /** * */ 
 private static final long serialVersionUID = -7383798315818998298L; 
 private static final long serialVersionUID = -1215951868789856113L; /** * */ 
 private static final long serialVersionUID = -2337142362506384973L; /** * */ 
 private static final long serialVersionUID = -4739084610588775205L; /** * */ 
 private static final long serialVersionUID = -7676525620761286343L; /** * */ 
 private static final long serialVersionUID = 3301990217162294096L; 
 FileReader fr = new FileReader(filePath); BufferedReader br = new BufferedReader(fr); 
 public String getSolutionErrorCode() { return solutionErrorCode; 
 private final String url = "http://cognita-dev1-vm01-core.eastus.cloudapp.azure.com:8000/ccds"; 
 } assertNotNull(strBuilder); if (strBuilder.length() > 1) { result = result + strBuilder.substring(0, strBuilder.length() - 1); } result = result + "]"; 
 private final String url = "http://cognita-dev1-vm01-core.eastus.cloudapp.azure.com:8000/ccds"; 
 repositoryLocation.setUrl("http://cognita_model_rw:not4you@cognita-nexus01.eastus.cloudapp.azure.com:8081/repository/repo_cognita_model_maven"); repositoryLocation.setUsername("cognita_model_rw"); 
 repositoryLocation.setUrl("http://cognita_model_rw:not4you@cognita-nexus01.eastus.cloudapp.azure.com:8081/repository/repo_cognita_model_maven"); repositoryLocation.setUsername("cognita_model_rw"); 
 } catch (ServiceException e) { logger.error(EELFLoggerDelegator.errorLogger,"------- Exception Occured in createNewCompositeSolution() --------"); throw e; 
 arti.setUri("fake.nexus.org/dcae/kpi_anomaly:1.0.0"); 
<|del|> 
<|del|>
 String user = "acumosdev"; 
<|del|> 
 private String asdcOperator = "admin"; 
 private static final long serialVersionUID = -5934864309832203668L; /** * 
 new Contact("Acumos Design Studio Composition Engine Team", "http://acumos.org", "DCE.someday@acumos.org"), // Contact "Apache 2.0", // License 
 new Contact("Acumos Design Studio Composition Engine Team", "http://acumos.org", "DCE.someday@acumos.org"), // Contact "Apache 2.0", // License 
 private static final EELFLoggerDelegator logger = EELFLoggerDelegator.getLogger(DSUtil.class); 
 private String url = ""; private String user =""; private String pass = ""; public static Properties CONFIG = new Properties(); 
 private static EELFLoggerDelegator logger = EELFLoggerDelegator.getLogger(ControllersTest.class); 
 private String url = ""; private String user = ""; private String pass = ""; public static Properties CONFIG = new Properties(); ICommonDataServiceRestClient client = null; 
 private static final EELFLoggerDelegator logger = EELFLoggerDelegator.getLogger(TGIFTest.class); 
 artifact.setNexusURI(nexusURI); artifact.setPayloadURI(payloadURI); 
<|del|> 
 new Contact("Acumos Team", // name "https://acumos.org/to-be-determined", // URL "contact@acumos.org"), // email "Apache 2.0", // License "https://www.apache.org/licenses/LICENSE-2.0"); // License URL 
<|del|> 
 * Copyright (C) 2017 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 fr.close(); 
 FileReader fr = new FileReader(filePath); Object obj = parser.parse(fr); 
 @Override public long getThreadCommentCount(String threadId) { 
 @Override 
 long getThreadCommentCount(String threadId); 
 if (null == this.clients.getClient().getUser(this.env.getProperty("federation.operator"))) { 
 protected EELFLoggerDelegate log = EELFLoggerDelegate.getLogger(getClass().getName()); 
 logger.warn(EELFLoggerDelegate.errorLogger, "Failed to setup source watcher for " + theSource, iox); 
<|del|> 
<|del|> 
 private static final EELFLoggerDelegate logger = EELFLoggerDelegate.getLogger(AdminServiceControllerTest.class); 
 char [] longCommentChars = new char[8193]; for (int i = 0; i < longCommentChars.length; ++i) longCommentChars[i] = 'x'; String longCommentString = new String(longCommentChars); 
 * Finds solutions that match every specified condition. Special-purpose method * to support the dynamic search page on the portal interface. 
<|del|> 
 log.error(EELFLoggerDelegate.errorLogger, "Exception Occurred while Sending Mail to user ={}", e); 
 log.error(EELFLoggerDelegate.errorLogger, "Exception Occurred while Sending Mail to user ={}", e); 
 * available criteria in CDS. 
 * @param theArtifactId identifier of the acumos artifact whose content * needs to be retrieved 
 * Provides the information for the 'self' peer. Needs to avoid the * 'chicken,egg' problem: one needs a context to access peers, including the * 'self' peer. Strictly an internal service call. 
 /** * Gets a page of step results. * * @param pageRequest * Page index, page size, sort information; ignored if null. * @return Page of step result objects. */ 
 * Model for a step result 
<|del|> 
<|del|>
 // no-arg constructor startDate = new Date(); 
public class MLPStepStatus extends MLPStatusCodeEntity implements Serializable { 
public class MLPStepType extends MLPTypeCodeEntity implements Serializable { 
 Boolean active = new Boolean(queryParameters.getFirst(CCDSConstants.SEARCH_ACTIVE)); 
 * @param stepResultId 
 * @param stepResultId 
 Iterable<MLPTag> findByTrackingId(@Param("trackingId") String trackingId); 
 sr.setStepCode(String.valueOf(StepTypeCode.OB)); 
 stepResultRepository.delete(sr.getStepResultId()); 
 * Model for subscription scope type, a code-name pair. 
<|del|> 
 private static final int port = 8080; private static final String userName = "cds_web_user"; private static final String password = "cds_web_pass"; 
<|del|> 
<|del|> 
public class MLPNotificationDeliveryMechanismType extends MLPCodeNamePair implements Serializable{ 
 CCDSConstants.USER_PATH + CCDSConstants.NOTIFICATION_PREF_PATH); 
public interface UserNotificationPreferenceRepository extends CrudRepository<MLPUserNotifPref, Long> { 
 } catch (ConstraintViolationException ex) { 
<|del|> 
<|del|> 
 private MLPUserNotifPref usrNotifPrefById = null; 
 * Like the subject of an email * @param msgSeverityCode * severity of the notification like high, medium or low 
<|del|> 
<|del|> 
<|del|>
 * This enum defines Acumos message severity type codes. 
<|del|> 
 public List<MLPUserNotifPref> getUserNotificationPreferences(String userId) { 
 @Override 
 * Returns solutions with a name or description that contains the search term. 
 * Gets a list of user notification preferences for the specified user. 
<|del|> 
<|del|> 
<|del|> 
 private UserNotificationPreferenceRepository notificationPreferenceRepository; 
 public Object createUserNotificationPreference(@RequestBody MLPUserNotifPref usrNotifPref, HttpServletResponse response) { 
 logger.debug(EELFLoggerDelegate.debugLogger, "deleteUserNotificationPreference: received {} ", userNotifPrefId); 
 notificationPreferenceRepository.delete(userNotifPrefId); 
 Iterable<MLPUserNotifPref> findByUserId(@Param("userId") String userId); 
 logger.error("testUserNotificationPreferences got response {}", ex.getResponseBodyAsString()); logger.error("testUserNotificationPreferences failed", ex); 
 * This code is defined by {@link org.acumos.cds.NotificationDeliveryMechanismCode} 
 * This code is defined by {@link org.acumos.cds.MessageSeverityCode} 
<|del|> 
<|del|> 
 logger.debug(message); 
 logger.debug(message); 
 logger.debug(ServiceException.CONNECTION_ERROR_CODE); 
 logger.error(" --------------- Exception Occured constructSubMessageBody() ---------", ex); 
 logger.error( " --------------- Exception Occured CreateProtoJson() when Reading the protobuf file and generating protobuf json--------------", 
 logger.error( " --------------- Exception Occured CreateProtoJson() when Reading the protobuf file and generating protobuf json--------------", 
 logger.error(" --------------- Exception Occured constructSyntax() --------------", ex); 
 logger.error(" --------------- Exception Occured costructMessage() --------------", ex); 
 logger.error(" --------------- Exception Occured constructInputMessage() --------------", ex); 
 logger.error("-------------- constructOutputMessage() end ---------------", ex); 
 logger.debug("-------------- constructconstructSubMessageBody() strated ---------------"); 
 logger.error("-------------- constructconstructSubMessageBody() end ---------------" + ex); 
 PR("Renounced"), // RM("Declined"); 
 RQ("Requested"), // RN("Renounced"), // DC("Declined"); 
 RQ("Requested"), // RN("Renounced"), // DC("Declined"); 
 RQ("Requested"), // RN("Renounced"), // DC("Declined"); 
 @Column(name = "SUBJECT_NAME", nullable = false, unique = true, columnDefinition = "VARCHAR(100)") 
 logger.info("main: successfully parsed configuration from environment {}", CONFIG_ENV_VAR_NAME); 
 " fetchProtoBufJSON() : Begin"); 
 logger.debug(EELFLoggerDelegator.debugLogger, " : {}", item.getStream()); 
 logger.error(EELFLoggerDelegator.errorLogger, "RuntimeException has came", e); 
 logger.error(EELFLoggerDelegator.errorLogger, "Failed to push image: {} ", throwable); 
 logger.info(EELFLoggerDelegator.applicationLogger, "start tagging image {0} in {1} as {2}", image, repository, tag); 
 logger.error(EELFLoggerDelegator.errorLogger, String.format("image '%s' not found ", image), e); 
 logger.debug(EELFLoggerDelegator.debugLogger," SolutionRevisonId for Version : {} ", solutionRevisionId); 
 e); throw new ServiceException(" Exception in insertCompositeSolution ", "222", "IOException in insertCompositeSolution"); 
 logger.error(EELFLoggerDelegator.errorLogger, " Exception in updateCompositeSolution ", e); throw new ServiceException(" Exception in insertCompositeSolution ", "222", "Exception in updateCompositeSolution"); 
 "6. Successfully created the artifact for the cdumpfile for the solution : {0} artifact ID : {1}" ,mlpSolution.getSolutionId(), mlpArtifact.getArtifactId()); 
 logger.error(EELFLoggerDelegator.errorLogger, " Exception Occured uploadFilesToRepository() ", e); throw new ServiceException(" Exception in updateSolnWithNewVersion() ", "222", "Exception Occured while uploadFiles To Repository"); 
 logger.debug(EELFLoggerDelegator.debugLogger, " setProbeIndicator() : Begin "); 
<|del|> 
<|del|> 
<|del|> 
 DSUtil.rmdir(new File(path+"org/")); 
 logger.debug(EELFLoggerDelegator.debugLogger, "Exception in createProtobufFile()"); 
<|del|>
 logger.error(EELFLoggerDelegator.errorLogger, "IOException while closing inputStream", e); throw new ServiceException("IOException while closing inputStream Exception in createProtobufFile()"); 
 logger.debug(EELFLoggerDelegator.debugLogger,"image : {0} : {1} uploaded successfully", imageTagName, tagId); 
 " Exception Occured in createNewCompositeSolution() ", e); throw new NoSuchElementException("Failed to create NewCompositeSolution"); 
 e); throw new ServiceException("Failed to read the CompositeSolution"); 
 logger.error(EELFLoggerDelegator.errorLogger, " Exception in getSolutionRevisions() ", e); throw e; 
 logger.error(EELFLoggerDelegator.errorLogger, " Exception in getListOfArtifacts() ", e); throw e; 
 arg.setRole("repeated"); 
 * Solution status; use true to find active solutions, false to find * inactive solutions. 
 cp = client.createPeer(new MLPPeer("another peer name", "subj name", "api url", false, false, "contact 2", PeerStatusCode.DC.name(), ValidationStatusCode.FA.name())); 
 URI uri = buildUri(new String[] { CCDSConstants.CODE_PATH, CCDSConstants.DEPLOY_PATH, CCDSConstants.STATUS_PATH }, null, null); 
 @RequestMapping(value = "/" + CCDSConstants.DEPLOY_PATH + "/" + CCDSConstants.STATUS_PATH, method = RequestMethod.GET) 
 public Object createValidationSequence(@PathVariable("sequence") Integer sequence, @PathVariable("valTypeCode") String valTypeCode, @RequestBody MLPValidationSequence valSeq, HttpServletResponse response) { logger.debug(EELFLoggerDelegate.debugLogger, "createValidationSequence: received object: {} ", valSeq); 
<|del|>
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|>
 log.error(EELFLoggerDelegate.errorLogger, "getZipFile failed", e); 
 log.error(EELFLoggerDelegate.errorLogger,"deserialize failed", e); 
 log.error(EELFLoggerDelegate.errorLogger, "getZipFile failed", e); throw e; 
 private static final EELFLoggerDelegate log = EELFLoggerDelegate.getLogger(ZipBrokerFileServiceImpl.class); 
 private Environment env; @Autowired 
 private final EELFLoggerDelegate log = EELFLoggerDelegate.getLogger(getClass().getName()); 
 log.error(EELFLoggerDelegate.errorLogger, uri + " failed" + ((response == null) ? "" : (" " + response)), x); 
 log.error(EELFLoggerDelegate.errorLogger, uri + " failed" + ((response == null) ? "" : (" " + response)), x); 
 log.error(EELFLoggerDelegate.errorLogger, uri + " unexpected failure.", t); 
 log.error(EELFLoggerDelegate.errorLogger, uri + " unexpected failure.", t); 
 log.error(EELFLoggerDelegate.errorLogger, uri + " failed" + ((response == null) ? "" : (" " + response)), x); 
 log.info(EELFLoggerDelegate.errorLogger, uri + " unexpected failure.", t); 
 log.error(EELFLoggerDelegate.errorLogger, uri + " failed" + ((response == null) ? "" : (" " + response)), x); 
 log.error(EELFLoggerDelegate.errorLogger, uri + " failed" + ((response == null) ? "" : (" " + response)), x); 
<|del|> 
 /** */ 
 private Clients clients; 
 private PeerService peerService; 
 private PeerService peerService; 
 log.debug(EELFLoggerDelegate.debugLogger, "getSolutions: cds solutions count {}", response.getSize()); 
 log.error(EELFLoggerDelegate.errorLogger, "Peer task failed for " + mlpPeer.getName() + ", " + mlpPeer.getApiUrl() + ", " + mlpSubscription.getSelector(), x); 
public class TaskConfiguration { 
 log.error(EELFLoggerDelegate.errorLogger, "Failed to setup mock", x); 
 log.info(EELFLoggerDelegate.debugLogger, "event: " + complete + "/" + listener.peerEventLatch.getCount()); 
 } catch (Exception x) { log.error(EELFLoggerDelegate.errorLogger, "Failed to retrieve revisions", x); 
 } catch (Exception x) { log.error(EELFLoggerDelegate.errorLogger, "Failed to retrieve artifacts", x); 
<|del|> 
<|del|> 
 private SuccessErrorMessage successErrorMessage = null; 
 private SuccessErrorMessage getResponseMessageStatus(String messagestatus, String messagedescription){ return new SuccessErrorMessage(messagestatus,messagedescription); } 
 private SuccessErrorMessage getResponseMessageStatus(String messagestatus, String messagedescription){ return new SuccessErrorMessage(messagestatus,messagedescription); } 
public class SuccessErrorMessage implements Serializable { 
 private String success = ""; private String errorMessage = ""; public SuccessErrorMessage() { 
 String[] dateMillis = getOptStringArray(CCDSConstants.SEARCH_DATE, queryParameters); // Only date is required 
 * A solution has exactly one owner. Unidirectional mapping. 
<|del|> 
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } 
<|del|> 
 log.info(EELFLoggerDelegate.debugLogger, "check peer {}", peer); 
 "peer {} no longer active, removing active tasks", peer); 
<|del|> 
 public MLPPeerGrpMemMap(MLPPeerGrpMemMap that) { this.created = that.created; 
 @Column(name = "CREATED_DATE", nullable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT '0000-00-00 00:00:00'") // REST clients should not send this property @ApiModelProperty(readOnly = true, value = "Set by system") 
 private Node currentNode; 
 logger.error("Cannot find docker info about the probe {}", probeContName); 
 } } 
 Blueprint blueprint = TaskManager.getBlueprint(); DockerInfoList dockerList = TaskManager.getDockerList(); 
 logger.error("Finding Connected to failed {}", e); 
 @ApiModelProperty(value = "UUID", example = "12345678-abcd-90ab-cdef-1234567890ab") 
 @ApiModelProperty(required = true, value = "Unique key", example = "site_config_key_1") 
 @ApiModelProperty(required = true, value = "User ID", example = "12345678-abcd-90ab-cdef-1234567890ab") 
 @ApiModelProperty(required = true, value = "User ID", example = "12345678-abcd-90ab-cdef-1234567890ab") 
 @Size(max = 36) @ApiModelProperty(example = "12345678-abcd-90ab-cdef-1234567890ab") 
 * Start date 
 @ApiModelProperty(required = true, example = "Classification") 
 @Column(name = "LAST_LOGIN_DATE") @ApiModelProperty(value = "Millisec since the Epoch", example = "1521202458867") 
 import org.acumos.cds.client.CommonDataServiceRestClientImpl; 
 * Java interface to ToscaLab python code 
 throw new Exception("Failed to load 'model_create.py' script"); 
 Assert.assertEquals(s3, m.getUserId()); 
<|del|> 
<|del|> 
 Assert.assertEquals(s3, m.getUserId()); 
 String serviceUrl = args[0]; String authUrl = args[1]; String modelType = args[2]; String path = args[3]; String modelName = args[4]; 
 if (args.length <= 5) { 
<|del|> 
<|del|> 
 JsonResponse<List<MLPSolution>> result = gatewayController.getSolutions(request, peerSubscription, response); Assert.assertNotNull(result); 
 JsonResponse<RestPageResponse<MLPSolution>> data = marketPlaceController.getUserAccessSolutions(userId, restPageReq); Assert.assertNotNull(data); 
 JsonResponse<MLPSolutionWeb> data = marketPlaceController.getAvgRatingsForSol(solutionId); Assert.assertNotNull(data); 
 JsonResponse data = userServiceController.updateUserImage(request, file, userId, response); Assert.assertNotNull(data); 
 private MessagingService messagingService; 
 JsonResponse<List<MLStepResult>> data = webBasedController.messagingStatus(userId, trackingId); Assert.assertNotNull(data); 
 protected OnboardingNotification onboardingStatus; 
 private ResourceLoader resourceLoader; 
<|del|> 
<|del|> 
 String imageTagName = dockerConfiguration.getImagetagPrefix() + File.separator + metadata.getModelName()+"_"+solutionID; 
<|del|> 
 logger.info(EELFLoggerDelegate.auditLogger, "login: No match for credentials for {}", login.getName()); 
 logger.info(EELFLoggerDelegate.auditLogger, "login: Successful login of {}", user.getLoginName()); 
<|del|> 
 logger.info(EELFLoggerDelegate.auditLogger, "updatePassword: Successful change of password for user {}", existingUser.getLoginName()); 
 String passwdNoMatch = "The old password did not match"; logger.info(EELFLoggerDelegate.auditLogger, passwdNoMatch+" for {}", existingUser.getLoginName()); 
 logger.info(EELFLoggerDelegate.auditLogger, "updatePassword: {} for user {}", passwdNoMatch, existingUser.getLoginName()); 
 DataMap dMap = new DataMap(); 
 if (node_type.equals(props.getDatabrokerType())) { 
 * Acumos Apache-2.0 
 * Provides the beans used in interactions with the local Acumos system 
 * Acumos Apache-2.0 
 * Acumos Apache-2.0 
 gatewayBuilder.child(FederationConfiguration.class) 
 public static interface Paths { 
<|del|>
<|del|> 
<|del|> 
<|del|>
<|del|> 
 logger.warn(EELFLoggerDelegate.debugLogger, "[Metadata Parsing] Modified Model name {} due to length more than 100 char : {}",newModelName ,modelNameLength); 
<|del|> 
 Assert.assertNotNull(mockImpl); 
 notificationController.getUserNotifPrefByUserId(request, userId, response); Assert.assertNotNull(notificationController); 
 MLUserNotifPref mlUserNotifPref = new MLUserNotifPref(); 
 MLUserNotifPref mlUserNotifPref = new MLUserNotifPref(); 
 MLUserNotifPref mlUserNotifPref = new MLUserNotifPref(); 
<|del|> 
 MLUserNotifPref mlUserNotifPref = new MLUserNotifPref(); 
 MLUserNotifPref mlUserNotifPref = new MLUserNotifPref(); 
 mlUserNotifPref.setNotfDelvMechCode("EM"); Assert.assertNotNull(mlUserNotifPref); 
 public static final String portal_feature_email_from = "portal.feature.email.from"; 
 public static final String portal_feature_email_from = "support@acumos.org"; 
 data.setResponseDetail("Exception occured while sending user notification"); response.setStatus(HttpServletResponse.SC_BAD_REQUEST); 
<|del|> 
<|del|> 
 log.info("inside finallly callOnboarding ---->>>"); //notificationService.generateNotification(notification, userId); 
 @Autowired private MailService mailservice; 
<|del|>
<|del|> 
 private Long refreshInterval; private String selector; private boolean onboardingStatusFailed; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 PJ("PROTOBUF FILE"); 
<|del|> 
 logger.debug("generateNotification End"); 
 public void putContainerDetailsJSONProbe(DockerInfoList dockerList,String apiUrl)throws Exception{ logger.debug("putContainerDetailsJSON Start"); 
 public void putBluePrintDetailsJSON(Blueprint bluePrint,String apiUrl)throws Exception{ logger.debug("putBluePrintDetailsJSON Start"); 
 logger.debug("apiUrl "+apiUrl); logger.debug("UrlAttribute "+deployDataObject.getUrlAttribute()); logger.debug("JsonMapping "+deployDataObject.getJsonMapping()); logger.debug("JsonPosition "+deployDataObject.getJsonPosition()); 
<|del|> 
 throw e; 
 log.debug(" start deploymentImageVM PULL_IMAGE " + PULL_IMAGE); 
<|del|> 
<|del|> 
 public void putContainerDetailsJSON(DockerInfoList dockerList,String apiUrl) throws Exception{ logger.debug("putContainerDetailsJSON Start"); 
 try { int sleepTimeFirstInt=Integer.parseInt(sleepTimeFirst); int sleepTimeSecondInt=Integer.parseInt(sleepTimeSecond); 
 envSecondaryServicePrincipal = System.getenv(AzureClientConstants.AZURE_AUTH_LOCATION); 
 throw e; 
 throw e; 
 log.debug(" Setting dockerHostIP " + dockerHostIP); 
 private CSVDatabrokerService service; 
 logger.error(EELFLoggerDelegator.errorLogger, "Error while updating ResultsetSize", e); response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED); 
 protobuf = ProtobufService.getInstance().getProtobuf(); 
//@RequestMapping(value = "/") 
 private CSVDatabrokerService service; 
 logger.error(EELFLoggerDelegator.errorLogger, "Error while setting Environment configuration", e); response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED); 
 public Object getProtobufFormattedData(@RequestParam(value="messageName", required=true) String messageName, @RequestParam(value="InputData", required=true) String input, HttpServletResponse response){ 
<|del|> 
 */ @ResponseStatus(HttpStatus.EXPECTATION_FAILED) 
public interface CSVDatabrokerService { /** * This methods writes line by line data to the OutputStream passed as the input parameter * @param out * @throws ServiceException * @throws IOException */ 
 private final EELFLoggerDelegator logger = EELFLoggerDelegator.getLogger(CSVDatabrokerServiceImpl.class); 
<|del|> 
 } catch (Exception e) { logger.error(EELFLoggerDelegator.errorLogger, "No environment configuration found!!", e); 
public interface Constants { 
<|del|> 
 public static void writeDataToFile(String path, String fileName, String extension, String data) throws IOException { 
 public static boolean isValidJsonSchema(String filePath) throws IOException { String jsonString = readFile(filePath); 
<|del|> 
<|del|>
 logger.error(EELFLoggerDelegator.errorLogger, "Exception in connect()", e); throw new ServiceException("Not able to Connect Remote server ","401", "Not able to Connect Remote server "); 
 logger.error(EELFLoggerDelegator.errorLogger, "Exception in createshellFile()", e); throw new ServiceException("Not able to create shell File ","401", "Not able to create shell File"); 
 logger.error(EELFLoggerDelegator.errorLogger, "Exception in executeShell()", e); 
 logger.error(EELFLoggerDelegator.errorLogger, "Exception in executeShell()", e); throw new ServiceException("Not able to execute shell File ","401", "Not able to execute shell File"); 
 private CSVDatabrokerService service; 
<|del|> 
<|del|> 
 private CSVDatabrokerService service; 
<|del|>
 "https://www.apache.org/licenses/LICENSE-2.0"); // License URL 
<|del|> 
 logger.debug(EELFLoggerDelegator.debugLogger,"mapData : End"); 
 private static final String FIELD_MAPPING_FILE_NAME = "classpath:FieldMapping.json"; 
 public OutputStream mapData(InputStream inputStream) throws Exception { 
 logger.error(EELFLoggerDelegator.errorLogger, "Error in mapData could not process successfully !!!", e); throw e; 
<|del|> 
 public void setType(String type) { 
<|del|> 
<|del|> 
<|del|> 
 public void mapData() throws Exception { 
 @Test(expected = IOException.class) public void mapDataTestException() throws Exception { 
 logger.debug(EELFLoggerDelegator.debugLogger,"Could not load test resource: " + testResource ); 
 response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); result = new Result(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Error while updating ResultsetSize"); 
 @ApiOperation(value = "Get resultset offset.", response = Integer.class) 
 @ApiOperation(value = "Get the .proto file", response = String.class) 
<|del|> 
 response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); result = new Result(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Error while setting Environment configuration"); 
 response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return new Result(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "No Data Found !!!"); 
 @Autowired @Qualifier("ProtobufServiceImpl") private ProtobufService protoService; @ApiOperation(value = "Convert input data to protobuf format", response = Byte.class) 
 response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return new Result(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Failed to convert to protobuf format data !!!"); 
 response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return new Result(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Failed to convert the protobuf data !!!"); 
 private Object param; 
@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) 
 * @param out * OutputStream parameter to write output to. 
 * @return byte[] * Return the date in the from of byte[] 
 public Configuration getConf() throws CloneNotSupportedException; 
 throw new ServiceException("Not able to Connect Remote server ","401", "Not able to Connect Remote server ", e); 
 throw new ServiceException("Not able to create shell File ","401", "Not able to create shell File", e); 
 throw new ServiceException("Not able to execute shell File ","401", "Not able to execute shell File", e); 
 throw new ServiceException("Not able to execute shell File ","401", "Not able to execute shell File", e); 
 throw new ServiceException("No environment configuration found! Please set the Environment configuration.","401", "Exception in writeDataTo()", e); 
 throw new ServiceException("No environment configuration found! Please set the Environment configuration.","401", "Exception in getData()", e); 
 throw new ServiceException("Not able to Connect Remote server ","401", "Not able to Connect Remote server ", e); 
 throw new ServiceException("Not able to execute shell File ","401", "Not able to execute shell File", e); 
<|del|> 
 logger.info("Successfully created notification " + notf); Assert.assertNotNull(notf); 
<|del|> 
 if (lastResult.getStatusCode().equals(STEP_SUCCESS)) { 
 logger.debug(EELFLoggerDelegator.debugLogger, " setProbeIndicator() : End "); 
 logger.audit(beginDate, "getSolutionGroups {}", pageRequest); 
 logger.audit(beginDate, "getPeerGroups {}", pageRequest); 
 logger.audit(beginDate, "getHealth"); 
 logger.audit(beginDate, "deleteRoleFunc roleId {} funcId {}", roleId, functionId); 
 public String getSolutionErrorDescription() { 
 public String createNewCompositeSolution(String userId) throws AcumosException { 
 public String createNewCompositeSolution(String userId) throws AcumosException { 
 logger.audit(beginDate, "createUserNotificationPreference: userNotifPrefId {}", usrNotifPref.getUserNotifPrefId()); 
 logger.info("httpGet(): GET Response Code ::" + responseCode); 
 output3 = httpGet(db_url); 
 logger.error("putDockerInfo: Need Docker Information... Exiting"); 
 logger.error("putDockerInfo: Cannot find docker info about the data broker {}", dataBrokerContName); dbresults.put("status", "error"); 
 logger.error("putDockerInfo: Cannot find docker info about the data broker {}", dataBrokerContName); dbresults.put("status", "error"); 
 logger.error("putDockerInfo: Empty blueprint JSON"); 
 if (nd.getNodeType().equalsIgnoreCase(DATABROKER)) { 
<|del|> 
<|del|> 
 logger.error("notifyNextNode: Finding connected to failed {}", e1); 
 logger.error("notifyNextNode: Contacting probe failed - ", e); 
 logger.info("contactProbe: Thread {} : Notifying probe: {}, POST: {}, proto uri: {} , message Name: {}", 
 logger.error("contactnode: Contacting node failed - ", e); 
 logger.info("contactDataBroker: Thread " + Thread.currentThread().getId() + " : " + output3.length + 
 // make a GET request to the databroker and receive response 
 if(in != null) in.close(); 
<|del|> 
 assertNotNull(conf); 
 Protobuf result = protobufServiceImpl.getProtobuf(); assertNotNull(result); 
 Integer timeout = Integer.parseInt(env.getProperty("jwt.auth.timeout")); expirationDate = new Date(createdDate.getTime() + timeout); 
<|del|> 
 List<MLPSolution> mlpSolutions = null; List<MLPArtifact> mlpArtifact = null; 
 logger.debug(EELFLoggerDelegator.debugLogger," CommonDataService returned empty Solution Revision list "); 
 private String parameter_type; private String parameter_tag; 
 private String parameter_tag; private String parameter_name; private String parameter_type; private String mapped_to_field; private String error_indicator; 
 // Design Studio Back-End ResultVO 
 ServiceContext theContext) throws ServiceException { 
 private static final EELFLoggerDelegate log = EELFLoggerDelegate.getLogger(MethodHandles.lookupClass()); 
 PullImageResultCallback pullResult = new PullImageResultCallback(); 
 depoutput2 = contactnode(depoutput, depurl, depcontainername); 
 throws Exception { 
<|del|>
 private static List listOfSockeTimoutModels = null; 
<|del|> 
 // 3. get the Relations(Links) from cdump file and collect the SourceNodeId and TargetNodeId and add those to set 
 HashSet<String> nodeIdSet = new HashSet<String>(); if (null != relationsList) { HashSet<Relations> relationsSet = new HashSet<Relations>(relationsList); 
<|del|> 
 * getBinaryJSON converts the uploaded json file based on the default.proto 
 logger.error("getJsonBinary_: Failed getting binary stream inputs:", ex); 
<|del|>
 logger.error("getInputMessageBuilder: needs to specify operation"); return null; 
 @ApiOperation(value = "Gets the output of the model in protobuf format.") 
 @ApiOperation(value = "Gets the output of the model in protobuf format.") 
 private String validationStatusCode; 
 "5. Successfully uploaded the Cdump file for solution ID : " + mlpSolution.getSolutionId()); 
 CommonDataServiceRestClientImpl cdmsClient = (CommonDataServiceRestClientImpl) CommonDataServiceRestClientImpl.getInstance( 
 public void getRestClient(String url, String user, String pass) { cmnDataService = new CommonDataServiceRestClientImpl(url, user, pass); 
 public String createNewCompositeSolution(String userId) { 
<|del|> 
<|del|> 
 * CDS based implementation of PeerSubscriptionService. 
<|del|> 
/** * Infrastrcture code for mocking underlying REST calls, such in the case of CDS api calls. 
 /** * Derived classes should use this to register mock responses. */ 
 /** * Use to register a mocked http request/response. */ 
 throw new IOException("Mock unhandled " + key); 
 throw new IOException("Failed to load mock resource " + resource); 
 logger.error("DatasourceController failed. Error while setting Environment configuration.", e); 
 logger.error("DatasourceController failed. Failed to convert to process data.", e); 
 private List<? extends MLPDocument> documents; private MLPRevisionDescription description; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 containerBP.setName(DockerKubeConstants.BLUEPRINT_CONTAINER); containerBP.setImage(dBean.getBluePrintImage()); 
 return baos.toByteArray(); 
 * @return Count of threads for specified solution and revision 
 * Copyright (C) 2017 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 PE("Pending"), // AP("Approved"), // DE("Declined"), // WD("Withdrawn"); 
<|del|> 
 logger.info("createDocument entry"); 
 @Column(name = "SOLUTION_ID", nullable = false, columnDefinition = "CHAR(36)") @NotNull(message = "SolutionID cannot be null") 
 @Size(max = 32) 
 logger.info("main: successfully parsed configuration from environment {}", CONFIG_ENV_VAR_NAME); 
 * @param solutionId * Solution ID 
 * This method will populate PublicModelCache For MatchingModels 
 * This method will remove PublicModelCache For MatchingModels 
 * This method will get the Public DSModels 
 * This method will populate PrivateModelCache For MatchingModels 
 logger.debug(EELFLoggerDelegator.debugLogger, "MLPUSer {} ", mlpUser); 
 logger.debug(EELFLoggerDelegator.debugLogger, "MLPUSer {} ", mlpUser); 
 * This method will get PrivateModelCache 
 * This method will set UserPrivateModelCache 
 * This method will get UserPrivateModelUpdateTime 
 * This method will set UserPrivateModelUpdateTime 
 * Gathers all CDS connectivity related parameters. Allows one to construct a cds client based on the * given parameters routing its requests through the local interface of the gateway. 
 * Copyright (C) 2018 AT&T Intellectual Property. All rights reserved. 
<|del|> 
 public List<DatasetModel> getDataSetList(@RequestParam(TEXT_SEARCH) String textSearch, @RequestParam(SEARCH_KEYS) DataSetSearchKeys datasetSearchKeys) { 
 ApiInfo apiInfo = new ApiInfo("Acumos Dataset REST API", 
 new Contact("Acumos Dev Team", "http://acumos.org", "noreply@acumos.org"), // Contact 
<|del|> 
<|del|> 
 // 3. get the Relations(Links) from cdump file and collect the // SourceNodeId and TargetNodeId and add those to set 
 logger.debug("getData() : Succesfully Executed Test case"); 
 logger.debug("getData() : Succesfully executed Test case"); 
 /** * Saves catalog object to the database. */ 
 private static final String REALM_NAME = "Acumos-DataStreamer"; 
 return new ApiInfo("Acumos DataStreamer Service REST API", // title 
 new Contact("Acumos DataStreamer Service Team", // name "http://acumos.readthedocs.io/en/latest/submodules/common-data-streamer/docs/", // URL 
 new Contact("Acumos DataStreamer Service Team", // name "http://acumos.readthedocs.io/en/latest/submodules/common-data-streamer/docs/", // URL 
 /** * @author sg453d * */ 
 private final String authorization = env.getProperty("basic.authorization"); 
 /** * Publishes the data received from the predictor. */ 
 "noreply@acumos.org"), // Contact 
<|del|> 
<|del|> 
 ds.setDriverClassName(DatabrokerConstants.MYSQLCLASSNAME); } else if (DatabrokerConstants.ORACLECLASSNAME.equals(conf.getDataSourceClassName())) { 
 * This method converts the ASCII data (input line) into protobuf binary format. 
 * This method converts the ASCII data (input line) into protobuf binary format for the specified message name. 
 * This method reads the protobuf binary formatted data (i.e., line) into specified message. 
 userService.refreshApiToken(user.getUserId()); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Launcher for the data-streamer catalog service Spring-Boot app. 
<|del|> 
 "https://www.apache.org/licenses/LICENSE-2.0", vendorExtensions); // vendor extensions 
 if (objCatalog.getCategory().equalsIgnoreCase(DMAAP)) catalogBuilder.append(CATEGORY, DMAAP); else if (objCatalog.getCategory().equalsIgnoreCase(MSG_ROUTER)) catalogBuilder.append(CATEGORY, MSG_ROUTER); 
<|del|> 
<|del|> 
<|del|>
 * Saves catalog object to the database. * @param authorization * @param codeCloudAuthorization * @param objCatalog * @return 
 log.error("Error in RestCatalogService:saveCatalog:" +e.getMessage()); 
 } catch (Exception e) { log.error("Exception in RestCatalogServiceImpl:updateCatalog" +e.getMessage()); 
 log.error("Exception in RestCatalogServiceImpl:updateCatalog" +e.getMessage()); 
 log.error("Exception in RestCatalogServiceImpl:getCatalog" +e.getMessage()); 
 log.error("Exception in RestCatalogServiceImpl:getCatalogs" +e.getMessage()); 
 log.error("Exception in RestCatalogServiceImpl:deleteCatalog" +e.getMessage()); 
<|del|> 
<|del|> 
 public String saveCatalog(String user, String authorization, String codeCloudAuthorization, CatalogObject objCatalog) throws IOException, DataStreamerException; 
 predictorUrl+ DataStreamerCatalogUtil.getEnv(PREDICTOR_SCORING_URL_SUFFIX, DataStreamerCatalogUtil.getComponentPropertyValue(PREDICTOR_SCORING_URL_SUFFIX))); 
 if(objCatalog.getCategory().equalsIgnoreCase(DMAAP)) { String subscriberUrl = DataStreamerCatalogUtil.getEnv(STREAMER_BASE_URL, DataStreamerCatalogUtil.getComponentPropertyValue(STREAMER_BASE_URL)) + catalogKey; 
 EELFResourceManager.loadMessageBundle(LOGMESSAGES); 
 "https://www.apache.org/licenses/LICENSE-2.0",vendorExtensions); // vendor extensions 
@Api(value = "Streamer") 
<|del|> 
 * Does data operation based on the data received from the files through the * datastreamer project. * @param authorization * @param feedAuthorization * @param catalogKey * @param fileName * @param attachedFiles * @return 
<|del|> 
 } catch (IOException ioe) { 
 /** * Does receive data operation based on the data received from the files through the attachment. */ 
<|del|> 
 log.error("ConsumerServiceImpl::operateData()::Encountered error while generating file name :" 
 log.error("ConsumerServiceImpl::operateData()::Encountered error while preparing URL for predictor"); 
<|del|> 
 } catch (IOException | DataStreamerException e) { log.error("MessageRouterTask::getPredictDetails()::Encountered error while fetchng details of predictor :"); 
 } catch (Exception e) { log.error("Exception in PublisherImpl:loadredir()" +e.getMessage()); 
 } catch (Exception e) { log.error("Exception in PublisherImpl:saveredir()" +e.getMessage()); 
<|del|> 
 * Publishes the data received from the predictor to the data router. 
 uc.setRequestMethod(PUT); uc.setRequestProperty(EXPECT, _100_CONTINUE); 
 pubid = uc.getHeaderField(X_ATT_DR_PUBLISH_ID); 
 uc.setRequestMethod(PUT); uc.setRequestProperty(EXPECT, _100_CONTINUE); 
 pubid = uc.getHeaderField(X_ATT_DR_PUBLISH_ID); 
 log.error("Error publishing file id " + fid); 
<|del|> 
<|del|> 
 finally { if(null != fileInputStream){ fileInputStream.close(); } } 
 } catch (Exception e) { log.error("Issue in handling Http response from HTTP response. " + e.getMessage()); 
 log.info("Issue while creating kerberosKeyTab: " + e.getMessage()); 
 log.error("Exception to save metadata : " + e.getMessage()); 
 log.info("Exception occurred while writing kerberos info to the file: " + e.getMessage()); 
 * @param authorization * basic authorization header value * @param codeCloudAuthorization * codeCloudAuthorization header value * @param objCatalog * new Catalog object which is created * @return status of saved Catalog Object. 
 log.error("Error in saveCatalog:",e); 
 * @param user * user details from the request 
<|del|> 
<|del|> 
<|del|>
 log.error("getPredictDetails()::Encountered error while fetchng details of predictor :",e); 
 log.error("Exception in loadredir()" +e); 
 } catch (Exception e) { log.error("Error in publish:"+e ); 
 public String receiveData(String user, String authorization, String feedAuthorization, 
 log.error("Error in publish:",e ); 
 private static final String X_DR_PUBLISH_ID = "X-DR-PUBLISH-ID"; 
<|del|> 
<|del|> 
 logger.info("Update peer : " + peerRes.getResponseBody()); Assert.assertNotNull(peerRes); 
 Assert.assertEquals(counts.get(peerId), subCount); 
 logger.error("Exception while fetching subscription counts", e); 
<|del|> 
<|del|> 
 private RestCatalogServiceImpl service; 
<|del|> 
<|del|> 
<|del|> 
 public String saveCatalog(String user, String authorization, String codeCloudAuthorization, CatalogObject objCatalog) 
 logger.debug("Records:" + sb.toString()); 
 props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); 
<|del|> 
 private MessageRouterTask messageRouterTask; 
<|del|> 
 log.info("Schedule job end"); 
 private Environment env; 
 private DataStreamerUtil dataStreamerUtil; 
<|del|> 
<|del|> 
 private final String authorization = env.getProperty(BASIC_AUTHORIZATION); 
<|del|> 
 log.error("MessageRouterTask::getPredictDetails()::Encountered error while fetchng details of predictor :"); 
 Mockito.when(mockAsync.sendTrackerNotification(uuid, userId, message)).thenReturn(step); 
 version = classPath.startsWith("jar") ? Application.class.getPackage().getImplementationVersion().split("-b")[0]:"0.0.0"; 
 version = "0.0.0"; 
 logger.warn("addPeerToGroup: failed on group ID {}", groupId); 
 logger.debug("searchPublishRequests enter"); 
 logger.warn("searchPublishRequests missing query"); 
<|del|> 
 logger.warn("getRevisionsForArtifact failed on ID {}", artifactId); 
 logger.debug(EELFLoggerDelegate.debugLogger, "update: received object: {} ", sd); 
 if (count == null) { logger.warn("updateSolutionDownloadStats failed on ID {}", solutionId); } else { 
 if (count == null || avg == null) { logger.warn("updateSolutionRatingStats failed on ID {}", solutionId); } else { 
 MDC.put(MDCs.SERVER_FQDN, "put.your.host.name.here"); 
 public static final String REQUEST_ID = "RequestID"; 
 /** Marker reporting invocation. */ public static final Marker INVOKE_RETURN = MarkerFactory.getMarker("INVOKE_RETURN"); 
 /** MDC correlating messages for a logical transaction. */ public static final String REQUEST_ID = "X-ACUMOS-RequestID"; 
<|del|> 
<|del|> 
 /** * This method parse the data and returns the Protobuf 
 /** * This method parse the input protobuf message * * @param messageStr * input as string format * * @return ProtobufMessage * converts and returns the ProtobufMessage. */ 
 try { new URI(uri); } catch (URISyntaxException ex) { throw new IllegalArgumentException(ex); } 
<|del|> 
 /** * MDC name constants. */ 
<|del|> 
 /** * Method to fetch the co-brand logo * * @return picture data w/ mime type information */ 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 public static final String KEY_TERMS_CONDITION = "global.termsCondition"; public static final String KEY_COBRAND_LOGO = "global.coBrandLogo"; public static final String KEY_CONTACT_INFO = "global.footer.contactInfo"; 
 private SiteContentServiceImpl siteContentService; 
 logger.error("Failed to execute getSolutionImage testcase", e); 
 logger.error("Failed to execute getSolutionImage404 testcase", e); 
 log.trace(EELFLoggerDelegate.debugLogger, "getSolutionRevisions"); 
 /** * Get the normalized URL for the nexus content server. * @return the URL, as a String, with exactly one trailing slash. */ 
<|del|> 
 System.out.println("dockerClient=" + client); RemoveImageCmd removeImageCmd = client.removeImageCmd(imageFullName).withForce(true); 
 @Column(name = "VERSION", nullable = false, columnDefinition = "VARCHAR(25)") @NotNull(message = "Version cannot be null") 
 @Column(name = "NOTEBOOK_TYPE_CD", nullable = false, columnDefinition = "CHAR(2)") @NotNull(message = "Notebook type cannot be null") 
 @ApiModelProperty(required = true, value = "Free-text version string", example = "v1.0") 
 @ApiModelProperty(required = true, value = "Two-character notebook type code", example = "AB") 
 @ApiModelProperty(required = true, value = "Two-character kernel type code", example = "AB") 
 logger.warn("addProjectNotebook: failed on notebook ID {}", notebookId); 
 logger.warn("addProjectPipeline: failed on pipeline ID {}", pipelineId); 
 * Unmaps the specified reference from the specified right-to-use. 
 @ApiOperation(value = "Gets a page of solutions in the specified catalogs, optionally sorted; empty if none are found.", // 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
@EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class}) 
<|del|> 
 @Override 
 @Value("${cmndatasvc.cmndatasvcendpointurl}") private String cmndatasvcendpointurl; 
<|del|> 
 private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
<|del|> 
 private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 final String springApplicationJson = System.getenv(CONFIG_ENV_VAR_NAME); //TODO : Add springApplicationJson validation code and log the error if any. 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 } else if (name.toLowerCase().contains(".proto")) { 
public class ProjectServiceImpl implements ProjectService { 
public class ProjectValidationServiceImpl implements ProjectValidationService { 
<|del|> 
<|del|> 
 log.info("Content: {}", content); 
 private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 default: logger.error("unimplemented license workflow {}", workflow); 
 * License Manager Client Unit tests * - Test creation of the RTU and RTU references * - Test reading and verifying license/right to use exists. 
<|del|>
<|del|>
<|del|> 
 protected static final String APPLICATION_JSON = MediaType.APPLICATION_JSON_UTF8_VALUE; protected static final String APPLICATION_OCTET_STREAM = MediaType.APPLICATION_OCTET_STREAM_VALUE; 
 log.error("Exception occurred during peer " + peerId + " " + opname, x); 
 * available criteria in CDS. 
 /** * Checks the check if a workflow should proceed, based upon the admin * requirements for verification related to that workflow, and the status of * verification for a solution/revision. * * @return Object with workflow */ 
 logger.debug("revisionId:: {}", revisionId); logger.debug("worflowId:: ()", worflowId); 
 logger.debug("securityVerificationApiUrl {}",securityVerificationApiUrl); 
 private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 logger.debug(" parseCdumpJsonFile in ParseJSON Start"); 
 throw new Exception(e); 
 logger.debug("jsonString::: {}",jsonString); logger.debug("jsonString.length::: {}",jsonString.length()); 
 /**This method makes call to license_scan and dump_model shell for security verification. * @param solutionId * @param revisionId * @return string * @throws Exception */ 
 public String createSiteConfig() { 
@EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class}) 
 private LoggingHandlerInterceptor loggingHandlerInterceptor; 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 PSLoggingAdapter psLoggingAdapter = new PSLoggingAdapter( 
 final PSLoggingAdapter psLoggingAdapter = new PSLoggingAdapter( 
 private InputValidationService inputValidationService; 
 private ProjectValidationService projectValidationService; 
 private InputValidationService inputValidationServiceImpl; 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
@EnableAutoConfiguration 
 private ConfigurationProperties confProps; 
@RequestMapping(value = "/") 
 private InputValidationService inputValidationService; 
 private NotebookValidationService notebookValidationService; 
 private NotebookService notebookService; 
 public ResponseEntity<?> createNotebookUnderProject( @PathVariable("authenticatedUserId") String authenticatedUserId, @PathVariable("projectId") String projectId, @RequestBody Notebook notebook) { 
<|del|> 
 private Notebook getNotebok(RuntimeException ex) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public Notebook archiveNotebook(String authenticatedUserId, String projectId, String notebookId, String actionType); 
 private CommonDataServiceRestClientImpl cdsClient; 
 private ConfigurationProperties confprops; 
 logger.debug("isEmptyOrNullString()"); 
<|del|>
<|del|> 
 public ResponseEntity<Project> createProject(@ApiParam(value = "The Authenticated User Id",allowableValues = "")@PathVariable("authenticatedUserId") String authenticatedUserId,@ApiParam(value = "Project") @RequestBody Project project) { 
 private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
<|del|> 
 fr.close(); 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
 private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
<|del|> 
 * Copyright (C) 2019 AT&T Intellectual Property & Tech Mahindra. All rights reserved. 
<|del|> 
 private static final String authenticatedUserId = "123"; 
 private InputValidationServiceImpl inputValidationServiceImpl; 
 private static final String authenticatedUserId = "123"; 
 private CommonDataServiceRestClientImpl cmnDataService; 
 private HandlerInterceptorConfiguration handlerInterceptorConfiguration; 
 private static final String authenticatedUserId = "123"; 
 protected static void addRtuRefs( final ICommonDataServiceRestClient dataClient, final ICreateRTURequest request, final MLPRightToUse rtu) { if (dataClient == null) { throw new IllegalArgumentException("dataClient was null, " + "expected value"); 
 * <p> * Wrapper method for updating the right to use. * Used primarily to log and capture any * {@link org.springframework.web.client.RestClientResponseException} * that is returned from the CDS client. * </p> 
 LOGGER.error("getRightToUses failed, server reports: {}", ex.getResponseBodyAsString()); 
 * <p> * CreateRTURequest class. * </p> 
<|del|> 
public class CreatedRtu implements ICreatedRtu { 
<|del|> 
 * <p> * The output of the RTU creation process {@link ILicenseCreator}. * </p> 
<|del|> 
public interface ICreateRTURequest extends ICommonLicenseRequest { 
 public void validateNotebookInput(Notebook notebook) throws InvalidInputJSONException; 
 @Autowired private Properties props; 
 * Checks if Notebook with same name and type already exists in DB. 
 void notebookExists(String authenticatedUserId,String projectId, Notebook notebook) throws DuplicateNotebookException; 
 void validateNotebook(String authenticatedUserId, Notebook notebook ); 
 private InputValidationService inputValidationServiceImpl; 
 //TODO : Move method to workbench-common library module. 
 @Value("${cmndatasvc.endpointurl}") 
 @Value("${cmndatasvc.endpointurl}") 
 } public boolean validate(String value) { return this.pattern.matcher(value).matches(); } 
 logger.debug("Inside the addRevisionDocument {} size {} extension {} name {} ", name, size, extension, name); 
<|del|> 
 String[] cmd3 = { "bash", scriptFile, solutionId, revisionId, SVServiceConstants.SECURITY_SCAN + SVServiceConstants.BACKSLASH + folder }; 
 logger.debug(EELFLoggerDelegator.debugLogger," CommonDataService returned empty SolutionRevision list"); 
<|del|> 
<|del|> 
 response.addRtu(completeRtu); 
 response.addRtu(completeRtu); 
/** When making a request for a license RTU consolidating common functionality. */ 
/** When making a request for a license RTU consolidating common functionality. */ 
/** Verified that there is a right to use for specified userId and solutionID. */ 
 private static final long serialVersionUID = 3714073159231864295L; 
 private LicenseJsonValidationResults validate(final JsonNode node) throws LicenseJsonException { 
 private static final long serialVersionUID = -7896327154019469541L; 
 private static final String FILE_NAME = "/license-schema.schema.json"; 
 InputStream is = LicenseJsonSchema.class.getResource(FILE_NAME).openStream(); 
 final String userId = "dummyuserid"; 
 public final ResponseEntity<?> handleArchivedException(ArchivedException ex, WebRequest request) { Notebook notebook = getNotebokWithErroStatus(ex); return new ResponseEntity<Notebook>(notebook, HttpStatus.BAD_REQUEST); 
 Notebook notebook = getNotebokWithErroStatus(ex); 
 return new ResponseEntity<Notebook>(notebook, HttpStatus.SERVICE_UNAVAILABLE); 
 private static final String baseMsg = TargetServiceInvocationException.class.getSimpleName() + " : "; 
 LicenseJsonValidationResults results = null; try { results = validateLicenseJson(targetStream); targetStream.close(); } catch (Exception e) { throw new LicenseJsonException("could not convert string to bytes", e); } return results; 
 node = getObjectMapper().readTree(inputStream); } catch (Exception e) { 
<|del|> 
 Set<ValidationMessage> errors = schema.validate(node); LicenseJsonValidationResults results = new LicenseJsonValidationResults(); 
/** Result object containing the validation error messages. */ 
 logger.error("CDS - Create Pipeline"); 
 logger.error("CDS - Create Pipeline"); 
<|del|> 
<|del|> 
<|del|>
// TODO : Need to move to workbench-common library. 
 protected static void addRtuRefs(final ICreateRtu request, final MLPRightToUse rtu) { 
 // TODO : Need to move this into common library 
 public void pipeLineExists(String authenticatedUserId, String projectId, Pipeline pipeLine){ 
 logger.error("Exception Occured in getMLPPipeLine() mathod",e); 
 InputStream is = LicenseJsonSchema.class.getResource(FILE_NAME).openStream(); 
 log.error("Processing peer " + this.peer + " subscription " + this.sub.getSubId() + " error.", fx); 
 log.warn("No solution revisions were retrieved from the peer"); 
 private StreamingResource download(URI theUri) throws FederationException { 
 logger.error("Specified Project : " + projectId + " is archived"); 
 private static final long serialVersionUID = 8892331347624397159L; 
 private static final long serialVersionUID = 8892331347624397159L; 
 authToken = httpRequest.getHeader(JWT_TOKEN_HEADER_KEY); 
<|del|> 
<|del|> 
<|del|> 
 UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( new AuthenticatedUser(mlpUser), authToken, new ArrayList<>()); authentication.setDetails(new WebAuthenticationDetailsSource() .buildDetails(httpRequest)); SecurityContextHolder.getContext().setAuthentication(authentication); 
 /** * Parameterized constructor * @param cdsClient * Object implementing ICommonDataServiceClient. */ 
 /** * Gets the MLPUser for the specified User login Name. * @param userName * User login name * @return * MLPUser instance associated to login Name. */ 
 logger.error("JsonProcessingException - Parse", e); 
 logger.error(JUPYTERNOTEBOOK_CREATE_NOTEBOOK_EXCEPTION_MSG, e); 
 logger.error(JUPYTERNOTEBOOK_CREATE_NOTEBOOK_EXCEPTION_MSG, e); 
 logger.error("JupyterNotebook - Update notebook in Jupyter Notebook server", e); 
 logger.error("JupyterNotebook - Update notebook in Jupyter Notebook server", e); 
 logger.error("JupyterNotebook - Launch Server", e); 
 logger.error(props.getJupyterhubLaunchExcp(), e); 
 logger.error("JsonParser - IO", e); 
 logger.error(props.getJupyterhubCreateUserExcp(), e); 
 logger.error(JUPYTERNOTEBOOK_SERVER_CONTENT_EXCEPTION_MSG, e); 
 logger.error(JUPYTERNOTEBOOK_DELETE_NOTEBOOK_EXCEPTION_MSG, e); 
 logger.error(JUPYTERNOTEBOOK_DELETE_NOTEBOOK_EXCEPTION_MSG, e); 
 private NotebookServiceUtil notebookServiceUtil; 
 private ConfigurationProperties confProps; 
<|del|> 
 } logger.debug("getProject() Begin"); 
 private ConfigurationProperties conf; 
<|del|> 
 logger.error("getSiteConfig failed, server reports: {}", ex.getResponseBodyAsString()); return "site config failed to be fetched from cds"; 
<|del|> 
 uploadInfo = nexusClient.uploadArtifact(getNexusGroupId(solutionId, revisionId), name, revisionId, 
 logger.error("Invalid project-service URL " + surl, e); 
 logger.error(PROJECT_SERVICE_GET_PROJECT_EXCP, e); 
 // pipeline will not be configured in the NiFi. 
 JSONObject bucket = null; String bucketName = null; String bucketIdentifier = null; 
 logger.error("Exception occured while Parsing " + newBucketString,e); throw new DataParsingException("Parse Exception occured while parsing " + newBucketString,e); 
 logger.error("Exception occured while Parsing " + newFlowString,e); throw new DataParsingException("Parse Exception occured while parsing " + newFlowString,e); 
 linkedHashMap = new LinkedHashMap<String, String>(2); linkedHashMap.put("componentType", PipelineServiceConstants.PROCESS_GROUP); linkedHashMap.put("name", PipelineServiceConstants.CHANGE_ME); changeFlowVersionPostRequestBody.put("flowContents", linkedHashMap); 
 linkedHashMap = new LinkedHashMap<String, String>(2); linkedHashMap.put("componentType", PipelineServiceConstants.PROCESS_GROUP); linkedHashMap.put("name", PipelineServiceConstants.CHANGE_ME); changeFlowVersionPostRequestBody.put("flowContents", linkedHashMap); 
 sslContext = SSLContext.getInstance("TLSv1.2"); 
 * The password for the trust store. 
public class ClientBase { 
<|del|> 
 * Check connectivity to the server. 
 * Request the server to add this client to its list of peers. 
 * Get information about a solution. 
 * Get a list of revisions in a solution. 
 * Get information about a revision. 
 printOutput(remoteInvoke("cp -r /vagrant/" + managixFolderName + " /tmp/asterix").getInputStream()); 
 LOGGER.info(pout); assert (checkOutput(pout, "ACTIVE")); //TODO: I should check for 'WARNING' here, but managix seems to not report this reliably 
 LOGGER.info(pout); assert (checkOutput(pout, "ACTIVE")); //TODO: I should check for 'WARNING' here, but managix seems to not report this reliably 
 assert (checkOutput(stop.getInputStream(), "Stopped Asterix instance")); 
 public static boolean checkOutput(InputStream input, String requiredSubString) { 
 try { candidate = IOUtils.toString(input, "UTF-8"); } catch (IOException e) { LOGGER.warning("Could not check output of subprocess"); 
 return IOUtils.toString(input, "UTF-8"); 
 public static void printOutput(InputStream input) { try { LOGGER.info(IOUtils.toString(input, "UTF-8")); } catch (IOException e) { LOGGER.warning("Could not print output of subprocess"); 
<|del|> 
<|del|> 
 LOGGER.severe("TEST CASE(S) FAILED"); 
 logOutput(remoteInvoke("cp -r /vagrant/" + managixFolderName + " /tmp/asterix").getInputStream()); 
 Assert.assertTrue(checkOutput(pout, "ACTIVE")); //TODO: I should check for 'WARNING' here, but issue 764 stops this from being reliable 
 candidate = IOUtils.toString(input, StandardCharsets.UTF_8.name()); 
 LOGGER.info(IOUtils.toString(input, StandardCharsets.UTF_8.name())); 
 private static void generateMergeAggregationExpressions(GroupByOperator gby, IOptimizationContext context) 
 clonedRecType = new ARecordType(reqType.getTypeName(), reqType.getFieldNames(), 
<|del|> 
 private void computeColumnSet(List<Pair<LogicalVariable, Mutable<ILogicalExpression>>> gbyList) { 
 private List<LogicalVariable> getGbyColumns() { 
 public void writeFields(DataOutput output) throws IOException { 
<|del|>
<|del|> 
<|del|> 
 JobId jobId = JobId.create(dis); 
 if (logDetails) { if (LOGGER.isLoggable(r.logLevel())) { LOGGER.log(r.logLevel(), "Executing: " + r); } } 
<|del|>
 noc = new NetworkOutputChannel(ccb, nBuffers); 
<|del|> 
<|del|>
 dequeueCount = new AtomicInteger(); this.logDetails = logDetails; 
 dequeueCount = new AtomicInteger(); this.logDetails = logDetails; 
 dequeueCount = new AtomicInteger(); this.logDetails = logDetails; 
<|del|> 
<|del|> 
 int position = s + 2; // skip 2 bytes containing string size 
 chars[writepos] = chars[readpos + 1]; 
<|del|> 
 AqlTranslator.ResultDelivery resultDelivery = whichResultDelivery(request); 
 ResultDelivery resultDelivery) throws Exception { 
 IHyracksDataset hdc, ResultDelivery resultDelivery) throws Exception { 
 IIndexDataflowHelperFactory invertedIndexDataflowHelperFactory) { 
 ILogicalOperator etsOp = new EmptyTupleSourceOperator(); 
 invListsTypeTraits, invListComparatorFactories, tokenizerFactory, indexDataFlowFactory); 
 * Additional variables that can be passed to the secondary index as payload. * This can be useful when creating a second filter on a non-primary and non-secondary * fields for additional pruning power. 
 * 
 public static void printLogicalPlan(ILogicalPlan plan) throws AlgebricksException { 
 public static void printOptimizedLogicalPlan(ILogicalPlan plan) throws AlgebricksException { 
 */ 
 appendln(out, new String("node [style=filled, color = lightgray];")); 
<|del|> 
 * DFS traversal function. Calls iteratively all children, and for each calls itself recursively 
 appendln(out, new String("node [style=filled, color = lightgray];")); 
 Boolean plot = xProps.getIsPlottingEnabled(); if (plot) { 
 PropertyInterpreters.getBooleanPropertyInterpreter()); 
 PropertyInterpreters.getBooleanPropertyInterpreter()); 
<|del|> 
 * 
 public void setDatasetID(int datasetID) { this.datasetID = datasetID; 
 if (index.getDataverseName().equals(MetadataConstants.METADATA_DATAVERSE_NAME) && !index.isPrimaryIndex()) { 
<|del|> 
<|del|> 
 TIMEZONE_IDS[i] = TZ_IDS[i].getBytes(encoding); 
 TIMEZONE_OFFSETS[i] = TimeZone.getTimeZone(new String(TIMEZONE_IDS[i], encoding)).getRawOffset(); 
 secondaryComparatorFactories = new IBinaryComparatorFactory[numSecondaryKeys + numPrimaryKeys]; 
 secondaryComparatorFactories[numSecondaryKeys + i] = primaryComparatorFactories[i]; 
 secondaryComparatorFactories[numSecondaryKeys + i] = IndexingConstants.getComparatorFactory(i); 
 protected void init(IndexType indexType, String dvn, String dsn, String in, List<List<String>> secondaryKeyFields, 
<|del|> 
 } AlgebricksMetaOperatorDescriptor asterixAssignOp = createAssignOp(spec, sourceOp, numSecondaryKeys); 
 private final boolean enforceKeyFields; 
 public static Pair<IAType, Boolean> getNonNullableOpenFieldType(IAType fieldType, String fieldName, 
 private static IAType keyFieldType(String expr, ARecordType recType) throws AlgebricksException { IAType fieldType; 
 int isEnforcedFieldPos = rec.getType().findFieldPosition(INDEX_ISENFORCED_FIELD_NAME); Boolean isEnforcingKeys = false; if (isEnforcedFieldPos > 0) isEnforcingKeys = ((ABoolean) rec.getValueByPos(isEnforcedFieldPos)).getBoolean(); 
 int isEnforcedFieldPos = rec.getType().findFieldPosition(INDEX_ISENFORCED_FIELD_NAME); Boolean isEnforcingKeys = false; if (isEnforcedFieldPos > 0) isEnforcingKeys = ((ABoolean) rec.getValueByPos(isEnforcedFieldPos)).getBoolean(); 
<|del|> 
 obj = env.getType(f.getArguments().get(0).getValue()); 
 throw new AlgebricksException("Typing error: expecting a constant value, found " + ce + " instead."); 
 return t0.getSubFieldType(fieldPath); 
 public IAType findSubFieldType(String subFieldName, IAType parent) throws IOException, AlgebricksException { 
 * 
<|del|> 
 } 
<|del|> 
 this.reqType = reqType; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * 
<|del|>
 * secondary key into [token, number of token] pair in a length-partitioned index. * In case of non length-partitioned index, it tokenizes secondary key into [token]. * 
<|del|>
<|del|>
 // In the bulk-load case on ngram or keyword index, // it contains [token, number of token] or [token]. 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
 for (int i = 0; i < inputs.size(); i++) { 
 * 
 private List<Mutable<ILogicalExpression>> additionalFilteringExpressions; 
<|del|>
 TokenizeOperator tokenizeOpArg = (TokenizeOperator) copyAndSubstituteVar(op, arg); boolean isomorphic = VariableUtilities.varListEqualUnordered(op.getSchema(), tokenizeOpArg.getSchema()); if (!op.getDataSourceIndex().equals(tokenizeOpArg.getDataSourceIndex())) 
 deepCopyVars(newTokenizeVars, op.getTokenizeVars()); 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
 StructuralPropertiesVector[] req = new StructuralPropertiesVector[numberOfChildren]; for (int i = 0; i < numberOfChildren; i++) { req[i] = StructuralPropertiesVector.EMPTY_PROPERTIES_VECTOR; } 
<|del|>
 dataSource, propagatedSchema, typeEnv, primaryKeys, payload, additionalFilteringKeys, 
<|del|> 
 List<LogicalVariable> additionalFilteringKeys, Mutable<ILogicalExpression> filterExpr, IDataSourceIndex<?, ?> dataSourceIndex) { 
<|del|> 
 if (TokenizeOp.getOperation() != Kind.INSERT || !TokenizeOp.isBulkload()) throw new AlgebricksException("Tokenize Operator only works when bulk-loading data."); 
<|del|>
 ILogicalOperator outOp = outEdges.get(exchg).get(0); 
 return null; } 
<|del|>
<|del|>
 return null; 
 if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Result state cleanup instance successfully completed."); } 
<|del|>
<|del|>
<|del|> 
<|del|>
 @Override public void fail() throws HyracksDataException { } 
<|del|>
 TokenizeOperator tokenizeOp = (TokenizeOperator) op; if (tokenizeOp.getOperation() != Kind.INSERT || !tokenizeOp.isBulkload()) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|>
 this.configuration = configuration; String[] splits = ((String) configuration.get(KEY_PATH)).split(","); this.isPKAutoGenerated = isPKAutoGenerated; 
 configureFileSplits(splits); configureFormat(sourceDatatype, isPKAutoGenerated, primaryKeyPosition, outputType); 
<|del|> 
<|del|> 
 Pair<IAType, Boolean> keyPairType = Index.getNonNullableKeyFieldType(secondaryKeyExprs.get(0).toString(), recType); secondaryKeyType = keyPairType.first; 
 } else if (secondaryKeys.size() > 2 && isPartitioned) { throw new AlgebricksException("Cannot create composite inverted index on multiple fields."); } 
 msb = Long.decode(components[0]).longValue(); msb <<= 16; msb |= Long.decode(components[1]).longValue(); msb <<= 16; msb |= Long.decode(components[2]).longValue(); 
 throw new IllegalArgumentException("Invalid UUID string: " + name); for (int i = 0; i < 5; i++) components[i] = "0x" + components[i]; 
<|del|> 
<|del|> 
 return new AdmTupleParser(ctx, recType, isPKAutoGenerated, primaryKeyPosition, origRecordTypeForAutoGeneratedPK); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 void parse(char[] buffer, int start, int length, DataOutput out) throws HyracksDataException; 
 delimiter, quote); 
 public void parse(char[] buffer, int start, int length, DataOutput out) throws HyracksDataException { 
 dataParser = new DelimitedDataParser(recordType, valueParserFactories, delimiter, '\u0000', false, -1, null); 
 throw new HyracksDataException( "Long Parser - a digit is expected. But, encountered this character: " + ch + " in the incoming input: " + errorString); 
 public static DelimitedDataParser getDilimitedDataParser(ARecordType recordType, char delimiter, char quote) { 
 configuration) : new NtDelimitedDataTupleParserFactory(recordType, fieldParserFactories, delimiter, isPKAutoGenerated, primaryKeyPosition, origSourceDataTypeForAutoGeneratedPK); 
 delimiter, quote); 
 delimiter, quote); 
 public ITupleParserFactory createTupleParser(ARecordType recType, boolean isDelimited, char delimiter, char quote); 
 public ITupleParserFactory createTupleParser(ARecordType recType, boolean delimitedFormat, char delimiter, char quote) { 
 * 
 * 
 * 
 * 
<|del|> 
<|del|> 
 private List<String> fieldPath; 
<|del|> 
 public static final int MAX_LENGTH = 65535; 
 if (length > ByteArrayPointable.MAX_LENGTH) { 
 t0 = (IAType) env.getType(arg0); 
<|del|> 
<|del|> 
 else{ 
<|del|> 
<|del|> 
 p.set(b1, s1, l1); return ((IComparable) p).compareTo(b2, s2, l2); 
 p.set(bytes, offset, length); return ((IHashable) p).hash(); 
 switch (op1.getOperatorTag()) { case LogicalOperatorTag.SINK: { /** * pattern match: sink insert assign * resulting plan: sink-insert-project-assign */ 
 // QQQ should be supported - issue 833 
 // QQQ should be supported - issue 833 
 // QQQ Should possibly be supported? - issue 833 
 // QQQ probably should be supported - issue 833 
 recoveryMgr.checkpoint(true, NON_SHARP_CHECKPOINT_TARGET_LSN); 
 recoveryMgr.checkpoint(true, NON_SHARP_CHECKPOINT_TARGET_LSN); 
 private final AtomicLong appendLSN; 
<|del|> 
 lockManager.lock(datasetId, -1, LockMode.X, txnCtx); 
 // commit transaction and release the dataset lock txnManager.commitTransaction(txnCtx, datasetId, -1); 
 // commit transaction and release the dataset lock txnManager.commitTransaction(txnCtx, datasetId, -1); 
 Kind[] statementsArray = { Kind.DATAVERSE_DECL, Kind.FUNCTION_DECL, Kind.QUERY, Kind.SET, Kind.WRITE, Kind.RUN }; 
 else { acquireDatasetWriteLock(datasetFullyQualifiedNameTo); acquireDatasetReadLock(datasetFullyQualifiedNameFrom); } 
 this.close(); 
 // get the local transaction ITransactionContext txnCtx = txnManager.getTransactionContext(jobId, false); 
 // get the local transaction ITransactionContext txnCtx = txnManager.getTransactionContext(jobId, false); 
 public static enum ComparableResultCode { 
 throw new AlgebricksException(e); 
 throw new AlgebricksException(e); 
 throw new AlgebricksException(e); 
 throw new HyracksDataException("ComparatorFactory - failed to promote the type:" + sourceTypeTag + " to the type:" + targetTypeTag); 
 throw new HyracksDataException( "Type casting error while getting an INT32 value: expected INT8/16/32/64/FLOAT/DOUBLE but got " + EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes[offset]) + "."); 
 value *= -1; } 
<|del|> 
<|del|> 
 throw new IllegalArgumentException(e); 
 throw new IllegalArgumentException(e); 
 throw new AlgebricksException(e); 
<|del|> 
 //Make the outside of the subplan the input of op2 Mutable<ILogicalOperator> outsideRef = op2.getInputs().get(0); outsideRef.setValue(op0.getInputs().get(0).getValue()); 
 //Make op2 the input of the subplan Mutable<ILogicalOperator> op2OutsideRef = op0.getInputs().get(0); op2OutsideRef.setValue(op2); 
 if (((VariableReferenceExpression) expr).getVariableReference().equals(aggVar)) { 
 //For LOJ with GroupBy, prepare objects to reset LOJ nullPlaceHolderVariable in GroupByOp 
<|del|> 
<|del|> 
 public void write(DataOutput dataOutput, long position) throws IOException { 
 public abstract int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) throws HyracksDataException; 
 start = (int) LongPointable.getLong(argOut.getByteArray(), 1) - 1; 
 conf.set(KEY_HADOOP_SHORT_CIRCUIT, "true"); conf.set(KEY_HADOOP_SOCKET_PATH, localShortCircuitSocketPath.trim()); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * join (TRUE) 
<|del|> 
 if (!assignUnion.getExpressions().get(0).toString().equalsIgnoreCase("union")) { 
<|del|> 
 List<LogicalVariable> var_unnest = new ArrayList<LogicalVariable>(); unnest1.getExpressionRef().getValue().getUsedVariables(var_unnest); unnest1.getExpressionRef().getValue().substituteVar(var_unnest.get(0), agg1_var.get(0)); 
<|del|> 
 //The rule "IntroduceUnionRule" will translates this assign operator into the UnionAll operator. 
 Pair<ILogicalOperator, LogicalVariable> op_var = e.accept(this, ts); ts = new MutableObject<ILogicalOperator>(op_var.first); VariableReferenceExpression var = new VariableReferenceExpression(op_var.second); inputVars.add(new MutableObject<ILogicalExpression>(var)); 
 return rtnChronon; 
 return (s2.compareTo(s1) >= 0 && s2.compareTo(e1) < 0) || (e2.compareTo(e1) <= 0 && e2.compareTo(s1) > 0); 
 initAccessAppend(hyracksTaskCtx); 
<|del|> 
 if (!joinInputs.get(0).getValue().getOperatorTag().toString().contains("AGGREGATE") || !joinInputs.get(1).getValue().getOperatorTag().toString().contains("AGGREGATE")) 
 if (!joinInputs.get(0).getValue().getOperatorTag().toString().contains("AGGREGATE") || !joinInputs.get(1).getValue().getOperatorTag().toString().contains("AGGREGATE")) 
 * Pushes down unnest through both branches of the union operator 
 //Getting the two topmost branched and adding them as an input to the unnests: 
 List<LogicalVariable> var_unnest2 = new ArrayList<LogicalVariable>(); unnest2.getExpressionRef().getValue().getUsedVariables(var_unnest2); unnest2.getExpressionRef().getValue().substituteVar(var_unnest2.get(0), agg2_var.get(0)); 
<|del|>
 btreeAccessors[i].reset(btree, NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); 
<|del|> 
<|del|> 
 //deserialize the tag (move input cursor forward) and check if it's not NULL tag 
 if (rtnChronon < 0L) { 
 return new AUnionType(unionList, "IntervalOrNullResult"); 
 private final ArrayBackedValueStorage argOut = new ArrayBackedValueStorage(); 
 temp.add(ADayTimeDurationConstructorDescriptor.FACTORY); 
 markAsValidInternal(component.getBuddyBTree(), force); 
 markAsValidInternal(component.getBTree(), force); 
 if (durable && force) { 
 markAsValidInternal(invIndex.getBTree(), force); 
 markAsValidInternal(component.getBTree(), force); 
 markAsValidInternal(rtree, force); 
 this.isTemporaryDatasetWriteJob = isTemporaryDatasetWriteJob; 
 } catch (Exception e) { LOGGER.log(Level.SEVERE, e.getMessage(), e); 
 this.isTemporaryDatasetWriteJob = isTemporaryDatasetWriteJob; 
 toDataset.getDatasetDetails().isTemp()); 
 JobEventListenerFactory jobEventListenerFactory = new JobEventListenerFactory(jobId, true); 
 secondaryBTreeFields, secondaryFilterFields, !temp); 
 // Default life time period of a temp dataset. It is 30 days. private final static long TEMP_DATASET_INACTIVE_TIME_THRESHOLD = 3600 * 24 * 30 * 1000; 
 public boolean isTemporaryDatasetWriteJob() { // The transaction only writes temporary datasets. return isTemporaryDatasetWriteJob; 
 IModificationOperationCallbackFactory modificationCallbackFactory = temp ? new TempDatasetPrimaryIndexModificationOperationCallbackFactory( 
 // Temporary dataset only lives in the compiler therefore the temp field is false. // DatasetTupleTranslator always read from the metadata node, so the temp flag should be always false. 
<|del|> 
 markAsValidInternal(component.getBuddyBTree()); 
 mergePolicy, opTracker, ioScheduler, ioOpCallback, durable); 
 public void markAsValid(ILSMComponent lsmComponent) throws HyracksDataException { 
 markAsValidInternal(component.getBTree()); 
 lsmHarness.addBulkLoadedComponent(component); 
 public void markAsValid(ILSMComponent lsmComponent) throws HyracksDataException; 
 if (durable) { 
<|del|> 
 public void merge(ILSMIndexOperationContext ctx, ILSMIOOperation operation) throws HyracksDataException, IndexException { 
 public void addBulkLoadedComponent(ILSMComponent c) throws HyracksDataException, IndexException { lsmIndex.markAsValid(c); 
 public void flush(ILSMIndexOperationContext ctx, ILSMIOOperation operation) throws HyracksDataException, IndexException { 
 public void flush(ILSMIndexOperationContext ctx, ILSMIOOperation operation) throws HyracksDataException, IndexException { 
 public void addBulkLoadedComponent(ILSMComponent c) throws HyracksDataException, IndexException { lsmIndex.markAsValid(c); 
 lsmHarness.flush(ctx, operation); 
 lsmHarness.merge(ctx, operation); 
 lsmHarness.addBulkLoadedComponent(component); 
 public void markAsValid(ILSMComponent lsmComponent) throws HyracksDataException { 
 lsmHarness.flush(ctx, operation); 
 lsmHarness.merge(ctx, operation); 
 invertedIndexFieldsForNonBulkLoadOps, durable); 
 markAsValid(component); 
 lsmHarness.addBulkLoadedComponent(component); 
 lsmHarness.addBulkLoadedComponent(component); 
 lsmHarness.addBulkLoadedComponent(component); 
 public void markAsValid(ILSMComponent lsmComponent) throws HyracksDataException { 
 System.out.println(opType.name() + " operation waits for enter a component"); 
 private Object addIndexIfNotExistsInternal(Index index) { 
 } else if (attempt < retries) { 
<|del|> 
 if (failedOperation && (opType == LSMOperationType.MODIFICATION || opType == LSMOperationType.FORCE_MODIFICATION)) { 
 } catch (Throwable e) { 
 if (readerCount <= -1) { throw new IllegalStateException("Invalid LSM disk component readerCount: " + readerCount); } 
<|del|> 
<|del|> 
<|del|> 
 return n == 0 ? -1 : n; 
 if (bytes % minFrameSize != 0) { throw new HyracksDataException("The size should be an integral multiple of the default frame size"); } 
 public synchronized void completeOperation(ILSMIndex index, LSMOperationType opType, ISearchOperationCallback searchCallback, 
 public void flushIfRequested() throws HyracksDataException { 
 return (int) Math.floor(slotIndex / rangesPerPart); 
 } //logTrackingInformation(buffer); 
<|del|> 
<|del|> 
 count = 0; runningSum = 0; 
<|del|> 
<|del|> 
 btreeFields, filterFields, true), localResourceFactoryProvider, 
 addIndexIfNotExistsInternal(index); 
<|del|> 
<|del|> 
 private int appMasterRpcPort = new Random().nextInt(65535-49152); 
 //HDFS path to AsterixDB cluster description 
 int deathClock = 60; while (ccUp.get() == false && deathClock > 0) { 
 LOG.debug(ex); 
 } catch (InterruptedException ex) { LOG.debug(ex); 
 } catch (InterruptedException ex) { LOG.debug(ex); 
 synchronized(ncStarted){ 
 Path p = new Path(dfsBasePath, instanceConfPath + File.separator + "library" + Path.SEPARATOR); 
 if(containerStatus.getState() != ContainerState.COMPLETE){ throw new IllegalStateException("Non-completed container given as completed by RM."); } 
 final Container container; 
 vargs.add("-result-ip-address " + local.getClusterIp()); if(initial){ vargs.add("-initial-run "); } 
 String pathSuffix = CONF_DIR_REL + instanceFolder + CONFIG_DEFAULT_NAME; 
 Utils.sendShutdownCall(ccIp,ccRestPort); 
 + PARAMS_DEFAULT_NAME; 
 public static void sendShutdownCall(String host, int port) throws IOException { final String url = "http://" + host + ":" + port + "/admin/shutdown"; 
 public static boolean probeLiveness(String host, int port) throws IOException { final String url = "http://" + host + ":" + port + "/query"; final String test = "for $x in dataset Metadata.Dataset return $x;"; 
<|del|> 
 } if (probe) { 
 /** * The offset of the frame_count which is one byte indicate how many initial_frames contained in current frame. * The actual frameSize = frame_count * intitialFrameSize(given by user) */ int META_DATA_FRAME_COUNT_OFFSET = 0; 
 /** * The caller should call this method to return the pre-allocated frames. * * @param bytes */ void deallocateFrames(int bytes); 
 return n == 0 ? -1 : n; 
 if (size <= 0) { 
 throw new HyracksDataException("should never happen"); 
 throw new HyracksDataException("should never happen"); 
 //TODO make a global memory manager to allocate and deallocate the frames. 
 - tupleCount * FrameConstants.SIZE_LEN); 
 throw new HyracksDataException( "The given frame can not be extended to insert the leftover data from the last record"); 
 private boolean failed; 
 protected final IMetaDataManager freePageManager; 
 protected boolean isActive = false; 
 if (!appendOnly) { 
 if (isActive) { 
 if(metadataPage <0 ){ 
 if(componentFilterPageId == LinkedMetaDataManager.NO_FILTER_IN_PLACE){//in-place mode, no filter page yet 
 synchronized(this){ if (writerThread == null) { writerThread = new Thread(this); writerThread.setName("FIFO Writer Thread"); haltWriter = false; writerThread.start(); } 
 //TODO: What do we do, if we could not write the page? 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 fieldList.add(new String(outInput1.getByteArray(), 3, outInput1.getLength() - 3, "UTF-8")); 
<|del|> 
 private static final long MIN_MODIFICATION_INTERVAL = 180000; // 3 minutes 
 if (size < 0) { 
 * @return {@code true} if succeed to read the data from the channel to the {@code frame}. * Otherwise return {@code false} if the end of stream is reached. 
 int itemCount = list.getItemCount(); for (int l = 0; l < itemCount; l++) { 
 * Runs runtime test cases that have been identified in the repeatedtestsuite.xml. * * Each test is run 10000 times. 
<|del|> 
 feedServer.stop(); 
 this(in, conf.getInt(KEY_BUFFER_SIZE, DEFAULT_BUFFER_SIZE)); 
 private final ISerializerDeserializer boolSerde = AqlSerializerDeserializerProvider.INSTANCE 
 Pair<IVisitablePointable, Boolean>(accessor1, false); 
<|del|> 
 fieldName = names.get(j); 
 keyEntry.set(item.getByteArray(), item.getStartOffset(), item.getLength()); 
 // Removes test storage directory, in case there are aborted tests before and // leftover files. removeTestStorageDirectory(); 
 // Removes test storage directory, in case there are aborted tests before and // leftover files. removeTestStorageDirectory(); 
 .asList(new String[] { "bin/pregelix examples/pregelix-example-jar-with-dependencies.jar " 
 public boolean isReplicationEnabled(); 
<|del|> 
 LSMBTreeWithBuddyDiskComponent component = (LSMBTreeWithBuddyDiskComponent) lsmComponent; 
 offset += 8; 
 offset += 4; 
 initPage(page.getBuffer().array()); 
 initPage(page.getBuffer().array()); 
<|del|> 
<|del|> 
 frontier.page = bufferCache.confiscatePage(BufferCache.INVALID_DPID); 
 int numPages = bufferCache.getNumPagesOfFile(fileId); if(numPages > 0 ){ throw new HyracksDataException("Indices using append-only semantics can't be cleared by calling create"); } 
<|del|> 
 hasEverBeenActivated = true; 
 bufferCache.deleteFile(fileId, false); 
<|del|> 
<|del|> 
 frontier.page = bufferCache.confiscatePage(BufferCache.INVALID_DPID); 
<|del|> 
<|del|> 
<|del|> 
 } 
 } try{ synchronized(poisonPill){ queue.put(poisonPill); while(queue.contains(poisonPill)){ poisonPill.wait(); } 
 synchronized(lowWater){ queue.put(lowWater); while(queue.contains(lowWater)){ lowWater.wait(); 
<|del|>
 boolean previousCharIsSeparator = true; 
<|del|> 
<|del|> 
 if (toRoot && level < nodeFrontiers.size() - 1) { 
 this.maxAllowedNumPages = maxAllowedNumPages; 
 assert (maxAllowedNumPages > 0); 
 clockPtr.set(clockPtr.incrementAndGet() % numPages.get()); 
<|del|> 
 @Override 
 else if (componentFilterPageId <= LinkedMetaDataPageManager.NO_FILTER_APPEND_ONLY){ 
 virtual = new AtomicBoolean(false); 
<|del|> 
 public PersistentLocalResourceRepository(List<IODeviceHandle> devices, String nodeId) throws HyracksDataException { mountPoints = new String[devices.size()]; this.nodeId = nodeId; for (int i = 0; i < mountPoints.length; i++) { 
 Map<Long, LocalResource> resourcesMap = ((PersistentLocalResourceRepository) localResourceRepository) .loadAndGetAllResources(); 
<|del|> 
 Thread.sleep(sleepInterval); 
<|del|> 
 public List<Mutable<ILogicalOperator>> ixJoinOuterAdditionalDataSourceRefs = null; public List<DataSourceType> ixJoinOuterAdditionalDataSourceTypes = null; public List<Dataset> ixJoinOuterAdditionalDatasets = null; public List<ARecordType> ixJoinOuterAdditionalRecordTypes = null; 
 initializeIxJoinOuterAddtionalDataSourcesIfEmpty(); ixJoinOuterAdditionalDataSourceTypes.add(DataSourceType.DATASOURCE_SCAN); ixJoinOuterAdditionalDataSourceRefs.add(subTreeOpRef); 
 + ZooKeeperService.ASTERIX_INSTANCE_STATE_PATH; 
 byte[] b = zk.getData(clusterStatePath + ZooKeeperService.ASTERIX_INSTANCE_STATE_REPORT, false, null); zk.delete(clusterStatePath + ZooKeeperService.ASTERIX_INSTANCE_STATE_REPORT, 0); clusterState = ClusterState.values()[(int)b[0]]; 
 || (!funcExpr.isFunctional() && !functionIsConstantAtRuntime(op, funcExpr, context))) { 
<|del|> 
 index = lcManager.getIndex(resourceName); 
 lcManager.unregister(resourceName); 
 if (getResourceID() == -1) { 
 index = lcManager.getIndex(resourceName); 
 lcManager.unregister(resourceName); 
 index = lcManager.getIndex(resourceName); 
<|del|> 
<|del|> 
 int datasetID = getDIDfromResourceName(resourceName); 
<|del|> 
 this.expression = configuration.get(AsterixTupleParserFactory.KEY_EXPRESSION); String[] splits = configuration.get(AsterixTupleParserFactory.KEY_PATH).split(","); 
 this.expression = configuration.get(AsterixTupleParserFactory.KEY_EXPRESSION); String[] splits = configuration.get(AsterixTupleParserFactory.KEY_PATH).split(","); 
 e.printStackTrace(); 
 } 
 public static final String KEY_EXPRESSION = "expression"; 
<|del|> 
 public ClusterState waitForClusterStart() throws Exception { 
 private void monitorStateChange() { 
<|del|> 
 /* The following assumes this DDL (but ignoring the field name orders): 
<|del|> 
 * http://www.apache.org/licenses/LICENSE-2.0 
 return name.endsWith(WORKSPACE_FILE_SUFFIX); 
<|del|> 
 InetSocketAddress replicaAddress = InetSocketAddress.createUnresolved(replicaIPAddress, replicationPort); 
 formJobTerminateLogRecord(txnCtx.getJobId().getId(), isCommit, nodeId); 
 writeLogRecordCommonFields(buffer); 
 public final static int REPLICATION_REQUEST_TYPE_SIZE = INTEGER_SIZE; public final static int REPLICATION_REQUEST_HEADER_SIZE = REPLICATION_REQUEST_TYPE_SIZE + INTEGER_SIZE; 
 public static ByteBuffer writeLSMComponentPropertiesRequest(LSMComponentProperties lsmCompProp, ByteBuffer buffer) 
 buffer = ByteBuffer.allocate(requestSize); } else { buffer.clear(); 
 ByteBuffer bb = ByteBuffer.allocate(REPLICATION_REQUEST_TYPE_SIZE); bb.putInt(ReplicationRequestType.GOODBYE.ordinal()); 
<|del|> 
 private boolean deleteAfterClose; 
 if (searchKeyExpr.getExpressionTag() == LogicalExpressionTag.FUNCTION_CALL) { constantAtRuntimeExpressions[keyPos] = searchKeyExpr; constAtRuntimeExprVars[keyPos] = context.newVar(); searchKeyExpr = new VariableReferenceExpression(constAtRuntimeExprVars[keyPos]); 
<|del|> 
 if (responseFunction == ReplicationRequestType.FLUSH_INDEX) { requestBuffer = AsterixReplicationProtocol.readRequest(socketChannel, requestBuffer); 
 recoveryLogs.add(logRecord); //this needs to be a new log object so that it is passed to recovery manager as a different object logRecord = new LogRecord(); 
 responseType = AsterixReplicationProtocol.getRequestType(socketChannel, dataBuffer); 
 // If it's JSON, check for the "lossless" flag 
 LOGGER.warning("JSON exception in parsing message " + message + " exception [" + jse.getMessage() + "]"); 
 LOGGER.warning("JSON Exception in parsing message " + message); 
 // QQQ For now, we are indeed assuming we get back JSON errors. 
 public IPrinterFactoryProvider getLosslessJSONPrinterFactoryProvider(); 
 FAIL, JOIN, 
 FAIL, JOIN, 
 lsmComponentRemoteLSN2LocalLSNMappingTaskQ = new LinkedBlockingQueue<LSMComponentLSNSyncTask>(); lsmComponentId2PropertiesMap = new ConcurrentHashMap<String, LSMComponentProperties>(); localLSN2RemoteLSNMap = new ConcurrentHashMap<Long, RemoteLogMapping>(); lsmComponentLSNMappingService = new LSMComponentsSyncService(); 
 lsmComponentRemoteLSN2LocalLSNMappingTaskQ = new LinkedBlockingQueue<LSMComponentLSNSyncTask>(); lsmComponentId2PropertiesMap = new ConcurrentHashMap<String, LSMComponentProperties>(); localLSN2RemoteLSNMap = new ConcurrentHashMap<Long, RemoteLogMapping>(); lsmComponentLSNMappingService = new LSMComponentsSyncService(); 
 lsmComponentRemoteLSN2LocalLSNMappingTaskQ = new LinkedBlockingQueue<LSMComponentLSNSyncTask>(); lsmComponentId2PropertiesMap = new ConcurrentHashMap<String, LSMComponentProperties>(); localLSN2RemoteLSNMap = new ConcurrentHashMap<Long, RemoteLogMapping>(); lsmComponentLSNMappingService = new LSMComponentsSyncService(); 
 Set<String> replicaIds = getActiveReplicasIds(); 
 //Recovery Method 
 //Recovery Method 
 //Recovery Method 
 public synchronized HashMap<Long, Long> getReplicaIndexLSNMap(String indexPath) throws IOException { 
 if(buffer.remaining() < ALL_RECORD_HEADER_LEN) { 
 hasRemaining = refillLogReadBuffer(); if(!hasRemaining){ 
 throw new AlgebricksException("'Interval' type unsupported for CSV output"); 
 bytes = UTF8StringUtil.writeStringToBytes(string); 
 optFuncExpr.getConstantAtRuntimeExpr(0), context.getMetadataProvider(), typeEnvironment)); 
 if (expressionType == null) { //Not constant at runtime 
 if (expressionType == null) { //Not constant at runtime 
 if (constantAtRuntimeExpression.getExpressionTag() == LogicalExpressionTag.CONSTANT) { constantValue = (AsterixConstantValue) ((ConstantExpression) constantAtRuntimeExpression).getValue(); 
<|del|> 
 ILogicalExpression[] constantAtRuntimeExpressions = new ILogicalExpression[numSecondaryKeys]; LogicalVariable[] constAtRuntimeExprVars = new LogicalVariable[numSecondaryKeys]; 
 ILogicalExpression[] constantAtRuntimeExpressions = new ILogicalExpression[numSecondaryKeys]; LogicalVariable[] constAtRuntimeExprVars = new LogicalVariable[numSecondaryKeys]; 
 if (searchKeyExpr.getExpressionTag() == LogicalExpressionTag.FUNCTION_CALL) { constantAtRuntimeExpressions[keyPos] = searchKeyExpr; constAtRuntimeExprVars[keyPos] = context.newVar(); searchKeyExpr = new VariableReferenceExpression(constAtRuntimeExprVars[keyPos]); 
<|del|> 
 return contentLength; 
 //TODO: This UTF8Tokenizer strongly relies on the Asterix data format, 
 //TODO: This UTF8Tokenizer strongly relies on the Asterix data format, 
 private final AStringSerializerDeserializer aStringSerDer = new AStringSerializerDeserializer(); 
 private final AStringSerializerDeserializer aStringSerDer = new AStringSerializerDeserializer(); 
 private final AObjectSerializerDeserializer aObjSerDer = new AObjectSerializerDeserializer(); 
 private final AObjectSerializerDeserializer aObjSerDer = new AObjectSerializerDeserializer(); 
 private final AObjectSerializerDeserializer aObjSerDer = new AObjectSerializerDeserializer(); 
 private final AStringSerializerDeserializer aStringSerDer = new AStringSerializerDeserializer(); private final ABinarySerializerDeserializer aBinarySerDer = new ABinarySerializerDeserializer(); 
 private final AStringSerializerDeserializer aStringSerDer = new AStringSerializerDeserializer(); 
 int aVeryLongLength = 65540; char[] aVeryLongHexString = new char[aVeryLongLength * 2]; Arrays.fill(aVeryLongHexString, 'F'); testOneInputString(new String(aVeryLongHexString)); 
 private final AObjectSerializerDeserializer aObjSerDer = new AObjectSerializerDeserializer(); 
 private final AObjectSerializerDeserializer aObjSerDer = new AObjectSerializerDeserializer(); 
 private final AObjectSerializerDeserializer aObjSerDer = new AObjectSerializerDeserializer(); 
 private final AStringSerializerDeserializer aStringSerDer = new AStringSerializerDeserializer(); 
<|del|> 
<|del|> 
 InsertOperator insertOp = (InsertOperator) op; if (!insertOp.isBulkload()) throw new AlgebricksException("Bulkload operation is expected"); 
 InsertOperator insertOp = (InsertOperator) op; 
 protected void afterReset() { } 
 public void appendUtf8StringPointable(UTF8StringPointable src, int byteStartOffset, int byteLength) throws IOException { 
 public void appendUtf8StringPointable(UTF8StringPointable src) throws IOException { appendUtf8StringPointable(src, src.getCharStartOffset(), src.getUTF8Length()); 
 int position = s + UTF8StringUtil.getNumBytesToStoreLength(stringLength); 
<|del|> 
<|del|> 
 import static org.mockito.Mockito.mock; import static org.mockito.Mockito.spy; import static org.mockito.Mockito.when; 
 public String getUserEmail() { 
<|del|> 
<|del|> 
 state = SystemState.CORRUPTED; 
 jobId2WinnerEntitiesMap.remove(jobId); 
 if (needToFreeMemory()) { 
 jobRecoveryFile.createNewFile(); } else { throw new IOException("File: " + fileName + " for job id(" + jobId + ") already exists"); 
<|del|> 
 if (needToFreeMemory()) { 
 File partitionFile = createJobRecoveryFile(jobId, getPartitionName(partitionMaxLSN)); 
 while (buffer.hasRemaining()) { fileChannel.write(buffer); } 
 while (buffer.hasRemaining()) { fileChannel.write(buffer); } 
<|del|> 
 try { 
 public void updatePrimaryKeys(IOptimizationContext context) { 
<|del|> 
<|del|> 
 && fieldType.getTypeTag() != keyFieldTypes.get(pos).getTypeTag()) 
<|del|> 
 private static final PrintWriter ERR = new PrintWriter(System.err); private final TestExecutor testExecutor = new TestExecutor(); 
 private JoinType joinType; private Expression rightExpr; private VariableExpr rightVar; private VariableExpr rightPosVar; 
 "is-system-null", 1); 
<|del|> 
 try { 
 } catch(IOException e) { 
 public void unregister(String resourceName) throws HyracksDataException; 
 throw new HyracksDataException("Failed to deallocate memory for index with resource name " + resourceName 
<|del|> 
 if (!lsmIndex.isMemoryComponentsAllocated()) { lsmIndex.allocateMemoryComponents(); 
 BufferCache.setDpid(frontier.page, BufferedFileHandle.getDiskPageId(fileId, finalPageId)); 
 private void persistFrontiers(int level, int rightPage) throws HyracksDataException { 
 setPageDpid(lastLeaf,nodeFrontiers.get(level).pageId); 
 if (rightPage < 0) { throw new HyracksDataException("Error in index creation. Internal node appears to have no rightmost guide"); 
 setPageDpid(frontier.page, finalPageId); 
 super.handleException(); 
<|del|> 
 protected boolean hasEverBeenActivated = false; protected boolean appendOnly = false; 
 protected int bulkloadLeafStart = 0; 
<|del|> 
<|del|> 
 this.appendOnly = true; initCachedMetadataPage(); 
<|del|> 
 if (!isEmptyTree(leafFrame)) { 
 if (frontierPage.confiscated()) { bufferCache.returnPage(frontierPage,false); 
<|del|> 
 * @author whli 
 return new StructuralPropertiesVector(diffPart, null); 
<|del|> 
 * creates (if necessary) and returns the dataset info. 
 * creates (if necessary) and returns the primary index operation tracker of a dataset. 
 * creates (if necessary) and returns the dataset virtual buffer caches. 
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private final SubstituteEquivalenceClassTransform substituteTransform = new SubstituteEquivalenceClassTransform(); 
 printOperator((AbstractLogicalOperator) root.getValue(), out, pvisitor, indent); 
 PlanPrettyPrinter.printOperator((AbstractLogicalOperator) opRef.getValue(), sb, pvisitor, 0); 
 // If it's JSON, check for the "lossless" flag 
 // TODO Check this call, result of merge from master! // ((IGenericAdapterFactory) adapterFactory).setFiles(files); 
<|del|> 
<|del|> 
<|del|> 
<|del|>
 // Get the cluster state 
 if (wEvent.getState() == KeeperState.SyncConnected) { msgQ.add("connected"); 
 * cycle in the wait-graph where the job waits on itself - but not directly on itself (which happens e.g. in the * case of upgrading a lock from S to X). 
<|del|> 
 public boolean isReadyToProcessUnqiueIdRequests(); 
 /** * @return the maximum unique id provided by the CC to this NC. * @throws Exception */ public long getNCMaxUniqueId() throws Exception; 
 public long requestAndGetUniqueID() throws Exception; 
 if (!aep.isReadyToProcessUnqiueIdRequests()) { throw new Exception("Cluster is not ready to process unique id requests."); 
 public static class GetUniqueIdFunction extends Function { 
 public void getUnqiueId(InetSocketAddress ncAddress, String nodeId) throws Exception { CCNCFunctions.GetUniqueIdFunction gridf = new CCNCFunctions.GetUniqueIdFunction(ncAddress, nodeId); 
 LOGGER.log(COUNT_LOGGING_LEVEL, "Dequeue (" + WorkQueue.this.hashCode() + "): " + dequeueCount.incrementAndGet() + "/" + enqueueCount); 
 localResourceRepository = (PersistentLocalResourceRepository) persistentLocalResourceRepositoryFactory .createRepository(); resourceIdFactory = (new ResourceIdFactoryProvider(localResourceRepository)).createResourceIdFactory(); 
 int currentVarCountert) throws AlgebricksException; 
 new LogicalExpressionJobGenToExpressionRuntimeProviderAdapter(QueryLogicalExpressionJobGen.INSTANCE)); 
 QueryTranslator aqlTranslator = new QueryTranslator(aqlStatements, sessionConfig, compilationProvider); 
<|del|> 
 } if(c.valid){ reachableDpids.add(c.dpid); } 
 for(Long l: reachableDpids){ if(!canFindValidCachedPage(l)){ return false; } } return true; 
 boolean isClean(); 
 if (positionalVariable != null) { nullableVars.add(positionalVariable); } 
 throw new AlgebricksException( "Null environment for pointer " + p + " in getVarType for var=" + var); 
 // Do not eliminate sort-merge below input order-sensitive operators. // TODO(buyingyi): once Taewoo merged his limit-push down change, // we need to use his new property in logical operator to check order sensitivity. 
 do { Identifier symbolFromParent = parentIterator.next(); if (!symbols.containsKey(symbolFromParent.getValue())) { currentSymbol = symbolFromParent; break; } } while (parentIterator.hasNext()); 
 // Rewrite the function body itself (without setting unbounded variables to dataset access). // TODO(buyingyi): throw an exception for recursive function definition or limit the stack depth. 
 public AsterixAppRuntimeContext(INCApplicationContext ncApplicationContext) { 
<|del|> 
<|del|> 
 resourceID = resourceIdFactory.createId(); 
<|del|> 
 private void allocateAndInitMetaDataPage() throws HyracksDataException { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 treeMetaManager.setFilterPage(bufferCache.confiscatePage(IBufferCache.INVALID_DPID)); 
<|del|> 
 forceFlushDirtyPages(invIndex.getBTree()); bufferCache.force(invIndex.getInvListsFileId(),true); 
 // if the type doesn't change, we just skip the reset. 
 for (ICachedPage p : pages) { if (p != null) { bufferCache.returnPage(p, false); 
 int freePage = IBufferCache.INVALID_PAGEID; 
 return IBufferCache.INVALID_PAGEID; 
 return IBufferCache.INVALID_PAGEID; 
 public static final int TREE_METADATA_NUM_PAGES = 2; 
 throw new NotImplementedException(); 
<|del|>
<|del|> 
 throw new AsterixException("Trying to add non-schemaless records to an open field."); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public void serializeString(String str, IMutableValueStorage vs, boolean writeTag) throws AsterixException { 
 throw new AsterixException("Could not serialize " + str); 
 public void serializeString(String str, IMutableValueStorage vs) throws AsterixException { serializeString(str, vs, false); 
 if (PointableUtils.sameType(ATypeTag.RECORD, rightType) && PointableUtils.sameType(ATypeTag.RECORD, leftType)) { 
 private static final byte SER_RECORD_TYPE_TAG = ATypeTag.RECORD.serialize(); private final Deque<IVisitablePointable> recordPath = new ArrayDeque<>(); @SuppressWarnings("unchecked") private final ISerializerDeserializer<ANull> nullSerDe = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.ANULL); 
 public static final int TREE_METADATA_NUM_PAGES = 2; 
 throw new AlgebricksException("Input record cannot be null"); 
 private final Map<IVisitablePointable, ListDeepEqualityChecker> lpointableToEquality = new HashMap<>(); private final Map<IVisitablePointable, RecordDeepEqualityChecker> rpointableToEquality = new HashMap<>(); 
 public FrameDistributor(FeedId feedId, FeedRuntimeType feedRuntimeType, int partition, 
 @Option(name = "-initial-run", usage = "A flag indicating if it's the first time the NC is started (default: false)", required = false) public boolean initialRun = false; 
 Cluster cluster = AsterixClusterProperties.INSTANCE.getCluster(); if (cluster == null) { throw new IllegalStateException("No cluster configuration found for this instance"); } 
<|del|> 
 String pregelixHome = System.getenv(pregelixHomeKey); 
 for (Index index : indexes) { if (index.isPrimaryIndex()) { toIndex = index; break; } 
<|del|> 
<|del|> 
 public void getUnqiueId(String nodeId) throws Exception; 
 public GetUniqueIdFunction(String nodeId) { 
<|del|> 
 public GlobalResourceIdFactory(HyracksRootContext rootCtx) { 
 for (final IOperatorNodePushable op : operatorNodePushablesBFSOrder) { 
 for (final IOperatorNodePushable op : operatorNodePushablesBFSOrder) { 
 Assert.assertTrue(t.getMessage().equals(EXPECTED_ERROR_MESSAGE)); 
 private class ExceptionRaisingActivityNode extends AbstractActivityNode { 
<|del|> 
<|del|> 
<|del|> 
 protected class SpaceEntryFactory implements IResetableComparableFactory { 
 Assert.assertTrue(checkOutput(pout, "ACTIVE")); 
 private final static TestExecutor testExecutor = new TestExecutor(CLUSTER_CC_ADDRESS,CLUSTER_CC_API_PORT); 
 // Set the node resolver to be the identity resolver that expects node names // to be node controller ids; a valid assumption in test environment. 
 int numOfFiles = 0; 
 recordDescriptor, recordDescriptor, new HashSpillableTableFactory(hashFunctionFactories)); 
 public FrameFreeSlotLastFit(int initialFrameNumber) { frameSpaces = new FrameSpace[initialFrameNumber]; 
<|del|> 
 @Override public void fail() throws HyracksDataException { if (isOpen) { super.fail(); } } @Override 
 * Note: If the call to {@link IFrameWriter#open()} failed, the {@link IFrameWriter#close()} must still be called by the producer. 
 throw th; 
 failException = new HyracksDataException(); 
 failException = new HyracksDataException(); 
 closeException = new HyracksDataException(); 
 closeException = new HyracksDataException(); 
 failException = new HyracksDataException(); 
 failException.addSuppressed(th); 
 closeException = new HyracksDataException(); 
 closeException.addSuppressed(th); 
 closeException = new HyracksDataException(); 
 closeException = new HyracksDataException(); 
 failException = new HyracksDataException(); 
 failException.addSuppressed(th); 
 throw new HyracksDataException(th); 
<|del|> 
<|del|> 
<|del|> 
 throw new HyracksDataException(th); 
<|del|> 
 throw new HyracksDataException(th); 
 throw new HyracksDataException(th); 
 throw new HyracksDataException(th); 
 // since we have two appenders, then we need to test each test twice 
 * appender.close() succeeds, throws exception, or throws error 
 appender.flush(writer, true); } catch (Throwable th) { closeException = new HyracksDataException(th); } try { 
 appender.flush(writer, true); } catch (Throwable th) { closeException = new HyracksDataException(th); } try { 
 throw new HyracksDataException(th); 
 try { 
 } catch (Exception cursorCloseException) { throw new IllegalStateException(cursorCloseException); } finally { writer.close(); 
 throw new HyracksDataException(th); 
<|del|> 
 throw new HyracksDataException(th); 
 } catch (Throwable th) { throw new HyracksDataException(th); 
 } catch (Throwable th) { throw new HyracksDataException(th); 
<|del|> 
 } catch (Throwable th) { throw new HyracksDataException(th); 
 } catch (Throwable th) { throw new HyracksDataException(th); 
 throw new HyracksDataException(th); 
 } catch (Throwable th) { throw new HyracksDataException(th); 
 openFieldNameLengths = Arrays.copyOf(openFieldNameLengths, openFieldNameLengths.length + DEFAULT_NUM_OPEN_FIELDS); 
 ARecordType resultType = (ARecordType) nestedRecordTypeLeft; ARecordType nestedRecordTypeRightCopy = (ARecordType) nestedRecordTypeRight; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * writer.fail() succeeds, throws exception, or throws error 
<|del|> 
<|del|> 
 public IControllerService getControllerService() { 
 appCtx = new NCApplicationContext(this, serverCtx, ctx, id, memoryManager, lccm); 
 public IControllerService getNodeControllerService() { 
 //unique ids < FIRST_AVAILABLE_USER_DATASET_ID are reserved for metadata indexes resource ids. 
 public void sendApplicationMessageToNC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; 
 public void sendApplicationMessageToNC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception { CCNCFunctions.SendApplicationMessageFunction fn = new CCNCFunctions.SendApplicationMessageFunction(data, deploymentId, nodeId); ipcHandle.send(-1, fn, null); 
 long createId() throws HyracksDataException; 
 synchronized (this) { this.notifyAll(); } 
 public void notifyFailure(long messageId) { synchronized (this) { this.notifyAll(); } 
 @Override public long createId() throws HyracksDataException { try { ResourceIdRequestResponseMessage reponse = null; //if there already exists a response, use it 
 synchronized (resourceIdResponseQ) { if (resourceIdResponseQ.size() > 0) { reponse = (ResourceIdRequestResponseMessage) resourceIdResponseQ.take(); } } 
 private void confirmDataverseCanBeDeleted(JobId jobId, String dataverseName) 
 confirmDatatypeIsUnusedByDatatypes(jobId, dataverseName, datatypeName); confirmDatatypeIsUnusedByDatasets(jobId, dataverseName, datatypeName); 
 private void confirmDatatypeIsUnusedByDatasets(JobId jobId, String dataverseName, String datatypeName) 
 private void confirmDatatypeIsUnusedByDatatypes(JobId jobId, String dataverseName, String datatypeName) 
 private List<String> getNestedComplexDatatypeNamesForThisDatatype(JobId jobId, String dataverseName, String datatypeName) throws Exception { 
 nodeGroupDatasets.add(set.getDatasetName()); 
 // Get datatype that uses this anonymous datatype (there is only one) 
<|del|> 
 * 
 IApplicationMessageCallback callback = callbacks.remove(absMessage.getId()); if (callback != null) { callback.deliverMessageResponse(absMessage); 
 boolean leftSubTreeInitialized = leftSubTree.initFromSubTree(join.getInputs().get(0)); boolean rightSubTreeInitialized = rightSubTree.initFromSubTree(join.getInputs().get(1)); if (!leftSubTreeInitialized || !rightSubTreeInitialized) { 
 // Sets up the nested plan for the groupby operator. 
 public static long getTreeIndexLSN(ITreeIndex treeIndex) throws HyracksDataException { 
 private final int partition; 
<|del|>
<|del|>
 // References to variables generated in the right branch of a left-outer-join cannot be inlined 
 * When this rule is fired, 
 * When this rule is fired, 
<|del|> 
 public String getStorageDirectoryName() { if (cluster != null) { return cluster.getStore(); 
<|del|> 
 * 
public interface IFeedAdapter extends IDatasourceAdapter { //TODO: delete this interface 
<|del|> 
 host = "127.0.0.1"; port = 19002; 
 * 
 * 
 * @param writer 
 * @throws Exception 
 /** * @return the record class */ 
 public void setRecordReader(IRecordReader<T> recordReader) throws Exception; 
<|del|> 
<|del|> 
<|del|> 
 private static final int NUMBER_OF_TUPLE_FIELDS = 1; 
 * adapter will run and how many threads per node. * 
 if (LOGGER.isInfoEnabled()) { LOGGER.info(feedUrl + " retrieved"); LOGGER.info(feedUrl + " has a title: " + feed.getTitle() + " and contains " + feed.getEntries().size() + " entries."); } 
 if (LOGGER.isInfoEnabled()) { LOGGER.info("\tEVENT: Feed Retrieved. URL = " + event.getUrlString()); } 
 String recEndString = configuration.get(ExternalDataConstants.KEY_RECORD_END); 
 return Status.class; 
 throw new IllegalArgumentException("no RSS URL provided"); 
public class ExternalDataConstants { //TODO: Remove unused variables. 
 conf.set(ExternalDataConstants.KEY_HADOOP_FILESYSTEM_URI, map.get(ExternalDataConstants.KEY_HDFS_URL).trim()); conf.set(ExternalDataConstants.KEY_HADOOP_FILESYSTEM_CLASS, DistributedFileSystem.class.getName()); 
 private void prepare() throws Exception { if (dataSourceFactory.isIndexible() && (files != null)) { ((IIndexibleExternalDataSource) dataSourceFactory).setSnapshot(files, indexingOp); 
 public boolean isIndexible(); 
 public boolean isIndexingOp(); 
<|del|> 
public class GenericAdapter implements IDataSourceAdapter { 
 public void open() throws HyracksDataException { 
 private ISerializerDeserializer<IAObject> intSerde = AqlSerializerDeserializerProvider.INSTANCE 
 private ISerializerDeserializer<IAObject> intSerde = AqlSerializerDeserializerProvider.INSTANCE 
 private final static byte nullByte = ATypeTag.NULL.serialize(); 
 throw new AsterixException("Unknown Record Id type: " + HDFSUtils.getRecordIdType(configuration)); 
 return (ExternalDataUtils.isDataSourceStreamProvider(configuration)) ? DataSourceType.STREAM : DataSourceType.RECORDS; 
 if (value[size - 1] != ExternalDataConstants.LF) { appendChar(ExternalDataConstants.LF); 
 this.file = new ExternalFile(); 
 reader.close(); 
<|del|> 
 if (LOGGER.isInfoEnabled()) { LOGGER.info(feedUrl + " retrieved"); LOGGER.info(feedUrl + " has a title: " + feed.getTitle() + " and contains " + feed.getEntries().size() + " entries."); } 
 if (LOGGER.isInfoEnabled()) { LOGGER.info("\tEVENT: Feed Retrieved. URL = " + event.getUrlString()); } 
 throw new AsterixException("Unrecognised input format: " + inputFormatParameter); 
<|del|>
 switch (ExternalDataUtils.getDataSourceType(configuration)) { case RECORDS: return DatasourceFactoryProvider.getRecordReaderFactory(configuration); case STREAM: return DatasourceFactoryProvider .getInputStreamFactory(configuration.get(ExternalDataConstants.KEY_STREAM), configuration); 
 return new HiveDataParserFactory(); case ExternalDataConstants.FORMAT_TWEET: return new TweetParserFactory(); case ExternalDataConstants.FORMAT_RSS: return new RSSParserFactory(); default: throw new AsterixException("Unknown data format"); 
public class GenericSocketFeedAdapter extends StreamBasedAdapter { 
public class GenericSocketFeedAdapterFactory implements IAdapterFactory { 
public class SocketClientAdapter implements IDataSourceAdapter { 
public class SocketClientAdapterFactory implements IAdapterFactory { 
 || adapterClassname.equalsIgnoreCase(ExternalDataConstants.ADAPTER_HDFS_CLASSNAME)) { 
 public static final String ALIAS_TWITTER_FIREHOSE_ADAPTER = "twitter_firehose"; 
 // Get a delimiter from the given configuration 
 return (aString.contains(ExternalDataConstants.EXTERNAL_LIBRARY_SEPARATOR) && aString.trim().length() > 1); 
 public static boolean isDataSourceStreamProvider(Map<String, String> configuration) { return configuration.containsKey(ExternalDataConstants.KEY_STREAM); 
<|del|> 
 * 
 * 
 public String getQualifiedTypeName() { 
<|del|> 
<|del|> 
 } pagesToWrite.clear(); 
<|del|> 
<|del|> 
 bufferCache.force(fileId,true); 
<|del|> 
<|del|>
 public TakeoverPartitionsRequestMessage(long requestId, String nodeId, String failedNode, Integer[] partitionsToTakeover) { 
 public void replayPartitionsLogs(Integer[] partitions, long lowWaterMarkLSN, String failedNode) throws IOException, ACIDException; 
 @AfterClass 
import org.apache.asterix.replication.functions.ReplicationProtocol; import org.apache.asterix.replication.functions.ReplicationProtocol.ReplicationRequestType; 
 @SuppressWarnings({ "unchecked" }) 
<|del|> 
<|del|> 
<|del|> 
 IBinaryHashFunction putHashFunc = ListItemBinaryHashFunctionFactory.INSTANCE.createBinaryHashFunction( buildItemTypeTag, ignoreCase); IBinaryHashFunction getHashFunc = ListItemBinaryHashFunctionFactory.INSTANCE.createBinaryHashFunction( 
 return (leftVal == rightVal); 
 public static boolean byteArrayEqual(IValueReference valueRef1, IValueReference valueRef2, int dataOffset) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 List<Index> indexes = mp.getDatasetIndexes(dataset.getDataverseName(), dataset.getDatasetName()); // Set the top operator pointer to the primary IndexInsertDeleteOperator 
 || index.getIndexType() == IndexType.LENGTH_PARTITIONED_NGRAM_INVIX) { // Create an expression per key 
 || index.getIndexType() == IndexType.LENGTH_PARTITIONED_NGRAM_INVIX) { // Create an expression per key 
 op0.getInputs().clear(); // Connect the last index update to the SINK 
<|del|> 
 Kind[] statementsArray = { Kind.DATAVERSE_DECL, Kind.DELETE, Kind.INSERT, Kind.UPSERT, Kind.UPDATE, Kind.DML_CMD_LIST, Kind.LOAD, Kind.CONNECT_FEED, Kind.DISCONNECT_FEED, Kind.SET, Kind.COMPACT, Kind.EXTERNAL_DATASET_REFRESH, Kind.RUN }; 
<|del|> 
 RUN 
<|del|> 
 outInput1.reset(); eval1.evaluate(tuple); fieldIndex = IntegerPointable.getInteger(outInput1.getByteArray(), 1); fieldValueType = recordType.getFieldTypes()[fieldIndex]; 
 private ArrayTupleBuilder nullTupleBuilder; 
 // we need to use the primary index opTracker and secondary indexes callbacks for insert/delete since the lock would // have been obtained through searchForUpsert operation 
 // prepare the tuple 
<|del|> 
<|del|> 
 public boolean stop() throws HyracksDataException; 
 protected AtomicBoolean closed = new AtomicBoolean(false); 
<|del|> 
<|del|> 
 private final String dataverseName; private final String adapterName; 
 this.dataverseName = namespace; this.adapterName = name; 
 return controller.resume(); 
 * or more contributor license agreements. See the NOTICE file 
 tupleAppender = new FrameTupleAppender(frame); 
<|del|> 
 * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * 
 * regarding copyright ownership. The ASF licenses this file 
<|del|> 
 * regarding copyright ownership. The ASF licenses this file 
 this.feedLogFile = FeedUtils .getAbsoluteFileRef(feedLogFileSplits[partition].getLocalFile().getFile().getPath(), feedLogFileSplits[partition].getIODeviceId(), ctx.getIOManager()) .getFile(); 
 } return new LocalFileSystemInputStream(path, expression, feedLogManager, isFeed); 
<|del|> 
 * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * 
 * regarding copyright ownership. The ASF licenses this file 
 * regarding copyright ownership. The ASF licenses this file 
 * regarding copyright ownership. The ASF licenses this file 
 if (ExternalDataUtils.isFeed(configuration)) { //TODO pass this value in the configuration and avoid this check for feeds 
 if (adapterName.equalsIgnoreCase(ExternalDataConstants.ALIAS_FILE_FEED_ADAPTER)) { 
 * regarding copyright ownership. The ASF licenses this file 
 public static void prepareFeed(Map<String, String> configuration, String dataverseName, String feedName) { 
 public static boolean keepDataSourceOpen(Map<String, String> configuration) { 
 * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * 
 * regarding copyright ownership. The ASF licenses this file 
 * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * 
 return; } 
 * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * 
public interface IMetadataEntity<T> extends Serializable { 
 * regarding copyright ownership. The ASF licenses this file 
 return true; 
 * They are safe as they don't print records. Printing records * using IserializerDeserializer can print incorrect results or throw exceptions. 
 * @param memBudgetInBytes * the given memory budgets to allocate the frames. If it less than 0, it will be treated as unlimited budgets 
 List<LogicalVariable> prevSecondaryKeyVars = null; List<Mutable<ILogicalExpression>> prevExpressions = null; List<Mutable<ILogicalExpression>> prevSecondaryExpressions = null; 
 List<LogicalVariable> prevSecondaryKeyVars = null; List<Mutable<ILogicalExpression>> prevExpressions = null; List<Mutable<ILogicalExpression>> prevSecondaryExpressions = null; 
 if (insertOp.getOperation() == Kind.UPSERT) { prevSecondaryKeyVars = new ArrayList<LogicalVariable>(); prevExpressions = new ArrayList<Mutable<ILogicalExpression>>(); prevSecondaryExpressions = new ArrayList<Mutable<ILogicalExpression>>(); 
 // in case of an Upsert operation, the currentTop is an assign which has the old secondary keys + the new secondary keys 
 public ITupleReference getLowKey(); 
<|del|> 
 public ITupleReference getLowKey() { return null; 
<|del|> 
 * Replay the logs that belong to the passed {@code partitions} starting from the {@code lowWaterMarkLSN} 
 LSMComponentLSNSyncTask syncTask = new LSMComponentLSNSyncTask(componentId, 
 //Currently we will not allow a node to perform remote recovery since another replica //already tookover its workload and might not resync correctly if there are on on-going //jobs on the replica. 
 //start recovery steps 
 throw new IllegalStateException("no ACTIVE remote replica(s) exists to perform remote recovery"); 
 long maxRemoteLSN = replicationManager.getMaxRemoteLSN(selectedRemoteReplicas.keySet()); 
 LSMIndexFileProperties fileProp = new LSMIndexFileProperties(filePath, fileSize, nodeId, lsmComponentFile, LSNByteOffset, requiresAck); 
 FileUtils.deleteQuietly(destFile); 
<|del|> 
 return !name.endsWith(LSM_COMPONENT_MASK_SUFFIX); 
 return name.equalsIgnoreCase(PersistentLocalResourceRepository.METADATA_FILE_NAME) || !name.startsWith("."); 
<|del|> 
 .isQualifiedForSpecialFlattening(subplanOp); 
 public void flush() throws HyracksDataException { // This operator needs to consume all of its input before sending its output to the next frame 
 startOfPipeline.flush(); 
 tupleAppender.flush(frameWriter, true); frameWriter.flush(); 
 } @Override public void flush() throws HyracksDataException { if (appender.getTupleCount() > 0) { appender.flush(writer, true); } writer.flush(); } 
 public IPushRuntime createPushRuntime(IHyracksTaskContext ctx) throws AlgebricksException, HyracksDataException; 
 int i = 0; for (Mutable<ILogicalOperator> opRef2 : op.getInputs()) { 
<|del|> 
 for (int i = 0; i < numberOfNonMaterializedOutputs; i++) { isOpen[i] = true; 
<|del|>
 String joinCondLeft = ""; // Step2. We employee the prefix fuzzy join strategy which needs initialize the mapping from the shared token to the // actually tuples of both side. left(right)InputPK targets at extracting those mapping from prefix tokens to tuples 
 public static final String ExternalLookupFunctionName = "external-lookup"; private final List<Object> variableTypes; 
<|del|> 
<|del|> 
 outputAppender.flush(outputWriter); 
 appender.flush(writer); 
 writer.flush(); 
 tupleAppender.flush(writers[i]); 
 tupleAppender.flush(writers[i]); 
<|del|> 
 appender.flush(writer); 
 appender.flush(writer); 
 public default void flush() throws HyracksDataException { throw new HyracksDataException("flush() is not supported in this IFrameWriter"); } 
 public synchronized void flush() throws HyracksDataException { flush = true; notifyAll(); 
 tupleAppender.flush(frameWriter); 
 producedVariables.addAll(op.getVariables()); 
 if (AsterixBuiltinFunctions.EXTERNAL_LOOKUP.equals(fid)) { 
 appender.flush(writer); 
 appender.flush(writer); 
 * Write the frame content to the given writer. * Clear the inner buffer after write if {@code clear} is <code>true</code>. 
 * @param clear indicate whether to clear the inside frame after writing or not. 
 * Write currently buffered records to {@code writer} then flushes {@code writer}. The inside frame is always cleared 
 public void write() throws HyracksDataException { 
<|del|> 
<|del|> 
<|del|> 
 //Flags added for test purpose 
<|del|> 
<|del|> 
 System.err.flush(); 
 // flush() is a no op since the frame writer's whole job is to write state data to a buffer 
<|del|> 
<|del|> 
 appender.flush(writer); 
 appender.flush(writer); 
 * A list to be filled with variables used in the logical operator op. 
 * @throws HyracksDataException 
 // Do nothing. 
 // Do nothing. 
 // Do nothing. 
 // Do nothing. 
 break; default: throw new AlgebricksException("Unsupported statement type " + stmtInsertUpsert.getKind()); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 ps.flush(); 
<|del|> 
 while (offset >= size && !eos && !failed && !flush) { 
 throw new HyracksDataException("unsupported operation"); 
 // INTERVAL // Interval asc and desc comparator factories are not the inverse of each other. // Thus, we need to specify the interval desc comparator factory for descending comparisons. 
 return INTERVAL_TAG_OFFSET; 
 private static final int INTERVAL_END_POINT_OFFSET = INTERVAL_START_POINT_OFFSET + Long.BYTES; private static final int INTERVAL_TAG_OFFSET = INTERVAL_END_POINT_OFFSET + Long.BYTES; 
 private IBinaryComparatorFactory intervalBinaryComparatorFactory(boolean ascending) { // Intervals have separate binary comparator factories, since asc is primarily based on start point // and desc is similarly based on end point. 
<|del|> 
 recordDescriptor, recordDescriptor, new HashSpillableTableFactory(hashFunctionFactories)); 
<|del|> 
 ISpillableTableFactory spillableTableFactory) { 
 void join(IFrameTupleAccessor accessorProbe, int tid, IFrameWriter writer) throws HyracksDataException { 
 throws HyracksDataException { 
 protected final int compare(int tp1, int tp2) throws HyracksDataException { 
<|del|> 
 if (fields != null) { 
<|del|> 
 private boolean visitTupleDiscardingOrCardinalityReduceOperator(ILogicalOperator op) throws AlgebricksException { 
 * @param context * the optimization context. * @param operator * the operator of interest. * @return a set of covering variables that can imply all subplan-local live variables at <code>operator</code>. * @throws AlgebricksException 
 LOGGER.info(message.key() + " was deleted."); 
 CouchbaseReader.this.close(); 
 if (message == POISON_PILL) { 
 this.reader = reader; this.LOGGER = LOGGER; 
 public static final long AUTO_RELEASE_AFTER_MILLISECONDS = 5000L; 
 return AsterixClusterProperties.INSTANCE.getClusterLocations(); 
 ArrayList<Short> listOfAssignedVBuckets = new ArrayList<Short>(); 
<|del|> 
 watcher.setController(controller); 
 public void setController(AbstractFeedDataFlowController controller) { this.controller = controller; 
 ncApplicationContext.setStateDumpHandler( new AsterixStateDumpHandler(ncApplicationContext.getNodeId(), lccm.getDumpPath(), lccm)); 
 public void setRecord(T t); 
<|del|> 
 public void emptyInbox() throws HyracksDataException { frameWriter.flush(); 
 public void emptyInbox() throws HyracksDataException { flush(); 
 private static final long STORAGE_TIME_TRACKING_FREQUENCY = 5000; 
 public int compare(IFrameTupleAccessor accessor0, int tIndex0, ITupleBufferPointAccessor bufferAccessor) 
<|del|>
<|del|> 
 public void set(T t); 
 public void set(T record) { 
 } coreOperator.wait(); 
<|del|> 
 } coreOperator.wait(); 
 producedVariables.addAll(op.getVariables()); 
 switch (tag) { case DATE: 
 break; case TIME: 
 throw new ParseException( 
 ((ADatePrinter) timeInstancePrinter).print(b, endOffset, endSize, ps); 
 ((ADatePrinter) timeInstancePrinter).print(b, endOffset, endSize, ps); 
 * 
<|del|> 
 private long parseIntervalSecondArgument(int startToken, ATypeTag parseType) 
 throw new ParseException(mismatchErrorMessage + objectType.getTypeName()); 
 private void parseInterval(ATypeTag typeTag, IAType objectType, DataOutput out) throws IOException { 
 private long parseIntervalSecondArgument(int startToken, ATypeTag parseType) throws IOException { int token = admLexer.next(); 
 return parseIntervalArgument(parseType); 
<|del|> 
 throw new ParseException("Interval argument not properly constructed."); 
 private List<LogicalVariable> hashFields; private INodeDomain domain; 
 public Object getSharedObject(); 
 return new PartitionDataWriter(ctx, nConsumerPartitions, edwFactory, recordDesc, tpcf.createPartitioner()); 
 return new PartitionWithMessageDataWriter(ctx, nConsumerPartitions, edwFactory, recordDesc, tpcf.createPartitioner()); 
 if (ctx.getSharedObject() == null) { synchronized (ctx) { if (ctx.getSharedObject() == null) { ctx.setSharedObject(ByteBuffer.allocate(MessagingFrameTupleAppender.MAX_MESSAGE_SIZE)); } } } 
 forwarder.initialize(ctx, writer); 
 public void parseUUIDString(String tokenImage) throws HyracksDataException { if (tokenImage.length() != UUID_CHARS) { throw new HyracksDataException("This is not a correct UUID value: " + tokenImage); 
 byte [] hexBytes = new byte[UUID_CHARS]; 
 private static int transformHexCharToInt(byte val) throws HyracksDataException { 
 StringBuilder result = new StringBuilder(UUID_CHARS); 
<|del|> 
 StringBuilder buf = new StringBuilder(AUUID.UUID_CHARS + 7); buf.append("uuid(\""); AUUID.appendLiteralOnly(b, s + 1, buf).append('"'); ps.print(buf.toString()); 
<|del|> 
 StringBuilder buf = new StringBuilder(AUUID.UUID_CHARS + 2); buf.append('"'); AUUID.appendLiteralOnly(b, s + 1, buf).append('"'); ps.print(buf.toString()); 
<|del|> 
<|del|> 
 int v1 = IntegerPointable.getInteger(out1.getByteArray(), out1.getStartOffset()); int v2 = IntegerPointable.getInteger(out2.getByteArray(), out2.getStartOffset()); 
 public IAggregateEvaluator createAggregateEvaluator(IHyracksTaskContext ctx) throws AlgebricksException; 
 public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws AlgebricksException; 
 public IUnnestingEvaluator createUnnestingEvaluator(IHyracksTaskContext ctx) throws AlgebricksException; 
 public ISerializedAggregateEvaluatorFactory createSerializableAggregateFunctionFactory( 
 public ISerializedAggregateEvaluatorFactory createSerializableAggregateFunctionFactory( 
 public IUnnestingEvaluatorFactory createUnnestingEvaluatorFactory(final IScalarEvaluatorFactory[] args) 
 public IAggregateEvaluatorFactory createAggregateEvaluatorFactory(final IScalarEvaluatorFactory[] args) 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private final IScalarEvaluator argEval = listEvalFactory.createScalarEvaluator(ctx); 
<|del|> 
 byte typeTag = serList[offset]; if (typeTag == ATypeTag.SERIALIZED_NULL_TYPE_TAG) { 
 IVariableTypeEnvironment env = new NonPropagatingTypeEnvironment(ctx.getExpressionTypeComputer(), ctx.getMetadataProvider()); 
 IVariableTypeEnvironment env = new NonPropagatingTypeEnvironment(ctx.getExpressionTypeComputer(), ctx.getMetadataProvider()); 
 public List<LogicalVariable> getInputVariables(int inputIndex) { return inputVars.get(inputIndex); 
 private void checkTypeConsistency(IVariableTypeEnvironment expected, List<LogicalVariable> expectedVariables, 
 AlgebricksConfig.ALGEBRICKS_LOGGER .warning("Type of two variables are not equal." + expectedVariables.get(i) + " is of type: " + expectedType + actualVariables.get(i) + " is of type: " + actualType); 
<|del|> 
 final ArrayBackedValueStorage abvs0 = new ArrayBackedValueStorage(); final ArrayBackedValueStorage abvs1 = new ArrayBackedValueStorage(); 
 final ICopyEvaluator eval0 = args[0].createEvaluator(abvs0); final ICopyEvaluator eval1 = args[1].createEvaluator(abvs1); 
 protected final int topK; 
<|del|> 
 // one primary + secondary indexes, choose the primary index directly. 
 private ILogicalOperator connectAll2ndarySearchPlanWithIntersect(List<ILogicalOperator> subRoots, 
 throw new Exception("Result for " + queryFile + " changed at line " + num + ":\n< " + lineExpected + "\n> "); 
<|del|> 
 LOGGER.info("Added library " + libraryName + " to Metadata"); 
<|del|> 
 FileUtils.deleteQuietly(destinationDir); destinationDir.mkdirs(); 
 throw new Exception("Couldn't unzip the file: " + libPath, e); 
 if (dataSourceFactory == null) { 
 public void setFeedLogManager(FeedLogManager feedLogManager); 
<|del|> 
 fuzzy.add(new InlineSubplanInputForNestedTupleSourceRule()); fuzzy.add(new RemoveRedundantVariablesRule()); 
 AsterixBuiltinFunctions.GET_ITEM, AsterixBuiltinFunctions.OPEN_RECORD_CONSTRUCTOR, AsterixBuiltinFunctions.FIELD_ACCESS_BY_INDEX, AsterixBuiltinFunctions.CAST_RECORD, AsterixBuiltinFunctions.CAST_LIST); 
<|del|> 
 public void computeAndSetTypeEnvironmentForOperator(ILogicalOperator op) throws AlgebricksException; 
 List<Mutable<ILogicalOperator>> inputOpRefsToUnion = new ArrayList<>(); 
 context.exitSubplan();; 
<|del|> 
 for (int i = 0; i < op.getOutputVars().size(); i++) { pp.substituteColumnVars(op.getInputVariables(0).get(i), op.getOutputVars().get(i)); } 
 * @see org.apache.asterix.om.function.IFunctionDescriptor#createEvaluatorFactory(org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory[]) 
 * @see org.apache.asterix.om.function.IFunctionDescriptor#createEvaluatorFactory(org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory[]) 
 // since a new LIMIT under a join can't generate the original result. 
 // one primary + secondary indexes, choose the primary index directly. 
 throw new AlgebricksException("The data source root should have the same operator type"); 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 case "lib": // expected format <dataverse-name> <library-name> <library-directory> //TODO: make this case work well with entity names containing spaces by looking for \" 
 LOGGER.warn("Failure during while operating a feed sourcec", th); 
 mBuffer.sendReport(frame); 
 * @param feedLogFileSplits * @param isFeed 
 stringBuilder.setLength(0); stringBuilder.append(record); stringBuilder.append(ExternalDataConstants.LF); stringBuilder.append(errorMessage); stringBuilder.append(ExternalDataConstants.LF); recordLogger.write(stringBuilder.toString()); recordLogger.flush(); 
 otherString.getChars(0, otherString.length(), value, 0); 
 aString.getChars(0, aString.length(), value, i); 
 * 
 * 
 * 
 // Will this check result in infinite recursion? How do I stop it? 
 // lookup with scope; this may side-affect state 
 * 
 // undefined and we're supposed to test for strict comparison, the 
 // Either take the number if it's the first, 
 // For this element of the list, make sure it is 
 // For this element of the list, make sure it is 
 // only one argument 
 // use the printpretty on arg0 to spew out 
 // absTime with no arguments returns the current time. 
 return aString.compareToIgnoreCase(o.aString); 
 // only try to process if the string is valid 
 return EvalResult.EVAL_FAIL.ordinal(); // NAC 
 // --- begin deletion methods 
 // already set by base class for this node; we shouldn't propagate 
 * 
 // digits as possible, which is why we don't use the 
 * 
 * based on the character content, * it's unparsed either as a quoted attribute or non-quoted attribute 
 /// Attribute reference node (attr, .attr, expr.attr) 
 /// ClassAd node 
 /// Expression list node 
 * 
 * 
 * 
 * 
 * 
 * 
 // pattern matching (regular expressions) 
 // turn the contents of an expression into a string 
 // tokenizeStringLiteral: Scans strings of the form " ... " or '...' 
 // tokenizePunctOperator: Tokenize puncutation and operators 
 // cut the token and return 
 * LexerSource that provide access to specific types of sources. 
 // ever put back a single character. 
 /* Creates an absolute time literal, from the string timestr, 
 /* Creates a relative time literal, from the string timestr, 
 /* Function which iterates through the string Str from the location 'index', *returning the index of the next digit-char 
 * which is the number of seconds since the epoch 
 /// List of supported operators 
 * 
 * 
 * 
 * 
 // if op is binary, but not associative or commutative, disallow splitting 
 // comparison between strings and non-exceptional non-string 
 // trap sigfpe and set the ClassAdExprFPE flag to true; on NT check the 
 char digit = text.charAt(source + 1); // is the next digit also 
 * 
 // Then we parse to see what the user wants. 
 String strVal = String.valueOf(val); int valFieldCount = strVal.length(); 
 String strMS = String.valueOf(ms); int msFieldCount = strMS.length(); 
<|del|> 
<|del|>
 return Boolean.FALSE; } 
<|del|>
<|del|>
<|del|> 
<|del|>
<|del|>
<|del|> 
<|del|> 
<|del|>
<|del|>
 * @param tokenCount the count of this token in a document , or a record, or something else. 
public class LogicalOperatorDeepCopyWithNewVariablesVisitor implements IQueryOperatorVisitor<ILogicalOperator, ILogicalOperator> { 
 * @param context,the 
<|del|> 
import org.apache.commons.lang3.mutable.Mutable; 
 * 
 FileReference file = ctx.getJobletContext() .createManagedWorkspaceFile(MaterializerTaskState.class.getSimpleName()); 
 SplitterMaterializerActivityNode sma = new SplitterMaterializerActivityNode( new ActivityId(odId, SPLITTER_MATERIALIZER_ACTIVITY_ID)); 
 fuzzy.add(new InlineSubplanInputForNestedTupleSourceRule()); fuzzy.add(new RemoveRedundantVariablesRule()); 
 throws AlgebricksException { 
<|del|> 
 ByteBuffer message = null; synchronized (ctx) { message = (ByteBuffer) ctx.getSharedObject(); if (message == null) { message = ByteBuffer.allocate(MessagingFrameTupleAppender.MAX_MESSAGE_SIZE); ctx.setSharedObject(message); } 
<|del|> 
 public static final byte NULL_FEED_MESSAGE = (byte) MessageType.NULL.ordinal(); public static final byte ACK_REQ_FEED_MESSAGE = (byte) MessageType.ACK_REQUEST.ordinal();; 
 @Override 
 int remainingFiles = job.getJobFiles().size(); 
<|del|> 
<|del|> 
<|del|> 
 sb.append("FailedToDeserializeField" + j); 
 allocated = 0; buffers.clear(); 
<|del|> 
 boolean insertTuple(int partition, byte[] byteArray, int[] fieldEndOffsets, int start, int size, 
 boolean insertTupleToSpilledPartition(int partition, byte[] byteArray, int[] fieldEndOffsets, int start, int size, 
 ITuplePointerAccessor getTupleAccessor(RecordDescriptor recordDescriptor); 
 private static final double FUDGE_FACTOR = 1.1; 
 private static final double FUDGE_FACTOR = 1.1; 
 public ISpillableTable buildSpillableTable(final IHyracksTaskContext ctx, int suggestTableSize, long dataBytesSize, 
 final FrameTuplePairComparator ftpcInputCompareToAggregate = new FrameTuplePairComparator(keyFields, intermediateResultKeys, comparators); 
 outRecordDescriptor, keyFields, intermediateResultKeys, null); 
 final ITuplePointerAccessor bufferAccessor = bufferManager.getTupleAccessor(outRecordDescriptor); 
 private BitSet spilledSet = new BitSet(numPartitions); private AtMostOneFrameForSpilledPartitionPolicy spillPolicy = new AtMostOneFrameForSpilledPartitionPolicy( bufferManager, spilledSet, ctx.getInitialFrameSize()); 
 private int getFirstEntryInHashTable(int partition) { return partition * entriesPerPartition; 
 private int getLastEntryInHashTable(int partition) { return Math.min(tableSize, (partition + 1) * entriesPerPartition); 
<|del|> 
 * @return true if it has output 
 * @return true if it has output 
 * The {@code accessor} and {@code tIndex} given the reference to the tuple to be inserted. 
 isFailed = true; 
 externalGroupBy = null; 
 throws HyracksDataException { return new ExternalGroupWriteOperatorNodePushable(ctx, new TaskId(new ActivityId(getOperatorId(), AGGREGATE_ACTIVITY_ID), partition), spillableTableFactory, partialRecDesc, outRecDesc, framesLimit, keyFields, firstNormalizerFactory, comparatorFactories, intermediateAggregateFactory); 
 private final INullWriter[] nullWriters; 
<|del|> 
<|del|> 
 private TuplePointer tempPtr = new TuplePointer(); // this is a reusable object to store the pointer,which is not used anywhere, // we mainly use it to match the corresponding function signature. 
 if (spilledStatus.get(pid)) { 
 if (isFailed){ state.hybridHJ.clearBuildTempFiles(); } else { ctx.setStateObject(state); if (LOGGER.isLoggable(Level.FINE)) { LOGGER.fine("OptimizedHybridHashJoin closed its build phase"); } 
 * @return a map from dataverse -> list of uninstalled libraries. 
 FileUtils.deleteQuietly(destinationDir); destinationDir.mkdirs(); 
 if (!installLibDir.getAbsolutePath().endsWith(LIBRARY_DIR_NAME)) { throw new HyracksDataException("Invalid library directory"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
import org.apache.commons.lang3.mutable.Mutable; 
 private final IHyracksTaskContext ctx; 
 protected FrameTupleAppender createTupleAppender(IHyracksTaskContext ctx) { 
<|del|> 
 init(false); 
 ByteBuffer message = (ByteBuffer) ctx.getSharedObject(); 
<|del|> 
<|del|> 
<|del|> 
 if (logType == LogType.FLUSH) { buffer.putInt(datasetId); 
 if (!feedLogManager.exists()) { 
 value = new char[increment]; 
 public int firstNonDigitChar() { 
<|del|> 
 return buffer; 
 /// List of supported operators 
 * 
 * 
 * 
 * 
 // same operators on both children . since op!=NO_OP, neither are op1, 
 // comparison between strings and non-exceptional non-string 
 // trap sigfpe and set the ClassAdExprFPE flag to true; on NT check the 
 * 
 // Then we parse to see what the user wants. 
 * 
 * 
 * 
 // We don't increment it until we use it. 
 * 
 // We have to be careful with substr() because with gcc 2.96, it likes to 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
<|del|>
<|del|>
 * 
<|del|>
<|del|>
<|del|>
 * 
 * 
 * 
 * 
 // We have to be careful with substr() because with gcc 2.96, it likes to 
 * 
 * 
 * 
 * 
 throw new HyracksDataException(th); 
<|del|> 
 // If reader is specified, we will use the selected reader. If format is // specified, we will assign a suitable reader for the format. 
<|del|> 
 if (position != length - 1) { System.arraycopy(value, position + 1, value, position, length - (position + 1)); 
 // PayloadLength: 1 byte 
 String[] lines = statement.trim().split("\n"); String[] command = lines[lines.length - 1].trim().split(" "); 
<|del|> 
 entry.setPublishedDate(DATE_PARSER.parse("2012-06-08")); 
 entry.setPublishedDate(DATE_PARSER.parse("2015-12-09")); 
 + "<p>For details check the <a href=\"https://rometools.jira.com/wiki/display/ROME/Change+Log#" + "ChangeLog-Changesmadefromv0.3tov0.4\">Changes Log for 0.3</a></p>"); 
 + "<p>For details check the <a href=\"https://rometools.jira.com/wiki/display/ROME/Change+Log#" + "ChangeLog-Changesmadefromv0.3tov0.4\">Changes Log for 0.3</a></p>"); 
 + "<p>For details check the <a href=\"https://rometools.jira.com/wiki/display/ROME/Change+Log#" + "ChangeLog-Changesmadefromv0.4tov0.5\">Changes Log for 0.4</a></p>"); 
 + "<p>For details check the <a href=\"https://rometools.jira.com/wiki/display/ROME/Change+Log#" + "ChangeLog-Changesmadefromv0.4tov0.5\">Changes Log for 0.4</a></p>"); 
 protected static boolean uninstallLibrary(String dataverse, String libraryName) 
 protected static void installLibraryIfNeeded(String dataverse, final File libraryDir, 
 LOGGER.info("Added library " + libraryName + " to Metadata"); 
<|del|> 
 protected static void registerLibrary(String dataverse, String libraryName, boolean isMetadataNode, File installLibDir) throws Exception { 
 protected static File getLibraryInstallDir() { 
<|del|> 
 public void setFeedLogManager(FeedLogManager feedLogManager); 
 LOGGER.warn("Failure during while operating a feed source", th); 
 private int maxRecordSize; // temporary until the big object in storage is solved 
 // TODO: fix handling of eod case with monitored buffers. 
 // metaTypes = {key(string), bucket(string), vbucket(int32), seq(long), cas(long), // creationTime(long),expiration(int32),flags(int32),revSeqNumber(long),lockTime(int32)} 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 return new TwitterFirehoseInputStreamProvider(configuration, ctx, partition); 
<|del|> 
<|del|> 
<|del|> 
 runningTestServers.put(port, server); 
 private ServerSocket serverSocket; private Thread listenerThread; 
 public static ITestServer createTestServer(String name, Integer port) throws Exception { switch (name) { 
 LOGGER.info("Result state cleanup instance successfully completed."); 
<|del|> 
 this.maxRecordSize = ((IAsterixPropertiesProvider) ctx.getJobletContext().getApplicationContext() .getApplicationObject()).getStorageProperties().getMemoryComponentPageSize() / 2; 
 * 
 * 
 * 
 * 
 * 
 LOGGER.error("NC message client failure", cause); 
 } future.channel().close(); 
 } // message fits // Do we have the full message? if (message.readableBytes() < currentMessageSize) { buffer.writeBytes(message, message.readableBytes()); return false; } else { buffer.writeBytes(message, currentMessageSize); return true; } 
 LOGGER.error("The NC messaging server encountered an error", th); 
<|del|> 
 //#. initialize DatasetIdFactory if it is not initialized. 
 HDFSCluster.getInstance().setup(); 
 } catch (Throwable th) { th.printStackTrace(); // There are two possibilities here: // 1. The socket was closed from the other end. // 2. Server.close() was called. 
<|del|> 
 * Insert the tuple from the tupleAccessor into the already spilled partition. * Usually the spilled partitions can have at most one frame to buffer the data. * 
 * Clear the memory occupation of the particular partition. 
 * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file 
 private TuplePointer tempPtr = new TuplePointer(); // this is a reusable object to store the pointer,which is not used anywhere. 
 private void closeAllSpilledPartitions(SIDE whichSide) throws HyracksDataException { 
 } System.err.println("Using the path: " + tempPath); 
<|del|> 
 LOGGER.error("NC message client failure", cause); 
 if (!future.isSuccess()) { LOGGER.error("NC message client failure", future.cause()); 
 } future.channel().close(); 
 private static final Logger LOGGER = Logger.getLogger(NCMessagingServer.class.getName()); private final int port; 
<|del|> 
 LOGGER.error("The NC messaging server encountered an error", th); 
 import org.apache.log4j.Logger; 
<|del|> 
<|del|> 
 stores.add(new Store(node.getId(), node.getMessagePort().toString(), nodeStores.toString())); 
<|del|> 
<|del|> 
<|del|> 
 if (!bagElements1.equals(bagElements2)) 
<|del|> 
 retainNull, dataset, jobGenParams.getIndexName(), lowKeyIndexes, highKeyIndexes, 
 metadataProvider, context, builder.getJobSpec(), unnestMapOp, opSchema, jobGenParams.getRetainInput(), retainNull, jobGenParams.getDatasetName(), dataset, jobGenParams.getIndexName(), 
 retainNull, dataset, jobGenParams.getIndexName(), keyIndexes, minFilterFieldIndexes, 
 List<LogicalVariable> sourceVars = null; // For a left outer join case, LEFT_OUTER_UNNEST_MAP operator is placed // instead of UNNEST_MAP operator. sourceVars = ((AbstractUnnestMapOperator) unnestMapOp).getVariables(); 
 dataset.getDataverseName(), dataset.getDatasetName(), retainInput, requiresBroadcast); 
 AccessMethodAnalysisContext analysisCtx, boolean retainInput, boolean retainNull, boolean requiresBroadcast, IOptimizationContext context) throws AlgebricksException { 
 op.getGroupByList().add(new Pair<LogicalVariable, Mutable<ILogicalExpression>>(newVar, new MutableObject<ILogicalExpression>(new VariableReferenceExpression(keyVar)))); 
 throw new AlgebricksException( "The subquery de-correlation rule should always be applied before index-access-method related rules."); 
 throw new AlgebricksException( "The subquery de-correlation rule should always be applied before index-access-method related rules."); 
<|del|> 
 } 
<|del|> 
 LOGGER.info("Result state cleanup instance successfully completed."); 
 LogicalVariable dataVar = dataSource.getDataRecordVariable(allVars); LogicalVariable metaVar = dataSource.getMetaVariable(allVars); 
 for (Pair<OrderOperator.IOrder, Mutable<ILogicalExpression>> orderExpression : order .getOrderExpressions()) { 
 OptimizableFuncExpr newOptFuncExpr = new OptimizableFuncExpr(funcExpr, new LogicalVariable[] { fieldVarExpr1, fieldVarExpr2 }, new ILogicalExpression[] { arg3 }, 
 funcArgs.add( new MutableObject<ILogicalExpression>(AccessMethodUtils.createInt32Constant(searchKeyType.ordinal()))); 
 assignSearchKeys.getInputs().add(new MutableObject<ILogicalOperator>( OperatorManipulationUtil.deepCopyWithExcutionMode(dataSourceOp.getInputs().get(0).getValue()))); 
 op.getGroupByList().add(new Pair<LogicalVariable, Mutable<ILogicalExpression>>(newVar, new MutableObject<ILogicalExpression>(new VariableReferenceExpression(keyVar)))); 
 ILogicalOperator assignOp = new AssignOperator(assignVar, new MutableObject<ILogicalExpression>(ConstantExpression.TRUE)); 
 AbstractUnnestMapOperator primaryIndexUnnestOp = null; 
 List<Mutable<ILogicalExpression>> primaryIndexFuncArgs = new ArrayList<Mutable<ILogicalExpression>>(); 
 IAType metaItemType = metadataProvider.findType(ds.getMetaItemTypeDataverseName(), ds.getMetaItemTypeName()); 
<|del|> 
 public ProjectOperator(List<LogicalVariable> variables, List<Mutable<ILogicalExpression>> expressions) { 
 public static String prettyPrintPlan(ILogicalPlan plan) throws AlgebricksException { 
 if (expr.getExpressionTag() != LogicalExpressionTag.VARIABLE && expr.getExpressionTag() != LogicalExpressionTag.CONSTANT) { 
 private Reader in; //the underlying buffer 
 .getVirtualBufferCaches(datasetID, ioDeviceNum); 
 vbcs = initializeVirtualBufferCaches(ioDeviceNum); 
 .getVirtualBufferCaches(index.getDatasetId().getId(), metadataPartition.getIODeviceNum()); 
 List<IVirtualBufferCache> virtualBufferCaches = runtimeContextProvider.getVirtualBufferCaches(datasetID, ioDeviceNum); 
 List<IVirtualBufferCache> virtualBufferCaches = runtimeContextProvider.getVirtualBufferCaches(datasetID, ioDeviceNum); 
<|del|> 
 final int partition = ctx.getTaskAttemptId().getTaskId().getPartition(); final int ioDeviceNum = fileSplitProvider.getFileSplits()[partition].getIODeviceId(); 
<|del|> 
 Set<String> nodeNames = AsterixAppContextInfo.getInstance().getMetadataProperties().getNodeNames(); Set<String> nodeNamesClone = new HashSet<String>(); for (String node : nodeNames) { nodeNamesClone.add(node); } 
 List<LogicalVariable> additionalNonFilteringFields, RecordDescriptor recordDesc, JobGenContext context, JobSpecification jobSpec, boolean bulkload) throws AlgebricksException; 
 List<LogicalVariable> additionalNonFilteringFields, RecordDescriptor recordDesc, JobGenContext context, JobSpecification jobSpec) throws AlgebricksException; 
 variables.add(v); 
 LogicalVariable prevPayload) { 
 private boolean rewritten = false; private List<Pair<LogicalVariable, LogicalVariable>> substituteVariable = new ArrayList<>(); 
 requiredRecordType = (ARecordType) dataSource.getItemType(); 
 IAType requiredRecordType = dataSource.getItemType(); 
 } return res; 
 for (int i = 0; i < n / 2; i++) { 
 throw new AlgebricksException("No positional variables are allowed over feeds."); 
 * @return an instance of the {@code FeedAdapter} in use. 
 public void reset(IRecordReader<?> reader) throws IOException; 
<|del|> 
<|del|> 
<|del|> 
 rwm.appendPk(tb); 
 } catch (IOException | AsterixException e) { 
 ARecordType recType = (ARecordType) findType(dataset.getItemTypeDataverseName(), dataset.getItemTypeName()); 
 typeList.add(getSubFieldType(field)); 
<|del|> 
<|del|> 
<|del|> 
<|del|>
 if (rqd.getPartitioningProperty() != null && rqd.getPartitioningProperty().isSingle()) { 
<|del|> 
 Pair<IOperatorDescriptor, AlgebricksPartitionConstraint> runtimeAndConstraints = mp.getInsertRuntime( dataSource, propagatedSchema, typeEnv, primaryKeys, payload, additionalFilteringKeys, additionalNonFilterVars, inputDesc, context, spec, true, -1); 
 throw new IllegalStateException(e); 
 opLoad.getDataSource(), opLoad.getOperation(), opLoad.getPrevRecordVar())); 
<|del|> 
<|del|> 
 DataSourceScanOperator scanOp = (DataSourceScanOperator) op; ILogicalExpressionReferenceTransformWithCondition inputTransfomer = visit(op.getInputs().get(0)); AqlDataSource dataSource = (AqlDataSource) scanOp.getDataSource(); 
<|del|> 
 throw new AlgebricksException("load dataset is not supported on Datasets with Meta records"); 
 PlanTranslationUtil.prepareVarAndExpression(keyFieldName, payloadVar, pkVars, pkExprs, varRefsForLoading, 
 PlanTranslationUtil.prepareVarAndExpression(additionalFilteringField, payloadVar, additionalFilteringVars, 
 throw new AlgebricksException( "insert into dataset is not supported on Datasets with Meta records"); 
 throw new AlgebricksException( "upsert into dataset is not supported on Datasets with Meta records"); 
 throw new AlgebricksException( "delete from dataset is not supported on Datasets with Meta records"); 
 PlanTranslationUtil.replaceFieldAccessWithMetaKey(assignExpr); 
 String queryFileShort = queryFile.getPath().substring(PATH_QUERIES.length()).replace(SEPARATOR.charAt(0), '/'); 
<|del|> 
 private CounterTimerTupleForwarder(int batchSize, long batchInterval) { 
 private RateControlledTupleForwarder(long interTupleInterval) { 
 private static final long MEMORY_AVAILABLE_POLL_PERIOD = 1000; // 1 second 
 String inputFormat = HDFSUtils.getInputFormatClassName(configuration); 
 String parserFactoryName = configuration.get(ExternalDataConstants.KEY_DATA_PARSER); 
 throw new AsterixException("Failed to create stream factory", e); 
 throw new AsterixException("Failed to create record reader factory", e); 
 throw new AsterixException("Failed to create an external parser factory", e); 
 lsmAccessor.forceInsert(tuple); 
<|del|> 
<|del|> 
<|del|> 
 Pair<ILogicalExpression, Mutable<ILogicalOperator>> eo = aqlExprToAlgExpression(ve.getExpr(), topOp); 
<|del|> 
 throw new AlgebricksException( dataset.getDatasetName() + ": load dataset is not supported on Datasets with Meta records"); 
<|del|> 
<|del|> 
<|del|> 
 public abstract boolean handleException(Throwable th); 
 /** * @return a list of external files being accessed */ 
 public boolean handleException(Throwable th); 
 public void reset() throws IOException { in.reset(); 
 return in.read(); 
 socket.close(); 
<|del|> 
 this.keys = isFeed ? new HashMap<WatchKey, Path>() : null; this.logManager = logManager; 
 }; 
 throws HyracksDataException { 
<|del|> 
 throws HyracksDataException { 
 LogicalVariable payLoadVar, List<LogicalVariable> additionalFilterKeyFields, List<LogicalVariable> additionalNonFilteringFields, RecordDescriptor recordDesc, JobGenContext context, JobSpecification jobSpec, boolean bulkload, int nodeId) throws AlgebricksException; 
 JobGenContext context, JobSpecification jobSpec, INodeDomain domain) throws AlgebricksException; 
 JobGenContext context, JobSpecification spec, boolean bulkload, INodeDomain domain) throws AlgebricksException; 
 JobGenContext context, JobSpecification spec, INodeDomain domain) throws AlgebricksException; 
 LogicalVariable payLoadVar, List<LogicalVariable> additionalFilterFields, List<LogicalVariable> additionalNonFilteringFields, RecordDescriptor recordDesc, JobGenContext context, JobSpecification jobSpec, int nodeId) throws AlgebricksException; 
 RecordDescriptor inputDesc, JobGenContext context, JobSpecification spec, INodeDomain domain) 
 additionalNonFilterVars, inputDesc, context, spec, true, -1); 
 additionalFilteringKeys, filterExpr, inputDesc, context, spec, true, null); 
 ((UnorderedPartitionedProperty) r.getPartitioningProperty()).setNodeDomain(domain); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (!(other instanceof ActiveActivity)) { 
 * 
 /** The (singleton) instance of IActiveManager **/ 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 CompiledInsertStatement compiledInsert = (CompiledInsertStatement) stmt; if (compiledInsert.getReturnRecord() || compiledInsert.getReturnField() != null) { 
 new AString(compiledInsert.getReturnField().get(0))))); 
<|del|> 
<|del|> 
 } //TODO: Remove the thread.sleep calls 
 * 
 * 
 * 
 IDatasetDetailsDecl idd = new InternalDetailsDecl(toIndex.getKeyFieldNames(), toIndex.getKeyFieldSourceIndicators(), false, null, toDataset.getDatasetDetails().isTemp()); 
 * 
 * 
 * 
<|del|> 
 if (!Files.isDirectory(path)) { validateAndAdd(path, expression, files); 
<|del|> 
<|del|> 
 private final boolean quietly; 
 * 
<|del|> 
<|del|> 
<|del|> 
 Map<String, ClusterPartition[]> partitions = AsterixAppContextInfo.getInstance().getMetadataProperties() .getNodePartitions(); 
 Map<String, ClusterPartition[]> partitions = AsterixAppContextInfo.getInstance().getMetadataProperties() .getNodePartitions(); 
import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; 
<|del|> 
 public void registerFeedEventSubscriber(FeedConnectionId connectionId, IFeedLifecycleEventSubscriber subscriber) { 
 FeedLifecycleListener.INSTANCE.registerFeedEventSubscriber(feedConnId, eventSubscriber); subscriberRegistered = true; 
 public void registerFeedEventSubscriber(FeedConnectionId connectionId, IFeedLifecycleEventSubscriber subscriber); 
 * 
 ILSMIndexAccessor accessor = index.createAccessor(NoOpOperationCallback.INSTANCE, 
 ILSMIndexAccessor accessor = index.createAccessor(NoOpOperationCallback.INSTANCE, 
 ILSMIndexAccessor accessor = index.createAccessor(NoOpOperationCallback.INSTANCE, 
 * 
 * @return true if there is an ongoing merge operation, false otherwise. 
 * @return true if there is an ongoing merge operation, false otherwise. 
 ILSMIndexAccessor accessor = index.createAccessor(NoOpOperationCallback.INSTANCE, 
 * @return true if there is an ongoing merge operation, false otherwise. 
 * @return true if there is an ongoing merge operation, false otherwise. 
 * 
 * 
 * 
<|del|> 
<|del|> 
 throw new AsterixException("Unsupported interval type."); 
 throw new AsterixException("Unsupported interval type."); 
 throw new AsterixException("Unsupported interval type."); 
 throw new AsterixException("Unsupported interval type."); 
 private final IBinaryComparator circleBinaryComp = ACirclePartialBinaryComparatorFactory.INSTANCE 
 case INT16: 
 if (intervalType0 != intervalType1) { 
<|del|> 
<|del|> 
 return AsterixBuiltinFunctions.INTERVAL_MET_BY; 
 if (interval0.getType() != interval1.getType()) { 
 if (intervalType0 != intervalType1) { 
<|del|> 
 * A work which is run at CC startup for each NC specified in the configuration file. * It contacts the NC service on each node and passes in the NC-specific configuration. 
 * An implementation of IApplicationConfig which is backed by Ini4j. 
 * Some utility functions for reading Ini4j objects with default value.s 
<|del|>
 * Stand-alone process which listens for configuration information from the * CC and starts an NC. Intended to be a constantly-running service. 
 * Command-line arguments for NC Service. 
 private ComparisonHelper ch = new ComparisonHelper(); 
 throw new AsterixException("Unsupported interval type: " + getTypeTag() + "."); 
 KVReader.this.run(); 
 connection.subject().toBlocking().forEach(new Action1<DCPRequest>() { 
 Reflections reflections = new Reflections(evaluatorPackagePrefix); 
 private Set<String> createdEvaluatorClassNames = new HashSet<>(); private String ownerPrefix; 
 private final Set<String> createdEvaluatorFactoryClassNames = new HashSet<>(); private String ownerPrefix; 
<|del|> 
<|del|> 
<|del|> 
 * 5) WAIT_LOG_SIZE: 14 bytes (Header1(6) + Tail(8)) * --> WAIT_LOG only requires LogType Field, but in order to conform the log reader protocol 
 */ @Override 
<|del|> 
 //release all locks held by this actor (which is a thread) by flushing partial frame. boolean tryLockSucceed = lockManager.tryLock(jobThreadId, datasetId, pkHash, LockMode.X, txnCtx); if (!tryLockSucceed) { 
 //release all locks held by this actor (which is a thread) by flushing partial frame. boolean tryLockSucceed = lockManager.tryLock(jobThreadId, datasetId, pkHash, LockMode.X, txnCtx); if (!tryLockSucceed) { 
<|del|> 
 + entityHashValue + " not found for job " + jobId + " in thread " 
 logRecord.setReplicated(logRecord.getLogSource() == LogSource.LOCAL && logRecord.getLogType() == LogType.WAIT); 
<|del|> 
<|del|> 
 * The right input is broadcast and the left input can be partitioned in any way. 
 throw new AlgebricksException("First argument should be String Type, but it is " + tag0); 
 throw new AlgebricksException("Second argument should be String Type, but it is " + tag1); 
<|del|> 
<|del|> 
<|del|> 
 address = InetAddress.getLoopbackAddress().getHostAddress(); 
 oos.writeUTF(NC_MAGIC_COOKIE); 
<|del|> 
 numNestedSecondaryKeFieldsConsideringPointMBR, secondaryRecDescConsideringPointMBR); 
 logRecord.setReplicated(logRecord.getLogSource() == LogSource.LOCAL && logRecord.getLogType() != LogType.WAIT); 
 * 
 * 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public static final long NILL = -1L; 
 enum RecordReadStatus { 
<|del|> 
 void ensureCapacity(IMetaDataPageManager freePageManager, ITreeIndexMetaDataFrame metaFrame, IBufferCache bufferCache, ITupleReference tuple) throws HyracksDataException; 
 strBuilder.append("smFlagOff: " + smFlagOff + "\n"); 
<|del|> 
<|del|> 
 public void split(ITreeIndexFrame rightFrame, ITupleReference tuple, ISplitKey splitKey, IMetaDataPageManager freePageManager, ITreeIndexMetaDataFrame metaFrame, IBufferCache bufferCache) 
 protected static final int nextLeafOff = flagOff + 1; // 22 protected static final int supplementalNumPagesOff = nextLeafOff + 4; // 26 protected static final int supplementalPageIdOff = supplementalNumPagesOff + 4; // 30 
<|del|> 
 // TODO(mblow): make page size available to avoid calculating it int pageSize = isLargePage() ? buf.capacity() / (getSupplementalNumPages() + 1) : buf.capacity(); 
 setLargeFlag(true); 
 configureLargePage(framePagesOld + deltaPages - 1, freePageManager.getFreePageBlock(metaFrame, framePagesOld + deltaPages - 1)); 
<|del|> 
 ICachedPage smPage = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, pageId), false, largePageHelper); 
 ICachedPage newLeftNode = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, newLeftId), true, largePageHelper); 
 ICachedPage rightNode = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, rightPageId), true, largePageHelper); 
 ICachedPage rightNode = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, rightPageId), true, largePageHelper); 
 ctx.interiorFrame.split(rightFrame, ctx.splitKey.getTuple(), ctx.splitKey, freePageManager, ctx.metaFrame, bufferCache); 
 final int multiplier = (int) Math.ceil((double) tupleSize / (bufferCache.getPageSize() - headerSize)); 
 protected void propagateBulk(int level, List<ICachedPage> pagesToWrite) throws HyracksDataException, TreeIndexException { 
 throw new TreeIndexException("Space required for record (" + tupleBytes + ") larger than maximum acceptable size (" + interiorFrame.getMaxTupleSize(BTree.this.bufferCache.getPageSize()) + ")"); 
 ICachedPage nextLeaf = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, nextLeafPage), false, BTreeLargeFrameHelper.INSTANCE); 
 ICachedPage nextLeaf = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, nextLeafPage), false, BTreeLargeFrameHelper.INSTANCE); 
<|del|> 
 INSUFFICIENT_SPACE, SUFFICIENT_CONTIGUOUS_SPACE, SUFFICIENT_SPACE, SUFFICIENT_INPLACE_SPACE, EXPAND, TOO_LARGE 
 protected static final int levelOff = totalFreeSpaceOff + 4; // 20 protected static final int flagOff = levelOff + 1; // 21 
 public void addFreePageBlock(ITreeIndexMetaDataFrame metaFrame, int startingPage, int count) throws HyracksDataException { 
 ICachedPage rootNode = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, rootPage), true, largePageHelper); 
 ICachedPage rootNode = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, rootPage), false, largePageHelper); 
 ICachedPage newRoot = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, rootPage), true, largePageHelper); 
 ctx.interiorFrame.split(rightFrame, tuple, ctx.splitKey, freePageManager, ctx.metaFrame, bufferCache); 
 ctx.leafFrame.split(rightFrame, tuple, ctx.splitKey, freePageManager, ctx.metaFrame, bufferCache); 
 break; 
 ioManager.syncRead(fInfo.getFileHandle(), (long) helper.getSupplementalBlockPageId(cPage) * pageSize, cPage.buffer); 
 ioManager.syncRead(fInfo.getFileHandle(), (long) helper.getSupplementalBlockPageId(cPage) * pageSize, cPage.buffer); 
<|del|> 
 bufferCache.addPage(cPage); numPages.getAndAdd(multiplier); return cPage; 
 ICachedPage page = bufferCache.pin(BufferedFileHandle.getDiskPageId(btreeFileId, 0), false, BTreeLargeFrameHelper.INSTANCE); 
 ICachedPage page = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, pageId), false, BTreeLargeFrameHelper.INSTANCE); 
 * @throws InterruptedException 
 throw new HyracksDataException("attempt to register to a failed feed data provider", rootFailureCause); 
 throw new HyracksDataException("attempt to register to a failed feed data provider", rootFailureCause); 
 * Fix. What should be done?: * 0. mark failure so no one can subscribe or unsubscribe. 
 * 2. when fail() is called, call fail on all subscribers 
 * 2. when fail() is called, call fail on all subscribers 
 innerCollector.fail(); 
<|del|> 
 * Runnables used for unit tests 
 TemplateHelper.INSTANCE.processFile(new File(inputFiles.getDirectory(), file), new File(outputDir, file.replace(".template", ""))); 
 public static final String fooBAR = "yeah this line is like way too long, but i just need to see how existing " + "failures will be reported."; 
 private static final FunctionInfoRepository registeredFunctions = new FunctionInfoRepository(); 
 public static final String FOO_BAR = "yeah this line is like way too long, but i just need to see how existing " + 
 public static final String FOO_BAR = "yeah this line is like way too long, but i just need to see how existing " 
 this.clusterStatePath = ZooKeeperService.ASTERIX_INSTANCE_BASE_PATH + File.separator + clusterName + ZooKeeperService.ASTERIX_INSTANCE_STATE_PATH; this.zk = zk; 
 public static final String fooBAR = "yeah this line is like way too long, but i just need to see how existing " + "failures will be reported."; 
 result.put(e.getKey(), new NodeControllerInfo(e.getKey(), NodeStatus.ALIVE, e.getValue().getDataPort(), e.getValue().getDatasetPort())); 
 wait(duration); 
 * TODO: Add Failure cases unit tests for this class 
 ByteBuffer next = (frame.capacity() <= framePool.getMaxFrameSize()) ? getFreeBuffer(frame.capacity()) : null; 
 private boolean poisoned = false; 
 public synchronized ByteBuffer retrieve() throws InterruptedException { 
 if (buffer != null) { 
<|del|> 
 Assert.assertNotNull(hde); 
 LOGGER.info("nextFrame() called. inputHandler is in mode: " + mode.toString()); 
 LOGGER.info("starting discard(frame)"); 
 LOGGER.info("Spilling to disk is enabled. Will try that"); 
 LOGGER.info("Spilling to disk is disabled. Will try to get a buffer"); 
 LOGGER.info("Was able to get a buffer"); 
 LOGGER.info("in discard(frame). Discard allowance has been consumed. --> Stalling"); 
 LOGGER.info("in discard(frame). So far, I have discarded " + numDiscarded); 
 LOGGER.info("Spilling is disabled --> discardOrStall(frame)"); 
 LOGGER.info("Discard is disabled --> stall(frame)"); 
 LOGGER.info("in stall(frame). So far, I have stalled " + numStalled); 
 LOGGER.info("Producer is waking up consumer"); 
 LOGGER.info("in stall(frame). Spilling is disabled. We will subscribe to frame pool"); 
 LOGGER.info("stall(frame) has been completed. Notifying the consumer that a frame is ready"); 
 LOGGER.info("Producer is waking up consumer"); 
 notifyMemoryConsumer(); 
 notifyMemoryConsumer(); 
 // Out of memory. we switch to next mode as per policy 
 notifyMemoryConsumer(); 
 LOGGER.info("Producer is waking up consumer"); 
 notifyDiskConsumer(); 
 notifyDiskConsumer(); 
 LOGGER.info("Consumer is going to sleep"); 
 LOGGER.info("Consumer is waking up"); 
 LOGGER.info("FrameAction: My subscription is being answered"); 
 LOGGER.info("FrameAction: Waking up waiting threads"); 
 LOGGER.info("FrameAction: Attempting to get allocated buffer"); 
 LOGGER.info("FrameAction: Allocated buffer is not ready yet. I will wait for it"); 
 LOGGER.info("FrameAction: Awoken Up"); 
<|del|> 
<|del|> 
<|del|> 
 buffer = get(); 
 buffer = get(frameAction.getSize()); 
<|del|> 
<|del|> 
<|del|> 
 e.printStackTrace(); cause = e; 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(WAIT_DURATION); 
 wait(openDuration); 
 wait(nextDuration); 
 wait(flushDuration); 
 wait(failDuration); 
 wait(closeDuration); 
 if (LOGGER.isLoggable(Level.SEVERE)) { LOGGER.severe("Preparing new log file was interrupted"); } Thread.currentThread().interrupt(); 
 if (txnLogFileId2ReaderCount.containsKey(id) && txnLogFileId2ReaderCount.get(id) > 0) { continue; 
 if (txnLogFileId2ReaderCount.containsKey(id) && txnLogFileId2ReaderCount.get(id) > 0) { continue; 
 Thread.currentThread().interrupt(); 
 if (!fillLogReadBuffer()) { throw new IllegalStateException( "Could not read LSN(" + LSN + ") from log file id " + logFile.getLogFileId()); } 
<|del|> 
 if (firstLSN == TransactionManagementConstants.LogManagerConstants.TERMINAL_LSN || firstLSN > lastLSN) { 
 IAType actualType = ((AUnionType) type).getActualType(); if (actualType.getTypeTag() == ATypeTag.BOOLEAN || actualType.getTypeTag() == ATypeTag.ANY) { 
 argsForNotFunction.add(new MutableObject<ILogicalExpression>(new ScalarFunctionCallExpression( FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.IS_MISSING), args))); 
 if (!NonTaggedFormatUtil.isOptional(reqFieldType)) { continue; 
 case NULL: 
 IMissingWriterFactory nullWriterFactory, IModificationOperationCallbackFactory modificationOpCallbackProvider, 
 return new LookupAdapter<>(dataParser, reader, inRecDesc, ridReader, retainInput, retainMissing, 
<|del|> 
 if (numberOfitems <= 0) { break; } if (!fixedSize) { 
 if (numberOfitems <= 0) { break; } if (!fixedSize) { 
 externalFilesIndexDataFlowHelperFactory, null, propagateInput, retainMissing, missingWriterFactory, null, searchOpCallbackFactory, null); 
 } // union AUnionType unionType = (AUnionType) type; if (!unionType.isNullableType()) { return i; } 
 AUnionType unionType = (AUnionType) recordType.getFieldTypes()[i]; 
 actualKeyType = ((AUnionType) keyType).getActualType(); 
 public void serialize(AMissing instance, DataOutput out) throws HyracksDataException { // A missing value only has a typetag in its serialized form. 
 public void serialize(IAObject instance, DataOutput out) throws HyracksDataException { // A null value only has a typetag in its serialized form. 
 case MISSING: 
<|del|> 
 private TypeCastUtils() { } 
 List<IAType> unionList = new ArrayList<>(); 
 if (currentType != null && !type.equals(currentType)) { any = true; break; 
 return null; 
 case ANY: 
 case UNION: 
 case UNION: 
<|del|> 
 private static final String ERR_MSG = "Aggregator is not implemented for "; 
 * case 2: we return the non-missing item type in the original union if there are only missing * and it in the original union. 
 List<IAType> items = new ArrayList<>(); 
 private static final String ERR_MSG = "Arithmetic operations are not implemented for "; 
 case DOUBLE: 
 case DOUBLE: 
 throw new NotImplementedException(ERR_MSG + t2.getTypeName()); 
 case FLOAT: 
 case FLOAT: 
 throw new NotImplementedException(ERR_MSG + t2.getTypeName()); 
 case INT64: 
 case INT64: 
 throw new NotImplementedException(ERR_MSG + t2.getTypeName()); 
 case INT32: 
 case INT32: 
 throw new NotImplementedException(ERR_MSG + tag2); 
 case INT16: 
 throw new NotImplementedException(ERR_MSG + tag2); 
 case INT8: 
 case INT8: 
 throw new NotImplementedException(ERR_MSG + tag2); 
 case ANY: 
 throw new NotImplementedException(ERR_MSG + tag2); 
 throw new NotImplementedException(ERR_MSG + tag2); 
 break; case DATE: 
 break; case DATE: 
 throw new NotImplementedException(ERR_MSG + tag2); 
 case TIME: 
 throw new NotImplementedException(ERR_MSG + tag2); 
 case DATETIME: 
 throw new NotImplementedException(ERR_MSG + tag2); 
 case DURATION: 
 throw new NotImplementedException(ERR_MSG + tag2); 
 case YEARMONTHDURATION: 
 case YEARMONTHDURATION: 
 case DAYTIMEDURATION: 
 case DAYTIMEDURATION: 
 default: throw new NotImplementedException(ERR_MSG + tag2); 
 default: throw new NotImplementedException(ERR_MSG + tag1); 
 private static final String ERR_MSG = "Aggregator is not implemented for "; 
 default: throw new NotImplementedException(ERR_MSG + tag); 
 IAType type; 
 default: throw new NotImplementedException(ERR_MSG + tag); 
 default: 
<|del|> 
 public static final IResultTypeComputer INSTANCE = new SwitchCaseComputer(); 
 private SwitchCaseComputer() { } 
 private SwitchCaseComputer() { } 
 private SwitchCaseComputer() { } 
 private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; 
 private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; 
 private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; 
 @FunctionalInterface 
<|del|> 
 default: 
 List<IAType> unionList = new ArrayList<>(); 
 List<IAType> unionList = new ArrayList<>(); 
 List<IAType> unionList = new ArrayList<>(); 
 } // union AUnionType unionType = (AUnionType) type; if (unionType.isUnknownableType()) { return true; } 
 ABoolean b; 
<|del|> 
 case UNORDEREDLIST: 
 case UNORDEREDLIST: 
 default: 
 default: 
<|del|> 
 long numGrams = usePrePost ? strLen + gramLen - 1 : strLen - gramLen + 1; 
 double distance; 
 result.setValue(1L + indexOf(textPtr.getByteArray(), textPtr.getContentStartOffset(), 
 int from = fromIndex; if (from < 0) { from = 0; 
 return from; 
 ABoolean res = compareIntervals(il, interval0, interval1) ? ABoolean.TRUE : ABoolean.FALSE; 
 aDatetime .setValue(AInt16SerializerDeserializer.getShort(bytes, offset + 1) * 1000l); 
 aDatetime.setValue(AInt32SerializerDeserializer.getInt(bytes, offset + 1) * 1000l); 
 aDatetime.setValue(AInt64SerializerDeserializer.getLong(bytes, offset + 1) * 1000l); 
 aDatetime.setValue(AInt64SerializerDeserializer.getLong(bytes, offset + 1) * 1000l); 
 // compute the weekday (0-based, and 0 = Sunday). Adjustment is needed as // the anchor day is Thursday. 
 private final static String EVALUATE_DESC = "(Lorg/apache/hyracks/dataflow/common/data/" + "accessors/IFrameTupleReference;Lorg/apache/hyracks/data/std/api/IPointable;)V"; 
 private final static String TYPECHECK_METHOD_DESC = "(Lorg/apache/hyracks/data/std/api/IPointable;" + "Lorg/apache/hyracks/data/std/api/IPointable;)Z"; 
 // Obtains the last added label. Label getLastAddedLabel() { return lastAddedLabel; } 
 private final static String EVALUATE_DESC = "(Lorg/apache/hyracks/dataflow/common/data/accessors/" + "IFrameTupleReference;Lorg/apache/hyracks/data/std/api/IPointable;)V"; 
 if ((className == null || !name.equals(className)) && ((access & Opcodes.ACC_PUBLIC) == 0 || (access & Opcodes.ACC_STATIC) == 0)) { innerClassNames.add(name); 
 case BOOLEAN: 
 case NULL: 
 case INT16: 
 case INT32: 
 ctx.getMissableTypeComputer(), ctx.getMetadataProvider(), TypePropagationPolicy.LEFT_OUTER, envPointers); 
 if (typeEnvs[i].getTypeEnv().getVarType(v) != null) { nonMissingVarIsProduced = true; break; 
 ITypingContext typingContext, IExpressionEvalSizeComputer expressionEvalSizeComputer, 
 RecordDescriptor recordDescriptor, boolean isLeftOuter, IMissingWriterFactory[] nullWriterFactories1, IPredicateEvaluatorFactory predEvalFactory) { 
 final IMissingWriter[] nullWriters1 = isLeftOuter ? new IMissingWriter[nonMatchWriterFactories1.length] : null; 
 final IMissingWriter[] nullWriters1 = isLeftOuter ? new IMissingWriter[nonMatchWriterFactories1.length] : null; 
 final IMissingWriter[] nullWriters1 = isLeftOuter ? new IMissingWriter[nonMatchWriterFactories.length] : null; 
 final IMissingWriter[] nonMatchWriter = isLeftOuter ? new IMissingWriter[nonMatchWriterFactories.length] : null; final ArrayTupleBuilder nullTupleBuild = isLeftOuter ? new ArrayTupleBuilder(buildRd.getFieldCount()) : null; 
 FrameUtils.appendConcatToWriter(writer, appender, accessor, tupleIndex, nonMatchTupleBuild.getFieldEndOffsets(), nonMatchTupleBuild.getByteArray(), 0, nonMatchTupleBuild.getSize()); 
 AUnionType unionType = (AUnionType) aObjectType; IAType type = unionType.getActualType(); if (type.getTypeTag() == tag) { return type; 
 serializedTypeTag = ATypeTag.SERIALIZED_NULL_TYPE_TAG; 
 return b2[s2] == ATypeTag.SERIALIZED_MISSING_TYPE_TAG ? 0 : -1; 
 return b2[s2] == ATypeTag.SERIALIZED_NULL_TYPE_TAG ? 0 : -1; 
 case MISSING: 
 case MISSING: case NULL: { 
 case MISSING: case NULL: { 
<|del|> 
<|del|> 
 byte serializedTypeTag = bytes[offset]; if (serializedTypeTag == ATypeTag.SERIALIZED_MISSING_TYPE_TAG || serializedTypeTag == ATypeTag.SERIALIZED_NULL_TYPE_TAG) { 
<|del|> 
 case MISSING: 
<|del|> 
 * This class is the type computer for not-missing function. 
 type = BuiltinType.ANY; break; 
 default: throw new NotImplementedException(ERR_MSG + tag); 
<|del|> 
 public static IAType getActualType(IAType inputType) { return inputType.getTypeTag() == ATypeTag.UNION ? ((AUnionType) inputType).getActualType() : inputType; 
 throw new AlgebricksException("The argument should be binary Type."); 
 throw new AlgebricksException("Second argument should be string Type."); 
 case UNION: return ((AUnionType) t).isMissableType(); 
 case UNION: return ((AUnionType) t).isUnknownableType(); default: 
 default: 
<|del|> 
<|del|> 
 } try { serde.serialize(b, out); } catch (HyracksDataException e) { throw new AlgebricksException(e); } 
 ATypeTag typeTag1 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(argLeft.getTag()); ATypeTag typeTag2 = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(argRight.getTag()); 
 int result = ch.compare(EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(argLeft.getTag()), EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(argRight.getTag()), outLeft, outRight); 
<|del|> 
 private final static String DESCRIPTOR_SUPER_CLASS_NAME = "org/apache/asterix/runtime/" + "evaluators/base/AbstractScalarFunctionDynamicDescriptor"; 
 PA.invokeMethod(fd, "reset(org.apache.asterix.om.types.IAType, org.apache.asterix.om.types.IAType, " + " org.apache.asterix.om.types.IAType)", outType, type0, type1); 
 PA.invokeMethod(fd, "reset(org.apache.asterix.om.types.IAType, org.apache.asterix.om.types.IAType," + " org.apache.asterix.om.types.IAType)", outType, type0, type1); 
 PA.invokeMethod(fd, "reset(org.apache.asterix.om.types.IAType, org.apache.asterix.om.types.IAType," + " org.apache.asterix.om.types.IAType)", outType, type0, type1); 
 profilerEntityCommitLogCount.incrementAndGet(); 
 Thread.currentThread().interrupt(); 
 private static final boolean DEBUG = false; 
 @Option(name = "-address", required = false, usage = "Address to listen on for connections from CC (default: all addresses)") 
 storageRootDirPath = mountPoints[i] + storageRootDirName.substring(System.getProperty("file.separator").length()); 
 List<LogicalVariable> assgnVars = new ArrayList<>(1); 
<|del|> 
 List<Mutable<ILogicalExpression>> assgnExprs = new ArrayList<>(1); 
 List<Mutable<ILogicalExpression>> rAggExprs = new ArrayList<>(1); 
 List<Mutable<ILogicalExpression>> rAggExprs = new ArrayList<>(1); 
 // If message fits, we append it, otherwise, we append a null message, then send a message only // frame with the message 
 if (i > 0) { 
<|del|> 
 @Override public void print(byte[] b, int s, int l, PrintStream ps) throws HyracksDataException { 
 ps.print(AInt16SerializerDeserializer.getShort(b, s + 1)); 
 ps.print(AInt64SerializerDeserializer.getLong(b, s + 1)); 
 ps.print(AInt8SerializerDeserializer.getByte(b, s + 1)); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // 1. in case spilling is not kicked off, the ordering property is maintained and hence local grouping // property is maintained. // 2. if spilling is kicked off, the grouping property is still maintained though the ordering property // is destroyed. 
 // 1. in case spilling is not kicked off, the ordering property is maintained and hence local grouping // property is maintained. // 2. if spilling is kicked off, the grouping property is still maintained though the ordering property // is destroyed. 
 if (!forceRR && (isLeftOuter || buildPartSize < probePartSize)) { //Case 2.1 - Recursive HHJ (wout Role-Reversal) 
 return new Pair<>(actualKeyType, nullable); 
<|del|> 
 IAType type; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 IAType type; 
 private static final String ERR_MSG = "Arithmetic operations are not implemented for "; 
<|del|> 
<|del|> 
 private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; 
 private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; 
 private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; 
 private static final byte CERTAIN = 1; private static final byte NULLABLE = 2; private static final byte MISSABLE = 4; private static final byte MISSING = 8; private static final byte NULL = 16; 
 private static final AObjectSerializerDeserializer aObjSerDer = AObjectSerializerDeserializer.INSTANCE; 
 continue; 
 private static final ATypeTag[] EXPECTED_INPUT_TAGS = { ATypeTag.BINARY, ATypeTag.INT32 }; 
 int subStart; 
 public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() { 
 public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() { 
<|del|> 
 public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() { 
 RecordDescriptor recDescriptor, IOperatorDescriptorRegistry spec) throws AlgebricksException { IOperatorDescriptor opDesc; 
 case INNER: 
 case LEFT_OUTER: 
<|del|> 
 RecordDescriptor recDescriptor, IOperatorDescriptorRegistry spec) throws AlgebricksException { IOperatorDescriptor opDesc; 
 if (toBreak) { break; 
 private static void writeMissing() throws HyracksDataException { 
 final IPredicateEvaluator predEvaluator = predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator(); 
 if (!forceRR && (isLeftOuter || (buildPartSize < probePartSize))) { //Case 1.1 - InMemHJ (wout Role-Reversal) 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print(ADoubleSerializerDeserializer.getDouble(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AFloatSerializerDeserializer.getFloat(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AInt16SerializerDeserializer.getShort(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AInt32SerializerDeserializer.getInt(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AInt64SerializerDeserializer.getLong(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AInt8SerializerDeserializer.getByte(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { throw new HyracksDataException("'Interval' type unsupported for CSV output"); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print("null"); 
 ps.print("["); ps.print(ADoubleSerializerDeserializer.getDouble(b, s)); ps.print(", "); ps.print(ADoubleSerializerDeserializer.getDouble(b, s + 8)); ps.print("]"); s += 16; 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print(ABooleanSerializerDeserializer.getBoolean(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(ADoubleSerializerDeserializer.getDouble(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AFloatSerializerDeserializer.getFloat(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AInt16SerializerDeserializer.getShort(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AInt32SerializerDeserializer.getInt(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AInt64SerializerDeserializer.getLong(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AInt8SerializerDeserializer.getByte(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print("{ \"interval\": { \"start\": "); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print("null"); 
<|del|> 
 ps.print("["); ps.print(ADoubleSerializerDeserializer.getDouble(b, s)); ps.print(", "); ps.print(ADoubleSerializerDeserializer.getDouble(b, s + 8)); ps.print("]"); s += 16; 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps.print(ABooleanSerializerDeserializer.getBoolean(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(ADoubleSerializerDeserializer.getDouble(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(AFloatSerializerDeserializer.getFloat(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps.print("null"); 
 } ps.print("{ \"point\": ["); ps.print(ADoubleSerializerDeserializer.getDouble(b, s)); ps.print(", "); ps.print(ADoubleSerializerDeserializer.getDouble(b, s + 8)); 
 public static final ABoolean TRUE = new ABoolean(true); public static final ABoolean FALSE = new ABoolean(false); 
 public static final ABoolean TRUE = new ABoolean(true); public static final ABoolean FALSE = new ABoolean(false); 
 public static final ABoolean TRUE = new ABoolean(true); public static final ABoolean FALSE = new ABoolean(false); 
 public static final ABoolean TRUE = new ABoolean(true); public static final ABoolean FALSE = new ABoolean(false); 
 public static final ABoolean TRUE = new ABoolean(true); public static final ABoolean FALSE = new ABoolean(false); 
 public static final ABoolean TRUE = new ABoolean(true); public static final ABoolean FALSE = new ABoolean(false); 
 @Override public Void visit(AListVisitablePointable accessor, Pair<PrintStream, ATypeTag> arg) throws AsterixException { 
 @Override public Void visit(AListVisitablePointable accessor, Pair<PrintStream, ATypeTag> arg) throws AsterixException { 
 @Override public Void visit(AListVisitablePointable accessor, Pair<PrintStream, ATypeTag> arg) throws AsterixException { 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(ADoubleSerializerDeserializer.getDouble(b, s + 1) + "d"); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps.print("null"); 
 ps.print(ADoubleSerializerDeserializer.getDouble(b, s)); ps.print(","); ps.print(ADoubleSerializerDeserializer.getDouble(b, s + 8)); s += 16; 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(ABooleanSerializerDeserializer.getBoolean(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(ABooleanSerializerDeserializer.getBoolean(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(ABooleanSerializerDeserializer.getBoolean(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print(ADoubleSerializerDeserializer.getDouble(b, s + 1) + "d"); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print(AFloatSerializerDeserializer.getFloat(b, s + 1) + "f"); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print("null"); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print(ABooleanSerializerDeserializer.getBoolean(b, s + 1)); 
 private static final int REPLICATION_DATAPORT_DEFAULT = 2000; private static final int REPLICATION_FACTOR_DEFAULT = 1; private static final int REPLICATION_TIME_OUT_DEFAULT = 15; 
 private static final int REPLICATION_DATAPORT_DEFAULT = 2000; private static final int REPLICATION_FACTOR_DEFAULT = 1; private static final int REPLICATION_TIME_OUT_DEFAULT = 15; 
 private static final int REPLICATION_DATAPORT_DEFAULT = 2000; private static final int REPLICATION_FACTOR_DEFAULT = 1; private static final int REPLICATION_TIME_OUT_DEFAULT = 15; 
 private static final int REPLICATION_LOG_BUFFER_NUM_PAGES_DEFAULT = 8; 
 Set<Replica> remoteReplicas = new HashSet<>();; 
 Set<String> remoteReplicasIds = new HashSet<>(); 
 Set<String> replicaIds = new HashSet<>(); 
 } catch (InterruptedException e) { Thread.currentThread().interrupt(); 
 //add the size of the log record itself + 4 bytes for its size 
 Thread.currentThread().interrupt(); 
 private NetworkingUtil() { throw new AssertionError("This util class should not be initialized."); } 
 lsmComponentId2PropertiesMap = new ConcurrentHashMap<>(); 
 lsmComponentId2PropertiesMap = new ConcurrentHashMap<>(); 
<|del|> 
 if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Unexpectedly error during replication.", e); } 
 if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Unexpectedly error during replication.", e); } 
 if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Filed to close replication socket.", e); } 
 if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Filed to close replication socket.", e); } 
 /** * check which indexes can be flushed (open indexes) and which cannot be * flushed (closed or have empty memory component). */ IDatasetLifecycleManager datasetLifeCycleManager = appContextProvider.getDatasetLifecycleManager(); 
 Set<Integer> datasetsToForceFlush = new HashSet<>(); 
 /** * if an index has something to be flushed, then the request to flush it * will succeed and we need to schedule it to be flushed. */ 
 Map<String, ClusterPartition[]> nodePartitions = ((IAsterixPropertiesProvider) appContextProvider 
 /** * this method is called sequentially by LogPage (notifyReplicationTerminator) * for JOB_COMMIT and JOB_ABORT log types. */ 
<|del|> 
<|del|> 
 syncLSMComponentFlushLSN(lsmCompProp, syncTask); updateLSMComponentRemainingFiles(lsmCompProp.getComponentId()); 
 Thread.currentThread().interrupt(); } catch (Exception e) { if (LOGGER.isLoggable(Level.SEVERE)) { LOGGER.log(Level.SEVERE, "Unexpected exception during LSN synchronization", e); } 
 throws InterruptedException, IOException { 
 } remoteLogMap = replicaUniqueLSN2RemoteMapping.get(lsmCompProp.getNodeUniqueLSN()); 
 /** * This could happen when a merged component arrives and deletes * the flushed component (which we are trying to update) before * its flush log arrives since logs and components are received 
 int logBufferSize = logManager.getLogPageSize(); 
 int logBufferSize = logManager.getLogPageSize(); 
<|del|> 
<|del|> 
<|del|> 
 synchronized (replicaEventsQ) { replicaEventsQ.offer(event); } 
<|del|> 
 Map<String, Set<String>> recoveryCandidates = new HashMap<>(); Map<String, Integer> candidatesScore = new HashMap<>(); 
 Map<String, Set<String>> recoveryCandidates = new HashMap<>(); Map<String, Integer> candidatesScore = new HashMap<>(); 
 if (locations.isEmpty()) { 
 Map<String, Set<String>> recoveryList = new HashMap<>(); 
 Set<String> nodesToRecover = new HashSet<>(); 
 if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Failed during remote recovery. Attempting again...", e); } 
 if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Failed during remote recovery. Attempting again...", e); } 
 if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Failed during completing failback. Restarting failback process...", e); } 
 syncCommitQ = new LinkedBlockingQueue<>(logPageSize / ILogRecord.JOB_TERMINATE_LOG_SIZE); flushQ = new LinkedBlockingQueue<>(); remoteJobsQ = new LinkedBlockingQueue<>(); 
 syncCommitQ = new LinkedBlockingQueue<>(logPageSize / ILogRecord.JOB_TERMINATE_LOG_SIZE); flushQ = new LinkedBlockingQueue<>(); remoteJobsQ = new LinkedBlockingQueue<>(); 
 } else if (logRecord.getLogSource() == LogSource.REMOTE && (logRecord.getLogType() == LogType.JOB_COMMIT || logRecord.getLogType() == LogType.ABORT)) { remoteJobsQ.offer(logRecord); 
 replicationThread.notifyLogReplicationRequester(logRecord); 
 replicationThread.notifyLogReplicationRequester(logRecord); 
<|del|> 
 public Void visit(AFlatValuePointable accessor, Pair<PrintStream, ATypeTag> arg) throws AsterixException { 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(ADoubleSerializerDeserializer.getDouble(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps.print("null"); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps .print(ABooleanSerializerDeserializer.getBoolean(b, s + 1)); 
 public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> ps.print("null"); 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 clusterNetPublicIPAddress = IniUtils.getString( ini, nodeSection, "public.cluster.address", clusterNetPublicIPAddress); 
<|del|> 
 } finally{ printer.close(); } 
 String clusterConfigFileName, String dgenFileName, String countFileName, String loadAQLFileName, String querySQLPPFileName) { 
 String clusterConfigFileName, String dgenFileName, String countFileName, String loadAQLFileName, String querySQLPPFileName) { 
 String clusterConfigFileName, String dgenFileName, String countFileName, String loadAQLFileName, String querySQLPPFileName) { 
 protected void doBuild(Experiment e) throws IOException, JAXBException{ 
 protected void doBuild(Experiment e) throws IOException, JAXBException{ 
 //load data into pidx 
 super("PerfTestAggBuilder", config, "asterix-agg.xml", "asterix-4.dgen", "bench_count.aql", "bench_3_load.aql", "agg_bench"); 
 public LSMPerfConstants() {} // never needs to be instantiated 
<|del|> 
 super("PerfTestAggBuilder", config, "asterix-agg.xml", "asterix-4.dgen", "bench_count.aql", "bench_3_load.aql", "agg_bench"); 
 private LSMPerfConstants(){ throw new UnsupportedOperationException(); } // never needs to be instantiated 
 private LSMPerfConstants(){ throw new UnsupportedOperationException(); } // never needs to be instantiated 
 private final AOrderedListType orderedlistType; 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
<|del|> 
 CachedPage cPage = (CachedPage) cachedPages.get(curPage); if (cPage != null) { cleanPage(cPage, false); } 
 if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this); 
 if (shutdownStart) { break; } pageCleanerPolicy.notifyCleanCycleFinish(this); 
<|del|> 
 private static final String INDENT = "\t"; 
 private static StringBuilder append(StringBuilder builder, JSONObject jobj, int indent) throws JSONException { StringBuilder sb = builder.append("{\n"); 
 private static StringBuilder append(StringBuilder builder, JSONArray jarr, int indent) throws JSONException { StringBuilder sb = builder.append("[\n"); 
 private static StringBuilder indent(StringBuilder sb, int i) { int indent = i; 
<|del|> 
 ccPort = IniUtils.getInt(ini, "cc", "cluster.port", ccPort); // Get ID of *this* NC 
 ccPort = IniUtils.getInt(ini, "cc", "cluster.port", ccPort); // Get ID of *this* NC 
 public void stop() { // Currently there is nothing to stop } 
 public void close() { // Nothing to close 
 public void error(int ecode) { // Errors are handled via messages 
 // Nothing to close 
 // Errors are handled in the application 
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 addFunction(FLOAT_CONSTRUCTOR, AFloatTypeComputer.INSTANCE, true); addPrivateFunction(FUZZY_EQ, BooleanFunctionTypeComputer.INSTANCE, true); 
 } catch (IllegalArgumentException e) { LOGGER.info(output + ": unsupported output-format, using " + OutputFormat.CLEAN_JSON + " instead"); 
 fldTypes[j] = rtd.getNullableFields().get(j) ? AUnionType.createUnknownableType(t2) : t2; 
 fldTypes[j] = rtd.getNullableFields().get(j) ? AUnionType.createUnknownableType(t2) : t2; 
 public Void visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, IOptimizationContext ctx) throws AlgebricksException { 
 public Boolean visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, ILogicalOperator arg) throws AlgebricksException { 
 public Void visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, IOptimizationContext arg) throws AlgebricksException { 
 public Void visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, IOptimizationContext ctx) throws AlgebricksException { 
 } return RecordReadStatus.TRUNCATED; 
 } catch (IllegalAccessException | ClassNotFoundException | InstantiationException | ClassCastException e) { throw new AsterixException("Unknown format: " + parser, e); 
 public ILogicalOperator visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, Void arg) throws AlgebricksException { 
 if (hasOptionalFields && ((nullBitMap[fieldId / 4] & (1 << (7 - 2 * (fieldId % 4)))) == 0)) { 
 if (hasOptionalFields && ((nullBitMap[fieldId / 4] & (1 << (7 - 2 * (fieldId % 4)))) == 0)) { 
 if (hasOptionalFields && ((nullBitMap[fieldId / 4] & (1 << (7 - 2 * (fieldId % 4) - 1))) == 0)) { 
 if (hasOptionalFields) { 
 return (bytes[getNullBitmapOffset(recordType) + fieldId / 4] & (1 << (7 - 2 * (fieldId % 4)))) == 0; 
 protected abstract IAType getResultType(ILogicalExpression expr, IAType... strippedInputTypes) throws AlgebricksException; 
 public Void visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, IOptimizationContext ctx) throws AlgebricksException { 
 public ILogicalOperator visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, Void arg) throws AlgebricksException { 
 public ILogicalOperator visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, Void arg) throws AlgebricksException { 
<|del|> 
 int resourcePartition, byte resourceType, IndexOperation indexOp, boolean logBeforeImage) { 
 if (rwQ != null || (statement != null && statement.getKind() == Kind.LOAD)) { 
 if (rwQ != null || (statement != null && statement.getKind() == Kind.LOAD)) { 
 LSMExperimentConstants.AQL_DIR).resolve(querySQLPPFileName), localExperimentRoot.resolve(LSMPerfConstants.RESULT_FILE)))); 
 while (true) { IApplicationMessage msg = null; 
<|del|> 
 public int read(SocketChannel sc, int size) throws IOException, NetException; 
 * Represents the write interface of a {@link IChannelControlBlock}. 
<|del|> 
import org.apache.hyracks.api.exceptions.NetException; import org.apache.hyracks.control.nc.NodeControllerService; 
<|del|> 
 public ILogicalOperator visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, Void arg) throws AlgebricksException { 
<|del|> 
 : new LeftOuterUnnestOperator(rightVar, new MutableObject<>(makeUnnestExpression(eo.first)), pVar, 
 throw new UnsupportedOperationException(ERR_MSG); 
 boolean hasOptionalFields = NonTaggedFormatUtil.hasOptionalField(recordType); if (hasOptionalFields) { 
 "Field: " + recType.getFieldNames()[optionalFieldId] + " can not be optional"); 
 if (hasOptionalFields) { 
 boolean hasOptionalFields = NonTaggedFormatUtil.hasOptionalField(inputRecType); if (hasOptionalFields) { 
 throw new HyracksDataException("Unable to cast record to " + reqType.getTypeName(), e); 
 public int getExpandedOffset(ARecordType recordType) { 
 .deserialize(fieldValue.getByteArray()[fieldValue.getStartOffset()]); if (!(i == 0 && typeTag == ATypeTag.MISSING) && nextTypeTag != ATypeTag.MISSING) { 
<|del|> 
 return variableMapping.get(right).equals(left); 
 comparatorFactories, predEvaluatorFactory, recDescriptor, true, nonMatchWriterFactories, tableSize); 
 context.getBinaryBooleanInspectorFactory(), select.getRetainMissing(), inputSchemas[0].findVariable(select.getMissingPlaceholderVariable()), context.getMissingWriterFactory()); 
 if (hasOptionalFields) { int nullBitMapSize = (int) (Math.ceil(numberOfSchemaFields / 4.0)); 
 if (hasOptionalFields && ((nullBitMap[fieldId / 4] & (1 << (7 - 2 * (fieldId % 4)))) == 0)) { 
 if (hasOptionalFields && ((nullBitMap[fieldId / 4] & (1 << (7 - 2 * (fieldId % 4)))) == 0)) { 
 private static boolean findAndEliminateRedundantFieldAccess(AssignOperator assign) throws AlgebricksException { 
 IPrimitiveValueProviderFactory[] valueProviderFactories = new IPrimitiveValueProviderFactory[numNestedSecondaryKeyFields]; 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> spPc = splitProviderAndPartitionConstraintsForDataset(dataset.getDataverseName(), dataset.getDatasetName(), indexName, temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataSource.getId().getDataverseName(), datasetName, indexName, temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, dataset.getDatasetDetails().isTemp()); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 comparatorFactories[i] = AqlBinaryComparatorFactoryProvider.INSTANCE.getBinaryComparatorFactory(nestedKeyType, true); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataSource.getId().getDataverseName(), datasetName, indexName, temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 comparatorFactories[i] = AqlBinaryComparatorFactoryProvider.INSTANCE.getBinaryComparatorFactory(nestedKeyType, true); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 log(pkHash, after, logBeforeImage ? before : null); 
 recordWithMetadata.setMetadata(i, lockTime); 
 private final ILangCompilationProvider compilationProvider = new SqlppCompilationProvider(); 
 public NetException() { // empty constructor 
 FullFrameChannelReadInterface(IChannelControlBlock ccb) { this.ccb = ccb; riEmptyStack = new ArrayDeque<>(); credits = 0; emptyBufferAcceptor = buffer -> { 
<|del|> 
 public void setMessagingChannelInterfaceFactory(IChannelInterfaceFactory interfaceFactory) { // do nothing 
 List<IAlgebraicRewriteRule> fuzzy = new LinkedList<>(); 
 // The ComplexJoinInferenceRule as well as the following variable/assign/select rules are successively 
 * 
 public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { 
 private List<Set<LogicalVariable>> previousPK = new ArrayList<>(); 
 Collection<LogicalVariable> liveVars = new HashSet<>(); 
 Set<LogicalVariable> currentPK = new HashSet<>(); 
 // Step2. We employee the prefix fuzzy join strategy which needs initialize the mapping // from the shared token to the actually tuples of both side. left(right)InputPK targets // at extracting those mapping from prefix tokens to tuples 
 // Step3. Translate the tokenizer, join condition and group by (shared token) as shown // in the above AQLPLUS template. 
<|del|> 
<|del|> 
 // Step3.1. Substitute the variable references of the above AQLPLUS template with // the actually attached variables. 
 translator.addOperatorToMetaScope(new VarIdentifier("#RIGHT_" + nBranches + "_" + i), deepCopyVisitor.deepCopy(rightInputOp)); 
<|del|> 
 List<Mutable<ILogicalExpression>> conjs2 = new ArrayList<>(); 
 Collection<LogicalVariable> primaryKeys = new HashSet<>(); 
 return new ArrayList<>(primaryKeys); 
 public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { 
 validate = false; List<LogicalVariable> producedVars = new ArrayList<>(); 
 validate = true; } else if (opRef.getValue().hasInputs()) { 
 List<LogicalVariable> vars = new ArrayList<>(); 
 Map<LogicalVariable, ILogicalOperator> varOpMap = new HashMap<>(); 
 Map<LogicalVariable, LogicalVariable> variableMapping = new HashMap<>(); 
 // For loj, the equivalence between two operators needs the both join sides of both // operators deriving from the same table respectively. if (!peer.getOperatorTag().equals(LogicalOperatorTag.LEFTOUTERJOIN)) { 
 List<LogicalVariable> candProduce = new ArrayList<>(); 
 List<LogicalVariable> peerProduce = new ArrayList<>(); 
 List<LogicalVariable> biPKs = new ArrayList<>(); 
 public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { 
 if (Character .toLowerCase(UTF8StringUtil.charAt(sentenceBytes, currentTokenStart + offset)) != Character .toLowerCase(UTF8StringUtil.charAt(sentenceBytes, tmpIndex + offset))) { 
 if (Character .toLowerCase(UTF8StringUtil.charAt(sentenceBytes, currentTokenStart + offset)) != Character .toLowerCase(UTF8StringUtil.charAt(sentenceBytes, tmpIndex + offset))) { 
 Map<FeedConnectionId, Pair<JobSpecification, Boolean>> disconnectJobList = new HashMap<>(); 
<|del|> 
 printer.print(currLine + '\n'); 
 if (adapterOutputType == null) { 
 this.recordWithMetadata = new RecordWithMetadataAndPK<>(value, CB_META_TYPES, 
<|del|> 
 adapterOutputType = getOutputType(feed, configuration, ExternalDataConstants.KEY_TYPE_NAME); if (metaType == null) { throw new AsterixException("Unknown specified feed output data type " + configuration.get(ExternalDataConstants.KEY_TYPE_NAME)); } 
 FeedMetadataUtil.validateFeed(feed, mdTxnCtx); 
 m.appendReplacement(out, String.valueOf((char) octet)); 
 private static final Pattern OCTAL = Pattern.compile("\\\\([0-3][0-7]{0,2})"); 
 hasOctal = true; ++dest; 
 int octal = Integer.parseInt(m.group(1), 8); if (octal == 0) { return false; } m.appendReplacement(out, String.valueOf((char) octal)); 
 if (hasNullableFields && ((nullBitMap[fieldId / 4] & (1 << (7 - 2 * (fieldId % 4)))) == 0)) { 
 if (hasNullableFields && ((nullBitMap[fieldId / 4] & (1 << (7 - 2 * (fieldId % 4) - 1))) == 0)) { 
 return (long)(metadataPageNum * bufferCache.getPageSize()) + LIFOMetaDataFrame.LSN_OFF; 
 private static final int ADDITIONAL_FILTERING_PAGE_OFF = VALID_OFF + 4; // 29 public static final int LSN_OFF = ADDITIONAL_FILTERING_PAGE_OFF + 4; // 33 public static final int STORAGE_VERSION_OFF = LSN_OFF + 8; //41 
<|del|> 
 public enum TREE_INDEX_STATE { 
 TreeIndexFactory<? extends ITreeIndex> treeFactory, ArrayList<ComparableFileName> allFiles) 
 allFiles.add(new ComparableFileName(fileRef)); return; 
 TreeIndexState idxState = isValidTreeIndex(treeFactory.createIndexInstance(fileRef)); if (idxState == TreeIndexState.VALID) { 
 FilenameFilter filter, TreeIndexFactory<? extends ITreeIndex> treeFactory ) throws HyracksDataException, IndexException { 
 public ILargePageHelper getLargePageHelper() { return null; } @Override public void ensureCapacity(IMetaDataPageManager freePageManager, ITreeIndexMetaDataFrame metaFrame, IBufferCache bufferCache, ITupleReference tuple) throws HyracksDataException { 
 throw new TypeMismatchException(funcName, 0, type0.getTypeTag(), ATypeTag.RECORD); 
 public boolean getLargeFlag(); 
<|del|> 
 strBuilder.append("tupleCountOff: " + tupleCountOff + "\n"); strBuilder.append("freeSpaceOff: " + freeSpaceOff + "\n"); 
 strBuilder.append("tupleCountOff: " + tupleCountOff + "\n"); strBuilder.append("freeSpaceOff: " + freeSpaceOff + "\n"); 
 return ((long)metadataPageNum * bufferCache.getPageSize()) + LIFOMetaDataFrame.LSN_OFF; 
 VERSION_MISMATCH, 
 VERSION_MISMATCH, 
 return TreeIndexState.VERSION_MISMATCH; } else return TreeIndexState.VALID; 
 Mutable<ILogicalExpression> varRef = new MutableObject<>(new VariableReferenceExpression(resVar)); 
 public static final List<IAType> FILE_INDEX_FIELD_TYPES = new ArrayList<>(); 
 public static final List<IAType> FILE_INDEX_FIELD_TYPES = new ArrayList<>(); 
 } if (stmtCreateIndex.hasMetaField()) { throw new AlgebricksException("Typed open index can only be created on the record part"); } 
 protected AlgebricksMetaOperatorDescriptor createCastOp(JobSpecification spec, DatasetType dsType, boolean hasMeta, List<Integer> primaryKeyIndicators) { 
 public List<Object> getPrevAdditionalNonFilteringTypes() { 
 List<LogicalVariable> metaVars = new ArrayList<>(); 
 List<Mutable<ILogicalExpression>> originalKeyExprList = new ArrayList<>(); 
 return new ArrayList<>(Arrays.asList(sourceVar.equals(metaVar) ? metaType.getFieldNames()[fieldIndex] : recordType.getFieldNames()[fieldIndex])); 
 return new ArrayList<>(Arrays.asList(sourceVar.equals(metaVar) ? metaType.getFieldNames()[fieldIndex] : recordType.getFieldNames()[fieldIndex])); 
 getExternalDataIndexingOperator(JobSpecification jobSpec, IAType itemType, Dataset dataset, List<ExternalFile> files, RecordDescriptor indexerDesc) throws AsterixException { 
 getExternalDataIndexingOperator(JobSpecification jobSpec, IAType itemType, Dataset dataset, List<ExternalFile> files, RecordDescriptor indexerDesc) throws AsterixException { 
<|del|> 
 AqlMetadataProvider metadataProvider) throws AsterixException, AlgebricksException { 
 if (keySourceIndicators == null || keySourceIndicators.get(i) == 0) { 
 protected AlgebricksMetaOperatorDescriptor createCastOp(JobSpecification spec, int numSecondaryKeyFields, DatasetType dsType, boolean hasMeta, List<Integer> primaryKeyIndicators) { CastRecordDescriptor castFuncDesc = (CastRecordDescriptor) CastRecordDescriptor.FACTORY.createFunctionDescriptor(); 
 return hasMeta() ? dataScanVariables.get(dataScanVariables.size() - 2) 
 List<Pair<LogicalVariable, Mutable<ILogicalExpression>>> groupByList = new ArrayList<Pair<LogicalVariable, Mutable<ILogicalExpression>>>(); List<Pair<LogicalVariable, Mutable<ILogicalExpression>>> decoList = new ArrayList<Pair<LogicalVariable, Mutable<ILogicalExpression>>>(); 
 List<Pair<LogicalVariable, Mutable<ILogicalExpression>>> groupByList = new ArrayList<Pair<LogicalVariable, Mutable<ILogicalExpression>>>(); List<Pair<LogicalVariable, Mutable<ILogicalExpression>>> decoList = new ArrayList<Pair<LogicalVariable, Mutable<ILogicalExpression>>>(); 
 List<Triple<LogicalVariable, LogicalVariable, LogicalVariable>> newVarMap = new ArrayList<Triple<LogicalVariable, LogicalVariable, LogicalVariable>>(); 
 List<Mutable<ILogicalExpression>> newLSMComponentFilterExpressions = new ArrayList<Mutable<ILogicalExpression>>(); 
 List<Mutable<ILogicalExpression>> newLSMComponentFilterExpressions = new ArrayList<Mutable<ILogicalExpression>>(); 
 List<Mutable<ILogicalExpression>> newLSMComponentFilterExpressions = new ArrayList<Mutable<ILogicalExpression>>(); 
 List<Pair<IOrder, Mutable<ILogicalExpression>>> newOrdersAndExprs = new ArrayList<Pair<IOrder, Mutable<ILogicalExpression>>>(); 
 Mutable<ILogicalExpression> varRef = new MutableObject<>(new VariableReferenceExpression(recordVar)); 
 CastRecordDescriptor castFuncDesc = (CastRecordDescriptor) CastRecordDescriptor.FACTORY .createFunctionDescriptor(); 
 } else { return TreeIndexState.VALID; } 
 public static final List<List<String>> FILE_INDEX_FIELD_NAMES = Collections .singletonList(Collections.singletonList("")); public static final List<IAType> FILE_INDEX_FIELD_TYPES = Collections.singletonList(BuiltinType.ASTRING); 
<|del|> 
 IScalarEvaluatorFactory isUnknownEvalFactory = isUnknownDesc .createEvaluatorFactory(new IScalarEvaluatorFactory[] { columnAccessEvalFactory }); IScalarEvaluatorFactory notEvalFactory = notDesc .createEvaluatorFactory(new IScalarEvaluatorFactory[] { isUnknownEvalFactory }); 
<|del|> 
 List<Mutable<ILogicalExpression>> conjs = new ArrayList<>(); 
 List<Mutable<ILogicalExpression>> conjs2 = new ArrayList<>(); 
 return new ArrayList<>(primaryKeys); 
 private final HashMap<Mutable<ILogicalOperator>, List<Mutable<ILogicalOperator>>> childToParent = new HashMap<>(); 
 protected AlgebricksMetaOperatorDescriptor createCastOp(JobSpecification spec, DatasetType dsType) { 
<|del|> 
 } else { return TreeIndexState.VALID; } 
 int optFuncExprIndex, AccessMethodAnalysisContext analysisCtx) throws AlgebricksException { 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset(dataverseName, datasetName, indexName, temp); 
 if (tag != ATypeTag.ANY && tag != ATypeTag.ORDEREDLIST && tag != ATypeTag.UNORDEREDLIST) { throw new AlgebricksException( "Type of argument in aggregation should be a collection type instead of " + type.getDisplayName()); } 
 if (tag != ATypeTag.ANY && tag != ATypeTag.ORDEREDLIST && tag != ATypeTag.UNORDEREDLIST) { throw new AlgebricksException( "Type of argument in aggregation should be a collection type instead of " + type.getDisplayName()); } 
 if (tag != ATypeTag.ANY && tag != ATypeTag.ORDEREDLIST && tag != ATypeTag.UNORDEREDLIST) { throw new AlgebricksException( "Type of argument in aggregation should be a collection type instead of " + type.getDisplayName()); } 
 if (tag != ATypeTag.ANY && tag != ATypeTag.ORDEREDLIST && tag != ATypeTag.UNORDEREDLIST) { throw new AlgebricksException( "Type of argument in aggregation should be a collection type instead of " + type.getDisplayName()); } 
 if (tag != ATypeTag.ANY && tag != ATypeTag.ORDEREDLIST && tag != ATypeTag.UNORDEREDLIST) { throw new AlgebricksException( "Type of argument in aggregation should be a collection type instead of " + type.getDisplayName()); } 
<|del|> 
 try{ response.sendError(HttpServletResponse.SC_NOT_FOUND); }catch(IllegalStateException | IOException e){ LOG.error(e); } 
 try { out = response.getOutputStream(); 
 try{ response.sendError(HttpServletResponse.SC_BAD_REQUEST); }catch(IllegalStateException | IOException e){ LOG.error(e); } 
 private static final int QUERY_WEBPORT_DEFAULT = 19006; 
 private static final int QUERY_WEBPORT_DEFAULT = 19006; 
 private static final HashMap<String,String> fileMimePair = new HashMap<>(); 
 private static final HashMap<String,String> fileMimePair = new HashMap<>(); 
 if ("/".equals(requestURI)) { 
 try{ response.sendError(HttpServletResponse.SC_NOT_FOUND); }catch(IllegalStateException | IOException e){ LOG.error(e); } 
 try { out = response.getOutputStream(); 
 private static final String QUERY_WEBPORT_KEY = "web.queryinterface.port"; private static int QUERY_WEBPORT_DEFAULT = 19006; 
 private final transient List<IRecordTypeAnnotation> annotations = new ArrayList<>(); 
<|del|> 
 * 
 } catch (Exception e) { throw new HyracksDataException(e); 
 LOGGER.warn("Feed has been interrupted. Closing the feed", e); Thread.currentThread().interrupt(); 
 this.budget = (int) Math.min(budgetInBytes / ctx.getInitialFrameSize(), Integer.MAX_VALUE); 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 if (!diskComponents.isEmpty()) { 
 if (memoryComponents != null && !memoryComponents.isEmpty()) { 
 return !opCtx.getComponentHolder().isEmpty() ? opCtx.getComponentHolder().get(0).getMostRecentMarkerLSN() : -1L; 
 private final ILogMarkerCallback callback; // A callback for log mark operations 
 wait(INTERVAL); 
 // TODO (amoudi): find a better reactive way to do this 
 return (metadataPageNum * (long) bufferCache.getPageSize()) + LIFOMetaDataFrame.LSN_OFFSET; 
 public static void displayResults(ResultReader resultReader, SessionConfig conf, Stats stats, ARecordType recordType) throws HyracksDataException { 
 CharSequence cs = minEsc(c); 
 LogManager.getRootLogger().setLevel(Level.ERROR); 
 return VERSION * -1; } else { return buf.getInt(STORAGE_VERSION_OFFSET); 
 deallocatables = new ArrayList<>(); 
 d.deallocate(); 
<|del|> 
<|del|> 
 "Inside limit clauses, it is disallowed to reference a variable having the same name" + " as any variable bound in the same scope as the limit clause."); 
<|del|> 
 IPartitioningProperty normalizedReqPart = reqdPart.normalize(equivalenceClasses, mayExpandProperties ? fds : null); 
 ILogMarkerCallback callback = (ILogMarkerCallback) ctx.get(ILogMarkerCallback.KEY_MARKER_CALLBACK); logRecord = new LogRecord(callback); 
 logRecord = new LogRecord(); 
 LogRecord logRecord = new LogRecord(); 
 remoteLog = new LogRecord(); 
 logRecord = new LogRecord(); 
 this.logRecord = new LogRecord(); 
 logRecord = new LogRecord(); 
 this.logRecord = new LogRecord(); 
 logRecord = new LogRecord(); 
<|del|> 
 aString.append("Marker, "); 
 public long getLastMarkerLSN() throws HyracksDataException; 
<|del|> 
 // The following set of names do not belong to the closed part, 
<|del|> 
<|del|> 
<|del|> 
 public IBufferFactory getBufferFactory(); 
 @Option(name = "-messaging-ip-address", usage = "IP Address to bind messaging " + "listener (default: same as -address)", required = false) 
 @Option(name = "-messaging-port", usage = "IP port to bind messaging listener " + "(default: random port)", required = false) 
 @Option(name = "-messaging-public-ip-address", usage = "Public IP Address to announce messaging" + " listener (default: same as -messaging-ip-address)", required = false) 
 ResultUtils.displayResults(resultReader, sessionConfig, stats, metadataProvider.findOutputRecordType()); 
 public static void displayResults(ResultReader resultReader, SessionConfig conf, Stats stats, ARecordType recordType) throws HyracksDataException { 
 return processSelectClause(selectBlock, currentOpRef); 
 return other.entityId.equals(entityId) && other.getFeedRuntimeType().equals(runtimeId) && other.getPartition() == partition; 
 LOGGER.log(Level.WARNING, "Exception in closing feed runtime" + e.getMessage(), e); 
 activeManager = new ActiveManager(ncApplicationContext.getNodeId(), feedProperties.getMemoryComponentGlobalBudget(), compilerProperties.getFrameSize()); 
 public DistributeFeedFrameWriter(EntityId feedId, IFrameWriter writer, FeedRuntimeType feedRuntimeType, int partition, FrameTupleAccessor fta) throws IOException { 
 private final Map<EntityId, FeedIntakeInfo> entity2Intake; private final Map<FeedConnectionId, FeedConnectJobInfo> connectJobInfos; 
<|del|> 
<|del|> 
 // intakeLocations is an ordered list; // element at position i corresponds to location of i'th instance of operator 
 IFeedJoint collectionSourceFeedJoint = null; 
 private void notifyFeedEventSubscribers(FeedLifecycleEvent event) { 
 List<IFeedJoint> intakeFeedPoints = new ArrayList<>(); 
 List<OperatorDescriptorId> collectOperatorIds = new ArrayList<>(); List<OperatorDescriptorId> computeOperatorIds = new ArrayList<>(); List<OperatorDescriptorId> storageOperatorIds = new ArrayList<>(); 
 IOperatorDescriptor actualOp; 
 AlgebricksMetaOperatorDescriptor op = (AlgebricksMetaOperatorDescriptor) actualOp; 
 List<String> collectLocations = new ArrayList<>(); 
 List<String> storageLocations = new ArrayList<>(); 
 LOGGER.error("Error while setting feed active locations", e); 
 LOGGER.error("Error while setting feed active locations", e); 
 public synchronized void registerFeedEventSubscriber(IFeedLifecycleEventSubscriber subscriber) { 
 public void deregisterFeedEventSubscriber(IFeedLifecycleEventSubscriber subscriber) { 
 public synchronized boolean isConnectedToDataset(String datasetName) { 
 public CollectionRuntime(FeedConnectionId connectionId, ActiveRuntimeId runtimeId, ISubscribableRuntime sourceRuntime, Map<String, String> feedPolicy, IHyracksTaskContext ctx, FeedFrameCollector frameCollector) { 
 public FeedIntakeInfo(JobId jobId, ActivityState state, EntityId feedId, IFeedJoint intakeFeedJoint, JobSpecification spec) { 
 public FeedCollectOperatorNodePushable(IHyracksTaskContext ctx, FeedConnectionId feedConnectionId, Map<String, String> feedPolicy, int partition, int nPartitions, ISubscribableRuntime sourceRuntime) { 
 IActiveMessage feedMessage, int partition) { 
 ActiveRuntimeId runtimeId; 
 public static Triple<IAdapterFactory, RecordDescriptor, IDataSourceAdapter.AdapterType> getPrimaryFeedFactoryAndOutput( Feed feed, FeedPolicyAccessor policyAccessor, MetadataTransactionContext mdTxnCtx) throws AlgebricksException { 
 public void configure(ILibraryManager libraryManager, Map<String, String> configuration) { // Nothing to be configured. 
 String operandId = null; 
 String operandId = null; 
 private static final Logger LOGGER = Logger.getLogger(APIServlet.class.getName()); 
 private final ILangCompilationProvider compilationProvider = new SqlppCompilationProvider(); 
 } catch (IllegalArgumentException e) { LOGGER.info(output + ": unsupported output-format, using " + OutputFormat.CLEAN_JSON + " instead"); 
 } catch (JSONException e) { LOGGER.finest("Could not indent JSON string, returning the input string: " + str); 
 } } catch (InterruptedException e) { Thread.currentThread().interrupt(); 
<|del|> 
 private final Map<ActiveRuntimeId, ActiveRuntime> activeRuntimes; 
 * artifacts/services associated with an active entity. 
 ActiveRuntimeManager mgr = activeRuntimeManagers.get(runtimeId); 
 public synchronized void registerRuntime(ActiveRuntime runtime) { ActiveRuntimeManager runtimeMgr = activeRuntimeManagers.get(runtime.getRuntimeId()); 
 public ActiveRuntime getRuntime(ActiveRuntimeId runtimeId) { ActiveRuntimeManager runtimeMgr = activeRuntimeManagers.get(runtimeId); return runtimeMgr != null ? runtimeMgr.getFeedRuntime(runtimeId) : null; 
 private ActiveManager activeManager; 
 executorService = Executors.newSingleThreadExecutor(); executorService.execute(ActiveJobNotificationHandler.INSTANCE); 
 public void receive(ActivePartitionMessage message) { 
 public void deregisterFeedEventSubscriber(IFeedLifecycleEventSubscriber subscriber) { 
 String operandId = null; 
 private transient final ILangCompilationProvider compilationProvider = new SqlppCompilationProvider(); 
 private static final Logger LOGGER = Logger.getLogger(APIServlet.class.getName()); 
<|del|> 
 private final EntityId entityId; 
 Thread.currentThread().setName(ActiveJobNotificationHandler.class.getSimpleName()); LOGGER.log(Level.INFO, "Started " + ActiveJobNotificationHandler.class.getSimpleName()); while (!Thread.interrupted()) { 
 Map<String, String> feedPolicy, int partition, ISubscribableRuntime sourceRuntime) { 
 private IAdapterFactory createExternalAdapterFactory() throws Exception { IAdapterFactory adapterFactory; 
 private IAdapterFactory createExternalAdapterFactory() throws Exception { IAdapterFactory adapterFactory; 
 private IAdapterFactory createExternalAdapterFactory() throws Exception { IAdapterFactory adapterFactory; 
 adapterFactory = (IAdapterFactory) (classLoader.loadClass(adaptorFactoryClassName).newInstance()); 
 Map<OperatorDescriptorId, OperatorDescriptorId> oldNewOID = new HashMap<>(); FeedMetaOperatorDescriptor metaOp; 
 Map<ConnectorDescriptorId, ConnectorDescriptorId> connectorMapping = new HashMap<>(); 
 Map<OperatorDescriptorId, List<LocationConstraint>> operatorLocations = new HashMap<>(); Map<OperatorDescriptorId, Integer> operatorCounts = new HashMap<>(); 
 private static final int NUM_PARAMS = 1; private static final int FTAnyAllOptionPosFromTheEndOfArg = 1; 
 private static final int NUM_PARAMS = 1; private static final int FTAnyAllOptionPosFromTheEndOfArg = 1; 
 private FTContainsParams() { // Do nothing - all static methods 
 private FTContainsParams() { // Do nothing - all static methods 
 public static byte[] getDisjunctiveFTSearchOptionArray() { return disjunctiveFTSearchOptionArray; } public static byte[] getConjunctiveFTSearchOptionArray() { return conjunctiveFTSearchOptionArray; } 
 public enum TokenizerType { 
 private TokenizerInfo() { // No method yet 
 private TokenizerInfo() { // No method yet 
 private static int hash(byte[] bytes, int start, int length, boolean useLowerCase, boolean useRawByte, int coefficient, int r) { 
 c.getArguments().add(new MutableObject<>(e)); 
 ILogicalOperator u = new UnnestOperator(uVar, new MutableObject<>(makeUnnestExpression(eo1.first))); 
 default: 
 public static final FunctionIdentifier SIMILARITY_JACCARD_CHECK = new FunctionIdentifier( 
 if (optFuncExpr.getOperatorSubTree(exprAndVarIdx.second).equals(rightSubTree)) { 
 if (optFuncExpr.getOperatorSubTree(exprAndVarIdx.second).equals(rightSubTree)) { 
 c.getArguments().add(new MutableObject<>(e)); 
 ((AbstractFunctionCallExpression) currExpr).getArguments().add(new MutableObject<>(e)); c.getArguments().add(new MutableObject<>(currExpr)); 
 ILogicalOperator u = new UnnestOperator(uVar, new MutableObject<>(makeUnnestExpression(eo1.first))); 
 default: 
<|del|> 
 return Collections.emptyList(); 
 ByteBuffer aBuffer = emptyBuffers.poll(); if (aBuffer == null) { aBuffer = ByteBuffer.allocate(frameSize); } 
 this(null); 
 super(vbc, isActive, filter); 
 super(vbc, isActive, filter); 
<|del|> 
<|del|> 
<|del|> 
 case MUL: 
 switch (t) { case EQ: case NEQ: case GT: case GE: case LT: case LE: case CONTAINS: return true; default: return false; } 
 switch (t) { case EQ: case NEQ: case GT: case GE: case LT: case LE: case CONTAINS: return true; default: return false; } 
<|del|> 
 if (th.getErrorCode() == ErrorCode.TUPLE) { // TODO(amoudi): add check for cause. cause should be either cast or duplicate key 
 throw new HyracksDataException(HyracksDataException.NONE, ErrorCode.CAST, "Field type " + inputTypeTag + " can't be promoted to type " + requiredTypeTag); 
 protected Map<LogicalVariable, ILogicalExpression> varAssignRhs = new HashMap<>(); 
<|del|> 
<|del|> 
 eval[k].evaluate(tupleRef, result); 
 throw new HyracksDataException(hde, ErrorCode.TUPLE, t); 
 break; } 
 private volatile transient String msgCache; 
 public static final int UNKNOWN = 0; 
 public static final int UNKNOWN = 0; 
 public static final int UNKNOWN = 0; 
 public static final int UNKNOWN = 0; 
 LogicalOperatorDeepCopyWithNewVariablesVisitor copyVisitor = new LogicalOperatorDeepCopyWithNewVariablesVisitor( 
<|del|> 
 } else { 
 return new ArrayList<>(); } 
 regardAsSelect = true; } 
 return false; } 
 // Step3.1. Substitute the variable references of the above AQLPLUS template with // the actually attached variables. 
 // Step3.1. Substitute the variable references of the above AQLPLUS template with // the actually attached variables. 
<|del|> 
 if (producedVars.contains(pk)) { 
 validate = true; } 
 extractPrimaryKeys(context, opRef.getValue(), prodVars); } 
 throw new AlgebricksException("Illegal variable production."); } 
 if (leftSource.getId().toString().equals(rightSource.getId().toString())) { 
 extreactedPK.add(pk); } 
 } if (candidate.getInputs().size() < 2) { 
 return true; } 
 // For loj, the equivalence between two operators needs the both join sides of both // operators deriving from the same table respectively. if (!peer.getOperatorTag().equals(LogicalOperatorTag.LEFTOUTERJOIN)) { 
 throw new AlgebricksException("Unexpected isomophic lojs of: " + candidate + "-" + peer); } 
 } if (biPKs.size() == candPKs.size()) { 
 isHomo = true; } 
 private final HashMap<Mutable<ILogicalOperator>, List<Mutable<ILogicalOperator>>> childToParent = new HashMap<>(); 
 tranlatedMater = false; 
 public boolean validateInterval(AIntervalPointable ip1) throws HyracksDataException { 
public final class TuplePointer implements IResetable<TuplePointer> { 
 if (this == o) { 
 IAType fieldType; 
 else { fieldType = TypeTagUtil.getBuiltinTypeByTag(typeTag); } 
 IAType fieldType; fieldType = TypeTagUtil.getBuiltinTypeByTag(itemTypeTag); 
 unorderedListBuilder.addItem(itemBuffer); } 
 } else { 
 writeResult = false; } 
 } else { 
 writeResult = false; } 
 } else if (fieldObj instanceof JSONObject) { if (((JSONObject) fieldObj).length() != 0) { writeRecord((JSONObject) fieldObj, out, null); } else { writeResult = false; } 
 if (nameList != null) for (String nln : nameList) { if (name.equals(nln)) { 
 return idx; } 
 continue; } } else { if (writeField(obj.get(curFNames[iter1]), curTypes[iter1], fieldOutput)) { recBuilder.addField(iter1, fieldValueBuffer); } 
<|del|> 
 if (curRecType != null) { 
 curFieldType = curRecType.getFieldType(attrName); } 
 throw new HyracksDataException("Non-null field is null"); } 
 public static final String SENSITIVE = "sensitive"; public static final String RETWEETED_BY_ME = "retweeted_by_me"; public static final String CURRENT_USER_RETWEET_ID = "current_user_retweet_id"; 
 public static final class Tweet_Place { 
 public static final class Tweet_User { 
 private final IObjectPool<IAsterixListBuilder, ATypeTag> listBuilderPool = new ListObjectPool<>( 
 private final IObjectPool<IAsterixListBuilder, ATypeTag> listBuilderPool = new ListObjectPool<>( 
 private final IObjectPool<IMutableValueStorage, ATypeTag> abvsBuilderPool = new ListObjectPool<>( 
 private final IObjectPool<IMutableValueStorage, ATypeTag> abvsBuilderPool = new ListObjectPool<>( 
 private final IObjectPool<IMutableValueStorage, ATypeTag> abvsBuilderPool = new ListObjectPool<>( 
 private final IObjectPool<IMutableValueStorage, ATypeTag> abvsBuilderPool = new ListObjectPool<>( 
 unorderedListBuilder.addItem(itemBuffer); } 
<|del|> 
 public static final String SENSITIVE = "sensitive"; public static final String RETWEETED_BY_ME = "retweeted_by_me"; public static final String CURRENT_USER_RETWEET_ID = "current_user_retweet_id"; 
 public static final class Tweet_Place { 
 AqlMetadataProvider metadataProvider = new AqlMetadataProvider(activeDefaultDataverse); 
 private List<String> dataverses = new ArrayList<>(); private List<String> datasets = new ArrayList<>(); 
<|del|> 
 "Phrase search in Full-text is not yet supported. Only one keyword per expression is permitted." 
 String arg2Value; AOrderedList aOList; AUnorderedList aUnOList; 
 if (objectFromExpr.getType() == BuiltinType.ASTRING) { 
 if (objectFromExpr.getType() == BuiltinType.ASTRING) { 
 private transient IBinaryTokenizer tokenizerForLeftArray = null; private transient IBinaryTokenizer tokenizerForRightArray = null; 
 private transient IBinaryTokenizer tokenizerForLeftArray = null; private transient IBinaryTokenizer tokenizerForRightArray = null; 
 private transient IBinaryTokenizer tokenizerForLeftArray = null; private transient IBinaryTokenizer tokenizerForRightArray = null; 
 private transient IBinaryHashFunction hashFunc = null; 
 private transient IBinaryHashFunction hashFunc = null; 
 private transient BinaryEntry keyEntry = null; 
 private transient BinaryHashSet rightHashSet = null; 
 throws HyracksDataException { 
 private void matchClosedPart(List<IVisitablePointable> fieldNames, List<IVisitablePointable> fieldTypeTags) throws AsterixException, HyracksDataException { 
 * 
 eval[k].evaluate(tupleRef, result); 
 * Note: this method is not thread safe. It is the responsibility of the caller to ensure no path conflict when * creating files simultaneously * 
 * Note: this method is not thread safe. It is the responsibility of the caller to ensure no path conflict when * creating files simultaneously * 
 return (metadataPageNum * (long) bufferCache.getPageSize()) + LIFOMetaDataFrame.LSN_OFFSET; 
<|del|> 
 switch (schemaFormat) { case ADM: 
 } 
 String schemaInferencer; SchemaFormat schemaType; 
 } else { 
 } else { 
 format = OutputFormat.CLEAN_JSON_WITH_SCHEMA; } 
 schemaBuilder.setTuple(); } 
 case RECORD: 
 case ORDEREDLIST: 
 case UNORDEREDLIST: 
 } else { 
 schemaBuilder.setSchema(typeTag); } 
 LOGGER.log(Level.SEVERE, "Error while loading heterogeneous type computer", e); 
 LOGGER.log(Level.SEVERE, "Error while loading heterogeneous type computer", e); 
 * 
 * 
 * 
 parent.addItem(current); } 
 * 
 * 
 return current; } 
<|del|> 
 * 
 } 
<|del|> 
 * 
 * 
 if (current.isStopInfer()) { 
 return; } 
 case STRING: if (!isPrintFieldName()) { 
 current.addItem(FlatSchemaNode.STRING_NODE); } 
 case POINT3D: 
 case YEARMONTHDURATION: 
 * 
 return type2; } 
 return type1; } 
 return FlatSchemaNodeType.STRING; } 
 if (type1 == FlatSchemaNodeType.NULL) { return type2; } if (type2 == FlatSchemaNodeType.NULL) { return type1; } 
 * 
 } else if (itemNode.getType().equals(NestedSchemaNodeType.LIST)) { 
 } else { 
<|del|> 
 } else { 
 innerListNode.resolveInternals(itemNode); } 
 * 
 if ((t0.getNodeType() != t1.getNodeType()) || t0.getNodeType() == t1.getNodeType() && !t0.equals(t1)) { 
 if ((t0.getNodeType() != t1.getNodeType()) || t0.getNodeType() == t1.getNodeType() && !t0.equals(t1)) { 
 nodePool.recycle(this); } 
 * 
<|del|> 
 * @param itemNode * @return true: means stop inferring, false: o.w 
 if (itemNode.getType().getNodeType() == NodeType.FLAT || innerType.getNodeType() == NodeType.FLAT) { 
 computedType = typeComputer.computePrimitiveWithNestedType(itemNode.getType(), innerType); } 
 else if (itemNode.getType().equals(type)) { 
 computedType = typeComputer.computeNestedType(itemNode.getType(), innerType); } 
 * Heterogeneous includes NULL... so it's up to IHeterogeneousTypeComputer. 
 * otherwise, it depends on the type computer. 
 } if (itemNode.getType().getNodeType() == NodeType.NESTED) { 
 out.println(innerType.toString().toLowerCase()); 
 out.println(innerType.toString().toLowerCase()); 
 out.println("root"); 
 if (innerType == NestedSchemaNodeType.RECORD) { 
 return; } 
 } addCreateStmt = "Asterix".equals(typeComputer.getName()); if (innerType.getNodeType() == NodeType.NESTED) { 
 } addCreateStmt = "Asterix".equals(typeComputer.getName()); if (innerType.getNodeType() == NodeType.NESTED) { 
 } else { 
 private String creatAdmType(String fieldName, AbstractNestedSchemaNode node) { 
 String fieldNameType = fieldName + "Type" + count.getValue(); 
 * 
 return null; } 
 if (r.innerType == FlatSchemaNodeType.ANY) { 
 } else if (r.innerType == FlatSchemaNodeType.NULL) { 
 admTypeString.setLength(admTypeString.length() - 1); } 
 rootAdmString.insert(offset, "create type " + fieldNameType + " as open {\n"); } else { rootAdmString.insert(offset, fieldNameType + "{\n"); } 
 * 1- fieldNameType for named record. e.g. "field1":"String","field2":1 
 } else { 
 admString.append(ResultSchemaUtils.SPACE_INDENT + admTypeName + ":"); } 
 } else { 
 suffix = ",\n"; } 
 } else { 
 suffix = "]"; } 
 admString.append(suffix); } 
 //SchemaBuilder helpers 
<|del|> 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
@FunctionalInterface public interface ISchemaNodeType extends Serializable { 
 * 
<|del|> 
 * 
<|del|> 
 * 
 } else { 
 recordPool.add((RecordSchemaNode) nestedNode); } 
 * 
 * 
 } else { 
 * 
 * Complex type Enum * 
 * 
 public List<ISchemaNode> getSchemas(long jobId) throws AsterixException { long jobSchemaId = jobSchemaIdMap.get(jobId); List<ISchemaNode> schemas = jobSchemas.get(jobSchemaId); 
 schemaLocations.remove(jobSchemaId); 
 * 
 schemas.notify(); } 
 * 
 * Generates unique schema ID for each job. * 
 * 
 schemas = new LinkedList<>(); 
 Logger.getGlobal().log(Level.INFO, "couldn't send message\n", e); 
 return type2; } 
 return type1; } 
<|del|> 
 if (type1 == FlatSchemaNodeType.NULL) { return type2; } 
 if (type2 == FlatSchemaNodeType.NULL) { return type1; } 
 * 
 case ASC: 
 default: 
 // Checks whether a proper constant expression is in place for the full-text search. // A proper constant expression in the full-text search should be among string, string type (Un)ordered list. 
 // Checks whether the given index is compatible with full-text search and // the type of the constant search predicate is STRING, ORDEREDLIST, or UNORDEREDLIST 
 public Query(boolean explain) { this.explain = explain; 
<|del|> 
 throws HyracksDataException { 
 pop = new RangePartitionExchangePOperator(((OrderedPartitionedProperty) pp).getOrderColumns(), domain, null); 
 AsterixRuntimeComponentsProvider.RUNTIME_PROVIDER, LSMBTreeIOOperationCallbackFactory.INSTANCE, BLOOM_FILTER_FALSE_POSITIVE_RATE, true, primaryIndexInfo.filterTypeTraits, primaryIndexInfo.filterCmpFactories, primaryIndexInfo.btreeFields, primaryIndexInfo.filterFields, true); 
 MultitenantVirtualBufferCache vbc = new MultitenantVirtualBufferCache( new VirtualBufferCache( 
 int numPages = datasetID < firstAvilableUserDatasetID ? storageProperties.getMetadataMemoryComponentNumPages() : storageProperties.getMemoryComponentNumPages(); 
 // This class has both lsmIndex and index (in super class) pointing to the same object 
 String KEY_MARKER_CALLBACK = "MARKER_CALLBACK"; 
 void before(ByteBuffer buffer); 
 void after(long lsn); 
 public Object getSharedObject(); 
 appendMessage(buffer); 
<|del|> 
 String body, String language, List<IAType> argumentTypes, String initParams, IResultTypeComputer rtc) { 
 library.getLanguage().trim(), function.getFunctionType().trim(), function.getInitParameters()); 
 super(namespace, asterixFunction, FunctionKind.SCALAR, argumentTypes, returnType, rtc, body, language, initParas); 
 throw new HyracksDataException("Unsupported operation %1$s in %2$s operator", ErrorCode.INVALID_OPERATOR_OPERATION, op.toString(), AsterixLSMInsertDeleteOperatorNodePushable.class.getSimpleName()); 
 private int tupleIndex = 0; 
 eval[k].evaluate(tupleRef, result); 
 } catch (HyracksDataException | AlgebricksException e) { throw new HyracksDataException(ErrorCode.HYRACKS, ErrorCode.ERROR_PROCESSING_TUPLE, "Error evaluating tuple %1$s in AssignRuntime", e, tupleIndex); 
 newExceptions.add( new HyracksDataException(ErrorCode.HYRACKS, ErrorCode.FAILURE_ON_NODE, e.getMessage(), e, nodeId)); 
<|del|> 
<|del|> 
import org.apache.asterix.om.types.ATypeTag; import org.apache.asterix.om.types.ARecordType; import org.apache.asterix.om.types.IAType; import org.apache.asterix.om.types.BuiltinType; 
 } catch (JSONException | IOException e) { 
<|del|> 
 initParams); 
 initParams); 
 String initParams) { 
 + (dataverseName == null ? defaultDataverseName : dataverseName) + " nor an alias with name " + datasetName + "!"); 
 Mutable<ILogicalExpression> varRef = new MutableObject<>(new VariableReferenceExpression(resVar)); 
 leafOperator.getInputs().add(new MutableObject<>(upsertOp)); 
 leafOperator.getInputs().add(new MutableObject<>(insertOp)); 
 pop = new RangePartitionExchangePOperator(((OrderedPartitionedProperty) pp).getOrderColumns(), domain, null); 
 "Field type %1$s can't be promoted to type %2$s", inputTypeTag, requiredTypeTag); 
 "Error evaluating tuple %1$s in AssignRuntime", (Throwable) e, new Serializable[] { tupleIndex }); 
 IAsterixAppRuntimeContext runtimeCtx = (IAsterixAppRuntimeContext) ctx.getJobletContext().getApplicationContext().getApplicationObject(); ILibraryManager libraryManager = runtimeCtx.getLibraryManager(); ClassLoader classLoader = libraryManager.getLibraryClassLoader(feedId.getDataverse(), adaptorLibraryName); 
 // Default constructor. 
 Mutable<ILogicalExpression> varRef = new MutableObject<>(new VariableReferenceExpression(resVar)); 
 leafOperator.getInputs().add(new MutableObject<>(insertOp)); 
 leafOperator.getInputs().add(new MutableObject<>(insertOp)); 
 leafOperator.getInputs().add(new MutableObject<>(upsertOp)); 
 leafOperator.getInputs().add(new MutableObject<>(deleteOp)); 
 leafOperator.getInputs().add(new MutableObject<>(insertOp)); 
 leafOperator.getInputs().add(new MutableObject<>(insertOp)); 
<|del|> 
 private static final List<Byte> STATEMENTS = Arrays.asList(new Byte[] { Statement.Kind.DATAVERSE_DECL, Statement.Kind.FUNCTION_DECL, Statement.Kind.QUERY, Statement.Kind.SET, Statement.Kind.WRITE, Statement.Kind.RUN }); 
<|del|> 
<|del|> 
 AqlMetadataProvider metadataProvider = new AqlMetadataProvider(activeDefaultDataverse); 
 private void merge(BufferedWriter writer, Pair<String, String> baseBlocks, String[] extensions) 
 private boolean isMatched(IAType type1, IAType type2, boolean useListDomain) throws AlgebricksException { 
 if (expr.getExpressionTag() == LogicalExpressionTag.CONSTANT) { return Collections.emptyList(); 
 return Collections.emptyList(); 
 public static final FunctionIdentifier EDIT_DISTANCE_STRING_CONTAINS = new FunctionIdentifier( FunctionConstants.ASTERIX_NS, "edit-distance-string-contains", 3); 
 spPc = splitProviderAndPartitionConstraintsForDataset(dataset.getDataverseName(), dataset.getDatasetName(), indexName, temp); 
 } 
<|del|> 
 public static final FunctionIdentifier SIMILARITY_JACCARD_CHECK = new FunctionIdentifier( 
 @Override public void close() throws IOException { // do nothing 
 } else if (fieldObj instanceof JSONObject) { if (((JSONObject) fieldObj).length() != 0) { writeRecord((JSONObject) fieldObj, out, null); } else { writeResult = false; } 
 if (nameList != null) { 
<|del|> 
 return new Pair<>(topOp, currExpr); 
 public static final FunctionIdentifier EDIT_DISTANCE_STRING_CONTAINS = new FunctionIdentifier( FunctionConstants.ASTERIX_NS, "edit-distance-string-contains", 3); 
 public static final IFunctionDescriptorFactory FACTORY = () -> new CastTypeDescriptor(); 
 return new QueryAPIServlet(new AqlCompilationProvider()); 
import static org.apache.asterix.api.http.servlet.ServletConstants.HYRACKS_CONNECTION_ATTR; 
import static org.apache.asterix.api.http.servlet.ServletConstants.HYRACKS_CONNECTION_ATTR; import static org.apache.asterix.api.http.servlet.ServletConstants.HYRACKS_DATASET_ATTR; 
<|del|> 
import static org.apache.asterix.api.http.servlet.ServletConstants.HYRACKS_CONNECTION_ATTR; 
 AsterixAppContextInfo props = (AsterixAppContextInfo) context.getAttribute(ASTERIX_BUILD_PROP_ATTR); 
 AsterixAppContextInfo props = (AsterixAppContextInfo) context.getAttribute(ASTERIX_BUILD_PROP_ATTR); 
 List<Server> serverList = new ArrayList<>(); serverList.add(setupWebServer(externalProperties)); serverList.add(setupJSONAPIServer(externalProperties)); serverList.add(setupFeedServer(externalProperties)); return serverList; 
import static org.apache.asterix.api.http.servlet.ServletConstants.ASTERIX_BUILD_PROP_ATTR; import static org.apache.asterix.api.http.servlet.ServletConstants.HYRACKS_CONNECTION_ATTR; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.spy; import static org.mockito.Mockito.when; 
 when(mockContext.getAttribute(HYRACKS_CONNECTION_ATTR)).thenReturn(mockHcc); when(mockContext.getAttribute(ASTERIX_BUILD_PROP_ATTR)).thenReturn(mockCtx); 
 if (conf.fmt() == SessionConfig.OutputFormat.CSV && ((length > 0) && (frameBytes[start + length - 1] == '\n'))) { length--; 
<|del|> 
 protected enum Value { 
 public static final IFunctionDescriptorFactory FACTORY = () -> new CastTypeDescriptor(); 
 Set<LogicalVariable> normalizedColumnSet = normalizeAndReduceGroupingColumns(columnSet, equivalenceClasses, fds); 
 Set<LogicalVariable> normalizedColumnSet = normalizeAndReduceGroupingColumns(columnSet, equivalenceClasses, fds); 
 public static final int STORAGE_VERSION_OFFSET = LAST_MARKER_LSN_OFFSET + 4; //45 private static final int HEADER_END_OFFSET = LAST_MARKER_LSN_OFFSET + 4; //49 
 Query newQ = new Query(q.isExplain()); 
 private boolean notFirst = false; 
 private boolean notFirst = false; 
 // Default constructor. 
<|del|> 
 } else { 
 jsonResponse.put("status", status); } 
 IHyracksDatasetDirectoryServiceConnection ddsc = new HyracksDatasetDirectoryServiceConnection( 
 return false; } 
 } 
 } 
<|del|> 
 } else { 
 } else { 
 format = OutputFormat.CLEAN_JSON_WITH_SCHEMA; } 
 } else { 
 sessionConfig = new SessionConfig(response.getWriter(), format); } 
 private void handleSchemaMessage(IMessage message) { 
 schemaBuilder.setTuple(); } 
 AbstractPrinterWithSchemaFactory npf; npf = (AbstractPrinterWithSchemaFactory) AqlCleanJSONWithSchemaPrinterFactoryProvider 
<|del|> 
 } else { 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 } else { if (tag == ATypeTag.ANY) { 
 } else { 
 printers[b[s + 1]].print(b, s + 1, l, ps); } 
 final Pair<PrintStream, ATypeTag> arg = new Pair<>(null, null); 
 * 
 * 
 * 
 * 
 * 
 //If this.type = itemNode.getType(), then they must have different innerType 
 * Heterogeneous includes NULL... so it's up to IHeterogeneousTypeComputer. 
 * otherwise, it depends on the type computer. 
 * DatasetType of list. 
 * 1- fieldNameType for named record. e.g. "field1":"String","field2":1 
 //SchemaBuilder helpers 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 //clear after retrieval 
 //Clean up interrupted job. jobSchemas.remove(jobSchemaId); jobSchemaIdMap.remove(jobId); schemaLocations.remove(jobSchemaId); Thread.currentThread().interrupt(); LOGGER.log(Level.SEVERE, "Waiting for schema has been interrupted.", e); 
 * 
 * 
 * Generates unique schema ID for each job. * 
 * 
 public LocalResource createLocalResource(long resourceId, String resourceName, int partition, int storageVersion, String resourcePath) { return new LocalResource(resourceId, resourceName, partition, resourcePath, resourceType, storageVersion, localResourceMetadata); 
 public LocalResource createLocalResource(long resourceId, String resourceName, int partition, int storageVersion, String resourcePath) { return new LocalResource(resourceId, resourceName, partition, resourcePath, resourceType, storageVersion, localResourceMetadata); 
 storageMetadataFile.getAbsolutePath(), 0, storageMetadataFile.getAbsolutePath(), 0, LIFOMetaDataFrame.VERSION, storageRootDirPath); 
 public LocalResource createLocalResource(long resourceId, String resourceName, int partition, int storageVersion, String resourcePath); 
 public LocalResource createLocalResource(long resourceId, String resourceName, int partition, int storageVersion, String resourcePath) { return new LocalResource(resourceId, resourceName, partition, resourcePath, LocalResource.TransientResource, storageVersion, null); 
 List<IPartitioningProperty> deliveredPartitioningPropertiesFromChildren = new ArrayList<IPartitioningProperty>(); 
 throws AlgebricksException { List<Pair<IOrder, Mutable<ILogicalExpression>>> oe = new LinkedList<Pair<IOrder, Mutable<ILogicalExpression>>>(); 
 AbstractLogicalOperator newChild = (AbstractLogicalOperator) op.getInputs().get(childIndex).getValue(); 
 List<LogicalVariable> varList = new ArrayList<>(((UnorderedPartitionedProperty) pp).getColumnSet()); 
 if (isFieldAccess) { LogicalVariable sourceVar = ((VariableReferenceExpression) funcExpr.getArguments().get(0).getValue()).getVariableReference(); 
 return Collections.emptyList(); 
<|del|> 
<|del|> 
 public static final FunctionIdentifier EDIT_DISTANCE_STRING_IS_FILTERABLE = new FunctionIdentifier( 
 if (DEBUG) { 
<|del|> 
<|del|> 
 if (dpp.getPartitioningType() == PartitioningType.ORDERED_PARTITIONED || dpp.getPartitioningType() == PartitioningType.UNORDERED_PARTITIONED) { firstDeliveredPartitioning = dpp; } 
 throw new AlgebricksException("Cannot resolve ambiguous alias reference for undefined identifier " + unresolvedVarName); 
 Mutable<ILogicalOperator> resOpRef = new MutableObject<ILogicalOperator>(resOp); result = produceFlworPlan(noFlworClause, isTop, resOpRef, rRes.second); 
 replaceNtsWithEts(eo.second.getValue()); 
 ia.setIndexExpr(visit(ia.getIndexExpr(), arg)); 
 import java.io.Serializable; 
import org.apache.hyracks.data.std.primitive.DoublePointable; import org.apache.hyracks.data.std.primitive.FloatPointable; import org.apache.hyracks.data.std.primitive.IntegerPointable; import org.apache.hyracks.data.std.primitive.UTF8StringLowercasePointable; import org.apache.hyracks.data.std.primitive.UTF8StringPointable; 
 } // Removes subplans. for(Map.Entry<GroupByOperator, List<ILogicalPlan>> entry: gbyToSubplanListMap.entrySet()){ entry.getKey().getNestedPlans().removeAll(entry.getValue()); } 
 new FieldAccessor(fromBindingVar, SqlppVariableUtil.toUserDefinedVariableName(usedVar .getVar()))); 
 searchOpRef = subTreeOp.getInputs().get(0); subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); 
 // Empty tuple source is a special case that can be partitioned in the same way as the data scan. if (child.getOperatorTag() != LogicalOperatorTag.EMPTYTUPLESOURCE) { 
 matchedTypes.add(optFuncExpr.getFieldType(j)); 
 //Recursively look through function calls. 
 AbstractFunctionCallExpression f = null; 
 AbstractFunctionCallExpression f = null; 
 SelectExpression newSelectExpression = (SelectExpression) substituteExpression(selectExpression, varExprMap, context); 
 private boolean first = true; // Need to copy the bytes from inputVal to outputVal because the byte space of inputVal could be re-used // by consequent tuples. private ArrayBackedValueStorage outputVal = new ArrayBackedValueStorage(); 
 protected Expression preVisit(Expression expr) throws AsterixException{ 
 protected Expression postVisit(Expression expr) throws AsterixException { 
 Set<LogicalVariable> liveVars = new HashSet<>(); List<LogicalVariable> usedVars = new ArrayList<>(); 
 Set<LogicalVariable> liveVars = new HashSet<>(); List<LogicalVariable> usedVars = new ArrayList<>(); 
 // However, if the op is already using variables that are not live, // then a replacement may enable fixing the plan. 
 List<LogicalVariable> liveVars = new ArrayList<>(); 
 private ILogicalOperator translateUpsert(Query expr, DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef, 
<|del|> 
<|del|> 
<|del|>
 * @return A list of additional extension instances of {@code IMetadataIndex} that are introduced by the extension 
 public static void insertMetadataDatasets(MetadataTransactionContext mdTxnCtx, IMetadataIndex[] indexes) throws Exception { 
 public static void insertMetadataDatasets(MetadataTransactionContext mdTxnCtx, IMetadataIndex[] indexes) throws Exception { 
 IVariableTypeEnvironment typeEnv, JobGenContext context, JobSpecification jobSpec, Object implConfig) throws AlgebricksException; 
 IAType itemType = MetadataManager.INSTANCE.getDatatype(aqlMetadataProvider.getMetadataTxnContext(), dataset.getItemTypeDataverseName(), itemTypeName).getDatatype(); 
 IAdapterFactory adapterFactory = aqlMetadataProvider.getConfiguredAdapterFactory(dataset, edd.getAdapter(), edd.getProperties(), (ARecordType) itemType, false, null, null); 
 IAdapterFactory adapterFactory = aqlMetadataProvider.getConfiguredAdapterFactory(dataset, edd.getAdapter(), edd.getProperties(), (ARecordType) itemType, false, null, null); 
 Index primaryIndex = MetadataManager.INSTANCE.getIndex(aqlMetadataProvider.getMetadataTxnContext(), dataverseName, datasetName, datasetName); 
 return aqlMetadataProvider.buildBtreeRuntime(jobSpec, scanVariables, opSchema, typeEnv, context, true, false, ((DatasetDataSource) dataSource).getDataset(), primaryIndex.getIndexName(), null, null, true, true, implConfig, minFilterFieldIndexes, maxFilterFieldIndexes); 
 return aqlMetadataProvider.buildBtreeRuntime(jobSpec, scanVariables, opSchema, typeEnv, context, true, false, ((DatasetDataSource) dataSource).getDataset(), primaryIndex.getIndexName(), null, null, true, true, implConfig, minFilterFieldIndexes, maxFilterFieldIndexes); 
<|del|>
 IVariableTypeEnvironment typeEnv, JobGenContext context, JobSpecification jobSpec, Object implConfig) throws AlgebricksException { 
 return new Pair<IOperatorDescriptor, AlgebricksPartitionConstraint>(feedCollector, new AlgebricksAbsolutePartitionConstraint(getLocations())); 
 return new Pair<IOperatorDescriptor, AlgebricksPartitionConstraint>(feedCollector, new AlgebricksAbsolutePartitionConstraint(getLocations())); 
 List<List<String>> aldsPartitioningKeys = alds.getPartitioningKeys(); boolean isAldsPKAutoGenerated = ((InternalDatasetDetails) alds.getTargetDataset().getDatasetDetails()) .isAutogenerated(); 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : spec.getConnectorOperatorMap().entrySet()) { 
public class MetadataConstants { private MetadataConstants() { } 
<|del|>
<|del|>
 connectorOpMap = new HashMap<>(); 
 connectorOpMap = new HashMap<>(); 
 public ConnectorDescriptorId clone(IConnectorDescriptorRegistry spec) { return new MToNPartitioningMergingConnectorDescriptor(spec, tpcf, sortFields, comparatorFactories, nkcFactory, stable).getConnectorId(); 
 constraintAcceptor.addConstraint( new Constraint(new PartitionCountExpression(consumer), new PartitionCountExpression(producer))); 
 constraintAcceptor.addConstraint( new Constraint(new PartitionCountExpression(consumer), new PartitionCountExpression(producer))); 
 LOGGER.log(Level.WARNING, "registerListener(IActiveEntityEventsListener listener) was called for the entity " + listener.getEntityId()); 
 boolean unnestToDataScan(Mutable<ILogicalOperator> opRef, IOptimizationContext context, UnnestOperator unnestOp, ILogicalExpression unnestExpr, AbstractFunctionCallExpression functionCallExpr) throws AlgebricksException; 
public interface IAlgebraExtensionManager { 
 * @param statementExecutor 
 void handle(IStatementExecutor statementExecutor, AqlMetadataProvider metadataProvider, IHyracksClientConnection hcc) throws Exception; 
 List<Mutable<ILogicalExpression>> additionalFilteringExpressions = new ArrayList<>(); 
 List<Mutable<ILogicalExpression>> additionalFilteringExpressions = new ArrayList<>(); 
 ICompiledDmlStatement dmlStatement) throws AsterixException, RemoteException, AlgebricksException, JSONException, ACIDException; 
 private ILogicalOperator translateUpsert(Query expr, DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef, List<Mutable<ILogicalExpression>> varRefsForLoading, 
 private ILogicalOperator translateUpsert(Query expr, DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef, List<Mutable<ILogicalExpression>> varRefsForLoading, 
 List<LogicalVariable> metaAndKeysVars; List<Mutable<ILogicalExpression>> metaAndKeysExprs; List<Mutable<ILogicalExpression>> metaExpSingletonList; 
 List<LogicalVariable> metaAndKeysVars; List<Mutable<ILogicalExpression>> metaAndKeysExprs; List<Mutable<ILogicalExpression>> metaExpSingletonList; 
 // do nothing 
 List<LogicalVariable> metaAndKeysVars; List<Mutable<ILogicalExpression>> metaAndKeysExprs; List<Mutable<ILogicalExpression>> metaExpSingletonList; 
 @Override public void onDeletionNotice(StatusDeletionNotice arg0) { // do nothing 
 @Override public void onScrubGeo(long arg0, long arg1) { // do nothing 
 @Override public void onStallWarning(StallWarning arg0) { // do nothing 
 public ResultReader(IHyracksDataset hdc) { 
 @Override public void onTrackLimitationNotice(int arg0) { // do nothing 
 @Override public void setFeedLogManager(FeedLogManager feedLogManager) { // do nothing 
 public ResultReader(IHyracksDataset hdc) { 
 @Override public void setController(AbstractFeedDataFlowController controller) { // do nothing 
 @Override public void setMetaType(ARecordType metaType) { // do nothing 
<|del|> 
<|del|> 
 "For details on how to obtain OAuth authentication token, visit https://dev.twitter.com/oauth" + "/overview/application-owner-access-tokens"); 
 ARecordType recordType) throws HyracksDataException { 
 } catch (JSONException e) { LOGGER.warn("Failed to build the result's JSON object", e); 
 LOGGER.warn("Unable to read template error message file", ioe); 
<|del|> 
<|del|> 
 ncConfig.clusterNetIPAddress = Inet4Address.getLoopbackAddress().getHostAddress(); ncConfig.dataIPAddress = Inet4Address.getLoopbackAddress().getHostAddress(); ncConfig.resultIPAddress = Inet4Address.getLoopbackAddress().getHostAddress(); 
 ncConfig.clusterNetIPAddress = Inet4Address.getLoopbackAddress().getHostAddress(); ncConfig.dataIPAddress = Inet4Address.getLoopbackAddress().getHostAddress(); ncConfig.resultIPAddress = Inet4Address.getLoopbackAddress().getHostAddress(); 
 public AQLAPIServlet(ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory) { super(compilationProvider, statementExecutorFactory); 
 public DDLAPIServlet(ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory) { super(compilationProvider, statementExecutorFactory); 
 this.statementExecutorFactory = statementExecutorFactory; 
 ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory) { this(hcc, queryText, new PrintWriter(System.out, true), compilationProvider, statementExecutorFactory); 
 MetadataManager.instantiate(new MetadataManager(proxy, MetadataNode.INSTANCE)); 
 protected final CCExtensionManager ccExtensionManager; public DefaultQueryTranslatorFactory(CCExtensionManager ccExtensionManager) { this.ccExtensionManager = ccExtensionManager; 
 Stats stats) throws Exception { 
 boolean defaultCompactionPolicy = compactionPolicy == null; 
 List<String> selectedNodes = new ArrayList<>(); 
 List<String> selectedNodes = new ArrayList<>(); 
 List<List<String>> indexFields = new ArrayList<>(); List<IAType> indexFieldTypes = new ArrayList<>(); 
 firstExternalDatasetIndex = filesIndex == null; 
 List<JobSpecification> jobsToExecute = new ArrayList<>(); 
 MutableObject<ProgressState> progress = new MutableObject<QueryTranslator.ProgressState>( ProgressState.NO_PROGRESS); MutableObject<MetadataTransactionContext> mdTxnCtx = new MutableObject<>( MetadataManager.INSTANCE.beginTransaction()); 
 List<JobSpecification> jobsToExecute = new ArrayList<>(); 
 if (!indexes.isEmpty()) { 
 List<JobSpecification> jobsToExecute = new ArrayList<>(); 
 protected void handleNodegroupDropStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 protected void handleCreateFeedStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 protected void handleCreateFeedStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 protected void handleCreateFeedPolicyStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 protected void handleCreateFeedPolicyStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 throw new AlgebricksException("Unable to read policy file" + cfps.getSourcePolicyFile(), e); 
 Map<String, String> policyProperties = new HashMap<>(); 
 protected void handleDropFeedPolicyStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 protected void handleDropFeedPolicyStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 IFeedJoint sourceFeedJoint; FeedConnectionRequest request; List<String> functionsToApply = new ArrayList<>(); 
 List<IFeedJoint> jointsToRegister = new ArrayList<>(); 
 List<IFeedJoint> jointsToRegister = new ArrayList<>(); 
 FeedEventsListener listener = (FeedEventsListener) ActiveJobNotificationHandler.INSTANCE .getActiveEntityListener(entityId); 
 return new Triple<>(request, needIntakeJob, jointsToRegister); 
 List<String> appliedFunctions = new ArrayList<>(); 
 LOGGER.log(Level.WARNING, e.getMessage(), e); 
 List<JobSpecification> jobsToExecute = new ArrayList<>(); 
 AqlMetadataProvider metadataProvider, ARecordType enforcedType) throws AlgebricksException { 
 LOGGER.log(Level.INFO, e.getMessage(), e); 
 List<String> ncNames = new ArrayList<>(ncIdentifiers.size()); 
 if (indexes.isEmpty()) { 
 * 
 deletedFiles = new ArrayList<>(); addedFiles = new ArrayList<>(); appendedFiles = new ArrayList<>(); 
 * 
 * 
 deletedFiles = new ArrayList<>(); addedFiles = new ArrayList<>(); appendedFiles = new ArrayList<>(); 
 * 
 deletedFiles = new ArrayList<>(); addedFiles = new ArrayList<>(); appendedFiles = new ArrayList<>(); 
 List<String> readDatasets = new ArrayList<>(); 
 List<String> readDatasets = new ArrayList<>(); 
 + "Is the server configuration correct (node names, buffer sizes, framesize)? " + "Check the logfiles for more details."); 
 String datasetNameTo, MetadataTransactionContext mdTxnCtx) throws Exception { 
 LOGGER.log(Level.WARNING, e.getMessage(), e); 
 LOGGER.log(Level.WARNING, e.getMessage(), e); 
 "The connection to your Pregelix cluster was refused. Is it running? " + "Is the port in the query correct?"); 
 throw new AlgebricksException("The vertex class of your Pregelix query was not found. " + "Does it exist? Is the spelling correct?"); 
 throw new AlgebricksException("The vertex class of your Pregelix query was not found. " + "Does it exist? Is the spelling correct?"); 
 List<String> cmds = new ArrayList<>(); 
 LOGGER.log(Level.SEVERE, rootE.getMessage(), rootE); 
 private HtmlElements() { } 
 * or add new features 
 this.flags = new HashMap<>(); 
 public AdapterExecutor(IFrameWriter writer, FeedAdapter adapter, AdapterRuntimeManager adapterManager) { 
 public ActiveRuntimeId getRuntimeId() { 
<|del|> 
<|del|> 
 public class Category { /** no modifications */ public static final byte QUERY = 0x01; /** modify data */ 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 Set<LogicalVariable> parentUsedVars = new HashSet<>(); 
<|del|> 
<|del|> 
 // First, get rid of duplicated variables from a group-by operator's decor list. 
 Set<LogicalVariable> survivedUnionSourceVarSet = new HashSet<>(); 
 case ASSIGN: 
 private ConstantExpressionUtil() { } 
 private ConstantExpressionUtil() { } 
 private RuleCollections() { 
 private RuleCollections() { 
 public static final List<IAlgebraicRewriteRule> buildNormalizationRuleCollection() { List<IAlgebraicRewriteRule> normalization = new LinkedList<>(); normalization.add(new ResolveVariableRule()); 
 public static final List<IAlgebraicRewriteRule> buildCondPushDownAndJoinInferenceRuleCollection() { List<IAlgebraicRewriteRule> condPushDownAndJoinInference = new LinkedList<>(); 
 public static final List<IAlgebraicRewriteRule> buildLoadFieldsRuleCollection() { List<IAlgebraicRewriteRule> fieldLoads = new LinkedList<>(); 
 public static final List<IAlgebraicRewriteRule> buildFuzzyJoinRuleCollection() { List<IAlgebraicRewriteRule> fuzzy = new LinkedList<>(); 
 public static final List<IAlgebraicRewriteRule> buildConsolidationRuleCollection() { List<IAlgebraicRewriteRule> consolidation = new LinkedList<>(); 
 public static final List<IAlgebraicRewriteRule> buildPlanCleanupRuleCollection() { List<IAlgebraicRewriteRule> planCleanupRules = new LinkedList<>(); 
 public static final List<IAlgebraicRewriteRule> buildDataExchangeRuleCollection() { List<IAlgebraicRewriteRule> dataExchange = new LinkedList<>(); 
<|del|> 
<|del|> 
 public static final List<IAlgebraicRewriteRule> buildPhysicalRewritesTopLevelRuleCollection() { List<IAlgebraicRewriteRule> physicalRewritesTopLevel = new LinkedList<>(); 
 public static final List<IAlgebraicRewriteRule> prepareForJobGenRuleCollection() { List<IAlgebraicRewriteRule> prepareForJobGenRewrites = new LinkedList<>(); 
 ILogicalOperator op = opRef.getValue(); if (op.acceptExpressionTransform(exprRef -> rewriteExpressionReference(op, exprRef, context))) { op.removeAnnotation(AsterixOperatorAnnotations.PUSHED_FIELD_ACCESS); context.computeAndSetTypeEnvironmentForOperator(op); return true; 
 public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { 
 return false; } 
 return false; } 
 return false; } 
 return false; } 
 List<LogicalVariable> payloadVars = new ArrayList<>(); 
 List<LogicalVariable> liveVars = new ArrayList<>(); 
 List<Mutable<ILogicalExpression>> originalKeyExprList = new ArrayList<>(); 
 List<Mutable<ILogicalExpression>> originalKeyExprList = new ArrayList<>(); 
 Mutable<ILogicalExpression> varRef = new MutableObject<>(new VariableReferenceExpression(recordVar)); 
 return new ArrayList<>(Arrays.asList(sourceVar.equals(metaVar) ? metaType.getFieldNames()[fieldIndex] : recordType.getFieldNames()[fieldIndex])); 
<|del|> 
 injectCastFunction(FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.CAST_TYPE), reqFieldType, inputFieldType, expRef, argExpr); 
 List<LogicalVariable> payloadVars = new ArrayList<>(); 
 Mutable<ILogicalExpression> payloadRef = new MutableObject<>(payloadExpr); 
 ArrayList<LogicalVariable> pkVars = new ArrayList<>(); ArrayList<Mutable<ILogicalExpression>> pkExprs = new ArrayList<>(); List<Mutable<ILogicalExpression>> varRefsForLoading = new ArrayList<>(); 
 ArrayList<LogicalVariable> pkVars = new ArrayList<>(); ArrayList<Mutable<ILogicalExpression>> pkExprs = new ArrayList<>(); List<Mutable<ILogicalExpression>> varRefsForLoading = new ArrayList<>(); 
 List<OrderColumn> orderColumns = new ArrayList<>(); 
 List<LogicalVariable> additionalFilteringVars; List<Mutable<ILogicalExpression>> additionalFilteringAssignExpressions; 
 List<LogicalVariable> additionalFilteringVars; List<Mutable<ILogicalExpression>> additionalFilteringAssignExpressions; 
 additionalFilteringVars = new ArrayList<>(); additionalFilteringAssignExpressions = new ArrayList<>(); additionalFilteringExpressions = new ArrayList<>(); 
 additionalFilteringAssign = new AssignOperator(additionalFilteringVars, additionalFilteringAssignExpressions); 
 throws AlgebricksException { Pair<ILogicalOperator, LogicalVariable> p = expr.accept(this, new MutableObject<>(new EmptyTupleSourceOperator())); ArrayList<Mutable<ILogicalOperator>> globalPlanRoots = new ArrayList<>(); 
 throws AlgebricksException { Pair<ILogicalOperator, LogicalVariable> p = expr.accept(this, new MutableObject<>(new EmptyTupleSourceOperator())); ArrayList<Mutable<ILogicalOperator>> globalPlanRoots = new ArrayList<>(); 
 List<Mutable<ILogicalExpression>> writeExprList = new ArrayList<>(1); writeExprList.add(new MutableObject<>(new VariableReferenceExpression(resVar))); 
 List<LogicalVariable> additionalFilteringVars; List<Mutable<ILogicalExpression>> additionalFilteringAssignExpressions; 
 List<LogicalVariable> additionalFilteringVars; List<Mutable<ILogicalExpression>> additionalFilteringAssignExpressions; 
 additionalFilteringVars = new ArrayList<>(); additionalFilteringAssignExpressions = new ArrayList<>(); additionalFilteringExpressions = new ArrayList<>(); 
 additionalFilteringVars = new ArrayList<>(); additionalFilteringAssignExpressions = new ArrayList<>(); additionalFilteringExpressions = new ArrayList<>(); 
 return new Pair<>(returnedOp, v); 
 return new Pair<>(a, v); 
 return new Pair<>(a, v); 
 List<Mutable<ILogicalExpression>> args = new ArrayList<>(); 
 args.add(new MutableObject<>(new VariableReferenceExpression(var))); 
 args.add(new MutableObject<>(new ConstantExpression( 
 args.add(new MutableObject<>(eo.first)); 
 return new Pair<>(op, v); 
 AbstractFunctionCallExpression f; 
 AbstractFunctionCallExpression f; 
 topOp = new MutableObject<>(groupVarAssignOp); 
 .makeAggregateFunctionExpression(AsterixBuiltinFunctions.LISTIFY, flArgs); LogicalVariable aggVar = context.newVar(); 
 return new Pair<>(aggOp, null); 
 .makeAggregateFunctionExpression(AsterixBuiltinFunctions.LISTIFY, flArgs); LogicalVariable aggVar = context.newVar(); 
 return new Pair<>(gOp, null); 
 AssignOperator finalAssignOp = new AssignOperator(resultVar, new MutableObject<>(new VariableReferenceExpression(unnestVar))); finalAssignOp.getInputs().add(new MutableObject<>(unnestOp)); return new Pair<>(finalAssignOp, resultVar); 
 return new Pair<>(a, var); 
 ((AbstractFunctionCallExpression) currExpr).getArguments().add(new MutableObject<>(e)); c.getArguments().add(new MutableObject<>(currExpr)); 
 return new Pair<>(a, assignedVar); 
 return new Pair<>(ord, null); 
 lastOp = new MutableObject<>(u); 
 List<Mutable<ILogicalExpression>> satExprList = new ArrayList<>(1); satExprList.add(new MutableObject<>(eo2.first)); s = new SelectOperator(new MutableObject<>(new ScalarFunctionCallExpression( 
 (List) mkSingletonArrayList(new MutableObject<>(fAgg))); a.getInputs().add(new MutableObject<>(s)); return new Pair<>(a, qeVar); 
 return new Pair<>(a, v1); 
 return new Pair<>(a, v1); 
 return new Pair<>(a, v1); 
 return new Pair<>(a, var); 
 return new Pair<>(s, null); 
 return new Pair<>(opLim, null); 
 case PLUS: 
 case PLUS: 
 case MUL: 
 case DIV: 
 case MOD: 
 case IDIV: 
 case CARET: 
 case OR: 
 case FUZZY_EQ: 
 default: 
 case VARIABLE_EXPRESSION: VariableReferenceExpression ve = new VariableReferenceExpression(context.getVar(((VariableExpr) expr).getVar().getId())); return new Pair<>(ve, topOpRef); case LITERAL_EXPRESSION: 
 return new Pair<>(new ConstantExpression( 
 return new Pair<>(new ConstantExpression( 
 default: 
 default: 
 Mutable<ILogicalOperator> srcRef = new MutableObject<>(); 
 Mutable<ILogicalOperator> srcRef = new MutableObject<>(); 
 Mutable<ILogicalOperator> top2 = new MutableObject<>(p.first); return new Pair<>(new VariableReferenceExpression(p.second), top2); 
 return new Pair<>(new VariableReferenceExpression(p.second), new MutableObject<>(s)); 
 return new Pair<>(new VariableReferenceExpression(p.second), new MutableObject<>(s)); 
 return new Pair<>(res, varListified); 
 if (i < nOps && ops.get(i) != opLogical) { throw new TranslationException( "Unexpected operator " + ops.get(i) + " in an OperatorExpr starting with " + opLogical); 
 return new Pair<>(a, assignedVar); 
 ArrayList<T> array = new ArrayList<>(1); 
 case VARIABLE: 
<|del|> 
 LogicalOperatorDeepCopyWithNewVariablesVisitor visitor = new LogicalOperatorDeepCopyWithNewVariablesVisitor(context, null); 
 childRef = new MutableObject<>(newChild); 
 subplanOp.getInputs().add(new MutableObject<>(inputOp)); Mutable<ILogicalOperator> nestedSource = new MutableObject<>(new NestedTupleSourceOperator(new MutableObject<>(subplanOp))); 
 fldTypes[j] = rtd.getOptionableFields().get(j) ? AUnionType.createUnknownableType(t2) : t2; 
 fldTypes[j] = rtd.getOptionableFields().get(j) ? AUnionType.createUnknownableType(t2) : t2; 
 List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> defaultLogicalRewrites = new ArrayList<>(); 
 List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> defaultLogicalRewrites = new ArrayList<>(); 
 List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> defaultPhysicalRewrites = new ArrayList<>(); 
 List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> defaultPhysicalRewrites = new ArrayList<>(); 
 return new Pair<>(q, q.getVarCounter()); 
 return new Pair<>(q, q.getVarCounter()); 
 protected AlgebricksMetaOperatorDescriptor createCastOp(JobSpecification spec, DatasetType dsType) { CastTypeDescriptor castFuncDesc = (CastTypeDescriptor) CastTypeDescriptor.FACTORY.createFunctionDescriptor(); 
 LOGGER.severe(e.getMessage()); LOGGER.severe("Usage:"); 
 StringBuilder msg = new StringBuilder("Invalid property value '" + value + "' for property '" + property + "'.\n"); 
 protected boolean failed = false; private FeedRecordDataFlowController<T>.DataflowMarker dataflowMarker; private Future<?> result; 
 LOGGER.warn("Feed has been interrupted. Closing the feed", e); Thread.currentThread().interrupt(); 
 } if (hde != null) { throw hde; } 
 return (double) (totalWriteCount - totalReadCount) / (double) budget; 
<|del|> 
 private DatasourceFactoryProvider() { } public static IExternalDataSourceFactory getExternalDataSourceFactory(ILibraryManager libraryManager, Map<String, String> configuration) throws AsterixException { 
 List<FileSplit> splits = new ArrayList<>(); 
 private List<FromTerm> fromTerms = new ArrayList<>(); 
 if (correlateClauses != null) { this.correlateClauses.addAll(correlateClauses); } 
 return correlateClauses != null && !correlateClauses.isEmpty(); 
 boolean aggregate = FunctionMapUtil.isSql92AggregateFunction(signature); 
<|del|> 
 private static final Map<String, BuiltinType> _builtinTypeMap = new HashMap<>(); 
 private static final Map<String, BuiltinType> _builtinTypeMap = new HashMap<>(); 
 openPartOffsets[this.numberOfOpenFields] = openPartOffsets[numberOfOpenFields] << 32; 
 private static final Map<IFunctionInfo, ATypeHierarchy.Domain> registeredFunctionsDomain = new HashMap<>(); 
 private static final Map<IFunctionInfo, ATypeHierarchy.Domain> registeredFunctionsDomain = new HashMap<>(); 
 private static final Map<IFunctionInfo, IFunctionInfo> builtinPublicFunctionsSet = new HashMap<>(); private static final Map<IFunctionInfo, IFunctionInfo> builtinPrivateFunctionsSet = new HashMap<>(); 
 private static final Map<IFunctionInfo, IFunctionInfo> builtinPublicFunctionsSet = new HashMap<>(); private static final Map<IFunctionInfo, IFunctionInfo> builtinPrivateFunctionsSet = new HashMap<>(); 
 private static final Map<IFunctionInfo, IResultTypeComputer> funTypeComputer = new HashMap<>(); 
 private static final Map<IFunctionInfo, IResultTypeComputer> funTypeComputer = new HashMap<>(); 
 public static final FunctionIdentifier TYPE_OF = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "type-of", 1); public static final FunctionIdentifier GET_HANDLE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 public static final FunctionIdentifier TYPE_OF = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "type-of", 1); public static final FunctionIdentifier GET_HANDLE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 public static final FunctionIdentifier TYPE_OF = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "type-of", 1); public static final FunctionIdentifier GET_HANDLE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 public static final FunctionIdentifier TYPE_OF = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "type-of", 1); public static final FunctionIdentifier GET_HANDLE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 public static final FunctionIdentifier TYPE_OF = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "type-of", 1); public static final FunctionIdentifier GET_HANDLE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 public static final FunctionIdentifier TYPE_OF = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "type-of", 1); public static final FunctionIdentifier GET_HANDLE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 public static final FunctionIdentifier CONCAT_NON_NULL = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 private final Triple<IVisitablePointable, IAType, Boolean> nestedVisitorArg = new Triple<>(fieldTempReference, null, null); 
 private final Triple<IVisitablePointable, IAType, Boolean> nestedVisitorArg = new Triple<>(fieldTempReference, null, null); 
 List<String> fieldPath = new ArrayList<>(); 
 protected IAType getResultType(ILogicalExpression expr, IAType... strippedInputTypes) throws AlgebricksException { 
 return type; } 
 AbstractComplexType nestedType = (AbstractComplexType) fieldType; 
 Map<String, ClusterPartition[]> nodePartitions = ((IAsterixPropertiesProvider) appContextProvider.getAppContext()).getMetadataProperties() .getNodePartitions(); 
 /** * this method is called sequentially by LogPage (notifyReplicationTerminator) * for JOB_COMMIT and JOB_ABORT log types. */ 
 private static final int INITIAL_REPLICATION_FACTOR = 1; 
 replicationJobsQ = new LinkedBlockingQueue<>(); replicaEventsQ = new LinkedBlockingQueue<>(); 
 replicas = new HashMap<>(); jobCommitAcks = new ConcurrentHashMap<>(); replicationJobsPendingAcks = new ConcurrentHashMap<>(); shuttingDownReplicaIds = new HashSet<>(); 
 replicas = new HashMap<>(); jobCommitAcks = new ConcurrentHashMap<>(); replicationJobsPendingAcks = new ConcurrentHashMap<>(); shuttingDownReplicaIds = new HashSet<>(); 
 int logBufferSize = replicationProperties.getLogBufferPageSize(); 
 Thread.currentThread().interrupt(); 
 replicationSuspended.wait(); 
 currentTxnLogBuffer = emptyLogBuffersQ.take(); 
 /** * since this is LSM_COMPONENT REPLICATE job, the job will contain * only the component being replicated. */ 
 handleReplicationFailure(socketChannel, e); 
 handleReplicationFailure(socketChannel, e); 
 Thread.currentThread().interrupt(); 
 if (LOGGER.isLoggable(Level.SEVERE)) { LOGGER.log(Level.SEVERE, "TxnLogReplicator thread terminated abnormally", e); } 
<|del|> 
<|del|> 
 handleReplicationFailure(clientSocket, e); 
 handleReplicationFailure(clientSocket, e); 
 handleReplicationFailure(clientSocket, e); 
 handleReplicationFailure(clientSocket, e); 
 handleReplicationFailure(clientSocket, e); 
 Thread.currentThread().interrupt(); 
 } else if (newState == ReplicaState.DEAD && replicationFactor > INITIAL_REPLICATION_FACTOR) { replicationFactor--; 
 Map<String, SocketChannel> replicaNodesSockets = new HashMap<>(); 
 } catch (IOException e) { if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Could not get replica socket", e); } 
 Set<String> replicasIds = new HashSet<>(); 
 Set<String> replicasIds = new HashSet<>(); 
 } LOGGER.log(Level.INFO, "Got shutdown notification from all remote replicas"); //close replication channel asterixAppRuntimeContextProvider.getAppContext().getReplicationChannel().close(); LOGGER.log(Level.INFO, "Replication manager stopped."); 
 } LOGGER.log(Level.INFO, "Got shutdown notification from all remote replicas"); //close replication channel asterixAppRuntimeContextProvider.getAppContext().getReplicationChannel().close(); LOGGER.log(Level.INFO, "Replication manager stopped."); 
 /** * 4. update the LSN_MAP for indexes that were not flushed * to the current append LSN to indicate no operations happened * since the checkpoint start. */ 
 Map<String, SocketChannel> replicaSockets = new HashMap<>(); 
 Thread.currentThread().interrupt(); 
 if (replicationJobsQ.isEmpty()) { 
 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } catch (IOException e) { if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Couldn't complete processing replication job", e); } 
 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } catch (IOException e) { if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Couldn't complete processing replication job", e); } 
 private ILogicalOperator translateUpsert(DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef, List<Mutable<ILogicalExpression>> varRefsForLoading, 
 private ILogicalOperator translateUpsert(DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef, List<Mutable<ILogicalExpression>> varRefsForLoading, 
 LogicalOperatorDeepCopyWithNewVariablesVisitor visitor = new LogicalOperatorDeepCopyWithNewVariablesVisitor(context, null); 
 String responseLine = incomingResponse.readLine(); 
 addAckToJob(jobId, ackFrom); 
 } catch (AsynchronousCloseException e) { if (LOGGER.isLoggable(Level.INFO)) { LOGGER.log(Level.INFO, "Replication listener stopped for remote replica: " + replicaId, e); } } catch (IOException e) { handleReplicationFailure(replicaSocket, e); 
 Thread.currentThread().interrupt(); 
 Thread.currentThread().interrupt(); 
 public static final ConstantExpression MISSING = new ConstantExpression(new IAlgebricksConstantValue() { 
 private Map<Object, IExpressionAnnotation> annotationMap = new HashMap<>(); 
 Map<Object, IExpressionAnnotation> m = new HashMap<>(); for (Entry<Object, IExpressionAnnotation> entry : annotationMap.entrySet()) { IExpressionAnnotation annot2 = entry.getValue().copy(); m.put(entry.getKey(), annot2); 
 Map<Object, IExpressionAnnotation> m = new HashMap<>(); for (Entry<Object, IExpressionAnnotation> entry : annotationMap.entrySet()) { IExpressionAnnotation annot2 = entry.getValue().copy(); m.put(entry.getKey(), annot2); 
 UNPARTITIONED, /** * PARTITIONED, the input data is partitioned, the operator is executed on * each partition and may receive input from other partitions (e.g. if it is * a join or an aggregate) */ 
 private final Map<String, Object> annotations = new HashMap<>(); 
 protected final List<Mutable<ILogicalOperator>> inputs; 
 inputs = new ArrayList<>(); 
<|del|> 
 IPredicateEvaluatorFactoryProvider predEvaluatorFactoryProvider = context .getPredicateEvaluatorFactoryProvider(); IPredicateEvaluatorFactory predEvaluatorFactory = (predEvaluatorFactoryProvider == null ? null : predEvaluatorFactoryProvider.getPredicateEvaluatorFactory(keysLeft, keysRight)); 
 IPredicateEvaluatorFactoryProvider predEvaluatorFactoryProvider = context .getPredicateEvaluatorFactoryProvider(); IPredicateEvaluatorFactory predEvaluatorFactory = (predEvaluatorFactoryProvider == null ? null : predEvaluatorFactoryProvider.getPredicateEvaluatorFactory(keysLeft, keysRight)); 
 protected List<ILocalStructuralProperty> deliveredLocalProperties(ILogicalOperator op, IOptimizationContext context) { 
 List<ILocalStructuralProperty> propsLocal = new ArrayList<>(); 
 assert subplans.length == 1; 
 private final List<List<LogicalVariable>> correlatedNullableVariableLists = new ArrayList<>(); 
 Map<LogicalVariable, Integer> varSizeMap = new HashMap<>(); 
 private HashSet<LogicalVariable> notToBeInlinedVars = new HashSet<>(); 
 private HashSet<LogicalVariable> notToBeInlinedVars = new HashSet<>(); 
 protected final Map<ILogicalOperator, List<FunctionalDependency>> fdGlobalMap = new HashMap<>(); protected final Map<ILogicalOperator, Map<LogicalVariable, EquivalenceClass>> eqClassGlobalMap = new HashMap<>(); 
 protected final Map<ILogicalOperator, List<FunctionalDependency>> fdGlobalMap = new HashMap<>(); protected final Map<ILogicalOperator, Map<LogicalVariable, EquivalenceClass>> eqClassGlobalMap = new HashMap<>(); 
 protected final Map<ILogicalOperator, List<FunctionalDependency>> fdGlobalMap = new HashMap<>(); protected final Map<ILogicalOperator, Map<LogicalVariable, EquivalenceClass>> eqClassGlobalMap = new HashMap<>(); 
 protected final Map<ILogicalOperator, ILogicalPropertiesVector> logicalProps = new HashMap<>(); 
 protected final Map<ILogicalOperator, ILogicalPropertiesVector> logicalProps = new HashMap<>(); 
 protected final Map<ILogicalOperator, ILogicalPropertiesVector> logicalProps = new HashMap<>(); 
 protected final Map<ILogicalOperator, ILogicalPropertiesVector> logicalProps = new HashMap<>(); 
 HashSet<ILogicalOperator> os = new HashSet<>(); 
 HashSet<ILogicalOperator> newEntry = new HashSet<>(); 
 return fd == null ? null : new ArrayList<>(fd.getHead()); 
 return fd == null ? null : new ArrayList<>(fd.getHead()); 
 List<LogicalVariable> hd = new ArrayList<>(); 
 List<LogicalVariable> tl = new ArrayList<>(); 
 buffers = new ArrayList<>(); 
 } int bIndex = storedTuplePointer.getFrameIndex(); int tIndex = storedTuplePointer.getTupleIndex(); 
 * or add new features 
 List<IAlgebraicRewriteRule> translationRules = new LinkedList<>(); translationRules.add(new TranslateIntervalExpressionRule()); translationRules.add(new ExtractGroupByDecorVariablesRule()); return translationRules; 
 * based on the available type and metadata information. 
 if (includeWithVariables || !liveVar.getVar().namedValueAccess()) { 
<|del|> 
 // get substituted first if some of their child expressions are present as keys in the exprMap. 
 throw new AlgebricksException("The second argument of a field access should be an STRING, but it is " 
 first = true; 
 if (!first) { 
<|del|> 
 private static List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> buildDefaultLogicalRewrites(CompilerExtensionManager ccExtensionManager) { 
 private static List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> buildDefaultLogicalRewrites(CompilerExtensionManager ccExtensionManager) { 
 private static List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> buildDefaultLogicalRewrites(CompilerExtensionManager ccExtensionManager) { 
 private static List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> buildDefaultLogicalRewrites(CompilerExtensionManager ccExtensionManager) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 defaultLogicalRewrites .add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection(ccExtensionManager))); defaultLogicalRewrites 
 defaultLogicalRewrites .add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection(ccExtensionManager))); defaultLogicalRewrites 
 defaultLogicalRewrites .add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection(ccExtensionManager))); defaultLogicalRewrites 
 defaultLogicalRewrites .add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection(ccExtensionManager))); defaultLogicalRewrites 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 defaultLogicalRewrites .add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection(ccExtensionManager))); defaultLogicalRewrites 
 defaultLogicalRewrites .add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection(ccExtensionManager))); defaultLogicalRewrites 
 defaultLogicalRewrites .add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection(ccExtensionManager))); defaultLogicalRewrites 
 defaultLogicalRewrites .add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection(ccExtensionManager))); defaultLogicalRewrites 
 public Pair<Query, Integer> reWriteQuery(List<FunctionDecl> declaredFunctions, MetadataProvider metadataProvider, 
 public Pair<Query, Integer> reWriteQuery(List<FunctionDecl> declaredFunctions, MetadataProvider metadataProvider, 
 public Pair<Query, Integer> reWriteQuery(List<FunctionDecl> declaredFunctions, MetadataProvider metadataProvider, 
 MetadataProvider queryMetadataProvider, Query rwQ, int varCounter, String outputDatasetName, 
 MetadataProvider queryMetadataProvider, Query rwQ, int varCounter, String outputDatasetName, 
 private static final long COMPILER_EXTERNAL_GROUP_TABLE_SIZE_DEFAULT = 16 << 20; // 16MB 
 public enum InsertResultType { 
 // If not, we continue to spill another partitions. 
 private final int frameCapacity; private int currentFrameNumberForInsert = 0; 
 private final int frameCapacity; private int currentFrameNumberForInsert = 0; 
 private final int frameCapacity; private int currentFrameNumberForInsert = 0; 
 private final int frameCapacity; private int currentFrameNumberForInsert = 0; 
 case ASSIGN: 
 case AGGREGATE: 
 case UNNEST: 
 case UNIONALL: 
 if (projection.star()) { 
 if (projection.star()) { 
 if (projection.star()) { 
 if (projection.star()) { 
 if (projection.star()) { 
 for (int i = n - 1; i >= 0; i--) { 
 for (int i = n - 1; i >= 0; i--) { 
 for (int i = n - 1; i >= 0; i--) { 
 for (int i = n - 1; i >= 0; i--) { 
<|del|> 
<|del|> 
 public ActiveSourceOperatorNodePushable getRuntime(ActiveRuntimeId runtimeId) { 
public class ExtensionFunctionIdentifier extends FunctionIdentifier { //TODO: remove this classs 
import org.apache.asterix.lang.common.util.FunctionUtil; 
 } 
import org.apache.asterix.lang.common.base.Expression.Kind; import org.apache.asterix.lang.common.base.ILangExpression; 
 List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> defaultLogicalRewrites = new ArrayList<>(); 
<|del|> 
 if ((st.getCategory() & getAllowedCategories()) == 0) { 
 ERROR_MESSAGE_COMPONENT_CONFLICT, le.getId(), cp.first, lang.toString()); 
 * * @param list 
 * 
<|del|> 
 public class Category { /** no modifications */ public static final byte QUERY = 0x01; /** modify data */ 
 private static final int COMPILER_FRAMESIZE_DEFAULT = StorageUtil.getSizeInBytes(32, KILOBYTE); 
 throw new AlgebricksException( "Unnest or index access expects the input to be a collection, but it was of type " 
 public static void init(boolean deleteOldInstanceData) throws Exception { 
 } private static class ByteValueStringInfo { public double value; public StorageUnit unitType; ByteValueStringInfo() { value = 0.0; unitType = StorageUnit.BYTE; } } 
 @Override public int hashCode() { return super.hashCode() + extensionId.hashCode(); } @Override 
 } 
 this.parserFactory = compilationProvider.getParserFactory(); 
<|del|> 
 for (int i = 0; i < nodePartitions; i++) { 
 JSONTokener tokener = new JSONTokener( new InputStreamReader(new ByteArrayInputStream(outputStream.toByteArray()))); 
<|del|> 
 public IConnectorDescriptor clone(IConnectorDescriptorRegistry registry); 
 /** * Return the number of entire frames that are allocated to this buffer manager. * * @return an integer value */ 
<|del|> 
<|del|> 
 int expectedByteSizeOfHashTableForGroupBy = SerializableHashTable.getExpectedByteSizeOfHashTable(tableSize); 
 return getNumFrames() > framesLimit; 
 public static final class Tweet_Place { 
 public static final class Tweet_User { 
<|del|> 
 OptimizableFuncExpr newOptFuncExpr; 
 "Phrase search in Full-text is not yet supported. Only one keyword per expression is permitted." 
 String arg2Value; AOrderedList aOList; AUnorderedList aUnOList; 
 if (objectFromExpr.getType() == BuiltinType.ASTRING) { 
 if (objectFromExpr.getType() == BuiltinType.ASTRING) { 
 case JACCARD: 
<|del|> 
 Pair<ILogicalExpression, Mutable<ILogicalOperator>> p2; 
 return new Pair<>(a, assignedVar); 
 return new Pair<>(a, assignedVar); 
 default: 
 List<Expression> exprs = new ArrayList<>(oldExprList.size()); 
 return new Pair<>(oe, env); 
 public static final FunctionIdentifier EDIT_DISTANCE_STRING_CONTAINS = new FunctionIdentifier( FunctionConstants.ASTERIX_NS, "edit-distance-string-contains", 3); 
public class AsterixConstantExpressionUtil { private AsterixConstantExpressionUtil() { throw new IllegalAccessError("Constant Expression Utility class"); } 
 private transient IBinaryTokenizer tokenizerForLeftArray = null; private transient IBinaryTokenizer tokenizerForRightArray = null; 
 private transient IBinaryTokenizer tokenizerForLeftArray = null; private transient IBinaryTokenizer tokenizerForRightArray = null; 
 private transient IBinaryHashFunction hashFunc = null; 
 private transient IBinaryHashFunction hashFunc = null; 
 private transient BinaryEntry keyEntry = null; 
 private transient BinaryHashSet rightHashSet = null; 
 numBytesToStoreLength = UTF8StringUtil.getNumBytesToStoreLength( UTF8StringUtil.getUTFLength(tokenizerForRightArray.getToken().getData(), tokenizerForRightArray.getToken().getStartOffset())); 
 "Phrase search in Full-text is not supported. An expression should only include only one word."); 
 "Phrase search in Full-text is not supported. An expression should only include only one word." 
 private final List<ByteBuffer> frames = new ArrayList<>(); 
 int frameNum; int frameOff; int entryKeyOff; int entryKeyLen; int entryCount; 
 int frameNum; int frameOff; int entryKeyOff; int entryKeyLen; int entryCount; 
 int frameNum; int frameOff; int entryKeyOff; int entryKeyLen; int entryCount; 
 int frameNum; int frameOff; int entryKeyOff; int entryKeyLen; int entryCount; 
 int frameNum; int frameOff; int entryKeyOff; int entryKeyLen; int entryCount; 
<|del|> 
 if (hasNextFound || hasNext()) { hasNextFound = false; return val; } else { throw new NoSuchElementException("No more elements in this set."); } 
 public SerializableHashTable(int tableSize, final IHyracksFrameMgrContext ctx) throws HyracksDataException { 
 "Phrase search in Full-text is not supported. An expression should include only one word."); 
 "Phrase search in Full-text is not supported. An expression should include only one word."); 
 "Phrase search in Full-text is not supported. An expression should include only one word."); 
 public static final String disjunctiveFTSearchOption = "any"; public static final String conjunctiveFTSearchOption = "all"; 
 public static final String disjunctiveFTSearchOption = "any"; public static final String conjunctiveFTSearchOption = "all"; 
 protected static final byte[] disjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(disjunctiveFTSearchOption); protected static final byte[] conjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(conjunctiveFTSearchOption); 
 protected static final byte[] disjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(disjunctiveFTSearchOption); protected static final byte[] conjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(conjunctiveFTSearchOption); 
 protected static final byte[] disjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(disjunctiveFTSearchOption); protected static final byte[] conjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(conjunctiveFTSearchOption); 
 protected static final byte[] disjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(disjunctiveFTSearchOption); protected static final byte[] conjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(conjunctiveFTSearchOption); 
 protected static final byte[] disjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(disjunctiveFTSearchOption); protected static final byte[] conjunctiveFTSearchOptionArray = UTF8StringUtil .writeStringToBytes(conjunctiveFTSearchOption); 
 private static final int NUM_PARAMS = 1; private static final int FTAnyAllOptionPosFromTheEndOfArg = 1; 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } finally { 
 } finally { 
 } finally { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (Exception e) { 
 } catch (Exception e) { 
 } catch (Exception e) { 
 } catch (Exception e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 } catch (IllegalStateException | IOException e) { 
 webServer = new Server(externalProperties.getWebInterfacePort()); 
 feedServer = new Server(externalProperties.getFeedServerPort()); 
 aInt8.setValue(arg >= 0.0f ? (byte) (arg > 0.0f ? 1 : 0) : -1); 
 aInt8.setValue(arg >= 0.0d ? (byte) (arg > 0.0d ? 1 : 0) : -1); 
 Mutable<ILogicalOperator> opRef = subTree.getAssignsAndUnnestsRefs().isEmpty() ? null : subTree.getAssignsAndUnnestsRefs().get(0); 
 AbstractDataSourceOperator dataSourceOp = (AbstractDataSourceOperator) indexSubTree.getDataSourceRef().getValue(); 
 AbstractDataSourceOperator dataSourceOp = (AbstractDataSourceOperator) indexSubTree.getDataSourceRef().getValue(); 
 public ClusterControllerService cc; public NodeControllerService[] ncs; public IHyracksClientConnection hcc; 
 private AsterixPropertiesAccessor propertiesAccessor; 
 private AsterixPropertiesAccessor propertiesAccessor; 
 private AsterixPropertiesAccessor propertiesAccessor; 
<|del|> 
<|del|> 
 private final Map<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> connectorOpMap; 
 LOGGER.severe("Interrupted while waiting for recovery"); Thread.currentThread().interrupt(); 
 return ObjectUtils.hashCodeMulti(getName().hashCode(), version); 
 return ObjectUtils.hashCodeMulti(dataverseName, datasetName, fileName); 
 "string-contains", 2); 
 "string-contains", 2); 
 return new ConstantExpression(new AsterixConstantValue(b ? ABoolean.TRUE : ABoolean.FALSE)); 
 if (!hasNextFound) { return hasNextElement(false); } else { return true; } 
 if (hasNextFound || hasNext()) { hasNextFound = false; return val; } else { throw new NoSuchElementException("No more elements in this set."); } 
 ListSet<LogicalVariable> searchKeyVars = new ListSet<>(); 
 ListSet<LogicalVariable> searchKeyVars = new ListSet<>(); 
 List<ILocalStructuralProperty> propsLocal = new ArrayList<>(); List<OrderColumn> orderColumns = new ArrayList<>(); 
 LogicalOperatorDeepCopyWithNewVariablesVisitor visitor = 
 ILocalResourceRepositoryFactory persistentLocalResourceRepositoryFactory = 
 IAsterixAppRuntimeContextProvider asterixAppRuntimeContextProvider = 
 new Index(dataverseName, datasetName, indexName, index.getIndexType(), 
 index.isEnforcingKeyFileds(), index.isPrimaryIndex(), 
 protected void handleCreateFeedPolicyStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 protected void handleCreateFeedPolicyStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 AsterixLSMInsertDeleteOperatorNodePushable indexOp = 
 JobSpecification jobSpec, IAdapterFactory adapterFactory, RecordDescriptor rDesc) throws AlgebricksException { 
 LogicalOperatorDeepCopyWithNewVariablesVisitor visitor = new LogicalOperatorDeepCopyWithNewVariablesVisitor(context, null); 
 ILocalResourceRepositoryFactory persistentLocalResourceRepositoryFactory = new PersistentLocalResourceRepositoryFactory(ioManager, ncApplicationContext.getNodeId(), metadataProperties); 
 IAsterixAppRuntimeContextProvider asterixAppRuntimeContextProvider = new AsterixAppRuntimeContextProviderForRecovery(this); 
 protected void handleCreateFeedStatement(AqlMetadataProvider metadataProvider, Statement stmt) throws Exception { 
 + "Is the server configuration correct (node names, buffer sizes, framesize)? " + "Check the logfiles for more details."); 
 throw new AlgebricksException("The vertex class of your Pregelix query was not found. " + "Does it exist? Is the spelling correct?"); 
 throw new AlgebricksException("The vertex class of your Pregelix query was not found. " + "Does it exist? Is the spelling correct?"); 
 private static GlobalRecoveryManager instance; private static ClusterState state; 
 private GlobalRecoveryManager(HyracksConnection hcc) { 
 AsterixLSMInsertDeleteOperatorNodePushable indexOp = (AsterixLSMInsertDeleteOperatorNodePushable) insertOperator; 
 private static final String NOT_ALLOWED_EXPRESSIONS_ERROR_MESSAGE = 
 JobSpecification jobSpec, IAdapterFactory adapterFactory, RecordDescriptor rDesc) throws AlgebricksException { 
 Pair<IBinaryComparatorFactory[], ITypeTraits[]> comparatorFactoriesAndTypeTraits = getComparatorFactoriesAndTypeTraitsOfSecondaryBTreeIndex( 
 ExternalBTreeWithBuddyDataflowHelperFactory indexDataflowHelperFactory = new ExternalBTreeWithBuddyDataflowHelperFactory( 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> spPc = splitProviderAndPartitionConstraintsForDataset( 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 IPrimitiveValueProviderFactory[] valueProviderFactories = new IPrimitiveValueProviderFactory[numSecondaryKeys]; 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 IPrimitiveValueProviderFactory[] valueProviderFactories = new IPrimitiveValueProviderFactory[numSecondaryKeys]; 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( 
 return aqlMetadataProvider.buildLoadableDatasetScan(jobSpec, adapterFactory, rDesc); 
 private transient UnorderedListBuilder listBuilder = new UnorderedListBuilder(); private transient ArrayBackedValueStorage itemValue = new ArrayBackedValueStorage(); 
 private transient UnorderedListBuilder listBuilder = new UnorderedListBuilder(); private transient ArrayBackedValueStorage itemValue = new ArrayBackedValueStorage(); 
 && optFuncExpr.getOperatorSubTree(0).getDataset() != null && !optFuncExpr.getOperatorSubTree(0) .getDataset().getDatasetName().equals(indexSubTree.getDataset().getDatasetName())) { 
 MutableObject<ProgressState> progress = new MutableObject<>(ProgressState.NO_PROGRESS); MutableObject<MetadataTransactionContext> mdTxnCtx = new MutableObject<>( MetadataManager.INSTANCE.beginTransaction()); 
 FeedRuntimeType connectionLocation; 
 if (indexes.isEmpty()) { 
<|del|> 
 throw new AsterixException("Failed to read configuration file " + fileName, e); 
 asterixConfigurationParams = new HashMap<>(); 
 if (mdNode == null || cfg.getString(section, AsterixProperties.PROPERTY_METADATA_PORT) != null) { 
 newMetadataNode = ncId; 
 private static final String NOT_ALLOWED_EXPRESSIONS_ERROR_MESSAGE = "JSON record can only have expressions [%1$s, %2$s, %3$s]"; 
public interface IMetadataIndex extends Serializable { 
 Dataset externalDataset = ((DatasetDataSource) dataSource).getDataset(); String itemTypeName = externalDataset.getItemTypeName(); 
 return new Pair<>(feedCollector, new AlgebricksAbsolutePartitionConstraint(getLocations())); 
 protected ISerializerDeserializer<AString> stringSerde = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.ASTRING); 
 protected final transient IARecordBuilder recordBuilder; protected final transient ArrayBackedValueStorage fieldValue; protected final transient ArrayTupleBuilder tupleBuilder; protected final transient ArrayTupleReference tuple; 
 protected final transient IARecordBuilder recordBuilder; protected final transient ArrayBackedValueStorage fieldValue; protected final transient ArrayTupleBuilder tupleBuilder; protected final transient ArrayTupleReference tuple; 
 protected final transient IARecordBuilder recordBuilder; protected final transient ArrayBackedValueStorage fieldValue; protected final transient ArrayTupleBuilder tupleBuilder; protected final transient ArrayTupleReference tuple; 
 protected final transient IARecordBuilder recordBuilder; protected final transient ArrayBackedValueStorage fieldValue; protected final transient ArrayTupleBuilder tupleBuilder; protected final transient ArrayTupleReference tuple; 
 protected final transient AMutableInt32 aInt32; protected final transient ISerializerDeserializer<AInt32> aInt32Serde; protected final transient ArrayBackedValueStorage fieldName = new ArrayBackedValueStorage(); 
 protected final transient AMutableInt32 aInt32; protected final transient ISerializerDeserializer<AInt32> aInt32Serde; protected final transient ArrayBackedValueStorage fieldName = new ArrayBackedValueStorage(); 
 private transient AMutableInt32 aInt32; 
 protected transient AMutableInt32 aInt32 = new AMutableInt32(0); protected transient AMutableDateTime aDateTime = new AMutableDateTime(0); protected transient AMutableInt64 aInt64 = new AMutableInt64(0); 
 protected transient AMutableInt32 aInt32 = new AMutableInt32(0); protected transient AMutableDateTime aDateTime = new AMutableDateTime(0); protected transient AMutableInt64 aInt64 = new AMutableInt64(0); 
 protected transient AMutableInt32 aInt32 = new AMutableInt32(0); protected transient AMutableDateTime aDateTime = new AMutableDateTime(0); protected transient AMutableInt64 aInt64 = new AMutableInt64(0); 
 private ISerializerDeserializer<AInt32> intSerde = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.AINT32); 
 private ISerializerDeserializer<AInt32> intSerde = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.AINT32); 
 private ISerializerDeserializer<AInt32> intSerde = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.AINT32); 
 private ISerializerDeserializer<AInt32> intSerde = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.AINT32); 
 List<LogicalVariable> lowKeyVarList, List<LogicalVariable> highKeyVarList) { 
 boolean retainInput, boolean requiresBroadcast) { 
 return Collections.emptyList(); 
 LONG 
 private final transient ARecord record; 
 private final transient ARecord record; 
<|del|> 
<|del|> 
<|del|> 
 // Fail if primary keys could not be inferred. 
 // To make sure the rule only runs once. private boolean hasRun = false; 
 public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { 
 AssignOperator newAssign = new AssignOperator(newVar, new MutableObject<ILogicalExpression>(exprRef .getValue().cloneExpression())); 
 public IPointable createPointable() { 
 StringRegExpPositionDescriptor.this.getIdentifier()) { private final RegExpMatcher matcher = new RegExpMatcher(); 
 public StringLTrimEvaluator(IHyracksTaskContext context, IScalarEvaluatorFactory evalFactory, 
 public StringRTrimEvaluator(IHyracksTaskContext context, IScalarEvaluatorFactory evalFactory, 
<|del|> 
 try (LittleEndianIntInputStream in = new LittleEndianIntInputStream(new BufferedInputStream(new FileInputStream(fileName)))) { 
 try (LittleEndianIntInputStream in = new LittleEndianIntInputStream(new BufferedInputStream(new FileInputStream(fileName)))) { 
 if (curRecType != null) { 
 if (curRecType != null) { 
 if (curRecType != null) { 
 if (curRecType != null) { 
<|del|> 
<|del|> 
 * This visitor rewrites several variable-arg user-facing functions to their coressponding 
 private StringTrimmer stringTrimmer = new StringTrimmer(resultBuilder, resultArray); 
 private StringTrimmer stringTrimmer = new StringTrimmer(resultBuilder, resultArray, " "); 
 pattern = Pattern.compile(patternString, StringEvaluatorUtils.toFlag(flagPtr.toString())); 
 int len = endIndex - startIndex; builder.reset(out, len); builder.appendUtf8StringPointable(srcPtr, srcPtr.getStartOffset() + srcStart + startIndex, len); 
 return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; 
 return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; 
 return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; 
 return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; 
 return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; 
 } else{ 
 //One of the variables doesn't come from a dataset, i.e. nonpure 
 ILogicalExpression[] getConstantExpressions(); 
 // However, if the op is already using variables that are not live, 
 // Match (assign | unnest | exchange)+. 
<|del|> 
<|del|> 
<|del|> 
 if (!table.insert(accessor, i)) { 
 && arg2.getExpressionTag() == LogicalExpressionTag.CONSTANT) { 
 if (objectFromExpr.getType() == BuiltinType.ASTRING) { 
 } else if (objectFromExpr.getType().getTypeTag() == ATypeTag.ORDEREDLIST) { 
 if (objectFromExpr.getType() == BuiltinType.ASTRING) { 
 } else if (objectFromExpr.getType().getTypeTag() == ATypeTag.UNORDEREDLIST) { 
 if (objectFromExpr.getType() == BuiltinType.ASTRING) { 
 if (obj.getType() == BuiltinType.ASTRING) { 
 if (obj.getType().getTypeTag() == ATypeTag.ORDEREDLIST) { 
 if (obj.getType().getTypeTag() == ATypeTag.UNORDEREDLIST) { 
 public boolean isEntityConnectedToDataset(String dataverseName, String datasetName); 
 unusedJoinBranchIndex = -1; } 
 throws AlgebricksException, HyracksDataException { 
 LOGGER.log(Level.SEVERE, "Global recovery was not completed successfully: ", e); 
 LOGGER.log(Level.SEVERE, "Exception in aborting", e1); 
 for (String nodesName : nodeNames) { MetadataManager.INSTANCE.addNode(mdTxnCtx, new Node(nodesName, 0, 0)); 
 WorkerThread(String id) { setName("Worker:" + id); 
 o.put("classpath", new JSONArray(Arrays.asList(classpath.split(File.pathSeparator)))); o.put("library-path", new JSONArray(Arrays.asList(libraryPath.split(File.pathSeparator)))); o.put("boot-classpath", new JSONArray(Arrays.asList(bootClasspath.split(File.pathSeparator)))); 
 return new Pair<>((result.first || changedAndVarMap.first), returnedMap); 
 return new Pair<>((result.first || changedAndVarMap.first), returnedMap); 
 //add primary keys 
 // Empty tuple source is a special case that can be partitioned in the same way as the data scan. if (child.getOperatorTag() != LogicalOperatorTag.EMPTYTUPLESOURCE) { 
 || subTreeOp.getOperatorTag() == LogicalOperatorTag.EXCHANGE) { 
 if (dataSource.getDatasourceType() != AqlDataSourceType.EXTERNAL_DATASET && dataSource.getDatasourceType() != AqlDataSourceType.INTERNAL_DATASET && dataSource.getDatasourceType() != AqlDataSourceType.LOADABLE) { 
 public boolean isScanAccessPathALeaf(); 
 if (dataSource.isScanAccessPathALeaf()) { 
 new ArrayList<>(); 
 List<ILocalStructuralProperty> propsLocal = new ArrayList<>(); 
<|del|> 
 private ClusterHelper() { } 
 String path = "admin/cluster"; 
 String path = "admin/cluster"; 
 * http://www.apache.org/licenses/LICENSE-2.0 
 CmdLineParser parser = new CmdLineParser(options, ParserProperties.defaults().withUsageWidth(120)); 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * http://www.apache.org/licenses/LICENSE-2.0 
 ILogicalOperator op = opRef.getValue(); 
 ILogicalOperator op = opRef.getValue(); 
 return new Pair<Boolean, Map<LogicalVariable, LogicalVariable>>(true, replacedVarMap); 
<|del|> 
 if (isBoundryOperatorCardinalityOne) { 
 if (isBoundryOperatorCardinalityOne) { 
 return ASTERIX_HELPER; 
 if (!failedRequests.isEmpty()) { 
 * A resource id factory that generates unique resource ids across all NCs by requesting * unique ids from the cluster controller. 
 if (!resourceIdResponseQ.isEmpty()) { 
 if (!resourceIdResponseQ.isEmpty()) { 
 private RuntimeUtils() { } 
 .getFeedPolicy(metadataProvider.getMetadataTxnContext(), dataverse, cfps.getSourcePolicyName()); 
 try { mdTxnCtx = MetadataManager.INSTANCE.beginTransaction(); metadataProvider.setMetadataTxnContext(mdTxnCtx); 
 * 
 * 
 public Map<Long, LocalResource> loadAndGetAllResources() throws HyracksDataException { 
 Map<Long, LocalResource> resourcesMap = new HashMap<>(); 
 filesToBeReplicated = new HashSet<>(); 
 if (storageDir != null && storageDir.isDirectory()) { FileUtils.deleteDirectory(storageDir); 
 public static final AsterixAppContextInfo INSTANCE = new AsterixAppContextInfo(); private ICCApplicationContext appCtx; private IGlobalRecoveryMaanger globalRecoveryMaanger; private ILibraryManager libraryManager; private IAsterixResourceIdManager resourceIdManager; 
 private Map<String, Map<String, String>> activeNcConfiguration = new HashMap<>(); 
 throw new IllegalStateException("Failed to read configuration file " + CLUSTER_CONFIGURATION_FILE, e); 
 AsterixAppContextInfo.INSTANCE.getGlobalRecoveryManager().startGlobalRecovery(); if (autoFailover && !pendingProcessingFailbackPlans.isEmpty()) { processPendingFailbackPlans(); 
 AsterixAppContextInfo.INSTANCE.getGlobalRecoveryManager().startGlobalRecovery(); if (autoFailover && !pendingProcessingFailbackPlans.isEmpty()) { processPendingFailbackPlans(); 
 if (!lostPartitions.isEmpty()) { 
 for (Entry<String, List<Integer>> entry : partitionRecoveryPlan.entrySet()) { String replica = entry.getKey(); Integer[] partitionsToTakeover = entry.getValue().toArray(new Integer[entry.getValue().size()]); 
 LOGGER.log(Level.WARNING, "Failed to send takeover request: " + takeoverRequest, e); 
 LOGGER.log(Level.WARNING, "Failed to send metadata node takeover request to: " + metadataPartiton.getActiveNodeId(), e); 
 LOGGER.log(Level.WARNING, "Failed to send complete failback request to: " + request.getNodeId(), e); 
 LOGGER.log(Level.WARNING, "Failed to send complete failback request to: " + request.getNodeId(), e); 
 LOGGER.log(Level.WARNING, "Failed sending an application message to an NC", e); 
 LOGGER.log(Level.WARNING, "Failed sending an application message to an NC", e); 
 if (!isScanOrUnnest(op)) { 
<|del|> 
 comparatorFactories = DatasetUtils.computeKeysBinaryComparatorFactories(dataset, itemType, metaItemType, 
 ISearchOperationCallbackFactory searchCallbackFactory; 
 public IScalarEvaluatorFactory createEvaluatorFactory(IScalarEvaluatorFactory[] args) { 
 int nextMatchStart; 
 throw new AlgebricksException(e1); 
 // The grammar guarantees that the BETWEEN operator gets exactly three expressions. 
 private static int INVALID_VALUE = 0xFFFFFFFF; private static byte INVALID_BYTE_VALUE = (byte) 0xFF; private double garbageCollectionThreshold; 
 int numberOfHeaderFrame = (int) ((double) tableSize * 2 / (double) frameSize); int numberOfContentFrame = (int) (((double) getNumberOfEntryInSlot() * 2 * getUnitSize() * tableSize) / (double) frameSize); 
<|del|> 
<|del|> 
 currentReadContentFrameForGC = contents.get(gcInfo.currentReadPageForGC); 
 while (gcInfo.currentReadIntOffsetInPageForGC < frameCapacity) { 
 oneTimeIntCapacityForWriter = Math.min(chunksToMove, frameCapacity - tempWriteIntPosInPage); oneTimeIntCapacityForReader = Math.min(chunksToMove, frameCapacity - tempReadIntPosInPage); 
 // Since the location of Reader and Writer are different, we can only move a minimum chunk // before the current page of either Reader or Writer changes. 
 chunksToDeleteAtThisTime = Math.min(chunksToDelete, frameCapacity - tempReadIntPosInPage); 
 List<Mutable<ILogicalExpression>> originalKeyExprList = new ArrayList<>(); 
 args.add(new MutableObject<>(eo.first)); 
 AbstractFunctionCallExpression f; 
 if (!isScanOrUnnest(op)) { 
 return operator.accept(visitor, null) <= 1; 
 if (!isScanOrUnnest(op2) && !descOrSelfIsSourceScan(op2)) { 
 if (op.getOperatorTag() == LogicalOperatorTag.DATASOURCESCAN) { 
 outer: while (i < count) { 
 while (storeIt.hasNext()) { 
 i++; if (i == count) { break outer; } 
 } catch (IllegalArgumentException e) { //NOSONAR - exception not logged or rethrown response.sendError(HttpServletResponse.SC_NOT_FOUND); 
 if (parts.length == 1) { 
 throw new IllegalArgumentException(); } else if (parts.length == 2) { JSONObject json; 
 } } private void fixupKeys(JSONObject json) throws JSONException { // TODO (mblow): generate the keys with _ to begin with 
 throw new IllegalArgumentException(); 
<|del|> 
 * @param includeConfig @return serialized JSON containing the node details 
 this.indexes = new HashMap<>(); 
 Set<ILSMIndex> datasetIndexes = new HashSet<>(); 
<|del|> 
<|del|> 
 return storageProperties.getMemoryComponentPageSize() * ((long) numPages); 
 // this should not be done this way. dataset lifecycle manager shouldn't return virtual buffer caches for // a dataset that was not yet created 
 public CheckpointThread(IRecoveryManager recoveryMgr, ILogManager logManager, 
 public CheckpointThread(IRecoveryManager recoveryMgr, ILogManager logManager, 
 public synchronized static IResourceLifecycleManager<IIndex> getIndexLifecycleManager() { 
 // This computer is needed to calculate the hash value of a aggregated tuple // while doing the garbage collection work on Hash Table. final ITuplePartitionComputer tpcIntermediate = new FieldHashPartitionComputerFamily(intermediateResultKeys, 
 * @return the result of an insertion - success, fail, or succeeded but exceeded the memory budget 
 boolean isGarbageCollectionNeeded(); 
 lastContentFrame.writeInvalidVal(lastOffsetInCurrentFrame, frameCapacity - lastOffsetInCurrentFrame); 
 Arrays.fill(frame.bytes, INVALID_BYTE_VALUE); 
 // Keeps the garbage collection related variable GarbageCollectionInfo gcInfo = new GarbageCollectionInfo(); 
 currentReadContentFrameForGC.writeInvalidVal(tempReadIntPosInPage, chunksToDeleteAtThisTime); 
 primaryKeyLogicalVars = new ArrayList<>(); 
 * pattern match: commit insert assign 
 * pattern match: commit insert assign 
 * pattern match: commit insert assign 
<|del|> 
 if (descendantOp.getInputs().isEmpty()) { 
 List<LogicalVariable> primaryKeyLogicalVars = new ArrayList<>(); 
<|del|> 
 args.add(new MutableObject<>(eo.first)); 
 AssignOperator op = new AssignOperator(v, new MutableObject<>(f)); 
 AssignOperator op = new AssignOperator(v, new MutableObject<>(f)); 
 AbstractFunctionCallExpression f; 
<|del|> 
 handleCreateFeedStatement(metadataProvider, stmt, hcc); 
 ActiveLifecycleEvent e; 
 GregorianCalendarSystem.getInstance().getExtendStringRepUntilField(chrononTime, 0, sbder, GregorianCalendarSystem.Fields.YEAR, GregorianCalendarSystem.Fields.MILLISECOND, true); 
 private static final char[] CHARS; 
 final String ChannelName = "ChannelName"; final String DataverseName = "DataverseName"; 
 final String ChannelName = "ChannelName"; final String DataverseName = "DataverseName"; 
 final String CHANNEL_EXTENSION_NAME = "Channel"; final String subscriptionEnding = "Subscriptions"; final String resultsEnding = "Results"; 
 final String CHANNEL_EXTENSION_NAME = "Channel"; final String subscriptionEnding = "Subscriptions"; final String resultsEnding = "Results"; 
 super(metadataProvider, stmt, hcc); 
 channel = BADLangExtension.getChannel(mdTxnCtx, dataverse, channelName.getValue()); 
<|del|> 
 Expression rightExpr = new LiteralExpr(new StringLiteral(brokerDataverse)); 
 AssignOperator castedRecordAssignOperator = new AssignOperator(castedRecVar, new MutableObject<ILogicalExpression>(castFunc)); 
 AssignOperator castedRecordAssignOperator = new AssignOperator(castedRecVar, new MutableObject<ILogicalExpression>(castFunc)); 
 private void removeRedundantListifies(Map<LogicalVariable, Integer> nspAggVars, Map<LogicalVariable, AbstractOperatorWithNestedPlans> nspWithAgg, 
 case SELECT: 
 case SELECT: 
 case SUBPLAN: 
 case SUBPLAN: 
 default: 
 List<LogicalVariable> aggVars = new ArrayList<>(); // test that the operator computes a "listify" aggregate 
 List<LogicalVariable> aggVars = new ArrayList<>(); // test that the operator computes a "listify" aggregate 
 List<LogicalVariable> aggVars = new ArrayList<>(); // test that the operator computes a "listify" aggregate 
 case FUNCTION_CALL: 
 case FUNCTION_CALL: 
 return new Pair<>(Boolean.TRUE, newVarExpr); 
 return new Pair<>(Boolean.TRUE, varExpr); 
 return new Pair<>(change, fce); 
 case CONSTANT: return new Pair<>(Boolean.FALSE, expr); default: 
 case CONSTANT: return new Pair<>(Boolean.FALSE, expr); default: 
<|del|> 
 private boolean pushSubplanAsAggIntoNestedSubplan(Mutable<ILogicalOperator> subplanOpRef, AbstractOperatorWithNestedPlans nspOp, LogicalVariable varFromNestedAgg, 
 if (!vFree.equals(varFromNestedAgg)) { 
<|del|> 
 if (opRef1InSubplan.getValue().getInputs().isEmpty()) { 
 workQueue.schedule(new NotifyThreadDumpResponse(ClusterControllerService.this, tdrf.getRequestId(), tdrf.getThreadDumpJSON())); 
 public void notifyThreadDump(String nodeId, String requestId, String threadDumpJSON) throws Exception; 
 private void pruneEachClass(boolean[] reserved, List<Mutable<ILogicalOperator>> candidates) throws AlgebricksException { 
 private void gatherProducingDataScans(Mutable<ILogicalOperator> opRef, Set<AbstractUnnestMapOperator> parentWithUM) { 
 parentWithUM.add((AbstractUnnestMapOperator) op); 
 parentWithUM.add((AbstractUnnestMapOperator) op); 
<|del|> 
 String subscriptionsDatasetName = channel.getSubscriptionsDataset(); 
 FieldAccessor fa = new FieldAccessor(vars, new Identifier(BADConstants.SubscriptionId)); 
<|del|>
 UUIDList.add(new LiteralExpr(new StringLiteral(subscriptionId))); 
 DeleteStatement delete = new DeleteStatement(vars, new Identifier(dataverse), new Identifier(subscriptionsDatasetName), condition, varCounter, dataverses, datasets); 
 DeleteStatement delete = new DeleteStatement(vars, new Identifier(dataverse), new Identifier(subscriptionsDatasetName), condition, varCounter, dataverses, datasets); 
 ((QueryTranslator) statementExecutor).handleDeleteStatement(metadataProvider, delete, hcc); 
 QueryTranslator.abort(e, e, mdTxnCtx); throw new HyracksDataException(e); } 
 IHyracksDataset hdc, Stats stats, String dataverse) throws AsterixException, Exception { 
 createDatasets(statementExecutor, subscriptionsName, resultsName, metadataProvider, hcc, hdc, stats, dataverse); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 case UNNEST: 
 case UNNEST: 
<|del|> 
<|del|> 
 protected String takeDump(ThreadMXBean threadMXBean) throws JSONException { 
 Object annotation = op2.getAnnotations().get(IS_MOVABLE); 
 //One of the variables doesn't come from a dataset, i.e. nonpure 
 List<LogicalVariable> vars = new ArrayList<>(); 
 List<LogicalVariable> projectVarsTemp = projectOp.getVariables(); if (liveVars.size() == projectVarsTemp.size() && liveVars.containsAll(projectVarsTemp)) { 
 List<LogicalVariable> orderedLiveVars = new ArrayList<>(); 
 handleCreateFeedStatement(metadataProvider, stmt, hcc); 
 private int removeJoinFromInputBranch(Mutable<ILogicalOperator> opRef, int startBranch) throws AlgebricksException { 
 public void setBeforeOpAdditionalFilteringExpression(Mutable<ILogicalExpression> prevAdditionalFilteringExpression) { 
 // Step1: Initialize the host embedding aql to substitute the fuzzy equal condition such as $r.a ~= $s.b 
 + "((#LEFT_0), " + " (join((#RIGHT_0), " 
 VariableUtilities.getLiveVariables(rightInputOp, liveVars); // rightInputPKs extract all the PKs derived from the downstream of the right branch. 
 if (constVal.getObject().getType().equals(BuiltinType.AFLOAT)) { 
 translator.addOperatorToMetaScope(new VarIdentifier("#RIGHT_" + i), copyVisitor.deepCopy(rightInputOp)); 
 builder.setExpressionRuntimeProvider( new LogicalExpressionJobGenToExpressionRuntimeProviderAdapter(QueryLogicalExpressionJobGen.INSTANCE)); 
 if (startBranch == 1 || unusedJoinBranchIndex != -1) { return unusedJoinBranchIndex; } else { return removeJoinFromInputBranch(opRef, 1); } 
 AbstractFunctionCallExpression f; 
 handleDropFeedPolicyStatement(metadataProvider, stmt, hcc); 
 final String ChannelName = "ChannelName"; final String DataverseName = "DataverseName"; 
 final String ChannelName = "ChannelName"; final String DataverseName = "DataverseName"; 
 final String ResultsDatasetName = "ResultsDatasetName"; final String SubscriptionsDatasetName = "SubscriptionsDatasetName"; 
 final String ResultsDatasetName = "ResultsDatasetName"; final String SubscriptionsDatasetName = "SubscriptionsDatasetName"; 
 final String ResultsDatasetName = "ResultsDatasetName"; final String SubscriptionsDatasetName = "SubscriptionsDatasetName"; 
 final String BAD_DATAVERSE_NAME = "Metadata"; final String Duration = "Duration"; final String Function = "Function"; 
<|del|> 
<|del|> 
 LiteralExpr leftExpr = new LiteralExpr(new StringLiteral(BADConstants.DataverseName)); 
<|del|> 
 AbstractFunctionCallExpression f; 
 handleDropFeedPolicyStatement(metadataProvider, stmt, hcc); 
 if (j != exprAndVarIdx.second) { 
<|del|> 
<|del|> 
 handleInsertUpsertStatement(metadataProvider, stmt, hcc); 
<|del|> 
 LogicalOperatorDeepCopyWithNewVariablesVisitor visitor = new LogicalOperatorDeepCopyWithNewVariablesVisitor(context, null); 
 ResultUtils.webUIErrorHandler(out, e); } finally { out.close(); 
 ResultUtils.webUIErrorHandler(out, e); } finally { out.close(); 
 ResultUtils.webUIErrorHandler(out, e); } finally { out.close(); 
 if (op1.getOperatorTag() == LogicalOperatorTag.DELEGATE_OPERATOR) { DelegateOperator eOp = (DelegateOperator) op1; 
 if (op0.getOperatorTag() != LogicalOperatorTag.DELEGATE_OPERATOR 
 if (op1.getOperatorTag() == LogicalOperatorTag.DELEGATE_OPERATOR) { DelegateOperator eOp = (DelegateOperator) op1; 
 DelegateOperator eOp = (DelegateOperator) op; 
 getAssignsAndUnnestsRefs().add(subTreeOpRef); getAssignsAndUnnests().add(subTreeOp); 
 throw report.getException(); 
 case DELEGATE_OPERATOR: { 
 case DELEGATE_OPERATOR: { 
 protected static String quot = "\""; 
 protected String eol = System.getProperty("line.separator", "\n"); 
<|del|>
<|del|>
<|del|>
 private static final int INVALID_VALUE = 0xFFFFFFFF; private static final byte INVALID_BYTE_VALUE = (byte) 0xFF; 
 private static final int INVALID_VALUE = 0xFFFFFFFF; private static final byte INVALID_BYTE_VALUE = (byte) 0xFF; 
 IntSerDeBuffer currentReadContentFrameForGC; 
<|del|> 
 for (Mutable<ILogicalOperator> inputOpRef : op.getInputs()) { 
 private Set<LogicalVariable> usedVars = new HashSet<>(); 
 private Map<Mutable<ILogicalOperator>, Set<LogicalVariable>> assignedVarMap = new LinkedHashMap<>(); private Set<LogicalVariable> assignedVarSet = new HashSet<>(); 
 boolean targetOpFound = false; 
 //Provided for Extensions but not used by core 
 resourcePartition, isSink); 
 if (op0.getOperatorTag() != LogicalOperatorTag.DELEGATE_OPERATOR 
<|del|> 
 * Retrieve stored functions (from CREATE FUNCTION statements) that have been used in an expression. 
 SplitOperatorDescriptor splitOpDesc = new SplitOperatorDescriptor(spec, recDescriptor, outputArity, intInsepctorFactory, conditionalVarFieldPos); 
<|del|> 
 int resultValue; 
 private int removeJoinFromInputBranch(Mutable<ILogicalOperator> opRef) throws AlgebricksException { 
 private int removeJoinFromInputBranch(Mutable<ILogicalOperator> opRef) throws AlgebricksException { 
 return unusedJoinBranchIndex; 
 nodeId = liveNodes.toArray(new String[liveNodes.size()])[rand.nextInt(Integer.MAX_VALUE) % liveNodes 
 nodeId = liveNodes.toArray(new String[liveNodes.size()])[rand.nextInt(Integer.MAX_VALUE) % liveNodes 
 final Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies = new HashMap<>(jobRun .getConnectorPolicyMap()); 
 public void takeThreadDump(String requestId) throws Exception; 
 public static Object deserialize(ByteBuffer buffer, int length) throws IOException { 
 List<TaskAttemptDescriptor> taskDescriptors = new ArrayList<>(); 
 Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies = new HashMap<>(); 
 flags.add(JobFlag.values()[dis.readInt()]); 
 public static void serialize(OutputStream out, Object object) throws IOException { 
 public static Object deserialize(ByteBuffer buffer, int length) throws IOException { 
 Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, Set<JobFlag> flags) throws Exception { 
 throw new HyracksDataException("Job " + jobId + " already exists"); 
 throw new HyracksDataException(e); 
 } catch (InterruptedException e) { // can safely interrupt thread since this is a task thread 
 AbstractFunctionCallExpression f; 
 handleCreateFeedStatement(metadataProvider, stmt); 
 public void startTasks(DeploymentId deploymentId, JobId jobId, byte[] planBytes, List<TaskAttemptDescriptor> taskDescriptors, Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, EnumSet<JobFlag> flags) throws Exception; 
<|del|> 
 ICachedPage filterPage = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, componentFilterPageId), false); 
 boolean includeMutableComponent, ArrayList<IIndexAccessor> indexAccessors, ArrayList<IIndexAccessor> deletedKeysBTreeAccessors, List<ILSMComponent> operationalComponents) { 
 boolean includeMutableComponent, ArrayList<IIndexAccessor> indexAccessors, ArrayList<IIndexAccessor> deletedKeysBTreeAccessors, List<ILSMComponent> operationalComponents) { 
 boolean checkIfEmptyIndex, boolean appendOnly) throws IndexException, HyracksDataException { 
 boolean checkIfEmptyIndex, boolean appendOnly) throws IndexException, HyracksDataException { 
 IVirtualMetaDataPageManager virtualFreePageManager, int id) throws IndexException { 
 FileReference dictBTreeFileRef, FileReference btreeFileRef, FileReference bloomFilterFileRef, boolean create) throws HyracksDataException, IndexException { 
 FileReference dictBTreeFileRef, FileReference btreeFileRef, FileReference bloomFilterFileRef, boolean create) throws HyracksDataException, IndexException { 
 ISearchOperationCallback searchCallback) throws HyracksDataException { 
 ISearchOperationCallback searchCallback) throws HyracksDataException { 
 if (lastTaskClusterAttempt != null && (lastTaskClusterAttempt.getStatus() == TaskClusterAttempt.TaskClusterStatus.COMPLETED || lastTaskClusterAttempt 
 * @param ta Failed Task Attempt * @param exceptions exeptions thrown during the failure 
 private volatile boolean aborted; 
 aborted = true; 
<|del|> 
<|del|> 
 LOGGER.log(Level.WARNING, "Failure starting task", e); 
 throw new HyracksException("Joblet was not found. This job was most likely aborted."); 
 throw new HyracksException("Joblet was not found. This job was most likely aborted."); 
 if (flags.contains(JobFlag.PROFILE_RUNTIME)) { 
 outputFiles = new ArrayList<File>(); 
<|del|> 
 private static final int REPLICATION_LOG_BUFFER_NUM_PAGES_DEFAULT = 8; 
public class JobSpecificationUtils { private JobSpecificationUtils(){ throw new AssertionError("This util class should not be initialized."); } 
 private JobUtils(){ throw new AssertionError("This util class should not be initialized."); } 
 private CompiledStatements() { throw new AssertionError("This class should not be initialized."); } 
 public CompiledDeleteStatement(String dataverseName, String datasetName, Expression condition, int varCounter, Query query) { 
 private ExternalIndexingOperations() { throw new AssertionError("This class should not be initialized."); } 
<|del|> 
 return index.getIndexName().equals(getFilesIndexName(index.getDatasetName())); 
<|del|> 
 * In case of external data, this method is used to build loading jobs for both * initial load on index creation and transaction load on dataset refresh 
 IScalarEvaluatorFactory selectCond; 
 String dvName = executor.getActiveDataverseName(dataverseName); 
 String dvName = executor.getActiveDataverseName(dataverse); String dsName = name.getValue(); 
 String strMetaItemTypeName = getMetaItemTypeName().getValue(); 
 String nodeGroupName = getNodeGroup(ngNameId, this, dvName); String compactionPolicyToUse = getCompactionPolicy(); Map<String, String> compactionPolicyPropertiesToUse = compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicyToUse == null; 
 String nodeGroupName = getNodeGroup(ngNameId, this, dvName); String compactionPolicyToUse = getCompactionPolicy(); Map<String, String> compactionPolicyPropertiesToUse = compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicyToUse == null; 
 String nodeGroupName = getNodeGroup(ngNameId, this, dvName); String compactionPolicyToUse = getCompactionPolicy(); Map<String, String> compactionPolicyPropertiesToUse = compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicyToUse == null; 
 String nodeGroupName = getNodeGroup(ngNameId, this, dvName); String compactionPolicyToUse = getCompactionPolicy(); Map<String, String> compactionPolicyPropertiesToUse = compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicyToUse == null; 
 Dataverse dv = MetadataManager.INSTANCE.getDataverse(metadataProvider.getMetadataTxnContext(), dvName); JobSpecification jobSpec = DatasetOperations.createDatasetJobSpec(dv, dsName, metadataProvider); 
 String activeDefaultDataverse = executor.getActiveDataverseName(dataverseName); 
 String dvName = executor.getActiveDataverseName(dataverseName); 
 String dvName = executor.getActiveDataverseName(getDataverseName()); String dsName = getDatasetName().getValue(); 
 MetadataLockManager.INSTANCE.refreshDatasetBegin(dvName, dvName + "." + dsName); 
 private DatasetOperations() { throw new AssertionError("This class should not be initialized."); } 
 private FeedOperations() { throw new AssertionError("This class should not be initialized."); } 
<|del|> 
 Triple<IOperatorDescriptor, AlgebricksPartitionConstraint, IAdapterFactory> t = metadataProvider .buildFeedIntakeRuntime(spec, primaryFeed, policyAccessor); 
 public static JobSpecification buildRemoveFeedStorageJob(Feed feed) throws AsterixException { 
 private FlushDatasetUtils() { throw new AssertionError("This util class should not be initialized."); } 
 String dataverseName, String datasetName, String indexName) throws Exception { 
 private ValidateUtil() { throw new AssertionError("This util class should not be initialized."); } 
 LOGGER.log(Level.WARNING, "Exception in executing shutdown hook", e); 
<|del|> 
 private JobSpecificationUtils() { 
<|del|>
 private JobUtils() { 
<|del|>
 public static List<ExternalFile> getSnapshotFromExternalFileSystem(Dataset dataset) throws AlgebricksException { List<ExternalFile> files = new ArrayList<>(); 
<|del|> 
 List<ExternalFile> externalFilesSnapshot, AqlMetadataProvider metadataProvider, boolean createIndex) throws AlgebricksException { 
 PersistentLocalResourceFactoryProvider localResourceFactoryProvider = new PersistentLocalResourceFactoryProvider(localResourceMetadata, LocalResource.ExternalBTreeResource); 
 List<ExternalFile> addedFiles, List<ExternalFile> appendedFiles, AqlMetadataProvider metadataProvider) throws AlgebricksException { List<ExternalFile> files = new ArrayList<>(); 
 AsterixStorageProperties storageProperties) { 
 AsterixStorageProperties storageProperties) { 
 AsterixStorageProperties storageProperties, AqlMetadataProvider metadataProvider) throws AlgebricksException { 
 IPrimitiveValueProviderFactory[] valueProviderFactories = new IPrimitiveValueProviderFactory[numNestedSecondaryKeyFields]; IBinaryComparatorFactory[] secondaryComparatorFactories = new IBinaryComparatorFactory[numNestedSecondaryKeyFields]; 
 IPrimitiveValueProviderFactory[] valueProviderFactories = new IPrimitiveValueProviderFactory[numNestedSecondaryKeyFields]; IBinaryComparatorFactory[] secondaryComparatorFactories = new IBinaryComparatorFactory[numNestedSecondaryKeyFields]; 
 * returns the active dataverse for an entity or a statement * 
<|del|>
 case BTREE: 
 case BTREE: 
<|del|> 
 case LENGTH_PARTITIONED_NGRAM_INVIX: indexOperationsHelper = new SecondaryInvertedIndexOperationsHelper(physOptConf, asterixPropertiesProvider); 
<|del|>
 throws AlgebricksException { 
 protected AlgebricksMetaOperatorDescriptor createAssignOp(JobSpecification spec, int numSecondaryKeyFields, RecordDescriptor secondaryRecDesc) { 
 Pair<IAType, Boolean> spatialTypePair = Index.getNonNullableOpenFieldType(secondaryKeyTypes.get(0), secondaryKeyFields.get(0), itemType); 
 * 3) Bulk-loading in RTree takes 4 doubles by reading 2 doubles twice and then, do the same work * as non-point MBR cases. 
 * 3) Bulk-loading in RTree takes 4 doubles by reading 2 doubles twice and then, do the same work * as non-point MBR cases. 
<|del|> 
 * In case of external data, this method is used to build loading jobs for both initial * load on index creation and transaction load on dataset refresh 
 case TYPEREFERENCE: 
 case RECORD: 
 case ORDEREDLIST: 
 case UNORDEREDLIST: 
<|del|> 
 for (Entry<TypeSignature, List<TypeSignature>> typeEntry : incompleteTopLevelTypeReferences.entrySet()) { TypeSignature typeSignature = typeEntry.getKey(); 
 typeRef = computeOrderedListType(null, oltd, typeMap, incompleteItemTypes, incompleteFieldTypes, 
 typeRef = computeUnorderedListType(null, ultd, typeMap, incompleteItemTypes, incompleteFieldTypes, 
 typeRef = computeRecordType(null, rtd, typeMap, incompleteFieldTypes, incompleteItemTypes, 
 case TYPEREFERENCE: 
<|del|> 
 case TYPEREFERENCE: 
 t2 = computeRecordType(null, recTypeDef2, typeMap, incompleteFieldTypes, incompleteItemTypes, 
 t2 = computeOrderedListType(null, oltd, typeMap, incompleteItemTypes, incompleteFieldTypes, 
 t2 = computeUnorderedListType(null, ultd, typeMap, incompleteItemTypes, incompleteFieldTypes, 
<|del|> 
 Properties prop = loadPolicyProperties(); 
 String nodeGroupName = getNodeGroup(ngNameId, this, dvName); String compactionPolicyToUse = getCompactionPolicy(); Map<String, String> compactionPolicyPropertiesToUse = compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicyToUse == null; 
 String nodeGroupName = getNodeGroup(ngNameId, this, dvName); String compactionPolicyToUse = getCompactionPolicy(); Map<String, String> compactionPolicyPropertiesToUse = compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicyToUse == null; 
 String nodeGroupName = getNodeGroup(ngNameId, this, dvName); String compactionPolicyToUse = getCompactionPolicy(); Map<String, String> compactionPolicyPropertiesToUse = compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicyToUse == null; 
 String nodeGroupName = getNodeGroup(ngNameId, this, dvName); String compactionPolicyToUse = getCompactionPolicy(); Map<String, String> compactionPolicyPropertiesToUse = compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicyToUse == null; 
 Dataverse dv = MetadataManager.INSTANCE.getDataverse(metadataProvider.getMetadataTxnContext(), dvName); JobSpecification jobSpec = DatasetOperations.createDatasetJobSpec(dv, dsName, metadataProvider); 
 protected String getNodeGroup(Identifier ngNameId, DatasetDecl dd, String dataverse) { 
 String nodeGroupName; 
 String strFeedName = feedName.getValue(); 
 String strPolicyName = getPolicyName().getValue(); MetadataLockManager.INSTANCE.dropFeedPolicyBegin(dvName, dvName + "." + strPolicyName); 
 String strTypeName = typeName.getValue(); 
 private static final Logger LOGGER = Logger.getLogger(DatasetOperations.class.getName()); 
<|del|> 
<|del|> 
 public static Pair<JobSpecification, Boolean> buildDisconnectFeedJobSpec(FeedConnectionId connectionId) throws AlgebricksException { 
 public static JobSpecification buildRemoveFeedStorageJob(Feed feed) throws AsterixException { 
 String dataverseName, String datasetName, String indexName) throws Exception { 
<|del|>
 throws AsterixException { 
 public static Map<String, IAType> createRecordNameTypeMap(ARecordType nestedFieldType) { Map<String, IAType> recordNameTypesMap = new LinkedHashMap<>(); 
 public SerializableHashTable(int tableSize, final IHyracksFrameMgrContext ctx) throws HyracksDataException { this(tableSize, ctx, 0.1); } public SerializableHashTable(int tableSize, final IHyracksFrameMgrContext ctx, double garbageCollectionThreshold) throws HyracksDataException { 
 public SerializableHashTable(int tableSize, final IHyracksFrameMgrContext ctx) throws HyracksDataException { this(tableSize, ctx, 0.1); } public SerializableHashTable(int tableSize, final IHyracksFrameMgrContext ctx, double garbageCollectionThreshold) throws HyracksDataException { 
 private final Mutable<ILogicalExpression> branchingExpression; 
 builder.addTargetEdge(i, sma, i); 
<|del|> 
<|del|> 
<|del|> 
 private volatile boolean aborted; 
public class ThreadDumpHelper { private ThreadDumpHelper() { } 
 + " times (~" + (after.getBlockedTime() - before.getBlockedTime()) + "ms)" 
 if (componentFilterPageId == LinkedMetaDataPageManager.NO_FILTER_IN_PLACE) { //in-place mode, no filter page yet 
 } else { // in place, not a new filter page 
 PersistentLocalResourceFactoryProvider localResourceFactoryProvider = 
 private static Pair<ExternalDataScanOperatorDescriptor, AlgebricksPartitionConstraint> getExternalDataIndexingOperator(AqlMetadataProvider metadataProvider, JobSpecification jobSpec, IAType itemType, Dataset dataset, List<ExternalFile> files, RecordDescriptor indexerDesc) throws HyracksDataException, AlgebricksException { 
 IBinaryComparatorFactory[] secondaryComparatorFactories = 
 IBinaryComparatorFactory[] secondaryComparatorFactories = 
 ExternalBTreeWithBuddyDataflowHelperFactory dataflowHelperFactory = new ExternalBTreeWithBuddyDataflowHelperFactory( 
 for (Entry<String, Map<ARecordType, List<Integer>>> fieldTypeEntry : incompleteFieldTypes.entrySet()) { String trefName = fieldTypeEntry.getKey(); 
 Map<ARecordType, List<Integer>> fieldsToFix = fieldTypeEntry.getValue(); for (Entry<ARecordType, List<Integer>> recTypeEntry : fieldsToFix.entrySet()) { ARecordType recType = recTypeEntry.getKey(); List<Integer> positions = recTypeEntry.getValue(); 
 for (Entry<TypeSignature, List<AbstractCollectionType>> typeSignatureEntry : incompleteItemTypes.entrySet()) { TypeSignature typeSignature = typeSignatureEntry.getKey(); 
public class HyracksThreadFactory implements ThreadFactory { 
 IOptimizationContext context, AqlMetadataProvider metadataProvider) 
 protected static final int typeIndicatorSize = 1; 
 private void setFullTextOption(IPointable[] argOptions, int uniqueQueryTokenCount) throws HyracksDataException { 
 if (compareStrInByteArrayAndPointable(FullTextContainsDescriptor.getDisjunctiveFTSearchOptionArray(), 
 } else if (compareStrInByteArrayAndPointable( FullTextContainsDescriptor.getConjunctiveFTSearchOptionArray(), argOptions[i + 1], true) == 0) { 
 public static final String SEARCH_MODE_OPTION = "mode"; public static final String DISJUNCTIVE_SEARCH_MODE_OPTION = "any"; public static final String CONJUNCTIVE_SEARCH_MODE_OPTION = "all"; 
 public static final String SEARCH_MODE_OPTION = "mode"; public static final String DISJUNCTIVE_SEARCH_MODE_OPTION = "any"; public static final String CONJUNCTIVE_SEARCH_MODE_OPTION = "all"; 
 public static final String SEARCH_MODE_OPTION = "mode"; public static final String DISJUNCTIVE_SEARCH_MODE_OPTION = "any"; public static final String CONJUNCTIVE_SEARCH_MODE_OPTION = "all"; 
 paramTypeMap.put(SEARCH_MODE_OPTION, ATypeTag.STRING); 
 IRecordDescriptorProvider recordDescProvider, final int partition, int nPartitions) throws HyracksDataException { 
<|del|> 
 private static Pair<ExternalDataScanOperatorDescriptor, AlgebricksPartitionConstraint> 
 IOptimizationContext context) 
 exceptions.add(new InterruptedException("Task " + getTaskAttemptId() + " was aborted!")); 
<|del|> 
 protected final IAsterixStateProxy proxy; protected IMetadataNode metadataNode; 
 protected final IAsterixStateProxy proxy; protected IMetadataNode metadataNode; 
 protected final IAsterixStateProxy proxy; protected IMetadataNode metadataNode; 
 AbstractFunctionCallExpression fce) { 
 List<IAType> matchedTypes = new ArrayList<>(); 
 //add primary keys 
 false, subTree.getDataSourceRef().getValue().getInputs().get(0).getValue() .getExecutionMode() == ExecutionMode.UNPARTITIONED, 
 * * @param afterSelectRefs 
 // Recursively check the given plan whether the desired pattern exists in it. // If so, try to optimize the plan. 
 // We found an optimization here. Don't need to optimize this operator again. 
 // We found an optimization here. Don't need to optimize this operator again. 
 Map<IAccessMethod, AccessMethodAnalysisContext> analyzedAMs = new TreeMap<>(); 
 if (chosenIndexes == null || chosenIndexes.isEmpty()) { 
 false, subTree.getDataSourceRef().getValue().getInputs().get(0).getValue() .getExecutionMode() == ExecutionMode.UNPARTITIONED, 
 AccessMethodUtils.retainInputs(subTree.getDataSourceVariables(), subTree.getDataSourceRef().getValue(), afterSelectRefs), false, subTree.getDataSourceRef().getValue().getInputs().get(0).getValue() .getExecutionMode() == ExecutionMode.UNPARTITIONED, context); 
 public static boolean setOperatorMode(AbstractLogicalOperator op) { 
<|del|> 
 org.apache.hyracks.algebricks.common.utils.Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = StoragePathUtil 
<|del|> 
<|del|> 
<|del|> 
 private static JobSpecification combineIntakeCollectJobs(AqlMetadataProvider metadataProvider, Feed feed, JobSpecification intakeJob, List<JobSpecification> jobsList, List<FeedConnection> feedConnections, String[] intakeLocations) throws AlgebricksException, HyracksDataException { 
 PartitionConstraintHelper.addAbsoluteLocationConstraint(jobSpec, ingestionOp, intakeLocations); PartitionConstraintHelper.addAbsoluteLocationConstraint(jobSpec, replicateOp, intakeLocations); 
<|del|> 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : subJob 
 public static JobSpecification buildStopFeedJob(EntityId feedId, List<String> intakeNodeLocations) 
<|del|> 
<|del|> 
 if (open) { writer.flush(); 
 if (appliedFunction != null) { 
 if (appliedFunction != null) { 
 public List<FunctionSignature> getAppliedFunctions() { 
 public byte getCategory() { 
 public StopFeedStatement(Pair<Identifier, Identifier> feedNameComp) { 
 if (connectFeedStmt.getAppliedFunctions() != null) { 
 if (connectFeedStmt.getAppliedFunctions() != null) { 
 if (connectFeedStmt.getAppliedFunctions() != null) { 
 try { 
 try { 
 } catch (IndexException | ACIDException | IOException e) { 
 } catch (IndexException | ACIDException | IOException e) { 
 try { 
 try { 
 if (!results.isEmpty()) 
 if (!results.isEmpty()) 
 } catch (IndexException | IOException e) { 
 ITupleReference tuple = getTupleToBeDeleted(jobId, MetadataPrimaryIndexes.FEED_CONNECTION_DATASET, searchKey); 
 ITupleReference tuple = getTupleToBeDeleted(jobId, MetadataPrimaryIndexes.FEED_CONNECTION_DATASET, searchKey); 
 } catch (IndexException | IOException | ACIDException e) { 
 } catch (IndexException | IOException | ACIDException e) { 
 } catch (IndexException | IOException | ACIDException e) { 
 } catch (IndexException | IOException | ACIDException e) { 
 public void addFeedConnection(FeedConnection feedConnection) { 
 logAndApply(new MetadataLogicalOperation(feedConnection, false)); 
 Arrays.asList(MetadataRecordTypes.FIELD_NAME_DATASET_NAME)), 
 List<FunctionSignature> appliedFunctions, String policyName, String outputType) { 
 List<FunctionSignature> appliedFunctions, String policyName, String outputType) { 
 IACursor cursor; 
 * 
 Object annotation = op2.getAnnotations().get(IS_MOVABLE); 
 false, subTree.getDataSourceRef().getValue().getInputs().get(0).getValue() .getExecutionMode() == ExecutionMode.UNPARTITIONED, 
 @Override public boolean stop() { try { reader.stop(); } catch (Exception e) { e.printStackTrace(); return false; 
 @Override public boolean stop() { try { reader.stop(); } catch (Exception e) { e.printStackTrace(); return false; 
 @Override public boolean stop() { try { reader.stop(); } catch (Exception e) { e.printStackTrace(); return false; 
 @Override public boolean stop() { try { reader.stop(); } catch (Exception e) { e.printStackTrace(); return false; 
 @Override public boolean stop() { try { reader.stop(); } catch (Exception e) { e.printStackTrace(); return false; 
 return true; 
 return true; 
 public XMLFileParser(ARecordType recordType, ADMDataParser admDataParser) { 
 throw new IOException(e); 
<|del|> 
 // do nothing 
 op.substituteVar(arg.first, arg.second); 
<|del|> 
 SplitOperator sOpArg = (SplitOperator) copyAndSubstituteVar(op, arg); boolean isomorphic = op.getBranchingExpression().getValue().equals(sOpArg.getBranchingExpression().getValue()); return isomorphic; 
<|del|> 
<|del|> 
 WatchKey key; 
 if ((expression == null || Pattern.matches(expression, path.toString()) && fileNotExistsInList(files, path))) { 
 if ((expression == null || Pattern.matches(expression, path.toString()) && fileNotExistsInList(files, path))) { 
 if ((expression == null || Pattern.matches(expression, path.toString()) && fileNotExistsInList(files, path))) { 
 return newRecordFormed; } 
<|del|> 
 protected static final int TYPE_INDICATOR_SIZE = 1; 
 if (isSink) { return; 
 ArrayQueue<AbstractLogicalOperator> opStack = new ArrayQueue<>(); opStack.add(currentOp); 
 ArrayQueue<AbstractLogicalOperator> opStack = new ArrayQueue<>(); opStack.add(currentOp); 
 //TODO: bug here. will not work for internal datasets with filters since the pattern becomes //[project-assign-assign-insert] 
 handleDropFeedPolicyStatement(metadataProvider, stmt); 
 if ((expression == null || Pattern.matches(expression, path.toString())) && fileNotExistsInList(files, path)) { 
public class PrintUtil { private PrintUtil() { } 
 public static final String KEY_TPS = "tps"; 
<|del|> 
 ArrayDeque<AbstractLogicalOperator> opStack = new ArrayDeque<>(); opStack.push(currentOp); 
 List<IAType> matchedTypes = new ArrayList<>(); 
 if ((chosenAccessMethod == BTreeAccessMethod.INSTANCE && indexType == IndexType.BTREE) || (chosenAccessMethod == RTreeAccessMethod.INSTANCE && indexType == IndexType.RTREE) 
<|del|> 
 if (!functionDecls.isEmpty()) { 
 if (!functionDecls.isEmpty()) { 
 private boolean fullTextContainsWithArg(ATypeTag typeTag2, IPointable arg1, IPointable arg2, IPointable[] argOptions) throws HyracksDataException { 
 Set<IClusterEventsSubscriber> subscribers = ClusterManagerProvider.getClusterManager().getRegisteredClusterEventSubscribers(); 
 Set<IClusterEventsSubscriber> subscribers = ClusterManagerProvider.getClusterManager().getRegisteredClusterEventSubscribers(); 
 ClusterManager(String eventHome) { 
 private ClusterManagerProvider() { } 
 builder.append(" -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=").append(debugPort); 
<|del|> 
<|del|> 
<|del|> 
 protected void appendJavaOpts(Node node, StringBuilder envBuffer, Property p) { 
 public List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> getLogicalRewrites() 
 public List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> getLogicalRewrites() 
 public List<Pair<AbstractRuleController, List<IAlgebraicRewriteRule>>> getPhysicalRewrites(); 
 throw new AlgebricksException("The first expression should be a string."); 
 throw new AlgebricksException( "The second expression should be a string, unordered list, or ordered list."); 
 "Options must be in the form of constant strings. Check that the option at " + (i % 2 + 1) + " is indeed a constant string"); 
 throw new AlgebricksException( "The given option " + option + " is not a valid argument to ftcontains()"); 
 "The given value for option " + option + " was not of the expected type"); 
 void checkSearchModeOption(String optionVal) throws AlgebricksException { 
 private boolean fullTextContainsWithArg(ATypeTag typeTag2, IPointable arg1, IPointable arg2, IPointable[] argOptions) throws HyracksDataException { 
 rightHashSet = new BinaryHashSet(HASH_SET_SLOT_SIZE, HASH_SET_FRAME_SIZE, hashFunc, strLowerCaseTokenCmp, null); 
 if ((typeTag1 != ATypeTag.STRING) || (typeTag2 != ATypeTag.ORDEREDLIST && typeTag2 != ATypeTag.UNORDEREDLIST && !ATypeHierarchy.isCompatible(typeTag1, typeTag2))) { 
 return true; 
<|del|> 
 if ((chosenAccessMethod == BTreeAccessMethod.INSTANCE && indexType == IndexType.BTREE) || (chosenAccessMethod == RTreeAccessMethod.INSTANCE && indexType == IndexType.RTREE) 
 if (j != exprAndVarIdx.second) { 
 expr = (AbstractLogicalExpression) assignOp.getExpressions().get(assignVarIndex).getValue(); if (expr.getExpressionTag() != LogicalExpressionTag.FUNCTION_CALL) { //Otherwise the cast for childFuncExpr would fail return null; } 
 throws AlgebricksException { 
 private static final List<FunctionIdentifier> FUNC_IDENTIFIERS = Collections.unmodifiableList(Arrays.asList( AlgebricksBuiltinFunctions.EQ, AlgebricksBuiltinFunctions.LE, AlgebricksBuiltinFunctions.GE, AlgebricksBuiltinFunctions.LT, AlgebricksBuiltinFunctions.GT)); 
 boolean matches = AccessMethodUtils.analyzeFuncExprArgsForOneConstAndVar( funcExpr, analysisCtx, context, typeEnvironment); 
 Mutable<ILogicalOperator> opRef = subTree.getAssignsAndUnnestsRefs().isEmpty() ? null : subTree.getAssignsAndUnnestsRefs().get(0); 
 AbstractDataSourceOperator dataSourceOp = (AbstractDataSourceOperator) indexSubTree.getDataSourceRef().getValue(); 
 Pair<ILogicalExpression, Boolean> returnedSearchKeyExpr = AccessMethodUtils.createSearchKeyExpr(optFuncExpr, indexSubTree, probeSubTree); 
 UnnestingFunctionCallExpression primaryIndexSearchFunc = new UnnestingFunctionCallExpression(primaryIndexSearch, primaryIndexFuncArgs); 
 ComparisonKind ck = AlgebricksBuiltinFunctions.getComparisonType(optFuncExpr.getFuncExpr().getFunctionIdentifier()); 
<|del|> 
 || subTreeOp.getOperatorTag() == LogicalOperatorTag.UNNEST) { 
 IAType metaItemType = metadataProvider.findType(ds.getMetaItemTypeDataverseName(), ds.getMetaItemTypeName()); 
 if (op.getOperatorTag() == LogicalOperatorTag.ASSIGN) { 
 StructuralPropertiesVector pvector = new StructuralPropertiesVector(new RandomPartitioningProperty(context.getComputationNodeDomain()), new LinkedList<ILocalStructuralProperty>()); 
<|del|> 
 IPhysicalPropertiesVector rqd = new StructuralPropertiesVector(pbpp.second, requiredProperty.getLocalProperties()); 
 IPhysicalPropertiesVector newDiff = newPropertiesDiff(newChild, rqd, mayExpandPartitioningProperties, context); 
 IPhysicalPropertiesVector deliveredByNewChild = ((AbstractLogicalOperator) op.getInputs().get(0).getValue()).getDeliveredPhysicalProperties(); 
 List<OrderColumn> orderColumns = getOrderColumnsFromGroupingProperties(reqdLocals, cldLocals); 
 } 
 public static final PointableBinaryComparatorFactory UTF8STRING_LOWERCASE_TOKEN_POINTABLE_INSTANCE = new PointableBinaryComparatorFactory(UTF8StringLowercaseTokenPointable.FACTORY); 
 private static final IBinaryTokenizerFactory aqlStringNoTypeTagTokenizer = new DelimitedUTF8StringBinaryTokenizerFactory(true, false, new UTF8WordTokenFactory(ATypeTag.STRING.serialize(), ATypeTag.INT32.serialize())); 
 protected static final int TYPE_INDICATOR_SIZE = 1; 
 private final IBinaryComparator strLowerCaseTokenCmp = AqlBinaryComparatorFactoryProvider.UTF8STRING_LOWERCASE_TOKEN_POINTABLE_INSTANCE.createBinaryComparator(); private final IBinaryComparator strLowerCaseCmp = AqlBinaryComparatorFactoryProvider.UTF8STRING_LOWERCASE_POINTABLE_INSTANCE.createBinaryComparator(); 
 private final IBinaryComparator strLowerCaseTokenCmp = AqlBinaryComparatorFactoryProvider.UTF8STRING_LOWERCASE_TOKEN_POINTABLE_INSTANCE.createBinaryComparator(); private final IBinaryComparator strLowerCaseCmp = AqlBinaryComparatorFactoryProvider.UTF8STRING_LOWERCASE_POINTABLE_INSTANCE.createBinaryComparator(); 
 private boolean fullTextContainsWithArg(ATypeTag typeTag2, IPointable arg1, IPointable arg2) throws HyracksDataException { 
 private static final Map<String, ATypeTag> paramTypeMap = new LinkedHashMap<>(); 
 private static final byte[] SEARCH_MODE_OPTION_ARRAY = UTF8StringUtil.writeStringToBytes(SEARCH_MODE_OPTION); private static final byte[] DISJUNCTIVE_SEARCH_MODE_OPTION_ARRAY = UTF8StringUtil 
 private static final byte[] SEARCH_MODE_OPTION_ARRAY = UTF8StringUtil.writeStringToBytes(SEARCH_MODE_OPTION); private static final byte[] DISJUNCTIVE_SEARCH_MODE_OPTION_ARRAY = UTF8StringUtil 
 private static final byte[] CONJUNCTIVE_SEARCH_MODE_OPTION_ARRAY = UTF8StringUtil 
 private static final byte[] CONJUNCTIVE_SEARCH_MODE_OPTION_ARRAY = UTF8StringUtil 
 private static final byte[] CONJUNCTIVE_SEARCH_MODE_OPTION_ARRAY = UTF8StringUtil 
 private static final byte[] CONJUNCTIVE_SEARCH_MODE_OPTION_ARRAY = UTF8StringUtil 
 // To handle multiple fuzzyjoin conditions on the same table pair, this rule differentiates the PKs 
 Collection<LogicalVariable> currentPK = new HashSet<>(); 
 return false; 
 default: 
 translator.addOperatorToMetaScope(new VarIdentifier("##LEFT_1"), leftInputOpCopy); 
<|del|> 
 expectedTypes.append(", "); } 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval = args[0].createScalarEvaluator(context); 
 eval = args[0].createScalarEvaluator(context); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval = args[0].createScalarEvaluator(context); 
 eval = args[0].createScalarEvaluator(context); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval = args[0].createScalarEvaluator(context); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval = args[0].createScalarEvaluator(context); 
 eval = args[0].createScalarEvaluator(context); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval = args[0].createScalarEvaluator(context); 
 eval = args[0].createScalarEvaluator(context); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 eval = args[0].createScalarEvaluator(context); 
 eval = args[0].createScalarEvaluator(context); 
 eval.evaluate(tuple, inputVal); 
 eval.evaluate(tuple, inputVal); 
 protected boolean prepareLists(IPointable left, IPointable right) throws HyracksDataException { 
 return Math.abs(leftVal - rightVal) < 1E-10; 
 throw new HyracksDataException(e); 
 throw new HyracksDataException(e); 
 throw new HyracksDataException(e1); 
 throw new HyracksDataException(e); 
 } catch (IOException e) { throw new InvalidDataFormatException(getIdentifier(), e, ATypeTag.SERIALIZED_DURATION_TYPE_TAG); 
 private IBinaryComparator utf8BinaryComparator = AqlBinaryComparatorFactoryProvider. UTF8STRING_POINTABLE_INSTANCE.createBinaryComparator(); 
<|del|> 
 throw new InvalidDataFormatException(getIdentifier(), e, ATypeTag.SERIALIZED_INTERVAL_TYPE_TAG); 
 throw new InvalidDataFormatException(getIdentifier(), ATypeTag.SERIALIZED_INTERVAL_TYPE_TAG); 
 throw new InvalidDataFormatException(getIdentifier(), ATypeTag.SERIALIZED_INTERVAL_TYPE_TAG); 
<|del|> 
 int currentType; 
 int currentType; 
 case INT8: 
 case INT16: 
 case INT32: 
 case INT64: 
 case FLOAT: 
 throw new TypeMismatchException(getIdentifier(), i, bytes[offset], 
 long lres; double dres; 
 long lres; double dres; 
 ABoolean aResult = res ? ABoolean.TRUE : ABoolean.FALSE; 
 throw new TypeMismatchException(getIdentifier().getName(), 0, serOrderedList[offset]); 
 private final ISerializerDeserializer<AMissing> missingSerde = AqlSerializerDeserializerProvider. INSTANCE.getSerializerDeserializer(BuiltinType.AMISSING); 
<|del|> 
 throw new TypeMismatchException(getIdentifier(), 0, 
 case INT8: 
 case INT16: 
 case INT32: 
 case INT64: 
 case FLOAT: 
 case DOUBLE: 
 throw new TypeMismatchException(getIdentifier(), i, data[offset], 
 throw new TypeMismatchException(getIdentifier(), i, data[offset], 
 throw new TypeMismatchException(getIdentifier(), i, data[offset], 
 throw new TypeMismatchException(getIdentifier(), 0, tag0, 
 throw new TypeMismatchException(getIdentifier(), 2, tag2, 
 throw new TypeMismatchException(getIdentifier(), 3, tag3, 
 ABoolean aResult = res ? ABoolean.TRUE : ABoolean.FALSE; 
 throw new UnsupportedTypeException( AsterixBuiltinFunctions.FIELD_ACCESS_NESTED.getName(), 
 // swap the starting and ending time, so that ending time is always larger than the // starting time. 
 // need to "borrow" the days in previous month to make the day positive; when month is // 1 (Jan), Dec will be borrowed day += isLeapYear 
 // need to "borrow" the days in previous month to make the day positive; when month is // 1 (Jan), Dec will be borrowed day += isLeapYear 
 // swap the starting and ending time, so that ending time is always larger than the // starting time. 
 // need to "borrow" the days in previous month to make the day positive; when month is // 1 (Jan), Dec will be borrowed 
 int formatLength; 
 int formatLength; 
 int formatLength; 
 finish(result); 
 finish(result); 
 agg[i] = aggFactories[i].createAggregateEvaluator(ctx); 
 agg[i] = aggFactories[i].createAggregateEvaluator(ctx); 
 } catch (Exception e) { 
 } catch (Exception e) { 
 eval.evaluate(tuple, inputVal); 
 eval = args[0].createScalarEvaluator(context); 
 eval = args[0].createScalarEvaluator(context); 
<|del|> 
<|del|> 
<|del|> 
 private static JobSpecification combineIntakeCollectJobs(MetadataProvider metadataProvider, Feed feed, 
 eventSubscriber.assertEvent(FeedLifecycleEvent.FEED_INTAKE_STARTED); 
 private static JobSpecification combineIntakeCollectJobs(MetadataProvider metadataProvider, Feed feed, 
 if (firstOp.getAdaptorFactory() == null) { 
 private static final int INTAKE_CARDINALITY = 1; // degree of parallelism at intake stage 
 private static final int INTAKE_CARDINALITY = 1; // degree of parallelism at intake stage 
 return results.get(0); } 
 logAndApply(new MetadataLogicalOperation(feedConnection, false)); 
 private IBinaryComparator utf8BinaryComparator = AqlBinaryComparatorFactoryProvider. UTF8STRING_POINTABLE_INSTANCE.createBinaryComparator(); 
 throw new InvalidDataFormatException(getIdentifier(), e, 
 ABoolean aResult = argRes ? ABoolean.FALSE : ABoolean.TRUE; 
 ABoolean aResult = res ? ABoolean.TRUE : ABoolean.FALSE; 
 MetadataProvider metadataProvider, IDataSource<DataSourceId> dataSource, 
 throw new InvalidDataFormatException(getIdentifier(), e, 
 int currentType; 
 throw new OverflowException(getIdentifier()); 
 throw new UnderflowException(getIdentifier()); 
 throw new IncompatibleTypeException(getIdentifier(), bytes0[offset0], bytes1[offset1]); 
 int size; 
 private final ISerializerDeserializer<AMissing> missingSerde = AqlSerializerDeserializerProvider. INSTANCE.getSerializerDeserializer(BuiltinType.AMISSING); 
 if (data[offset] != ATypeTag.SERIALIZED_BOOLEAN_TYPE_TAG) { 
 if (data[offset] != ATypeTag.SERIALIZED_BOOLEAN_TYPE_TAG) { 
 if (tag0 != ATypeTag.SERIALIZED_POINT_TYPE_TAG) { 
 if (tag1 != ATypeTag.SERIALIZED_POINT_TYPE_TAG) { 
 if (tag2 != ATypeTag.SERIALIZED_DOUBLE_TYPE_TAG) { 
 if (tag3 != ATypeTag.SERIALIZED_DOUBLE_TYPE_TAG) { 
 throw new TypeMismatchException(AsterixBuiltinFunctions.FIELD_ACCESS_NESTED, 0, serRecord[start], ATypeTag.SERIALIZED_RECORD_TYPE_TAG); 
 AsterixBuiltinFunctions.FIELD_ACCESS_NESTED.getName(), serRecord[start]); 
 arg.second = Math.abs(ATypeHierarchy.getDoubleValue("deep-equal", 0, b1, s1) - ATypeHierarchy.getDoubleValue("deep-equal", 1, b2, s2)) < 1E-10; 
 arg.second = Math.abs(ATypeHierarchy.getDoubleValue("deep-equal", 0, b1, s1) - ATypeHierarchy.getDoubleValue("deep-equal", 1, b2, s2)) < 1E-10; 
 private volatile transient String msgCache; 
 private volatile transient String msgCache; 
 if (serRecord[start] != ATypeTag.SERIALIZED_RECORD_TYPE_TAG) { throw new AlgebricksException("Field accessor is not defined for values of type " + EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(serRecord[start])); 
 day += isLeapYear 
 long lres; double dres; 
 long lres; double dres; 
<|del|> 
 DataSourceId id = getId(); String dataverseName = id.getDataverseName(); String datasetName = id.getDatasourceName(); Index primaryIndex = MetadataManager.INSTANCE.getIndex(metadataProvider.getMetadataTxnContext(), 
 return lookupSourceInMetadata(mdTxnCtx, id); 
 new IPCResponder<Object>(handle, mid))); 
 new IPCResponder<Object>(handle, mid))); 
 } if (serRecord[start] != ATypeTag.SERIALIZED_RECORD_TYPE_TAG) { throw new AlgebricksException("Field accessor is not defined for values of type " + EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(serRecord[start])); } 
 LOGGER.log(Level.WARNING, "Exception in executing shutdown hook", e); 
 map.putAll((AsterixAppContextInfo.INSTANCE.getCCApplicationContext() 
 case REGISTER_NODE: 
 case REGISTER_NODE: 
 break; case NODE_HEARTBEAT: 
 break; case NOTIFY_JOBLET_CLEANUP: 
 break; case REPORT_PROFILE: 
 break; case NOTIFY_TASK_COMPLETE: 
 break; case NOTIFY_TASK_FAILURE: 
 break; case REGISTER_PARTITION_PROVIDER: 
 break; case REGISTER_PARTITION_REQUEST: 
 break; case REGISTER_RESULT_PARTITION_LOCATION: 
 break; case REGISTER_RESULT_PARTITION_LOCATION: 
 rrpwc.getJobId(), rrpwc.getResultSetId(), rrpwc.getPartition())); break; case REPORT_RESULT_PARTITION_FAILURE: CCNCFunctions.ReportResultPartitionFailureFunction rrpf = 
 rrpf.getJobId(), rrpf.getResultSetId(), rrpf.getPartition())); break; case SEND_APPLICATION_MESSAGE: 
 break; case GET_NODE_CONTROLLERS_INFO: 
 break; case GET_NODE_CONTROLLERS_INFO: 
 break; case STATE_DUMP_RESPONSE: 
 break; case SHUTDOWN_RESPONSE: 
 break; case THREAD_DUMP_RESPONSE: 
 break; default: LOGGER.warning("Unknown function: " + fn.getFunctionId()); 
 case GET_CLUSTER_CONTROLLER_INFO: 
 case GET_CLUSTER_CONTROLLER_INFO: 
<|del|> 
 case GET_JOB_STATUS: 
 ccs.getWorkQueue().schedule(new GetJobInfoWork(ccs, gjif.getJobId(), 
 break; case START_JOB: 
 break; case GET_DATASET_RESULT_STATUS: HyracksClientInterfaceFunctions.GetDatasetResultStatusFunction gdrsf = 
 ccs.getWorkQueue().schedule(new GetResultStatusWork(ccs, gdrsf.getJobId(), gdrsf.getResultSetId(), new IPCResponder<Status>(handle, mid))); 
 case GET_DATASET_RESULT_LOCATIONS: 
 break; case GET_NODE_CONTROLLERS_INFO: 
 break; case GET_CLUSTER_TOPOLOGY: 
 break; case CLI_DEPLOY_BINARY: 
 break; case CLI_DEPLOY_BINARY: 
 break; case CLI_UNDEPLOY_BINARY: 
 break; case CLUSTER_SHUTDOWN: 
 break; case CLUSTER_SHUTDOWN: 
<|del|> 
<|del|> 
 return; } 
 return; } 
 byte typeTag = listBytes[start]; if (typeTag != ATypeTag.SERIALIZED_UNORDEREDLIST_TYPE_TAG && typeTag != ATypeTag.SERIALIZED_ORDEREDLIST_TYPE_TAG) { 
 return Math.abs(leftVal - rightVal) < EPSILON; 
 if (value < 0 && value != Long.MIN_VALUE) { 
 case INT8: 
 case DOUBLE: 
 default: 
 case INT64: 
 case FLOAT: 
 case DOUBLE: 
 default: 
 switch (i % 10) { case 1: return i + "st"; case 2: return i + "nd"; case 3: return i + "rd"; default: return i + "th"; } 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // This won't get called for an in-place index. The root page // is maintained at a fixed location as in the below method. 
 buf.putInt(ROOT_PAGE_NUMBER, 0); 
 return (metadataPageNum * bufferCache.getPageSize()) + LIFOMetaDataFrame.lsnOff; 
 public int getPageSizeWithHeader() { 
 public int getPageSizeWithHeader() { 
 if(addActiveReplica(replica, partition, partitionRecoveryPlan)) { break; } 
 } return true; 
 } return true; 
 private boolean writeFieldWithFieldType(Object fieldObj, IAType fieldType, DataOutput out) throws HyracksDataException { 
 parseJSONArray((JSONArray) fieldObj, out, (AOrderedListType) chkFieldType); 
 testExecutor.executeTest(PATH_ACTUAL, tcCtx, pb, false); } 
 if (addActiveReplica(replica, partition, partitionRecoveryPlan)) { 
 int maxNumberOfTuplesInDataTable = memoryBudgetInBytes / tupleByteSize; 
 int maxNumberOfTuplesInDataTable = memoryBudgetInBytes / tupleByteSize; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // System.out.println("===== buildSpillableTable error: " + tableSize + " " // + expectedFrameCountOfHashTableForGroupBy // + " " + framesLimit); 
 final IPartitionedTupleBufferManager bufferManager = new VPartitionTupleBufferManager( 
 // Check whether the garbage collection is required and conduct a garbage collection if so. if (hashTableForTuplePointer.isGarbageCollectionNeeded()) { 
 // Check whether the garbage collection is required and conduct a garbage collection if so. if (hashTableForTuplePointer.isGarbageCollectionNeeded()) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 int inputsize0, double factor, int[] keys0, int[] keys1, IBinaryHashFunctionFamily[] hashFunctionGeneratorFactories, IBinaryComparatorFactory[] comparatorFactories, RecordDescriptor recordDescriptor, ITuplePairComparatorFactory tupPaircomparatorFactory01, 
 int inputsize0, double factor, int[] keys0, int[] keys1, IBinaryHashFunctionFamily[] hashFunctionGeneratorFactories, IBinaryComparatorFactory[] comparatorFactories, RecordDescriptor recordDescriptor, ITuplePairComparatorFactory tupPaircomparatorFactory01, 
<|del|> 
 public Map<String, String> getConfig() { 
 public VPartitionTupleBufferManager(IPartitionedMemoryConstrain constrain, int partitions, IDeallocatableFramePool framePool) throws HyracksDataException { 
 if (tupleCount == 0) { // There is no inserted tuple in the given frame. Something is wrong. return false; 
 assert bufferInfo.getStartOffset() == 0 : "Haven't supported yet in FrameTupleAppender"; 
 assert bufferInfo.getStartOffset() == 0 : "Haven't supported yet in FrameTupleAppender"; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (!compactTableAndInsertAgain(entry, storedTuplePointer)) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 forceRoleReversal = !isLeftOuter && b; 
 forceRoleReversal = !isLeftOuter && b; 
<|del|> 
<|del|> 
 return numberOfHeaderFrame + numberOfContentFrame; 
<|del|> 
 return (int) Math.ceil(fieldCount / 8.0); 
 targetBuf[runner++] = (byte) 0; 
 return new QueryTranslator(aqlStatements, conf, compilationProvider, ((CompilerExtensionManager) AsterixAppContextInfo.INSTANCE .getExtensionManager()).getDataFormatProvider()); 
 AqlMetadataProvider metadataProvider = new AqlMetadataProvider(dataverse); 
<|del|> 
<|del|> 
 if (opDesc instanceof LSMTreeInsertDeleteOperatorDescriptor && ((LSMTreeInsertDeleteOperatorDescriptor) opDesc).isPrimary()) { String operandId = ((LSMTreeInsertDeleteOperatorDescriptor) opDesc).getIndexName(); 
<|del|> 
 public HybridHashJoinOperatorDescriptor(IOperatorDescriptorRegistry spec, int memsize, int inputsize0, 
 hashTableByteSizeForInMemTuples = SerializableHashTable.getExpectedTableSizeInByte(inMemTupCount, frameSize); 
<|del|> 
 boolean selectFoundAndOptimizationApplied; 
 if (subTree.getSelectRefs().isEmpty()) { 
 subTree.getAssignsAndUnnests(), analyzedAMs, context, typeEnvironment)) { 
 subTree.getAssignsAndUnnests(), analyzedAMs, context, typeEnvironment)) { 
 if (subTree.setDatasetAndTypeMetadata(metadataProvider)) { 
<|del|> 
 AbstractLogicalOperator subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); 
 if (subTree.setDatasetAndTypeMetadata(metadataProvider)) { 
 boolean joinFoundAndOptimizationApplied; 
 boolean joinFoundAndOptimizationApplied; 
 OptimizableOperatorSubTree indexSubTree; 
 try (FileOutputStream fos = new FileOutputStream(resourceFile.getFile()); 
 FileReference storageMetadataFile = getStorageMetadataFile(ioManager, nodeId, ioDeviceId); if (storageMetadataFile.getFile().exists()) { LocalResource rootLocalResource = readLocalResource(storageMetadataFile.getFile()); String storageRootDirPath = (String) rootLocalResource.getResource(); 
 ExternalBTreeWithBuddyLocalResourceMetadataFactory localResourceMetadata = new ExternalBTreeWithBuddyLocalResourceMetadataFactory( 
 try (FileOutputStream fos = new FileOutputStream(resourceFile.getFile()); 
 FileReference storageMetadataFile = getStorageMetadataFile(ioManager, nodeId, ioDeviceId); if (storageMetadataFile.getFile().exists()) { LocalResource rootLocalResource = readLocalResource(storageMetadataFile.getFile()); String storageRootDirPath = (String) rootLocalResource.getResource(); 
 throws HyracksDataException { 
 ExternalBTreeWithBuddyLocalResourceMetadataFactory localResourceMetadata = new ExternalBTreeWithBuddyLocalResourceMetadataFactory( 
 private final transient IOManager ioManager; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 String relativePath = getFileName(resource.getPath(), resource.getId()); 
<|del|> 
<|del|> 
<|del|> 
 private static FileReference getStorageMetadataFile(IOManager ioManager, String nodeId, 
<|del|> 
<|del|> 
 maxDiskLastLsn = ((AbstractLSMIOOperationCallback) lsmIndex .getIOOperationCallback()) 
 private int workspaceIndex; private IFileDeviceComputer deviceComputer; 
<|del|> 
<|del|> 
<|del|> 
 ILSMIOOperationCallbackFactory ioOpCallbackFactory, int version, boolean durable) 
<|del|> 
 int collectGarbage(ITuplePointerAccessor bufferAccessor, ITuplePartitionComputer tpc) 
 assertTrue(nsTable.getTupleCount(i) == tupleCntPerPart || nsTable.getTupleCount(i) == tupleCntPerPart - 1); 
 for (Mutable<ILogicalOperator> inputOpRef : op.getInputs()) { boolean foundHere = checkAndApplyTheSelectTransformationRule(inputOpRef, context); 
<|del|> 
 return new DataSourceIndex(primaryIndex, dataset.getDataverseName(), dataset.getDatasetName(), this); 
 MetadataProvider metadata = (MetadataProvider) mp; 
 MetadataProvider metadata = (MetadataProvider) mp; 
 int spaceAfterIncrease; 
 @Override public boolean rewritePost(Mutable<ILogicalOperator> opRef, IOptimizationContext context) 
<|del|> 
<|del|> 
 FileSplit[] splitsForDataset = metadataProvider.splitsForDataset(metadataProvider.getMetadataTxnContext(), 
<|del|> 
<|del|> 
 public FileSplit[] splitsForDataset(MetadataTransactionContext mdTxnCtx, String dataverseName, String datasetName, 
 public LineFileWriteOperatorDescriptor(IOperatorDescriptorRegistry spec, FileSplit[] splits, int[] columns, char separator) { 
 public RecordFileScanOperatorDescriptor(IOperatorDescriptorRegistry spec, FileSplit[] splits, RecordDescriptor recordDescriptor) { 
 protected UnmanagedFileSplit[] inputFileSplits; 
 FileReference fileRef = ncs.getIoManager().getFileReference(0, fileName); 
public abstract class FileSplit implements Serializable { 
 protected FileSplit(String node, String path) { 
 public abstract File getFile(IIOManager ioManager) throws HyracksDataException; 
 * @param path 
 * determine which IO device holds the path and returns a FileReference based on that 
 public FileReference resolve(String path) throws HyracksDataException; 
public class MappedFileSplit extends ManagedFileSplit { 
 private final IIOManager ioManager; 
 FileWriteOperator(IIOManager ioManager, int index) { 
 protected abstract IRecordWriter createRecordWriter(IIOManager ioManager, ManagedFileSplit fileSplit, int index) 
 return new DeserializedOperatorNodePushable(ctx, new FileWriteOperator(ctx.getIOManager(), partition), recordDescProvider.getInputRecordDescriptor(getActivityId(), 0)); 
 return new FileOutputStream((File) args[0]); } catch (FileNotFoundException e) { 
 return new FileOutputStream((File) args[0]); } catch (FileNotFoundException e) { 
 protected IRecordWriter createRecordWriter(IIOManager ioManager, ManagedFileSplit fileSplit, int index) 
 if (columns == null) { for (int i = 0; i < record.length; ++i) { if (i != 0) { bufferedWriter.write(separator); } bufferedWriter.write(StringSerializationUtils.toString(record[i])); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 ManagedFileSplit[] ordersSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "tpch0.001" + File.separator + "orders.tbl") }; 
 ManagedFileSplit[] ordersSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "tpch0.001" + File.separator + "orders.tbl") }; 
 new ManagedFileSplit[] { new ManagedFileSplit(NC1_ID, path) }); 
 ManagedFileSplit[] ordersSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "tpch0.001" + File.separator + "orders4.tbl") }; 
 ManagedFileSplit[] ordersSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "tpch0.001" + File.separator + "orders4.tbl") }; 
 ManagedFileSplit[] ordersSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "tpch0.001" + File.separator + "orders1.tbl") }; 
 ManagedFileSplit[] ordersSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "tpch0.001" + File.separator + "orders1.tbl") }; 
 ManagedFileSplit[] custSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "customer.tbl") }; 
 ManagedFileSplit[] custSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "customer.tbl") }; 
 ManagedFileSplit[] custSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "customer.tbl") }; 
 ManagedFileSplit[] custSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "customer.tbl") }; 
 ManagedFileSplit[] custSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "customer.tbl") }; 
 ManagedFileSplit[] custSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "customer.tbl") }; 
<|del|> 
<|del|> 
<|del|> 
 OptimizableOperatorSubTree indexSubTree; 
 if (index.getResourceID() == resource.getId()) { throw new HyracksDataException("Resource Id doesn't match expected metadata index resource id"); } 
 if (index.getResourceID() == resource.getId()) { throw new HyracksDataException("Resource Id doesn't match expected metadata index resource id"); } 
 FileReference bTreeFileRef = ioManager.resolveAbsolutePath(bTreeFile.getAbsolutePath()); FileReference bloomFilterFileRef = ioManager.resolveAbsolutePath(bloomFilterFile.getAbsolutePath()); 
 FileReference bTreeFileRef = ioManager.resolveAbsolutePath(bTreeFile.getAbsolutePath()); FileReference bloomFilterFileRef = ioManager.resolveAbsolutePath(bloomFilterFile.getAbsolutePath()); 
 FileReference bTreeFileRef = ioManager.resolveAbsolutePath(bTreeFile.getAbsolutePath()); FileReference buddyBTreeFileRef = ioManager.resolveAbsolutePath(buddyBTreeFile.getAbsolutePath()); FileReference bloomFilterFileRef = ioManager.resolveAbsolutePath(bloomFilterFile.getAbsolutePath()); 
 FileReference bTreeFileRef = ioManager.resolveAbsolutePath(bTreeFile.getAbsolutePath()); FileReference buddyBTreeFileRef = ioManager.resolveAbsolutePath(buddyBTreeFile.getAbsolutePath()); FileReference bloomFilterFileRef = ioManager.resolveAbsolutePath(bloomFilterFile.getAbsolutePath()); 
 FileReference bTreeFileRef = ioManager.resolveAbsolutePath(bTreeFile.getAbsolutePath()); FileReference buddyBTreeFileRef = ioManager.resolveAbsolutePath(buddyBTreeFile.getAbsolutePath()); FileReference bloomFilterFileRef = ioManager.resolveAbsolutePath(bloomFilterFile.getAbsolutePath()); 
 FileReference rTreeFileRef = ioManager.resolveAbsolutePath(rTreeFile.getAbsolutePath()); FileReference bTreeFileRef = ioManager.resolveAbsolutePath(bTreeFile.getAbsolutePath()); FileReference bloomFilterFileRef = ioManager.resolveAbsolutePath(bloomFilterFile.getAbsolutePath()); 
 FileReference rTreeFileRef = ioManager.resolveAbsolutePath(rTreeFile.getAbsolutePath()); FileReference bTreeFileRef = ioManager.resolveAbsolutePath(bTreeFile.getAbsolutePath()); FileReference bloomFilterFileRef = ioManager.resolveAbsolutePath(bloomFilterFile.getAbsolutePath()); 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { createFile(nc1) }); 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { createFile(nc1) }); 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { createFile(nc1) }); 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { createFile(nc1) }); 
<|del|> 
 return new ConstantFileSplitProvider(new FileSplit[] { fileSplit }); 
 FileSplit[] intFileSplits = new FileSplit[1]; intFileSplits[0] = new ManagedFileSplit(AlgebricksHyracksIntegrationUtil.NC1_ID, "data" + File.separator + "simple" + File.separator + "int-part1.tbl"); 
 FileSplit[] fileSplits = new FileSplit[1]; fileSplits[0] = new ManagedFileSplit(AlgebricksHyracksIntegrationUtil.NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "customer.tbl"); 
 "data" + File.separator + "tpch0.001" + File.separator + "customer-part1.tbl"); 
 FileSplit[] fileSplits = new FileSplit[1]; fileSplits[0] = new ManagedFileSplit(AlgebricksHyracksIntegrationUtil.NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "customer.tbl"); 
 FileSplit[] inputSplits = new FileSplit[] { 
 outputOp[i] = new LineFileWriteOperatorDescriptor(spec, new FileSplit[] { fileSplit }); 
 outputOp[i] = new LineFileWriteOperatorDescriptor(spec, new FileSplit[] { fileSplit }); 
 public FileSplit createFile(NodeControllerService ncs) throws IOException { 
 FileSplit[] outputFileSplit = new FileSplit[outputArity]; 
 FileSplit[] inputSplits = new FileSplit[] { 
 outputOp[i] = new LineFileWriteOperatorDescriptor(spec, new FileSplit[] { outputFileSplit[i] }); 
 FileSplit[] fileSplits = new FileSplit[1]; fileSplits[0] = new ManagedFileSplit(AlgebricksHyracksIntegrationUtil.NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "nation.tbl"); 
 primarySplitProvider = new ConstantFileSplitProvider(new FileSplit[] { new ManagedFileSplit(NC1_ID, 
 secondarySplitProvider = new ConstantFileSplitProvider(new FileSplit[] { new ManagedFileSplit(NC1_ID, 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "tpch0.001" + File.separator + "orders-part1.tbl") }; 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "tpch0.002" + File.separator + "orders-part2.tbl") }; 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { 
 primarySplitProvider = new ConstantFileSplitProvider(new FileSplit[] { new ManagedFileSplit(NC1_ID, 
 secondarySplitProvider = new ConstantFileSplitProvider(new FileSplit[] { new ManagedFileSplit(NC1_ID, 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "orders-with-locations-part1.txt") }; 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator + "orders-with-locations-part2.txt") }; 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { createFile(nc1) }); 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { createFile(nc1) }); 
 IFileSplitProvider outSplits = new ConstantFileSplitProvider(new FileSplit[] { createFile(nc1) }); 
 new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "tpch0.002" + File.separator + "lineitem.tbl") }); 
 FileSplit[] splits = new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "words.txt") }; 
 FileSplit[] splits = new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator + "words.txt") }; 
 new FileSplit[] { fs }); 
 new FileSplit[] { fs }); 
 FileSplit[] inputSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, inputFileName) }; 
 IFileSplitProvider splitProvider = new ConstantFileSplitProvider(new FileSplit[] { 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator 
 new FileSplit[] { 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] ordersSplits = new FileSplit[] { new ManagedFileSplit(NC2_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { 
 FileSplit[] ordersSplits = new FileSplit[] { 
 FileSplit[] custSplits = new FileSplit[] { 
 FileSplit[] custSplits = new FileSplit[] { 
 FileSplit[] custSplits = new FileSplit[] { 
 FileSplit[] custSplits = new FileSplit[] { 
 FileSplit[] custSplits = new FileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator 
 FileSplit[] custSplits = new FileSplit[] { 
 FileSplit[] custSplits = new FileSplit[] { 
 FileSplit[] custSplits = new FileSplit[] { 
 new FileSplit[] { new ManagedFileSplit(NC1_ID, path) }); 
 + SPLIT_STRING + BLOOM_FILTER_STRING)); 
 + SPLIT_STRING + BLOOM_FILTER_STRING)); 
 + SPLIT_STRING + BLOOM_FILTER_STRING)); 
 default: 
<|del|> 
<|del|> 
 case CIRCLE: 
 case DATE: 
 case DATETIME: 
 case DOUBLE: 
 case FLOAT: 
 case BOOLEAN: 
 case INT8: 
 case INT16: 
 case INT32: 
 case INT64: 
 case LINE: 
<|del|> 
 case STRING: 
 case BINARY: 
 case TIME: 
 case DURATION: 
 case YEARMONTHDURATION: 
 case INTERVAL: 
 case ORDEREDLIST: 
 case POINT: 
 case POINT3D: 
 case RECTANGLE: 
 case POLYGON: 
 case RECORD: 
 case UNORDEREDLIST: 
 case UUID: 
 case SHORTWITHOUTTYPEINFO: 
 default: 
<|del|> 
 protected static final ISerializerDeserializer<ADayTimeDuration> dayTimeDurationSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADAYTIMEDURATION); 
 protected static final ISerializerDeserializer<AYearMonthDuration> yearMonthDurationSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AYEARMONTHDURATION); 
 case UNION: 
<|del|> 
 case UNION: // we could do smth better for nullable fields 
<|del|> 
 case INT16: 
<|del|> 
<|del|> 
 case FLOAT: 
 case DOUBLE: 
 case STRING: 
 case RECTANGLE: 
 case CIRCLE: 
 case POINT: 
 case POINT3D: 
 case LINE: 
 case POLYGON: 
 case DURATION: 
 case INTERVAL: 
 case UUID: 
 case BINARY: 
 default: 
<|del|> 
 case STRING: return hashedTokens ? aqlHashingStringTokenizer : aqlStringTokenizer; case ORDEREDLIST: 
 case UNORDEREDLIST: 
 default: 
<|del|> 
 case STRING: 
 case UNORDEREDLIST: 
 default: 
<|del|> 
 case UNION: 
<|del|> 
<|del|> 
<|del|> 
 case FLOAT: 
 case DOUBLE: 
 case STRING: 
 case BINARY: 
 default: 
<|del|> 
 case FLOAT: 
 case DOUBLE: 
 case STRING: 
 case BINARY: 
 private final ISerializerDeserializer<ADateTime> datetimeSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADATETIME); 
 private final ISerializerDeserializer<ADateTime> datetimeSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADATETIME); 
 private final ISerializerDeserializer<ADateTime> datetimeSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADATETIME); 
 IBinaryComparator utf8BinaryComparator = BinaryComparatorFactoryProvider.UTF8STRING_POINTABLE_INSTANCE.createBinaryComparator(); 
 private ISerializerDeserializer<ARectangle> rectangle2DSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ARECTANGLE); 
 private ISerializerDeserializer<AYearMonthDuration> yearMonthDurationSerde = SerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.AYEARMONTHDURATION); 
 private ISerializerDeserializer<ARectangle> rectangle2DSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ARECTANGLE); 
 private final ISerializerDeserializer<ARectangle> rectangleSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ARECTANGLE); 
 private final IBinaryComparator ascDoubleComp = BinaryComparatorFactoryProvider.DOUBLE_POINTABLE_INSTANCE.createBinaryComparator(); 
 private ISerializerDeserializer<ADayTimeDuration> dayTimeDurationSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer( BuiltinType.ADAYTIMEDURATION); 
 private ISerializerDeserializer<ADayTimeDuration> dayTimeDurationSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer( BuiltinType.ADAYTIMEDURATION); 
 private ISerializerDeserializer<AYearMonthDuration> yearMonthDurationSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer( BuiltinType.AYEARMONTHDURATION); 
 private final ISerializerDeserializer<AInterval> intervalSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINTERVAL); 
 private final ISerializerDeserializer<AInterval> intervalSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINTERVAL); 
 public JobId startJob(byte[] acggfBytes, Set<JobFlag> jobFlags, JobId jobId) throws Exception { 
 public JobId startJob(byte[] acggfBytes, Set<JobFlag> jobFlags, JobId jobId) throws Exception; 
 public JobId startJob(byte[] acggfBytes, Set<JobFlag> jobFlags, JobId jobId) throws Exception; 
 this.recordLvl = "true".equals(collection) ? 1 : 0; 
 if (curLvl == recordLvl && curStatus == 5) { 
 private static final String CAP_DATETIME_REGEX = "\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:" + "\\d\\d:\\d\\d[-,+]\\d\\d:\\d\\d"; 
 private SAXParserFactory capMessageSAXParserFactory; private SAXParser capMessageSAXParser; 
 Deque<String> curPathStack; 
 Deque<String> curPathStack; 
 String preElementName; private Map<String, Integer> listElementNames; 
 public ListElementHandler(Map<String, Integer> listElementNames) { 
 Deque<Boolean> recordTypeMarker; Deque<IAType> fieldTypeTracker; Deque<String> nestedListTracker; Deque<String> curPathStack; 
 public CAPMessageHandler(ARecordType recordType, List<ArrayBackedValueStorage> bufferList, List<IARecordBuilder> rbList) throws HyracksDataException { 
 public CAPMessageHandler(ARecordType recordType, List<ArrayBackedValueStorage> bufferList, List<IARecordBuilder> rbList) throws HyracksDataException { 
 public CAPMessageHandler(ARecordType recordType, List<ArrayBackedValueStorage> bufferList, List<IARecordBuilder> rbList) throws HyracksDataException { 
 if (nestedListTracker.isEmpty() || !nestedListTracker.peek().equals(fullPathName)) { 
<|del|> 
<|del|> 
 state = START_OF_ELEMENT_NAME; 
 private ComplexBuilder complexBuilder; private ArrayList<ComplexBuilder> builderList; 
 complexBuilder.write(out); 
<|del|> 
<|del|> 
 private static boolean fileNotExistsInList(List<File> files, Path path) { 
 EnumSet<JobFlag> jobFlags) throws Exception; 
 EnumSet<JobFlag> jobFlags) throws Exception; 
 public StartJobFunction(DeploymentId deploymentId, byte[] acggfBytes, EnumSet<JobFlag> jobFlags, JobId jobId) { 
<|del|> 
 joiner.closeTable(); 
 EnumSet<JobFlag> jobFlags) throws Exception; 
 if (flags.contains(JobFlag.STORE_JOB)) { //TODO: Right now the map is append-only 
 case INNER: 
 default: 
<|del|> 
 public static final int SMART_BUILDER_STATE_RECORD = 1; public static final int SMART_BUILDER_STATE_LIST = 2; public static final int SMART_BUILDER_STATE_VALUE = 3; 
 public static final int SMART_BUILDER_STATE_RECORD = 1; public static final int SMART_BUILDER_STATE_LIST = 2; public static final int SMART_BUILDER_STATE_VALUE = 3; 
<|del|> 
<|del|> 
<|del|> 
 LOGGER.log(Level.WARNING, "Channel Job Failed to run.", e); 
 //TODO: Allow Repetitive Channels to use YMD durations 
<|del|> 
<|del|> 
 LOGGER.log(Level.WARNING, "Channel Failed to connect to Broker."); 
 LOGGER.log(Level.WARNING, "Channel Failed to connect to Broker."); 
 LOGGER.log(Level.INFO, response.toString()); 
 LOGGER.log(Level.WARNING, "Channel Failed to get response from Broker."); 
 LOGGER.log(Level.WARNING, "Channel Failed to connect to Broker."); 
<|del|> 
 return new RepetitiveChannelOperatorNodePushable(ctx, runtimeId, jobSpec, duration, strIP, port); 
 private static final String ERROR_MESSAGE_DUPLICATE_FIELD = "Duplicate field name \"%1$s\""; 
 // runtime errors 
 // runtime errors 
 if (th.getErrorCode() == ErrorCode.ERROR_PROCESSING_TUPLE) { 
<|del|> 
<|del|> 
 CollectionRuntime feedRuntime = (CollectionRuntime) feedManager.getRuntime(runtimeId); 
 throw new RuntimeDataException( ErrorCode.ERROR_OPERATORS_FEED_MSG_OPERATOR_NODE_PUSHABLE_INVALID_SUBSCRIBABLE_RUNTIME, subscribableRuntimeType); 
 private final String nodeId; private transient volatile String msgCache; 
 private final String nodeId; private transient volatile String msgCache; 
 private final String nodeId; private transient volatile String msgCache; 
<|del|> 
<|del|> 
 throw new RuntimeDataException( ErrorCode.ERROR_INPUT_RECORD_CONVERTER_DCP_MSG_TO_RECORD_CONVERTER_UNKNOWN_DCP_REQUEST, dcpRequest.toString()); 
 frameDistributor.close(); 
 throw new CoreDataException( ErrorCode.ERROR_PARSER_DATAFLOW_STD_FILE_FIELD_CURSOR_FOR_DELIMITED_PARSER_QUOTE_BEGINNING, recordCount, fieldCount); 
<|del|> 
 private JobRun(DeploymentId deploymentId, JobId jobId, EnumSet<JobFlag> jobFlags) { 
 this(deploymentId, jobId, jobFlags); 
 ccs.removeActivityClusterGraph(jobId); 
<|del|>
 * destroy a pre-distributed job 
 ncs.removeActivityClusterGraph(jobId); 
 ncs.checkForDuplicateDistributedJob(jobId); ActivityClusterGraph acg = (ActivityClusterGraph) DeploymentUtils.deserialize(acgBytes, null, ncs.getApplicationContext()); ncs.storeActivityClusterGraph(jobId, acg); 
 ncs.storeActivityClusterGraph(jobId, acg); 
 protected void appendOtherTupleFields(ArrayTupleBuilder tb) throws Exception { 
 } catch (Exception ex) { 
 } catch (Exception exception) { 
 private void logExceptionCausingTuple(int tupleIndex, Throwable e) throws HyracksDataException { 
 private void logExceptionCausingTuple(int tupleIndex, Throwable e) throws HyracksDataException { 
 throw new HyracksDataException("attempt to register to a failed feed data provider", rootFailureCause); 
 throw new HyracksDataException("attempt to register to a failed feed data provider", rootFailureCause); 
 JobId jobId, JobSpecification jobSpec, Map<String, String> feedPolicy) throws HyracksDataException { 
 throw e; } catch (Exception exception) { 
 frameCollector.wait(); 
 private static void init() throws HyracksDataException { 
 throw new RuntimeDataException(ErrorCode.ERROR_LIBRARY_EXTERNAL_FUNCTION_UNSUPPORTED_KIND, finfo.getKind()); 
 try { throw new RuntimeDataException(ErrorCode.ERROR_LIBRARY_JAVA_FUNCTION_HELPER_OBJ_TYPE_NOT_SUPPORTED, jtypeTag.name()); } catch (IllegalStateException e) { // Exception is not thrown e.printStackTrace(); } break; 
 throw new RuntimeDataException(ErrorCode.ERROR_LIBRARY_EXTERNAL_FUNCTION_UNSUPPORTED_NAME, finfo.getFunctionIdentifier().getName()); 
 throw new RuntimeDataException( ErrorCode.ERROR_OPERATORS_FEED_INTAKE_OPERATOR_NODE_PUSHABLE_FAIL_AT_INGESTION); 
 throw new RuntimeDataException( ErrorCode.ERROR_OPERATORS_FEED_MSG_OPERATOR_NODE_PUSHABLE_INVALID_SUBSCRIBABLE_RUNTIME, 
<|del|> 
<|del|> 
 private void parseRecord() throws HyracksDataException { 
 throw new HyracksDataException(e); 
 public void appendKeys(ArrayTupleBuilder tb, IRawRecord<? extends T> record) throws HyracksDataException { // do nothing. 
 } catch (Exception e) { throw new RuntimeDataException( ErrorCode.ERROR_PROVIDER_DATASOURCE_FACTORY_UNKNOWN_INPUT_STREAM_FACTORY, e, streamSource); 
 } catch (Exception e) { throw new RuntimeDataException( ErrorCode.ERROR_PROVIDER_DATASOURCE_FACTORY_UNKNOWN_INPUT_STREAM_FACTORY, e, streamSource); 
 } catch (Exception e) { throw new RuntimeDataException( ErrorCode.ERROR_PROVIDER_DATASOURCE_FACTORY_UNKNOWN_INPUT_STREAM_FACTORY, e, streamSource); 
 Thread.sleep(sleepInterval); 
 public void sendApplicationMessageToCC(Serializable message, DeploymentId deploymentId) throws Exception { 
 public boolean nextRecord() throws IOException { 
 public boolean nextField() throws IOException { 
 throw new IOException("At record: " + recordCount + ", field#: " + fieldCount + " - a quote enclosing a field needs to be placed in the beginning of that field."); 
 throw new IOException("At record: " + recordCount + ", field#: " + fieldCount + " - A quote enclosing a field needs to be followed by the delimiter."); 
 throw new HyracksDataException("attempt to register to a failed feed data provider", rootFailureCause); 
 throw new HyracksDataException("attempt to register to a failed feed data provider", rootFailureCause); 
<|del|> 
 } catch (Exception ex) { 
 } catch (Exception exception) { 
 } catch (Exception e) { 
 throw e; } catch (Exception exception) { 
 frameCollector.wait(); 
 public void sendApplicationMessageToCC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; 
 if (startPos == -1) { char[] tempBuffer = ("<" + String.valueOf(inputBuffer)).toCharArray(); 
 if (startPos == -1) { char[] tempBuffer = ("<" + String.valueOf(inputBuffer)).toCharArray(); 
 if (startPos == -1) { char[] tempBuffer = ("<" + String.valueOf(inputBuffer)).toCharArray(); 
<|del|> 
 ICheckpointManager checkpointMgr = runtimeContext.getTransactionSubsystem().getCheckpointManager(); checkpointMgr.doSharpCheckpoint(); 
 * A daemon thread that periodically attempts to perform checkpoints. 
 protected static final int MIN_TABLE_SIZE = 100; protected static final int TABLE_FRAME_SIZE = 32768; 
 CAPParserState state = CAPParserState.INIT_STATE; 
 if (state == CAPParserState.IN_START_OF_ELEMENT_NAME) { 
 } else if (state == CAPParserState.IN_SCHEMA_DEFINITION) { 
 if (state == CAPParserState.START_OF_ELEMENT_NAME) { 
 return true; 
 throws HyracksDataException { // an initialized append only tree is always completely empty with size = 0, hence, this operation is a No Op 
 public void invalidate() { // When an append only tree is created, it is automatically invalidated, hence, this is a No Op 
 public void releasePage(ITreeIndexMetaDataFrame metaFrame, int freePage) throws HyracksDataException { throw new HyracksDataException("Pages of an in memory index are released through the virtual buffer cache"); 
 throws HyracksDataException { throw new HyracksDataException("Pages of an in memory index are released through the virtual buffer cache"); 
 public void setRootPageId(int rootPage) throws HyracksDataException { // the root of an in memory index will always be 1 
 public void invalidate() throws HyracksDataException { throw new HyracksDataException( "An in memory index can't be invalidated. It can be reset through calling init()"); 
<|del|> 
<|del|> 
 boolean isPointMBR, IPageManagerFactory pageManagerFactory) { 
 ILocalResourceRepositoryFactory localResourceRepositoryFactory = new TransientLocalResourceRepositoryFactory(); 
<|del|> 
 public void setRootPageId(int rootPage) throws HyracksDataException { // the root of an in memory index will always be 1 
 if (smFlag) { 
<|del|> 
<|del|> 
 if (!appendOnly || (appendOnly && confiscatedMetaNode == null)) { 
 return (metaFrame.getLevel() == META_PAGE_LEVEL_INDICATOR); 
 this.file = file; this.largePageHelper = leafFrameFactory.getLargePageHelper(); 
<|del|> 
 public void releasePage(ITreeIndexMetaDataFrame metaFrame, int freePage) throws HyracksDataException { throw new HyracksDataException("Pages of an in memory index are released through the virtual buffer cache"); 
 throws HyracksDataException { throw new HyracksDataException("Pages of an in memory index are released through the virtual buffer cache"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public void setRootPageId(int rootPage) throws HyracksDataException { // the root of an in memory index will always be 1 
<|del|> 
 ITupleFilterFactory tupleFilterFactory, IModificationOperationCallbackFactory modificationOpCallbackFactory, String indexName, IMetadataPageManagerFactory metadataPageManagerFactory) { 
 public static final List<IAlgebraicRewriteRule> buildFulltextContainsRuleCollection() { return Collections.singletonList(new FullTextContainsParameterCheckRule()); } public static final List<IAlgebraicRewriteRule> buildNormalizationRuleCollection() { 
 final PersistentLocalResourceRepository localResourceRepository = 
 final PersistentLocalResourceRepository localResourceRepository = (PersistentLocalResourceRepository) txnSubsystem 
 List<IAlgebraicRewriteRule> alteredNormalizationCollection = new ArrayList<>(); alteredNormalizationCollection.addAll(normalizationCollection); 
<|del|> 
 for (IntSerDeBuffer frame : headers) { 
 throw new TypeMismatchException(funcName, argIndex, type.getTypeTag(), ATypeTag.INT8, ATypeTag.INT16, ATypeTag.INT32, ATypeTag.INT64); 
<|del|> 
 + ((bytes[offset + 2] & 0xff) << 8) + (bytes[offset + 3] & 0xff); 
 bytes[offset] = (byte) (value); 
 public static final int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) { 
 public LSMComponentFilterFrameFactory(ITreeIndexTupleWriterFactory tupleWriterFactory) { 
 BooleanPointable.setBoolean(buf, MIN_SET_INDICATOR_OFFSET, min.getLength() == 0); BooleanPointable.setBoolean(buf, MAX_SET_INDICATOR_OFFSET, max.getLength() == 0); 
<|del|> 
 // avoid additional optFuncExpressions in case of a join 
 isFullTextSearchQuery = AccessMethodUtils.getBooleanConstant(funcArgs.get(index + IS_FULLTEXT_SEARCH_INDEX)); 
 return getStatementExecutorFactory(null); 
<|del|> 
 @Override public boolean rewritePost(Mutable<ILogicalOperator> opRef, IOptimizationContext context) 
 IMetadataPageManager metadataPageManager = (IMetadataPageManager) rtreeComponent.getRTree() .getPageManager(); 
 public void split(ITreeIndexFrame rightFrame, ITupleReference tuple, ISplitKey splitKey, IExtraPageBlockHelper extraPageBlockHelper, IBufferCache bufferCache) 
 IMetadataPageManager metadataPageManager = (IMetadataPageManager) treeIndex.getPageManager(); 
 IMetadataPageManager metadataPageManager = (IMetadataPageManager) treeIndex.getPageManager(); 
 IMetadataPageManager metadataPageManager = (IMetadataPageManager) btreeComponent.getBTree() .getPageManager(); 
 IMetadataPageManager metadataPageManager = (IMetadataPageManager) btreeComponent.getBTree() .getPageManager(); 
 return INVALID; 
 if (afp.getLSNByteOffset() != IMetaDataPageManager.INVALID_LSN_OFFSET) { 
 treeMetaManager.get(treeMetaManager.createMetadataFrame(), MARKER_LSN_KEY, pointable); 
 private static final double DOUBLE_EPSILON = computeDoubleEpsilon(); 
 LongPointable pointable = new LongPointable(); IMetadataPageManager metadataPageManager = ((IMetadataPageManager) treeIndex.getPageManager()); metadataPageManager.get(metadataPageManager.createMetadataFrame(), LSN_KEY, pointable); return pointable.getLength() == 0 ? INVALID : pointable.longValue(); 
 if (afp.getLSNByteOffset() != IMetaDataPageManager.INVALID_LSN_OFFSET) { 
 public Map<String, NodeControllerInfo> getNodeControllerInfos() throws HyracksException; 
 public ClusterTopology getClusterTopology() throws HyracksException; 
 similarityThreshold = ((ConstantExpression) funcArgs.get(index + SIM_THRESHOLD_INDEX).getValue()).getValue(); 
 "Unequal number of valid Dictionary BTree, Inverted Lists, Deleted BTree, and Bloom Filter files found. Aborting cleanup."); 
 queryTokenBuilder.reset(); tokenCountInOneField++; 
 } else { //TODO(amoudi): Ensure Bulk load follow the same lifecycle Other Operations (Flush, Merge, etc). //then after operation should be called from harness as well //https://issues.apache.org/jira/browse/ASTERIXDB-1764 
 return LangExecutionUtil.buildTestsInXml(TestCaseContext.DEFAULT_REPEATED_TESTSUITE_XML_NAME); 
 } StringWriter sw = new StringWriter(); LicenseUtil.readAndTrim(sw, cFile); license.setContent(sw.toString()); 
 final MavenProject depProject = dep.getKey(); String depLocation = dependencySets.isEmpty() ? location : getIncludedLocation(depProject.getArtifact()); 
public class LicenseUtil { private LicenseUtil() { } 
 @Override public void execute(Environment env, Map params, TemplateModel [] loopVars, TemplateDirectiveBody body) 
 body.render(new IndentingWriter(env.getOut(), spacesParam)); } } 
 getLog().debug("- URL: " + new URL(licenseUrl)); 
 conf.out().println(spec.toJSON().toString(1)); 
 for (String attrName : JSONObject.getNames(obj)) { if (obj.isNull(attrName) || obj.length() == 0) { 
 return Integer.compare(l1 != null ? l1.getMetric() : LicenseSpec.UNDEFINED_LICENSE_METRIC, l2 != null ? l2.getMetric() : LicenseSpec.UNDEFINED_LICENSE_METRIC); 
 /** * Prints out the detailed information for partitions: in-memory and spilled partitions. * This method exists for a debug purpose. */ public String printPartitionInfo(SIDE whichSide) { StringBuilder buf = new StringBuilder(); 
<|del|> 
<|del|> 
<|del|> 
 int headerSlotTotalCount; 
 buf.append("(A) hash table cardinality (# of slot):\t" + tableSize + "\tExpected Table Size(MB):\t" 
 public SlotInfoPair(T1 first, T2 second) { 
 } 
<|del|> 
 return buf.toString(); 
 private static final int LAST_EXPRESSION_POS_BEFORE_OPTION = 1; private static final int FULLTEXT_WITHOUT_OPTION_NO_OF_ARGUMENTS = 2; private static final int FULLTEXT_WITH_OPTION_NO_OF_ARGUMENTS = 3; 
 private static final int LAST_EXPRESSION_POS_BEFORE_OPTION = 1; private static final int FULLTEXT_WITHOUT_OPTION_NO_OF_ARGUMENTS = 2; private static final int FULLTEXT_WITH_OPTION_NO_OF_ARGUMENTS = 3; 
 private static final int LAST_EXPRESSION_POS_BEFORE_OPTION = 1; private static final int FULLTEXT_WITHOUT_OPTION_NO_OF_ARGUMENTS = 2; private static final int FULLTEXT_WITH_OPTION_NO_OF_ARGUMENTS = 3; 
 public void rewrite(List<FunctionDecl> declaredFunctions, StatementWithReturn topExpr, MetadataProvider metadataProvider, LangRewritingContext context) throws AsterixException; 
 if (returnExpression != null) { 
 if (returnExpression != null) { 
 if (returnExpression != null) { 
 @Option(name = "-initial-run", usage = "A flag indicating if it's the first time the NC is started (default: false)", required = false) 
 PersistentLocalResourceRepository localResourceRepository = (PersistentLocalResourceRepository) runtimeContext .getLocalResourceRepository(); 
<|del|> 
 private static final String REPLICATION_MAX_REMOTE_RECOVERY_ATTEMPTS_KEY = "replication.max.remote.recovery.attempts"; 
 private String metadataNodeId; private Replica metadataPrimaryReplica; private Set<Replica> metadataNodeReplicas; 
 public void startReplicationThreads() { 
<|del|> 
 public static int calculateGroupByTableCardinality(int memoryBudgetInBytes, int numberOfGroupByColumns, 
<|del|> 
 /** * Prints out the detailed information for partitions: in-memory and spilled partitions. * This method exists for a debug purpose. */ public String printPartitionInfo(SIDE whichSide) { StringBuilder buf = new StringBuilder(); 
 OptimizedHybridHashJoinOperatorDescriptor join = new OptimizedHybridHashJoinOperatorDescriptor(spec, 15, 122, 
 int minDataSize = frameSize * 4; 
<|del|> 
<|del|> 
<|del|> 
 private static final String REPLICATION_MAX_REMOTE_RECOVERY_ATTEMPTS_KEY = "replication.max.remote.recovery.attempts"; 
 private String metadataNodeId; private Replica metadataPrimaryReplica; private Set<Replica> metadataNodeReplicas; 
 return Collections.emptySet(); 
 return Collections.emptySet(); 
 private static final Map<String, Class<? extends IReplicationStrategy>> BUILT_IN_REPLICATION_STRATEGY = new HashMap<>(); 
 IndexFileRef indexFileRef = localResourceRepo.getIndexFileRef(jobFile); if (!replicationStrategy.isMatch(indexFileRef.getDatasetId())) { return; } 
 Set<String> nodes = replicationProperties.getNodeReplicasIds(localNodeId); 
<|del|> 
<|del|> 
 Map<String, ClusterPartition[]> nodePartitions = ((IPropertiesProvider) runtimeContext).getMetadataProperties() .getNodePartitions(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private static final Map<String, Class<? extends IFaultToleranceStrategy>> BUILT_IN_FAULT_TOLERANCE_STRATEGY = new HashMap<>(); 
<|del|> 
 private T1 first; private T2 second; 
 public static int calculateGroupByTableCardinality(long memoryBudgetByteSize, int numberOfGroupByColumns, 
 public static int calculateGroupByTableCardinality(long memoryBudgetByteSize, int numberOfGroupByColumns, 
 long possibleNumberOfHashEntries = 2L << numberOfBits; 
 double hashTableRatio = (double) groupByTableByteSize / (groupByTableByteSize + memoryBudgetByteSize); 
 public static long getExpectedTableFrameCount(long tableSize, int frameSize) { long numberOfHeaderFrame = (long) (Math.ceil((double) tableSize * 2 / (double) frameSize)); long numberOfContentFrame = (long) (Math 
 int tableSize = 1001; int numFrames = 3; 
 int minDataSize = frameSize * 4; 
 int minDataSize = frameSize * 5; 
 String subdir = innerfile.isDirectory() ? TestHelper.joinPath(path, innerfile.getName()) : path; 
<|del|> 
<|del|> 
 long freeSpace = (long) (memSizeInFrames - spilledStatus.cardinality()) * frameSize; 
 long minSpaceAfterIncrease = (long) memSizeInFrames * frameSize; 
 .getExpectedTableByteSize((long) currentInMemTupCount - buildPSizeInTups[p], frameSize)); 
 (long) inMemTupCount + spilledTupleCount, ctx.getInitialFrameSize()) - originalHashTableSize; 
 private static class ResultSetMap implements IDatasetStateRecord, Serializable { 
 HashMap<ResultSetId, ResultState[]> resultStateMap; 
<|del|> 
 public void rewrite(List<FunctionDecl> declaredFunctions, IReturningStatement topStatement, MetadataProvider metadataProvider, LangRewritingContext context) throws AsterixException { setup(declaredFunctions, topStatement, metadataProvider, context); if (topStatement.isTopLevel()) { 
<|del|> 
 ILocalResourceRepositoryFactory persistentLocalResourceRepositoryFactory = new PersistentLocalResourceRepositoryFactory( ioManager, ncApplicationContext.getNodeId(), metadataProperties); 
<|del|> 
 LOGGER.info("Stores: " + PrintUtil.toString(metadataProperties.getStores())); 
 * Updates the cluster state based on the state of all cluster partitions and the metadata node. 
 * Force the cluster state into {@code state} 
 * Force the cluster state into {@code state} 
 * Updates the active node and active state of the cluster partition with id {@code partitionNum} 
 * Updates the metadata node id and its state. 
 private static final String REPLICATION_MAX_REMOTE_RECOVERY_ATTEMPTS_KEY = "replication.max.remote.recovery.attempts"; 
 default boolean isParticipant(String nodeId) { 
 private static final Map<String, Class<? extends IReplicationStrategy>> BUILT_IN_REPLICATION_STRATEGY = new HashMap<>(); 
 boolean highAvailabilityEnabled = cluster.getHighAvailability() != null && cluster.getHighAvailability().getEnabled() != null && Boolean.valueOf(cluster.getHighAvailability().getEnabled()); if (!highAvailabilityEnabled || cluster.getHighAvailability().getDataReplication() == null 
 throw new IllegalStateException(e); 
 if (cluster.getHighAvailability().getDataReplication().getReplicationTimeOut() == null || String .valueOf(cluster.getHighAvailability().getDataReplication().getReplicationTimeOut().intValue()) .length() == 0) { 
 public void handleReplicaFailure(String replicaId) { 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 private static final Map<String, Class<? extends IFaultToleranceStrategy>> BUILT_IN_FAULT_TOLERANCE_STRATEGY = new HashMap<>(); 
 boolean highAvailabilityEnabled = cluster.getHighAvailability() != null && cluster.getHighAvailability().getEnabled() != null && Boolean.valueOf(cluster.getHighAvailability().getEnabled()); if (!highAvailabilityEnabled || cluster.getHighAvailability().getFaultTolerance() == null 
 throw new IllegalStateException(e); 
<|del|> 
<|del|> 
 ObjectNode json = ClusterStateManager.INSTANCE.getClusterStateDescription(); 
 ObjectNode json = ClusterStateManager.INSTANCE.getClusterStateDescription(); 
 json.set("cc", cc); 
<|del|> 
<|del|> 
<|del|> 
 json.set("ncs", getClusterStateJSON(request, "../").get("ncs")); 
<|del|> 
 if (node.equals(ncs.get(i).get("node_id").asText())) { return (ObjectNode) ncs.get(i); 
 json.set(newKey, json.remove(key)); 
 gc.set("name", gcNames.get(i)); gc.set("collection-time", ((ArrayNode)gcCollectionTimes.get(i)).get(index)); gc.set("collection-count", ((ArrayNode)gcCollectionCounts.get(i)).get(index)); 
 String primaryKeys, boolean temp, Map<String, NodeControllerInfo> nodeMap) throws Exception { 
 String primaryKeys, boolean temp, Map<String, NodeControllerInfo> nodeMap) throws Exception { 
 nc.set(PID, details.get(PID)); 
 jsonObject.set("cluster", clusterState); 
 displayRecord(record); 
 errorResp.set("error-code", errorArray); 
 for (Map.Entry<String, String> e : propMap.entrySet()) { expectedResponse.put(e.getKey(), e.getValue()); 
 res.set("handle", handle); 
 ++_nesting; 
 public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException { --_nesting; 
 public void writeStartArray(JsonGenerator jg) throws IOException { ++_nesting; 
 if (_nesting == 0) { 
<|del|> 
import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.Arrays; import java.util.ArrayList; 
 // <library-directory> 
 int nodePid = new ObjectMapper().readValue(config, ObjectNode.class).get("pid").asInt(); if (nodePid <= 1) { 
 if (json != null) { 
 json.set("ACircle", circle); 
 json.set("ADuration", duration); 
 json.set("ADuration", duration); 
 line.set("p1", p1.toJSON()); line.set("p2", p2.toJSON()); json.set("ALine", line); 
 json.set("AOrderedList", list); 
 json.set("APoint", point); 
 json.set("APoint3D", point); 
 json.set("APolygon", polygon); 
 item.set(type.getFieldNames()[i], fields[i].toJSON()); 
 json.set("ARecord", record); 
 rectangle.set("p1", p1.toJSON()); rectangle.set("p2", p2.toJSON()); json.set("ARectangle", rectangle); 
 json.set("AUnorderedList", list); 
 json.set("ADuration", duration); 
 type.set("item-type", itemType.toJSON()); 
 type.set("fields", fields); 
 type.set("item-type", itemType.toJSON()); 
 stateDescription.set("ncs",ncs); 
 jan.set("inputs", jInputs); 
 jan.set("depends-on", jDeps); 
 jac.set("activities", jans); 
 if (pcObject.size() > 0) { op.set("partition-constraints", pcObject); 
 jopArray.add(op); 
 acJSON.set("activities", activitiesJSON); 
 acJSON.set("dependencies", dependenciesJSON); 
 entry.set("input-partition-counts", inPartCountsJSON); 
 entry.set("output-partition-counts", outPartCountsJSON); 
 planJSON.set("activities", acTasks); 
 c.set("tasks", tasksAry); 
 c.set("produced-partitions", prodParts); 
 c.set("required-partitions", reqdParts); 
 attempt.set("task-attempts", taskAttempts); 
 c.set("attempts", attempts); 
 acJSON.set("plan", planJSON); 
 acJSON.set("plan", planJSON); 
 jobLogObject.set("activity-cluster-graph", acg.toJSON()); jobLogObject.set("job-run", run.toJSON()); 
 fileProperties.initialize(filePath, fileSize, replicaId, false, AbstractLSMIOOperationCallback.INVALID, false); 
 .map(Replica::getId).filter(getActiveReplicasIds()::contains).collect(Collectors.toSet()); 
<|del|> 
<|del|> 
 private int selectSinglePartitionToSpill(long currentFreeSpace, int currentInMemTupCount, int frameSize) { 
 private int selectPartitionsToReload(long freeSpace, int pid, int inMemTupCount) { 
 return finalGroupByTableCardinality > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) finalGroupByTableCardinality; 
 private static final int OUTPUT_FRAME_LIMT = 1; private static final int MIN_FRAME_LIMT = MIN_DATA_TABLE_FRAME_LIMT + MIN_HASH_TABLE_FRAME_LIMT + OUTPUT_FRAME_LIMT; 
 if (LOGGER.isLoggable(Level.FINE)) { LOGGER.fine("InMemoryHashJoin has finished using " + nFrames + " frames for Thread ID " + Thread.currentThread().getId() + "."); } 
 if (freeSpace < 0) { 
 // We put minus since the method returns a negative value to represent a newly reclaimed space. long expectedHashTableSizeDecrease = -SerializableHashTable .calculateByteSizeDeltaForTableSizeChange(inMemTupCount, -numberOfTuplesToBeSpilled, frameSize); 
 inMemTupCount -= numberOfTuplesToBeSpilled; if (freeSpace >= 0) { 
 private int selectPartitionsToReload(long freeSpace, int pid, int inMemTupCount) { 
 long expectedHashTableByteSizeIncrease = SerializableHashTable.calculateByteSizeDeltaForTableSizeChange( inMemTupCount, spilledTupleCount, ctx.getInitialFrameSize()); if (freeSpace >= buildRFWriters[i].getFileSize() + expectedHashTableByteSizeIncrease) { 
 int numFrames = 23; 
 int minDataSize = frameSize * 40; 
 int minDataSize = frameSize * 40; 
<|del|> 
 // <library-directory> 
 return ExternalDataUtils.createExternalParserFactory(libraryManager, ExternalDataUtils.getDataverse(configuration), parserFactoryName); 
 private static int storageMemorycomponentGlobalBudgetDefault; 
 jvmargs = "-Xmx" + (int) Math.ceil(0.6 * ramSize / (1024 * 1024)) + "m"; 
 private static int STORAGE_MEMORYCOMPONENT_NUMPAGES_DEFAULT; 
 e.printStackTrace(); 
 } catch (Exception exception) { exception.printStackTrace(); 
 throw new HyracksDataException(e); 
 ErrorCode.ERROR_PARSER_FACTORY_DELIMITED_DATA_PARSER_FACTORY_QUOTE_DELIMITER_MISMATCH, quoteValue, delimiter); 
 default IStatementExecutorFactory getStatementExecutorFactory(ExecutorService executorService) { 
 private HttpUriRequest constructHttpMethod(String statement, URI uri, String stmtParam, boolean postStmtAsParam, List<CompilationUnit.Parameter> otherParams) throws URISyntaxException { if (statement.length() + uri.toString().length() < MAX_URL_LENGTH) { 
<|del|> 
<|del|> 
<|del|>
 ResultSetMetaData rsMd = entry.getValue(); 
 case DEFERRED: 
 jobResultLocations.get(jobId).setException(exceptions.isEmpty() ? null : exceptions.get(0)); // TODO(tillw) throwing an NPE here hangs the system, why? 
 case DEFERRED: 
 public static final DefaultJobResourceController INSTANCE = new DefaultJobResourceController(); 
 public static final DefaultJobResourceController INSTANCE = new DefaultJobResourceController(); 
 // Does nothing for releasing the resource. 
 assert dACP != null : "IllegalStateEncountered: Dependent AC is being planned without a plan for " + "dependency AC: Encountered no plan for ActivityID " 
 assert dATasks.length == tasks.length : "Dependency activity partitioned differently from " + "dependent: " + dATasks.length + " != " + tasks.length; 
 assert dATasks.length == tasks.length : "Dependency activity partitioned differently from " + "dependent: " + dATasks.length + " != " + tasks.length; 
 TaskCluster[] taskClusters = ac.getActivityClusterGraph().isUseConnectorPolicyForScheduling() ? buildConnectorPolicyAwareTaskClusters(ac, activityPlanMap, taskConnectivity) : buildConnectorPolicyUnawareTaskClusters(ac, activityPlanMap); 
 nodeId = liveNodes.toArray(new String[liveNodes.size()])[Math.abs(random.nextInt()) % liveNodes.size()]; 
 nodeId = liveNodes.toArray(new String[liveNodes.size()])[Math.abs(random.nextInt()) % liveNodes.size()]; 
 jobRun.getConnectorPolicyMap()); INodeManager nodeManager = ccs.getNodeManager(); 
 ccs.getWorkQueue() .schedule(new JobCleanupWork(ccs.getJobManager(), jobRun.getJobId(), JobStatus.FAILURE, exceptions)); 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
<|del|> 
<|del|> 
 public JobManager(CCConfig ccConfig, ClusterControllerService ccs, IComputationResource computationResource) throws Exception { 
 this.ccs = ccs; this.computationResource = computationResource; 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
 executeJobInternal(run); 
 this.callback = callback; 
 long getAvailableCores(String nodeId); 
<|del|> 
 long availableMemoryByteSize = inputComputationResource.getAggregatedMemoryByteSize(); inputComputationResource.setAggregatedMemoryByteSize(availableMemoryByteSize + aggregatedRAMRequirement); 
 public JobManager(CCConfig ccConfig, ClusterControllerService ccs) throws Exception { 
 appCtx.notifyJobFinish(jobId); 
 appCtx.notifyJobFinish(jobId); 
 throw new HyracksException(e); 
 participatingNodeIds = new HashSet<>(); cleanupPendingNodeIds = new HashSet<>(); 
 * @throws HyracksDataException 
 ((IPropertiesProvider) asterixAppRuntimeContextProvider.getAppContext()).getMetadataProperties() 
 fileProperties.initialize(filePath, fileSize, replicaId, false, -1L, false); 
 fileProperties.initialize(filePath, fileSize, replicaId, false, -1L, false); 
 throw new HyracksException(e); 
 FeedEventsListener listener = (FeedEventsListener) ActiveJobNotificationHandler.INSTANCE.getActiveEntityListener(entityId); 
 public JobManager(CCConfig ccConfig, ClusterControllerService ccs, IComputationResource computationResource) throws Exception { 
 this.ccs = ccs; this.computationResource = computationResource; 
 double duration; 
 public void doGet(IServLetRequest request, IServLetResponse response) { 
 response.setStatus(HttpResponseStatus.OK); if ("".equals(path(request))) { 
 LOGGER.log(Level.WARNING, "Failure handling a request", e); 
 LOGGER.log(Level.WARNING, "Failure handling a request", e); 
 if ("/".equals(requestURI)) { IServLetResponse.setContentType(response, IServLet.ContentType.TEXT_HTML); resourcePath = "/feed/home.html"; } else { resourcePath = requestURI; } 
 } catch (Exception e) { LOGGER.log(Level.SEVERE, "Failure handling a request", e); 
 private void doPost(IServLetResponse response) throws IOException { IServLetResponse.setContentType(response, IServLet.ContentType.APPLICATION_JSON, IServLet.Encoding.UTF8); 
 static SessionConfig initResponse(IServLetRequest request, IServLetResponse response) throws IOException { IServLetResponse.setContentType(response, IServLet.ContentType.TEXT_PLAIN, IServLet.Encoding.UTF8); 
 } else if ("ADM".equals(output)) { 
 } else if ("ADM".equals(output)) { 
 case CSV: 
<|del|> 
 Thread.sleep(1000L * requestInterval); 
 private static Logger logger = Logger.getLogger(TwitterUtil.class.getName()); 
 private TwitterUtil() { } 
 public static class GeoConstants { private GeoConstants() { } 
 public static final Map<String, double[][]> boundingBoxes = initializeBoundingBoxes(); 
 public static final Map<String, double[][]> boundingBoxes = initializeBoundingBoxes(); 
 String locationValue; 
 String keywords[]; 
 if (logger.isLoggable(Level.WARNING)) { 
 Twitter twitter = tf == null ? null : tf.getInstance(); 
 if (logger.isLoggable(Level.WARNING)) { logger.warning("unable to load authentication credentials from auth.properties file" 
 public static final class AuthenticationConstants { private AuthenticationConstants() { } 
 public static final class SearchAPIConstants { private SearchAPIConstants() { } 
 prepareJoin = AQLPLUS_INNER_JOIN + AQLPLUS; 
 prepareJoin = AQLPLUS_LEFTOUTER_JOIN + AQLPLUS; 
 throw new AlgebricksException("The given condition for the fuzzy join (" + joinOp.getJoinKind() + ") is not valid. Valid root conditions are " + LogicalOperatorTag.INNERJOIN + " or " + LogicalOperatorTag.LEFTOUTERJOIN + "."); 
 public List<String> getRecordReaderNames(); 
 @Override public boolean rewritePost(Mutable<ILogicalOperator> opRef, IOptimizationContext context) 
 if (leftInputPKs.isEmpty() || rightInputPKs.isEmpty()) { 
 boolean storageParallelism = parallelism == CompilerProperties.COMPILER_PARALLELISM_AS_STORAGE; AlgebricksAbsolutePartitionConstraint computationLocations = storageParallelism 
 // Deducts the reserved buffer cache size and memory component size from available memory, // and deducts one core for processing heartbeats. 
 Map<TaskId, List<Pair<TaskId, ConnectorDescriptorId>>> taskConnectivity = new HashMap<>(); 
 cInfoList.add(Pair.of(targetTID, cdId)); 
 boolean tidMatch = task.getTaskId().equals(tid); assert tidMatch; 
 Map<ConnectorDescriptorId, IConnectorPolicy> cPolicyMap = new HashMap<>(); 
 } else { for (int i = 0; i < nProducers; ++i) { c.indicateTargetPartitions(nProducers, nConsumers, i, targetBitmap); fanouts[i] = targetBitmap.cardinality(); 
 Map<ActivityId, ActivityPartitionDetails> activityPartsMap = new HashMap<>(); 
 Map<PartitionId, TaskCluster> getPartitionProducingTaskClusterMap() { 
 if (!tc.getProducedPartitions().isEmpty()) { continue; 
 nodeId = liveNodes.toArray(new String[liveNodes.size()])[Math.abs(random.nextInt()) % liveNodes.size()]; 
 nodeId = liveNodes.toArray(new String[liveNodes.size()])[Math.abs(random.nextInt()) % liveNodes.size()]; 
 final Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies = new HashMap<>( 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
<|del|> 
<|del|> 
 throws HyracksException { 
 appCtx.notifyJobFinish(jobId); 
 appCtx.notifyJobFinish(jobId); 
 throw new HyracksException(e); 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
 public NodesRESTAPIFunction(ClusterControllerService ccs) { 
 public void run() { 
<|del|> 
 nodeId = liveNodes.toArray(new String[liveNodes.size()])[random.nextInt(1) % liveNodes.size()]; 
 assert ta.getStatus() == TaskAttempt.TaskStatus.COMPLETED || ta.getStatus() == TaskAttempt.TaskStatus.RUNNING; 
 assert ta.getStatus() == TaskAttempt.TaskStatus.COMPLETED || ta.getStatus() == TaskAttempt.TaskStatus.RUNNING; 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
 LOGGER.log(Level.SEVERE, e.getMessage(), e); 
 try { IServLetResponse.setContentType(response, IServLet.ContentType.TEXT_HTML, IServLet.Encoding.UTF8); } catch (IOException e) { LOGGER.log(Level.WARNING, "Failure setting content type", e); response.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR); return; } 
 ResultUtil.webUIErrorHandler(out, e); 
import org.apache.hyracks.http.server.AbstractLet; import org.apache.hyracks.http.server.IServLet; import org.apache.hyracks.http.server.IServLetRequest; import org.apache.hyracks.http.server.IServLetResponse; 
 private void doGet(IServLetRequest request, IServLetResponse response) throws IOException { 
 private void doPost(IServLetResponse response) throws IOException { IServLetResponse.setContentType(response, IServLet.ContentType.APPLICATION_JSON, IServLet.Encoding.UTF8); 
 LOGGER.log(Level.SEVERE, "Failure setting response status", e); 
<|del|> 
 servlet = new AQLAPIServlet(new AqlCompilationProvider()); break; 
 List<Mutable<ILogicalExpression>> inputExprs = simFuncExpr.getArguments(); if (inputExprs.size() != 3) { 
 // rightInputPKs in currentPKs extract all the PKs derived from the right branch in the newest fuzzyjoin. 
 previousPKs.add(currentPKs); // Avoid the duplicated PK generation in findPrimaryKeysInSubplan, especially for multiway fuzzy join. 
 if (leftInputPKs.isEmpty() || rightInputPKs.isEmpty()) { 
 // left-hand side and right-hand side of fuzzyjoin has the same type IAType actualLeftType = TypeComputeUtils.getActualType(leftType); IAType actualRightType = TypeComputeUtils.getActualType(rightType); if (!actualLeftType.deepEqual(actualRightType)) { 
 // left-hand side and right-hand side of fuzzyjoin has the same type IAType actualLeftType = TypeComputeUtils.getActualType(leftType); IAType actualRightType = TypeComputeUtils.getActualType(rightType); if (!actualLeftType.deepEqual(actualRightType)) { 
 // left-hand side and right-hand side of fuzzyjoin has the same type IAType actualLeftType = TypeComputeUtils.getActualType(leftType); IAType actualRightType = TypeComputeUtils.getActualType(rightType); if (!actualLeftType.deepEqual(actualRightType)) { 
 // Step2. By default, we triggered the prefix fuzzy join strategy, which needs to initialize the mapping from // the shared token to the actually tuples of both side. left(right)InputPKs is used to extract those mappings 
 for (int i = INNER_STAGE_INDEX; i <= OUTER_STAGE_INDEX; i++) { 
 // Since the generatePrefixFuzzyJoinSubplan generates the prefix-based join operators for the partial simJoin 
<|del|> 
 FeedRuntimeType connectionLocation = null; 
 public <R, T> R accept(ILangVisitor<R, T> visitor, T arg) throws CompilationException { 
 // Deprecated. Don't use this and provide an error code. This exists for the current exceptions and // those exceptions need to adopt error code as well. @Deprecated 
import org.apache.asterix.common.exceptions.CompilationException; 
 VariableSubstitutionEnvironment arg, CloneAndSubstituteVariablesVisitor visitor) throws CompilationException { 
 storageMemorycomponentGlobalBudgetDefault = (int) STORAGE_MEMORYCOMPONENT_GLOBALBUDGET_DEFAULT / (16 * getMemoryComponentPageSize()); 
 private static int storageMemorycomponentGlobalBudgetDefault; 
 for (String depLocation : locations) { addDependencyToLicenseMap(depProject, dep.getValue(), depLocation); 
 defaultLogicalRewrites .add(new Pair<>(seqFirstRuleGateKeeperDfs, RuleCollections.buildFuzzyJoinRuleCollection())); 
 } catch (CompilationException e) { throw new CompilationException(ErrorCode.COMPILATION_REPARSER_ERROR); 
 } catch (CompilationException e) { throw new CompilationException(ErrorCode.COMPILATION_REPARSER_ERROR); 
 // Return an operator that produced the given PK variable. private static ILogicalOperator getOpThatProducesPK(ILogicalOperator rootOp, LogicalVariable pkVar) 
 for (Mutable<ILogicalOperator> opRef : rootOp.getInputs()) { 
 prodOp = getOpThatProducesPK(opRef.getValue(), pkVar); 
 break; 
 for (LogicalVariable pk : pkVars) { ILogicalOperator mOp = getOpThatProducesPK(op, pk); 
 } catch (AsterixException e) { throw new AlgebricksException(e); 
 NodeCapacity getCapacity(); 
 if (caughtException == null) { caughtException = new HyracksException(e); } else { caughtException.addSuppressed(e); } 
 outputVars = new ArrayList<LogicalVariable>(); 
 dataset.indexDataflowHelperFactory(this, theIndex, itemType, metaType, 
 int[] filterFields; int[] rtreeFields; 
 int[] filterFields; int[] rtreeFields; 
 dataset.indexDataflowHelperFactory(this, primaryIndex, itemType, metaType, compactionInfo.first, compactionInfo.second), getStorageComponentProvider().metadataPageManagerFactory()); 
 primaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), IndexOperation.UPSERT, ResourceType.LSM_BTREE) : new UpsertOperationCallbackFactory(jobId, datasetId, primaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), 
 primaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), IndexOperation.UPSERT, ResourceType.LSM_BTREE) : new UpsertOperationCallbackFactory(jobId, datasetId, primaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), 
 getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE, dataset.hasMetaPart()); 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE, dataset.hasMetaPart()); 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, 
 IIndexDataflowHelperFactory indexDataFlowFactory = dataset.indexDataflowHelperFactory(this, secondaryIndex, recType, metaItemType, compactionInfo.first, compactionInfo.second); 
 List<Mutable<ILogicalExpression>> conjs2 = new ArrayList<>(); 
 @Override public boolean rewritePost(Mutable<ILogicalOperator> opRef, IOptimizationContext context) 
 // current opperator is join 
<|del|> 
 // Bail if primary keys could not be inferred. if (leftInputPKs == null || rightInputPKs == null) { 
 // Bail if primary keys could not be inferred. if (leftInputPKs == null || rightInputPKs == null) { 
 // Bail if primary keys could not be inferred. if (leftInputPKs == null || rightInputPKs == null) { 
 // left-hand side and right-hand side of "~=" has the same type IAType left2 = TypeHelper.getNonOptionalType(leftType); IAType right2 = TypeHelper.getNonOptionalType(rightType); if (!left2.deepEqual(right2)) { 
 if (funcExpr.getFunctionIdentifier().equals(AsterixBuiltinFunctions.GET_ITEM)) { 
<|del|> 
 public void setMetaType(ARecordType metaType) { // do nothing 
 if (curRecType != null && curFNames!=null && closedFieldCount < curFNames.length) { 
 public void setController(AbstractFeedDataFlowController controller) { // do nothing 
 public static AlgebricksException create(int errorCode, Serializable... params) { return new AlgebricksException(ErrorCode.HYRACKS, errorCode, ErrorCode.getErrorMessage(errorCode), params); 
<|del|> 
<|del|> 
<|del|> 
 if (rules.isEmpty()) { return false; 
 if (propertyStream != null) { 
 } else { 
 } else { 
 resultDelivery.name() + " job " + "with id " + jobId + " failed", e); 
 Assert.assertNotNull("no handle for " + reqType + " test " + testFile.toString(), resultStream); 
 Assert.assertNotNull("no handle for " + reqType + " test " + testFile.toString(), handleVar); variableCtx.put(handleVar, handle); 
 if (LOGGER.isLoggable(Level.INFO)) { LOGGER.log(Level.INFO, ctx.getTaskAttemptId() + " sleeping for " + time + " ms"); } 
 if (LOGGER.isLoggable(Level.INFO)) { LOGGER.log(Level.INFO, ctx.getTaskAttemptId() + " done sleeping for " + time + " ms"); } 
 } //TODO(tillw) throwing a HyracksDataException here hangs the execution tests 
 throw HyracksDataException.create(ErrorCode.MORE_THAN_ONE_RESULT, jobId); 
 logger.log(Level.SEVERE, "Result cleaner thread interrupted, shutting down.", e); 
 SequentialOnceRuleController seqOnceCtrl = new SequentialOnceRuleController(true); SequentialFirstRuleCheckFixpointRuleController seqFirstRuleGateKeeperDfs = new SequentialFirstRuleCheckFixpointRuleController( true); 
 @Override public boolean rewritePost(Mutable<ILogicalOperator> opRef, IOptimizationContext context) 
 // Steps 1 and 2. Generate the prefix-based fuzzy jon template. 
 extraSelect = new SelectOperator(exprRef, false, null); extraSelect.setSourceLocation(exprRef.getValue().getSourceLocation()); 
 extraSelect = new SelectOperator(exprRef, false, null); extraSelect.setSourceLocation(exprRef.getValue().getSourceLocation()); 
 } catch (AsterixException e) { throw new AlgebricksException(e); 
 if (caughtException == null) { caughtException = new HyracksException(e); } else { caughtException.addSuppressed(e); } 
 // Iteration2: R1 false, R2 true, R3 false 
 // So, the iteration should be stopped after the iteration 3. 
 synchronized (ctx) { hds = (IHyracksDataset) ctx.get(HYRACKS_DATASET_ATTR); 
 synchronized (ctx) { hcc = (IHyracksClientConnection) ctx.get(HYRACKS_CONNECTION_ATTR); hds = (IHyracksDataset) ctx.get(HYRACKS_DATASET_ATTR); 
<|del|> 
<|del|> 
 SequentialFirstRuleCheckFixpointRuleController seqFirstRuleGateKeeperDfs = new SequentialFirstRuleCheckFixpointRuleController(true); 
 // Step1: Initialize the host embedding aql to substitute the fuzzy equal condition such as $r.a ~= $s.b 
 leftInputVarCopy = copyVisitor.varCopy(leftInputPKs.get(i)); 
 return new ObjectMapper().writeValueAsString(this); 
 return new ObjectMapper().readValue(json, Checkpoint.class); 
 translator.addVariableToMetaScope(new VarIdentifier("$$LEFT_1"), leftInputVarCopy); 
 List<ExternalFile> addedFiles, List<ExternalFile> appendedFiles, MetadataProvider metadataProvider) throws AlgebricksException { 
 List<ExternalFile> addedFiles, List<ExternalFile> appendedFiles, MetadataProvider metadataProvider) throws AlgebricksException { 
 public static JobSpecification buildCommitJob(Dataset ds, List<Index> indexes, MetadataProvider metadataProvider) throws AlgebricksException { 
 public static JobSpecification buildCommitJob(Dataset ds, List<Index> indexes, MetadataProvider metadataProvider) throws AlgebricksException { 
 if (TransactionUtils.PROFILE_MODE) { 
 public TransactionContext(JobId jobId, TransactionSubsystem transactionSubsystem) throws ACIDException { 
 IStorageComponentProvider storageComponentProvider) { this(hcc, queryText, // This is a commandline client and so System.out is appropriate new PrintWriter(System.out, true),// NOSONAR compilationProvider, statementExecutorFactory, storageComponentProvider); 
<|del|> 
<|del|> 
<|del|> 
 if (!openIndexList.isEmpty()) { 
 LOGGER.info(Thread.currentThread().getId() + "======> entity_commit[" + currentLSN + "]" + tempKeyTxnId); 
 // entity commit log must come after the update log, // therefore, consider only partitions with max LSN > logLSN 
<|del|> 
<|del|> 
 this.reportIntervalInMillisec = reportIntervalInSeconds * 1000L; 
 context.addServlet(new ServletHolder(new APIServlet( new AqlCompilationProvider(), new SqlppCompilationProvider(), new DefaultStatementExecutorFactory(), new StorageComponentProvider())), "/*"); 
 public static final List<List<String>> RECORD_ID_FIELDS; 
 FilesIndexDescription.FILES_INDEX_COMP_FACTORIES, FilesIndexDescription.BLOOM_FILTER_FIELDS, 
 IRuntimeComponentProvider storageManager, IFileSplitProvider fileSplitProvider, ISearchOperationCallbackFactory searchOpCallbackFactory, 
 void initializeMetadata(INCApplicationContext appCtx, IStorageComponentProvider storageManager) throws HyracksDataException, RemoteException, ACIDException; 
 Resource localResourceMetadata = new LSMBTreeLocalResourceMetadata(typeTraits, 
public class IndexHelper { 
 public static int[] getBtreeFieldsIfFiltered(Dataset dataset, Index index) 
 public static int[] getBtreeFieldsIfFiltered(Dataset dataset, Index index) 
 int[] filterFields; int[] rtreeFields; 
 int[] filterFields; int[] rtreeFields; 
 primaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), IndexOperation.UPSERT, ResourceType.LSM_BTREE) : new UpsertOperationCallbackFactory(jobId, datasetId, primaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), 
 primaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), IndexOperation.UPSERT, ResourceType.LSM_BTREE) : new UpsertOperationCallbackFactory(jobId, datasetId, primaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), 
 getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE, dataset.hasMetaPart()); 
 itemType = (ARecordType) MetadataManager.INSTANCE.getDatatype( mdTxnCtx, dataset.getItemTypeDataverseName(), itemTypeName).getDatatype(); 
 ARecordType metaType = dataset.hasMetaPart() ? (ARecordType) MetadataManager.INSTANCE.getDatatype( mdTxnCtx, dataset.getMetaItemTypeDataverseName(), dataset.getMetaItemTypeName()) 
 ARecordType metaType = dataset.hasMetaPart() ? (ARecordType) MetadataManager.INSTANCE.getDatatype( mdTxnCtx, dataset.getMetaItemTypeDataverseName(), dataset.getMetaItemTypeName()) 
 ARecordType metaType = dataset.hasMetaPart() ? (ARecordType) MetadataManager.INSTANCE.getDatatype( mdTxnCtx, dataset.getMetaItemTypeDataverseName(), dataset.getMetaItemTypeName()) 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE) 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE, dataset.hasMetaPart()); 
 int[] filterFields; int[] rtreeFields; 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), 
 int[] filterFields; int[] invertedIndexFields; int[] filterFieldsForNonBulkLoadOps; int[] invertedIndexFieldsForNonBulkLoadOps; 
 int[] filterFields; int[] invertedIndexFields; int[] filterFieldsForNonBulkLoadOps; int[] invertedIndexFieldsForNonBulkLoadOps; 
 int[] filterFields; int[] invertedIndexFields; int[] filterFieldsForNonBulkLoadOps; int[] invertedIndexFieldsForNonBulkLoadOps; 
 int[] filterFields; int[] invertedIndexFields; int[] filterFieldsForNonBulkLoadOps; int[] invertedIndexFieldsForNonBulkLoadOps; 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, 
 private static final BTreeDataflowHelperFactoryProvider bTreeDataflowHelperFactoryProvider = BTreeDataflowHelperFactoryProvider.INSTANCE; private static final RTreeDataflowHelperFactoryProvider rTreeDataflowHelperFactoryProvider = RTreeDataflowHelperFactoryProvider.INSTANCE; private static final InvertedIndexDataflowHelperFactoryProvider invertedIndexDataflowHelperFactoryProvider = InvertedIndexDataflowHelperFactoryProvider.INSTANCE; 
 private static final BTreeDataflowHelperFactoryProvider bTreeDataflowHelperFactoryProvider = BTreeDataflowHelperFactoryProvider.INSTANCE; private static final RTreeDataflowHelperFactoryProvider rTreeDataflowHelperFactoryProvider = RTreeDataflowHelperFactoryProvider.INSTANCE; private static final InvertedIndexDataflowHelperFactoryProvider invertedIndexDataflowHelperFactoryProvider = InvertedIndexDataflowHelperFactoryProvider.INSTANCE; 
 private static final BTreeDataflowHelperFactoryProvider bTreeDataflowHelperFactoryProvider = BTreeDataflowHelperFactoryProvider.INSTANCE; private static final RTreeDataflowHelperFactoryProvider rTreeDataflowHelperFactoryProvider = RTreeDataflowHelperFactoryProvider.INSTANCE; private static final InvertedIndexDataflowHelperFactoryProvider invertedIndexDataflowHelperFactoryProvider = InvertedIndexDataflowHelperFactoryProvider.INSTANCE; 
public class FeedOperations { private FeedOperations() { } 
 IAdapterFactory adapterFactory; 
 public static Pair<JobSpecification, Boolean> buildDisconnectFeedJobSpec( FeedConnectionId connectionId) throws AlgebricksException { 
 public static JobSpecification buildRemoveFeedStorageJob(Feed feed) throws AsterixException { 
 private ExternalIndexingOperations() { } 
 private ExternalIndexingOperations() { } 
 ExternalDatasetDetails dsd = (ExternalDatasetDetails) dataset.getDatasetDetails(); 
 ExternalDatasetDetails dsd = (ExternalDatasetDetails) dataset.getDatasetDetails(); 
 public static List<ExternalFile> getSnapshotFromExternalFileSystem(Dataset dataset) 
 if (files.isEmpty()) { 
 LOGGER.log(Level.WARNING, "Exception while trying to get snapshot from external system", e); 
 return getExternalDataIndexingOperator(metadataProvider, spec, itemType, dataset, files == null ? MetadataManager.INSTANCE.getDatasetExternalFiles(metadataProvider.getMetadataTxnContext(), dataset) : files, indexerDesc); 
 MetadataProvider metadataProvider, IStorageComponentProvider storageManager) throws AlgebricksException { 
 public static JobSpecification buildAbortOp(Dataset ds, List<Index> indexes, MetadataProvider metadataProvider) 
 public static JobSpecification buildAbortOp(Dataset ds, List<Index> indexes, MetadataProvider metadataProvider) 
 public static JobSpecification buildRecoverOp(Dataset ds, List<Index> indexes, MetadataProvider metadataProvider) 
 public static JobSpecification buildRecoverOp(Dataset ds, List<Index> indexes, MetadataProvider metadataProvider) 
 primaryComparatorFactories[i] = storageComponentProvider.comparatorFactoryProvider() .getBinaryComparatorFactory(keyType, true); 
 IBinaryComparatorFactory[] secondaryComparatorFactories = new IBinaryComparatorFactory[numNestedSecondaryKeyFields]; IPrimitiveValueProviderFactory[] valueProviderFactories = new IPrimitiveValueProviderFactory[numNestedSecondaryKeyFields]; 
 IBinaryComparatorFactory[] secondaryComparatorFactories = new IBinaryComparatorFactory[numNestedSecondaryKeyFields]; IPrimitiveValueProviderFactory[] valueProviderFactories = new IPrimitiveValueProviderFactory[numNestedSecondaryKeyFields]; 
 * In case of external data, * this method is used to build loading jobs for both initial load on index creation 
 case BTREE: 
 case RTREE: 
 case LENGTH_PARTITIONED_NGRAM_INVIX: 
<|del|> 
 protected AlgebricksMetaOperatorDescriptor createAssignOp(JobSpecification spec, int numSecondaryKeyFields, RecordDescriptor secondaryRecDesc) 
 projectionList[projCount] = numPrimaryKeys + numSecondaryKeyFields; 
 IScalarEvaluatorFactory selectCond; 
 dataflowHelperFactory, dataset.modificationCallbackFactory( storageComponentProvider, index, null, IndexOperation.FULL_MERGE, null), storageComponentProvider.metadataPageManagerFactory()); 
 + " fields as a key for the R-tree index. " + "There can be only one field as a key for the R-tree index."); 
 * Instead of storing a MBR(4 doubles) for a point(2 doubles) in RTree leaf node, * PointMBR concept is introduced. 
 * many doubles as it actually requires. For this purpose, * PointMBR specific optimization logic is added as follows: 
 * 3) Bulk-loading in RTree takes 4 doubles by reading 2 doubles twice and then, * do the same work as non-point MBR cases. 
 * In case of external data, this method is used to build loading jobs for both * initial load on index creation 
 if (TransactionUtils.PROFILE_MODE) { 
 return LSMBTreeUtils.createExternalBTreeWithBuddy(ctx.getIOManager(), fileRef, opDesc.getRuntimeComponentProvider().getBufferCache(ctx), 
 return LSMBTreeUtils.createLSMTree(ctx.getIOManager(), virtualBufferCaches, fileRef, opDesc.getRuntimeComponentProvider().getBufferCache(ctx), 
 // Checks if the GET_ITEM function is on the one of the supported similarity-check functions. 
 // leftInputPKs in currrentPKs keeps all PKs derived from the left branch in the current similarity fuzzyjoin. 
 // rightInputPKs in currentPKs keeps all PKs derived from the right branch in the current similarity fuzzyjoin. 
 // Steps 1 and 2. Generate the prefix-based fuzzy jon template. 
 // Steps 3 and 4. Generate the prefix-based fuzzy join subplan. 
 spec.setRequiredComputationCapacity(ResourceUtils.getRequiredCompacity(plan, computationLocations, sortFrameLimit, groupFrameLimit, joinFrameLimit, frameSize)); 
 public NodeCapacity getCapacity() { 
 NodeCapacity getCapacity(); 
 public static final int JOB_REQUIREMENTS_EXCEED_CAPACITY = 9; public static final int NO_SUCH_NODE = 10; public static final int CLASS_LOADING_ISSUE = 11; 
 public static final int JOB_REQUIREMENTS_EXCEED_CAPACITY = 9; public static final int NO_SUCH_NODE = 10; public static final int CLASS_LOADING_ISSUE = 11; 
 private IClusterCapacity requiredComputationCapacity; 
 private NodeCapacity capacity; 
 capacity = reg.getCapacity(); 
 public NodeCapacity getCapacity() { return capacity; 
<|del|> 
 return Collections.unmodifiableMap(ipAddressNodeNameMap); 
 public Collection<String> getAllNodeIds() { return Collections.unmodifiableSet(nodeRegistry.keySet()); 
 public Collection<NodeControllerState> getAllNodeControllerStates() { return Collections.unmodifiableCollection(nodeRegistry.values()); 
 private final JobExecutor executor; 
 ActivityClusterPlanner(JobExecutor newJobExecutor) { this.executor = newJobExecutor; 
<|del|> 
 Collection<JobRun> getRunningJobs(); 
 throw HyracksException.create(ErrorCode.CLASS_LOADING_ISSUE, e, e.getMessage()); 
 IReadOnlyClusterCapacity getMaximumCapacity(); 
 IClusterCapacity getCurrentCapacity(); 
 // The current resource, which is dynamically changing. private IClusterCapacity currentResource = new ClusterCapacity(); 
 public IReadOnlyClusterCapacity getMaximumCapacity() { 
 public IReadOnlyClusterCapacity getMaximumCapacity() { 
 public IClusterCapacity getCurrentCapacity() { 
 public NodeCapacity getCapacity() { return new NodeCapacity(Runtime.getRuntime().maxMemory(), Runtime.getRuntime().availableProcessors() - 1); 
 throw new CompilationException(ErrorCode.COMPILATION_FIELD_NOT_FOUND, ARecordType.toFieldNameString( filterField)); 
 throw new CompilationException(ErrorCode.COMPILATION_FILTER_CANNOT_BE_NULLABLE, ARecordType.toFieldNameString(filterField)); 
<|del|> 
<|del|> 
 public static List<IAType> validatePartitioningExpressions(ARecordType recType, 
 .getDatatype() : null; 
 .getDatatype() : null; 
 IActivityClusterGraphGeneratorFactory acggf, IActivityClusterGraphGenerator acgg, Set<JobFlag> jobFlags, IResultCallback<JobId> callback) { this(deploymentId, jobId, jobFlags, callback); this.acggf = acggf; 
 return Collections.emptyList(); 
 this.tempDir = new File(tmpDir, "repo" + random.nextInt()); 
 public void setUrl(String s) { // unused 
 public void setSnapshotUpdatePolicy(ArtifactRepositoryPolicy artifactRepositoryPolicy) { // unused 
 public void setReleaseUpdatePolicy(ArtifactRepositoryPolicy artifactRepositoryPolicy) { // unused 
 public void setLayout(ArtifactRepositoryLayout artifactRepositoryLayout) { // unused 
 public void setBlacklisted(boolean b) { // unused 
 public void setAuthentication(Authentication authentication) { // unused 
 public void setProxy(Proxy proxy) { // unused 
 private static final String FIRST_NAMES_FILE = "dist.all.first.cleaned"; private static final String LAST_NAMES_FILE = "dist.all.last.cleaned"; 
 FeedRuntimeType connectionLocation = null; 
 if (exceptions != null && !exceptions.isEmpty()) { 
 public ApiServlet(ConcurrentMap<String, Object> ctx, String[] paths, ILangCompilationProvider aqlCompilationProvider, ILangCompilationProvider sqlppCompilationProvider, IStatementExecutorFactory statementExecutorFactory) { 
 public DdlApiServlet(ConcurrentMap<String, Object> ctx, String[] paths, ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory) { 
 public FullApiServlet(ConcurrentMap<String, Object> ctx, String[] paths, ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory) { 
 public QueryApiServlet(ConcurrentMap<String, Object> ctx, String[] paths, ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory) { 
 public RestApiServlet(ConcurrentMap<String, Object> ctx, String[] paths, ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory) { 
 public UpdateApiServlet(ConcurrentMap<String, Object> ctx, String[] paths, ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory) { 
 private static final List<String> recordReaderNames = Collections.unmodifiableList(Arrays.asList("hdfs")); 
 public List<String> getRecordReaderNames() { 
 private static final List<String> recordReaderNames = Collections.unmodifiableList(Arrays.asList( ExternalDataConstants.ALIAS_LOCALFS_ADAPTER, ExternalDataConstants.ALIAS_SOCKET_ADAPTER, ExternalDataConstants.SOCKET, 
 public static List<IAType> validatePartitioningExpressions(ARecordType recType, ARecordType metaRecType, 
 List<List<String>> keyFieldNames, List<Integer> keySourceIndicators, List<IAType> keyFieldTypes, IndexType indexType) throws AlgebricksException { List<IAType> fieldTypes = KeyFieldTypeUtils.getKeyTypes(recType, metaRecType, keyFieldNames, keySourceIndicators); 
 * 
 private static Pair<ExternalScanOperatorDescriptor, AlgebricksPartitionConstraint> getIndexingOperator( 
 this.retainMissing = retainMissing; 
 IIndexDataflowHelperFactory dataflowHelperFactory = dataset.getIndexDataflowHelperFactory(metadataProvider, 
 dataset.getSearchCallbackFactory(metadataProvider.getComponentProvider(), secondaryIndex, 
 Mutable<ILogicalExpression> keyVarRef = new MutableObject<>(new VariableReferenceExpression(keyVar)); 
import org.apache.asterix.dataflow.data.common.AqlExpressionTypeComputer; import org.apache.asterix.dataflow.data.common.AqlMergeAggregationExpressionFactory; import org.apache.asterix.dataflow.data.common.AqlMissableTypeComputer; import org.apache.asterix.dataflow.data.common.AqlPartialAggregationTypeComputer; 
 new PrintWriter(System.out, true), // NOSONAR compilationProvider, statementExecutorFactory, storageComponentProvider); 
 asterixAppRuntimeContextProvider, txnProperties); 
 public Set<IClusterManagementWork> notifyNodeFailure(Collection<String> deadNodeIds) { setState(ClusterStateManager.INSTANCE.getState()); ClusterStateManager.INSTANCE.setGlobalRecoveryCompleted(false); 
 IPageManagerFactory pageManagerFactory) { 
 ISearchOperationCallbackFactory searchOpCallbackProvider, IPageManagerFactory pageManagerFactory) { 
 ILogManager getLogManager(); 
 ILockManager getLockManager(); 
 public abstract ILSMIndex createIndexInstance(INCApplicationContext appCtx, LocalResource resource) throws HyracksDataException; 
 IPageManagerFactory pageManagerFactory) { 
 IIndexDataflowHelperFactory filesIndexDataflowHelperFactory, IndexInfoOperatorDescriptor fileIndexesInfo, List<IIndexDataflowHelperFactory> indexesDataflowHelperFactories, List<IndexInfoOperatorDescriptor> indexesInfos) { super(spec, filesIndexDataflowHelperFactory, fileIndexesInfo, indexesDataflowHelperFactories, indexesInfos); 
 IIndexDataflowHelperFactory filesIndexDataflowHelperFactory, IndexInfoOperatorDescriptor fileIndexesInfo, List<IIndexDataflowHelperFactory> indexesDataflowHelperFactories, List<IndexInfoOperatorDescriptor> indexesInfos) { super(spec, filesIndexDataflowHelperFactory, fileIndexesInfo, indexesDataflowHelperFactories, indexesInfos); 
 new FilesIndexDescription().FILES_INDEX_COMP_FACTORIES, FilesIndexDescription.BLOOM_FILTER_FIELDS, externalFilesIndexDataFlowHelperFactory, null, propagateInput, retainMissing, missingWriterFactory, null, searchOpCallbackFactory, null); 
 IPageManagerFactory pageManagerFactory) { 
 * 
 public ILSMIOOperationCallbackFactory getIoOperationCallbackFactory(Index index) throws AlgebricksException { 
 public ILSMOperationTrackerFactory getIndexOperationTrackerFactory(Index index) throws AlgebricksException { return index.isPrimaryIndex() ? new PrimaryIndexOperationTrackerFactory(getDatasetId()) : new SecondaryIndexOperationTrackerFactory(getDatasetId()); 
 ArtifactResolutionRequest request) throws ProjectBuildingException, IOException { 
 throw CompilationException.create(ErrorCode.COMPILATION_TRANSLATION_ERROR, e); 
 ioManager = ncApplicationContext.getIoManager(); 
 lsmBtree = LSMBTreeUtils.createLSMTree(ioManager, virtualBufferCaches, file, bufferCache, fileMapProvider, typeTraits, 
 throw new CompilationException(ErrorCode.COMPILATION_CANT_DROP_ACTIVE_DATASET, ARecordType.toFullyQualifiedName(dataverseName, datasetName), listener.getEntityId().toString()); 
 return ((InternalDatasetDetails) dataset.getDatasetDetails()).getFilterField(); 
 IIndexDataflowHelperFactory dataflowHelperFactory = dataset.getIndexDataflowHelperFactory(metadataProvider, index, itemType, metaType, mergePolicyFactory, mergePolicyFactoryProperties); 
 IIndexDataflowHelperFactory dataflowHelperFactory = dataset.getIndexDataflowHelperFactory(metadataProvider, index, itemType, metaType, mergePolicyFactory, mergePolicyFactoryProperties); 
 resultDelivery.name() + " job " + "with id " + jobId + " failed", e); 
 * 
 * 
 ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory, IComponentProvider componentProvider) { 
 ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory, IComponentProvider componentProvider) { 
 ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory, IComponentProvider componentProvider) { 
 ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory, IComponentProvider componentProvider) { 
 return datasetName + DATASET_INDEX_NAME_SEPARATOR + idxName; 
 IIndexDataflowHelperFactory indexDataFlowFactory = dataset.getIndexDataflowHelperFactory(this, secondaryIndex, recType, metaItemType, compactionInfo.first, compactionInfo.second); 
 ServletUtils.setContentType(response, IServlet.ContentType.TEXT_PLAIN, IServlet.Encoding.UTF8); 
 String accept = request.getHeader("Accept", ""); 
 boolean wrapperArray = format == OutputFormat.CLEAN_JSON || format == OutputFormat.LOSSLESS_JSON; 
 ServletUtils.setContentType(response, "application/json"); 
 if (!buffer.isWritable()) { 
<|del|> 
 public void notifyChannelWritable() { 
 executor = Executors.newFixedThreadPool(16, runnable -> new Thread(runnable, "HttpExecutor(port:" + port + ")-" + threadId.getAndIncrement())); 
 FullHttpRequest request = (FullHttpRequest) msg; IServlet servlet = server.getServlet(request); 
 private ConfigGenerator() { } 
 System.err.println("The usage of ConfigGenerator: "); System.err.println("<input node json file> <output inventory file> <output config file>"); 
 if (cluster.isEmpty()) { 
 jsonResponse.put("status", resultReader.getStatus().name()); 
 getStatementExecutorFactory(), componentProvider); 
 getOrCreateDirectoryRecord(rsId, partition).fail(); 
 public DatasetDirectoryRecord getOrCreateDirectoryRecord(ResultSetId rsId, int partition) { 
 public synchronized Set<JobId> getJobIds() { 
 public synchronized IDatasetStateRecord getState(JobId jobId) { 
 public synchronized void deinitState(JobId jobId) { 
 private synchronized void deinit(JobId jobId) { 
<|del|> 
<|del|> 
<|del|> 
 winnerJobSet.add(logRecord.getJobId()); cleanupJobCommits(logRecord.getJobId()); 
 while (true) { 
 MetadataProvider metadataProvider = new MetadataProvider(null, new StorageComponentProvider()); 
 protected static IStorageComponentProvider storageComponentProvider = new StorageComponentProvider(); 
 IStorageComponentProvider getStorageComponentProvider(); 
 public IStorageManager getStorageManager(); 
 IStorageManager storageManager, IFileSplitProvider fileSplitProvider, 
 * A transaction subsystem is responsible of maintaining Atomicity, Consistency, Isolation, and Durability * on a record level. 
 public IStorageManager getStorageManager() { 
 private final IStorageComponentProvider storaegComponentProvider; 
 getSplitProviderAndConstraints(dataSource.getId().getDataverseName(), datasetName, indexName, temp); 
 getSplitProviderAndConstraints(dataverseName, datasetName, indexName, dataset.getDatasetDetails().isTemp()); 
 public IStorageComponentProvider getStorageComponentProvider() { return storaegComponentProvider; 
 modificationOpCallbackFactory, indexName, pageManagerFactory); 
 IStorageManager storageManager = StorageManager.INSTANCE; 
 protected final IStorageManager storageManager = new TestStorageManager(); 
 IBufferCache bufferCache = opDesc.getStorageManager().getBufferCache(ctx); return BTreeUtils.createBTree(bufferCache, opDesc.getStorageManager() 
 protected final IStorageManager storageManager; 
 this.storageManager = storageManager; 
 RecordDescriptor recDesc, IStorageManager storageManager, 
 IStorageManager getStorageManager(); 
 IStorageManager storageManager, IIndexLifecycleManagerProvider lifecycleManagerProvider, 
 return RTreeUtils.createRTree(treeOpDesc.getStorageManager().getBufferCache(ctx), treeOpDesc.getStorageManager().getFileMapProvider(ctx), treeOpDesc.getTreeIndexTypeTraits(), 
 return RTreeUtils.createRTree(treeOpDesc.getStorageManager().getBufferCache(ctx), treeOpDesc.getStorageManager().getFileMapProvider(ctx), treeOpDesc.getTreeIndexTypeTraits(), 
 * @return the disk buffer cache {@link org.apache.hyracks.storage.common.buffercache.IBufferCache} 
 * @return the local resource repository {@link org.apache.hyracks.storage.common.file.ILocalResourceRepository} 
 * @return the resource id factory {@link org.apache.hyracks.storage.common.file.IResourceIdFactory} 
 protected static IStorageComponentProvider storageComponentProvider = new StorageComponentProvider(); 
 this.retainMissing = retainMissing; 
 List<List<String>> keyFieldNames, List<Integer> keySourceIndicators, List<IAType> keyFieldTypes, IndexType indexType) throws AlgebricksException { List<IAType> fieldTypes = KeyFieldTypeUtils.getKeyTypes(recType, metaRecType, keyFieldNames, keySourceIndicators); 
 new PrintWriter(System.out, true), // NOSONAR compilationProvider, statementExecutorFactory, storageComponentProvider); 
 * Create the index dataflow helper factory * 
 public IIndexDataflowHelperFactory indexDataflowHelperFactory(MetadataProvider mdProvider, Index index, ARecordType recordType, ARecordType metaType, ILSMMergePolicyFactory mergePolicyFactory, Map<String, String> mergePolicyProperties) throws AlgebricksException { 
 public ILSMIOOperationCallbackFactory ioOperationCallbackFactory(Index index) throws AlgebricksException { 
 public ILSMIOOperationCallbackFactory ioOperationCallbackFactory(Index index) throws AlgebricksException { 
 public ILSMOperationTrackerProvider indexOperationTrackerProvider(Index index) throws AlgebricksException { 
 Index index, JobId jobId, IndexOperation op, int[] primaryKeyFields) throws AlgebricksException { 
 IStorageComponentProvider componentProvider, Index index, JobId jobId, IndexOperation op, int[] primaryKeyFields) throws AlgebricksException { 
import org.apache.asterix.common.utils.TransactionUtil; 
 metadataProvider.getStorageComponentProvider().getMetadataPageManagerFactory(), isFullTextSearchQuery); 
 IStatementExecutor translator = statementExecutorFactory.create(aqlStatements, sessionConfig, compilationProvider, componentProvider); 
 * @return an instance which implements {@link org.apache.hyracks.storage.common.IStorageManager} 
 throw new HyracksDataException(e); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> indexSplitsAndConstraint = metadataProvider.getSplitProviderAndConstraints(ds.getDataverseName(), ds.getDatasetName(), index.getIndexName(), temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> indexSplitsAndConstraint = metadataProvider.getSplitProviderAndConstraints(ds.getDataverseName(), ds.getDatasetName(), index.getIndexName(), temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> indexSplitsAndConstraint = metadataProvider.getSplitProviderAndConstraints(ds.getDataverseName(), ds.getDatasetName(), index.getIndexName(), temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = metadataProvider.getSplitProviderAndConstraints(index.getDataverseName(), index.getDatasetName(), index.getIndexName(), temp); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = metadataProvider.getSplitProviderAndConstraints(index.getDataverseName(), index.getDatasetName(), index.getIndexName(), temp); 
 valueProviderFactories[i] = metadataProvider.getStorageComponentProvider().getPrimitiveValueProviderFactory(); 
 public ILSMIndex createIndexInstance(INCApplicationContext appCtx, LocalResource resource) throws HyracksDataException { 
 public ILSMIndex createIndexInstance(INCApplicationContext appCtx, LocalResource resource) throws HyracksDataException { 
 if (TransactionUtil.PROFILE_MODE) { 
public class LSMBTreeUtil { private LSMBTreeUtil() { } 
 throw new IOException("Unknown format " + format); 
 } catch (Exception e) { LOGGER.log(Level.WARNING, "Failure during handling of an IServletRequest", e); 
 } catch (Exception e) { LOGGER.log(Level.WARNING, "Failure during handling of an IServletRequest", e); 
 public void before(ByteBuffer buffer) { 
 ComponentMetadataUtils.MARKER_LSN_KEY, NOT_FOUND); if (lsn == NOT_FOUND) { 
 private void exitComponents(ILSMIndexOperationContext ctx, LSMOperationType opType, ILSMDiskComponent newComponent, 
 List<IDiskComponent> immutableComponents = new ArrayList<>(index.getImmutableComponents()); 
 for (IDiskComponent c : immutableComponents) { 
 List<IDiskComponent> mergableComponents = new ArrayList<>(); 
 LongPointable pointable = new LongPointable(); IMetadataPageManager metadataPageManager = (IMetadataPageManager) treeIndex.getPageManager(); metadataPageManager.get(metadataPageManager.createMetadataFrame(), LSN_KEY, pointable); return pointable.getLength() == 0 ? INVALID : pointable.longValue(); 
 public void afterOperation(LSMOperationType opType, List<ILSMComponent> oldComponents, IDiskComponent newComponent) throws HyracksDataException { 
 public void afterOperation(LSMOperationType opType, List<ILSMComponent> oldComponents, IDiskComponent newComponent) throws HyracksDataException { 
 public void afterOperation(LSMOperationType opType, List<ILSMComponent> oldComponents, IDiskComponent newComponent) throws HyracksDataException { 
 public void before(ByteBuffer buffer) { 
 ComponentMetadataUtils.MARKER_LSN_KEY, NOT_FOUND); if (lsn == NOT_FOUND) { 
 ComponentMetadataUtils.MARKER_LSN_KEY, NOT_FOUND); if (lsn == NOT_FOUND) { 
 List<IDiskComponent> diskComponents = index.getImmutableComponents(); for (IDiskComponent c : diskComponents) { 
 List<IMemoryComponent> memComponents = index.getMemoryComponents(); 
 public void after(long lsn) { 
 return Objects.equals(first, p.first) && Objects.equals(second, p.second); 
 return Objects.hash(first, second); 
 return prime + data.hashCode(); 
 if (!(obj instanceof ArrayBackedValueStorage)) { 
<|del|> 
 private final List<ILSMDiskComponent> secondDiskComponents; 
 public List<ILSMDiskComponent> getFirstComponentList() { 
 AbstractLSMMemoryComponent mutableComponent = (AbstractLSMMemoryComponent) c; 
 super((IMetadataPageManager) invIndex.getMainIndex().getPageManager(), filter); 
 public int getFileReferenceCount() { 
 for (AbstractDiskComponent c : immutableComponents) { 
 public long getComponentLSN(List<ILSMComponent> diskComponents) throws HyracksDataException { 
 ComponentMetadataUtils.MARKER_LSN_KEY, NOT_FOUND); if (lsn == NOT_FOUND) { 
 private void exitComponents(ILSMIndexOperationContext ctx, LSMOperationType opType, IDiskComponent newComponent, boolean failedOperation) throws HyracksDataException, IndexException { 
 file.setLastModefiedTime(new Date(((ADateTime) externalFileRecord .getValueByPos(FilesIndexDescription.EXTERNAL_FILE_MOD_DATE_FIELD_INDEX)).getChrononTime())); 
 * Copying content of metadata page from memory component to disk component should be done in this call * Merging content of metadata pages from disk components to new disk component should be done in this call 
 ILSMDiskComponentFactory componentFactory, IFileMapProvider diskFileMapProvider, 
<|del|> 
 super((IMetadataPageManager) invIndex.getPageManager(), filter); 
<|del|> 
 public void afterOperation(LSMOperationType opType, List<ILSMComponent> oldComponents, ILSMDiskComponent newComponent) throws HyracksDataException { 
 public void afterOperation(LSMOperationType opType, List<ILSMComponent> oldComponents, ILSMDiskComponent newComponent) throws HyracksDataException { 
 public void afterOperation(LSMOperationType opType, List<ILSMComponent> oldComponents, ILSMDiskComponent newComponent) throws HyracksDataException { 
<|del|> 
 // A failed operation should not change the component state since it's better for // the failed operation's effect to be no-op. 
 public void afterOperation(LSMOperationType opType, List<ILSMComponent> oldComponents, ILSMDiskComponent newComponent) throws HyracksDataException { 
 LongPointable markerLsn = LongPointable.FACTORY .createPointable(ComponentMetadataUtil.getLong(oldComponents.get(0).getMetadata(), ComponentMetadataUtil.MARKER_LSN_KEY, ComponentMetadataUtil.NOT_FOUND)); 
 return ComponentMetadataUtil.NOT_FOUND; 
 LongPointable markerLsn = LongPointable.FACTORY .createPointable(ComponentMetadataUtil.getLong(oldComponents.get(0).getMetadata(), ComponentMetadataUtil.MARKER_LSN_KEY, ComponentMetadataUtil.NOT_FOUND)); 
 pointable.setLong(value); 
 buffer.release(); 
 buffer.release(); 
 // In case two merge operations were scheduled to merge an overlapping set of components, // the second merge will fail and it must reset those components back to their previous state. 
 return Objects.hash(first, second); 
 return Objects.hash(data); 
 public IPageManager getPageManager() throws HyracksDataException { throw HyracksDataException.create(ErrorCode.LSM_INVERTED_INDEX_DOES_NOT_HAVE_PAGE_MANAGER); 
 private float getActualSimilarityVal(ISequenceIterator firstSequence, ISequenceIterator secondSequence, float simThresh) throws HyracksDataException { int flLen = firstSequence.size(); int slLen = secondSequence.size(); 
 boolean canTerminateEarly = edThresh >= 0; 
 return SIMILARITY_THRESHOLD_NOT_SATISFIED_VALUE; 
 * Gets the similarity value for the given two sequences. If the value doesn't satisfy the given simThresh, * this method returns -1. Else, this returns the real similarity value. 
 return SIMILARITY_THRESHOLD_NOT_SATISFIED_VALUE; 
 public static int getIntersectSize(ISequenceIterator tokensX, ISequenceIterator tokensY) throws HyracksDataException { 
 public QueryTranslator(List<Statement> statements, SessionConfig conf, ILangCompilationProvider compliationProvider, IStorageComponentProvider componentProvider, ThreadFactory threadFactory) { 
 boolean b = ABooleanSerializerDeserializer.getBoolean(serString, startOffset); 
 boolean argResult = ABooleanSerializerDeserializer.getBoolean(bytes, offset + 1); if (argResult == false) { 
 boolean argResult = ABooleanSerializerDeserializer.getBoolean(argPtr.getByteArray(), argPtr.getStartOffset() + 1); 
 boolean argRes = ABooleanSerializerDeserializer.getBoolean(bytes, offset + 1); ABoolean aResult = argRes ? (ABoolean.FALSE) : (ABoolean.TRUE); 
 boolean argResult = ABooleanSerializerDeserializer.getBoolean(data, offset + 1); 
 Boolean v = ABooleanSerializerDeserializer.getBoolean(b, s); 
 boolean v1 = ABooleanSerializerDeserializer.getBoolean(b1, s1); boolean v2 = ABooleanSerializerDeserializer.getBoolean(b2, s2); 
 @Override public void print(byte[] b, int s, int l, PrintStream ps) throws HyracksDataException { 
 public void flush() throws HyracksDataException { // Commit is at the end of a modification pipeline and there is no need to flush 
 * 
 Process process = new ProcessBuilder(joinPath(LOCAL_SAMPLES_DIR, "bin/stop-sample-cluster.sh"), "-f") 
 process = new ProcessBuilder(joinPath(LOCAL_SAMPLES_DIR, "bin/start-sample-cluster.sh")).inheritIO().start(); 
 Process process = new ProcessBuilder(joinPath(LOCAL_SAMPLES_DIR, "bin/stop-sample-cluster.sh")) 
<|del|> 
 } } 
 } } 
 private List<String> appArgs = new ArrayList<>(); 
<|del|>
 private List<String> appArgs = new ArrayList<>(); 
 @Option(name = "-cc-port", usage = "Cluster Controller port (default: 1099)", required = false) 
 @Option(name = "-cc-port", usage = "Cluster Controller port (default: 1099)", required = false) 
 if (configFile != null) { loadINIFile(); } 
<|del|> 
 } else { 
 IServletResponse.setContentType(response, IServlet.ContentType.TEXT_HTML, IServlet.Encoding.UTF8); 
 MetadataLockManager.INSTANCE.queryBegin(activeDataverse, query.getDataverses(), query.getDatasets()); 
 JobId jobId = null; 
<|del|> 
 private final ActivityClusterGraph acg; 
 * Distribute the specified Job. 
<|del|> 
 throw HyracksException.create(ErrorCode.DUPLICATE_DISTRIBUTED_JOB); 
 throw HyracksException.create(ErrorCode.ERROR_FINDING_DISTRIBUTED_JOB); 
 case JOB_STARTED: 
public class NoOpSubscriber implements IActiveEventSubscriber { 
public class NoOpSubscriber implements IActiveEventSubscriber { 
 public void sync() { // do nothing 
 public void unsubscribe() { // do nothing 
<|del|> 
 public static final JobId INVALID = new JobId(-1l); 
 public static final JobId INVALID = new JobId(-1l); 
 public static final JobId INVALID = new JobId(-1l); 
public class FeedOperations { private static final Logger LOGGER = Logger.getLogger(FeedOperations.class.getName()); 
 FeedConnectionRequest fcr = new FeedConnectionRequest(FeedRuntimeType.INTAKE, feedConnection.getAppliedFunctions(), feedConnection.getDatasetName(), feedConnection.getPolicyName(), feedConnection.getFeedId()); 
 String[] intakeLocations) throws AlgebricksException, HyracksDataException { 
 } catch (IOException e) { LOGGER.log(Level.WARNING, "Problem in creating socket against host " + url + " on the port " + port, e); throw e; 
 public synchronized DatasetDirectoryRecord getOrCreateDirectoryRecord(ResultSetId rsId, int partition) { 
<|del|> 
<|del|> 
<|del|> 
 protected void addServlet(HttpServer server, String path) { server.addServlet(createServlet(server, path, path)); 
 protected void addServlet(HttpServer server, String path) { server.addServlet(createServlet(server, path, path)); 
 throw HyracksDataException.create(ErrorCode.CANNOT_TRUNCATE_OR_DELETE_FILE, file.toString(), e); 
 } public void setDeleteAfterClose(boolean deleteAfterClose) { this.deleteAfterClose = deleteAfterClose; } 
 throw HyracksDataException.create(ErrorCode.CANNOT_TRUNCATE_OR_DELETE_FILE, e, file.toString()); 
<|del|> 
 ncs.checkForDuplicateDistributedJob(jobId); ActivityClusterGraph acg = (ActivityClusterGraph) DeploymentUtils.deserialize(acgBytes, null, ncs.getApplicationContext()); ncs.storeActivityClusterGraph(jobId, acg); 
<|del|>
<|del|> 
 run = new JobRun(ccs, deploymentId, jobId, callback, ccs.getDistributedJobStore().getDistributedJobDescriptor(jobId)); 
 run = new JobRun(ccs, deploymentId, jobId, callback, ccs.getDistributedJobStore().getDistributedJobDescriptor(jobId)); 
<|del|> 
<|del|>
 byte[] acgBytes = predistributed ? null : JavaSerializationUtils.serialize(acg); 
 HttpUtil.setContentType(response, HttpUtil.ContentType.TEXT_HTML); 
 HttpUtil.setContentType(response, HttpUtil.ContentType.APPLICATION_JSON, HttpUtil.Encoding.UTF8); 
 } public static String extension(String path) { int i = path.lastIndexOf('.'); return i < 1 ? "" : path.substring(i); } 
 LOGGER.log(Level.WARNING, "Remove job" + jobId); 
<|del|> 
 private static final Logger LOGGER = Logger.getLogger(GetNodeDetailsJSONWork.class.getName()); private static final Section [] CC_SECTIONS = { Section.CC, Section.COMMON }; private static final Section [] NC_SECTIONS = { Section.NC, Section.COMMON }; 
 @NCConfigOption() public String resultListenAddress; 
 configManager.processConfig(ncConfig, aep.getUsageFilter()); this.ncAppEntryPoint = aep; 
<|del|> 
 } public static String extension(String path) { int i = path.lastIndexOf('.'); return i < 1 ? "" : path.substring(i); } 
 commandLineOptions.add(option); } } } commandLineOptions.sort(Comparator.comparing(IOption::cmdline)); 
 @NCConfigOption() public String resultListenAddress; 
 ioManager = new IOManager(IODeviceHandle.getDevices(ncConfig.iodevices)); 
 ioManager.setExecutor(executor); 
// cList.add("-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005"); 
 configManager.processConfig(ncConfig, aep.getUsageFilter()); this.ncAppEntryPoint = aep; 
 digit = serString[offset] - '0'; 
 digit = serString[offset] - '0'; 
 digit = serString[offset] - '0'; 
 digit = serString[offset] - '0'; 
 digit = serString[offset] - '0'; 
 digit = serString[offset] - '0'; 
 digit = serString[offset] - '0'; 
 digit = serString[offset] - '0'; 
 int digit = serString[offset] - '0'; if (value < limit + digit) 
<|del|> 
<|del|> 
 int digit = serString[offset] - '0'; if (value < limit + digit) 
<|del|> 
 int digit = serString[offset] - '0'; if (value < limit + digit) 
<|del|> 
 if (value > 0) { 
 int digit; 
 int digit; 
 int digit; 
 int digit; 
<|del|> 
 FileRemoveOperatorDescriptor frod = new FileRemoveOperatorDescriptor(spec, spC.first, true); AlgebricksPartitionConstraintHelper.setPartitionConstraintInJobSpec(spec, frod, spC.second); 
public enum ActivityState { 
 ActivityState getState(); 
 private IFunctionDescriptor getFunctionDescriptor(AbstractFunctionCallExpression expr, IVariableTypeEnvironment env, JobGenContext context) throws AlgebricksException { 
 public ClusterControllerDetailsApiServlet(ConcurrentMap<String, Object> ctx, String... paths) { super(ctx, paths); 
 webServer.addServlet(new ApiServlet(webServer.ctx(), new String[] { "/*" }, ccExtensionManager.getAqlCompilationProvider(), ccExtensionManager.getSqlppCompilationProvider(), getStatementExecutorFactory(), componentProvider)); 
 jsonAPIServer.setAttribute(ASTERIX_APP_CONTEXT_INFO_ATTR, AppContextInfo.INSTANCE); 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>,Pair<IOperatorDescriptor, Integer>>> entry : subJob.getConnectorOperatorMap().entrySet()) { 
 String nodeName = ctx.getJobletContext().getApplicationContext().getNodeId(); return new HDFSRecordReader<Object, Writable>(read, inputSplits, readSchedule, nodeName, conf, files, indexer); 
 public static LookupAdapterFactory<?> getLookupAdapterFactory(ILibraryManager libraryManager, 
 } catch (ClassNotFoundException|IllegalAccessException|InstantiationException e) { throw new RuntimeDataException(ErrorCode.ERROR_PROVIDER_DATASOURCE_FACTORY_UNKNOWN_INPUT_STREAM_FACTORY, e, streamSource); 
 Map<ATypeTag, IValueParserFactory> m = new EnumMap<>(ATypeTag.class); 
 public static IRecordReaderFactory<?> createExternalRecordReaderFactory(ILibraryManager libraryManager, 
 private static void updateNCs() throws Exception { 
 TaskUtil.<ILogMarkerCallback>get(ILogMarkerCallback.KEY_MARKER_CALLBACK, ctx); 
 VSizeFrame message = TaskUtil.<VSizeFrame>get(HyracksConstants.KEY_MESSAGE, ctx); 
 void startupCompleted() throws Exception; //NOSONAR 
 void registerConfig(IConfigManager configManager); 
<|del|> 
 private INCApplicationContext ncAppCtx; 
<|del|> 
 if (bReader == null || pReader == null) { if (isLeftOuter && pReader != null) { appendNullToProbeTuples(pReader); 
<|del|> 
<|del|> 
 private final Map<String, Map<IOption, Object>> activeNcConfiguration = new HashMap<>(); 
<|del|> 
 public void processConfig(Configurable configurable, OptionHandlerFilter usageFilter) throws CmdLineException, IOException { 
<|del|> 
 printUsage(e.getParser(), filter); 
 case CLUSTER_LISTEN_ADDRESS: return "IP Address to bind cluster listener"; 
 public NodeControllerService(NCConfig config) throws Exception { 
 messagingNetManager = new MessagingNetworkManager(this, ncConfig.messagingListenAddress, ncConfig.messagingListenPort, ncConfig.netThreadCount, ncConfig.messagingPublicAddress, ncConfig.messagingPublicPort, appCtx.getMessagingChannelInterfaceFactory()); 
 cmdLineBuffer.append(" -address 127.0.0.1"); 
 cmdLineBuffer.append(" -address 127.0.0.1"); 
 cmdLineBuffer.append(" -address 127.0.0.1"); 
 //cList.add("-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005"); 
 //send file info NetworkingUtil.transferBufferToChannel(socketChannel, outBuffer); //transfer file NetworkingUtil.sendFile(fileChannel, socketChannel); 
 } catch (Exception e) { LOGGER.log(Level.WARNING, "Unhandled exception ", e); 
 // TODO(tillw) addHandler(createAdminConsoleHandler()); server.addServlet(new StaticResourceServlet(ctx, new String[] { "/static/*" })); 
<|del|> 
 } throw e; 
 } throw e; 
 if (runFileWriters != null) { for (RunFileWriter runFileWriter : runFileWriters) { if (runFileWriter != null) { runFileWriter.close(); } 
 } catch (Exception e) { throw e; 
 } catch (Exception e) { throw e; 
 throw e; 
 throw e; 
 } catch (Exception e) { try { for (RunFileWriter run : generatedRuns) { run.erase(); } } finally { writer.fail(); throw e; } 
 } catch (Exception e) { 
 // to send the failure signal to the downstream, when there is a throwable thrown. 
 throw e; 
 if (!forceNLJ && (afterMax < (NLJ_SWITCH_THRESHOLD * beforeMax))) { //Case 2.1.1 - Keep applying HHJ 
 if (isLeftOuter && rprfw != null) { // For the outer join, we don't reverse the role. 
 if (isLeftOuter && rprfw != null) { // For the outer join, we don't reverse the role. 
 "\t\t>>>Case 2.1.2 - SWITCHED to NLJ RecursiveHHJ WITH " + "(isLeftOuter || build<probe) - [Level " + level + "]"); 
 if (isLeftOuter && rprfw != null) { // For the outer join, we don't reverse the role. 
 if (isLeftOuter && rprfw != null) { // For the outer join, we don't reverse the role. 
 //checked-modified applyNestedLoopJoin(buildRd, probeRd, memSizeInFrames, rbrfw, rprfw); 
 //checked-modified applyNestedLoopJoin(buildRd, probeRd, memSizeInFrames, rbrfw, rprfw); 
<|del|> 
 logger.log(Level.WARNING, "Invalid handle: \"" + strHandle + "\""); 
 } /* * Always write and then flush to send out the message if exists */ @Override public void flush(IFrameWriter writer) throws HyracksDataException { write(writer, true); writer.flush(); } 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE) 
 modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE, dataset.hasMetaPart()); 
 } LOGGER.log(Level.INFO, "Stopped " + ActiveJobNotificationHandler.class.getSimpleName()); 
 private boolean pendingFailbackCompletion = false; private IMessageBroker messageBroker; 
 private boolean pendingFailbackCompletion = false; private IMessageBroker messageBroker; 
<|del|> 
<|del|> 
 webServer = new WebServer(this); 
<|del|> 
 parser.printUsage(new OutputStreamWriter(out), null, filter); 
 public static void printUsage(CmdLineException e, OptionHandlerFilter filter, PrintStream out) { out.println("ERROR: " + e.getMessage()); printUsage(e.getParser(), filter, out); 
 try { while (probeReader.nextFrame(inBuffer)) { joiner.join(inBuffer.getBuffer(), writer); inBuffer.reset(); } joiner.completeJoin(writer); } finally { joiner.releaseMemory(); 
 file.delete(); // Make sure we never access the file if it is deleted. file = null; handle = null; 
 joiner.completeJoin(writer); 
 } @Override public MetadataOnlyReplicationStrategy from(Cluster cluster) { MetadataOnlyReplicationStrategy st = new MetadataOnlyReplicationStrategy(); return st; } 
 throw new IllegalArgumentException(String.format("Unsupported Replication Strategy. Available types: %s", BUILT_IN_REPLICATION_STRATEGY.keySet().toString())); 
 BOOTSTRAPPING, // The first time the NC is bootstrapped. PERMANENT_DATA_LOSS, // No checkpoint files found on NC and it is not BOOTSTRAPPING (data loss). 
public class JSONOutputRequestUtil { private JSONOutputRequestUtil() {} 
 return request.getHttpRequest().headers().get(HttpHeaderNames.HOST); 
 protected IHyracksDataset getHyracksDataset() throws Exception { // NOSONAR 
 } catch (JsonProcessingException e) { // NOSONAR 
 private final String component; private final int errorCode; private final Serializable[] params; private final String nodeId; 
 private final String component; private final int errorCode; private final Serializable[] params; private final String nodeId; 
 private final String component; private final int errorCode; private final Serializable[] params; private final String nodeId; 
 private final String component; private final int errorCode; private final Serializable[] params; private final String nodeId; 
 CCConfig ccConfig = new CCConfig(configManager); 
 return Section.VIRTUAL; 
 ncConfig1.iodevices = new String [] { joinPath(System.getProperty("user.dir"), "target", "data", "device0") }; 
 ncConfig2.iodevices = new String [] { joinPath(System.getProperty("user.dir"), "target", "data", "device1") }; 
<|del|> 
 this.aep = aep; configManager.processConfig(ccConfig, this.aep.getUsageFilter()); 
<|del|> 
 ncConfig1.iodevices = new String [] { joinPath(System.getProperty("user.dir"), "target", "data", "device0") }; 
 ncConfig2.iodevices = new String [] { joinPath(System.getProperty("user.dir"), "target", "data", "device1") }; 
 ncConfig1.iodevices = new String [] { joinPath(System.getProperty("user.dir"), "target", "data", "device0") }; 
<|del|> 
 throw new AsterixException(ErrorCode.PROVIDER_STREAM_RECORD_READER_DUPLICATE_FORMAT_MAPPING, 
 this.hasHeader = ExternalDataUtils.hasHeader(config); 
 throw new HyracksDataException(e); 
 if (tmpFactories.containsKey(format)) { throw new AsterixException(ErrorCode.FEED_DATASOURCE_FACTORY_DUPLICATE_FORMAT_MAPPING, format); 
 private static final String RESOURCE = "META-INF/services/org.apache.asterix.external.input.record." + "reader.stream.StreamRecordReader"; 
 private static final String RESOURCE = "META-INF/services/org.apache.asterix.external.input.record." + "reader.stream.StreamRecordReader"; 
<|del|> 
 @Override public boolean hasNext() throws IOException { 
 if (readLength > 0) { if (inQuote) { throw new IOException("malformed input record ended inside quote"); 
 if (readLength > 0) { if (inQuote) { throw new IOException("malformed input record ended inside quote"); 
 // Directly mark it as fail, without further abortion. 
import static org.apache.hyracks.control.common.config.OptionTypes.INTEGER; import static org.apache.hyracks.control.common.config.OptionTypes.INTEGER_BYTE_UNIT; import static org.apache.hyracks.util.StorageUtil.StorageUnit.KILOBYTE; 
<|del|> 
<|del|> 
 throw new AlgebricksException(ErrorCode.ASTERIX, ErrorCode.COMPILATION_DATASET_TYPE_DOES_NOT_HAVE_PRIMARY_INDEX, getDatasetType()); 
<|del|> 
 private final int upsertIdx; 
 void forceUpdateMeta(ILSMIndexOperationContext ctx, IValueReference key, IValueReference value) throws HyracksDataException; 
 @Override public void updateMeta(IValueReference key, IValueReference value) throws HyracksDataException { // a hack because delete only gets the memory component 
 return (StreamRecordReader) recordReaderClazz.getDeclaredConstructor(AsterixInputStream.class, Map.class) 
 private ListMapNode head = new ListMapNode(null, null, null, null); 
 ListMapNode current = head; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (!log.mkdirs() && !log.isDirectory()) { throw new IOException(config.logdir + ": cannot create"); 
 private Map<IOption, Object> createNodeSpecificMap(String nodeId) { LOGGER.fine("createNodeSpecificMap: " + nodeId); 
<|del|> 
 Index index = mdProvider.getIndex(getDataverseName(), getDatasetName(), getDatasetName()); 
 void updateMeta(ILSMIndexOperationContext ctx, IValueReference key, IValueReference value) throws HyracksDataException; 
 current.payload = value; return current.payload; 
<|del|> 
<|del|> 
<|del|> 
 private Map<IOption, Object> createNodeSpecificMap(String nodeId) { LOGGER.fine("createNodeSpecificMap: " + nodeId); 
<|del|> 
public interface IConfigManager { int PARSE_INI_POINTERS_METRIC = 100; int PARSE_INI_METRIC = 200; int PARSE_COMMAND_LINE_METRIC = 300; int APPLY_DEFAULTS_METRIC = 400; 
 */ 
 private final int defaultBranch; 
 private final boolean propageToAllBranchAsDefault; 
 this(outputArity, branchingExpression, 0, false); 
 public int getDefaultBranch() { return defaultBranch; 
 public boolean getPropageToAllBranchAsDefault() { return propageToAllBranchAsDefault; 
 this(spec, rDesc, outputArity, brachingExprEvalFactory, intInsepctorFactory, 0, false); 
 int outputBranch = defaultBranch; 
 if (!propageToAllBranchAsDefault) { 
<|del|> 
 System.err.println("XXX RState created " + toString()); 
 System.err.println("XXX RState close " + toString()); 
 System.err.println("XXX RState closeAndDelete " + toString()); 
 System.err.println("XXX RState write1 " + toString()); 
 System.err.println("XXX RState write2 " + toString()); 
 System.err.println("XXX RState readOpen " + toString()); 
 System.err.println("XXX RState readClose " + toString()); 
 System.err.println("XXX RState read1 " + toString()); 
 System.err.println("XXX RState read2 " + toString()); 
 System.err.println("XXX RState abort " + toString()); 
 System.err.println("XXX RState returnPage " + toString()); 
<|del|> 
 System.err.println("XXX Writer open " + toString()); 
 System.err.println("XXX Writer nextFrame " + toString()); 
 System.err.println("XXX Writer fail " + toString()); 
 System.err.println("XXX Writer close " + toString()); 
 * used by extensions to access shared datasource factory for a job 
 public void copyInto(byte[] copy) { 
 private final IHyracksTaskContext ctx; private boolean initialized = false; private IFrame message; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 debugPrint(); 
 public void setOp(byte op) throws HyracksDataException { // not needed for test case 
 for (int i = 0; i < consumerPartitionCount; i++) { if (allocatedFrames[i]) { appenders[i].flush(pWriters[i]); 
 Thread.sleep(interval); 
<|del|> 
 for (int i = 0; i < consumerPartitionCount; i++) { if (allocatedFrames[i]) { appenders[i].flush(pWriters[i]); 
 final ICCServiceContext ccServiceCtx, EnumSet<JobFlag> jobFlags) throws HyracksException { 
 ICCServiceContext ccServiceCtx, EnumSet<JobFlag> jobFlags) throws HyracksException; 
 void stop() throws Exception; //NOSONAR 
 void stop() throws Exception; //NOSONAR 
 // No-op 
 // No-op 
<|del|> 
 try (BufferedReader readerExpected = new BufferedReader(new FileReader(expectedFile)); BufferedReader readerActual = new BufferedReader(new FileReader(actualFile))) { 
<|del|> 
 public Pair<LSMInsertDeleteOperatorNodePushable, CommitRuntime> getInsertPipeline(IHyracksTaskContext ctx, Dataset dataset, IAType[] primaryKeyTypes, 
 public void lock(DatasetId datasetId, int entityHashValue, byte lockMode, ITransactionContext txnContext) 
 ACTIVE_PORT(INTEGER, 19003, "The listen port of the active server"), 
 serviceCtx.setStateDumpHandler(new AsterixStateDumpHandler(serviceCtx.getNodeId(), lccm.getDumpPath(), lccm)); 
 void startupCompleted() throws Exception; //NOSONAR 
 void stop() throws Exception; //NOSONAR 
 void stop() throws Exception; //NOSONAR 
 IHyracksClientConnection getHcc() throws Exception; //NOSONAR 
 final ICCServiceContext ccServiceCtx, Set<JobFlag> jobFlags) throws HyracksException { 
 ICCServiceContext ccServiceCtx, Set<JobFlag> jobFlags) throws HyracksException; 
 return "ps -ef | awk '/java.*org\\.apache\\.hyracks\\.control\\.[cn]c\\.[CN]CDriver/ {print $2}' " + 
<|del|> 
<|del|> 
 int rc = cancelQuery(getEndpoint(Servlets.QUERY_CANCEL), params); 
 } 
 String clientContextId = request.getParameter(CLIENT_CONTEXT_ID); 
 int rc = cancelQuery(getEndpoint(Servlets.QUERY_CANCEL), params, clientContextId); Assert.assertTrue(rc == 200 || rc == 404); 
 }); 
 void stop() throws Exception; 
<|del|> 
 private List<Exception> exceptions; 
<|del|> 
<|del|> 
 if (exceptions != null && !exceptions.isEmpty()) { return exceptions.get(0); 
 private List<Exception> exceptions; 
 private static final PrintStream debugStream = null; //System.err; 
 public synchronized DatasetJobRecord.Status getResultStatus(JobId jobId, ResultSetId rsId) throws HyracksDataException { 
 pw.println(String.valueOf(getDatasetJobRecord(jId))); 
 debugTrace("created " + toString()); 
 debugTrace("created " + toString()); 
 debugTrace("open " + toString()); 
 debugTrace("open " + toString()); 
 debugTrace("close " + toString()); 
 debugTrace("close " + toString()); 
 debugTrace("closeAndDelete " + toString()); 
 debugTrace("write1 " + toString()); 
 debugTrace("write1 " + toString()); 
 debugTrace("write2 " + toString()); 
 debugTrace("write2 " + toString()); 
 debugTrace("readOpen " + toString()); 
 debugTrace("readOpen " + toString()); 
 debugTrace("readClose " + toString()); 
 debugTrace("readClose " + toString()); 
 debugTrace("read1 " + toString()); 
 debugTrace("read1 " + toString()); 
 debugTrace("read2 " + toString()); 
 debugTrace("read2 " + toString()); 
 debugTrace("abort " + toString()); 
 debugTrace("abort " + toString()); 
 debugTrace("returnPage " + toString()); 
 debugTrace("returnPage " + toString()); 
 debugTrace("open " + toString()); 
 debugTrace("open " + toString()); 
 debugTrace("nextFrame " + toString()); 
 debugTrace(" fail " + toString()); 
 debugTrace(" fail " + toString()); 
 debugTrace("close " + toString()); 
 debugTrace("close " + toString()); 
 // if the JSON parsing fails, the statement is empty and we get an empty statement error 
 // using a plain IllegalStateException here to get into the right catch clause for a 500 
 } else if (logRecord.getNewOp() == AbstractIndexModificationOperationCallback.DELETE_BYTE) { indexAccessor.forceInsert(logRecord.getOldValue()); } else if (logRecord.getNewOp() == AbstractIndexModificationOperationCallback.UPSERT_BYTE) { 
 nc.getTransactionManager().completedTransaction(txnCtx, DatasetId.NULL, -1, true); IIndexDataflowHelper dataflowHelper = nc.getPrimaryIndexDataflowHelper(dataset, KEY_TYPES, RECORD_TYPE, META_TYPE, new NoMergePolicyFactory(), null, null, storageManager, KEY_INDEXES, 
 nc.getTransactionManager().completedTransaction(txnCtx, DatasetId.NULL, -1, true); 
 protected final DatasetId datasetId; 
 public void lock(DatasetId datasetId, int entityHashValue, byte lockMode, ITransactionContext txnContext) 
 public static final int ENTITYCOMMIT_UPDATE_HEADER_LEN = RS_PARTITION_LEN + DatasetId.BYTES + PKHASH_LEN + PKSZ_LEN; 
 public void commitTransaction(ITransactionContext txnContext, DatasetId datasetId, int pkHash) 
 private static final DatasetId METADATA_DATASET_ID = new ImmutableDatasetId(MetadataPrimaryIndexes.PROPERTIES_METADATA.getDatasetId()); 
 transactionSubsystem.getTransactionManager().commitTransaction(txnCtx, DatasetId.NULL, -1); 
 transactionSubsystem.getTransactionManager().abortTransaction(txnCtx, DatasetId.NULL, -1); 
 public DatasetId getDatasetId(); 
 public DatasetId getDatasetId() { 
 txnManager.completedTransaction(txnContext, DatasetId.NULL, -1, 
 txnManager.completedTransaction(txnContext, DatasetId.NULL, -1, 
 private final DatasetId datasetId; 
 datasetLifeCycleManager.flushDataset(datasetId.getId(), false); 
 log("lock", datasetId.getId(), entityHashValue, lockMode, txnContext); 
 log("instantLock", datasetId.getId(), entityHashValue, lockMode, txnContext); 
 log("tryLock", datasetId.getId(), entityHashValue, lockMode, txnContext); 
 log("instantTryLock", datasetId.getId(), entityHashValue, lockMode, txnContext); 
 log("unlock", datasetId.getId(), entityHashValue, lockMode, txnContext); 
 public void abortTransaction(ITransactionContext txnCtx, DatasetId datasetId, int PKHashVal) throws ACIDException { 
 public void commitTransaction(ITransactionContext txnCtx, DatasetId datasetId, int PKHashVal) 
 public void completedTransaction(ITransactionContext txnContext, DatasetId datasetId, int PKHashVal, 
 private Request req(final Kind kind, final ITransactionContext txnCtx, final DatasetId dsId, final int hashValue, 
 private static DatasetId d(int id) { return new DatasetId(id); 
 return txnCtx.getJobId() + ":" + kind.name() + ":" + dsId.getId() + ":" + hashValue + ":" 
 static Request create(final Kind kind, final ITransactionContext txnCtx, final DatasetId dsId, final int hashValue, 
<|del|> 
<|del|> 
 private final Map<String, JobId> runningQueries = new ConcurrentHashMap<>(); 
<|del|> 
 IStatementExecutorContext runningQueries = (IStatementExecutorContext) ctx .get(ServletConstants.RUNNING_QUERIES_ATTR); 
 JobId jobId = runningQueries.getJobIdFromClientContextId(clientContextId); 
 public static final String EXECUTOR_SERVICE_ATTR = "org.apache.asterix.EXECUTOR_SERVICE_ATTR"; public static final String RUNNING_QUERIES_ATTR = "org.apache.asterix.RUNINNG_QUERIES"; 
 public static final String EXECUTOR_SERVICE_ATTR = "org.apache.asterix.EXECUTOR_SERVICE_ATTR"; public static final String RUNNING_QUERIES_ATTR = "org.apache.asterix.RUNINNG_QUERIES"; 
 public void testDelete() throws Exception { 
 int rc = cancelQuery(getEndpoint(Servlets.RUNNING_QUERY), params); 
 // TODO(yingyi): investigate if we need synchronized cancellation. 
 // Cancels a submitted query through the cancellation REST API. 
<|del|> 
 * Runs the SQL++ runtime tests with a cancellation request for each read-only query. 
 public static final String RUNNING_QUERY = "/admin/requests/running/*"; 
 public static final String RUNNING_QUERY = "/admin/requests/running/*"; 
 int rc = cancelQuery(getEndpoint(Servlets.RUNNING_QUERY), params); 
 throw HyracksDataException.create(ErrorCode.UNIDENTIFIED_IO_ERROR_READING_FILE, baseDir); 
 return om.writer(new MinimalPrettyPrinter()).writeValueAsString(on); } catch (JsonProcessingException e) { // NOSONAR 
 return om.writer(new MinimalPrettyPrinter()).writeValueAsString(on); } catch (JsonProcessingException e) { // NOSONAR 
 return om.writer(new MinimalPrettyPrinter()).writeValueAsString(on); } catch (JsonProcessingException e) { // NOSONAR 
 List<JobSpecification> jobsToExecute = new ArrayList<JobSpecification>(); 
 ResultDecorator postResultDecorator, ResultAppender handleAppender, ResultAppender statusAppender, boolean optimize, boolean executeQuery, boolean generateJobSpec) { 
<|del|> 
 int followersCount = random.nextInt(200); 
 int followersCount = random.nextInt(200); 
 ? date.getMonth() == endDate.getMonth() ? endDate.getMonth() 
 public DateTime() { // do nothing 
 this.hour = (hour < 10) ? "0" : Integer.toString(hour); this.min = (min < 10) ? "0" : Integer.toString(min); this.sec = (sec < 10) ? "0" : Integer.toString(sec); 
 private char[] content = new char[500]; 
 public Point() { // do nothing 
 private RandomUtil() { // do nothing } 
 public static final Random random = new Random(); 
 public static final Random random = new Random(); 
 public static final class TweetFields { private TweetFields() { // do nothing } 
 private TweetMessage() { // do nothing 
 // do nothing 
 builder.append(String.format("%02d", day)); 
 } catch (Exception e) { LOGGER.info("OutputStream failed. Add it into the removal list."); 
 public boolean generateNextBatch(int numTweets) throws IOException{ 
 public TwitterFirehoseInputStream(Map<String, String> configuration, int partition) 
 public enum Mode { 
 LOGGER.warning("Exception in adapter " + e.getMessage()); 
 stopIfRunning(runtimeId, runtime); 
 TweetMessage msg; 
 TweetMessage msg; 
 public void initialize(DefaultInitializationInfo info) { 
 public void initialize(DefaultInitializationInfo info) { 
 public static final class TweetFields { private TweetFields() { // do nothing } 
 dataGenerator = new DataGenerator(); 
 ReentrantReadWriteLock dvLock = dataversesLocks.computeIfAbsent(dataverseName, LOCK_FUNCTION); 
 public static final byte GENERIC_EVENT = 0x02; 
 ReentrantReadWriteLock entityLock = computeIfAbsent(entityName, extensionLocks); 
 ReentrantReadWriteLock entityLock = computeIfAbsent(entityName, extensionLocks); 
 * 
 respond(ctx, request, HttpResponseStatus.BAD_REQUEST); 
 // Done with the adapter. about to close, setting the stage based on the failed ingestion flag and notifying // the runtime manager adapterManager.setFailed(failed); 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : subJob.getConnectorOperatorMap().entrySet()) { 
 return failedIngestion; 
<|del|> 
<|del|> 
 adapter.start(adapterManager.getPartition(), writer); 
 continueIngestion = false; } catch (InterruptedException e) { throw e; 
<|del|> 
 ISearchOperationCallbackFactory searchCallbackFactory, String indexName, int[] prevFieldPermutation, IPageManagerFactory pageManagerFactory) { 
 if (!recordReaders.containsKey(format)) { recordReaders.put(format, new ArrayList<>()); 
 throw HyracksDataException.create(ErrorCode.OPERATION_EXCEEDED_MAX_RESTARTS, MAX_RESTARTS); 
 try { 
 throw HyracksDataException.create(ErrorCode.OPERATION_EXCEEDED_MAX_RESTARTS, MAX_RESTARTS); 
<|del|> 
<|del|> 
 consumer.poison(); 
 protected static final FeedPolicyEntity[] policies = new FeedPolicyEntity[] { BASIC, ADVANCED_FT_DISCARD, 
<|del|> 
 protected boolean pushIntoQueueFromCursorAndReplaceThisElement(PriorityQueueElement e) throws HyracksDataException, IndexException { 
<|del|> 
 public static FileSplit[] splitsForDataset(MetadataTransactionContext mdTxnCtx, String dataverseName, String datasetName, String targetIdxName, boolean temp) throws AlgebricksException { 
 File relPathFile = new File(StoragePathUtil.prepareDataverseIndexName(dataset.getDataverseName(), dataset.getDatasetName(), targetIdxName)); 
 public void add(IMetadataLock.Mode mode, IMetadataLock lock) { 
 public static FileSplit[] splitsForDataset(MetadataTransactionContext mdTxnCtx, String dataverseName, String datasetName, String targetIdxName, boolean temp) throws AlgebricksException { 
 File relPathFile = new File(StoragePathUtil.prepareDataverseIndexName(dataset.getDataverseName(), dataset.getDatasetName(), targetIdxName)); 
<|del|> 
 public static FileSplit[] splitsForDataset(MetadataTransactionContext mdTxnCtx, String dataverseName, String datasetName, String targetIdxName, boolean temp) throws AlgebricksException { 
 if (opId == null) { opId = jobSpec.createOperatorDescriptorId(opDesc); } 
 public IDatasetStateRecord getState(JobId jobId); 
 //wait ten seconds to ensure the result sweeper does not break the job //The result sweeper runs every 5 seconds during the tests Thread.sleep(10000); 
 public IDatasetStateRecord getState(JobId jobId) { return getDatasetJobRecord(jobId); } public synchronized long getJobTimestamp(JobId jobId) { 
 //wait three minutes to ensure the result sweeper does not break the job //The result sweeper runs every 2 minutes during the tests Thread.sleep(180000); 
 List<IInvertedListCursor> cursorsOrderedByTokens) throws HyracksDataException; 
 LOGGER.log(Level.WARNING, "Failure during index delete operation", e); 
 List<IInvertedListCursor> cursorsOrderedByTokens) throws HyracksDataException { 
 throw HyracksDataException.create(e); 
 } catch (ACIDException e) { 
 } catch (HyracksDataException e) { 
 } catch (HyracksDataException e) { 
 } catch (HyracksDataException e) { 
 } catch (HyracksDataException e) { 
 } catch (HyracksDataException e) { 
 } catch (ACIDException e) { 
 } catch (ACIDException e) { 
 } catch (HyracksDataException e) { 
 } catch (ACIDException e) { 
 } catch (HyracksDataException e) { 
 } catch (ACIDException e) { 
 } catch (ACIDException e) { 
 } catch (HyracksDataException e) { 
 } catch (HyracksDataException e) { 
 } catch (HyracksDataException | ACIDException e) { 
 } catch (ACIDException e) { 
 } catch (ACIDException e) { 
 } catch (ACIDException e) { 
 } catch (ACIDException e) { 
 } catch (HyracksDataException e) { 
 } catch (ACIDException e) { 
 } catch (HyracksDataException e) { 
 } catch (HyracksDataException | ACIDException e) { 
 * Moves the cursor to the next value 
 if (e.getErrorCode() == ErrorCode.UNSORTED_LOAD_INPUT || e.getErrorCode() == ErrorCode.DUPLICATE_KEY || e.getErrorCode() == ErrorCode.DUPLICATE_LOAD_INPUT) { 
<|del|> 
 protected void checkPriorityQueue() throws HyracksDataException { 
 try { doOpen(); failed = false; } catch (Throwable th) { failure = th; throw th; } 
 HyracksDataException hde = HyracksDataException.create(ErrorCode.NEXT_FRAME_ON_FAILED_WRITER); LOGGER.log(Level.WARNING, "nextFrame called on a failed writer", hde); throw hde; 
 HyracksDataException hde = HyracksDataException.create(ErrorCode.NEXT_FRAME_ON_FAILED_WRITER); LOGGER.log(Level.WARNING, "flush called on a failed writer", hde); throw hde; 
 @Override public final void fail() throws HyracksDataException { failed = true; doFail(); 
<|del|> 
<|del|> 
 throws ACIDException, HyracksDataException { 
 indexAccessor.update(tuple); 
 if (e.getErrorCode() == ErrorCode.UNSORTED_LOAD_INPUT || e.getErrorCode() == ErrorCode.DUPLICATE_KEY || e.getErrorCode() == ErrorCode.DUPLICATE_LOAD_INPUT) { 
 // TODO: at this time, we only add proceed() part. 
 Assert.assertTrue(filter.getLength() == 11); 
 } return null; 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : subJob 
 throw HyracksDataException.create(e); 
 private void processTuple(int i) throws Exception { 
 protected void processTuple(ByteBuffer buffer, int i) throws AsterixException, IOException { 
 public void open() throws HyracksDataException { 
 public void fail() throws HyracksDataException { 
 public void open() throws HyracksDataException { 
<|del|> 
 int offset = tupleIndex == 0 ? FrameConstants.TUPLE_START_OFFSET : IntSerDeUtils.getInt(buffer.array(), tupleCountOffset - 4 * tupleIndex); return start + offset; 
 predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator(); 
 public void fail() throws HyracksDataException { 
 predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator(); 
 predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator(); 
 predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator(); 
 closeException = th; 
 } } catch (Throwable th) { writer.fail(); closeException = new HyracksDataException(th); 
 this.writer = writer; 
 public void open() throws HyracksDataException { 
 public void nextFrame(ByteBuffer buffer) throws HyracksDataException { 
 final IPredicateEvaluator predEvaluator = predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator(); 
 } else { 
 return (int) Math.ceil(d); } 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public void closeBuild(boolean isFailed) throws HyracksDataException { // TODO: Should use the isFailed flag to simply cleanup in case of failure 
 public void doOpen() throws HyracksDataException { writer.open(); consumerThread.start(); 
 } try { inbox.put(FAIL); } catch (InterruptedException e) { LOGGER.log(Level.WARNING, "interrupted", e); Thread.currentThread().interrupt(); } 
<|del|> 
 while (running) { frame = inbox.poll(); if (frame == null) { writer.flush(); frame = inbox.take(); } 
 public void open() throws HyracksDataException { 
 public void nextFrame(ByteBuffer buffer) throws HyracksDataException { 
 public void fail() throws HyracksDataException { 
 } appender.write(writer, true); 
 } @Override public void flush() throws HyracksDataException { // flush() makes no sense to sink operators } 
 try { flushIfNotFailed(); } finally { writer.close(); 
 DumpInStreamToPrintStream disps = new DumpInStreamToPrintStream(process.getErrorStream(), System.err); 
 public void open() throws HyracksDataException { 
 public void open() throws HyracksDataException { 
 public void fail() throws HyracksDataException { 
 return new IFrameWriter() { 
 public void fail() { 
 public void nextFrame(ByteBuffer buffer) throws HyracksDataException { 
 public void fail() throws HyracksDataException { 
 public void fail() throws HyracksDataException { 
 public void open() throws HyracksDataException { 
 final IPredicateEvaluator predEvaluator = predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator(); 
 private final ITuplePartitionComputerFactory hpcf0 = new FieldHashPartitionComputerFactory(keys0, hashFunctionFactories); private final ITuplePartitionComputerFactory hpcf1 = new FieldHashPartitionComputerFactory(keys1, hashFunctionFactories); 
 state.joiner.completeJoin(writer); 
 public void closeBuild(boolean isFailed) throws HyracksDataException { // TODO: Should use the isFailed flag to simply cleanup in case of failure 
 for (int p = spilledStatus.nextClearBit(0); p >= 0 && p < numOfPartitions; p = spilledStatus.nextClearBit(p + 1)) { 
 public void open() throws HyracksDataException { 
 public void fail() throws HyracksDataException { 
 ITuplePartitionComputer probeHpc = new FieldHashPartitionComputerFamily(probeKeys, hashFunctionGeneratorFactories) .createPartitioner(0); ITuplePartitionComputer buildHpc = new FieldHashPartitionComputerFamily(buildKeys, hashFunctionGeneratorFactories) .createPartitioner(0); 
 if (isLeftOuter && rprfw != null) { // For the outer join, we don't reverse the role. 
 public void fail() throws HyracksDataException { 
 try { flushWriter.fail(); } catch (Throwable secondFailure) { th.addSuppressed(secondFailure); } 
 public void fail() throws HyracksDataException { 
 public void open() throws HyracksDataException { 
 public void fail() throws HyracksDataException { 
 } catch (Throwable th) { if (closeException == null) { closeException = th; } else { closeException.addSuppressed(th); } 
 try { writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = th; } else { closeException.addSuppressed(th); } } 
 try { writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = th; } else { closeException.addSuppressed(th); } } 
 closeException = th; 
 @Override public boolean hasNext() throws IOException { 
 if (!recordReaders.containsKey(format)) { recordReaders.put(format, new ArrayList<>()); 
 LOGGER.log(Level.WARNING, "Unable to log exception causing tuple", ex); 
 LOGGER.log(Level.WARNING, "Unable to log exception causing tuple", ex); 
 LOGGER.log(Level.WARNING, "Unable to handle exception ", exception); 
 LOGGER.log(Level.WARNING, "Unable to handle exception ", exception); 
 LOGGER.log(Level.WARNING, "Unable to handle exception ", exception); 
 if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Exception was caught in tuple " + tupleIndex, e); } 
 fpa.spillToDiskOnCongestion() ? new FrameSpiller(ctx, 
 * @return returns a new frame with tuples excluding the exception generating tuple * or null if exception was not handled 
 * @return returns a new frame with tuples excluding the exception generating tuple * or null if exception was not handled 
 final IPredicateEvaluator predEvaluator = predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator(); 
 try { flushWriter.fail(); } catch (Throwable secondFailure) { th.addSuppressed(secondFailure); } 
 closeException = th; try { writer.fail(); } catch (Throwable failFailure) { th.addSuppressed(failFailure); } throw HyracksDataException.create(closeException); 
 try { writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = th; } else { closeException.addSuppressed(th); } } 
 closeException = th; 
 this.spiller = fpa.spillToDiskOnCongestion() ? new FrameSpiller(ctx, 
 public void poison() { poisoned = true; 
 if (cause instanceof InterruptedException && !Thread.currentThread().isInterrupted()) { LOGGER.log(Level.WARNING, "Wrapping an InterruptedException in HyracksDataException and current thread is not interrupted", cause); 
<|del|> 
 throw HyracksDataException.create(e); 
 closeException.addSuppressed(failFailure); 
 // NOSONAR if JSON parsing fails, just use the original string 
 public static final List<String> recordReaderFormats = Collections.unmodifiableList( Arrays.asList(ExternalDataConstants.FORMAT_DELIMITED_TEXT, ExternalDataConstants.FORMAT_CSV)); public static final String requiredConfigs = ""; 
 throw new CompilationException(ErrorCode.FEED_UNKNOWN_ADAPTER_NAME); 
 logExceptionCausingTuple(tupleIndex, th); 
 if (filter != null) { 
 if (filter != null) { 
<|del|> 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : subJob.getConnectorOperatorMap().entrySet()) { 
 public EmptyLineSeparatedRecordReader(AsterixInputStream inputStream, Map<String, String> config) {//NOSONAR 
 public EmptyLineSeparatedRecordReader(AsterixInputStream inputStream, Map<String, String> config) {//NOSONAR 
 public static final String REQUIRED_CONFIGS = ""; 
 public static final String REQUIRED_CONFIGS = "quote"; // NOSONAR private final char quote; 
 public static final String REQUIRED_CONFIGS = "quote"; // NOSONAR private final char quote; 
 public static final String REQUIRED_CONFIGS = "quote"; // NOSONAR private final char quote; 
 if (quoteString.length() != 1) { 
 if (tmpFactories.containsKey(format)) { throw new AsterixException(ErrorCode.FEED_DATASOURCE_FACTORY_DUPLICATE_FORMAT_MAPPING, 
 IApplicationMessage receivedMsg = (IApplicationMessage) JavaSerializationUtils 
<|del|> 
 LOGGER.log(Level.WARNING, "Unable to handle exception", exception); 
<|del|> 
<|del|> 
<|del|>
 // no op 
 public IndexTestContext(ISerializerDeserializer[] fieldSerdes, IIndex index, boolean filtered) throws HyracksDataException { 
 this.tupleBuilder = filtered ? new ArrayTupleBuilder(fieldSerdes.length + 1) : new ArrayTupleBuilder(fieldSerdes.length); 
 this.tupleBuilder = filtered ? new ArrayTupleBuilder(fieldSerdes.length + 1) : new ArrayTupleBuilder(fieldSerdes.length); 
 this.tupleBuilder = filtered ? new ArrayTupleBuilder(fieldSerdes.length + 1) : new ArrayTupleBuilder(fieldSerdes.length); 
 ArrayTupleReference tuple, ISerializerDeserializer[] fieldSerdes, boolean filtered) throws HyracksDataException { 
 for (int i = 0; i < (filtered ? fieldCount - 1 : fieldCount); i++) { 
 for (int i = 0; i < (filtered ? fieldCount - 1 : fieldCount); i++) { 
 for (int i = 0; i < (filtered ? fieldCount - 1 : fieldCount); i++) { 
 for (int i = 0; i < (filtered ? fieldCount - 1 : fieldCount); i++) { 
 if (filtered) { fieldSerdes[0].serialize(checkTuple.getField(0), dos); 
 if (filtered) { fieldSerdes[0].serialize(checkTuple.getField(0), dos); 
 public Pair<ITupleReference, ITupleReference> insertIntTuples(IIndexTestContext ctx, int numTuples, boolean filtered, Random rnd) throws Exception { 
 if (filtered) { 
 filterBuilder.addField(currTuple.getFieldData(filterField), currTuple.getFieldStart(filterField), currTuple.getFieldLength(filterField)); 
 } else if (compareFilterTuples(minMax.getRight(), filterOnlyTuple, comparator) < 0) { 
 } else if (compareFilterTuples(minMax.getRight(), filterOnlyTuple, comparator) < 0) { 
 public void upsertIntTuples(IIndexTestContext ctx, int numTuples, Random rnd) throws Exception { 
 ArrayTupleBuilder tupleBuilder = filtered ? new ArrayTupleBuilder(fieldCount + 1) : new ArrayTupleBuilder(fieldCount); 
 ArrayTupleBuilder tupleBuilder = filtered ? new ArrayTupleBuilder(fieldCount + 1) : new ArrayTupleBuilder(fieldCount); 
 ArrayTupleBuilder tupleBuilder = filtered ? new ArrayTupleBuilder(fieldCount + 1) : new ArrayTupleBuilder(fieldCount); 
 setExceptionHandler(runtimeFactories); 
 logExceptionCausingTuple(tupleIndex, th); 
 public void open() throws HyracksDataException { 
 public void nextFrame(ByteBuffer buffer) throws HyracksDataException { 
 try { flushIfNotFailed(); } finally { writer.close(); 
 } catch (Exception e) { flushWriter.fail(); throw e; 
 } catch (Exception e) { flushWriter.fail(); throw e; 
 IOperatorNodePushable op = new AbstractUnaryInputSinkOperatorNodePushable() { 
 closeException.addSuppressed(failFailure); 
 writer.close(); 
<|del|>
 boolean frameBeingUsed; 
 public OrderedIndexTestContext(ISerializerDeserializer[] fieldSerdes, IIndex index, boolean filtered) throws HyracksDataException { 
 BTreeLeafFrameType leafType, boolean filtered) throws Exception; 
 BTreeLeafFrameType leafType, boolean filtered) throws Exception; 
 private void executeHttpRequest(OutputFormat fmt, String statement, Map<String, Object> variableCtx, String reqType, File testFile, File expectedResultFile, File actualResultFile, MutableInt queryCount, String extension) 
 public void executeQuery(OutputFormat fmt, String statement, Map<String, Object> variableCtx, String reqType, File testFile, File expectedResultFile, File actualResultFile, MutableInt queryCount, List<CompilationUnit.Parameter> params, int numResultFiles) throws Exception { 
<|del|> 
 throws HyracksDataException { //Redundant info from after 
 public void beforeOperation(LSMOperationType opType) throws HyracksDataException { //Not interested in this 
 throws HyracksDataException { //Redundant info from after 
 public void setNumOfMutableComponents(int count) { //Not interested in this 
 public List<ILSMComponent> getLastOldComponents() { 
 public ILSMDiskComponent getLastNewComponent() { 
<|del|> 
 builder.setIMergeAggregationExpressionFactory(new MergeAggregationExpressionFactory()); builder.setPartialAggregationTypeComputer(new PartialAggregationTypeComputer()); builder.setExpressionTypeComputer(ExpressionTypeComputer.INSTANCE); builder.setMissableTypeComputer(MissableTypeComputer.INSTANCE); 
 public Pair<IReturningStatement, Integer> reWriteQuery(List<FunctionDecl> declaredFunctions, MetadataProvider metadataProvider, IReturningStatement q, SessionConfig conf) throws AsterixException { 
 return new ConnectorApiServlet(ctx, paths, appCtx); 
 } webManager.stop(); 
 } webManager.stop(); 
 public Pair<IReturningStatement, Integer> reWriteQuery(List<FunctionDecl> declaredFunctions, MetadataProvider metadataProvider, IReturningStatement q, SessionConfig conf) throws AsterixException { if (q == null) { return null; } 
 if (rwQ != null || (statement != null && statement.getKind() == Statement.Kind.LOAD)) { LogicalOperatorPrettyPrintVisitor pvisitor = new LogicalOperatorPrettyPrintVisitor(conf.out()); PlanPrettyPrinter.printPlan(plan, pvisitor, 0); 
 return new DdlApiServlet(ctx, paths, appCtx, ccExtensionManager.getSqlppCompilationProvider(), getStatementExecutorFactory(), componentProvider); case Servlets.RUNNING_REQUESTS: return new QueryCancellationServlet(ctx, paths); 
<|del|> 
 /** * This test is the LSMBTreeMergeTest but using a filter, and at each step of the filter's lifecycle its value is * checked against computed min/maxes from the check tuples. */ 
 ResultMetadata outMetadata, Stats stats, String clientContextId, IStatementExecutorContext ctx) throws Exception; 
 ResultMetadata outMetadata, Stats stats, String clientContextId, IStatementExecutorContext ctx) throws Exception; 
 ResultReader resultReader = new ResultReader(getHyracksDataset(), rsmd.getLeft(), rsmd.getMiddle()); 
 CompletableFuture<IMessage> future = mb.deregisterFuture(requestMessageId); if (future != null) { future.complete(this); 
 return new QueryServiceServlet(ctx, paths, appCtx, ccExtensionManager.getSqlppCompilationProvider(), 
 protected void configureServers() throws Exception { // override to start web services on NC nodes 
 protected void configureServers() throws Exception { // override to start web services on NC nodes 
 public List<ICachedPage> getLSNUpdates() { 
 public List<ICachedPage> getNSNUpdates() { 
 if (th instanceof HyracksDataException) { if (((HyracksDataException) th).getErrorCode() == ErrorCode.RECORD_READER_MALFORMED_INPUT_STREAM) { 
 LOGGER.log(Level.WARNING, e.getMessage(), e); 
 } catch (Exception e) { 
 } catch (Exception e) { 
 e.printStackTrace(); LOGGER.warning(e.getMessage()); 
 e.printStackTrace(); LOGGER.warning(e.getMessage()); 
 if (foundTuple) { 
 if (foundTuple) { 
 if (foundIn < 0) { 
 if (foundIn < 0) { 
 if (accessorIndex < 0) { 
 if (accessorIndex < 0) { 
 // Replace expr corresponding to original variable in the original assign with a get-item on // newVarFromExpression. 
 private Deque<Map<Integer, LogicalVariable>> stack = new ArrayDeque<>(); 
<|del|> 
 Thread.sleep(8000); 
import org.apache.hyracks.api.dataflow.value.IBinaryComparatorFactory; import org.apache.hyracks.api.dataflow.value.ILinearizeComparatorFactory; import org.apache.hyracks.api.dataflow.value.ISerializerDeserializer; import org.apache.hyracks.api.dataflow.value.ITypeTraits; import org.apache.hyracks.api.dataflow.value.RecordDescriptor; 
 functionSignature.getArity()), isFunctional); 
<|del|> 
 public JobId startJob(JobId jobId, Map<byte[], byte[]> contextRuntTimeVarMap) throws Exception; 
 EnumSet<JobFlag> jobFlags, JobId jobId, Map<byte[], byte[]> contextRuntimeVarMap, 
 public void startTasks(JobId jobId, List<TaskAttemptDescriptor> taskDescriptors, Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, Set<JobFlag> flags) throws Exception; 
 public void cancelJob(JobId jobId) throws Exception; public JobId distributeJob(byte[] acggfBytes) throws Exception; public JobId destroyJob(JobId jobId) throws Exception; 
 return "Context Variable: " + expr.getValue(); 
 public void cancelJob(JobId jobId) throws Exception; public JobId distributeJob(byte[] acggfBytes) throws Exception; public JobId destroyJob(JobId jobId) throws Exception; 
 public void startTasks(JobId jobId, List<TaskAttemptDescriptor> taskDescriptors, Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, Set<JobFlag> flags) throws Exception; 
 * We use a binary hash function that promotes numeric types (tinyint,smallint,integer,bigint,float) to double * if requested. 
 // Get a LONG (bigint) value from numeric types array. We assume the specific location of a byte array // contains the type tag. 
 throw new TypeMismatchException(funcName, argIndex, tag, ATypeTag.TINYINT, ATypeTag.SMALLINT, ATypeTag.INTEGER, ATypeTag.BIGINT, ATypeTag.FLOAT, ATypeTag.DOUBLE); 
 throw new TypeMismatchException(funcName, argIndex, tag, ATypeTag.TINYINT, ATypeTag.SMALLINT, ATypeTag.INTEGER, ATypeTag.BIGINT, ATypeTag.FLOAT, ATypeTag.DOUBLE); 
 throw new TypeMismatchException(funcName, argIndex, tag, ATypeTag.TINYINT, ATypeTag.SMALLINT, ATypeTag.INTEGER, ATypeTag.BIGINT, ATypeTag.FLOAT, ATypeTag.DOUBLE); 
 if (fieldTypes[i].getTypeTag() == ATypeTag.RECORD) { 
 throw new TypeMismatchException(funcName, argIndex, tag, ATypeTag.TINYINT, ATypeTag.SMALLINT, ATypeTag.INTEGER, ATypeTag.BIGINT, ATypeTag.FLOAT, ATypeTag.DOUBLE); 
 ATypeTag.TINYINT, ATypeTag.SMALLINT, ATypeTag.INTEGER, ATypeTag.BIGINT, ATypeTag.FLOAT, ATypeTag.DOUBLE); 
 // Get a LONG (bigint) value from numeric types array. We assume the specific location of a byte array // contains the type tag. 
 ATypeTag.TINYINT, ATypeTag.SMALLINT, ATypeTag.INTEGER, ATypeTag.BIGINT, ATypeTag.FLOAT, ATypeTag.DOUBLE); 
 ATypeTag.TINYINT, ATypeTag.SMALLINT, ATypeTag.INTEGER, ATypeTag.BIGINT, ATypeTag.FLOAT, ATypeTag.DOUBLE); 
 throw new IOException("Can't convert integer types. The target type should be one of " + "tinyint/smallint/integer/bigint."); 
import static org.apache.hyracks.tests.am.btree.DataSetConstants.filterCmpFactories; import static org.apache.hyracks.tests.am.btree.DataSetConstants.filterTypeTraits; 
 ILSMIndex primaryIndex = dsInfo.getPrimaryIndex(); 
<|del|> 
 } for (ILSMIndex index : indexes) { if (index.isPrimaryIndex()) { index.getMergePolicy().diskComponentAdded(index, false); break; } } 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 public boolean isMergeLagging(ILSMIndex index) throws HyracksDataException, IndexException; 
 executor = new SchedulerThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), threadFactory); 
 throw new IllegalStateException("Inconsistent memory component state for dataset " + datasetID); 
 throw new IllegalArgumentException("Mismatched operation group type. Operation type" + operation.getIOOpertionType() + " group operation type: " + this.operationType); 
 throw new IllegalArgumentException("Mismatched operation group type. Operation type" + operation.getIOOpertionType() + " group operation type: " + this.operationType); 
<|del|> 
 btreeFields, filterFields, durable, (IMetadataPageManagerFactory) opDesc.getPageManagerFactory(), partition); 
 int[] rtreeFields, int[] filterFields, boolean durable, boolean isPointMBR, IBufferCache diskBufferCache, int partition) throws HyracksDataException { 
 int[] rtreeFields, int[] buddyBTreeFields, int[] filterFields, boolean durable, boolean isPointMBR, int partition) throws HyracksDataException { 
 int[] rtreeFields, int[] filterFields, boolean durable, boolean isPointMBR, int partition) throws HyracksDataException { 
 public boolean isCorrelated() { 
 dataset.indexDataflowHelperFactory(this, theIndex, itemType, metaType, 
 IIndexDataflowHelperFactory indexDataflowHelperFactory = dataset.indexDataflowHelperFactory(this, secondaryIndex, recType, metaType, compactionInfo.first, compactionInfo.second); 
 String estr = e.toString(); GlobalConfig.ASTERIX_LOGGER.log(Level.SEVERE, estr, e); responseMsg.setError(new Exception(estr)); 
 LOGGER.log(Level.WARNING, e.toString(), e); 
 return Byte.toString(value); 
 RecordDescriptor inputRecDesc, IndexOperation op, boolean isPrimary, IIndexDataflowHelperFactory indexHelperFactory, IModificationOperationCallbackFactory modCallbackFactory, ITupleFilterFactory tupleFilterFactory) throws HyracksDataException { 
 IIndexDataflowHelperFactory dataflowHelperFactory, int[] deletedFiles, int[] fieldPermutation, float fillFactor, boolean verifyInput, long numElementsHint, boolean checkIfEmpty) { 
 public ExternalIndexBulkModifyOperatorNodePushable(IIndexDataflowHelperFactory indexHelperFactory, IHyracksTaskContext ctx, int partition, int[] fieldPermutation, float fillFactor, boolean verifyInput, long numElementsHint, boolean checkIfEmpty, RecordDescriptor inputRecDesc, int[] deletedFiles) throws HyracksDataException { 
 int[] keyFields, boolean lowKeyInclusive, boolean highKeyInclusive, IIndexDataflowHelperFactory indexHelperFactory, boolean retainInput, boolean retainMissing, IMissingWriterFactory missingWriterFactory, ISearchOperationCallbackFactory searchCallbackFactory, int[] minFilterFieldIndexes, int[] maxFilterFieldIndexes, int version) { 
 public static JobSpecification buildCommitJob(Dataset ds, List<Index> indexes, MetadataProvider metadataProvider) throws AlgebricksException { 
 int[] fieldPermutation, IIndexDataflowHelperFactory indexHelperFactory, IMissingWriterFactory missingWriterFactory, 
 int[] fieldPermutation, IIndexDataflowHelperFactory indexHelperFactory, ITupleFilterFactory tupleFilterFactory, IModificationOperationCallbackFactory modificationOpCallbackFactory, int[] prevValuePermutation) { 
 IIndexDataflowHelperFactory secondaryHelperFactory = new IndexHelperFactory(storageManager, secondarySplitProvider); 
 public IndexDropOperatorDescriptor(IOperatorDescriptorRegistry spec, IIndexDataflowHelperFactory dataflowHelperFactory) { 
 IIndexDataflowHelperFactory indexHelperFactory, IStorageManager storageManager) throws HyracksDataException { 
<|del|> 
 protected abstract void performOpOnIndex(IIndexDataflowHelper indexDataflowHelper, IHyracksTaskContext ctx) throws HyracksDataException; 
 public static JobSpecification dropDatasetJobSpec(Dataset dataset, MetadataProvider metadataProvider) 
 * 
 // The previous resource Id needs to be removed since calling IIndex.create() may possibly destroy any // physical artifact that the LocalResourceRepository is managing (e.g. a file containing the resource Id). 
 diskFileMapProvider, fieldCount, rtreeCmpFactories, btreeComparatorFactories, linearizer, comparatorFields, linearizerArray, 0, mergePolicy, opTracker, ioScheduler, ioOpCallback, filterFactory, 
 * 
 public synchronized static IOManager getIOManager() throws HyracksDataException { 
 ILocalResourceRepositoryFactory localResourceRepositoryFactory = new TransientLocalResourceRepositoryFactory(); 
<|del|> 
 public synchronized static IOManager getIOManager() throws HyracksDataException { 
 /** the input record type can be an union type * for the case when it comes from a subplan or left-outer join */ 
 void handle(IStatementExecutor queryTranslator, AqlMetadataProvider metadataProvider, IHyracksClientConnection hcc) throws Exception; 
 public static final String EXECUTOR_SERVICE_ATTR = "org.apache.asterix.EXECUTOR_SERVICE"; 
 private final AtomicLong futureIdGenerator; private final LongObjectMap<MessageFuture> futureMap; 
<|del|> 
 resultPointable.set(result, 0, result.length); 
 public StartJobFunction(DeploymentId deploymentId, byte[] acggfBytes, Set<JobFlag> jobFlags, JobId jobId, 
 for (Entry<byte[], byte[]> entry : vars.entrySet()) { byte[] key = entry.getKey(); 
 return empty; 
 EnumSet<JobFlag> jobFlags, JobId jobId, IResultCallback<JobId> callback, boolean predestributed) { 
 Set<JobFlag> flags, Map<byte[], byte[]> jobParameters) throws Exception; 
 return new byte[0]; 
 IStatementExecutor.ResultDelivery delivery, IStatementExecutor.Stats stats, RequestParameters param, String handleUrl, long[] outExecStartEnd) throws Exception { 
 IStatementExecutor.Stats stats, RequestParameters param, String handleUrl, long[] outExecStartEnd) throws Exception { 
 IStatementExecutor.Stats stats, RequestParameters param, String handleUrl, long[] outExecStartEnd) throws Exception { 
 RuntimeDataException.create(ErrorCode.INDEX_NOT_ALIGNED, lsmIndex.toString(), index.toString()); 
<|del|> 
 RuntimeDataException.create(ErrorCode.INDEX_NOT_ALIGNED, lsmIndex.toString(), index.toString()); 
 private static ITypeTraits[] getTypeTraits(MetadataProvider metadataProvider, Dataset dataset, Index index, 
 && index.getIndexName().equals(IndexingConstants.getFilesIndexName(dataset.getDatasetName()))) { 
 if (index.getIndexName().equals(IndexingConstants.getFilesIndexName(dataset.getDatasetName()))) { 
 int numPrimaryKeys = dataset.getPrimaryKeys().size(); 
<|del|> 
 new MutableObject<>(new VariableReferenceExpression(secondaryMap.getPropagateIndexMinFilterVar())), new MutableObject<>(new VariableReferenceExpression(secondaryMap.getPropagateIndexMaxFilterVar()))); 
 public static boolean isType(ITupleReference tuple, int fieldIdx, byte tag) { 
 public static boolean isType(ITupleReference tuple, int fieldIdx, byte tag) { 
 addFunction(IF_MISSING_OR_NULL, IfMissingOrNullTypeComputer.IF_MISSNG_OR_NULL, true); addFunction(IF_MISSING, IfMissingOrNullTypeComputer.IF_MISSING, true); addFunction(IF_NULL, IfMissingOrNullTypeComputer.IF_NULL, true); 
 result.set(nullBytes, 0, nullBytes.length); 
 private static final String KEY_FEED_NAME = "Feed Name"; 
 int dimension, List<String> filterFieldName, boolean isPointMBR) throws AlgebricksException; 
 int dimension, List<String> filterFieldName, boolean isPointMBR) throws AlgebricksException { 
 ControllerConfig.Option.DEFAULT_DIR .setDefaultValue(FileUtil.joinPath(System.getProperty("java.io.tmpdir"), "asterixdb")); 
 public JobId startJob(long predestributedId, Map<byte[], byte[]> jobParameters) throws Exception; 
 private static final String REQUIRED_CONFIGS = ""; protected Map<String, String> config; 
 super(inputStream); this.config = config; 
 private static final String REQUIRED_CONFIGS = ""; 
 private static final String REQUIRED_CONFIGS = "quote"; 
 if (quoteString.length() != 1) { 
 private static final String REQUIRED_CONFIGS = ""; 
 public void configure() throws HyracksDataException { 
<|del|> 
 if (configKey.length() > 0 && !configuration.containsKey(configKey)) { 
<|del|>
 public FeedMessagingOperatorPushable(IHyracksTaskContext ctx, IRecordDescriptorProvider recordDescriptorProvider, Map<String, String> feedPolicyProperties, ActivityId activityId) throws HyracksDataException { 
 public FeedMessagingOperatorPushable(IHyracksTaskContext ctx, IRecordDescriptorProvider recordDescriptorProvider, Map<String, String> feedPolicyProperties, ActivityId activityId) throws HyracksDataException { 
<|del|>
 public JobId startJob(long predestributedId, Map<byte[], byte[]> jobParameters) throws Exception; 
 Set<JobFlag> flags, Map<byte[], byte[]> jobParameters, long predistributedId) throws Exception; 
 private void assignFilterFromSecondaryUnnestMap(AbstractLogicalOperator op, Dataset dataset, 
 throw new CompilationException(ErrorCode.COMPILATION_ILLEGAL_STATE, String.valueOf(quantifier)); 
 // 'missing' and 'null' cannot be in the output 
 GlobalConfig.ASTERIX_LOGGER.log(Level.SEVERE, "Unexpected exception", e); responseMsg.setError(new Exception(e.toString())); 
<|del|> 
 } if (obj == null) { 
 } if (getClass() != obj.getClass()) { 
 return false; } 
 } if (minID != other.minID) { 
 return false; } 
 ControllerConfig.Option.DEFAULT_DIR .setDefaultValue(((String) ControllerConfig.Option.DEFAULT_DIR.defaultValue()) .replace(System.getProperty("java.io.tmpdir"), "${java.io.tmpdir}/")); 
 private void propagateFilterInSecondaryUnnsetMap(UnnestMapOperator secondaryUnnest, IAType filterType, 
 private void setFilterValueFromSecondaryUnnestMap(UnnestMapOperator primaryOp, 
 import java.io.DataOutput; import java.io.File; 
<|del|> 
 // The firstLSN is always the lsn of the currently being flushed component or the next // to be flushed when no flush operation is on going 
 List<ITupleReference> filterTuples = new ArrayList<ITupleReference>(); 
 aString.setValue(Integer.toString(function.getReferenceCount())); 
 boolean isExclusiveLatchNodes(); 
 private void cleanupArtifacts() throws HyracksDataException { 
<|del|> 
<|del|> 
 public abstract void configure(AsterixInputStream inputStream, Map<String, String> config) throws HyracksDataException; 
 ccs.getWorkQueue().schedule(new DistributeJobWork(ccs, djf.getACGGFBytes(), predistributedId++, new IPCResponder<Long>(handle, mid))); 
 if (id == -1) { 
 ccs.getWorkQueue() .schedule(new DistributedJobFailureWork(rdjf.getPredistributedId(), rdjf.getNodeId())); 
<|del|> 
 // create output descriptor 
 if ("".equals(nodesString)) { 
 public void reset() { 
 boolean propagateFilter = unnestMap.propagateIndexFilter(); 
 minFilterFieldIndexes, maxFilterFieldIndexes, jobGenParams.getIsFullTextSearch()); 
 List<String> fieldName = getFieldNameFromSubAssignTree(optFuncExpr, descendantOp, varIndex, recType).second; 
 List<String> fieldName = getFieldNameFromSubAssignTree(optFuncExpr, descendantOp, varIndex, recType).second; 
 public void markPropagageIndexFilter() { this.propagateIndexFilter = true; 
 public boolean propagateIndexFilter() { 
<|del|> 
<|del|> 
 // If the source dataset doesn't exist, then it's a no-op. if (sourceDataset == null) { return; } 
 // Starts another transaction for switching the metadata entity. mdTxnCtx = MetadataManager.INSTANCE.beginTransaction(); 
 lsmHarness.batchOperate(ctx, accessor, tuple, processor, frameOpCallback); 
 BloomFilterFactory bloomFilterFactory, IComponentFilterHelper filterHelper) { 
 List<ILSMDiskComponent> immutableComponents = new ArrayList<>(index.getImmutableComponents()); 
 List<ILSMDiskComponent> immutableComponents = new ArrayList<>(index.getImmutableComponents()); 
 /** * Return the component Id of this disk component from its metadata * @return * @throws HyracksDataException */ ILSMDiskComponentId getComponentId() throws HyracksDataException; 
 /** * Return the component Id of this disk component from its metadata * @return * @throws HyracksDataException */ ILSMDiskComponentId getComponentId() throws HyracksDataException; 
 /** * Return the component Id of this disk component from its metadata * @return * @throws HyracksDataException */ ILSMDiskComponentId getComponentId() throws HyracksDataException; 
 public static final String REBALANCE = "/admin/rebalance"; 
 IOperatorDescriptor keyProviderOp = DatasetUtil.createDummyKeyProviderOp(spec, dataset, metadataProvider); 
 AbstractOperatorDescriptor keyProviderOp = createDummyKeyProviderOp(spec); 
 public static final int RESOURCE_DOES_NOT_EXIST = 55; 
<|del|> 
 throws Exception { String nodeGroup = ngName; 
 if (e.getErrorCode() != ErrorCode.DUPLICATE_KEY) { 
 for (List<LogicalVariable> vars : compareVars) { 
 for (int i = 0; i < extraVars.size(); i++) { 
 for (int i = 0; i < extraVars.size(); i++) { 
 public static synchronized int generateDatasetId() throws AsterixException { if (id == Integer.MAX_VALUE) { throw new AsterixException(ErrorCode.DATASET_ID_EXHAUSTED); } return ++id; 
 throw HyracksDataException.create(ErrorCode.POLYGON_INVALID, e, polygon); 
 DoubleSerializerDeserializer.write(y, out); 
 } catch (AsterixException | IOException e) { 
 } catch (AsterixException | IOException e) { 
 private boolean writeField(Object fieldObj, IAType fieldType, DataOutput out) throws IOException, JSONException { // save fieldType for closed type check String nstt; 
<|del|> 
<|del|> 
 firstFlusher.waitUntilCount(1); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 merger.waitUntilCount(1); 
 firstFlusher.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 firstFlusher.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledMergesCount(expectedCancelledMerges); 
<|del|> 
 public static final String JAVA_IO_TMPDIR = "java.io.tmpdir"; 
 FileUtil.joinPath(System.getProperty(JAVA_IO_TMPDIR), "hyracks")),; 
 ControllerConfig.Option.DEFAULT_DIR .setDefaultValue(FileUtil.joinPath(System.getProperty(ControllerConfig.TMP_DIR), "asterixdb")); 
 FileUtil.joinPath(System.getProperty(TMP_DIR), "hyracks")),; 
 ? TypeUtil.createEnforcedType(aRecordType, metaRecordType, IteratorUtils.toList(IteratorUtils.singletonIterator(index))) 
 Set<String> ncs) throws AsterixException { 
 private final Random random = new Random(); 
 public String resolveNode(ICcApplicationContext appCtx, String value, Map<InetAddress, Set<String>> ncMap, Set<String> ncs) throws AsterixException { if (ncs.contains(value)) { return value; } InetAddress ipAddress = null; 
<|del|> 
 NodeResolver.updateNCs(); 
 NodeResolver.updateNCs(); 
 NodeResolver.updateNCs(); 
 return METADATA.equals(dvName) ? Collections.emptyList() : MetadataManager.INSTANCE.getDataverseDatasets(mdTxnCtx, dvName); 
 return METADATA.equals(dvName) ? Collections.emptyList() : MetadataManager.INSTANCE.getDataverseDatasets(mdTxnCtx, dvName); 
 private final long resourceId; 
 IIndexBulkLoader createComponentBulkLoader(ILSMDiskComponent component, float fillFactor, boolean verifyInput, long numElementsHint, boolean checkIfEmptyIndex, boolean withFilter) throws HyracksDataException; 
 setExceptionHandler(runtimeFactories); 
 Task targetTS = activityPlanMap.get(p.getLeft().getActivityId()).getTasks()[p.getLeft() 
 for (Task t : tc.getTasks()) { 
 return new AbstractUnaryInputSinkOperatorNodePushable() { 
 ILSMDiskComponentBulkLoader componentBulkLoader = createComponentBulkLoader(component, 1.0f, false, 0L, false, false); 
 ILSMDiskComponentBulkLoader componentBulkLoader = createComponentBulkLoader(component, 1.0f, false, 0L, false, false); 
 public LSMTreeRefrencingTupleWriterFactory(ITreeIndexTupleWriterFactory factory) { 
 boolean antimatterAware, boolean isAntimatter) { 
 // Flushes the remaining chunks of the all spilled partitions to the disk. 
 // Adjusts the hash table size hashTableByteSizeForInMemTuples += expectedHashTableByteSizeIncrease; 
 "\t\t>>>Case 2.1.2 - SWITCHED to NLJ RecursiveHHJ WITH (isLeftOuter || build<probe)" + " - [Level " + level + "]"); 
<|del|> 
 throw new RuntimeDataException(ErrorCode.NC_REQUEST_TIMEOUT, timeout / 1000.0); 
 throw new RuntimeDataException(ErrorCode.COMPILATION_ILLEGAL_STATE, String.valueOf(right.getKey())); 
 // Adjusts the hash table size hashTableByteSizeForInMemTuples += expectedHashTableByteSizeIncrease; 
<|del|> 
 * @return A file reference based on the mounting point of {@code ioDeviceId} and the passed {@code relativePath} 
 READABLE_MERGING 
<|del|> 
 break; case ROLLBACK: for (ILSMComponent c : ctx.getComponentHolder()) { if (c.getType() == LSMComponentType.DISK) { lsmIndex.removeDiskComponent((ILSMDiskComponent) c); } } default: break; } 
 * @param map * a map representing the json object 
 * 
 final String timeStamp = transactionFileName .substring(transactionFileName.indexOf(TRANSACTION_PREFIX) + TRANSACTION_PREFIX.length()); 
 public static final byte[] EMPTY = new byte[0]; 
<|del|> 
 private RTreeOpContext createOpContext(IModificationOperationCallback modificationCallback, int[] nonIndexFields) { 
 if (allFields != null) { 
 } else { 
 } else { 
 public void resetLogTuple(ITupleReference newTuple) { 
 int maxPageId = freePageManager.getMaxPageId(ctx.getMetaFrame()); 
<|del|> 
 } appender.write(writer, true); 
 // Makes the space for the in-memory hash table (some partitions may need to be spilled to the disk // during this step in order to make the space.) 
 hashTableByteSizeForInMemTuples = SerializableHashTable.getExpectedTableByteSize(inMemTupCount, 
 processor.process(tuple, i); i++; 
<|del|> 
<|del|> 
 setAntiMatterTuple(diskTuple, outputElement.getCursorIndex()); 
 throw HyracksDataException.create(ErrorCode.CANNOT_FIND_MATTER_TUPLE_FOR_ANTI_MATTER_TUPLE); 
 return elementA.getCursorIndex() > elementB.getCursorIndex() ? -1 : 1; 
 ILSMDiskComponent newComponent = null; 
 firstFlusher.waitUntilCount(1); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledMergesCount(expectedCancelledMerges); 
 firstFlusher.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 firstFlusher.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 merger.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledMergesCount(expectedCancelledMerges); 
<|del|> 
<|del|> 
 int maxPageId = freePageManager.getMaxPageId(ctx.getMetaFrame()); 
 for (int i = 0; i < intersect.getNumInput(); i++) { 
 for (int i = 0; i < intersect.getNumInput(); i++) { 
 List<UnnestMapOperator> primaryUnnestMapOps = new ArrayList<>(); 
 firstSearcher.waitUntilEntered(); 
 secondSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 merger.waitUntilCount(1); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledMergesCount(expectedCancelledMerges); 
 firstFlusher.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 firstFlusher.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledFlushesCount(expectedCancelledFlushes); 
 merger.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledMergesCount(expectedCancelledMerges); 
 merger.waitUntilCount(1); 
 firstSearcher.waitUntilEntered(); 
 TestLsmBtreeIoOpCallbackFactory.INSTANCE.waitUntilCancelledMergesCount(expectedCancelledMerges); 
 firstValidator.waitUntilCount(1); 
 rollerback.waitUntilTaskInWaitingState(); 
<|del|> 
<|del|> 
 component.decommission(); 
 ((ILSMDiskComponent) c).logRollback(); 
 downstreamOpen = true; 
 protected ICCApplication createCCApplication() { return new CCApplication(); 
 } appender.write(writer, true); 
 writer.fail(); if (failCalledByUpstream) { throw HyracksDataException.create(ErrorCode.FAIL_ON_FAILED_WRITER); } failCalledByUpstream = true; 
 public void closeBuild() throws HyracksDataException { 
 } catch (Exception e) { flushWriter.fail(); throw e; 
<|del|> 
 if (!returnDeletedTuples && !completed && isDeleted(checkElement)) { 
 } catch (HyracksDataException e) { if (LOGGER.isLoggable(Level.FINEST)) { LOGGER.log(Level.FINEST, e.toString(), e); } 
 try { flushIfNotFailed(); } finally { writer.close(); 
 private static String ONE_TO_ONE_CONNECTOR = "org.apache.hyracks.dataflow.std.connectors.OneToOneConnectorDescriptor"; 
 public void closeBuild() throws HyracksDataException { 
 IOperatorNodePushable op = new AbstractUnaryInputSinkOperatorNodePushable() { 
 IOperatorNodePushable op = new AbstractUnaryInputUnaryOutputOperatorNodePushable() { 
 } catch (Exception e) { flushWriter.fail(); throw e; 
 throw HyracksDataException.create(th); 
 writer.close(); 
 writer.close(); 
 } } catch (Throwable th) { writer.fail(); closeException = new HyracksDataException(th); 
 // ITypeTraits REGISTERED_CLASSES.put("FixedLengthTypeTrait", FixedLengthTypeTrait.class); REGISTERED_CLASSES.put("VarLengthTypeTrait", VarLengthTypeTrait.class); 
 //Using static method (fromJson) Method method = clazz.getMethod(DESERIALIZATION_METHOD, IPersistedResourceRegistry.class, JsonNode.class); 
 return new ObjectMapper().readValue(json, Checkpoint.class); 
 String mountPoint = devices.get(i).getMount().getPath(); 
 if (!mountPoint.endsWith(File.separator)) { mountPoints[i] = mountPoint + File.separator; 
 resourceCache.invalidate(relativePath); 
 assert dataset.getDatasetType() == DatasetType.INTERNAL; 
 assert dsType == DatasetType.INTERNAL; 
 public LSMSecondaryCreationTupleProcessorNodePushable(IHyracksTaskContext ctx, RecordDescriptor inputRecDesc, IMissingWriterFactory missingWriterFactory, int numTagFields, int numSecondaryKeys, int numPrimaryKeys, boolean hasBuddyBTree) throws HyracksDataException { 
 protected void resetSearchPredicate(int tupleIndex) { // do nothing // no need to set search predicate for disk component scan operation 
 ILSMIndexAccessor accessor = index.createAccessor(NoOpOperationCallback.INSTANCE, 
 public void diskComponentAdded(final ILSMIndex index, boolean fullMergeIsRequested) throws HyracksDataException, IndexException { 
<|del|> 
 ISearchOperationCallback searchCallback, int[] nonIndexFields) throws HyracksDataException { 
 private PermutingTupleReference logTuple; // Optional, for filtered LSM Index transaction support 
 * This number is taken from HBase compaction policy 
 * @return a pair of indexes indicating the start and end position of the sequence * otherwise, return null if no sequence is found 
 } long startComponentSize = immutableComponents.get(i).getComponentSize(); 
 * Static variables */ 
<|del|> 
<|del|> 
 RegisterResultPartitionLocationFunction fn = new RegisterResultPartitionLocationFunction( 
 ReportResultPartitionWriteCompletionFunction fn = new ReportResultPartitionWriteCompletionFunction( 
 void registerNode() throws Exception; void updateMaxJobId(JobId jobId); 
 throw HyracksDataException.create(ErrorCode.POLYGON_INVALID, e, polygon); 
 return mergableIndexes == null ? 0 : mergableIndexes.getRight() - mergableIndexes.getLeft() + 1; 
 List<ILSMDiskComponent> mergableComponents = new ArrayList<>(immutableComponents.subList(startIndex, endIndex + 1)); 
 ISerializerDeserializer[] enforcedRecFields = new ISerializerDeserializer[1 + numPrimaryKeys + numFilterFields]; 
<|del|> 
<|del|> 
 private final long maxJobId; 
 execute(writer, false, tryBlock, extraCatch, extraFinally); 
 throw new UnsupportedOperationException(); 
 IFunctionDescriptor castFuncDesc = FunctionManagerHolder.getFunctionManager() .lookupFunction(strictCast ? BuiltinFunctions.CAST_TYPE : BuiltinFunctions.CAST_TYPE_LAX); 
<|del|> 
 public boolean dirExists(); 
 delete(fileRef.getFile()); 
<|del|> 
 throw HyracksDataException.create(ErrorCode.CANNOT_DELETE_FILE, e, file.getAbsolutePath()); 
 fileRef.getFile().getParentFile().mkdirs(); 
 throw HyracksDataException.create(ErrorCode.FILE_DOES_NOT_EXIST, fileRef.getAbsolutePath()); 
 public synchronized void purge() throws HyracksDataException { 
 public int openFile(FileReference fileRef) throws HyracksDataException { openFileCount.incrementAndGet(); 
 public void deleteFile(FileReference file) throws HyracksDataException { deleteFileCount.incrementAndGet(); 
 throw HyracksDataException.create(ErrorCode.NO_MAPPING_FOR_FILENAME, fileRef); 
 throw HyracksDataException.create(ErrorCode.FILE_ALREADY_EXISTS, fileRef.getAbsolutePath()); 
 * @return true if the index dir exists, false otherwise 
 protected static FilenameFilter bloomFilterFilter = new FilenameFilter() { @Override public boolean accept(File dir, String name) { return !name.startsWith(".") && name.endsWith(BLOOM_FILTER_STRING); 
 throw HyracksDataException.create(ErrorCode.CANNOT_PURGE_ACTIVE_INDEX); 
 private ConcurrentMap<Integer, FileReference> id2nameMap = new ConcurrentHashMap<>(); private ConcurrentMap<FileReference, Integer> name2IdMap = new ConcurrentHashMap<>(); 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) {//NOSONAR 
 public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { 
 public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { 
 public OrderedLinearizeComparatorFactory(IBinaryComparatorFactory factory, boolean ascending) { 
 return new PersistentLocalResourceRepository(ioManager, ioManager.getIODevices(), nodeId, metadataProperties, resourceRegistry); 
<|del|> 
<|del|> 
 indexAccessor.forceDelete(logRecord.getNewValue()); } else if (logRecord.getNewOp() == AbstractIndexModificationOperationCallback.UPSERT_BYTE) { // redo, upsert the new value indexAccessor.forceUpsert(logRecord.getNewValue()); 
 public void open() throws HyracksDataException { //Get local resource file 
 indexAccessor.forceDelete(logRecord.getNewValue()); } else if (logRecord.getNewOp() == AbstractIndexModificationOperationCallback.UPSERT_BYTE) { // redo, upsert the new value indexAccessor.forceUpsert(logRecord.getNewValue()); 
 // Executes a metadata transaction. private static void runMetadataTransaction(MetadataProvider metadataProvider, Work work) throws Exception { 
 private static void dropSourceDataset(Dataset source, MetadataProvider metadataProvider, 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Thread.sleep(waitTime); 
<|del|> 
 public boolean dirExists(); 
<|del|>
<|del|>
 return -1; 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 // Method signature enforced by IPersistedResourceRegistry for deserializiation public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { //NOSONAR 
 throw HyracksDataException.create(ErrorCode.POLYGON_INVALID, e, polygon); 
 protected AlgebricksMetaOperatorDescriptor createCastOp(JobSpecification spec, DatasetType dsType, boolean strictCast) throws AlgebricksException { 
<|del|> 
<|del|> 
 IOperatorDescriptor op = new LSMSecondaryIndexCreationTupleProcessorOperatorDescriptor(spec, taggedSecondaryRecDesc, MissingWriterFactory.INSTANCE, NUM_TAG_FIELDS, numSecondaryKeyFields, numPrimaryKeyFields, hasBuddyBTree); 
 MetadataManager.INSTANCE.addNodegroup(mdTxnCtx, new NodeGroup(nodeGroup, new ArrayList<>(ncNames))); 
 * 
 * 
 @SuppressWarnings("squid:S1172") // unused parameter public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { 
 "Value must be less than or equal to the available number of nodes in cluster (" 
 public synchronized boolean cancelRemovePending(String nodeId) { 
 IToken token = tokenizer.getToken(); writeTuple(token, numTokens, i); 
 throw HyracksDataException.create(e); 
 throw HyracksDataException.create(e); 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : subJob.getConnectorOperatorMap().entrySet()) { 
 public void notify(ActiveEvent event) { // no op 
 public void sync() { // no op 
 public void unsubscribe() { // no op 
 public void subscribed(IActiveEntityEventsListener eventsListener) throws HyracksDataException { // no op 
 ILSMComponentFilter filter = operationalComponents.get(outputElement.cursorIndex).getLSMComponentFilter(); 
 throw HyracksDataException.create(ErrorCode.NO_INDEX_FOUND_WITH_RESOURCE_ID, resourceID); 
 void destroy() throws HyracksDataException; 
 try { indexHelper.destroy(); } catch (HyracksDataException e) { if (!failSliently) { throw e; } } 
 public LSMBTree(IIOManager ioManager, ITreeIndexFrameFactory insertLeafFrameFactory, 
<|del|> 
<|del|> 
 private static AIntervalAscPartialBinaryComparatorFactory getInstance() { 
 private static AIntervalDescPartialBinaryComparatorFactory getInstance() { 
 public ALinePartialBinaryComparatorFactory getInstance() { 
 public static final RawBinaryComparatorFactory INSTANCE = new RawBinaryComparatorFactory(); 
 public static final RawBinaryComparatorFactory INSTANCE = new RawBinaryComparatorFactory(); 
 public static final RawBinaryComparatorFactory INSTANCE = new RawBinaryComparatorFactory(); 
 private static NoOpIOOperationCallbackFactory getInstance() { 
 private static NoOpOperationTrackerFactory getInstance() { 
 } 
 public FloatPrimitiveValueProviderFactory getInstance() { 
 public IntegerPrimitiveValueProviderFactory getInstance() { 
public class InMemoryInvertedIndex implements IInvertedIndex { 
 @Option(name = "-p", aliases = "--partition-range-start", usage = "Starting partition number for the set of data generators (default = 0)") 
 @Option(name = "-pid", aliases = "--parition-id", usage = "The partition id in order to avoid key duplication", required = true) 
<|del|> 
 long bits = Double.doubleToLongBits(v); boolean zeroOrNaN = bits == BITS_ZERO_POS || bits == BITS_ZERO_NEG || bits == BITS_NAN; setBoolean(result, !zeroOrNaN); 
<|del|> 
 public static final NoOpDatasetRebalanceCallback INSTANCE = new NoOpDatasetRebalanceCallback(); 
 public static final NoOpDatasetRebalanceCallback INSTANCE = new NoOpDatasetRebalanceCallback(); 
 public static final NoOpDatasetRebalanceCallback INSTANCE = new NoOpDatasetRebalanceCallback(); 
 public void beforeRebalance(MetadataProvider metadataProvider, Dataset source, Dataset target, IHyracksClientConnection hcc) { 
 public void afterRebalance(MetadataProvider metadataProvider, Dataset source, Dataset target, IHyracksClientConnection hcc) { 
 System.out.println("Active Manager requested " + this.toString() + " Current Compacity: " + runtimes.size() + " " + Thread.currentThread().getName()); 
 System.out.println("Active runtime not found!" + this.toString()); 
 LOGGER.log(Level.INFO, "refreshStats called"); 
 LOGGER.log(Level.INFO, "returning immediately since state = " + state + " and statsRequestState = " + statsRequestState); 
 if (!functionFalsePositiveCheck.first) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 isIndexOnlyPlan = false; indexOnlyPlanInfo.first = isIndexOnlyPlan; 
 return false; } 
 return false; } 
 // Append output variables/types generated by the secondary-index search (not forwarded from input). 
 // If this is not a left-outer-join case, then we use UNNEST-MAP operator. 
 // The right (inner) subtree must have a datasource scan. if (rightSubTree.hasDataSourceScan()) { 
 if (getDataSourceRef() == null) { setDataSourceRef(subTreeOpRef); setDataSourceType(DataSourceType.EXTERNAL_SCAN); 
 getLog().error(e); 
 String internalFuncDescriptorClassName = CodeGenHelper.toInternalClassName(originalFuncDescriptorClassName); if (internalFuncDescriptorClassName.equals(DESCRIPTOR_SUPER_CLASS_NAME)) { 
 String internalEvaluatorFactoryClassName = CodeGenHelper.toInternalClassName(originalEvaluatorFactoryClassName); String targetEvaluatorFactoryClassName = CodeGenHelper.generateClassName(internalEvaluatorFactoryClassName, 
 private static final String METHOD_NAME = "createScalarEvaluator"; 
 private static final String METHOD_NAME = "createEvaluatorFactory"; 
 public ILogicalOperator createSecondaryToPrimaryPlan(Mutable<ILogicalExpression> conditionRef, 
 private static HashSet<FunctionIdentifier> secondLevelFuncIdents = new HashSet<>(); 
 Arrays.asList(new Pair<FunctionIdentifier, Boolean>(BuiltinFunctions.SPATIAL_INTERSECT, true))); 
 isIndexOnlyPlan = indexOnlyPlanInfo.getFirst(); 
<|del|> 
 public class ResourceType { 
 // Append output variables/types generated by the secondary-index search (not forwarded from input). 
 // If this is not a left-outer-join case, then we use UNNEST-MAP operator. 
 replacedFuncExprs.add(analysisCtx.getMatchedFuncExpr(exprIndex.first).getFuncExpr()); 
public final class FunctionCollection { 
 throws AlgebricksException { // The job gen parameters are transferred to the actual job gen via the UnnestMapOperator's function arguments. 
 // If this is not a left-outer-join case, then we use UNNEST-MAP operator. 
 public boolean analyzeFuncExprArgsAndUpdateAnalysisCtx(AbstractFunctionCallExpression funcExpr, 
 private static final List<Pair<FunctionIdentifier, Boolean>> FUNC_IDENTIFIERS = Collections.unmodifiableList( 
 isIndexOnlyPlan = indexOnlyPlanInfo.getFirst(); 
 private T1 first; private T2 second; private T3 third; private T4 fourth; 
 private T1 first; private T2 second; private T3 third; private T4 fourth; 
 private T1 first; private T2 second; private T3 third; private T4 fourth; 
 return introduceProjects(null, -1, opRef, Collections.<LogicalVariable> emptySet(), context); 
 protected boolean introduceProjects(AbstractLogicalOperator parentOp, int parentInputIndex, Mutable<ILogicalOperator> opRef, Set<LogicalVariable> parentUsedVars, IOptimizationContext context) throws AlgebricksException { 
 public static void resetLOJMissingPlaceholderVarInGroupByOp(AccessMethodAnalysisContext analysisCtx, LogicalVariable newMissingPlaceholderVaraible, IOptimizationContext context) throws AlgebricksException { 
 secondLevelFuncIdents.add(AsterixBuiltinFunctions.EDIT_DISTANCE_STRING_CONTAINS); 
 if (funcExpr.getFunctionIdentifier() == AsterixBuiltinFunctions.STRING_CONTAINS || funcExpr.getFunctionIdentifier() == AlgebricksBuiltinFunctions.FULLTEXT_CONTAINS) { 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 void reportPartitionFailure(JobId jobId, ResultSetId resultSetId, int partition, HyracksDataException cause) throws HyracksException; 
 public void reportResultPartitionFailure(JobId jobId, ResultSetId rsId, int partition) throws Exception; 
 public void reportResultPartitionFailure(JobId jobId, ResultSetId rsId, int partition) throws Exception; 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) { // No op 
<|del|> 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void writeOut(IFrameWriter writer, IFrame frame, boolean failed, HyracksDataException failureCause) throws HyracksDataException { 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 public void fail(HyracksDataException cause) throws HyracksDataException { // No op 
 // No op 
<|del|> 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : subJob .getConnectorOperatorMap().entrySet()) { 
 * 
 (ActiveNotificationHandler) metadataProvider.getApplicationContext().getActiveNotificationHandler(); 
 protected void jobCreated(ActiveEvent event) { // Do nothing 
 public static final NoOpDatasetRebalanceCallback INSTANCE = new NoOpDatasetRebalanceCallback(); 
 public static final NoOpDatasetRebalanceCallback INSTANCE = new NoOpDatasetRebalanceCallback(); 
 public static final NoOpDatasetRebalanceCallback INSTANCE = new NoOpDatasetRebalanceCallback(); 
 // Does nothing. 
 // Does nothing. 
<|del|> 
 final HyracksDataException cause = HyracksDataException.create(t); partitioner.fail(cause); throw cause; 
 writer.fail(); 
 writer.fail(); 
 // no op 
 final HyracksDataException cause = HyracksDataException.create(e); writer.fail(cause); throw cause; 
 } catch (Exception e) { 
 final HyracksDataException cause = HyracksDataException.create(e); startOfPipeline.fail(cause); throw cause; 
 final HyracksDataException cause = HyracksDataException.create(e); writer.fail(cause); throw cause; 
 } catch (HyracksException e) { LOGGER.log(Level.WARNING, e.getMessage(), e); 
 } catch (Throwable t) { frameWriter.fail(); throw t; 
 final HyracksDataException cause = HyracksDataException.create(e); appenderWrapper.fail(cause); throw cause; 
 writer.fail(); throw t; 
 final HyracksDataException cause = HyracksDataException.create(e); writer.fail(cause); throw cause; 
 if (frameOutputStream.getTupleCount() > 0) { 
 final HyracksDataException cause = HyracksDataException.create(t); mergeResultWriter.fail(cause); throw cause; 
 throw cause; 
 final HyracksDataException cause = HyracksDataException.create(e); flushWriter.fail(cause); throw cause; 
 final HyracksDataException cause = HyracksDataException.create(e); writer.fail(cause); throw cause; 
 final HyracksDataException cause = HyracksDataException.create(e); writer.fail(cause); throw cause; 
 final HyracksDataException cause = HyracksDataException.create(ex); writer.fail(cause); throw cause; 
 Mockito.doAnswer(failAnswer).when(writer).fail(Mockito.any()); 
 writer.fail(Mockito.any()); 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); 
 addIndent(indent).append("\"variables\":[\"" + op.getVariable() + "\"]"); 
 addIndent(indent).append("\"variables\":[\"" + op.getVariable() + "\"]"); 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); 
 AlgebricksAppendable plan = addIndent(indent).append("\"operator\":\"" + opSignature + "\""); if (op.getVariables().size() > 0) { 
 AlgebricksAppendable plan = addIndent(indent).append("\"operator\":\"" + opSignature + "\""); if (op.getVariables().size() > 0) { 
 AlgebricksAppendable plan = addIndent(indent).append("\"operator\":\"" + opSignature + "\""); if (op.getVariables().size() > 0) { 
 AlgebricksAppendable plan = addIndent(indent).append("\"operator\":\"" + opSignature + "\""); if (op.getVariables().size() > 0) { 
 for (LogicalVariable v : op.getVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); appendFilterInformation(plan, op.getMinFilterVars(), op.getMaxFilterVars(), indent); 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); appendFilterInformation(plan, op.getMinFilterVars(), op.getMaxFilterVars(), indent); 
 for (LogicalVariable v : op.getProjectVariables()) { if (!first) 
 for (LogicalVariable v : op.getProjectVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (op.getVariables().size() > 0) { 
 if (op.getVariables().size() > 0) { 
 for (LogicalVariable v : op.getVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (op.getDataSource() != null) { 
 addIndent(indent).append("\"data-source\":\"" + op.getDataSource() + "\""); 
 addIndent(indent).append("\"data-source\":\"" + op.getDataSource() + "\""); 
 addIndent(indent).append("\"data-source\":\"" + op.getDataSource() + "\""); 
 addIndent(indent).append("\"data-source\":\"" + op.getDataSource() + "\""); 
 List<LogicalVariable> maxFilterVars, Integer indent) throws AlgebricksException { 
 for (LogicalVariable v : minFilterVars) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (minFilterVars != null && maxFilterVars != null) { 
 if (minFilterVars != null && maxFilterVars != null) { 
 for (LogicalVariable v : maxFilterVars) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 addIndent(indent).append("\"value\":\"" + op.getMaxObjects().getValue().accept(exprVisitor, indent) + "\""); 
 addIndent(indent).append("\"offset\":\"" + offset.accept(exprVisitor, indent) + "\""); 
 addIndent(indent).append("\"offset\":\"" + offset.accept(exprVisitor, indent) + "\""); 
 if (op.getInputVariables().size() > 0) { 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (op.getOutputVariables().size() > 0) { 
 for (LogicalVariable v : op.getOutputVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 addIndent(indent).append("\"" + branchingExpression.getValue().accept(exprVisitor, indent) + "\""); 
 addIndent(indent).append(str("\"data-source\":\"" + op.getDataSource() + "\",\n")); 
 addIndent(indent).append(str("\"data-source\":\"" + op.getDataSource() + "\",\n")); 
 .append(op.getPayloadExpression().getValue().accept(exprVisitor, indent) + "\""); 
 .append(op.getPayloadExpression().getValue().accept(exprVisitor, indent) + "\""); 
 addIndent(indent).append("\"record-before-upsert\":\"" + op.getBeforeOpRecordVar() + "\""); if ((op.getBeforeOpAdditionalNonFilteringVars() != null)) { 
 addIndent(indent) .append("\"additional-before-upsert\":\"" + op.getBeforeOpAdditionalNonFilteringVars() + "\""); 
 addIndent(indent) .append("\"additional-before-upsert\":\"" + op.getBeforeOpAdditionalNonFilteringVars() + "\""); 
 addIndent(indent) .append("\"additional-before-upsert\":\"" + op.getBeforeOpAdditionalNonFilteringVars() + "\""); 
 if (op.getTokenizeVars().size() > 0) { 
 if (op.getTokenizeVars().size() > 0) { 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (op.getSecondaryKeyExpressions().size() > 0) { 
 @Override public Void visitDelegateOperator(DelegateOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"" + op.toString() + "\""); 
 @Override public Void visitDelegateOperator(DelegateOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"" + op.toString() + "\""); 
 if (!first) 
 PlanPrettyPrinter.printPlanJson(p, this, indent + 4); first = false; 
 PlanPrettyPrinter.printPlanJson(p, this, indent + 4); first = false; 
 PlanPrettyPrinter.printPlanJson(p, this, indent + 4); first = false; 
 buffer.append("{\"expression\":\"" + ve.second.getValue().accept(exprVisitor, indent).replace('"', ' ') + "\"}"); 
 public static int operatorID = 0; 
 public static void printOperatorJson(AbstractLogicalOperator op, LogicalOperatorPrettyPrintVisitorJson pvisitor, int indent) throws AlgebricksException { 
 appendln(out, "{"); op.accept(pvisitor, indent + 1); 
 appendln(out, ","); 
 if (op.getOperatorID() == 0) { 
 if (op.getOperatorID() == 0) { 
 if (op.getOperatorID() == 0) { 
 if (pOp != null) { appendln(out, ","); 
 if (pOp != null) { appendln(out, ","); 
 if (pOp != null) { appendln(out, ","); 
 appendln(out, ","); pad(out, indent); append(out, "\"execution-mode\":\"" + op.getExecutionMode() + '"'); if (op.getInputs().size() > 0) { appendln(out, ","); pad(out, indent); 
 pad(out, indent + 2); 
 pad(out, indent + 2); 
 pad(out, indent - 1); appendln(out, "}"); 
 pad(out, indent - 1); appendln(out, "}"); 
 public SessionConfig(OutputFormat fmt, boolean optimize, boolean executeQuery, boolean generateJobSpec, PlanFormat lpfmt, PlanFormat oplpfmt) { 
 public PlanFormat getOplpfmt() { return this.oplpfmt; } 
 public static PlanFormat planFormat; public static PlanFormat opPlanFormat; 
 public static PlanFormat planFormat; public static PlanFormat opPlanFormat; 
 SessionConfig sessionConfig = new SessionConfig(format, true, isSet(executeQuery), true, planFormat, opPlanFormat); 
<|del|> 
 } public int getOperatorID() { return operatorID; } 
 public LogicalOperatorPrettyPrintVisitorJson(AlgebricksAppendable buffer, ILogicalExpressionVisitor<String, Integer> exprVisitor) { 
 if (op.getVariables().size() > 0) { 
 for (LogicalVariable v : op.getVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("]"); 
 buffer.append("]"); 
 buffer.append("]"); 
 buffer.append("]"); 
 buffer.append("]"); 
 buffer.append("]"); 
 if (op.getGroupByList().size() > 0) { buffer.append(",\n"); addIndent(indent).append("\"group-by-list\":"); pprintVeList(op.getGroupByList(), indent); 
 if (op.getGroupByList().size() > 0) { buffer.append(",\n"); addIndent(indent).append("\"group-by-list\":"); pprintVeList(op.getGroupByList(), indent); 
 if (op.getGroupByList().size() > 0) { buffer.append(",\n"); addIndent(indent).append("\"group-by-list\":"); pprintVeList(op.getGroupByList(), indent); 
 if (op.getGroupByList().size() > 0) { buffer.append(",\n"); addIndent(indent).append("\"group-by-list\":"); pprintVeList(op.getGroupByList(), indent); 
 if (op.getDecorList().size() > 0) { 
 if (op.getDecorList().size() > 0) { 
 if (op.getDecorList().size() > 0) { 
 if (op.getDecorList().size() > 0) { 
 if (op.getNestedPlans().size() > 0) { 
 if (op.getNestedPlans().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 addIndent(indent) .append("\"condition\":" + "\"" + op.getCondition().getValue().accept(exprVisitor, indent) + "\""); 
 addIndent(indent) .append("\"condition\":" + "\"" + op.getCondition().getValue().accept(exprVisitor, indent) + "\""); 
 addIndent(indent) .append("\"second\":\"" + p.second.getValue().accept(exprVisitor, indent).replace('"', ' ') + "\""); 
 if (op.getVariables().size() > 0) { 
 if (op.getVariables().size() > 0) { 
 for (LogicalVariable v : op.getVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 .append(op.getPayloadExpression().getValue().accept(exprVisitor, indent) + ",\n"); 
 .append(op.getPayloadExpression().getValue().accept(exprVisitor, indent) + ",\n"); 
 addIndent(indent).append("\"expressions\":\"" + op.getCondition().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); 
 if (op.getVariables().size() > 0) { 
 if (op.getVariables().size() > 0) { 
 for (LogicalVariable v : op.getVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 @Override public Void visitSubplanOperator(SubplanOperator op, Integer indent) throws AlgebricksException { if (!op.getNestedPlans().isEmpty()) { 
 addIndent(indent) .append("\"values\":[" + "\"" + v.first + "\"," + "\"" + v.second + "\"," + "\"" + v.third + "\"]"); 
 addIndent(indent) .append("\"values\":[" + "\"" + v.first + "\"," + "\"" + v.second + "\"," + "\"" + v.third + "\"]"); 
 addIndent(indent) .append("\"values\":[" + "\"" + v.first + "\"," + "\"" + v.second + "\"," + "\"" + v.third + "\"]"); 
 buffer.append("\"" + str(op.getOutputVars().get(i)) + "\""); 
 buffer.append("\"" + str(op.getOutputVars().get(i)) + "\""); 
 buffer.append("\"" + str(op.getInputVariables(i).get(j)) + "\""); 
 buffer.append("\"" + str(op.getInputVariables(i).get(j)) + "\""); 
 if (op.getVariables().size() > 0) { 
 for (LogicalVariable v : op.getVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 addIndent(indent).append("\"position\":\"" + op.getPositionalVariable() + "\""); 
 addIndent(indent).append("\"position\":\"" + op.getPositionalVariable() + "\""); 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); 
 private SyndEntry getNextRSSFeed() throws IOException, FeedException, FetcherException { 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); 
 buffer.append("\"" + str(v) + "\""); first = false; 
 addIndent(indent).append("\"expressions\":\"" + op.getExpressionRef().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); appendFilterInformation(plan, op.getMinFilterVars(), op.getMaxFilterVars(), indent); 
 for (LogicalVariable v : op.getProjectVariables()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (op.getDataSource() != null) { 
 addIndent(indent).append("\"data-source\":\"" + op.getDataSource() + "\""); 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("\"" + str(v) + "\""); first = false; 
 addIndent(indent).append("\"value\":\"" + op.getMaxObjects().getValue().accept(exprVisitor, indent) + "\""); 
 if (op.getInputVariables().size() > 0) { 
 if (op.getOutputVariables().size() > 0) { 
 buffer.append("\"" + str(v) + "\""); first = false; 
 protected Void doRecover(IRetryPolicy policy) throws AlgebricksException, HyracksDataException, InterruptedException { 
 if (listener.getState() == ActivityState.PERMANENTLY_FAILED && listener instanceof IActiveEntityController) { ((IActiveEntityController) listener).recover(); 
 addIndent(indent).append("\"" + branchingExpression.getValue().accept(exprVisitor, indent) + "\""); 
<|del|> 
 .append(op.getPayloadExpression().getValue().accept(exprVisitor, indent) + "\""); 
 addIndent(indent).append("\"record-before-upsert\":\"" + op.getBeforeOpRecordVar() + "\""); if ((op.getBeforeOpAdditionalNonFilteringVars() != null)) { 
 addIndent(indent) .append("\"additional-before-upsert\":\"" + op.getBeforeOpAdditionalNonFilteringVars() + "\""); 
 addIndent(indent) .append("\"additional-before-upsert\":\"" + op.getBeforeOpAdditionalNonFilteringVars() + "\""); 
 for (LogicalVariable v : op.getTokenizeVars()) { if (!first) 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (op.getSecondaryKeyExpressions().size() > 0) { 
 if (op.getSecondaryKeyExpressions().size() > 0) { 
 if (op.getSecondaryKeyExpressions().size() > 0) { 
 if (!first) 
 PlanPrettyPrinter.printPlanJson(p, this, indent + 4); first = false; 
 PlanPrettyPrinter.printPlanJson(p, this, indent + 4); first = false; 
 PlanPrettyPrinter.printPlanJson(p, this, indent + 4); first = false; 
 buffer.append("{\"expression\":\"" + ve.second.getValue().accept(exprVisitor, indent).replace('"', ' ') + "\"}"); 
 buffer.append("{\"expression\":\"" + ve.second.getValue().accept(exprVisitor, indent).replace('"', ' ') + "\"}"); 
 buffer.append("{\"expression\":\"" + ve.second.getValue().accept(exprVisitor, indent).replace('"', ' ') + "\"}"); 
 buffer.append("{\"expression\":\"" + ve.second.getValue().accept(exprVisitor, indent).replace('"', ' ') + "\"}"); 
 public static int operatorID = 0; 
 public static int operatorID = 0; 
 public static int operatorID = 0; 
 appendln(out, ","); 
 if (op.getOperatorID() == 0) { 
 append(out, "\"operator-id\":" + op.getOperatorID()); 
 if (pOp != null) { appendln(out, ","); 
 appendln(out, ","); pad(out, indent); append(out, "\"execution-mode\":\"" + op.getExecutionMode() + '"'); if (op.getInputs().size() > 0) { appendln(out, ","); pad(out, indent); 
 boolean moreInputes = false; 
 boolean moreInputes = false; 
 boolean moreInputes = false; 
 printOperatorJson((AbstractLogicalOperator) k.getValue(), pvisitor, indent + 4); 
 public static void resetOperatorID(ILogicalPlan plan) { 
 public static void reset(AbstractLogicalOperator op) { 
 import java.io.Reader; import java.util.ArrayList; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.logging.Level; import java.util.logging.Logger; 
 public PlanFormat getOplpfmt() { return this.oplpfmt; } 
 public PlanFormat getOplpfmt() { return this.oplpfmt; } 
 if (rwQ != null || (statement != null && statement.getKind() == Kind.LOAD)) { 
 if (rwQ != null || (statement != null && statement.getKind() == Kind.LOAD)) { 
 if (rwQ != null || (statement != null && statement.getKind() == Kind.LOAD)) { 
 public static PlanFormat planFormat; public static PlanFormat opPlanFormat; 
 LOGGER.log(Level.INFO, plan + ": unsupported plan-format, using " + PlanFormat.CLEAN_JSON + " instead", e); 
import org.apache.asterix.common.utils.JSONUtil; 
 private int operatorID = 0; 
 private int operatorID = 0; 
 if (op.getVariables().size() > 0) { 
 buffer.append("\"" + str(v) + "\""); first = false; 
 buffer.append("]"); 
 addIndent(indent).append("\"option\":\"all\""); 
 if (op.getNestedPlans().size() > 0) { 
 if (op.getNestedPlans().size() > 0) { 
 addIndent(indent) .append("\"condition\":" + "\"" + op.getCondition().getValue().accept(exprVisitor, indent) + "\""); 
 addIndent(indent) .append("\"condition\":" + "\"" + op.getCondition().getValue().accept(exprVisitor, indent) + "\""); 
 addIndent(indent) .append("\"second\":\"" + p.second.getValue().accept(exprVisitor, indent).replace('"', ' ') + "\""); 
 buffer.append("\"" + str(v) + "\""); first = false; 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 if (op.getExpressions().size() > 0) { 
 addIndent(indent).append("\"expressions\":\"" + op.getCondition().getValue().accept(exprVisitor, indent) .replace('"', ' ') + "\""); 
 buffer.append("\"" + str(v) + "\""); first = false; 
 protected synchronized void waitForNonTransitionState() throws InterruptedException { while (TRANSITION_STATES.contains(state) || suspended) { 
 protected Void doRecover(IRetryPolicy policy) throws AlgebricksException, HyracksDataException, InterruptedException { 
 } } catch (InterruptedException e) { throw e; } catch (Exception e) { throw HyracksDataException.create(e); 
 } } catch (InterruptedException e) { throw e; } catch (Exception e) { throw HyracksDataException.create(e); 
 if (listener.getState() == ActivityState.PERMANENTLY_FAILED && listener instanceof IActiveEntityController) { ((IActiveEntityController) listener).recover(); 
<|del|> 
 if (wait) { 
 protected IHyracksClientConnection hcc; protected volatile boolean recoveryCompleted; 
 default void notifyStateChange(ClusterState newState) { 
 void startGlobalRecovery(ICcApplicationContext appCtx) throws HyracksDataException; /** * @return true, if global recovery has been completed successfully */ boolean isRecoveryCompleted(); 
 IMetadataLockManager getMetadataLockManager(); 
 public static final int REMOTE_EXCEPTION_WHEN_CALLING_METADATA_NODE = 1044; 
 private final String nodeId; 
 if (out != null) { out.close(); } 
 writer.fail(); 
 writer.fail(); 
<|del|> 
 protected synchronized void waitForNonTransitionState() throws InterruptedException { while (TRANSITION_STATES.contains(state) || suspended) { 
 void sync() throws HyracksDataException, InterruptedException; 
 listener.wait(5000); //NOSONAR this method is being called in a while loop 
 public void stop() throws HyracksDataException, InterruptedException { 
 if (!failed && appender.getTupleCount() > 0) { FrameUtils.flushFrame(frame.getBuffer(), writer); 
 private static final Logger LOGGER = Logger.getLogger(BuiltinFeedPolicies.class.getName()); 
 private static final FeedPolicyEntity[] POLICIES = new FeedPolicyEntity[] { BASIC, ADVANCED_FT_DISCARD, ADVANCED_FT_SPILL, ELASTIC }; 
 policyParams.put(FeedPolicyAccessor.MAX_SPILL_SIZE_ON_DISK, "" + Long.toString(FeedPolicyAccessor.NO_LIMIT)); 
 private FeedMetadataUtil() { } 
 String datasetName) throws AlgebricksException { 
 init(cleanupOnStart); while (true) { Thread.sleep(10000); 
 Assert.assertEquals(cause.getErrorCode(), expectedException.getErrorCode()); Assert.assertEquals(cause.getMessage(), expectedException.getMessage()); 
 protected void triggerReplication(List<ILSMDiskComponent> lsmComponents, boolean bulkload, LSMOperationType opType) 
<|del|> 
<|del|> 
 ps.print(Float.isNaN(f) ? "NaN" : (f == Float.POSITIVE_INFINITY) ? "INF" : "-INF"); 
 ps.print(Float.isNaN(f) ? "NaN" : (f == Float.POSITIVE_INFINITY) ? "INF" : "-INF"); 
 public static void printDoubleForJson(byte[] b, int s, PrintStream ps) throws HyracksDataException { 
 public static void printDouble(byte[] b, int s, PrintStream ps) throws HyracksDataException { 
 final SessionConfig.OutputFormat outputFormat = conf.fmt(); switch (outputFormat) { 
<|del|>
<|del|>
<|del|>
<|del|>
 if (!op.getVariables().isEmpty()) { 
 buffer.append(","); } 
 if (!op.getVariables().isEmpty()) { 
 buffer.append(","); } 
 if (!op.getExpressions().isEmpty()) { 
 if (!op.getGroupByList().isEmpty() { 
 if (!op.getDecorList().isEmpty()) { 
 if (!op.getNestedPlans().isEmpty()) { 
 if (!op.getExpressions().isEmpty()) { 
 if (!op.getVariables().isEmpty()) { 
 buffer.append(","); } 
 if (!op.getExpressions().isEmpty()) { 
 if (!op.getExpressions().isEmpty()) { 
 if (!op.getVariables().isEmpty()) { 
 buffer.append(","); } 
 if (!op.getVariables().isEmpty()) { 
 buffer.append(","); } 
 if (!op.getVariables().isEmpty()) { 
 buffer.append(","); } 
 if (!op.getProjectVariables().isEmpty()) { 
 buffer.append(","); } 
 if (!op.getVariables().isEmpty()) { 
 buffer.append(","); } 
 buffer.append(","); } 
 buffer.append(","); } 
 if (!op.getInputVariables().isEmpty()) { 
 buffer.append(","); } 
 if (!op.getOutputVariables().isEmpty()) { 
 buffer.append(","); } 
 if (op.getBeforeOpAdditionalNonFilteringVars() != null) { 
 if (!op.getTokenizeVars().isEmpty()) { 
 if (!op.getSecondaryKeyExpressions().isEmpty()) { 
 buffer.append(","); } 
 public int operatorID = 0; 
 public int operatorID = 0; 
 pad(out, currentIndent); 
 pad(out, currentIndent); 
 public void deregisterRuntime(ActiveRuntimeId runtimeId) throws HyracksDataException { 
 private final IActiveEntityEventsListener listener; 
 notifySubscribers(STATE_CHANGED); 
<|del|> 
 protected synchronized void waitForNonTransitionState() throws InterruptedException { while (TRANSITION_STATES.contains(state) || suspended) { 
 MetadataLockUtil.modifyDatasetBegin(lockManager, metadataProvider.getLocks(), dataset.getDataverseName(), DatasetUtil.getFullyQualifiedName(dataset)); 
 waitForNonTransitionState(); 
 } else if (state == ActivityState.RUNNING) { 
 protected synchronized void waitForNonTransitionState() throws InterruptedException { while (TRANSITION_STATES.contains(state) || suspended) { 
 filePath = filePath.replace(evil, ""); // NOSONAR 
 indexAccessor.forceUpsert(logRecord.getNewValue()); } else if (logRecord.getNewOp() == AbstractIndexModificationOperationCallback.FILTER_BYTE) { indexAccessor.updateFilter(logRecord.getNewValue()); 
<|del|> 
<|del|> 
<|del|> 
public class LSMBTreeTupleWriter extends BTreeTypeAwareTupleWriter implements ILSMTreeTupleWriter { 
 if (readEntityNoPKInfo(buffer)) { 
 // Removes the indexes from the outer branch in the optimizer's consideration list for this rule. 
<|del|> 
 TypeUtil.createEnforcedType(recordType, metaType, Collections.singletonList(index)); 
 TypeUtil.createEnforcedType(recordType, metaType, Collections.singletonList(index)); 
 TypeUtil.createEnforcedType(recordType, metaType, Collections.singletonList(index)); 
 try { flush(); } finally { buffer.release(); } 
 secondaryIndexOutputTypes, generateInstantTrylockResultFromIndexSearch); 
 Mutable<ILogicalExpression> vRef = new MutableObject<>(new VariableReferenceExpression(pkVar)); order.getOrderExpressions().add(new Pair<>(OrderOperator.ASC_ORDER, vRef)); 
 AbstractUnnestMapOperator primaryIndexUnnestMapOp = null; if (retainMissing) { 
 if (funcExpr.getFunctionIdentifier() != BuiltinFunctions.GET_ITEM) { 
 result = initializeDataSource(searchOpRef); passedSource = true; if (!subTreeOp.getInputs().isEmpty()) { searchOpRef = subTreeOp.getInputs().get(0); subTreeOp = (AbstractLogicalOperator) searchOpRef.getValue(); } 
 private static Pair<Boolean, Boolean> pushThroughOp(Set<LogicalVariable> toPush, Mutable<ILogicalOperator> opRef2, ILogicalOperator initialOp, IOptimizationContext context) throws AlgebricksException { 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : subJob .getConnectorOperatorMap().entrySet()) { 
<|del|> 
 conf.out().println("----------Expression tree:"); 
 if (output.config().getLpfmt().equals(SessionConfig.PlanFormat.JSON)) { ct = new IdCounter(); 
 return new Pair<Query, Integer>(q, q.getVarCounter()); 
 return new Pair<Query, Integer>(q, q.getVarCounter()); 
 private static PlanFormat planFormat; private static PlanFormat opPlanFormat; 
 private static PlanFormat planFormat; private static PlanFormat opPlanFormat; 
 private static PlanFormat planFormat; private static PlanFormat opPlanFormat; 
 private static PlanFormat planFormat; private static PlanFormat opPlanFormat; 
 if (!op.getOutputVariables().isEmpty()) { 
 if (!op.getTokenizeVars().isEmpty()) { 
 if (!op.getSecondaryKeyExpressions().isEmpty()) { 
 public static int getOperatorID() { return operatorID; } 
 public static int getOperatorID() { return operatorID; } 
 ExternalProperties xProps = AppContextInfo.INSTANCE.getExternalProperties(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 hds = new HyracksDataset(hcc, appCtx.getCompilerProperties().getFrameSize(), ResultReader.NUM_READERS); 
 hds = new HyracksDataset(hcc, appCtx.getCompilerProperties().getFrameSize(), ResultReader.NUM_READERS); 
 return Arrays.toString(locations); 
 executorThread = new Thread(this, threadName); executorThread.start(); 
 while (executorThread.isAlive()) { 
 writer.close(); 
 } @Override protected void abort() throws HyracksDataException, InterruptedException { if (adapterRuntimeManager != null) { adapterRuntimeManager.stop(); } } 
 return locations.toString(); 
 PhysicalOptimizationConfig physicalOptimizationConfig, AlgebricksPartitionConstraint clusterLocations) { 
 PhysicalOptimizationConfig physicalOptimizationConfig, AlgebricksPartitionConstraint clusterLocations) { 
<|del|> 
 throw HyracksDataException.create(ErrorCode.CANNOT_DELETE_FILE, e, absFileName); 
@RunWith(Parameterized.class) public class JsonLogicalPlanTest { 
 private static final long serialVersionUID = 1L; 
 IStatementExecutor translator = statementExectorFactory.create(appCtx, aqlStatements, sessionOutput, compilationProvider, componentProvider); 
 @Override protected void get(IServletRequest request, IServletResponse response) { 
 UNPARTITIONED, /** 
<|del|> 
 return false; } 
 numBits += 1.0; } 
 numBits += 1.0; } 
 numBits += 1.0; } 
 LOGGER.log(Level.INFO, "Dropping index " + resourceRef.getRelativePath() + " on node " + ctx.getNodeId()); 
 LOGGER.log(Level.INFO, "Dropping index " + resourceRef.getRelativePath() + " on node " + ctx.getNodeId()); 
 LOGGER.log(Level.INFO, "Dropping index " + resourceRef.getRelativePath() + " on node " + ctx.getNodeId()); 
 LOGGER.log(Level.WARNING, "Failure scheduling replication or destroying merged component", e); 
 dsInfo.undeclareActiveIOOperation(); 
 try { LOGGER.log(Level.WARNING, "Unhandled throwable", th); } catch (Throwable loggingFailure) {// NOSONAR... swallow logging failure } 
 } catch (NoSuchFileException | FileNotFoundException e) { 
 } catch (NoSuchFileException | FileNotFoundException e) { 
 MetadataProvider tempMdProvider = new MetadataProvider(appCtx, metadataProvider.getDefaultDataverse()); tempMdProvider.getConfig().putAll(metadataProvider.getConfig()); 
 parentsPathToReplicate.remove(parentsPathToReplicate.size() - 1); 
 parentsPathToReplicate.remove(parentsPathToReplicate.size() -1 ); 
 Mutable<ILogicalOperator> replicateActualParent = parentsPathToReplicate.get(parentsPathToReplicate.size() - 1); 
 ResultUtil.printResults(metadataProvider.getApplicationContext(), pvisitor.get().toString(), output, new Stats(), null); 
 String accept = request.getHeader("Accept", ""); 
 public JobSpecification compileQuery(List<FunctionDecl> declaredFunctions, AqlMetadataProvider queryMetadataProvider, Query rwQ, int varCounter, String outputDatasetName, 
 cluster = (Cluster) unmarshaller.unmarshal(is); nodeNamePrefix = cluster.getInstanceName() + "_"; updateNodeIdToFullName(); 
 AlgebricksAppendable buffer = new AlgebricksAppendable(output.out()); 
<|del|> 
 public SessionConfig(OutputFormat fmt) { this(fmt, PlanFormat.STRING); 
 PlanPrettyPrinter.printPlanJson(plan, pvisitor, 0, ct,"1"); 
<|del|> 
 private String operatorID = ""; 
 } } 
 @Override public String toString() { 
 public static class IdCounter { public int value; 
 + " that is not registered. Could be that the runtime completed execution on" + " this node before the cluster controller sent the stop request"); 
 for (Node node : nodes) { 
 return new StringValue("\"" + newValue.replace("\"","\'").trim() + "\""); 
 return new StringValue("\"" + newValue.replace("\"","\'").trim() + "\""); 
 edgeLabel += "-" + connectorId; 
 edgeLabel += "-" + connectorId; 
 context.getPhysicalOptimizationConfig().getMaxFramesForGroupBy())); 
 super.close(); 
<|del|> 
 return om.writer(new MinimalPrettyPrinter()).writeValueAsString(on); } catch (JsonProcessingException e) { // NOSONAR 
 return om.writer(new MinimalPrettyPrinter()).writeValueAsString(on); } catch (JsonProcessingException e) { // NOSONAR 
 return om.writer(new MinimalPrettyPrinter()).writeValueAsString(on); } catch (JsonProcessingException e) { // NOSONAR 
 return om.writer(new MinimalPrettyPrinter()).writeValueAsString(on); } catch (JsonProcessingException e) { // NOSONAR 
 addServlet(jsonAPIServer, Servlets.QUERY_SERVICE); addServlet(jsonAPIServer, Servlets.RUNNING_REQUESTS); 
 return new FullApiServlet(ctx, paths, appCtx, ccExtensionManager.getSqlppCompilationProvider(), 
 public JobId startJob(DeploymentId deploymentId, byte[] acggfBytes, EnumSet<JobFlag> jobFlags) throws Exception; 
 synchronized Object getResponse() throws Exception { while (pending) { 
 IHyracksClientConnection hcc = getHcc(); 
 return new FullApiServlet(ctx, paths, appCtx, ccExtensionManager.getAqlCompilationProvider(), getStatementExecutorFactory(), componentProvider); 
 * 
 timeout = java.util.concurrent.TimeUnit.NANOSECONDS .toMillis(TimeUnit.parseDurationStringToNanos(param.timeout)); 
 cancelQuery(ncMb, ncCtx.getNodeId(), param.clientContextID, hde); throw hde; 
 public static final long DEFAULT_NC_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(5); //TODO: Make configurable 
 this.jobId = jobId; if (jobId == null) { throw new IllegalArgumentException("jobId"); } 
<|del|> 
<|del|>
 public T createTupleReference() { return (T) new BTreeTypeAwareTupleReference(typeTraits, updateAware); 
<|del|> 
public interface IBTreeIndexTupleWriter<T extends IBTreeIndexTupleReference> extends ITreeIndexTupleWriter<T> { 
 if (ctx.getIndexTuple() != null) { ctx.getIndexTuple().reset(tuple); indexTuple = ctx.getIndexTuple(); ctx.getCurrentMutableBTreeAccessor().getOpContext().resetNonIndexFieldsTuple(tuple); 
 return BitOperationUtils.getFlagBytes(numBits); 
 IMetadataPageManagerFactory freePageManagerFactory, boolean updateAware) 
 IMetadataPageManagerFactory metadataPageManagerFactory, boolean filtered, boolean needKeyDupCheck, 
 public DiagnosticsApiServlet(ICcApplicationContext appCtx, ConcurrentMap<String, Object> ctx, String... paths) { 
 public ShutdownApiServlet(ICcApplicationContext appCtx, ConcurrentMap<String, Object> ctx, String[] paths) { 
 for (Entry<ConnectorDescriptorId, Pair<Pair<IOperatorDescriptor, Integer>, Pair<IOperatorDescriptor, Integer>>> entry : subJob .getConnectorOperatorMap().entrySet()) { 
 public static AlgebricksAbsolutePartitionConstraint getPartitionConstraints(ICcApplicationContext appCtx, 
 int numNodesInCluster = appCtx.getClusterStateManager().getParticipantNodes(true).size(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 cList.add("-Dfile.encoding=" + StandardCharsets.UTF_8); 
 cList.add("-Dfile.encoding=" + StandardCharsets.UTF_8); 
<|del|> 
 Pair<ILogicalOperator, Map<LogicalVariable, LogicalVariable>> copiedAggOpAndVarMap = OperatorManipulationUtil.deepCopyWithNewVars(aggOp, context); 
 * 
 @Override protected void configureLoggingLevel(Level level) { super.configureLoggingLevel(level); Logger.getLogger("org.apache.asterix").setLevel(level); } protected void configureServers() throws Exception { } 
<|del|> 
 void stop() throws Exception; //NOSONAR 
<|del|> 
 @Override public boolean hasNext() throws HyracksDataException { 
 /** the input record type can be an union type * for the case when it comes from a subplan or left-outer join */ 
 leftSubTree.initFromSubTree(joinOp.getInputs().get(0), false); 
 return true; 
<|del|> 
 String getDisplayName() throws HyracksDataException; 
 StringBuilder resultBuilder = new StringBuilder(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 MODE("mode"); 
<|del|> 
 new SessionConfig(resultWriter, format, resultPrefix, resultPostfix, handlePrefix, handlePostfix); 
 boolean printOptimizedPlan, boolean printPhysicalOpsOnly, boolean generateBinaryRuntime, boolean printJob, PlanFormat pformat) 
@RunWith(Parameterized.class) public class JsonLogicalPlanTest { 
 private String id = ""; 
<|del|> 
 } } 
<|del|> 
 boolean idSet = ct.setOperatorId(op); 
 append(out, "\"operator-id\":\"" + op.getId() + "\""); 
 IServletResponse.setContentType(response, IServlet.ContentType.TEXT_HTML, IServlet.Encoding.UTF8); 
 SessionOutput sessionOutput = createSessionOutput(param, handleUrl, resultWriter); SessionConfig sessionConfig = sessionOutput.config(); 
 SessionOutput sessionOutput = createSessionOutput(param, handleUrl, resultWriter); SessionConfig sessionConfig = sessionOutput.config(); 
 public InMemoryInvertedIndexAccessor createAccessor(int[] nonIndexFields) throws HyracksDataException { 
<|del|> 
 @Override public String getDisplayName() throws HyracksDataException { 
 @Override default IChainedComponentBulkLoader createIndexBulkLoader(float fillFactor, boolean verifyInput, 
public interface IChainedComponentBulkLoader { /** * Adds a tuple to the bulkloaded component * * @param tuple * @return Potentially modified tuple, which is used as an input for downstream bulkloaders * @throws HyracksDataException */ 
public interface IChainedComponentBulkLoader { /** * Adds a tuple to the bulkloaded component * * @param tuple * @return Potentially modified tuple, which is used as an input for downstream bulkloaders * @throws HyracksDataException */ 
 void scheduleFullMerge(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException; 
 @Override public String getDisplayName() throws HyracksDataException { 
 } public void setFinished() { this.isFinished = true; } 
 } else { IExpressionAnnotation ann = fexp.getAnnotations().get(BroadcastExpressionAnnotation.BROADCAST_ANNOTATION_KEY); 
 public enum BulkLoadUsage { 
 if (primaryComponents.isEmpty()) { 
public interface ILSMComponentIdGeneratorFactory extends Serializable { 
<|del|> 
 public ExecutionTrace getTrace() { return ExecutionTrace.INSTANCE; 
 public static final Logger TRACE_LOG = Logger.getLogger(ExecutionTrace.class.getName()); public static final Level TRACE_LOG_LEVEL = Level.INFO; 
 public static final Logger TRACE_LOG = Logger.getLogger(ExecutionTrace.class.getName()); public static final Level TRACE_LOG_LEVEL = Level.INFO; 
 public static final Logger TRACE_LOG = Logger.getLogger(ExecutionTrace.class.getName()); public static final Level TRACE_LOG_LEVEL = Level.INFO; 
 public static final ExecutionTrace INSTANCE = new ExecutionTrace(); 
 public static final ExecutionTrace INSTANCE = new ExecutionTrace(); 
 protected static final int pid = 1; 
 protected static final int pid = 1; 
 protected static final int pid = 1; 
 protected static final int pid = 1; 
 protected final int pid = 1; 
 TRACE_LOG.log(TRACE_LOG_LEVEL, e.toJson()); 
 TRACE_LOG.log(TRACE_LOG_LEVEL, e.toJson()); 
 Thread.currentThread().interrupt(); throw HyracksDataException.create(e); 
 Thread.currentThread().interrupt(); throw HyracksDataException.create(e); 
 sb.append("}"); 
<|del|> 
 LOGGER.log(Level.WARNING, "Failed getting hyracks dataset connection. Resetting hyracks connection.", e); 
 IHyracksDataset hds = (IHyracksDataset) ctx.get(HYRACKS_DATASET_ATTR); if (hds == null) { synchronized (ctx) { 
 IHyracksDataset hds = (IHyracksDataset) ctx.get(HYRACKS_DATASET_ATTR); if (hds == null) { synchronized (ctx) { 
<|del|> 
<|del|> 
 * @return The scheduled flush operation 
 List<ILSMIOOperation> getDependingOps(); void setDependingOps(List<ILSMIOOperation> dependingOps); 
 isFinished.set(true); 
 ctx.setDependingOps(dependingOps); 
 Thread.currentThread().interrupt(); 
<|del|> 
 super(ioOp, trace); System.err.println("COMPARE ComparableTracedIOOperation"); 
 super(ioOp, trace); System.err.println("COMPARE ComparableTracedIOOperation"); 
 if (wait) { cancelQueryFuture.get(ExecuteStatementRequestMessage.DEFAULT_QUERY_CANCELLATION_WAIT_MILLIS, TimeUnit.MILLISECONDS); } 
 case "metrics": 
 resultStream = METRICS_QUERY_TYPE.equals(reqType) ? ResultExtractor.extractMetrics(resultStream) : ResultExtractor.extract(resultStream); 
 componentBulkLoader = component.createBulkLoader(1.0f, false, numTuples, false, true, true); 
 componentBulkLoader = component.createBulkLoader(1.0f, false, numTuples, false, true, true); 
 c.activate(); 
 c.purge(); 
 c.clear(); 
 c.destroy(); 
<|del|> 
 final ILSMIOOperation myIoOp = this.ioOp; if (myIoOp instanceof Comparable && other instanceof ComparableTracedIOOperation) { return ((Comparable) myIoOp).compareTo(((ComparableTracedIOOperation) other).getIoOp()); 
<|del|> 
 final ILSMIOOperation myIoOp = this.ioOp; if (myIoOp instanceof Comparable && other instanceof ComparableTracedIOOperation) { return ((Comparable) myIoOp).compareTo(((ComparableTracedIOOperation) other).getIoOp()); 
 void deleteComponents(ILSMIndexOperationContext ctx, Predicate<ILSMComponent> predicate) throws HyracksDataException; 
 private boolean alwaysHold(ILogicalExpression cond) { 
 public void startTasks(DeploymentId deploymentId, JobId jobId, byte[] planBytes, List<TaskAttemptDescriptor> taskDescriptors, Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, Set<JobFlag> flags, Map<byte[], byte[]> jobParameters) throws Exception; 
 public void distributeJob(JobId jobId, byte[] planBytes) throws Exception; public void destroyJob(JobId jobId) throws Exception; 
<|del|> 
 long tid = tracer.durationB(name, cat, args); 
 throw HyracksDataException.create(ErrorCode.TUPLE_CANNOT_FIT_INTO_EMPTY_FRAME, length0 + length1); 
 int fTargetSlotsLength = fields.length * Integer.BYTES; 
 public void durationE(long tid, String args) { // nothing to do here 
 public void instant(String name, String cat, Scope scope, String args) { // nothing to do here 
 public static final Tracer ALL = new Tracer("All", new String[] { "*" }); 
 public static final Tracer ALL = new Tracer("All", new String[] { "*" }); 
 public static final Tracer ALL = new Tracer("All", new String[] { "*" }); 
 // schedule a delete for flushed component 
 // This is a workaround until ASTERIXDB-2106 is fixed 
 public JobId startJob(JobId jobId, Map<byte[], byte[]> jobParameters) throws Exception; 
 public JobId startJob(JobId jobId, Map<byte[], byte[]> jobParameters) throws Exception; 
 public JobId startJob(JobId jobId, Map<byte[], byte[]> jobParameters) throws Exception; 
<|del|> 
 ClientInterfaceIPCI(final ClusterControllerService ccs, final JobIdFactory jobIdFactory) { 
 callback.setValue(jobId); 
 public void notifyDistributedJobFailure(PreDistributedId preDistributedId, String nodeId) throws Exception; 
 Set<JobFlag> flags, Map<byte[], byte[]> jobParameters) throws Exception; 
 for (int i = 0; i < paramListSize; i++) { 
 public void notifyDistributedJobFailure(PreDistributedId preDistributedId, String nodeId) throws Exception; 
 FileReference bloomFilterMergeTarget, ILSMIOOperationCallback callback, String indexIdentifier, List<ILSMIOOperation> dependingOps) { super(accessor, target, callback, indexIdentifier, cursor, dependingOps); 
 public static final FunctionIdentifier ST_IS_SIMPLE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 public static final FunctionIdentifier ST_X_MAX = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, 
 public static final FunctionIdentifier ST_LINE_FROM_MULTIPOINT = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "st-line-from-multipoint", 1); 
 private static final long NANOTIME_DELTA_TO_EPOCH = System.nanoTime() - TimeUnit.MILLISECONDS.toNanos(System.currentTimeMillis()); 
<|del|> 
<|del|> 
 OGCGeometryCollection geometryCollection = (OGCGeometryCollection) geometry; 
 return "GeometryCollection".equals(type) || "MultiLineString".equals(type) || "MultiPoint".equals(type) || "MultiPolygon".equals(type); 
 return "GeometryCollection".equals(type) || "MultiLineString".equals(type) || "MultiPoint".equals(type) || "MultiPolygon".equals(type); 
 OGCMultiPolygon polygon = (OGCMultiPolygon) geometry; 
<|del|> 
 private Set<String> reportedNodes = ConcurrentHashMap.newKeySet(); 
<|del|> 
 structure = wktImporter.executeOGC(WktImportFlags.wktImportNonTrusted, geometry, null); 
 structure = wktImporter.executeOGC(WktImportFlags.wktImportNonTrusted, geometry, null); 
 structure = wktImporter.executeOGC(WktImportFlags.wktImportNonTrusted, geometry, null); 
 structure = wktImporter.executeOGC(WktImportFlags.wktImportNonTrusted, geometry, null); 
<|del|> 
 getFilterManager().updateFilter(mergedComponent.getLSMComponentFilter(), filterTuples); 
 for (int i = 0; i < currentCursor && !killerTupleFound; i++) { if (buddyBtreeBloomFilters[i] != null && !buddyBtreeBloomFilters[i].contains(buddyBTreeTuple, hashes)) { 
 for (int i = 0; i < currentCursor && !killerTupleFound; i++) { if (bloomFilters[i] != null && bloomFilters[i].contains(btreeTuple, hashes)) { 
 String format = ("JSON".equalsIgnoreCase(fmtString) || "CLEAN_JSON".equalsIgnoreCase(fmtString)) 
 return PlanFormat.valueOf(format); 
 return PlanFormat.valueOf(format); 
 private static final String LPLAN = "Logical plan"; private static final String OPLAN = "Optimized logical plan"; 
 stringPrefix = stringPrefix.isEmpty() ? val.toString() : stringPrefix + "." + val.toString(); 
 String opId = stringPrefix.isEmpty() ? "" + Integer.toString(++id) : stringPrefix + "." + Integer.toString(++id); 
 String opId = stringPrefix.isEmpty() ? "" + Integer.toString(++id) : stringPrefix + "." + Integer.toString(++id); 
 private Deque<Integer> prefix; 
 numElements += ((AbstractLSMWithBloomFilterDiskComponent) mergeOp.getMergingComponents().get(i)) .getBloomFilter().getNumElements(); 
 numElements += ((AbstractLSMWithBloomFilterDiskComponent) mergedComponents.get(i)).getBloomFilter() .getNumElements(); 
 getFilterManager().writeFilter(mergedComponent.getLSMComponentFilter(), mergedComponent.getMetadataHolder()); 
 getFilterManager().writeFilter(mergedComponent.getLSMComponentFilter(), mergedComponent.getMetadataHolder()); 
import org.apache.commons.lang3.mutable.Mutable; 
import org.apache.commons.lang3.mutable.Mutable; 
 OGCGeometry geometry = OGCGeometry.createFromOGCStructure( OperatorImportFromWkb.local().executeOGC(0, buffer, null), SpatialReference.create(4326)); 
 // Initialize the resulting geometry with an empty point. geometry = new OGCPoint(new Point(), DEFAULT_CRS); 
 throw new RuntimeException("Memory allocation limit (" + MAX_ARRAY_SIZE + " bytes) exceeded"); 
 String id = ""; 
import org.apache.commons.lang3.mutable.Mutable; 
import org.apache.commons.lang3.mutable.Mutable; 
 protected void processNull() throws UnsupportedItemTypeException { throw new UnsupportedItemTypeException(BuiltinFunctions.ST_UNION, ATypeTag.SERIALIZED_SYSTEM_NULL_TYPE_TAG); 
import java.io.ByteArrayInputStream; import java.io.DataInputStream; import java.io.DataOutput; import java.io.IOException; 
import java.io.ByteArrayInputStream; import java.io.DataInputStream; import java.io.DataOutput; import java.io.IOException; 
import java.io.ByteArrayInputStream; import java.io.DataInputStream; import java.io.DataOutput; import java.io.IOException; 
 "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
import java.io.ByteArrayInputStream; import java.io.DataInputStream; import java.io.DataOutput; import java.io.IOException; 
import java.io.ByteArrayInputStream; import java.io.DataInputStream; import java.io.DataOutput; import java.io.IOException; 
 structure = wktImporter.executeOGC(WktImportFlags.wktImportNonTrusted, geometry, null); 
 "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
import java.io.ByteArrayInputStream; import java.io.DataInputStream; import java.io.DataOutput; import java.io.IOException; 
 "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 throw new UnsupportedOperationException( "The operation " + getIdentifier() + " is not supported for the type " + geometry.geometryType()); 
 public JSONDataParser(ARecordType recordType, JsonFactory jsonFactory, boolean detectGeoJSON, String geometryFieldName, boolean detectTemporal) { 
 * 
 arrayBuilderPool = new ObjectPool<>(new ListBuilderFactory(), ATypeTag.ARRAY); 
<|del|> 
<|del|> 
<|del|> 
 private static final long NANOTIME_DELTA_TO_EPOCH = System.nanoTime() - TimeUnit.MILLISECONDS.toNanos(System.currentTimeMillis()); 
 public static final TraceCategoryRegistry INSTANCE = new TraceCategoryRegistry(); 
 public static final TraceCategoryRegistry INSTANCE = new TraceCategoryRegistry(); 
 public final long cat; public final ITracer.Phase ph; 
<|del|> 
 print<ILogicalPlan, AlgebricksAppendable, Integer> printOperator = AbstractLogicalOperatorPrettyPrintVisitor::printPhysicalOps; 
 print<ILogicalPlan, AlgebricksAppendable, Integer> printOperator = AbstractLogicalOperatorPrettyPrintVisitor::printPhysicalOps; 
<|del|> 
 * Remove the deployed Job Spec 
 * Used to run a deployed Job Spec by id 
 JobId startJob(DeployedJobSpecId deployedJobSpecId, Map<byte[], byte[]> jobParameters) throws Exception; 
 return new PreDistributedId(Long.parseLong(str.substring(4))); 
<|del|> 
<|del|> 
<|del|> 
 void apply(T1 arg1, T2 arg2, T3 arg3) throws AlgebricksException; 
 long executionMilliseconds = checkEndTime.getTime() - checkStartTime.getTime(); 
 * Used to run a deployed Job Spec by id 
 JobId startJob(DeployedJobSpecId deployedJobSpecId, Map<byte[], byte[]> jobParameters) throws Exception; 
 JobId startJob(IActivityClusterGraphGeneratorFactory acggf, EnumSet<JobFlag> jobFlags) throws Exception; 
 public DeployedJobSpecId deployJobSpec(byte[] acggfBytes) throws Exception; 
 return new PreDistributedId(Long.parseLong(str.substring(4))); 
 Set<JobFlag> flags, Map<byte[], byte[]> jobParameters, DeployedJobSpecId deployedJobSpecId) throws Exception; 
 public void undeployJobSpec(DeployedJobSpecId deployedJobSpecId) throws Exception; 
 accessor.scheduleFullMerge(index.getIOOperationCallback()); 
 protected void resumeOrRecover(MetadataProvider metadataProvider) throws HyracksDataException { 
 protected void resumeOrRecover(MetadataProvider metadataProvider) throws HyracksDataException { 
<|del|> 
<|del|> 
 ILSMDiskComponent primaryComponent = primaryIndex.getDiskComponents().get(componentPos); componentBulkLoader = (LSMIndexDiskComponentBulkLoader) secondaryIndex.createBulkLoader(1.0f, false, numTuples, false, primaryComponent.getComponentId()); 
 * Remove the deployed Job Spec 
 * Used to run a deployed Job Spec by id 
 JobId startJob(DeployedJobSpecId deployedJobSpecId, Map<byte[], byte[]> jobParameters) throws Exception; 
 public DeployedJobSpecId deployJobSpec(byte[] acggfBytes) throws Exception; 
 public DeployedJobSpecId undeployJobSpec(DeployedJobSpecId deployedJobSpecId) throws Exception; 
 Set<JobFlag> flags, Map<byte[], byte[]> jobParameters, DeployedJobSpecId deployedJobSpecId) throws Exception; 
 public void undeployJobSpec(DeployedJobSpecId deployedJobSpecId) throws Exception; 
 public DeployedJobSpecId undeployJobSpec(DeployedJobSpecId deployedJobSpecId) throws Exception; 
 public void notifyDeployedJobSpecFailure(DeployedJobSpecId deployedJobSpecId, String nodeId) throws Exception; 
 public void undeployJobSpec(DeployedJobSpecId deployedJobSpecId) throws Exception; 
 return tupleIndex - lastFrameStart; 
 return tupleIndex - lastFrameStart; 
 public static < T extends AbstractLogicalOperatorPrettyPrintVisitor > void printPlan(ILogicalPlan plan, 
 public static < T extends AbstractLogicalOperatorPrettyPrintVisitor > void printPlan(ILogicalPlan plan, 
 public static <T extends AbstractLogicalOperatorPrettyPrintVisitor> void printPlan(ILogicalPlan plan, 
 public static <T extends AbstractLogicalOperatorPrettyPrintVisitor> void printPlan(ILogicalPlan plan, 
 print<AbstractLogicalOperator, LogicalOperatorPrettyPrintVisitor, Integer> printOperator = LogicalOperatorPrettyPrintVisitor::printOperator; 
 public static<T extends AbstractLogicalOperatorPrettyPrintVisitor>void printPlan(ILogicalPlan plan, T pvisitor, int indent) throws AlgebricksException { 
 public static<T extends AbstractLogicalOperatorPrettyPrintVisitor>void printPlan(ILogicalPlan plan, T pvisitor, int indent) throws AlgebricksException { 
 print<ILogicalPlan, LogicalOperatorPrettyPrintVisitorJson, Integer> printPlan = LogicalOperatorPrettyPrintVisitorJson::printPlanJson; 
 print<ILogicalPlan, AlgebricksAppendable, Integer> printOperator = AbstractLogicalOperatorPrettyPrintVisitor::printPhysicalOps; 
 aString.setValue(Integer.toString(function.getReferenceCount())); 
 aString.setValue(Integer.toString(function.getReferenceCount())); 
 startupThreads.add(ncStartThread); 
 private final List<Mutable<ILogicalOperator>> parents; 
 ccConfig.appCCMainClass = CCApplicationEntryPoint.class.getName(); // ccConfig.useJOL = true; 
 ccConfig.appCCMainClass = CCApplicationEntryPoint.class.getName(); // ccConfig.useJOL = true; 
 datasets.clear(); 
 public DatasetVirtualBufferCaches(int datasetID, StorageProperties storageProperties, int numPages, int numPartitions) { 
 ac.getProperty().add(new Property("storage.memorycomponent.globalbudget", "128MB", "")); ac.getProperty().add(new Property("storage.memorycomponent.numpages", "32", "")); 
 private final Map<Integer, Long> allocatedMap = new HashMap<>(); private final Map<Integer, Long> reservedMap = new HashMap<>(); private long available; 
 private final Map<Integer, Long> allocatedMap = new HashMap<>(); private final Map<Integer, Long> reservedMap = new HashMap<>(); private long available; 
 AsterixClusterProperties.INSTANCE.getStorageDirectoryName(), metadataPartition.getPartitionId()); 
 public IValueReference get(IValueReference key) throws HyracksDataException { 
 public IValueReference get(IValueReference key) throws HyracksDataException { 
 return modified; } 
 // The number of parameters should be three: exp1, exp2, and the option if (oldExprs.size() != numberOfCorrectArguments) { throw CompilationException.create(ErrorCode.COMPILATION_INVALID_PARAMETER_NUMBER, fi, oldExprs.size()); } 
 return modified; } 
 IJobletEventListenerFactory getJobletEventListenerFactory(); 
 return "ACID:" + id; 
<|del|> 
<|del|> 
 private final Map<PreDistributedId, PreDistributedJobDescriptor> preDistributedJobDescriptorMap; 
 ccs.createOrGetJobParameterByteStore(jobId).getParameterMap(), deployedJobSpecId); 
 * 
 public ParserContext() { 
 } return fieldSlotBytes; 
<|del|> 
 public void setDiskPageId(long dpid) { throw new UnsupportedOperationException(); 
 * * @param value * the value to be copied 
 * * @param value * the value to be copied 
 private final AtomicInteger used; 
 this.fileMapManager = new FileMapManager(); 
 this.fileMapManager = new FileMapManager(); 
<|del|> 
<|del|> 
<|del|> 
 map.put("pageBudget", pageBudget); 
<|del|> 
 private final ArrayList<VirtualPage> pages; private volatile int nextFree; 
 public void flushDirtyPage(ICachedPage page) throws HyracksDataException { 
 sb.append(String.format("Capacity = %d\n", numPages)); sb.append(String.format("Allocated pages = %d\n", pages.size())); 
 sb.append(String.format("Next free page = %d\n", nextFree)); 
 IIndexAccessParameters iap = new IndexAccessParameters(modificationCallback, NoOpOperationCallback.INSTANCE); mutableBTreeAccessors[i] = mutableBTrees[i].createAccessor(iap); 
 public PartitionedOnDiskInvertedIndexAccessor createAccessor(IIndexAccessParameters iap) throws HyracksDataException { 
 RTreeAccessor memRTreeAccessor = flushingComponent.getIndex().createAccessor(NoOpIndexAccessParameters.INSTANCE); 
 mutableBTreeAccessors[i] = mutableComponent.getBuddyIndex().createAccessor(NoOpIndexAccessParameters.INSTANCE); 
 mutableBTreeAccessors[i] = mutableComponent.getBuddyIndex().createAccessor(NoOpIndexAccessParameters.INSTANCE); 
 new LSMRTreeWithAntiMatterTuplesDiskComponentFactory(bulkLoadRTreeFactory, filterHelper); 
 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(poolSize); 
 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(poolSize); 
 long startTime = Instant.now().toEpochMilli(); 
 byte[] jobIdParameter = JOB_ID_PARAMETER_NAME; 
 long executionMilliseconds = Instant.now().toEpochMilli() - startTime; 
 long executionMilliseconds = Instant.now().toEpochMilli() - startTime; 
 * an interface for JobEventListenerFactories to add Asterix transaction JobId getter 
 private final DataOutput dataOutput = resultStorage.getDataOutput(); 
 return new JobEventListenerFactory(txnId, transactionalWrite); 
 return new MultiTransactionJobletEventListenerFactory(txnIds, transactionalWrite); 
 IJobletEventListenerFactory fact = ctx.getJobletContext().getJobletEventListenerFactory(); return new CommitRuntime(ctx, ((IJobEventListenerFactory) fact).getJobId(jobId), datasetId, 
 private final List<Mutable<ILogicalOperator>> parents; 
 AbstractFunctionCallExpression functionCallExpression = (AbstractFunctionCallExpression)unnestMapOperator.getExpressionRef().getValue(); if (functionCallExpression.getFunctionIdentifier() != BuiltinFunctions.INDEX_SEARCH) { return null; } 
 newBTreeParameters.setIsEqCondition(false); 
 metadataProvider.getDataFormat().getFieldAccessEvaluatorFactory( metadataProvider.getFunctionManager(), itemType, filterFieldName, recordColumn); 
 ISerializerDeserializerProvider serdeProvider = metadataProvider.getDataFormat().getSerdeProvider(); ITypeTraitProvider typeTraitProvider = metadataProvider.getDataFormat().getTypeTraitProvider(); 
 metadataProvider.getDataFormat().getFieldAccessEvaluatorFactory( metadataProvider.getFunctionManager(), itemType, filterFieldName, recordColumn); 
 Pair<IAType, Boolean> keyTypePair = Index.getNonNullableOpenFieldType(index.getKeyFieldTypes().get(0), index.getKeyFieldNames().get(0), itemType); 
<|del|> 
 public LSMBTreeMemoryComponent(LSMBTree lsmIndex, BTree btree, IVirtualBufferCache vbc, boolean isActive, 
 void recycled(ILSMMemoryComponent component); 
 void allocated(ILSMMemoryComponent component); 
 private static final Algorithm ALG = Algorithm.MERGE_SORT; 
 int runningNormalizedKeyTotalLength = 0; 
 return (long) frameAccessor.getBuffer().capacity() + ptrSize * frameAccessor.getFieldCount() * Integer.BYTES; 
 copy(tPointers, i, tPointersTemp, i, end - i); 
 int runningNormalizedKeyTotalLength = 0; 
 AbstractFrameSorter.compareNormalizeKeys(nmkey, 0, maxEntry.nmk, 0, normalizedKeyTotalLength); 
<|del|>
 boolean modified = op.acceptExpressionTransform(ftcontainsExprVisitor); 
 optionTypeStringVal = ConstantExpressionUtil.getStringConstant(optionExprVal); 
 Map<String, Object> getParameters(); 
 Map<String, Object> getParameters(); 
 secondaryIndex.getIOOperationCallback().afterOperation(LSMIOOperationType.FLUSH, null, diskComponents[i]); 
 DeployedJobSpecId deployJobSpec(JobSpecification jobSpec) throws Exception; 
 DeployedJobSpecId undeployJobSpec(DeployedJobSpecId deployedJobSpecId) throws Exception; 
 JobId startJob(DeployedJobSpecId deployedJobSpecId, Map<byte[], byte[]> jobParameters) throws Exception; 
 public JobId startJob(DeployedJobSpecId deployedJobSpecId, Map<byte[], byte[]> jobParameters) throws Exception; 
 public DeployedJobSpecId undeployJobSpec(DeployedJobSpecId deployedJobSpecId) throws Exception; 
 "asterixdb/asterix-opt/asterix-bad/src/main/resources/asterix-build-configuration.xml"); 
 ITupleReference getTupleFromMetadataEntity(T metadataEntity) throws AlgebricksException, HyracksDataException; 
 void dropDataset(MetadataTransactionContext ctx, String dataverseName, String datasetName) throws AlgebricksException; 
 Function getFunction(MetadataTransactionContext ctx, FunctionSignature functionSignature) throws AlgebricksException; 
 List<Function> getDataverseFunctions(MetadataTransactionContext ctx, String dataverseName) throws AlgebricksException; 
 void dropLibrary(MetadataTransactionContext ctx, String dataverseName, String libraryName) throws AlgebricksException; 
 List<Library> getDataverseLibraries(MetadataTransactionContext ctx, String dataverseName) throws AlgebricksException; 
 Dataset getDataset(JobId jobId, String dataverseName, String datasetName) throws AlgebricksException, RemoteException; 
 void dropDatatype(JobId jobId, String dataverseName, String datatypeName) throws AlgebricksException, RemoteException; 
 Library getLibrary(JobId jobId, String dataverseName, String libraryName) throws AlgebricksException, RemoteException; 
 void dropFeedPolicy(JobId jobId, String dataverseName, String policyName) throws AlgebricksException, RemoteException; 
 public Index getMetadataEntityFromTuple(ITupleReference frameTuple) throws AlgebricksException, HyracksDataException { 
 public ITupleReference getValue(JobId jobId, ITupleReference tuple) throws AlgebricksException, HyracksDataException { 
 this.lsmIndex = lsmIndex; this.idGenerator = idGenerator; 
 if (mergedComponents == null || mergedComponents.isEmpty()) { 
 protected transient INCServiceContext ncCtx; 
 if (!primaryComponents.isEmpty()) { 
 IBinaryComparatorFactory[] btreeComparatorFactories) { 
<|del|> 
<|del|> 
 return new SecondaryIndexModificationOperationCallback(metadataIndex.getDatasetId(), 
 NoMergePolicyFactory.class.getName(), CorrelatedPrefixMergePolicyFactory.class.getName() }; CompactionPolicy compactionPolicy; 
 // Otherwise, if the component is in other state, e.g., INACTIVE, or // READABLE_UNWRITABLE_FLUSHING, it's not considered as being recycled here. 
 // #. flush the internal dataset // We need this to guarantee the correctness of component Id acceleration for secondary-to-primary index. 
 boolean missing(); 
 } else if (cmp == IdCompareResult.GREATER_THAN) { 
 } else if (cmp == IdCompareResult.GREATER_THAN) { 
 } else if (cmp == IdCompareResult.GREATER_THAN) { 
 throw CompilationException.create(ErrorCode.COMPILATION_TRANSLATION_ERROR, e); 
 int[] sortFields, INormalizedKeyComputerFactory[] keyNormalizerFactories, 
 static IBinaryComparatorFactory[] SortFieldsComparatorFactories = new IBinaryComparatorFactory[] { PointableBinaryComparatorFactory.of(UTF8StringPointable.FACTORY), PointableBinaryComparatorFactory.of(UTF8StringPointable.FACTORY) }; 
 outputSerDes[f] = FormatUtils.getDefaultFormat().getSerdeProvider().getSerializerDeserializer(metaItemType); 
 TimeUnit.MILLISECONDS.sleep(100); 
<|del|> 
<|del|> 
 }); 
 if (dsModifyCounter.decrementAndGet() == 0) { 
 } 
 if (indexBuildCounter.decrementAndGet() == 0) { 
 // No op 
 } 
<|del|> 
 // if idGeneratorFactory is not set for legacy lsm indexes, we return a default // component id generator which always generates the missing component id. 
 TypeUtil.Global.append(sb, txnIdToJobSlotMap.get(i)); 
 if (!jobRecoveryFile.createNewFile()) { throw new IOException("Failed to create file: " + fileName + " for job id(" + jobId + ")"); } 
 "no need to roll back as there were no operations by the job " + txnContext.getJobId()); 
 //send goodbye to remote replica 
 sb.append(">>dump_begin\t>>----- [txnIdSlotMap] -----\n"); for (Long i : txnIdToJobSlotMap.keySet()) { 
 TypeUtil.Global.append(sb, txnIdToJobSlotMap.get(i)); 
 private static final int POOL_SIZE = 1; 
<|del|> 
 private void readObjectNoData() throws ObjectStreamException { idGeneratorFactory = new ILSMComponentIdGeneratorFactory() { private static final long serialVersionUID = 1L; 
<|del|> 
 if (!forBuddyBtree) { 
 if (forBuddyBtree) { 
 ioOpCallback.updateLastLSN(logRecord.getLSN()); //schedule flush after update accessor.scheduleFlush(lsmIndex.getIOOperationCallback()); 
 ioOpCallback.updateLastLSN(logRecord.getLSN()); //schedule flush after update accessor.scheduleFlush(lsmIndex.getIOOperationCallback()); 
<|del|> 
 : new PrimaryIndexInstantSearchOperationCallbackFactory(dataset.getDatasetId(), 
<|del|> 
 private TransactionContextFactory() { } 
 return; 
 * transaction is ongoing and has not yet committed/aborted. COMMITTED: The 
 throw new ACIDException(e); 
 * Sets the maximum txn id to the bigger value of {@code txnId} and its current value. 
<|del|> 
 throw new IllegalStateException("Disk components can't be removed from the search operation"); 
 pushOutputElementIntoQueueIfNeeded(); 
 } if (opType == LSMOperationType.ROLLBACK) { lsmIndex.getDiskComponents().remove(c); } 
 throws HyracksDataException { 
 throws HyracksDataException { 
 throws HyracksDataException { 
 throws HyracksDataException { 
 if (compare(cmp, outputElement.getTuple(), queueHead.getTuple()) == 0) { 
<|del|> 
 } if (opType == LSMOperationType.ROLLBACK) { lsmIndex.getDiskComponents().remove(c); } 
 for (ILSMDiskComponent inactiveComp : inactiveDiskComponents) { if (inactiveComp.getFileReferenceCount() == 1) { 
 throws HyracksDataException { 
 throws HyracksDataException { 
 throws HyracksDataException { 
 throws HyracksDataException { 
 public Set<VariableExpr> getLiveVariables() { 
 public static Set<VariableExpr> getLiveVariables(Scope scope, boolean includeWithVariables) { 
<|del|> 
<|del|> 
<|del|> 
 this.arguments = arguments; 
 /* 
 //initialize replication channel replicationChannel = new ReplicationChannel(nodeId, replicationProperties, txnSubsystem.getLogManager(), replicaResourcesManager, replicationManager, getServiceContext(), asterixAppRuntimeContextProvider, replicationManager.getReplicationStrategy()); 
 bufferCache = new BufferCache(ioManager, prs, pcp, new FileMapManager(), storageProperties.getBufferCacheMaxOpenFiles(), getServiceContext().getThreadFactory()); 
 @Override public Section section() { return Section.COMMON; } 
 @Override public String description() { // TODO(mblow): add missing descriptions return null; } 
 @Override public String description() { // TODO(mblow): add missing descriptions return null; } 
 ITypeTraits[] typeTraits = DatasetUtil.computeTupleTypeTraits(dataset, itemType, null); IBinaryComparatorFactory[] comparatorFactories = DatasetUtil.computeKeysBinaryComparatorFactories(dataset, 
 INCApplicationContext appContext, IAppRuntimeContextProvider asterixAppRuntimeContextProvider) { 
 public ReplicationManager(String nodeId, ReplicationProperties replicationProperties, 
 this.replicationProperties = replicationProperties; try { replicationStrategy = ReplicationStrategyFactory.create(replicationProperties.getReplicationStrategy(), replicationProperties, ncConfig.getConfigManager()); } catch (HyracksDataException e) { LOGGER.warning("Unable to initialize replication strategy"); } 
<|del|> 
 txnCommitAcks = new ConcurrentHashMap<>(); replicationTxnsPendingAcks = new ConcurrentHashMap<>(); shuttingDownReplicaIds = new HashSet<>(); 
 Thread.currentThread().interrupt(); 
 Replica replica = replicas.get(replicaId); if (replica == null) { return; } 
 Replica replica = replicas.get(replicaId); if (replica == null) { return; } 
 Replica replica = replicas.get(replicaId); if (replica == null) { return; } 
 LOGGER.log(Level.INFO, "Stopping ClusterControllerService"); stopApplication(); 
 private static AsterixPropertiesAccessor propertiesAccessor; 
 bufferCache = new BufferCache(ioManager, prs, pcp, new FileMapManager(), storageProperties.getBufferCacheMaxOpenFiles(), getServiceContext().getThreadFactory(), replicationManager); } 
 public DatasetLifecycleManager(AsterixStorageProperties storageProperties, ILocalResourceRepository resourceRepository, int firstAvilableUserDatasetID, ILogManager logManager, int numPartitions) { 
 ccServiceCtx.addJobLifecycleListener(appCtx.getActiveNotificationHandler()); 
 ccServiceCtx.addJobLifecycleListener(appCtx.getActiveNotificationHandler()); 
 private static FileSplit[] getDataverseSplits(IClusterStateManager clusterStateManager, String dataverseName) { 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, String storagePathPrefix, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
 private IReplicationStrategy replicationStrategy; 
 private final PersistentLocalResourceRepository localResourceRepo; private NCConfig ncConfig; 
 IAppRuntimeContextProvider asterixAppRuntimeContextProvider, INCServiceContext ncServiceContext) { 
 try { replicationStrategy = ReplicationStrategyFactory.create(replicationProperties.getReplicationStrategy(), replicationProperties, ncConfig.getConfigManager()); } catch (HyracksDataException e) { LOGGER.warning("Unable to initialize replication strategy"); } 
 localResourceRepo = (PersistentLocalResourceRepository) asterixAppRuntimeContextProvider.getLocalResourceRepository(); this.hostIPAddressFirstOctet = ncConfig.getPublicAddress().substring(0, 3); 
 Replica replica = new Replica(nodeId, NetworkingUtil.getHostAddress(hostIPAddressFirstOctet), ncConfig.getReplicationPublicPort()); 
 IApplicationConfig config = ncConfig.getConfigManager().getNodeEffectiveConfig(replicaId); sc.connect(new InetSocketAddress(config.getString(NCConfig.Option.REPLICATION_LISTEN_ADDRESS), config.getInt(NCConfig.Option.REPLICATION_LISTEN_PORT))); 
 IApplicationConfig config = ncConfig.getConfigManager().getNodeEffectiveConfig(replicaId); sc.connect(new InetSocketAddress(config.getString(NCConfig.Option.REPLICATION_LISTEN_ADDRESS), config.getInt(NCConfig.Option.REPLICATION_LISTEN_PORT))); 
 LOGGER.log(Level.INFO, "Stopping ClusterControllerService"); stopApplication(); 
 Set<String> remotePrimaryReplicas = replicationProperties.getRemotePrimaryReplicasIds(nodeId); for (String clientId : remotePrimaryReplicas) { 
 //initialize replication channel replicationChannel = new ReplicationChannel(nodeId, replicationProperties, txnSubsystem.getLogManager(), replicaResourcesManager, replicationManager, getServiceContext(), asterixAppRuntimeContextProvider, replicationManager.getReplicationStrategy()); 
 bufferCache = new BufferCache(ioManager, prs, pcp, new FileMapManager(), storageProperties.getBufferCacheMaxOpenFiles(), getServiceContext().getThreadFactory()); 
 ReplicationProperties repProperties = asterixAppRuntimeContextProvider.getAppContext().getReplicationProperties(); final boolean replicationEnabled = repProperties.isReplicationEnabled(); 
 if (startupQueue.keySet().size() == nodeIds.size() - 1) { startupQueue.put(nodeId, state); for (Map.Entry<String, SystemState> nodeState : startupQueue.entrySet()) { 
 if (startupQueue.keySet().size() == nodeIds.size() - 1) { startupQueue.put(nodeId, state); for (Map.Entry<String, SystemState> nodeState : startupQueue.entrySet()) { 
 if (startupQueue.keySet().size() == nodeIds.size() - 1) { startupQueue.put(nodeId, state); for (Map.Entry<String, SystemState> nodeState : startupQueue.entrySet()) { 
 if (startupQueue.keySet().size() == nodeIds.size() - 1) { startupQueue.put(nodeId, state); for (Map.Entry<String, SystemState> nodeState : startupQueue.entrySet()) { 
 if (startupQueue.keySet().size() == nodeIds.size() - 1) { startupQueue.put(nodeId, state); for (Map.Entry<String, SystemState> nodeState : startupQueue.entrySet()) { 
 if (startupQueue.keySet().size() == nodeIds.size() - 1) { startupQueue.put(nodeId, state); for (Map.Entry<String, SystemState> nodeState : startupQueue.entrySet()) { 
 RegistrationTasksResponseMessage response = new RegistrationTasksResponseMessage(nodeState.getKey(), tasks); 
 } } else { startupQueue.put(nodeId, state); 
 } } else { startupQueue.put(nodeId, state); 
 } } else { startupQueue.put(nodeId, state); 
<|del|> 
 } else { 
 } else { 
 public String getStorageSubDir() { return storageSubDir; } 
<|del|> 
<|del|> 
<|del|> 
 public Set<Replica> getRemoteReplicasAndSelf(String nodeId) { 
 public String getClusterIp() { return ipAddr; } public void setClusterIp(String ip) { 
 public int getPort() { return port; 
 public void setPort(int port) { 
 public void setPort(int port) { 
 public boolean equals(Object o) { if (!(o instanceof Replica)) { 
 public boolean equals(Object o) { if (!(o instanceof Replica)) { 
 public int hashCode() { 
<|del|> 
 public ReplicationManager(String nodeId, AsterixReplicationProperties replicationProperties, 
 public ReplicationManager(String nodeId, AsterixReplicationProperties replicationProperties, 
<|del|> 
 Replica replica = replicas.get(replicaId); 
 Replica replica = replicas.get(replicaId); 
 Replica replica = replicas.get(replicaId); 
<|del|> 
<|del|> 
<|del|> 
 if (!success) { 
 if (!success) { 
 File storageRootDir = getStorageRootDirectoryIfExists(ioManager, mountPoints[i], nodeId, i); 
 LOGGER.log(Level.WARN, "resource was not found for resource id " + resourceId); 
 // lsn @ maxDiskLastLsn is either a flush log or a master replica log if (lsn >= maxDiskLastLsn) { 
 int FILTER_UPDATE_HEADER_LEN = RS_PARTITION_LEN + DatasetId.BYTES; 
 throw new IllegalStateException(); 
 throw new IllegalStateException(); 
 * whether the operator is used for final stage aggregation 
 public void allocatedCalled(ILSMMemoryComponent component) { 
 public void allocatedReturned(ILSMMemoryComponent component) { 
 webManager = new WebManager(); 
<|del|> 
 } // If the metadata node (or replica) failed and lost its data // => Metadata Remote Recovery from standby replica 
 Map<String, ClusterPartition[]> nodePartitions = ((IPropertiesProvider) asterixAppRuntimeContextProvider.getAppContext()).getMetadataProperties() .getNodePartitions(); 
 } stop(); 
 StoragePathUtil.prepareStoragePartitionPath(storageDirName, clusterPartition[j].getPartitionId()) 
 try (FileInputStream fis = new FileInputStream(file); ObjectInputStream oisFromFis = new ObjectInputStream( fis)) { 
 int numTuplesPerDeleteRound = (int) Math .ceil((float) ctx.getCheckTuples().size() / (float) numDeleteRounds); 
<|del|> 
<|del|> 
 private static final int REPLICATION_FACTOR_DEFAULT = 1; 
 private final String nodeNamePrefix; public ReplicationProperties(PropertiesAccessor accessor) { 
 private final String nodeNamePrefix; public ReplicationProperties(PropertiesAccessor accessor) { 
 ITypeTraits[] typeTraits = DatasetUtil.computeTupleTypeTraits(dataset, itemType, null); IBinaryComparatorFactory[] comparatorFactories = DatasetUtil.computeKeysBinaryComparatorFactories(dataset, 
 private static FileSplit[] getDataverseSplits(IClusterStateManager clusterStateManager, String dataverseName) { 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, String storagePathPrefix, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
 // Starts ncs. int n = 0; 
 case BOOTSTRAPPING: 
 application.stop(); 
 return true; } 
 public static final Node CLIENT_NODE = new Node(CLIENT_NODE_ID, CLUSTER_IP, null, null, null, null, null, null, null); 
 ScalarFunctionCallExpression notFuncExpr = (ScalarFunctionCallExpression) selectOp.getCondition().getValue(); 
 public static void resetLOJMissingPlaceholderVarInGroupByOp(AccessMethodAnalysisContext analysisCtx, LogicalVariable newMissingPlaceholderVaraible, IOptimizationContext context) throws AlgebricksException { 
 // Match datasource information if there are no (assign | unnest)* 
 bufferCache.unpin(currentPage); currentPage = bufferCache.pin(BufferedFileHandle.getDiskPageId(getFileId(), childPageId), false); ctx.getInteriorFrame().setPage(currentPage); 
 if (!ctx.isExceptionHandled() && currentPage != null) { bufferCache.unpin(currentPage); ctx.setExceptionHandled(true); 
 ccConfig.clusterNetIpAddress = Inet4Address.getLoopbackAddress().getHostAddress(); ccConfig.clientNetIpAddress = Inet4Address.getLoopbackAddress().getHostAddress(); 
 if (replicationManager.getReplicationStrategy().isParticipant(getServiceContext().getNodeId())) { 
 remoteRecoveryManager = new RemoteRecoveryManager(replicationManager, this, replicationProperties); 
<|del|> 
<|del|> 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, String storagePathPrefix, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, String storagePathPrefix, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
<|del|> 
 IReplicaResourcesManager replicaResoucesManager, IReplicationManager replicationManager, INCApplicationContext appContext, IAppRuntimeContextProvider asterixAppRuntimeContextProvider) { 
 ((IPropertiesProvider) asterixAppRuntimeContextProvider.getAppContext()).getMetadataProperties() .getNodePartitions(); Set<String> nodeReplicationClients = replicationProperties.getNodeReplicationClients(nodeId); 
 final TriggerNCWork startNc = new TriggerNCWork(ClusterControllerService.this, ncServiceAddress.getLeft(), ncServiceAddress.getRight(), nodeId); 
 functionDecls = retrieveStoredFunctions(metadataProvider, functionDecl.getFuncBody(), declaredFunctions, functionDecls, functionCollector, functionParser, functionNormalizer); 
 public TransactionSubsystem(INCServiceContext serviceCtx, String id, 
 public static FileSplit[] splitsForAdapter(ICcApplicationContext appCtx, String dataverseName, String feedName, 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, String storagePathPrefix, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, String storagePathPrefix, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
 ((IPropertiesProvider) asterixAppRuntimeContextProvider.getAppContext()).getMetadataProperties() 
<|del|> 
 this.logManager = logManager; localResourceRepo = (PersistentLocalResourceRepository) asterixAppRuntimeContextProvider.getLocalResourceRepository(); this.hostIPAddressFirstOctet = ncConfig.getPublicAddress().substring(0, 3); replicas = new HashMap<>(); 
 txnCommitAcks = new ConcurrentHashMap<>(); replicationTxnsPendingAcks = new ConcurrentHashMap<>(); 
 dataBuffer = ByteBuffer.allocate(INITIAL_BUFFER_SIZE); replicationMonitor = new ReplicasEventsMonitor(); //add list of replicas from configurations (To be read from another source e.g. Zookeeper) Set<Replica> replicaNodes = replicationStrategy.getRemoteReplicas(nodeId); 
 dataBuffer = ByteBuffer.allocate(INITIAL_BUFFER_SIZE); replicationMonitor = new ReplicasEventsMonitor(); //add list of replicas from configurations (To be read from another source e.g. Zookeeper) Set<Replica> replicaNodes = replicationStrategy.getRemoteReplicas(nodeId); 
 replicasIds.add(replica.getId()); 
 replicasIds.add(replica.getId()); 
 for (Replica locationRep : locations) { String location = locationRep.getId(); 
 LOGGER.warning("Using the path: " + tempPath); 
 if (replicationManager.getReplicationStrategy().isParticipant(getServiceContext().getNodeId())) { 
 return new FeedLogManager( FeedUtils.getAbsoluteFileRef(feedLogFileSplit.getPath(), 0, ctx.getIoManager()).getFile()); 
 lsmComponentId2PropertiesMap = new ConcurrentHashMap<>(); 
 txnCommitAcks = new ConcurrentHashMap<>(); replicationTxnsPendingAcks = new ConcurrentHashMap<>(); shuttingDownReplicaIds = new HashSet<>(); 
 txnCommitAcks = new ConcurrentHashMap<>(); replicationTxnsPendingAcks = new ConcurrentHashMap<>(); shuttingDownReplicaIds = new HashSet<>(); 
<|del|> 
<|del|> 
 Thread.currentThread().interrupt(); 
 if (locations.isEmpty()) { 
 public Map<Long, DatasetResourceReference> getLaggingReplicaIndexesId2PathMap(String replicaId, long targetLSN) throws HyracksDataException { 
 * with the latest valid {@code componentTimestamp} and low watermark {@code lsn} 
 * Advance the index low watermark to {@code lsn} 
 // we use cache line size as the block size (64 bytes) private static final int NUM_BITS_PER_BLOCK = 64 * 8; 
 private boolean blockContains(long[] hashes) throws HyracksDataException { 
 private boolean legacyContains(long[] hashes) throws HyracksDataException { 
 opts.stream().forEach(opt -> configManager.set(opt.getLeft(), opt.getRight())); 
 opts.stream().forEach(opt -> configManager.set(opt.getLeft(), opt.getRight())); 
 OutputStream out = new FileOutputStream(entryDestination)) { 
 replicationManager = new ReplicationManager(nodeId, replicationProperties, replicaResourcesManager, txnSubsystem.getLogManager(), asterixAppRuntimeContextProvider, ncServiceContext); 
 replicationManager = new ReplicationManager(nodeId, replicationProperties, replicaResourcesManager, txnSubsystem.getLogManager(), asterixAppRuntimeContextProvider, ncServiceContext); 
 remoteRecoveryManager = new RemoteRecoveryManager(replicationManager, this, replicationProperties); 
<|del|> 
<|del|> 
 Set<String> partitionReplicas = replicationStrategy.getRemoteReplicas(partition.getNodeId()).stream() .map(Replica::getId).collect(Collectors.toSet()); 
 Set<String> nodeReplicas = replicationStrategy.getRemoteReplicas(failingBackNodeId).stream().map(Replica::getId) .collect(Collectors.toSet()); 
 Set<String> nodeReplicas = replicationStrategy.getRemoteReplicas(failingBackNodeId).stream().map(Replica::getId) .collect(Collectors.toSet()); 
 Set<String> nodeReplicas = replicationStrategy.getRemoteReplicas(failingBackNodeId).stream().map(Replica::getId) .collect(Collectors.toSet()); 
 RegistrationTasksResponseMessage response = new RegistrationTasksResponseMessage(nodeState.getKey(), tasks); 
 public static IFaultToleranceStrategy create(ICCServiceContext serviceCtx, ReplicationProperties repProp, IReplicationStrategy strategy) { 
 if ("metadata_only".equals(repProp.getReplicationStrategy())) { 
 if (failedNodes.isEmpty()) { //bootstrap 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public String getTxnLogDir() { 
 public String getStorageSubdir() { 
 ClusterPartition partition = new ClusterPartition(uniquePartitionId.getAndIncrement(), ncId, i, storageSubdir); 
 replicas.add(new Replica(nodeId, configManager.getNodeEffectiveConfig(nodeId).getString(NCConfig.Option.REPLICATION_LISTEN_ADDRESS), configManager.getNodeEffectiveConfig(nodeId).getInt(NCConfig.Option.REPLICATION_LISTEN_PORT))); 
 clientReplicas.add(new Replica(replica, configManager.getNodeEffectiveConfig(replica).getString(NCConfig.Option.REPLICATION_LISTEN_ADDRESS), configManager.getNodeEffectiveConfig(replica).getInt(NCConfig.Option.REPLICATION_LISTEN_PORT))); 
 public ChainedDeclusteringReplicationStrategy from(ReplicationProperties repProp, IConfigManager configManager) throws HyracksDataException { 
 public Set<Replica> getRemoteReplicasAndSelf(String nodeId) { 
 public MetadataOnlyReplicationStrategy from(ReplicationProperties p, IConfigManager configManager) throws HyracksDataException { 
 AlgebricksPartitionConstraint partitionConstraints) throws AsterixException { 
 return SplitsAndConstraintsUtil.getIndexSplits(dataset, indexName, appCtx.getNodeProperties().getStorageSubdir(), mdTxnCtx, appCtx.getClusterStateManager()); 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, String storagePathPrefix, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, String storagePathPrefix, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
 throw new AlgebricksException(me); 
 boolean suspendReplication) { 
 InetSocketAddress replicaAddress = InetSocketAddress.createUnresolved(replica.getClusterIp(), replica.getPort()); 
<|del|> 
 IReplicaResourcesManager remoteResoucesManager, ILogManager logManager, IAppRuntimeContextProvider asterixAppRuntimeContextProvider, INCServiceContext ncServiceContext) { 
 IReplicaResourcesManager remoteResoucesManager, ILogManager logManager, IAppRuntimeContextProvider asterixAppRuntimeContextProvider, INCServiceContext ncServiceContext) { 
 LOGGER.warning("Unable to initialize replication strategy"); 
 LOGGER.warning("Unable to initialize replication strategy"); 
 Replica replica = new Replica(nodeId, NetworkingUtil.getHostAddress(hostIPAddressFirstOctet), ncConfig.getReplicationPublicPort()); 
<|del|> 
<|del|> 
<|del|> 
 recycledObjects = new ArrayDeque<>(); 
 read(checkpointPath); 
 return indexCheckpointManagerMap.computeIfAbsent(ref, this::create); 
 joinPath("asterixdb", "asterix-app", "src", "test", "resources", "cc.conf"); 
 public ClusterControllerService cc; //NOSONAR public NodeControllerService[] ncs = new NodeControllerService[2]; //NOSONAR public IHyracksClientConnection hcc; //NOSONAR 
 public ClusterControllerService cc; //NOSONAR public NodeControllerService[] ncs = new NodeControllerService[2]; //NOSONAR public IHyracksClientConnection hcc; //NOSONAR 
 public ClusterControllerService cc; //NOSONAR public NodeControllerService[] ncs = new NodeControllerService[2]; //NOSONAR public IHyracksClientConnection hcc; //NOSONAR 
<|del|> 
<|del|> 
 } else if (!failedNodes.isEmpty()) { 
 public static FileSplit[] getIndexSplits(Dataset dataset, String indexName, MetadataTransactionContext mdTxnCtx, IClusterStateManager csm) throws AlgebricksException { 
 throw new AlgebricksException(me); 
 LOGGER.warning("Unable to initialize replication strategy: " + e.getMessage()); 
 stringSerDe.serialize(aString, serializedFieldName.getDataOutput()); 
 String libraryName, ExternalLibrary library) throws ACIDException, RemoteException { 
 public ClusterControllerService cc; //NOSONAR public NodeControllerService[] ncs = new NodeControllerService[2]; //NOSONAR public IHyracksClientConnection hcc; //NOSONAR 
 public ClusterControllerService cc; //NOSONAR public NodeControllerService[] ncs = new NodeControllerService[2]; //NOSONAR public IHyracksClientConnection hcc; //NOSONAR 
 this.logManager = replicationEnabled ? new LogManagerWithReplication(this) : new LogManager(this); 
 clazz = AutoFaultToleranceStrategy.class; 
 nodeIdAddress = (String) activeNcConfiguration.get(nodeId).get(NCConfig.Option.REPLICATION_PUBLIC_ADDRESS); nodePort = (int) activeNcConfiguration.get(nodeId).get(NCConfig.Option.REPLICATION_PUBLIC_PORT); 
 if (activeNcConfiguration.containsKey(replica)) { 
 TestHelper.deleteExistingInstanceFiles(); 
 TestHelper.deleteExistingInstanceFiles(); 
 integrationUtil.init(true, AsterixHyracksIntegrationUtil.DEFAULT_CONF_FILE); 
 integrationUtil.init(true, TEST_CONFIG_FILE_NAME); 
 integrationUtil.init(true, TEST_CONFIG_FILE_NAME); 
 integrationUtil.init(true, TEST_CONFIG_FILE_NAME); 
 boolean toRun = TestHelper.isInPrefixList(only, queryFileShort); 
 boolean skipped = TestHelper.isInPrefixList(ignore, queryFileShort); 
 return setUp(cleanup, AsterixHyracksIntegrationUtil.DEFAULT_CONF_FILE, integrationUtil, true, null); 
 return setUp(cleanup, configFile, integrationUtil, true, null); 
 integrationUtil.init(cleanup, configFile); 
 boolean toRun = TestHelper.isInPrefixList(only, queryFileShort); 
 TestHelper.deleteExistingInstanceFiles(); 
 TestHelper.deleteExistingInstanceFiles(); 
 integrationUtil.init(true, DEFAULT_TEST_CONFIG_FILE_NAME); 
 integrationUtil.init(false, DEFAULT_TEST_CONFIG_FILE_NAME); 
 integrationUtil.addOption(StorageProperties.Option.STORAGE_MEMORYCOMPONENT_GLOBALBUDGET, "128MB"); integrationUtil.addOption(StorageProperties.Option.STORAGE_MEMORYCOMPONENT_NUMPAGES, 32); 
 integrationUtil.init(true, TEST_CONFIG_FILE_PATH); 
<|del|> 
 throw new AlgebricksException(me); 
 LOGGER.warning("Unable to initialize replication strategy: " + e.getMessage()); 
 FileUtils.copyFile(externalTestsJar, new File(NCServiceExecutionIT.APP_HOME + "/repo", externalTestsJar.getName())); 
 FileUtils.copyDirectoryStructure(new File(joinPath("..", "asterix-app", "data")), 
 // FileUtils.copyDirectoryStructure(new File(FileUtil.joinPath("target", "data")), // new File(NCServiceExecutionIT.ASTERIX_APP_DIR // + "/clusters/local/working_dir/target/data/csv")); 
 TestHelper.unzip(installerZip, OUTPUT_DIR); 
 boolean loggable = LOGGER.isLoggable(Level.FINE); if (loggable) { 
 && Objects.equals(withVarMap, target.withVarMap); // NOSONAR 
 && Objects.equals(value, other.value); // NOSONAR 
 && Objects.equals(undeclaredFieldsDataGen, target.getUndeclaredFieldsDataGen()); // NOSONAR 
 && varCounter == target.varCounter; // NOSONAR 
 && Objects.equals(orderbyClause, target.orderbyClause) && subquery == target.subquery && Objects.equals(selectSetOperation, target.selectSetOperation); // NOSONAR 
 return Objects.equals(condition, target.condition) && Objects.equals(datasetName, target.datasetName) && Objects.equals(dataverseName, target.dataverseName) && Objects.equals(rewrittenQuery, target.rewrittenQuery) && Objects.equals(vars, target.vars) && varCounter == target.varCounter; 
 && Objects.equals(query, target.query) && Objects.equals(var, target.var) && Objects.equals(returnExpression, target.returnExpression) && varCounter == target.varCounter; 
 && Objects.equals(query, target.query) && Objects.equals(var, target.var) && Objects.equals(returnExpression, target.returnExpression) && varCounter == target.varCounter; 
 return explain == target.explain && Objects.equals(body, target.body) && topLevel == target.topLevel && varCounter == target.varCounter; 
 return Objects.equals(expr, target.expr) && Objects.equals(name, target.name) && exprStar == target.exprStar && star == target.star; 
 && Objects.equals(selectSetOperation, target.selectSetOperation) && subquery == target.subquery; 
 private static final String TARGET_DIR = FileUtil.joinPath(".", "target"); private static final String LOG_DIR = FileUtil.joinPath(TARGET_DIR, "failsafe-reports"); 
 private static final String APP_HOME = FileUtil.joinPath(TARGET_DIR, "appassembler"); 
 private static final String APP_HOME = FileUtil.joinPath(TARGET_DIR, "appassembler"); 
 rewriteExpressionUsingGroupVariable(groupVar, groupFieldVars, letClauseAfterGby, visibleVarsPreGroupByScope); 
 rewriteExpressionUsingGroupVariable(groupVar, groupFieldVars, orderbyClause, visibleVarsPreGroupByScope); 
 rewriteExpressionUsingGroupVariable(groupVar, groupFieldVars, limitClause, visibleVarsPreGroupByScope); 
 case 1: 
 default: 
 throw new CompilationException( "Cannot resolve ambiguous alias reference for undefined identifier " + SqlppVariableUtil .toUserDefinedVariableName(varName).getValue() + " in " + localVars); 
 throw new CompilationException( "Cannot resolve ambiguous alias reference for undefined identifier " + SqlppVariableUtil .toUserDefinedVariableName(varName).getValue() + " in " + localVars); 
 ioManager, getServiceContext().getNodeId(), metadataProperties, indexCheckpointManagerProvider); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = getSplitProviderAndConstraints(dataset, secondaryIndex.getIndexName()); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = getSplitProviderAndConstraints(dataset, secondaryIndex.getIndexName()); 
 Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = getSplitProviderAndConstraints(dataset, secondaryIndex.getIndexName()); 
 } catch (HyracksDataException e) { //NOSONAR 
 requestBuffer = ReplicationProtocol.writeLSMComponentPropertiesRequest(lsmCompProp, //NOSONAR 
<|del|> 
<|del|> 
 if (!listener.getExecutorService().awaitTermination(BADConstants.EXECUTOR_TIMEOUT, TimeUnit.SECONDS)) { 
 && Objects.equals(withVarMap, target.withVarMap); 
 && Objects.equals(value, other.value); 
 && Objects.equals(undeclaredFieldsDataGen, target.getUndeclaredFieldsDataGen()); 
 && varCounter == target.varCounter; 
 && varCounter == target.varCounter && Objects.equals(var, target.var); 
 && Objects.equals(selectSetOperation, target.selectSetOperation); 
 private VarIdentifier lookupVariable(String varName) throws CompilationException { 
 private VarIdentifier lookupVariable(String varName) throws CompilationException { 
 private static final String RESOURCE_DIR = FileUtil.joinPath(TARGET_DIR, "test-classes", "NCServiceIT"); 
 private void processMetadataNode(IServletRequest request, IServletResponse response) throws HyracksDataException { 
<|del|> 
<|del|> 
 public static void init() { // Only execute the static block 
 throws AlgebricksException, HyracksDataException { // No Op 
 return Collections.emptyList(); 
 ILocalResourceRepositoryFactory persistentLocalResourceRepositoryFactory = new PersistentLocalResourceRepositoryFactory(ioManager, getServiceContext().getNodeId(), metadataProperties, indexCheckpointManagerProvider); 
 final Set<Integer> nodePartitionsIds = Arrays.stream(nodePartitions).map(ClusterPartition::getPartitionId).collect(Collectors.toSet()); 
 } catch (HyracksDataException e) { //NOSONAR 
 case 1: 
 default: 
 default: 
 } else { 
 public VarIdentifier(VarIdentifier v) { 
 public ClusterControllerService cc; //NOSONAR public NodeControllerService[] ncs = new NodeControllerService[2]; //NOSONAR public IHyracksClientConnection hcc; //NOSONAR 
 public ClusterControllerService cc; //NOSONAR public NodeControllerService[] ncs = new NodeControllerService[2]; //NOSONAR public IHyracksClientConnection hcc; //NOSONAR 
 public ClusterControllerService cc; //NOSONAR public NodeControllerService[] ncs = new NodeControllerService[2]; //NOSONAR public IHyracksClientConnection hcc; //NOSONAR 
 public void init(boolean deleteOldInstanceData, String confFile) throws Exception { //NOSONAR 
 try (InputStream in = zipFile.getInputStream(entry); //NOSONAR 
 } catch (HyracksDataException e) { LOGGER.log(Level.WARNING,"Couldn't initialize replication strategy",e); 
 } catch (HyracksDataException e) { LOGGER.log(Level.WARNING,"Couldn't initialize replication strategy",e); 
<|del|> 
 @SuppressWarnings("squid:CommentedOutCodeLine") 
 //cList.add("-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005"); //NOSONAR 
 //cList.add("-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005"); //NOSONAR 
 LOGGER.info(() -> "Deleted file: " + localFile.getAbsolutePath()); } else { LOGGER.warning(() -> "Requested to delete a non-existing file: " + localFile.getAbsolutePath()); 
 replicateMissingFiles(replicaMissingFiles); 
<|del|> 
 public ClusterControllerService cc; public NodeControllerService[] ncs = new NodeControllerService[2]; public IHyracksClientConnection hcc; 
 public ClusterControllerService cc; public NodeControllerService[] ncs = new NodeControllerService[2]; public IHyracksClientConnection hcc; 
<|del|> 
 try (InputStream in = zipFile.getInputStream(entry); 
 nkc.normalize(bytes, start + Long.BYTES, length - Long.BYTES, normalizedKeys, keyStart + int64NormalizedKeyLength); 
 return null; //NOSONAR 
 if (f == 0 && nmkComputer != null) { nmkComputer.normalize(b1, tPointers[normalizedKeyLength], tPointers[normalizedKeyLength + 1], tPointers, 0); 
 private static final Logger LOGGER = LogManager.getLogger(); 
 if (!checkpointFiles[i].delete() && LOGGER.isWarnEnabled()) { LOGGER.warn("Could not delete checkpoint file at: " + checkpointFiles[i].getAbsolutePath()); 
 if (LOGGER.isLoggable(Level.INFO)) { 
 if (LOGGER.isLoggable(Level.INFO)) { 
 private static final Logger LOGGER = LogManager.getLogger(); 
 private static final Logger LOGGER = LogManager.getLogger(); 
 private static final Logger LOGGER = LogManager.getLogger(); 
 LOGGER.debug("final runs: {}", stop); 
 if (LOGGER.isLoggable(Level.FINE)) { LOGGER.log(Level.FINE, "trying to get " + key + " from immutable memory components number: " + (i + 1)); 
<|del|> 
<|del|> 
 return seq.compareTo(o.seq); 
 @Override protected void post(IServletRequest request, IServletResponse response) throws IOException { 
 private int seqNum; 
<|del|> 
 String metaTypeName = FeedUtils.getFeedMetaTypeName(sourceFeed.getConfiguration()); 
 public Map<String, String> getConfiguration(); 
 public Map<String, String> getConfiguration() throws CompilationException{ return MergePolicyUtils.toProperties(withObjectNode); 
 if (cfs.getWithObjectNode() != null) { out.print(" with "); out.print(cfs.getWithObjectNode().toString()); } 
 public Map<String, String> getConfiguration() throws CompilationException { 
 lsmHarness.updateFilter(ctx, tuple, callback); 
 * 
 final RandomAccessFile raf = new RandomAccessFile(targetFilePath.toFile(), "rw"); // NOSONAR closed by LogBuffer 
<|del|> 
 lsmAccessor.updateFilter(prevTuple); 
 void isFlushed(boolean isFlushed); 
<|del|> 
 // Quick Mocking the options for CORS 
 // Quick Mocking the options for CORS, not sure if the headers are needed or not 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 return currentElementIxForScan < numElements; 
<|del|> 
 public OnDiskInvertedIndexRangeSearchCursor(IInPlaceInvertedIndex invIndex, IIndexOperationContext opCtx) throws HyracksDataException { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public enum processType { 
 public boolean merge(List<IInvertedListCursor> invListCursors, int occurrenceThreshold, int numPrefixLists, 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 db.addBuiltin(ScalarFunction.createBuiltinOperator( Operator.MOD.getName(), Lists.<Type>newArrayList( Type.DECIMAL, Type.DECIMAL), Type.DECIMAL)); 
 if ((t0.isFloatingPointType() || t1.isFloatingPointType()) && op_ == ArithmeticExpr.Operator.MOD) { fnName = "fmod"; } 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Returns all files info of a table or partition. */ 
<|del|>
 keyVal[1] = table.getNullPartitionKeyValue(); } 
 * Add partitions in metastore which exist in HDFS but not in metastore. 
 Table table = getExistingTable(tableName.getDb(), tableName.getTbl()); 
 Table table = getExistingTable(tableName.getDb(), tableName.getTbl()); 
 hdfsTable, new Path(hdfsTable.getHdfsBaseDir()), path); // Set "ifNotExists" to be true to skip partition creation // if the target partition already exists. 
<|del|> 
 private final CachedHmsPartitionDescriptor cachedMsPartitionDescriptor_; 
 * Serialises a TPartitionStats object to a partition. 
 private TableName tableName_; // Show files for all the partitions if this is null. 
 partitionSpec_.setPrivilegeRequirement(Privilege.VIEW_METADATA); 
<|del|> 
 * Returns files info for the given dbname/tableName and partition spec. * Returns files info for all partitions if partition spec is null. 
 * Returns files info for the given dbname/tableName and partition spec. * Returns files info for all partitions if partition spec is null. 
 Preconditions.checkState(partition != null); partitions = Lists.newArrayList(partition); 
 throw new InternalException("SHOW FILES only supports Hdfs table. " + "Unsupported table class: " + table.getClass()); 
<|del|> 
 ParserError("SHOW FILES IN"); // Invalid partition. ParserError("SHOW FILES IN db.tbl PARTITION(p)"); 
 // Make sure the target table is HdfsTable. if (!(table_ instanceof HdfsTable)) { throw new AnalysisException(toSql() + " must target an HDFS table: " + table_.getFullName()); } 
 // Make sure the target table is HdfsTable. if (!(table_ instanceof HdfsTable)) { throw new AnalysisException(toSql() + " must target an HDFS table: " + table_.getFullName()); } 
 * Generate List<TPartitionKeyValue> for a specified Path. * @path must be a complete partition key path from tablePath. 
<|del|> 
 * Add partitions in metastore which exist in HDFS but not to metastore. 
 hdfsTable, new Path(hdfsTable.getHdfsBaseDir()), path); // Set "ifNotExists" to be true to skip partition creation // if the target partition already exists. 
 AuthzError("ALTER TABLE functional.alltypes recover partitions", 
 if (replicationFactor != null && Short.parseShort(replicationFactor) != entry.getInfo().getReplication()) { 
 if (replicationFactor != null && Short.parseShort(replicationFactor) != entry.getInfo().getReplication()) { 
 String replicationFactor = params.get(CACHE_DIR_REPLICATION_PROP_NAME); if ( replicationFactor!= null && Short.parseShort(replicationFactor) != entry.getInfo().getReplication()) { 
 * Returns true if this file format with the given compression format is splittable. 
 * Normalize components of the given file path. For example, substitutes the unique * id portion of Impala generated file names with a fixed literal. Subclasses should * override to do filesystem specific cleansing. 
 private static final Path S3A_CANONICAL_BUCKET = new Path("s3a://bucket"); 
 List<Integer> slotPath = Lists.newArrayList();; if (path_ != null) { slotPath.addAll(path_); } else if (column_ != null) { slotPath.add(column_.getPosition()); 
 * this name exists in the catalog. 'loadFileMetadata' indicates if the table's file 
 throw new TableLoadingException("Error loading metadata for table: " + 
 hdfsTable.load(hdfsTable, msClient.getHiveClient(), msTbl, loadFileMetadata, modifiedPartitions); 
 private final VertexId id_; 
 @Override 
 public static Vertex fromJsonObj(JSONObject obj) { 
 this.label_.equals(vertex.label_); 
 private final Set<Vertex> sources_; private final Set<Vertex> targets_; private final EdgeType edgeType_; 
 private final Set<Vertex> sources_; private final Set<Vertex> targets_; private final EdgeType edgeType_; 
 public Map toJson() { 
 // Name of the user that issued this query private String user_; 
 Set<String> sourceBaseCols = Sets.newHashSet(); 
 private void getSourceBaseCols(Expr expr, Set<String> sourceBaseCols, List<Expr> predicateDependents, boolean filterExprs) { List<SlotId> slotIds = extractSlotIds(expr, filterExprs); 
 predicateDependents.addAll(analyticExpr.getPartitionExprs()); for (OrderByElement orderByElem: analyticExpr.getOrderByElements()) { predicateDependents.add(orderByElem.getExpr()); } 
<|del|> 
 if (aggInfo_ != null) { 
 private String label_; // for SlotRef.toSql() in absence of column name // Expr(s) materialized into this slot; multiple exprs for unions. Should be empty if // column_ is set. private List<Expr> sourceExprs_ = Lists.newArrayList(); 
 private String label_; // for SlotRef.toSql() in absence of column name // Expr(s) materialized into this slot; multiple exprs for unions. Should be empty if // column_ is set. private List<Expr> sourceExprs_ = Lists.newArrayList(); 
<|del|> 
 return 29; 
 // Use getString() to check the value is null (and not 0). assertEquals(null, rs.getString("NUM_PREC_RADIX")); 
 * queries) or a result expr. 
 private final Set<Vertex> sources_; private final Set<Vertex> targets_; private final EdgeType edgeType_; 
<|del|> 
 // slot should correspond to a materialized base table column 
 // If the expr is an analytic expr, record the grouping and 
 * Extract the SlotIds that constitute a direct projection dependency with 'expr' as * the target. 
 // Remember if there is an applicable ACL entry, including owner user, named user, // owning group, named group. 
<|del|> 
 // Remember if there is an applicable Acl entry, including owner user, named user, // owning group, named group. If none of those acl entries are found, then use // OTHER entry for permission check. boolean foundMatch = false; 
 if (foundMatch) { // Processed all entries except the OTHER entry. // Found applicable acl entries, but none of them contain requsted // permission, so deny access. return false; 
 } else if (e.getPermission().implies(action)) { return true; 
<|del|> 
 private List<TPartitionKeyValue> getTPartitionKeyValueList(Path tablePath, Path path) { 
 * Add partitions to metastore which exist in HDFS but not in metastore. 
 // Set "ifNotExists" to be true to skip partition creation if the target // partition already exists. 
 private final List<Expr> resultDependencyPredicates_ = Lists.newArrayList(); 
 * slots. If 'directPredDeps' is not null, it is populated with the exprs that 
 * Retrieve the exprs that 'e' is directly projection dependent on. * TODO Handle conditional exprs (e.g. CASE, IF). 
 * Retrieve the exprs that 'e' is directly projection dependent on. * TODO Handle conditional exprs (e.g. CASE, IF). 
 * Retrieve the exprs that 'e' is directly predicate dependent on. * TODO Handle conditional exprs (e.g. CASE, IF). 
 if (aggInfo_ != null && !aggInfo_.getAggregateExprs().isEmpty()) { 
 * queries) or a result expr (labeled column of a query result set). 
<|del|> 
<|del|> 
 * Private c'tor, used only for testing. 
 public void computeLineageGraph(List<Expr> resultExprs, Analyzer analyzer) { init(analyzer); 
 * Compute predicate dependencies for the query result, i.e. exprs that affect the * possible values of the result exprs / target columns, such as predicates in a WHERE * clause. 
<|del|> 
<|del|> 
 if (aggInfo_ != null && !selectList_.isDistinct()) { 
<|del|> 
 slotDesc.setLabel(getColLabels().get(i)); 
 if (operandIndx != 0) slotDesc.addSourceExpr(resultExpr); ++operandIndx; 
 // Return select BE startup options as a serialized TStartupOptions 
 throw new AnalysisException("Decimal precision must be <= " + ScalarType.MAX_PRECISION + ": " + precision); 
 public TResultSet getFiles(List<TPartitionKeyValue> partitionSpec) throws CatalogException { 
 if (operandIndx != 0) slotDesc.addSourceExpr(resultExpr); ++operandIndx; 
 if (operandIndx != 0) slotDesc.addSourceExpr(resultExpr); ++operandIndx; 
 LOG.error("Error retrieving BE startup options. Shutting down JVM"); 
 for (List<LiteralExpr> l3: allLists) { verifyTransitive(l1, l2, l3); } 
Copyright 2012 Cloudera Inc. 
<|del|> 
 // Order NullLiterals based on the SQL ORDER BY default behavior: NULLS LAST. 
 public TResultSet getFiles(List<TPartitionKeyValue> partitionSpec) throws CatalogException { 
 * Evaluate in the BE the children of this expr that are constant expressions and * substitute them with the evaluation result as LiteralExprs. Modifies this expr 
 * Evaluate in the BE the children of this expr that are constant expressions and * substitute them with the evaluation result as LiteralExprs. Modifies this expr 
 * path e.g. c4=1/c5=2/c6=3 * partitionKeys The ordered partition keys. e.g.("c4", "c5", "c6") * depth The start position in partitionKeys to match the path name. 
 private List<Partition> getHmsPartitionList(Set<List<String>> partitionsNotInHms, 
 LOG.warn(String.format("Invalid partition value (%s) for Type (%s).", 
 * * Throws an AnalysisException if the evaluation fails in the BE. * 
 // If the table is cached, get its cache pool name and replication factor. New // partitions will inherit this property. 
 Short cacheReplication = 0; Long cacheDirId = HdfsCachingUtil.getCacheDirectiveId( 
 * Casts this expr to a specific target type. It checks the validity of the cast and * calls uncheckedCastTo(). 
 // SetLookup strategy NYI for Timestamps or Decimals 
 "Illegal table reference to non-collection type: 't'"); 
 // analyze() ensures that value_ never exceeds the maximum scale and precision. Preconditions.checkState(isAnalyzed_); 
 // Append warning about tables missing stats except for child queries of // 'compute stats'. The parent_query_id is only set for compute stats child queries. 
 // Append warning about tables missing stats except for compute stats query. // Check if parent_query_id is not set because it's only set for compute stats query. 
 tableName_); 
 tableName_); 
 } catch (Exception ex) { 
 throw new CatalogException("Table " + tableName + " is not an HDFS table"); 
 hdfsTable); 
 hdfsTable); 
 * Generate list of HMS paritions from a set of specified Path. Path in * partitionsNotInHms must be a complete partition key path from tablePath. 
 * Create a new HMS Partition. 
 private Partition createHmsPartitionFromValues(List<String> partitionSpecValues, 
 public TResultSet getFiles(List<TPartitionKeyValue> partitionSpec) throws CatalogException { 
 public TResultSet getFiles(List<TPartitionKeyValue> partitionSpec) throws CatalogException { 
 public TResultSet getFiles(List<TPartitionKeyValue> partitionSpec) throws CatalogException { 
 Set<List<String>> partitionsNotInHms = hdfsTable.getPathsWithoutPartitions(); if (partitionsNotInHms.isEmpty()) return; 
 // This may happen when another client of HMS has added the partitions. LOG.debug(String.format("Ignoring '%s' when adding partition to %s.", e, tableName)); 
 // This may happen when another client of HMS has added the partitions. LOG.debug(String.format("Ignoring '%s' when adding partition to %s.", e, tableName)); 
 private List<Partition> partitionValuesToHmsPartitions( Set<List<String>> partitionsNotInHms, 
 private Partition prepareHmsPartitionFromValues(List<String> partitionSpecValues, 
<|del|> 
 parentTableRef = parentAnalyzer.getTableRef(resolvedPath_.getRootDesc().getId()); 
<|del|> 
 "with w as (select c from functional.allcomplextypes t, " + "(select count(a1.key) c from t.array_map_col a1) v1) " + 
 new TStatus(TErrorCode.OK, new ArrayList<String>())); 
 // (and not during TableRef analysis) to prefer reporting a duplicate alias for // consistency with 'standard' SQL. We cannot detect duplicate aliases before path // resolution because we only know the aliases for a concrete (resolved) table ref. 
 "Path resolved to type: %s", ref.getResolvedPath().toString(), 
 throws AnalysisException, TableLoadingException { // We only allow correlated references in predicates of a subquery. 
 // Illegal cases: // 1. Path contains an intermediate collection reference. // 2. Destination of the path is a catalog table or a registered alias. if (p.hasNonDestCollection() || p.getMatchedTypes().isEmpty()) return false; 
 public static final String ARRAY_IMPLICIT_FIELD_NAME = "__item"; public static final String MAP_IMPLICIT_KEY_FIELD_NAME = "__key"; public static final String MAP_IMPLICIT_VALUE_FIELD_NAME = "__value"; 
 public static final String ARRAY_IMPLICIT_FIELD_NAME = "__item"; public static final String MAP_IMPLICIT_KEY_FIELD_NAME = "__key"; public static final String MAP_IMPLICIT_VALUE_FIELD_NAME = "__value"; 
 public static StructType getTypeAsStruct(Type t) { 
 public List<Type> getMatchedTypes() { Preconditions.checkState(isResolved_); return matchedTypes_; 
 if (partition.isDefaultPartition()) continue; 
 * Returns all partitions which match the partition keys directory structure and pass * type compatibility check. Also these partitions are not already part of the table. 
 * Generate list of HMS paritions from a set of lists of partition column values. * The list of column values must be valid and have the same order with partition * columns defined in the HDFS table. 
 "ALTER TABLE RECOVER PARTITIONS must target an HDFS table: " + "functional_hbase.alltypes"); 
 * TRUNCATE [TABLE] tbl1 [, tbl2, tbl3...] 
 // Set in analyze(). 
 // We only support truncating hdfs tables now. if (!(table instanceof HdfsTable)) { throw new AnalysisException(String.format( "TRUNCATE TABLE not allowed on non hdfs table: %s", table.getFullName())); 
 return "TRUNCATE TABLE " + Joiner.on(", ").join(tableNames_); 
 * Computes the column lineage graph for a create/alter view statetement. 
 if (subqueryStmt.getAnalyzer().hasEmptyResultSet()) { boolLiteral = new BoolLiteral(predicate.isNotExists()); 
 if (subqueryStmt.getAnalyzer().hasEmptyResultSet()) { boolLiteral = new BoolLiteral(predicate.isNotExists()); 
 && !subqueryStmt.hasAnalyticInfo() && subqueryStmt.getHavingPred() == null) { boolLiteral = new BoolLiteral(!predicate.isNotExists()); 
 && !subqueryStmt.hasAnalyticInfo() && subqueryStmt.getHavingPred() == null) { boolLiteral = new BoolLiteral(!predicate.isNotExists()); 
 // Remove any DISTINCT clause as it does not affect the result of EXISTS // subqueries. 
 subqueryStmt.hasAggInfo() && !subqueryStmt.getSelectList().isDistinct()); 
 if (!analyticInfo.getCommonPartitionExprs().contains(e)) return false; 
 // into the view, unless the predicates are compatible with the analytic // function's partition by clause, because those extra filters 
 return analyticInfo.getCommonPartitionExprs().contains(e); 
 if (!canMigrateConjuncts(inlineViewRef)) { 
 * A raw path is ambiguous if it has multiple legal resolutions. Otherwise, 
 private Path getLegalPath(List<String> rawPath, ArrayList<Path> resolutions, 
 result.getMatchedTypes().size() == p.getMatchedTypes().size()) { 
 // Expr that returns the referenced collection. Typically a SlotRef into the // parent scan's tuple. Result of analysis. Fully resolved against base tables. 
 Table table = tupleDesc.getTable(); if (table != null && !(table instanceof View)) referencedTbls.add(table); 
 // Set/validated during analysis. 
 // The fnNamePath_ is not always set. if (!isAnalyzed_ && fnNamePath_ != null) return Joiner.on(".").join(fnNamePath_); 
 Table table = slotDesc.getParent().getTable(); 
 // Raw path that is to be resolved relative to rootDesc_ or rootTable_. 
 private final List<Type> matchedTypes_ = Lists.newArrayList(); 
 * Returns true if the path could be fully resolved, false otherwise. * A failed resolution leaves this Path in a partially resolved state. 
 } isResolved_ = true; 
 // for "[path.]*" (excludes trailing '*') private final List<String> rawPath_; 
 // Path of slot relative to parent_. Only set for slots that represent a column/field. 
 * table references are subclasses of TableRef. * TODO: Rename this class to CollectionRef and re-consider the naming of all subclasses. 
 // Path to a collection type. Not set for inline views. 
 // Resolution of rawPath_ if applicable. Result of analysis. 
 * Returns the size in bytes of the fixed-length portion that a slot of this type * occupies in a tuple. 
 fqAlias, col, tbl), tblName, 
 HdfsTable dummyTable = new HdfsTable(null, null, db, createTableStmt.getTbl(), createTableStmt.getOwner()); List<ColumnDef> columnDefs = createTableStmt.getColumnDefs(); 
 * IF(TupleIsNull(tids), NULL, expr) * * The given tids are expected to be materialized tuples. The inputExprs * may or may not be bound by them. * 
 public static List<Expr> wrapExprs(List<Expr> inputExprs, 
 * SlotRefs evaluate to NULL, false otherwise. * Throws an InternalException if expr evaluation in the BE failed. 
 throws InternalException { Preconditions.checkNotNull(expr); 
 expr.collect(SlotRef.class, slotRefs); 
 * The given tids must be materialized. The given inputExprs are expected to be bound * by tids once fully substituted against base tables. However, inputExprs may not yet * be fully substituted at this point. 
 if (contains(ExistsPredicate.class)) { throw new AnalysisException("EXISTS subquery predicates are not " + 
 if (expr.contains(TupleIsNullPredicate.class)) return true; 
 // Regression test for fully qualified builtin function name (IMPALA-1951) 
 throw new AnalysisException("Overflow check on " + type + " isn't supported."); 
 * Returns the HDFS paths corresponding to HdfsTable partitions that don't exist in * the metastore. An HDFS path is represented as a list of strings values, one per * partition key column. 
 throw new CatalogException(String.format("Failed to recover partitions for %s " + "with exception:%s.", getFullName(), e)); 
 * parittions. E.g. Having /c1=0001 and /c1=01, we should make sure only one partition * will be added. 
 LOG.trace(String.format("Skip recovery of path '%s' because it already exists " + 
 * original value, the second element is the literal value. 
 for (List<String> partitionSpecValues: partitionsNotInHms) { hmsPartitions.add(createHmsPartitionFromValues( partitionSpecValues, msTbl, tableName, null)); 
 } else if (fnName_.getFunction().equalsIgnoreCase("truncate") || 
 tables_ = Lists.newArrayListWithCapacity(tableNames_.size()); 
 "TRUNCATE TABLE not supported on non-HDFS table: %s", table.getFullName())); 
 List<TTableName> list = Lists.newArrayListWithCapacity(tables_.size()); 
 existingPartitions.add(partition.getPartitionValues()); 
<|del|> 
<|del|> 
 * Returns all partitions which match the partition keys directory structure and pass * the type compatibility check. 
 * partitionValues The partition values used to create a partition. * partitionExprs The list of LiteralExprs which is used to avoid duplicate partitions. 
 * partitionValues The partition values used to create a partition. * partitionExprs The list of LiteralExprs which is used to avoid duplicate partitions. 
 * partitionValues The partition values used to create a partition. * partitionExprs The list of LiteralExprs which is used to avoid duplicate partitions. 
 * partitionsNotInHms Contains all the recovered partitions. 
<|del|> 
 * original value, the second element is the LiteralExpr created from the original * value. 
<|del|> 
<|del|> 
 HdfsCachingUtil.uncachePartition(partition); 
 // Remembers the indices into rawPath_ and matchedTypes_ of the first collection 
 // Directly use the item type to only allow implicit path resolutions, 
 * If the given type is a collection, returns a struct type representing named fields * of its explicit path. Returns the given type itself if it is already a struct. * Requires that the given type is a complex type. 
 private CollectionStructType(ArrayList<StructField> fields, boolean isMapStruct) { 
 for (String s: rawPath) lcRawPath.add(s.toLowerCase()); 
 * c alias <-- type struct<item:struct<f:int,item:int,pos:int>,pos:bigint>> 
 // Directly start from the item type because only implicit paths are allowed. 
<|del|> 
 // array<int> --> item 
 * TRUNCATE [TABLE] [database.]table 
 tableName_ = analyzer.getFqTableName(tableName_); 
 // Subqueries need to be rewritten by the StmtRewriter first. 
 if (analyzer.containsSubquery()) { StmtRewriter.rewriteQueryStatement(queryStmt_, queryStmtAnalyzer); queryStmt_ = queryStmt_.clone(); queryStmtAnalyzer = new Analyzer(analyzer); queryStmt_.analyze(queryStmtAnalyzer); } 
 for (OrderByElement o: orderByElements_) result.add(o.clone()); 
 for (OrderByElement o: orderByElements_) o.getExpr().reset(); 
 UnionStmt unionClone = new UnionStmt(operandClones, cloneOrderByElements(), limitElement_ == null ? null : limitElement_.clone()); unionClone.setWithClause(cloneWithClause()); unionClone.hasAnalyticExprs_ = hasAnalyticExprs_; return unionClone; 
 if (other.requiresIntermediateTuple()) { 
<|del|> 
 public String toSql() { return ""; } 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // Map from UnionStmt's result slots to our resultExprs. Used during plan generation. private final ExprSubstitutionMap smap_; 
 tableName_ = analyzer.getFqTableName(tableName_); 
 private Pair<String, LiteralExpr> getTypeCompatibleValue(Path path, String partitionKey) { 
 result.setType(Path.getTypeAsStruct(resolvedPath_.destType())); 
 rootTable_ = rootDesc.getTable(); 
 * block as well as a table ref with an absolute path (e.g. a BaseTabeRef). Such a * statement would generate a Subplan containing a base table scan (very expensive), * and should therefore be avoided. 
 * (2) only correlated table refs * (3) a mix of correlated table refs and uncorrelated child table refs 
 * Returns all physical (non-inline-view) TableRefs of this statement and the nested * statements of inline views. The returned TableRefs are in depth-first order. 
class LimitElement { ///////////////////////////////////////// // BEGIN: Members that need to be reset() 
<|del|> 
<|del|> 
<|del|> 
Copyright 2015 Cloudera Inc. 
 protected final JoinOperator joinOp_; // User-provided hint for the distribution mode. Set to 'NONE' if no hints were given. protected final DistributionMode distrModeHint_; 
 // Join conjuncts from the ON clause that aren't equi-join predicates. 
 // Init string prefix used to indicate if the class should be cached. When this // is specified, the Class is loaded and initialized exactly once. Instances of // the cached Class are still created for every query. 
<|del|> 
 // is specified, the Class is loaded and initialized at most once. Instances of 
<|del|> 
<|del|> 
 * Returns true if this table ref has a resolved path that is rooted at a registered * tuple descriptor, false otherwise. 
 // First absolute table ref. TableRef absoluteRef = null; 
// This class contains information about how unnested datasets are related. 
 // Used to validate unions. This is a substitution map for comparison purposes. 
 static boolean isComplexType(Type type) { 
 /** * Registers this table ref with the given analyzer and add a slot descriptor for * the materialized collection to be populated by parent scan. Also determines * whether this table ref is correlated or not. */ 
 // and the table ref does not conflict with absolute refs. 
 // Resolution of rawPath_ if applicable. Set in TableRef.analyze(). 
 throw new AnalysisException( joinOp_.toString() + " requires an ON or USING clause."); 
<|del|> 
 * they should be unique in the descriptor table. * TODO for 2.3: Consider also cloning table and slot descriptors for clarity, * or otherwise make changes to more provide clearly defined clone() semantics. 
 private final Set<String> hostnames_; 
 private final Set<String> ipAddresses_; 
<|del|> 
 private static final String[] PARQUET_INPUT_FORMATS = { 
 // Input format class for Avro tables read by hive. private static final String AVRO_INPUT_FORMAT = "org.apache.hadoop.hive.ql.io.avro.AvroContainerInputFormat"; 
<|del|> 
<|del|> 
 public NestedRowSrcTableRef(PlanNode subplanInput) { 
 * Subplan. A NestedRowSrcNode can only appear in the plan tree of a SubplanNode. 
 * A SubplanNode evaluates its second child plan tree for every row from its first child, * and returns those rows produced by the second child. The second child is called * 'the subplan' and the first child the 'input'. 
<|del|>
<|del|> 
 // Assume the collection expr has been fully resolved in analysis. 
 cardinality_ = -1; 
 private boolean isBroadcastJoin_; private boolean isPartitionedJoin_; 
<|del|> 
 // Set the proper join operator based on whether predicates are assigned or not. if (conjuncts_.isEmpty() && otherJoinConjuncts_.isEmpty() && !joinOp_.isSemiJoin()) { 
 // Tuple not materialized by scan, so no associated table descriptor. 
 String[] tables = new String[] { "allcomplextypes", "allcomplextypes_view" }; 
<|del|> 
<|del|> 
 private PlanFragment createNLJoinFragment(NLJoinNode node, 
 * should be non-null. If the join node contains at least one equi-join predicate, the * it is evaluated using the hash join algorithm. Otherwise, the nested-loop * join algorithm is used. 
 * Registers this table ref with the given analyzer and adds a slot descriptor for 
 * - from bottom to top, all rhs's are in increasing order of selectivity (percentage * of surviving rows) 
 private static class SubplanRef { 
 for (TableRef ref: tblRefs) { 
<|del|>
 "(select f1 from t.struct_array_col a where t.int_struct_col.f1 %s a.f1)", 
 Preconditions.checkState(!(parentRef instanceof InlineViewRef)); 
<|del|> 
 cardinality_ = PlannerContext.AVG_COLLECTION_SIZE; 
 * FROM FactTbl F JOIN Customers C ON (F.cust_id = C.id) ... WHERE C.region = 'US' 
 // For the month interval, use the invisible special-case implementation. // "ADD_MONTHS(t, m)" by definition is different from "t + INTERVAL m MONTHS". 
 String funcOpName = String.format("%sS_%s", timeUnit_, 
<|del|> 
 analyzer.registerConjuncts(havingPred_, true); 
 return unassignedConjuncts; 
<|del|> 
 throw new AnalysisException("'" + op_.toString() + "'" + 
 // from the ON and USING clauses. 
 // Non-equi join conjuncts. 
 otherJoinConjuncts, "NESTED LOOP JOIN"); 
 List<BinaryPredicate> newEqJoinConjuncts = Lists.newArrayList(); ExprSubstitutionMap combinedChildSmap = getCombinedChildSmap(); 
 // from the ON and USING clauses. 
 // Non-equi join conjuncts. 
 public void testSingleNodeNlJoin() { 
 numClusteringCols_ = msTbl.getPartitionKeys().size(); 
 schema = IOUtils.toString(urlStream); 
public class AvroSchemaConverter { // Arbitrarily chosen schema name and record prefix. Note that // record names must be unique within an Avro schema. 
 decimalSchema.addProp(SCALE_PROP_NAME, String.valueOf(impalaDecimalType.decimalScale())); 
 if (outerGroup == null) { throw new AnalysisException("Failed to convert\n" + outerGroup.toString() + "\nThe logical MAP type must have"); } 
 * * If innerField is a group, but originalType is not null, the element type is * based on the logical type. 
 * A Parquet type is considered logical when it has an annotation. The annotation is * stored as a "OriginalType". The parquet documentation refers to these as logical * types, so we use that terminology here. 
 "inferred from: " + field.toString())); 
<|del|> 
 throw new AnalysisException(String.format(errPrefix, outerGroup.toString(), "MAP", "The logical MAP type must have exactly 1 inner field.")); 
 * stored as a "OriginalType". The Parquet documentation refers to these as logical 
 private final static String ERROR_MSG = "Failed to convert Parquet type\n%s\nto an Impala %s type:\n%s\n"; 
 private final static String ERROR_MSG = "Failed to convert Parquet type\n%s\nto an Impala %s type:\n%s\n"; 
 // be annotated with MAP_KEY_VALUE). We treat the case that innerGroup has an // annotation and the case the innerGroup does not have an annotation the same. 
 private static boolean isAnalyticFn(Function fn) { 
 return isAnalyticFn(fn, PERCENT_RANK); 
 // TODO: IMPALA-2171:Remove this when ntile() can handle a non-constant argument. 
 throw new AnalysisException(e.toString()); 
 // The following 3 functions are never directly executed because they get rewritten 
 db, "percent_rank", Lists.<Type>newArrayList(), Type.DOUBLE, Type.STRING)); 
 db, "cume_dist", Lists.<Type>newArrayList(), Type.DOUBLE, Type.STRING)); 
 * Registers this collection table ref with the given analyzer and adds a slot * descriptor for the materialized collection to be populated by parent scan. * Also determines whether this collection table ref is correlated or not. 
 * A SingularRowSrcNode returns the current row that is being processed by its 
 Preconditions.checkState(children_.size() == 2); // Check that there are no unassigned conjuncts that can be evaluated by this node. // All such conjuncts should have already been assigned in the right child. 
 queryStmt_.analyze(inlineViewAnalyzer_); correlatedTupleIds_.addAll(queryStmt_.getCorrelatedTupleIds(inlineViewAnalyzer_)); 
 * Indicates if this TableRef directly or indirectly references another TableRef from * an outer query block. 
 PlanFragment childFragment) { 
 // Adjust cardinality for all collections referenced along the tuple's path. 
 * Creates and adds subplan nodes as soon as the tuple ids required by at least one * subplan ref are materialized by a join node added during plan generation. 
 * Uncorrelated and non-relative table refs. These are the 'regular' table refs whose 
 * Correlated and relative table refs. The plan of such refs must be put inside a * Subplan. See SubplanRef for details. 
 * If this function is called when generating the right-hand side of a SubplanNode, * then correlated and relative table refs that require only tuples produced by the * SubplanNode's input are placed inside parentRefs. 
 // Construct an incomplete SubplanNode that only knows its input so we can push it // into the planner context. The subplan is set after the subplan tree has been // constructed. 
 * Returns a new list with all table refs from subplanRefs that can be correctly * evaluated inside a SubplanNode placed after the given plan root, as well as a * new SingularRowSrcTableRef as the first element in the list. 
 // List of table ref ids in 'root' as well as the table ref ids of all table refs // placed in 'subplanRefs' so far. 
 // List of table ref ids in 'root' as well as the table ref ids of all table refs // placed in 'subplanRefs' so far. 
 otherJoinConjuncts_ = Expr.substituteList(otherJoinConjuncts_, getCombinedChildSmap(), analyzer, false); 
<|del|> 
 parentDesc_ = null; 
 parentDesc_ = null; 
 boolean isStraightJoin, List<TableRef> parentRefs, List<SubplanRef> subplanRefs) { 
 // Default join selectivity when we cannot come up with a better estimate. 
 if (eqJoinConjuncts_.isEmpty()) { Preconditions.checkState(!otherJoinConjuncts_.isEmpty() || !conjuncts_.isEmpty()); 
 result = createNestedLoopJoinFragment( 
 // Default join selectivity when we cannot come up with a better estimate. 
 // Always prefer Hash Join over Nested-Loop Join due to limited costing 
Copyright (c) 2012 Cloudera, Inc. All rights reserved. 
 * Converts a "primitive" Parquet type to an Impala type. * A primitive type is a non-nested type with no annotations. 
 // From the Parquet Spec: // 2. If the repeated field is a group with multiple fields, then it's type is a // struct. 
Copyright (c) 2015 Cloudera, Inc. All rights reserved. 
 // 8-byte pointer and 4-byte length indicator (12 bytes total). // Per struct alignment rules, there is an extra 4 bytes of padding to align to 8 // bytes so 16 bytes total. 
import com.cloudera.impala.analysis.PrivilegeSpec; 
 expr0Children.add(distinctAggExprs.get(0).getChild(0).ignoreImplicitCast()); } else { for (Expr expr: distinctAggExprs.get(0).getChildren()) { expr0Children.add(expr.ignoreImplicitCast()); } 
 * Create the info for an aggregation node that computes the second phase of 
 int idx = origGroupingExprs.size(); Expr aggExprParam = new SlotRef(inputDesc.getSlots().get(idx)); 
 private final LinkedList<SubplanNode> subplans_ = Lists.newLinkedList(); 
 // Tuple ids of root descriptors from outer query blocks that this table ref 
 private final Deque<SubplanNode> subplans_ = new ArrayDeque<SubplanNode>(); 
<|del|> 
 precedingRefs.put(tblRef, Sets.newHashSet(tmpTblRefs)); 
<|del|>
 * Attempt to get database info from metastore. Return null if error encountered. 
<|del|> 
<|del|> 
<|del|> 
 } catch (SchemaParseException e) { 
<|del|> 
 Preconditions.checkNotNull(errorString, "Stack trace lost during exception."); 
 // Analyze avro schemas, which is indicated by the avro.schema.url or avro.schema.literal // table properties being set. 
 // Analyze avro schemas, which is indicated by the avro.schema.url or avro.schema.literal // table properties being set. 
 * valid JSON string. Check if avro.schema.literal is a valid JSON string. Check if * it is supported. 
 * valid JSON string. Check if avro.schema.literal is a valid JSON string. Check if * it is supported. 
<|del|>
<|del|> 
 private final LinkedList<SubplanNode> subplans_ = Lists.newLinkedList(); 
 LOG.trace( "candidate " + ref.getUniqueAlias() + ": " + Long.toString(materializedSize)); 
<|del|> 
 // Separate table refs into parent refs (uncorrelated or absolute) and // subplan refs (correlated or relative), and generate their plan. 
 * evaluated inside a SubplanNode placed after the given plan root. * The returned table refs have their left-table links properly set, and the * corresponding SubplanRefs are removed from subplanRefs. 
 mergeAggInfo_.separatorExpr_ = separatorExpr_; 
 exprList.add(new SlotRef(inputDesc.getSlots().get(origGroupingExprs.size()))); 
 if (separatorExpr_ != null && distinctAggExprs.get(0).getFnName().getFunction(). equalsIgnoreCase("group_concat")) { numDistinctParams--; } 
 inputAggInfo.getAggregateExprs().size() + (separatorExpr_ != null ? 1 : 0)); 
 // Used in group_concat function with the distinct clause, represents the optional // separator. 
 } else { 
<|del|> 
<|del|> 
 * - The right-hand side of each SubplanNode is a plan tree generated by joining a 
 * 
 // Prepend a SingularRowSrcTableRef representing the current row being processed 
 private List<TableRef> extractApplicableRefs(PlanNode root, 
 * TODO: Now that we have a nested-loop join supporting all join modes we could 
 ExistsPredicate existsPred = (ExistsPredicate) expr; // Note that the concept of a 'correlated inline view' is similar but not the same // as a 'correlated subquery', i.e., a subquery with a correlated predicate. 
 public static List<ColumnDef> createFromFieldSchemas(List<FieldSchema> fieldSchemas) 
 columnDefs_ = analyzeAvroSchema(analyzer); if (columnDefs_.isEmpty()) { 
 // Look for the schema in TBLPROPERTIES and in SERDEPROPERTIES, with latter 
<|del|> 
<|del|> 
 String schema = null; // TODO: Add support for https:// here. 
<|del|> 
 * can represent multiple privileges only at the COLUMN scope. 
 String dbName, TableName tableName, HdfsUri uri, List<String> columnNames) { 
 * Analyzes a privilege spec at the COLUMN scope. 
 if (table.getColumn(columnName) == null) { // The error message should not reveal the existence or absence of a column. 
 Preconditions.checkState(!Strings.isNullOrEmpty(tableName_.getTbl())); 
<|del|> 
 * updating the Sentry Service or if the Impala catalog does not contain the given role 
 sentryPolicyService_.grantRolePrivileges(user, roleName, updatedPrivileges); // Update the catalog for (TPrivilege updatedPriv: updatedPrivileges) { rolePrivileges.add(catalog_.addRolePrivilege(roleName, updatedPriv)); } 
 "%s myrole", formatArgs)); AnalyzesOk(String.format("%s SELECT (id, id) ON TABLE functional.alltypes " + "%s myrole", formatArgs)); 
 } catch (AnalysisException e) { if (analyzer.hasMissingTbls()) throw e; 
<|del|> 
<|del|> 
 // Check avro schema when it is set in avro.schema.url or avro.schema.literal. // This avoids potential metadata corrution (see IMPALA-2048). 
 * Check that avro schema provided in avro.schema.url or avro.schema.literal is valid Json and contains only * supported Impala types. If both properties are set, then schema in 'avro.schema.url' is ignored. 
<|del|> 
 // Url is invalid but ignored because literal is provided. 
 Preconditions.checkNotNull(errorString, "Stack trace lost during exception."); 
 case GT: return LT; case DISTINCT_FROM: return DISTINCT_FROM; case NOT_DISTINCT: return NOT_DISTINCT; 
 "IS DISTINCT FROM", "IS NOT DISTINCT FROM"}; 
 // Check if a custom separator is used in the group_concat function. 
 if (separatorExpr_ != null) { exprList.add(separatorExpr_); 
 slotDesc.initializeFromExpr(expr); 
 } else { 
<|del|> 
 // This avoids potential metadata corruption (see IMPALA-2042). 
 // This avoids potential metadata corruption (see IMPALA-2042). 
<|del|> 
<|del|> 
 public void TestAlterTableSetTblPropertiesAVRO() { 
<|del|> 
 sb.append("\n ("); sb.append(PrintUtils.joinWrapLines(view.getColumnNames(), ", ", ",", 4, 40)); sb.append(") AS\n"); 
<|del|> 
<|del|> 
 * Check that Avro schema provided in avro.schema.url or avro.schema.literal is valid Json and * contains only supported Impala types. If both properties are set, then avro.schema.url is ignored. 
 * Check that Avro schema provided in avro.schema.url or avro.schema.literal is valid Json and * contains only supported Impala types. If both properties are set, then avro.schema.url is ignored. 
<|del|> 
 private final ArrayList<ColumnDef> columnDefs_; 
import org.apache.avro.SchemaParseException; import org.apache.hadoop.hive.serde2.avro.AvroSerdeUtils; import com.cloudera.impala.common.AnalysisException; 
 // avoid potential metadata corruption (see IMPALA-2042). 
 "Could not resolve table reference: 'functional.badtable'"); 
 * Check that Avro schema provided in avro.schema.url or avro.schema.literal is valid * Json and contains only supported Impala types. If both properties are set, then * avro.schema.url is ignored. 
 schemaLocation.get( AvroSerdeUtils.AvroTableProperties.SCHEMA_LITERAL.getPropName()); 
 /** * Returns the destination tuple descriptor of this path, or null * if the destination of this path is not a registered alias. */ 
 String[] tables = new String[] { "allcomplextypes" }; 
 String[] tables = new String[] { "allcomplextypes" }; 
 for (Expr expr: distinctAggExprs.get(i).getChildren()) { 
 if (separatorExpr_ != null) exprList.add(separatorExpr_); 
 // Check if one of the children is actually the optional separator in group_concat 
<|del|> 
 } else { 
<|del|> 
 // SELECT permissions on columns ('id', 'int_struct_col', 'struct_array_col', // 'int_map_col') on 'functional.allcomplextypes' (no SELECT permissions on 
<|del|> 
 // Custom separators used in group_concat aggregate functions with distinct. 
<|del|> 
 // If custom separators for group_concat were provided, add them to the check // since they will hold their own SlotDescriptor 
 new SlotRef(outputTupleDesc_.getSlots().get(i)), new SlotRef(intermediateTupleDesc_.getSlots().get(i))); 
 // materialize custom separator expressions, if any 
<|del|> 
 "GROUP_CONCAT(DISTINCT) must have a string literal as the custom separator"); AnalyzesOk("select group_concat(distinct string_col, concat('-', '?')) from functional.alltypesagg"); 
<|del|> 
 tableName_ = analyzer.getFqTableName(tableName_); 
<|del|> 
 tableName_ = analyzer.getFqTableName(tableName_); 
 // The table-level SELECT must be the first table-level request, and it // must precede all column-level privilege requests. 
 boolean hasColumnSelectPriv = false; 
 hasColumnSelectPriv = true; 
 if (!hasTableSelectPriv && !hasColumnSelectPriv) { 
<|del|> 
 public static synchronized Connection getConnection(Configuration conf) 
 boolean isCompressed, ClusterStatus clusterStatus) throws IOException { 
 org.apache.hadoop.hbase.client.Table table; 
<|del|> 
 LOG.error("Error closing HBase table: " + hbaseTableName_, e); 
<|del|> 
 // Syntax: GROUP_CONCAT([DISTINCT] expression [, separator]) 
 if (fnName_.getFunction().equalsIgnoreCase("group_concat") && getChildren().size() == 2 && !getChild(1).isConstant()) { 
<|del|> 
 AnalyzesOk("select group_concat(distinct name, cast(123 as string)) " + "from functional.testtbl"); AnalysisError("select group_concat(distinct name, cast(id as string)) " + "from functional.testtbl", 
 // Add "expression" parameter. Need to get it from the inputDesc's slots so the 
 // Syntax: GROUP_CONCAT([DISTINCT] expression [, separator]) 
<|del|> 
 // The second argument in group_concat(distinct) must be a constant expr that // returns a string. 
 /** * Initializes a slot by setting its source expression information */ public void initFromExpr(Expr expr) { Preconditions.checkState(sourceExprs_.isEmpty()); 
 /** * Sets this node as a preaggregation. Only valid to call this if it is not marked * as a preaggregation */ 
 "Illegal column/field reference 'complex_nested_struct_col.f2.f11' with " + "intermediate collection 'f2' of type " + 
 "Illegal column/field reference 'complex_nested_struct_col.f2.f11' with " + "intermediate collection 'f2' of type " + 
 thriftDb_.setMetastore_db(msDb); 
 * Returns the metastore.api.Database object this Database was created from. 
 org.apache.hadoop.hive.metastore.api.Database msDb = db.getMetaStoreDb(); 
 descResult.results = Lists.newArrayList(); String location = null; String comment = null; if(msDb != null) { location = msDb.getLocationUri(); comment = msDb.getDescription(); } 
 dbTypeCol.setString_val(Objects.toString(location, "")); 
 dbTypeCol.setString_val(Objects.toString(location, "")); 
<|del|>
 private final TDescribeOutputStyle outputStyle_; 
 * Builds results for a DESCRIBE DATABASE <db> command. This consists of the database * location and comment. 
 TColumnValue dbLocationCol = new TColumnValue(); dbLocationCol.setString_val(Objects.toString(location, "")); 
Copyright 2015 Cloudera Inc. 
 * Represents of a DESCRIBE DATABASE statement which returns metadata on 
 public DescribeDbStmt(String dbName, TDescribeOutputStyle outputStyle) { Preconditions.checkState(!Strings.isNullOrEmpty(dbName), "Invalid database name"); dbName_ = dbName; outputStyle_ = outputStyle; 
 public DescribeDbStmt(String dbName, TDescribeOutputStyle outputStyle) { Preconditions.checkState(!Strings.isNullOrEmpty(dbName), "Invalid database name"); dbName_ = dbName; outputStyle_ = outputStyle; 
 params.setDb(dbName_); 
 // must be valid since tableExistsInMetaStore is true. Preconditions.checkNotNull(msDb); 
 * Returns null if it is not related to a hive database such as builtins_db. 
 TColumnValue dbLocationCol = new TColumnValue(); dbLocationCol.setString_val(Objects.toString(location, "")); 
<|del|>
 // Currently we only retrieve privileges stored in hive metastore. // TODO: Retrieve privileges from Catalog 
 // TODO: Deal with constant exprs more generally, instead of special-casing // group_concat(). 
 // TODO: Deal with constant exprs more generally, instead of special-casing // group_concat(). 
 if (inputExpr.getChildren().size() == 2) exprList.add(inputExpr.getChild(1)); 
 && numDistinctParams == 2) { --numDistinctParams; 
 && numDistinctParams == 2) { --numDistinctParams; 
<|del|> 
<|del|> 
<|del|> 
 DISTINCT_FROM("IS DISTINCT FROM", "distinctfrom", TComparisonOp.DISTINCT_FROM), NOT_DISTINCT("IS NOT DISTINCT FROM", "notdistinct", TComparisonOp.NOT_DISTINCT), 
 tableName_ = analyzer.getFqTableName(tableName_); 
<|del|> 
 /// Struct type with the fields to display for the described path. private StructType resultStruct_; 
 resultStruct_ = path_.getRootTable().getHiveColumnsAsStruct(); 
 * Represents a DESCRIBE DATABASE statement which returns metadata on 
 private final String dbName_; 
<|del|> 
 // TODO: Get cardinality from nested types stats. cardinality_ = DEFAULT_CARDINALITY; 
 private final InsertStmt insertStmt_; // Drop table statment for cleanup after CTAS query failure. private final DropTableOrViewStmt cleanupStmt_; // END: Members that need to be reset() ///////////////////////////////////////// 
 if (fs.isDirectory(sourcePath)) { filesLoaded = FileSystemUtil.relocateAllVisibleFiles(sourcePath, tmpDestPath); 
 if (fs.isDirectory(sourcePath)) { filesLoaded = FileSystemUtil.relocateAllVisibleFiles(sourcePath, tmpDestPath); 
<|del|> 
 public String getLineageGraph() { return analyzer_.getSerializedLineageGraph(); } 
 private Map<String, Vertex> vertices_ = Maps.newHashMap(); 
 ColumnLineageGraph graph = new ColumnLineageGraph(stmt, null); 
 Edge.EdgeType type = Edge.EdgeType.valueOf((String) jsonEdge.get("edgeType")); return new Edge(sourceVertices, targetVertices, type); 
 obj = parser.parse(serializedGraph); 
 TestUtils.prettyPrintJson(ColumnLineageGraph.thriftToJSON(lineageGraph)) + "\n"); 
 * e.g. (10,3) is a supertype of (3,3) but (5,4) is not a supertype of (3,0). 
 if (t1 == PrimitiveType.INVALID_TYPE || t2 == PrimitiveType.INVALID_TYPE) continue; 
 .add("path", pathStr) 
 // Drop table statement for cleanup after CTAS query failure. 
 // Setting this value causes dropped tables to be completely // deleted without going through HDFS' trash mechanism 
 public DropTableOrViewStmt(TableName tableName, boolean ifExists, boolean dropTable, boolean purgeTable) { 
 // Setting this value causes dropped partition(s) to be completely 
 // deleted without going through HDFS' trash mechanism // TODO: Revisit this once we have S3 support 
 params.setIf_exists(ifExists_); params.setPurge(purgeTable_); 
 params.setIf_exists(ifExists_); params.setPurge(purgeTable_); 
 ParserError("DROP VIW Foo"); ParserError("DROP VIEW Foo purge"); 
 // deleted. For example, for HDFS tables it skips the trash mechanism 
 Preconditions.checkNotNull(table); // PURGE option with a DROP VIEW is not allowed Preconditions.checkState(!(table instanceof View && purgeTable_)); 
 // Setting this value causes dropped partition(s) to be permanently // deleted. For example, for HDFS tables it skips trash mechanism 
 // Setting this value causes dropped tables to be permanently // deleted. For example, for hdfs tables it skips the trash directory 
 // Setting this value causes dropped tables to be permanently // deleted. For example, for hdfs tables it skips the trash directory 
 // Setting this value causes dropped tables to be permanently // deleted. For example, for hdfs tables it skips the trash directory 
 purgePartition_ = purgePartition; 
 if (purgePartition_) sb.append(" PURGE"); 
 tableName_ = tableName; ifExists_ = ifExists; dropTable_ = dropTable; purgeTable_ = purgeTable; // PURGE with a view is not allowed. Preconditions.checkState(!(!dropTable_ && purgeTable_)); 
<|del|> 
<|del|> 
 boolean missingStats = scan.isTableMissingStats() || scan.hasCorruptTableStats(); // In the absence of collection stats, treat scans on collections as if they // have no limit. 
 boolean missingStats = scan.isTableMissingStats() || scan.hasCorruptTableStats(); if (scan.isAccessingCollectionType() || (missingStats && !scan.hasLimit())) { 
 if (outputStyle_ == TDescribeOutputStyle.FORMATTED || outputStyle_ == TDescribeOutputStyle.EXTENDED) { throw new AnalysisException("DESCRIBE FORMATTED|EXTENDED must refer to a table"); 
 analyzer.registerConjuncts(havingPred_, true); 
 private Privilege getPrivilegeRequirement() { 
<|del|> 
 for (Map.Entry<String, List<PrivilegeGrantInfo>> privilegeEntry: 
 for (Map.Entry<String, String> param: params.entrySet()) { 
 private final FunctionName functionName_; private final TFunctionCategory category_; 
 StringBuilder sb = new StringBuilder("DROP " + ((dropTable_) ? "TABLE " : "VIEW ")); 
<|del|> 
 // flushTablet() can return null when a tablet we wanted to flush was already flushed. Those // nulls along with BatchResponses are then put in a list by Deferred.group(). We first need // to filter the nulls out. 
 // Configure the session to background flush as often as it can (every 1ms). 
 throw new IllegalArgumentException("Unknown column index " + columnIndex); 
 * @throws IllegalArgumentException if the column doesn't exist, if the value doesn't match * the column's type, or if it was already set 
<|del|> 
 this.varLengthData = Arrays.asList(new byte[this.schema.getColumnCount()][]); 
 private void checkNotFrozen() { 
import java.util.Arrays; import java.util.BitSet; import java.util.List; 
 private void startCluster(int numMasters, int numTservers) throws Exception { 
 public void killMasterOnPort(int port) throws InterruptedException { Process master = master_processes.remove(port); 
 msg.hdfs_scan_node.setTable_id(desc_.getTable().getId().asInt()); 
 (location_ != null) ? location_.toString() : hdfsTable.getLocation(), table.getFullName())); 
 nameSb.append("Table ").append(table.getFullName()); 
 private final Map<Integer, Process> masterProcesses = new ConcurrentHashMap<>(); 
 /** * Get the cluster status, making sure we close the admin client afterwards. */ 
 if (currentRowCount == 0) return new Pair<Long, Long>(0L, 0L); 
 for (final HRegionLocation location : locations) { 
 * for this region from the ClusterStatus. Returns 0 in case of an error. 
 Pair<Long, Long> estRowStats = getEstimatedRowStatsForRegion(region, false, clusterStatus); 
 private static void generateDataToFile( String schemaFile, int targetNumElements, String outputFile) throws IOException { 
 private static void generateDataToFile( String schemaFile, int targetNumElements, String outputFile) throws IOException { 
 conf.set("parquet.avro.write-old-list-structure", "false"); 
 for (float i = 0.0f; i < NUM_UNIQUE_ELEMENTS; i++) { floatCache.add(i); 
 case RECORD: { GenericRecordBuilder builder = new GenericRecordBuilder(schema); for (Field f: schema.getFields()) { builder.set(f, generateDatum(f.schema(), depth)); } return builder.build(); 
 int numElements = new Integer(args[1]); 
 Short replication = null; List<Long> cacheIds = Lists.newArrayList(); 
Copyright 2015 Cloudera Inc. 
Copyright 2015 Cloudera Inc. 
<|del|> 
 for (double i = 0.0d; i < NUM_ELEMENTS; i++) { 
 * to call {@code nextRows()}). Disabled by default. * NOTE: This is risky until KUDU-1260 is resolved. 
 public static final long STATS_SIZE_PER_COLUMN_BYTES = 400; 
 hdfsTable.getPartitions().size() * HdfsTable.STATS_SIZE_PER_COLUMN_BYTES; if (statsEstimate > HdfsTable.MAX_INTERMEDIATE_STATS_SIZE_MB) { 
 public THdfsPartition toThrift(boolean includeFileDesc, boolean includeStats) { 
 thriftHdfsPart.setHms_parameters( includeStats ? hmsParameters_ : filterStatsFromHmsParameters()); 
 // For incremental stats, estimate the size of intermediate stats and report an // error if the estimate is greater than MAX_INTERMEDIATE_STATS_SIZE. 
 long statsSizeEstimate = hdfsTable.getColumns().size() * hdfsTable.getPartitions().size() * HdfsTable.STATS_SIZE_PER_COLUMN_BYTES; if (statsSizeEstimate > HdfsTable.MAX_INTERMEDIATE_STATS_SIZE_BYTES) { 
 * Returns hmsParameters_ after filtering out all the partition 
 private Map<String, String> getFilteredHmsParameters() { Predicate<String> isIntermediateStatsKey = new Predicate<String>() { 
 private Map<String, String> getFilteredHmsParameters() { Predicate<String> isIntermediateStatsKey = new Predicate<String>() { 
 private Map<String, String> getFilteredHmsParameters() { Predicate<String> isIntermediateStatsKey = new Predicate<String>() { 
 return Maps.filterKeys(hmsParameters_, isIntermediateStatsKey); 
 public THdfsPartition toThrift(boolean includeFileDesc, boolean includeIntermediateStats) { 
 public static final long NO_TIMESTAMP = -1; 
 checkArgument(htTimestamp >= 0, "Need non-negative number for the scan, " + 
 * Sets the timestamp the scan must be executed at, in microseconds since the Unix epoch. None is * used by default. 
 // Finally, run analysis on the insert and cleanup statement. 
<|del|> 
 for (TableRef tblRef: tableRefs_) clone.add(tblRef.clone()); 
 this.selectList_ = selectList; 
 public UpdateStmt clone() { return new UpdateStmt(this); 
 "Expression is of class '%s'. Expected class '%s'", firstExpr.getClass().getSimpleName(), cl.getSimpleName()), 
 "order by by string_col asc desc"); 
 * In ACID terms this, by itself, corresponds to Isolation mode "Repeatable 
 /** * Returns whether this column is a key column in the Kudu table. */ public boolean isKey() { return isKey_; } /** * Returns whether this column is nullable in the Kudu table. */ 
 // Alias to the string key that identifies the storage handler for tables. 
 // Kudu specific value for the storage handler table property keyed by KEY_STORAGE_HANDLER. 
 private ImmutableList<String> kuduKeyColumnNames_; 
 Set<String> keyColumns) throws TableLoadingException { 
 throw new TableLoadingException(String.format("Kudu tables must have at least one key " + "column (had %d), and no more key columns than there are table columns (had %d).", keyColumns.size(), schema.size())); 
 Set<String> columnNames = Sets.newHashSet(); 
 Set<String> columnNames = Sets.newHashSet(); 
 // TODO(kudu-merge): Check for decimal types? 
 String keyColumnsProp = Preconditions.checkNotNull(msTbl.getParameters().get(KEY_KEY_COLUMNS) .toLowerCase(), "'kudu.key_columns' cannot be null."); Set<String> keyColumns = KuduUtil.parseKeyColumns(keyColumnsProp); 
 for (LocatedTablet tab: tablets) { 
 builder.add(leader.getRpcHost() + ":" + leader.getRpcPort().toString()); 
 * Abstract class to implement the storage specific portion of DDL requests. 
 */ 
 * Creates the table. 
 public boolean alterTable() throws ImpalaRuntimeException { return true; } 
 * incremental stats information. 
<|del|> 
 // error if the estimate is greater than MAX_INTERMEDIATE_STATS_SIZE_BYTES. 
 return !(key.startsWith(PartitionStatsUtil.INCREMENTAL_STATS_NUM_CHUNKS) || key.startsWith(PartitionStatsUtil.INCREMENTAL_STATS_CHUNK_PREFIX)); 
 return !(key.startsWith(PartitionStatsUtil.INCREMENTAL_STATS_NUM_CHUNKS) || key.startsWith(PartitionStatsUtil.INCREMENTAL_STATS_CHUNK_PREFIX)); 
 "IS NOT DISTINCT FROM", "<", ">", ">=", "<=", "!=", "=", "<>"}) { // Operator can compare types that are identical 
 + operator + " cast(NULL as " + string_type + ")", "operands of type " + numeric_type + " and " + string_type + " are not comparable:"); 
 val = (boolean)obj; 
<|del|> 
<|del|> 
<|del|> 
 } } 
 * Returns null if it is not related to a hive database such as builtins_db. 
 ScalarFunction udf1 = ScalarFunction.createScalarFunction("default", "Foo", args1, Type.INVALID, "/Foo", "Foo.class", null, null, TFunctionBinaryType.HIVE); 
 loadFunctionsFromDbParams(msDb); 
<|del|> 
<|del|> 
 * input key <k>. Returns true if the parameters map contains a pair <k,v> * corresponding to input k and it is removed, false otherwise. 
 * using base64 encoding. 
 String base64Fn = Base64.encodeBase64String(serializedFn); 
 LOG.error("Error adding function to DB params " + fn.getName()); 
 if (addToDbParams && !addFunctionToDbParams(fn)) return false; fns.add(fn); Collections.sort(fns, FUNCTION_RESOLUTION_ORDER); return true; 
 if (addToDbParams && !addFunctionToDbParams(fn)) return false; fns.add(fn); Collections.sort(fns, FUNCTION_RESOLUTION_ORDER); return true; 
 // Remove the function from the metastore database parameters 
 String base64Fn = Base64.encodeBase64String(serializedFn); 
 boolean removeFn = removeFromHmsParameters(fnKey); Preconditions.checkState(removeFn); 
 LOG.error("Error serializing function " + desc.getName(), e); 
<|del|> 
 ScalarFunction udf1 = ScalarFunction.createScalarFunction("default", "Foo", args1, Type.INVALID, "/Foo", "Foo.class", null, null, TFunctionBinaryType.HIVE); 
 List<T> filtered; 
 for (Db db: dbs) names.add(db.getName()); 
 Preconditions.checkState(msDb != null); Map<String, String> hms_params = msDb.getParameters(); if (hms_params == null) hms_params = Maps.newHashMap(); 
 LOG.error("Error adding function to DB params " + fn.getName()); 
 val = (byte)obj; 
 * Static helper method to create a function with a given TFunctionBinaryType. 
 * Static helper method to create a scalar function of given * TFunctionBinaryType. Used for testing. 
 * Representation of a SHOW CREATE TABLE statement which returns either the * "CREATE TABLE ..." string that re-creates the table or the "CREATE VIEW ..." * string that re-creates the view as appropriate. 
 // Analyze the view query statement with its own analyzer for authorization. 
 matrixStr.append(StringUtils.repeat(' ', cellSpacing)); 
 * TFunctionBinaryType. 
 * Returns null if it is not related to a hive database such as builtins_db. 
 return new TColumnValue().setString_val( ((TimestampLiteral) expr).getStringValue()); 
 // Views from the Hive metastore may rely on Hive's column naming if the SQL // statement references a column by its implicitly defined column names. 
 // Use toSql() to ensure that the table name and query statement are normalized // and identifiers are quoted. sb.append(view.getTableName().toSql()); 
 AuthzOk("show create table functional.alltypes"); // Have permissions on view and underlying table. AuthzOk("show create table functional_seq_snap.alltypes_view"); 
 value.reset(); 
 varLengthData.reset(); rows.putLong(indirectWrittenBytes); int bbSize = varLengthData.remaining(); rows.putLong(bbSize); indirect.add(varLengthData); indirectWrittenBytes += bbSize; 
 if (!(conjunct instanceof BinaryPredicate)) continue; 
 * Inject tablet server side error for Batch rpc related tests. * @param error Error response from tablet server. * @param latencyMs Blocks response handling thread for some time to simulate * write latency. 
 * Inject tablet server side error for Batch rpc related tests. * @param error Error response from tablet server. * @param latencyMs Blocks response handling thread for some time to simulate * write latency. 
 Batch.injectTabletServerErrorAndLatency(error, 200); 
 // expected assertTrue(e.getMessage().contains("injected error for test")); 
 * @param error error response from tablet server * @param latencyMs blocks response handling thread for some time to simulate * write latency 
 * @throws IllegalArgumentException if the column doesn't exist or if the value doesn't match * the column's type * @throws IllegalStateException if the row was already applied 
 * Encodes a byte buffer into the key. 
 private void addBinaryComponent(ByteBuffer value, boolean isLast) { 
 rows.putLong(indirectWrittenBytes); int bbSize = varLengthData.remaining(); rows.putLong(bbSize); indirect.add(varLengthData); indirectWrittenBytes += bbSize; 
 // we may add the same callback multiple times, later retry of flushTablet will return null // immediately. Since it is an illegal use case, we do not handle this currently. 
 return e; 
 return e; 
 return "Batch(" + ops.size() + " ops)@" + Integer.toHexString(hashCode()); 
 static void injectTabletServerErrorAndLatency(TabletServerErrorPB error, int latencyMs) { 
 /** * Regression test for case where an error in the previous batch could cause the next * batch to hang in flush() */ 
 if (itemType_.isScalarType()) return leftPadding + toSql(); 
 if (valueType_.isScalarType()) return leftPadding + toSql(); 
 * Native user added functions are persisted to the parameters map of the hive metastore * db object corresponding to this instance. This map's key is the function signature and 
 * Updates the hms parameters map by adding the input <k,v> pair. 
 fn.getBinaryType() != TFunctionBinaryType.BUILTIN && fn.getBinaryType() != TFunctionBinaryType.HIVE); 
 } catch (ImpalaException | TException e) { 
 private boolean addFunction(Function fn, boolean addToDbParams) { 
<|del|> 
 public static ScalarFunction createForTesting(String db, 
 String badFnKey = "impala_registered_function_badFn"; 
 ArrayList<FunctionCallExpr> aggExprs = aggInfo_.getMaterializedAggregateExprs(); if (!aggExprs.isEmpty()) { 
 ArrayList<FunctionCallExpr> aggExprs = aggInfo_.getMaterializedAggregateExprs(); if (!aggExprs.isEmpty()) { 
 if (itemType_.isScalarType()) return leftPadding + toSql(); 
 if (valueType_.isScalarType()) return leftPadding + toSql(); 
 TupleDescriptor tupleDesc = slotPath.getRootDesc(); String slotLabel = Joiner.on(".").join(slotPath.getRawPath()); 
<|del|> 
 if (d1 == null || d2 == null) return -1; 
 // true if this BinaryPredicate is inferred from slot equivalences, false otherwise. private boolean isInferred_ = false; 
 public boolean isInferred() { return isInferred_; } public void setIsInferred() { isInferred_ = true; } 
 * runtime. A runtime filter is constructed during the build phase of a join node, and is * applied at a scan node on the probe side of that join node. Runtime filters are 
 // Expr (rhs of join predicate) on which the filter is built 
 public static RuntimeFilter create(IdGenerator<RuntimeFilterId> idGen, 
 // Only consider binary equality predicates if (!Predicate.isEqBinaryPredicate(joinPredicate)) return null; 
 // Only consider binary equality predicates if (!Predicate.isEqBinaryPredicate(joinPredicate)) return null; 
 if (lhsTids.size() != 1 || filterConstructingNode.getChild(1).getTupleIds().contains(lhsTids.get(0))) { return null; } 
<|del|> 
 // 'expr' is not a SlotRef and may contain multiple SlotRefs 
 * there is a value transfer from 'slotId'. The slots are grouped by tuple id. 
 assignRuntimeFilters(analyzer, (ScanNode) root); 
 AggregateInfo aggInfo = selectStmt.getAggInfo(); PlanNode root = createTableRefsPlan(parentRefs, subplanRefs, isStraightJoin, aggInfo, analyzer); 
<|del|> 
 * every row from child(0) joins with |child(1)| / NDV(R.d) rows 
 private final ArrayList<Long> allocations_ = Lists.newArrayList(); 
 switch (hiveRetType_) { case BOOLEAN_WRITABLE: { BooleanWritable val = (BooleanWritable)obj; UnsafeUtil.UNSAFE.putByte(outputBufferPtr_, val.get() ? (byte)1 : 0); return; } 
 UnsafeUtil.UNSAFE.putByte(outputBufferPtr_, (boolean)obj ? (byte)1 : 0); 
 if (d1 == null || d2 == null) return -1; 
 if (s1 == null || s2 == null) return -1; 
 if (b1 == null || b2 == null) return false; 
 false, Type.BOOLEAN, "_ZN6impala13LikePredicate4LikeEPN10impala_udf15FunctionContextERKNS1_9StringValES6_", "_ZN6impala13LikePredicate11LikePrepareEPN10impala_udf15FunctionContextENS2_18FunctionStateScopeE", 
 "'a' ILIKE '%b.', ('a' ILIKE '%b.'), " + 
 // Drop table statement for cleanup after CTAS query failure. 
 if (parentTable_ == null) return null; return new TableName( parentTable_.getDb() != null ? parentTable_.getDb().getName() : null, parentTable_.getName()); 
 * HDFS partitions pruner provides a mechanism to filter out partitions of an HDFS 
 * Construct a node to scan given data files into tuples described by 'desc', * with 'conjuncts' being the unevaluated conjuncts bound by the tuple after * partition pruning and 'partitions' being the remaining partitions after pruning. 
 MetaStoreUtil.checkShortPropertyMap("Property", tblProperties_); MetaStoreUtil.checkShortPropertyMap("Serde property", serdeProperties_); 
 MetaStoreUtil.checkShortPropertyMap("Property", tblProperties_); MetaStoreUtil.checkShortPropertyMap("Serde property", serdeProperties_); 
 LOG.error("Error retrieving startup options: " + e.getMessage()); System.exit(1); 
 ArrayList<SlotDescriptor> result = Lists.newArrayList(); 
 loadReq.close(); 
 // Excludes partition columns. List<FieldSchema> msColDefs = msTbl.getSd().getCols(); 
 if (cachedPart.isDirty() || cachedPart.isDefaultPartition()) { 
 if (cachedPart.isDirty() || cachedPart.isDefaultPartition()) { 
 rowBuilder.add(String.valueOf(p.hasIncrementalStats())); rowBuilder.add(p.getLocation()); 
 StringBuilder errorLog, StringBuilder actualOutput) { 
 } Preconditions.checkNotNull(loadReq); 
 "INPATH location '%s' cannot contain non-hidden subdirectories.", sourceDataPath_)); 
 } @Override public int hashCode() { return id_; } 
 public boolean matches(String input); public String transform(String input); 
 public boolean matches(String input); public String transform(String input); 
 private final static String pathFilter_ = "-*\\d+--\\d+_\\d+.*$"; private final static String portFilter_ = "//\\w+(\\.\\w+)?(\\.\\w+)?:\\d+"; 
<|del|> 
 tserver_processes.put(port, configureAndStartProcess(tsCmdLine)); 
 tserver_processes.put(port, configureAndStartProcess(tsCmdLine)); 
 private final static String REGEX_AGAINST_ACTUAL = "regex:"; 
 private final static String PATH_FILTER = "-*\\d+--\\d+_\\d+.*$"; private final static String PORT_FILTER = "//\\w+(\\.\\w+)?(\\.\\w+)?:\\d+"; 
 private final static String PATH_FILTER = "-*\\d+--\\d+_\\d+.*$"; private final static String PORT_FILTER = "//\\w+(\\.\\w+)?(\\.\\w+)?:\\d+"; 
 private final static String NUMBER_FILTER = "\\d+(\\.\\d+)?"; private final static String FILTER_KEY = "size="; 
 if (filterFileSize && fileSizeFilter_.matches(expectedStr)) { 
 // File size could vary from run to run. For example, parquet file header size could // change if Impala version changes. That doesn't mean anything wrong with the plan 
 static FileSizeFilter fileSizeFilter_ = new FileSizeFilter(); 
 static FileSizeFilter fileSizeFilter_ = new FileSizeFilter(); 
 boolean filterFileSize) { 
 private final int defaultTimeoutMs; 
<|del|> 
 List<HdfsPartition> partitions = Lists.newArrayList(); 
<|del|> 
<|del|> 
<|del|> 
 } catch (InternalException e) { throw new AnalysisException("Invalid Time Zone.", e); 
 } catch (InternalException e) { throw new AnalysisException("Invalid Time Zone.", e); 
 // Takes a timezone String as a serialized TTimezoneIsValidParams. Returns true if // timezone String is valid, false otherwise as a TTimezoneIsValidResult. public native static byte[] NativeCheckIsValidTimeZone(byte[] timezone); 
 if (timezone == null) return false; 
 "Took too long getting the list of tablets, " + deadlineTracker)); 
 return d.addCallbackDeferring( 
 Deferred<List<LocatedTablet>> locateTable(final String tableId, 
 * than could be held in the session's error storage, the overflow state is set to true. * Resets the pending errors. 
 assertEquals("(int8 c0=1, int16 c1=2, int32 c2=3, int64 c3=4, timestamp c4=5, string" + " c5=c5_val, binary c6=\"c6_val\")", 
 // Return type of the function inferred from the udf method signature. The enum // maps it to corresponding primitive type. private HiveUdfDataType hiveRetType_; 
 // Return type of the function inferred from the udf method signature. The enum // maps it to corresponding primitive type. private HiveUdfDataType hiveRetType_; 
 // Return type of the function inferred from the udf method signature. The enum // maps it to corresponding primitive type. private HiveUdfDataType hiveRetType_; 
 setHiveReturnType(retType, m.getReturnType()); if (hiveRetType_ == HiveUdfDataType.INVALID_TYPE) { throw new ImpalaRuntimeException("Unsupported argument type: " + hiveRetType_); } 
 * Sets the number of replicas that each tablet will have. If not specified, it uses the * server-side default which is usually 3 unless changed by an administrator. 
 Analyzer analyzer) { if (!op_.isEquivalence() && op_ != Operator.NULL_MATCHING_EQ) return null; 
<|del|> 
<|del|> 
 private String getLlamaPoolConfigValue(Configuration conf, String pool, String key, String defaultValue) { 
 private String getLlamaPoolConfigValue(Configuration conf, String pool, String key, String defaultValue) { 
 public static boolean isEquivalencePredicate(Expr expr) { 
 protected void addRuntimeFilter(RuntimeFilterId filterId, Expr filterExpr) { 
 } else if (ctx_.getQueryOptions().isEnable_runtime_filter_propagation()) { RuntimeFilterGenerator.generateRuntimeFilters(ctx_.getRootAnalyzer(), singleNodePlan); ctx_.getRootAnalyzer().getTimeline().markEvent( "Runtime filters computed"); 
 // size is less than the pernode memlimit 
 // join is more costly than a partitioned join 
<|del|> 
<|del|> 
 StringBuilder sb = new StringBuilder("DROP FUNCTION "); if (ifExists_) sb.append("IF EXISTS "); 
 params.setIf_exists(ifExists_); 
 Db db = new Db(dbName, this, msClient.getHiveClient().getDatabase(dbName)); 
 Database dbInfo = msClient.getHiveClient().getDatabase(dbName); Db db = new Db(dbName, dbInfo.getDescription(), this); 
<|del|> 
 public boolean computeLineage() { return computeLineage_; } 
 // for the parent AggregationNode node.setIsPreagg(ctx_); 
 private class CachePoolReader implements Runnable { @Override 
 private boolean useStreamingPreagg_; 
 if (useStreamingPreagg_) return "PREAGGREGATION"; 
<|del|> 
<|del|> 
 Preconditions.checkState(fn.dbName().equals(getName())); // TODO: add this to persistent store 
 if (udf.getBinaryType() == TFunctionBinaryType.JAVA) { 
 if (!functionList.isEmpty()) { 
 "found: %s", fn.signatureString())); 
<|del|>
 if (getBinaryType() == TFunctionBinaryType.JAVA && hasSignature()) { fn_.setIsPersistent(false); 
 super(fnName, null, null, location, ifNotExists, optArgs); 
<|del|> 
 if (!isPersistentJavaFn() && analyzer.getCatalog().getFunction( 
 private TFunctionBinaryType binaryType_; // Set to true if this function is persisted. private boolean isPersistent_; 
 if (retType == null) { this.retType_ = ScalarType.INVALID; } else { this.retType_ = retType; } 
 FileSystem fs = source.getFileSystem(CONF); fs.copyToLocalFile(source, dest); 
 for (SlotId sid: sids) tSlotIds.add(sid.asInt()); 
<|del|> 
 } } else if (fn_.getBinaryType() != TFunctionBinaryType.JAVA) { throw new AnalysisException( String.format("Missing function signature while creating non-Java UDF: %s", fn_.getFunctionName())); 
<|del|> 
 "Type " + udf.getReturnType().toSql() + " is not supported for Java UDFs."); 
 if (!functionList.isEmpty()) { 
<|del|> 
 + " is not supported. Only " + FunctionType.JAVA.name() + " functions " + "are supported."; 
 LOG.warn("Skipping load of incompatible Java function: " + 
 } catch (Exception e) { 
 List<org.apache.hadoop.hive.metastore.api.Function> javaFns = 
 * - Java UDFs which are not persisted (Visible to Impala but not Hive) 
 * - Java UDFs which are not persisted (Visible to Impala but not Hive) 
 * - Java UDFs which are not persisted (Visible to Impala but not Hive) 
 * a Java UDF. 
 List<Function> functionList = currentDb.getFunctions( 
 desc_.functionName()).isEmpty() && !ifExists_) { 
 StringBuilder warnMessage = new StringBuilder(); 
 private void loadJavaFunctions(Db db, 
 org.apache.hadoop.hive.metastore.api.Database msDb = msClient.getHiveClient().getDatabase(dbName); Db db = new Db(dbName, this, msDb); loadFunctionsFromDbParams(db, msDb); 
 * - Java UDFs which are not persisted (visible to Impala but not Hive) 
 Preconditions.checkNotNull(db_); for (Function fn: db_.getFunctions(udf.functionName())) { if (!hasSignature() || (hasSignature() && fn.isPersistent())) { 
 synchronized (functions_) { 
 * Each function can be of the following 4 types. * - Native/IR stored in db params (persisted, visible to Impala) * - Hive UDFs stored in the HMS (visible to Hive + Impala) 
 * - Java UDFs which are not persisted (visible to Impala but not Hive) * - Builtin functions, which are recreated after every restart of Catalog * (persisted, visible to Impala) 
<|del|> 
 if (hasSignature()) { 
 String.format("Native functions require a return type and/or " + "argument types: %s", fn_.getFunctionName())); 
 if (hasSignature()) params.setSignature(desc_.signatureString()); 
 if (hasSignature()) params.setSignature(desc_.signatureString()); 
 if (!hasSignature() && db.getFunctions( 
<|del|> 
 List<Function> result = Lists.newArrayList(); 
 * Copies the source file to a destination path on the local filesystem and returns true 
 // Data types that are supported as return or argument types in Java UDFs. 
 STRING("STRING", TPrimitiveType.STRING); 
 STRING("STRING", TPrimitiveType.STRING); 
 public static boolean isSupported(Type t) { 
 new TColumn("is persistent", Type.STRING.toThrift()))); 
 * Mix of compatible and incompatible Java UDFs for testing. 
 // Incompatible - Complex type is not supported for function return values. 
 } // Incompatible public Object evaluate(Object a, Object b, Object c) { return null; } 
 // Set to true for functions that survive service restarts, including all builtins, // native and IR functions, but only Java functions created without a signature. 
 if (!hasSignature() && db != null && db.getFunctions( 
 loadReq = tableLoadingMgr_.loadAsync(tableName); 
 * tests/test-hive-udfs. This is run in testdata/bin/create-load-data.sh, and * copied to HDFS in testdata/bin/copy-udfs-uda.sh. 
 * tests/test-hive-udfs. This is run in testdata/bin/create-load-data.sh, and * copied to HDFS in testdata/bin/copy-udfs-uda.sh. 
 /** * Return the number of header lines that should be skipped when scanning this table. */ 
 private Type[] argTypes_; private Type retType_; 
 ArrayList<Long> allocations_ = Lists.newArrayList(); 
<|del|> 
<|del|> 
 if (incompatible) continue; 
 long expectedNumNodes = (args.length < 9) ? 0 : Long.parseLong(args[8]); int numVerifyRetries = (args.length < 10) ? 3 : Integer.parseInt(args[9]); 
 private boolean hasLocalTarget_ = false; 
 AnalyzesOk("create function if not exists TestFn" + javaFnSuffix); 
 // Db object for function fn_. Set in analyze(); 
<|del|> 
 * - Builtin functions, which are recreated after every restart of the * Catalog. (persisted, visible to Impala) 
<|del|> 
<|del|> 
 * predicate into literals, if possible. * TODO: create a more general mechanism and retire this function 
 for (DistributeParam d : distributeParams_) { 
 for (DistributeParam d : distributeParams_) { 
 public static DistributeParam createHashParam(List<String> cols, BigDecimal buckets) { return new DistributeParam(Type.HASH, cols, buckets); 
 public static DistributeParam createRangeParam(List<String> cols, 
 private final int num_buckets_; 
 // Set in analyze() 
 // Creating the thrift structure simultaneously checks for semantic errors 
 "SPLIT ROWS has different size than number of projected key columns: %d. " + "Split row: %s", columns_.size(), splitRowToString(splitRow))); 
 throw new AnalysisException(String.format("Split row value is not supported: %s " + "(Type: %s) is not supported.", expr.getStringValue(), expr.getType().toSql())); 
 return String.format("HASH(%s) INTO %d BUCKETS", Joiner.on(", ").join(columns_), num_buckets_); 
 // All tableRefs have been analyzed, but at least one table is missing metadata. 
 /** * TODO Consider renaming this to create() and moving the createDataSink() * logic from DataSink to TableSink. */ 
 return TableSink.create(table_, TableSink.Op.INSERT, partitionKeyExprs_, ImmutableList.<Integer>of(), overwrite_, ignoreDuplicates_); 
 // END: Members that need to be reset() ///////////////////////////////////////// 
 for (int i = keyColumnsOffset; i < sourceStmt_.resultExprs_.size(); ++i) { sourceStmt_.resultExprs_.set(i, sourceStmt_.resultExprs_.get(i).castTo( 
 rhsExpr.analyze(analyzer); SlotRef lhsSlotRef = valueAssignment.first; 
 "reference", lhsSlotRef.toSql(), rhsExpr.toSql())); 
 format("Duplicate value assignment to column: '%s'", lhsSlotRef.toSql())); 
 "Column '%s' of type %s is not compatible with the expression %s of type %s", c.getName(), c.getType().toSql(), rhsExpr.toSql(), rhsExpr.getType().toSql())); 
<|del|> 
 public UpdateStmt(List<String> targetTablePath, FromClause tableRefs, List<Pair<SlotRef, Expr>> assignmentExprs, Expr wherePredicate, boolean ignoreNotFound) { 
 return TableSink.create(table_, TableSink.Op.UPDATE, ImmutableList.<Expr>of(), referencedColumns_, false, ignoreNotFound_); 
 isKey_ = isKey; isNullable_ = isNullable; 
<|del|> 
 // Alias to the string key that identifies the storage handler for Kudu tables. 
 // Kudu specific value for the storage handler table property keyed by // KEY_STORAGE_HANDLER. 
 return KUDU_STORAGE_HANDLER.equals(mstbl.getParameters().get(KEY_STORAGE_HANDLER)); 
 if (!columnNames.containsAll(keyColumns)) { 
 String keyColumnsProp = Preconditions.checkNotNull(msTbl.getParameters() .get(KEY_KEY_COLUMNS).toLowerCase(), "'kudu.key_columns' cannot be null."); 
 if ((analysisResult.isInsertStmt() || analysisResult.isCreateTableAsSelectStmt() || analysisResult.isUpdateStmt() || analysisResult.isDeleteStmt()) 
 // Indexes for the set of hosts that will be used for the query. 
 // Extract predicates that can be evaluated by Kudu. 
 cardinality_ = Math.max(Math.max(1, cardinality_), kuduTable_.getNumRows()); 
 private List<Expr> extractKuduConjuncts(Analyzer analyzer) 
 private static BinaryPredicate normalizeIntLiteralComparison( 
 * data from a plan fragment into an Kudu table using a Kudu client. 
 private ArrayList<Integer> targetColIdxs_; 
<|del|> 
 public static boolean compareSchema(Table msTable, KuduTable kuduTable) 
 /** * Sets the value in 'key' at 'pos', given the json representation. */ 
 /** * Sets the value in 'key' at 'pos', given the range literal. */ 
 static String toString(TRangeLiteral l) throws ImpalaRuntimeException { 
 AnalyzesOk("delete from functional_kudu.testtbl"); AnalyzesOk("delete ignore from functional_kudu.testtbl"); 
 public double getSelectivity() { if (src_.getCardinality() == -1 || src_.getChild(0).getCardinality() == -1) { return Double.MAX_VALUE; } 
 double a_selectivity = a.getSelectivity() == -1 ? Double.MAX_VALUE : a.getSelectivity(); double b_selectivity = b.getSelectivity() == -1 ? Double.MAX_VALUE : b.getSelectivity(); double diff = a_selectivity - b_selectivity; 
<|del|> 
 return -1; 
 Preconditions.checkState(!Strings.isNullOrEmpty(dbName_)); 
 "permissions to issue a GRANT/REVOKE statement.", dbName_)); 
 AnalyzesOk(String.format("%s ALL ON SERVER %s myrole", formatArgs)); AnalyzesOk(String.format("%s ALL ON SERVER server1 %s myrole", formatArgs)); 
 .batchSizeBytes(1) // Just a hint, won't actually be that small 
 Preconditions.checkState(resolvedPath_.destType().isCollectionType()); result.setType(Path.getFields(resolvedPath_.destType())); 
<|del|> 
 org.apache.hadoop.hive.metastore.api.Partition part) throws ImpalaException { 
 private DataPartition(TPartitionType type, List<Expr> exprs) { 
<|del|> 
<|del|> 
Copyright 2016 Cloudera Inc. 
 /** * Literal for timestamp values. Because of the custom timestamp parsing done in the * backend, no analysis of these values is done in the frontend; these are just stored as * uninterpreted Strings. */ 
 return createServerScopedPriv(privilegeLevel, null); 
 String configServerName = analyzer.getAuthzConfig().getServerName(); if (serverName_ != null && !serverName_.equals(configServerName)) { 
 * Returns null if this is not a SlotRef comparison. * TODO(kudu-merge): create a more general mechanism and retire this function 
 throw new AnalysisException(String.format("Split row value is not supported: " + "%s (Type: %s).", expr.getStringValue(), expr.getType().toSql())); 
 throw new AnalysisException(String.format("Split row value is not supported: " + "%s (Type: %s).", expr.getStringValue(), expr.getType().toSql())); 
<|del|> 
 if (sourceStmt_ != null) sourceStmt_.reset(); 
 format("Left-hand side column '%s' in assignment expression '%s=%s' does not " + "belong to target table '%s'", lhsSlotRef.toSql(), lhsSlotRef.toSql(), 
 whereClause_ = wherePredicate; groupingExprs_ = groupingExprs; havingClause_ = havingPredicate; colLabels_ = Lists.newArrayList(); 
 // TODO(kudu-merge) why -1? 
 } 
 // Indexes, obtained from the Analyzer's host index, for the set of hosts that will be // used for the query. 
 cardinality_ = Math.min(Math.max(1, cardinality_), kuduTable_.getNumRows()); 
 private static void setKey(Type type, JsonArray array, int pos, PartialRow key) 
 private static void setKey(Type type, TRangeLiteral literal, int pos, String colName, PartialRow key) throws ImpalaRuntimeException { 
 key.addBoolean(pos, literal.isBool_literal()); 
 org.apache.hadoop.hive.metastore.api.Partition partition = null; 
 * Empty implementation for the DdlDelegate interface that does nothing. * TODO(kudu-merge) Should this really return an error? 
 // Indexes for the set of hosts that will be used for the query. // From analyzer.getHostIndex().getIndex(address) 
 return isSupported() && !isComplexType(); 
 * Note: If table has partitions, you need to call * {@link #uncachePartition(HdfsPartition)} for each partition as well. 
 * Return the number of header lines that should be skipped when scanning files in this * table. 
 return "Currently configured default filesystem: " + 
 " is not supported."; 
 if (!FileSystemUtil.hasGetFileBlockLocations(fs)) { synthesizeBlockMetadata(fs, fd, fileFormat); return; } 
 if (!FileSystemUtil.hasGetFileBlockLocations(fs)) { synthesizeBlockMetadata(fs, fd, fileFormat); return; } 
 if (!FileSystemUtil.hasGetFileBlockLocations(fs)) { synthesizeBlockMetadata(fs, fd, fileFormat); return; } 
 return "Currently configured default filesystem: " + 
 /** * Literal for timestamp values. Because of the custom timestamp parsing done in the * backend, no analysis of these values is done in the frontend; these are just stored as * uninterpreted Strings. */ 
 // 'prefix_index_' represents the portion of the partition's location that comes before 
 int batchSizeBytes = 1024*1024; 
<|del|> 
 b.mark(); byte[] buf = new byte[b.limit() - b.position()]; b.get(buf); b.reset(); writeByteArray(dataOutput, buf); 
 * Used for integrations with compute frameworks. 
 * Returns the tablet which the scanner created from this token will access. 
 "Table name cannot be empty, please specify '" + KuduSinkConfigurationConstants.TABLE + "'in configuration file"); 
<|del|> 
 throw new EventDeliveryException("Failed to flush one or more changes. " + 
 throw new EventDeliveryException("Failed to flush changes. " + 
<|del|> 
 if(e instanceof Error || e instanceof RuntimeException) { throw (Error) e; 
 public static final String MASTER_ADDRESS = "master"; 
 Configurables.configure(sink, context); Assert.fail("Should have failed due to missing properties"); 
 } else { LOG.info(String.format("Copying '%s' to '%s' between filesystems.", sourceFile, destFile)); 
 private static final String DEFAULT_KUDU_EVENT_PRODUCER = "org.kududb.flume.sink.SimpleKuduEventProducer"; 
 // If for whatever reason we have pending operations then just refuse to process // and tell caller to try again a bit later. We don't want to pile on the kudu // session object. 
 if (!(fs instanceof DistributedFileSystem || fs instanceof S3AFileSystem)) { 
 // TODO(tmarshall): Differentiate based on the pattern. evalCost_ = getChildCosts() + LIKE_COST; 
 evalCost_ = LITERAL_COST; 
 * Package-private because we shade Protobuf and this is not usable outside this package. 
 * Intended for internal use only. 
 * <tt>tableName: </tt> The name of the table in Kudu to write to. <p> * <tt>masterAddresses: </tt> Comma-separated list of "host:port" pairs of the masters (port optional). <p> 
 public static final String MASTER_ADDRESSES = "masterAddresses"; 
 public static final String TABLE_NAME = "tableName"; 
 * @param event to be written to Kudu 
 * are written as such to Kudu 
 * <tt>table: </tt> The name of the table in Kudu to write to. <p> * <tt>master: </tt> The Kudu master host addresses. <p> 
 tableName = context.getString(KuduSinkConfigurationConstants.TABLE); 
 "Master address cannot be empty, please specify '" + 
 logger.info("No Kudu event producer defined, will use default"); 
 * The Kudu master host addresses. 
<|del|> 
<|del|> 
 conjuncts_ = Expr.orderConjuncts(conjuncts_); 
<|del|> 
 // Indicates whether the file format can skip complex columns in scans and just 
 public boolean canSkipComplexTypes() { 
 * @param op the comparison operation 
<|del|> 
 value = Math.nextAfter(value, Double.POSITIVE_INFINITY); 
 StringBuilder error = new StringBuilder(); hdfsTable.parseSkipHeaderLineCount(error); if (error.length() > 0) throw new AnalysisException(error.toString()); 
 // TODO (KUDU-1411) 
 * method. This allows use cases such as generating scan tokens in the planner * component of a query engine, then sending the tokens to execution nodes based * on locality, and then instantiating the scanners on those nodes. 
 public byte[] serialize() throws IOException { byte[] buf = new byte[message.getSerializedSize()]; 
 public static KuduScanner deserializeIntoScanner(byte[] buf, KuduClient client) throws Exception { 
 public static KuduScanner deserializeIntoScanner(byte[] buf, KuduClient client) throws Exception { 
 // TODO (KUDU-1187) 
 */ @InterfaceAudience.Public @InterfaceStability.Unstable 
<|del|> 
<|del|> 
 private final int prefix_index_; 
 int numClusteringColumns = HdfsPartitionLocationCompressor.this.numClusteringColumns_; if (numClusteringColumns == 0) return new Pair<String,String>(s, ""); // Iterate backwards over the input until we have passed 'numClusteringColumns' 
 for (; numClusteringColumns > 0 && i >= 0; --i) { if (s.charAt(i) == '/') --numClusteringColumns; 
<|del|> 
<|del|> 
 public void populate(ArrayList<T> list) { 
 private ArrayList<T> list_ = Lists.newArrayList(); 
 public int getIndex(T t) { 
 private final LocatedTablet tablet; private final ScanTokenPB message; 
 * Serializes this {@code ScanToken} into a byte array. 
 throw new IllegalArgumentException("Scan tokens from different tables may not be compared"); 
 for (KuduPredicate predicate : predicates.values()) { 
 // If the last propagated timestamp is set send it with the scan. 
 KuduScanToken.KuduScanTokenBuilder tokenBuilder = client.newScanTokenBuilder(table) 
 static class TableSplit extends InputSplit implements Writable, Comparable<TableSplit> { 
 // We currently just care about the partition key since we're within the same table. 
import static org.junit.Assert.*; 
 switch (type_) { case DATE: case DATETIME: case BINARY: return false; default: return true; } 
 builder.add("-1"); // The Kudu client API doesn't expose tablet row counts. 
 // Compute cost as the sum of evaluating all of the WHEN exprs, plus 
<|del|> 
<|del|> 
<|del|> 
 protected float getChildCosts() { float cost = 0; for (Expr child : children_) cost += child.getCost(); 
 protected float getChildCosts() { float cost = 0; for (Expr child : children_) cost += child.getCost(); 
<|del|> 
 orderJoinConjunctsByCost(); 
 orderJoinConjunctsByCost(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public final static ColumnDef REQUIRED_THRIFT_COLUMN_DEF; 
public class KuduClient implements AutoCloseable { 
 if (analyzer.dbContainsTable(tableName_.getDb(), tableName_.getTbl(), Privilege.CREATE) && !ifNotExists_) { 
 AlterTableSetTblProperties.analyzeSkipHeaderLineCount(tblProperties_); 
 // Note As of the time of writing (03/11/16), a null tablet doesn't make sense, if we see a null // tablet it's because we didn't set it properly before calling sendRpc(). 
 private static final long TEST_TIMEOUT_SECONDS = 600000; 
<|del|> 
<|del|> 
<|del|> 
 BaseKuduTest.restartTabletServer(table); 
 Preconditions.checkState(conjuncts_.isEmpty()); 
 Preconditions.checkState(conjuncts_.isEmpty()); 
 Preconditions.checkNotNull(rules); Preconditions.checkState(RuntimeEnv.INSTANCE.isTestEnv()); 
 * Picks at random a tablet server that serves tablets from the passed table and restarts it. * Waits between killing and restarting the process. 
<|del|> 
 assertTrue(cluster.waitForTabletServers(NUM_TABLET_SERVERS)); 
 assertEquals(masterPort, TestUtils.findFreePort(masterPort)); 
 assertEquals(masterPort, TestUtils.findFreePort(masterPort)); 
import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.SocketAddress; import java.net.URL; import java.net.URLDecoder; 
 return provider_.getGroupMapping().getGroups(user.getShortName()); 
<|del|> 
 Path p2) throws IOException { // Only distributed file systems have encryption zones. 
 // If the source and the destination are on different file systems, or in different // encryption zones, files can't be moved from one location to the other and must be // copied instead. 
 // If the source and the destination are on different file systems, or in different // encryption zones, files can't be moved from one location to the other and must be // copied instead. 
 boolean doRename = (isDestDfs && sameFileSystem) ? sameEncryptionZone : sameFileSystem; 
 * Returns true iff the filesystem is a S3AFileSystem. 
 * Returns true iff the filesystem is a S3AFileSystem. 
 .append(colName_, rhs.colName_) .append(comment_, rhs.comment_) .append(typeDef_, rhs.typeDef_) .append(type_, rhs.type_) 
 RowFormat getRowFormat() { if (rowFormat_ != null) return rowFormat_; Preconditions.checkState(fileFormat_ == null || fileFormat_ == THdfsFileFormat.TEXT); return RowFormat.DEFAULT_ROW_FORMAT; } 
<|del|> 
 * @param statistics object to update 
 * @param statistics object to update 
<|del|> 
<|del|> 
 KEEP_RUNNING_LATCH.await(2, TimeUnit.SECONDS); 
 private final ConcurrentHashMap<String, Statistics.TabletStatistics> stsMap = new ConcurrentHashMap<>(); 
 * How many operations have been sent to server and succeeded. 
 * How many rpcs have been sent to server and succeeded. One rpc may contain 
 * @param tabletId the tablet's id 
 public String getTableName(String tabletId) { 
<|del|> 
 @Test(timeout = 10000) 
 .append(colName_, rhs.colName_) .append(comment_, rhs.comment_) .append(typeDef_, rhs.typeDef_) .append(type_, rhs.type_) 
 Preconditions.checkState(fileFormat_ == THdfsFileFormat.TEXT); 
 Preconditions.checkState(fileFormat_ == THdfsFileFormat.TEXT); 
 if (rowFormat != null) params.setRow_format(rowFormat.toThrift()); 
<|del|> 
 private void analyzeKuduFormat(Analyzer analyzer) throws AnalysisException { 
<|del|> 
 // user provides a Kudu table name (or uses implicit Hive Metastore to Kudu mapping // rules), then the schema is imported from Kudu. 
 List<String> candidateTableNames = Lists.newArrayListWithCapacity(2); 
 kudu.createTable(kuduTableName, schema, tableOpts); 
 int otherLogLevel, boolean allowAuthToLocal) throws InternalException { 
 String.format("Error altering Kudu table '%s'", name), e); 
Copyright 2016 Cloudera Inc. 
 super(outer, inner, tblRef, otherJoinConjuncts, "HASH JOIN"); 
<|del|> 
 * Given a distributed plan, return list of plans ready for parallel execution. 
 private void createBuildPlans(PlanFragment fragment, CohortId buildCohortId) { 
<|del|> 
 evalCost_ = getChildCosts() + (float) (getAvgStringLength(getChild(0)) + 
 // without any columns is specified. Maybe reject that here? // TODO: Revisit in the context of IMPALA-3650 
 * data if the table is not managed. Throws an exception if the Kudu table could not be 
 * Create a table in Kudu with a schema equivalent to the schema stored in msTable_. * Throws an exception if unable to do so. 
 "INPATH location '%s' cannot contain non-hidden subdirectories.", sourceDataPath_)); 
 private static boolean arePathsInSameHdfsEncryptionZone(FileSystem fs, Path p1, 
 * preserving the existing file extension. If renameIfAlreadyExists is false, an 
 Path destFile = destFs.isDirectory(dest) ? new Path(dest, sourceFile.getName()) : dest; 
 boolean destIsDfs = isDistributedFileSystem(destFs); 
 } else { Preconditions.checkState(!sameFileSystem); 
 * Returns true iff the path is on a S3AFileSystem. 
 } else { Preconditions.checkState(!sameFileSystem); 
 evalCost_ = getChildCosts() + (float) (getAvgStringLength(getChild(0)) + getAvgStringLength(getChild(1)) * BINARY_PREDICATE_COST); 
 evalCost_ = getChildCosts() + (float) (getAvgStringLength(getChild(0)) + getAvgStringLength(getChild(1)) * BINARY_PREDICATE_COST) + LIKE_COST; 
 final static String KUDU_STORAGE_HANDLER_ERROR_MESSAGE = "Kudu tables must be" 
 public JoinBuildSink(JoinTableId joinTableId, JoinNode joinNode) { 
 * JoinBuildSink to build another hash table) 
 * operation. 
 * A Statistics belongs to a specific AsyncKuduClient. It stores client-level 
 * This class is thread-safe. The user can use it anywhere to get statistics of this 
 WRITE_OPS(1), 
 int getIndex() { 
 return tabletStatistics.getStatistic(statistic); 
 * @param statistic the statistic type to get * @return the value of the statistic 
 * @param statistic the statistic type to get * @return the value of the statistic 
 * @param statistic the statistic type to get * @return the value of the statistic 
 * which have statistics information. * @return set of tablet ids 
 * which have statistics information. * @return set of tablet ids 
 * which have statistics information. * @return set of table names 
 * which have statistics information. * @return set of table names 
 if (!ctx_.authzConfig.isFileBasedPolicy()) return; 
 * (= tree of PlanFragments) into a (logical) tree of distributed plans. The root 
 output.append( detailPrefix + "hash-table-id=" + joinTableId_.toString() + "\n"); 
 private void createBuildPlans(PlanFragment fragment, CohortId buildCohortId) { 
 // Create new fragment with JoinBuildSink that consumes the output of the // join's rhs input (the one that materializes the build side). // The new fragment has the same data partition as the join node's fragment. 
 // Create new fragment with JoinBuildSink that consumes the output of the // join's rhs input (the one that materializes the build side). // The new fragment has the same data partition as the join node's fragment. 
 PlanFragment buildFragment = new PlanFragment(ctx_.getNextFragmentId(), join.getChild(1), join.getFragment().getDataPartition()); 
 * This is a helper for the CatalogOpExecutor to provide functionality that isn't yet in * Hive. When Hive functionality is available, that should be preferred to the * functionality here. https://issues.cloudera.org/browse/IMPALA-3424 tracks this. 
 * Create a table in Kudu with a schema equivalent to the schema stored in 'msTbl'. * Throws an exception 'msTbl' represents an external table or if the table couldn't 
 * TableNotFoundException is thrown. If the table exists and could not be dropped, * an ImpalaRuntimeException is thrown. 
 private final TableDataLayout dataLayout_; 
 return provider_.getGroupMapping().getGroups(user.getShortName()); 
 public void TestDescribe() throws ImpalaException { 
 filtersStr.add(String.format(format, entry.getKey(), entry.getValue().toSql())); 
 * Returns the maximum number of bytes returned by the scanner, on each batch. 
 // Uncorrelated NOT EXISTS subquery is illegal with only relative table refs 
public abstract class KuduException extends IOException { 
<|del|> 
 throw new IllegalArgumentException("Column (" + columnIndex + ") is of type " + columnType.getName() + " but was requested as a type " + expectedType.getName()); 
 typeDef_ = typeDef; isPrimaryKey_ = isPrimaryKey; 
 } return byteVal; 
<|del|> 
 for (String name: colNames) colNames_.add(name.toLowerCase()); 
 Preconditions.checkState(KuduUtil.isSupportedKeyType(colType)); 
 private final List<ColumnDef> primaryKeyColDefs_ = Lists.newArrayList(); 
 * Return the name that should be used in Kudu when creating a table and the user did * not provide an explicit Kudu table name. 
<|del|> 
class NonRecoverableException extends KuduException { 
class RecoverableException extends KuduException { 
 private final User processUser_; 
* ('statsKey'='val','statsKey2',='val2') statement. 
 setStatsValue(statsKey, entry.getValue(), col, colStats_); 
 && (statsKey == ColumnStats.StatsKey.AVG_SIZE || statsKey == ColumnStats.StatsKey.MAX_SIZE)) { 
 updateStatsParams.putToColumn_stats(colName_.toString(), colStats_.toThrift()); 
<|del|> 
public class AlterTableSetColumnStats extends AlterTableStmt { 
 // Validity of stats key should have already been asserted. Preconditions.checkState(false); 
 import static org.junit.Assert.*; 
 public void update(StatsKey key, Number value) { 
 * partitioning. To force the use of a single tablet (not recommended), * call this method with an empty list and set no split rows and no hash * partitions. 
 ColumnSchema columnSchema = schema.getColumnByIndex(columnIndex); throw new IllegalArgumentException("The requested column (name: " + columnSchema.getName() + ", index: " + columnIndex + ") is null"); 
 throw new IllegalArgumentException("Column (name: " + columnSchema.getName() + ", index: " + columnIndex +") is of type " + columnType.getName() + " but was requested as a type " + expectedType.getName()); 
<|del|> 
<|del|> 
 protected void analyzeUsingPrivilege(Analyzer analyzer, Privilege privilege) throws AnalysisException { 
 protected void analyzeUsingPrivilege(Analyzer analyzer, Privilege privilege) throws AnalysisException { 
 TUpdateCatalogCacheRequest merged_update_request = new TUpdateCatalogCacheRequest(); 
 // Merge incrementalRequest into merged_update_request if (!merged_update_request.isSetIs_delta()) { merged_update_request.setIs_delta(incrementalRequest.isIs_delta()); } 
 merged_update_request.setCatalog_service_id( incrementalRequest.getCatalog_service_id()); 
 mergedUpdateRequest.getUpdated_objects().addAll( incrementalRequest.getUpdated_objects()); mergedUpdateRequest.getRemoved_objects().addAll( incrementalRequest.getRemoved_objects()); 
 mergedUpdateRequest.getUpdated_objects().addAll( incrementalRequest.getUpdated_objects()); mergedUpdateRequest.getRemoved_objects().addAll( incrementalRequest.getRemoved_objects()); 
 nameSb.append("Table ").append(table.getFullName()); 
 private List<HdfsPartition> partitions_ = Lists.newArrayList(); 
 // Flag used to tell if it is using the old KV style PartitionSpec. 
 // Flag used to tell if it is using the old KV style PartitionSpec. 
<|del|> 
<|del|> 
 Analyzer analyzer, List<Expr> conjuncts, boolean allowEmpty) 
 for (byte[] catalogUpdate: thriftCatalogUpdates) { 
 @Override public void close() { 
@InterfaceAudience.Private 
 public List<String> getTabletsList() { 
 public List<Db> getDbs(PatternMatcher matcher) { return filterCatalogObjectsByPattern(dbCache_.get().values(), matcher); 
<|del|> 
 return d.join(asyncScanner.scanRequestTimeout); 
 public static final Logger LOG = LoggerFactory.getLogger(NonCoveredRangeCache.class); 
 /** * Retrieves a non-covered range from the cache. 
 /** * Adds a non-covered range to the cache. * * @param startPartitionKey the inclusive start partition key of the non-covered range * @param endPartitionKey the exclusive end partition key of the non-covered range */ 
 */ @InterfaceAudience.Public @InterfaceStability.Unstable 
 return EMPTY; 
 @Test(timeout = 100000) 
 * caller to specify the table privilege required for executing the alter * statement 
 * caller to specify the table privilege required for executing the alter * statement 
 * caller to specify the table privilege required for executing the alter * statement 
 List<ColumnDef> colDefs, List<ColumnDef> avroCols, StringBuilder warning) throws AnalysisException { 
 // A CHAR/VARCHAR/STRING column definition maps to an Avro STRING, and is preserved // as a CHAR/VARCHAR/STRING in the reconciled schema. Column name and comment // are taken from the Avro schema. 
<|del|> 
class NonCoveredRangeCache { private static final Logger LOG = LoggerFactory.getLogger(NonCoveredRangeCache.class); 
class NonCoveredRangeCache { private static final Logger LOG = LoggerFactory.getLogger(NonCoveredRangeCache.class); 
 return null; } else { return range; 
 } // Concurrent additions of the same non-covered range key are handled by // serializing puts through the concurrent map. 
 assertEquals(rows, collectRows(syncClient.newScannerBuilder(table).build())); 
 * If 'allowEmpty' is True, partitions that contain no file may be survived * during pruning. Used by some ALTER TABLE statements which need partition * pruning. 
 MetadataOpParams metadataParams) throws ImpalaException { 
 for (Db db: fe.getDbs(schemaPatternMatcher, user)) { if (fnPatternMatcher != null) { 
 for (String tabName: fe.getTableNames(db.getName(), tablePatternMatcher, user)) { 
 if (columnPatternMatcher == null) continue; 
 public class MetaStoreClient implements AutoCloseable { 
 // hive by default has no quote char 
 // You can set the escape character as a tuple or first byte of field delimiter. // Empirically, this is ignored by hive. 
 ", tablet=" + operation.getTablet() + 
 // not null when refreshing a single partition specified by this partition // spec 
 if (partitionSpec_ != null) partitionSpec_.setTableName(tableName_); 
 return impaladCatalog_.getDataSources( PatternMatcher.createHivePatternMatcher(pattern)); 
 private void markInUse() { Preconditions.checkState(!isInUse_); 
 synchronized (monitor) { return activeBuffer == null ? inactiveBuffers.size() < 2 : activeBuffer.getOperations().size() > 0 || !inactiveBufferAvailable(); 
<|del|> 
 * Returns all databases that match the pattern of 'matcher'. * @see PatternMatcher for supported matchers. 
 * Returns all databases that match the pattern of 'matcher'. * @see PatternMatcher for supported matchers. 
 public List<String> getTableNames(String dbName, PatternMatcher matcher) 
 * Return all catalog objects from 'candidates' that match the pattern of 'matcher'. If * 'matcher' does not have a pattern, all catalog objects in 'candidates' are returned. * The results are sorted in CATALOG_OBJECT_ORDER. 
 public List<String> getTableNames(String dbName, PatternMatcher matcher, 
<|del|> 
 * Utility Class that represents the input parameters of getMetadataOp() function call. 
 * associated search patterns in 'metadataParams'. All patterns are treated as JDBC * search patterns. * @see PatternMatcher#createJdbcPatternMatcher(String) 
 * associated search patterns in 'metadataParams'. All patterns are treated as JDBC * search patterns. * @see PatternMatcher#createJdbcPatternMatcher(String) 
 * associated search patterns in 'metadataParams'. All patterns are treated as JDBC * search patterns. * @see PatternMatcher#createJdbcPatternMatcher(String) 
<|del|> 
 ctx_.authzConfig); 
 ctx_.catalog.reset(); 
 hiveClient_.close(); 
 * Return all Strings from 'candidates' that match the pattern of 'matcher'. If * 'matcher' does not have a pattern, all catalog objects in 'candidates' are returned. 
 while (iter.hasNext()) { String tblName = iter.next(); 
 * A utility Class that represents the input parameters of getDbsMetadata() function call. 
 // Returns true if patterns_ is null or the candidate matches. // Returns false if patterns_ is empty or the candidate mismatches. 
 * Returns aal DataSources that match the pattern of 'matcher'. * @see PatternMatcher for supported matchers. 
 * Returns aal DataSources that match the pattern of 'matcher'. * @see PatternMatcher for supported matchers. 
 * Return all String from 'candidates' that match the pattern of 'matcher'. If 'matcher' * does not have a pattern, all catalog objects in 'candidates' are returned. 
 * Returns all columns of a table that match a pattern and are accessible to * the given user. If pattern is null, it matches all columns. 
 * Returns all columns of a table that match a pattern and are accessible to * the given user. If pattern is null, it matches all columns. 
 * Utility Class that represents the input parameters of getDbsMetadata() function call. 
 // Returns true if patterns_ is null or the candidate matches. // Returns false if patterns_ is empty or the candidate mismatches. 
 * Utility Class that represents the input parameters of a getDbsMetadata() function * call. 
 // Maximum number of idle metastore connections in the connection pool at any point. 
 // Ensure the connection isn't returned to the pool if the pool has been closed // or if the number of connections in the pool exceed MAX_HMS_CONNECTION_POOL_SIZE. 
<|del|> 
 * Returns a list of data sources names that match pattern. 
 * Returns all DataSources that match 'matcher'. 
 * Returns all DataSources that match 'matcher'. 
 * Return all members of 'candidates' that match 'matcher'. 
 * Return all members of 'candidates' that match 'matcher'. 
<|del|> 
 public static PatternMatcher createJdbcPatternMatcher(String pattern) { Preconditions.checkNotNull(pattern); PatternMatcher matcher = new PatternMatcher(); 
 * null pattern matches nothing while empty pattern matches all. 
 String pattern) { 
 * If 'allowEmpty' is True, partitions that contain no file may survive during * pruning. Used by some ALTER TABLE statements which need partition pruning. 
 * corresponding matchers. 
<|del|> 
 * to the given user. 
<|del|> 
 try { reconciledColDef.analyze(); } catch (AnalysisException e) { Preconditions.checkNotNull(null, "reconciledColDef.Analyze should never throw"); } 
 Preconditions.checkNotNull( null, "reconciledColDef.analyze() should never throw."); 
 * Set the end boundary to CURRENT_ROW if the start boundary is 
 // 5. Set the start boundary to CURRENT_ROW for first_value() if the end boundary // is UNBOUNDED_PRECEDING and IGNORE NULLS is not set. if (analyticFnName.getFunction().equals(FIRST_VALUE) && window_ != null 
 private final Queue<Long> incompleteRpcs = new PriorityBlockingQueue<>(); 
 @Test(timeout = 10000) 
 * @throws KuduException for any error returned by sending RPCs to the master * @throws InterruptedException if this thread is interrupted while sleeping as it is waiting for * the alter table to complete 
 * @throws KuduException if anything went wrong 
 " bytes of data but expected " + expectedSize + " for " + numRows + " rows"); throw new NonRecoverableException(statusIllegalState); 
 * Representation of an error code and message. 
 * 5. first_value() with UNBOUNDED PRECEDING and not IGNORE NULLS: * Set the end boundary to CURRENT_ROW. 
 fnCall_ = new FunctionCallExpr(new FunctionName(LAST_VALUE), 
 || analyticFnName.getFunction().equals(LAST_VALUE)) 
 public void killTabletServerOnPort(int port) throws InterruptedException { Process ts = tserver_processes.remove(port); 
<|del|> 
@InterfaceAudience.Private 
 int numRows, Slice bs, Slice indirectBs) { 
 Schema schema, WireProtocol.RowwiseRowBlockPB data, final CallResponse callResponse) 
 if (w instanceof String || w instanceof ImpalaIntWritable || w instanceof ImpalaFloatWritable || w instanceof ImpalaBigIntWritable || w instanceof ImpalaDoubleWritable || w instanceof ImpalaBooleanWritable || w instanceof ImpalaTinyIntWritable || w instanceof ImpalaSmallIntWritable) { 
 * @param udfClassPath: fully qualified class path for the UDF. 
 UdfExecutor createUdfExecutor(String jarFile, String udfClassPath, Type retType, 
 jarFile = Strings.nullToEmpty(jarFile); ScalarFunction scalar_fn = ScalarFunction.createForTesting("default", "fn", argTypes, retType, /* unused */jarFile, udfClassPath, null, null, TFunctionBinaryType.JAVA); 
 jarFile = Strings.nullToEmpty(jarFile); ScalarFunction scalar_fn = ScalarFunction.createForTesting("default", "fn", argTypes, retType, /* unused */jarFile, udfClassPath, null, null, TFunctionBinaryType.JAVA); 
 jarFile = Strings.nullToEmpty(jarFile); ScalarFunction scalar_fn = ScalarFunction.createForTesting("default", "fn", argTypes, retType, /* unused */jarFile, udfClassPath, null, null, TFunctionBinaryType.JAVA); 
 ScalarFunction scalar_fn = ScalarFunction.createForTesting(null, "fn", argTypes, retType, udfPath, udfPath, null, null, TFunctionBinaryType.JAVA); TFunction fn = scalar_fn.toThrift(); 
 return new UdfExecutor(serializer.serialize(params)); 
 private final static TBinaryProtocol.Factory PROTOCOL_FACTORY = 
 // Validate the argument's type. To mimic the behavior of the BE, only primitive types // are allowed. 
 // Permutation of the previous. 
 d.join(); // Don't care about the response. 
 private static void callTheRightCallback( 
class NonCoveredRangeException extends NonRecoverableException { 
 * see if you're using the non-async API, such as {@link KuduSession} instead of 
 private static final HiveMetaHookLoader dummyHookLoader = new HiveMetaHookLoader() { 
 * a new client is created and added to the pool. The idle pool can expand till a maximum * size of MAX_HMS_CONNECTION_POOL_SIZE, beyond which the connections are closed. 
 * a new client is created and added to the pool. The idle pool can expand till a maximum * size of MAX_HMS_CONNECTION_POOL_SIZE, beyond which the connections are closed. 
 // Maximum number of idle metastore connections in the connection pool at any point. 
 // or if the number of connections in the pool exceeds MAX_HMS_CONNECTION_POOL_SIZE. 
 * This class intends to test a UDF that has some classes that the Catalog's 
<|del|> 
 Preconditions.checkArgument(!isRefresh || name != null); Preconditions.checkArgument(isRefresh || partitionSpec == null); 
 // not null when refreshing a single partition 
 columnDefs_, tableName_.toString()); 
 "Could not resolve table reference: 'wrongdb.alltypessmall'"); 
<|del|> 
 // Doing a get first instead of putIfAbsent to avoid creating unnecessary // table locations caches because in the most common case the table should // already be present 
 // Give the locations to the tablet location cache for the table, so that it // can cache them and discover non-covered ranges. 
 long deadline = System.nanoTime() + ttl * TimeUnit.MILLISECONDS.toNanos(1); 
 AsyncKuduClient.EMPTY_ARRAY, deadline)); 
 /** Deadline in ns relative the the System nanotime clock. */ 
 private long ttl() { return TimeUnit.NANOSECONDS.toMillis(deadline - System.nanoTime()); 
 * with the provided bounds. 
 String tableName = name.getMethodName() + System.currentTimeMillis(); 
<|del|> 
 super(name, catalog, createMetastoreDb(name)); Table table = new InformationSchemaTable(null,null,this,"impala-metrics", "system"); addTable(table); 
// inputCardinality_ = numRowsEstimate_; // need to change to metrics.size() or estimate // cardinality_ = numRowsEstimate_; 
 public Deferred<AlterTableResponse> alterTable(String name, AlterTableOptions ato) { 
 // Clear the table locations cache so the new partition is immediately visible. 
 // already be present. 
 // Build the list of discovered remote tablet instances. If we have // already discovered the tablet, its locations are refreshed. 
 // Early creating the tablet so that it parses out the pb. 
 CreateViewStmt createViewStmt = (CreateViewStmt) AnalyzesOk(createViewSql); Db db = catalog_.getDb(createViewStmt.getDb()); 
 private String tableId; 
 * @return the ID of the altered table, or null if the master version is too old 
 // The current join is a distributed non-equi right outer or semi join // which has no backend support. Invert the join to make it executable. 
 //root.computeTupleIds(); 
 * Represents a set of partitions resulting from evaluating a list of partition conjuncts * against a table's partition list. 
<|del|> 
 if (e.isConstant()) { throw new AnalysisException(String.format("Invalid partition expr %s. A " + "partition spec may not contain constant predicates.")); 
 FileSystem fs = path.getFileSystem(new Configuration()); 
 String.format("Column %s is not nullable but was decoded as null", name)); } else { // leave unset for possible Kudu default 
 private final static Logger LOG = LoggerFactory.getLogger(KuduScanNode.class); 
 private final static Logger LOG = LoggerFactory.getLogger(KuduScanNode.class); 
 TNetworkAddress networkAddress = addressToTNetworkAddress("localhost:12345"); 
<|del|> 
 // Slot paths are ambiguous. 
 // Slot paths are ambiguous. 
 // Slot paths are ambiguous. 
 parameters.put(KuduSinkConfigurationConstants.PRODUCER, "org.apache.kudu.flume.sink.AvroKuduEventProducer"); 
 // List of conjuncts that can be pushed down to Kudu, after they have been normalized // by BinaryPredicate.normalizeSlotRefComparison(). Used for computing stats and // explain strings. 
 kuduTable_.getKuduMasterAddresses()).build()) { 
 // TODO: Consider only using the LEADER replica. 
 if (op == null) return false; 
 if (op == null) return false; 
<|del|> 
 Preconditions.checkNotNull(partitions); Preconditions.checkState(!partitions.isEmpty()); partitions_ = partitions; 
 for (PartitionParams p: partitions_) p.setTableName(tableName); 
<|del|> 
 partition.getSerdeInfo().getParameters().putAll(properties); 
 private static final String SCHEMA_URL_HEADER = "flume.avro.schema.url"; private static final String SCHEMA_LITERAL_HEADER = "flume.avro.schema.literal"; 
 throw new FlumeException("Cannot deserialize event", e); 
 if (col.isNullable()) { row.setNull(name); 
 private Schema schema(Event event) throws FlumeException { Map<String, String> headers = event.getHeaders(); String schemaURL = headers.get(SCHEMA_URL_HEADER); String schemaLiteral = headers.get(SCHEMA_LITERAL_HEADER); 
<|del|> 
 "Invalid avro.schema.url: %s. Path does not exist.", url)); 
<|del|> 
 "Partition expr in set location statements can only match " + "one partition. Too many matched partitions %s %s", Joiner.on(", ").join(partitionNames), num < partitions.size() ? "..." : ".")); 
 if (bp.isSingleColumnPredicate(slotRef, null)) { columnNames.add(slotRef.getRef().getDesc().getColumn().getName()); } else { 
 rangeElementStrings.add(rangeElement.toSql()); 
 rangeElementStrings.add((rangeElement.toSqlImpl())); 
<|del|> 
 AddMetricTable(); 
 new SystemTable(new TableId(TableId.SYSTEM_METRICS), null, this, "metrics", "system"); table.addColumn(new Column("impalad_address", Type.STRING, 0)); table.addColumn(new Column("group", Type.STRING, 1)); 
 new SystemTable(new TableId(TableId.SYSTEM_METRICS), null, this, "metrics", "system"); table.addColumn(new Column("impalad_address", Type.STRING, 0)); table.addColumn(new Column("group", Type.STRING, 1)); 
 addTable(table); 
 private final static int ESTIMATED_NUM_ROWS_PER_NODE = 300; 
 private static final int NUM_PARTITION_LOG_LIMIT = 3; 
 ++num; 
 for(HdfsPartition targetPartition : targetPartitions){ 
 partitionSet_ == null ? "" : partitionSet_.toSql(); 
 // Result of analysis 
 super.analyze(analyzer); 
 super.analyze(analyzer); 
 Set<String> partColNames = Sets.newHashSet(); 
 Column partColumn = nullPredicate.getBoundSlot().getDesc().getColumn(); Preconditions.checkState(clusterColumns.contains(partColumn)); partColNames.add(partColumn.getName()); 
<|del|> 
 if (e instanceof BinaryPredicate) { 
 String key = hdfsTable.getColumns().get(i).getName(); 
 * Base class for PartitionSpec and PartitionSet containing the partition * specifications of related DDL operations. 
 } 
<|del|> 
 private Schema getSchema(Event event) throws FlumeException { 
 private void testEvents(int eventCount, SchemaLocation schemaLocation) 
 Context ctx = schemaLocation != SchemaLocation.GLOBAL ? new Context() : new Context(ImmutableMap.of(PRODUCER_PREFIX + SCHEMA_PROP, schemaURI)); 
 assertEquals("incorrect status for non-empty channel", status, Sink.Status.READY); 
 assertEquals("incorrect status for non-empty channel", status, Sink.Status.READY); 
 record.setLongField(2L * i); record.setDoubleField(2.71828 * i); record.setNullableField(i % 2 == 0 ? null : "taco"); record.setStringField(String.format("hello %d", i)); 
<|del|> 
 "partition spec may not contain constant predicates.", e.toSql())); 
 "column(s): " + e.toSql() + "."); 
 // specified partition specs ignore IF EXISTS by setting partitionShouldExists_ to null. // The given conjuncts are assumed to only reference partition columns. 
 BinaryPredicate bp = (BinaryPredicate) e; if (bp.getOp() != Operator.EQ || !bp.isSingleColumnPredicate(slotRef, null)) { 
 HdfsCachingUtil.uncachePartition(partition); 
 HdfsCachingUtil.uncachePartition(partition); 
<|del|> 
 List<LocatedTablet> newTablets = table.getTabletsLocations( 
 if (Bytes.memcmp(upperBound, range.getFirst()) <= 0) break; 
 // Copy predicates into the row in range partition key column order, // stopping after the first missing predicate. 
 throw new IllegalArgumentException( String.format("unexpected predicate type can not be pushed into key: %s", predicate)); 
 Preconditions.checkArgument(additional >= 0, "negative additional"); 
 Preconditions.checkArgument(additional >= 0, "negative additional"); 
 Preconditions.checkArgument(additional >= 0, "negative additional"); if (data.length - len >= additional) return; data = Arrays.copyOf(data, len + additional); 
 Preconditions.checkArgument(additional >= 0, "negative additional"); if (data.length - len >= additional) return; data = Arrays.copyOf(data, len + additional); 
 if (index >= len) { throw new IndexOutOfBoundsException(String.format("index: %s, len: %s", index, len)); } 
 if (index >= len) { throw new IndexOutOfBoundsException(String.format("index: %s, len: %s", index, len)); } 
 * Appends all of the bytes from another byte array to this vec. 
 if (index >= len) { throw new IndexOutOfBoundsException(String.format("index: %s, len: %s", index, len)); } 
 String.format("Failed to coerce value for column '%s' to type %s", 
public interface KuduOperationsProducer extends Configurable, AutoCloseable { 
 try { operationsProducer.close(); } catch (Exception e) { ex = e; logger.error("Error closing operations producer", e); } try { 
 "Missing master addresses. Please specify property '$s'.", MASTER_ADDRESSES); 
 parameters.put(TABLE_NAME, tableName); parameters.put(MASTER_ADDRESSES, getMasterAddresses()); parameters.put(PRODUCER, SimpleKeyedKuduOperationsProducer.class.getName()); 
 try (KuduClient client = new KuduClientBuilder(kuduTable_.getKuduMasterAddresses()).build()) { 
<|del|> 
<|del|> 
 for (KuduPredicate predicate: kuduPredicates_) tokenBuilder.addPredicate(predicate); 
 // Cannot push prediates with null literal values (KUDU-1595). 
 private static KuduPredicate.ComparisonOp getKuduOperator(BinaryPredicate.Operator op) { 
<|del|> 
 private KuduOperationsProducer operationsProducer; 
<|del|> 
 "partition(year=2050, month=10) location ' '", 
 addIfExists(analyzer, table_, transformedConjuncts); 
<|del|> 
<|del|> 
 new CreateTableOptions().addHashPartitions(ImmutableList.of("key"), 3).setNumReplicas(1); 
<|del|> 
 Set<String> partitionSpecs = Sets.newHashSet(); 
<|del|> 
 if (getDb() != null) sb.append(getDb() + "."); 
 * this method provides a uniquely comparable string representation for this object. 
<|del|> 
 List<ColumnDef> newColumnDefs = analyzeAvroSchema(analyzer); if (newColumnDefs.isEmpty()) { 
 AvroSchemaUtils.setFromSerdeComment(newColumnDefs); // Replace the old column defs with the new ones and analyze them. columnDefs_.clear(); columnDefs_.addAll(newColumnDefs); 
 throw new AnalysisException("Avro schema is null or empty: " + fullTblName); 
 avroCols = AvroSchemaParser.parse(avroSchema); } catch (TableLoadingException e) { throw new AnalysisException(e.getMessage(), e); 
 "Error parsing Avro schema for table '%s': %s", fullTblName, 
 // Kudu specific value for the storage handler table property keyed by // KEY_STORAGE_HANDLER. 
 private ImmutableList<String> kuduKeyColumnNames_; 
 Set<String> columnNames = Sets.newHashSet(); 
 // TODO(kudu-merge): Check for decimal types? 
 msTable_ = msTbl; 
 String sentryServiceConfig, int impalaLogLevel, int otherLogLevel, boolean allowAuthToLocal, String kerberosPrincipal) throws InternalException { 
 * This is a helper for the CatalogOpExecutor to provide functionality that isn't yet in * Hive. When Hive functionality is available, that should be preferred to the * functionality here. https://issues.cloudera.org/browse/IMPALA-3424 tracks this. 
 * This is a helper for the CatalogOpExecutor to provide functionality that isn't yet in * Hive. When Hive functionality is available, that should be preferred to the * functionality here. https://issues.cloudera.org/browse/IMPALA-3424 tracks this. 
<|del|> 
 metastoreTableName : "__IMPALA__" + metastoreDbName + "." + metastoreTableName; 
public class AlterTableSetLocationStmt extends AlterTableSetStmt { // max num of partitions printed during error reporting. 
 sortedPartitions.size() < partitions.size() ? "..." : ".")); 
<|del|> 
<|del|> 
 * Represents an ALTER TABLE [PARTITION partitionSet] SET [UNCACHED|CACHED 'pool']. 
 // If non-null, partitions that an incremental computation might apply to. Must be 
<|del|> 
 partitionColsSql, properties, serdeParameters, isExternal, false, rowFormat, format, compression, table.getStorageHandlerClassName(), location); 
 private ImmutableList<String> kuduKeyColumnNames_; 
 private ImmutableList<String> kuduKeyColumnNames_; 
 * @return a long representing a HybridTime-encoded timestamp 
 // The message may be null. 
<|del|> 
 return countRowsInScan(scanBuilder.build()); 
 sharedWriteTimestamp = resp.getWriteTimestampRaw(); 
 // get disconnected just after sending an RPC so when we reconnect to the same TS we might get // the "Invalid call sequence ID" message. 
 LOG.debug("create plan"); Planner planner = new Planner(analysisResult, queryCtx); 
 private KuduPredicate(ColumnSchema column, byte[][] inListValues) { 
<|del|> 
 * Compares two bounds based on the type of the column. * @param column the column which the values belong to 
 return KeyEncoder.encodeRangePartitionKey(row, rangeSchema); 
 * @return {@code true} if this RANGE predicate contains the value 
 checkColumn(column, Type.BINARY); for (T value : values) { vals.add((byte[]) value); } 
 "com.cloudera.impala.hive.serde.ParquetInputFormat", 
 "com.cloudera.impala.hive.serde.ParquetInputFormat", 
 KuduTable table = createTable( "testDisconnect-" + System.currentTimeMillis(), basicSchema, options); 
 KuduTable table = createTable( "testNoLeader-" + System.currentTimeMillis(), basicSchema, options); 
 TableName tblName = new TableName(dbName, tableName); 
 Table table = globalState_.referencedTables_.get(tblName); if (table != null) { // Return query-local version of table. Preconditions.checkState(table.isLoaded()); return table; } 
 private static final Object metastoreAccessLock_ = new Object(); // IDs not covered in all other cases. 
 return Integer.valueOf(id_).hashCode(); 
 return Integer.toString(id_); 
 TableName tblName = new TableName(dbName, tableName); 
 // List of tables to exclude from partition pruning, and thus all partitions are sent to // BE. For example, the output table of an insert query. private final List<Table> tblNoPartitionPruning_ = Lists.newArrayList();; 
<|del|> 
<|del|> 
 // The Impalad Catalog has the latest tables from the statestore. In order to use the // same version of table in a single query, we cache all referenced tables here. 
 // The Impalad Catalog has the latest tables from the statestore. In order to use the // same version of table in a single query, we cache all referenced tables here. 
 // The output table of an insert query. private Table targetTable_; 
<|del|> 
 public static final long LOCAL_VIEW_ID = -4; 
 static int INVALID_JOIN_TABLE_ID = -1; 
 // List of tables to exclude from partition pruning, and thus all partitions are sent to // BE. For example, the output table of an insert query. private final List<Table> tblNoPartitionPruning_ = Lists.newArrayList();; 
 client.discoverTablets(table, new byte[0], tabletLocations, 1000); 
 // Preserve the root type for NULL literals. 
 // Throws if the expression cannot be evaluated by the BE. return null; 
 private static String localLibraryPath_; 
 public static final int TABLE_SINK_ID = 0; 
 // Maps from base table to its table id used in backend. HashMap<Table, Integer> tableIdMap = Maps.newHashMap(); 
 public TTupleDescriptor toThrift(Integer tableId) { 
 public TTableDescriptor toThriftDescriptor(int tableId, Set<Long> referencedPartitions) { 
 public TTableDescriptor toThriftDescriptor(int tableId, Set<Long> referencedPartitions) { 
 public TTableDescriptor toThriftDescriptor(int tableId, Set<Long> referencedPartitions) { 
 while (KEEP_RUNNING_LATCH.getCount() > 0 && !deadlineTracker.timedOut()) { 
 predicate = normalizeSlotRefComparison(predicate, analyzer); 
 try { thread.join(); } catch (InterruptedException e) { // Need to continue cleaning up. } 
 // same version of a table in a single query, we cache all referenced tables here. 
 * Connect tupleDescriptors to tableDescriptors with unique table ids and get * this DescriptorTable ready to be sent to backend. 
<|del|> 
 /** * Connect tupleDescriptors to tableDescriptors with unique table ids. * Verify table level consistency in the same query by checking references to the same * table refer to the same table instance. */ 
 /** * Connect tupleDescriptors to tableDescriptors with unique table ids. * Verify table level consistency in the same query by checking references to the same * table refer to the same table instance. */ 
 if (targetTable_ != null) { tableIdMap.put(targetTable_, TABLE_SINK_ID); referencedTables.put(targetTable_.getTableName(), targetTable_); } 
 TableName tblName = table.getTableName(); Table checkTable = referencedTables.get(tblName); Preconditions.checkState(checkTable == null || table == checkTable); 
<|del|> 
 // Connect tupleDescriptors to tableDescriptors with unique table ids. // Verify table level consistency in the same query by checking references to the same // table are the same instances. 
 // Maps from base table to its table id used in the backend. 
<|del|> 
 private final Map<Integer, TTableDescriptor> tableMap_ = Maps.newHashMap(); 
 null, null, getTblProperties(), getSerdeProperties(), isExternal(), getIfNotExists(), getRowFormat(), HdfsFileFormat.fromThrift(getFileFormat()), compression, null, getLocation()); 
 null, null, getTblProperties(), getSerdeProperties(), isExternal(), getIfNotExists(), getRowFormat(), HdfsFileFormat.fromThrift(getFileFormat()), compression, null, getLocation()); 
 * Analyzes the parameters of a CREATE TABLE ... STORED AS KUDU statement. Also checks * if Kudu specific properties and parameters are specified for non-Kudu tables. 
 private boolean hasPrimaryKeysSpecified() { 
 * Creates a temporary KuduTable object populated with the specified properties but has * an invalid TableId and is not added to the Kudu storage engine or the * HMS. This is used for CTAS statements. 
 * Creates a temporary KuduTable object populated with the specified properties but has * an invalid TableId and is not added to the Kudu storage engine or the * HMS. This is used for CTAS statements. 
 if (!seenTableIds.contains(tableSink.target_table_id) 
 * Validate that all tables in the descriptor table of 'request' have a unique id and * those are properly referenced by tuple descriptors and table sink. 
 * Creates a view for testing purposes. 
 HashSet<Integer> seenTableIds = Sets.newHashSet(); 
 * Returns the thrift representation of this DescriptorTable. Assign unique ids to all * distinct tables and set them in tuple descriptors as necessary. 
 private void validateTableIds(TExecRequest request) { 
 // same version of a table in a single query, we cache all referenced tables here. 
 * Null flags are omitted for non-nullable slots. There is no padding between tuples when * stored back-to-back in a row batch. 
 static void throwIfNotEmpty(Collection<?> c, String message) 
<|del|> 
<|del|> 
 distributeParam.setPkColumnDefMap(pkColumnDefsByName); 
 /** * Checks if a primary key is specified in a CREATE TABLE stmt. Should only be called * after tableDef_ has been analyzed. */ private boolean hasPrimaryKey() { Preconditions.checkState(tableDef_.isAnalyzed()); 
<|del|> 
 if (!org.apache.impala.catalog.Type.areAssignmentCompatibleTypes(colType, exprType)) { 
 String exprValue = expr.getStringValue(); Preconditions.checkState(!Strings.isNullOrEmpty(exprValue)); literal.setString_literal(exprValue); 
 void setPkColumnDefMap(Map<String, ColumnDef> pkColumnDefByName) { 
 static class Options { 
 fqTableName_ = analyzer.getFqTableName(getTblName()); fqTableName_.analyze(); 
 // Distribution schemes of this Kudu table. Both range and hash-based distributions are 
<|del|> 
 kuduTableName_ = msTable_.getParameters().get(KuduTable.KEY_TABLE_NAME); 
 String colName = colSchema.getName(); 
 * if an error occurs while trying to drop a table from Kudu. 
 * an equivalent schema. Throws an exception if any errors are encountered. 
 // Replace the columns in the Metastore table with the columns from the recently // accessed Kudu schema. 
 * addresses point to valid Kudu masters and that the table exists. 
 public static void validateKuduTblExists( 
 throw new ImpalaRuntimeException(String.format("Kudu table '%s' on master '%s' " + "does not exist.", kuduTableName, masterAddrs)); 
 "functional.alltypestiny", "CREATE TABLE AS SELECT is not supported for " + "Kudu tables."); 
 public void load(boolean dummy /* not used */, IMetaStoreClient msClient, 
 String colName = colSchema.getName(); 
 } else { Preconditions.checkState(param.isSetBy_range_param()); 
 msg.hdfs_scan_node.setUse_mt_scan_node(useMtScanNode_); 
 // Only use one scanner thread per scan-node instance since intra-node // parallelism is achieved via multiple fragment instances. ctx_.getQueryOptions().setNum_scanner_threads(1); 
 // Build the list of discovered remote tablet instances. If we have // already discovered the tablet, its locations are refreshed. 
 * Modifying the list returned by this method affect this cache, 
 @GuardedBy("tabletServers") 
 @GuardedBy("tabletServers") 
 static List<String> toColumnNames(Collection<ColumnDef> colDefs) { 
 /** * Generates and returns a map of column names to column definitions. Assumes that * the column names are unique. */ 
 private void setColumnDefs(List<ColumnDef> colDefs) { 
 "Only Kudu tables can use the DISTRIBUTE BY clause."); 
 // Table name in the Kudu storage engine. It may not neccessarily be the same as the 
 // 1. For managed tables, 'kuduTableName_' is prefixed with 'impala::<db_name>' to 
 * columns. Replaces the columns in msTable_ with the columns from the Kudu table * schema. Throws an ImpalaRuntimeException if Kudu column data types cannot be 
 String colName = colSchema.getName(); 
<|del|> 
 PartitionSchema partitionSchema = kuduTable.getPartitionSchema(); Preconditions.checkState(!colsByPos_.isEmpty()); 
 public static KuduTable createCtasTarget(Db db, 
 if (db != null && params.cascade) dropTablesFromKudu(db); 
 if (!KuduTable.isKuduTable(msTable) || Table.isExternalTable(msTable)) continue; 
<|del|> 
 * such as creating and dropping tables from Kudu. 
<|del|> 
 static void createManagedTable(org.apache.hadoop.hive.metastore.api.Table msTbl, 
 Preconditions.checkState(!Table.isExternalTable(msTbl)); 
 cols.add(new FieldSchema(colSchema.getName(), type.toSql().toLowerCase(), null)); 
 throw new ImpalaRuntimeException(String.format("Kudu table '%s' does not exist " + "on master '%s'", kuduTableName, masterAddrs)); 
 return KUDU_TABLE_NAME_PREFIX + metastoreDbName + "." + metastoreTableName; 
 "Function DATE_PART does not accept the keyword FROM"); // IGNORE NULLS may only be used with first_value/last_value AnalysisError("select lower('FOO' ignore nulls)", "Function LOWER does not accept the keyword IGNORE NULLS."); 
 // order or all columns for Kudu tables. 
 private void analyzeTargetTable(Analyzer analyzer) throws AnalysisException { 
 "insert into x with t(c2) as (select 2) select * from t"); 
 ColumnDef def = colDefsByColName.put(colDef.getColName(), colDef); Preconditions.checkState(def == null); 
 * Analyzes and checks table properties which are common to both managed and external 
<|del|> 
 if (!hasPrimaryKey()) { throw new AnalysisException("A primary key is required for a Kudu table."); } 
 "zero. Given number of replicas is: " + r.toString()); 
 throw new AnalysisException("Split values cannot be NULL. Split row: " + splitRowToString(splitRow)); 
 // Authoritative list of primary key column definitions populated during analysis. 
 * Analyzes the primary key columns. Checks if the specified primary key columns exist * in the table column definitions and if composite primary keys are properly defined * using the PRIMARY KEY (col,..col) clause. 
<|del|> 
import org.apache.log4j.Logger; 
 "distribute by hash(y) into 8 buckets stored as kudu"); // Multilevel partitioning. Data is split into 3 buckets based on 'x' and each // bucket is partitioned into 4 tables based on the split points of 'y'. 
 "Table distribution must be specified for managed Kudu tables."); AnalysisError("create table tab (a int) stored as kudu", "A primary key is required for a Kudu table."); 
 "Table distribution must be specified for managed Kudu tables."); AnalysisError("create table tab (a int) stored as kudu", "A primary key is required for a Kudu table."); 
 "com.cloudera.impala.hive.serde.ParquetOutputFormat", 
 // bucket is partitioned into 4 tablets based on the split points of 'y'. 
<|del|> 
 * the ordering exprs refer to the new tuple materialized by this sort instead of the * original input. 
 // the tuple operated on and returned by the sort node. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * sorted. The source exprs of the slots in sortTupleDesc_ are changed to those in * tupleSlotExprs. 
<|del|> 
<|del|> 
 return !(fs instanceof S3AFileSystem|| fs instanceof LocalFileSystem); 
 analyzer.addWarning("UPSERT does not currently support any plan hints."); return; 
<|del|> 
 insertStmt_ = InsertStmt.createInsert( null, createStmt.getTblName(), false, pkvs, null, queryStmt, null, false); 
 * Representation of a single insert or upsert statement, including the select statement 
<|del|> 
 if (!(table_ instanceof KuduTable)) { 
 if (isUpsert_) { throw new AnalysisException("UPSERT does not currently support any plan hints."); } 
<|del|> 
 "All primary key columns must be specified for UPSERTing into Kudu tables. " + "Missing columns are: id"); 
 } getFnCall().getParams().setIsIgnoreNulls(false); 
 SlotRef inputSlotRef = (SlotRef) smap.getLhs().get(i); SlotRef outputSlotRef = (SlotRef) smap.getRhs().get(i); 
 // The descriptor for the tuples on which the sort operates. 
 // ones that point to the slot refs into the sort's output tuple. 
 // Update the tuple descriptor used to materialize the input of the sort. 
 List<Expr> orderingExprs; if (insertStmt.getTargetTable() instanceof KuduTable) { orderingExprs = Lists.newArrayList(insertStmt.getKuduKeyExprs()); } else { orderingExprs = Lists.newArrayList(insertStmt.getPartitionKeyExprs()); } 
 public boolean requiresSubqueryRewrite() { 
<|del|> 
 * to call toThrift() on this predicate because there is no BE implementation. 
 stmt.whereClause_ = new BetweenToCompoundRule().rewrite(stmt.whereClause_, analyzer); 
 * Rewrites BetweenPredicates into an equivalent conjunctive/disjunctive * CompoundPredicate. * Examples: * A BETWEEN X AND Y ==> A >= X AND A <= Y * A NOT BETWEEN X AND Y ==> A < X OR A > Y 
 return rewriteRecursive(expr, analyzer); 
 private Expr rewriteRecursive(Expr expr, Analyzer analyzer) throws AnalysisException { 
 // refer to this to understand how to create new partitions. 
 // The default partition must be updated if the file format is changed so that new // partitions are created with the new file format. 
<|del|> 
 * Ping request only used for tests to test connections. 
 private final Set<String> tabletServers = new HashSet<>(); 
<|del|> 
<|del|> 
 * expressions. 
 * (key columns for Kudu tables), so that partitions can be written sequentially in the 
import org.apache.impala.planner.PlanNode; import org.apache.impala.rewrite.BetweenToCompoundRule; import org.apache.impala.rewrite.ExprRewriter; 
 * Class describing a BETWEEN predicate. This predicate needs to be rewritten into a * CompoundPredicate for it to be executable, i.e., it is illegal to call toThrift() * on this predicate because there is no BE implementation. 
<|del|> 
 Expr clonedConjunct = betweenToCompoundRule_.apply(conjunct.clone(), analyzer); 
 * Modifying the list returned by this method affect this cache, 
 return !(fs instanceof S3AFileSystem|| fs instanceof LocalFileSystem); 
 // resultExprs_[i] produces the mentionedUpsertColumns_[i] column of the target table. 
 for (int col = 0; col < columns.size(); ++col) { 
 if (isUpsert_) mentionedUpsertColumns_.add(col); 
 void setParentRpc(KuduRpc<?> parentRpc) { assert (this.parentRpc == null); this.parentRpc = parentRpc; 
 * A managed Kerberos Key Distribution Center. * * Provides utility functions to create users and services which can authenticate * to the KDC. * * The KDC is managed as an external process, using the krb5 binaries installed on the system. 
 * A managed Kerberos Key Distribution Center. * * Provides utility functions to create users and services which can authenticate * to the KDC. * * The KDC is managed as an external process, using the krb5 binaries installed on the system. 
 // race-prone TestUtils.findFreePort instead. The upside is that we 
 Path createServiceKeytab(String spn) throws IOException { 
 private static String getBinaryPath(String executable, List<String> searchPaths) throws IOException { 
 // same version of a table in a single query, we cache all referenced tables here. // TODO: Investigate what to do with other catalog objects. 
 // Verify table level consistency in the same query by checking that references to // the same Table refer to the same table instance. 
 // Verify table level consistency in the same query by checking that references to // the same Table refer to the same table instance. 
 if (tbl != targetTable_) referencedPartitions = getReferencedPartitions(tbl); 
 if (tableId == null) return ttupleDesc; ttupleDesc.setTableId(tableId); Preconditions.checkNotNull(path_); ttupleDesc.setTuplePath(path_.getAbsolutePath()); 
 } 
<|del|> 
 // Do not analyze the stmt to avoid applying rewrites that would alter the view // definition. We want to model real views as closely as possible. 
 * Done after analyzeAggregation() since ordering and result exprs may refer to the * outputs of aggregation. 
 LOG.debug("executing {}: {}", Paths.get(argv[0]).getFileName(), Joiner.on(' ').join(args)); 
 private final ServerInfo serverInfo; 
 // canEvalUsingPartitionMd() to fold constant expressions without modifying // the original expr. Expr clonedConjunct = exprRewriter_.rewrite(conjunct.clone(), analyzer); 
 public ExprRewriter(ExprRewriteRule rule) { rules_ = Lists.newArrayList(rule); } 
 * tablet is. For example, an RPC might call {@link #getLeaderConnection()}, contact that TS, find * it's not the leader anymore, and then call {@link #demoteLeader(TabletClient)}. 
<|del|> 
 * @param replicaSelection replication selection mechanism to use 
 String getTabletIdAsString() { return tabletId.toString(Charset.defaultCharset()); } 
 String getTabletIdAsString() { return tabletId.toString(Charset.defaultCharset()); } 
 public void testReplicaSelections() throws Exception { 
<|del|> 
<|del|> 
<|del|> 
 // Remember the SQL string before unnesting operands. 
 // Collect all result expr lists and cast the exprs as necessary. 
 // Should never happen. throw new IllegalStateException( "Error creating agg info in UnionStmt.analyze()", e); 
 // We just care about getting one back. 
 // We just care about getting one back. 
 boolean disableSpilling = 
<|del|> 
 return Joiner.on(",").join(sortedPartitionSpec); 
 addedHmsPartitions.addAll( getPartitionsFromHms(msTbl, msClient, tableName, difference)); 
 * @param rpcTraceFrame trace to add 
 enum Action { // Just before putting the RPC on the wire. 
 PingRequest parent = PingRequest.makeMasterPingRequest(); 
 if (!expr.getType().isSupported()) { 
 // Unsupported type date in a star expansion. 
 * range-based or both. See RangePartition for details on the supported range partitions. 
 * range-based or both. See RangePartition for details on the supported range partitions. 
 // Columns of this distribution. If no columns are specified, all // the primary key columns of the associated table are used. 
 // Columns of this distribution. If no columns are specified, all // the primary key columns of the associated table are used. 
 "partition values is different than the number of distribution " + 
 "(type: %s) is not type compatible with distribution column '%s' (type: %s).", 
 TestUtils.assumeKuduIsSupported(); 
<|del|> 
 * Extracts common conjuncts from a single disjunctive CompoundPredicate. 
 // Get childrens' conjuncts and check 
 if (child1Conjuncts.contains(conjunct)) { // The conjunct may have parenthesis but there's no need to preserve them. // Removing them makes the toSql() easier to read. 
 for (PartitionDef p: partitions_) { 
 public String toCanonicalString() { 
 // Handle HDFS cache. This is done in a separate round bacause we have to apply // caching only to newly added partitions. 
 private static int kuduOperationTimeoutMs_ = 3 * 60 * 1000; 
 Preconditions.checkState(parsedReplicas > 0, "Invalid number of replicas table property:" + replication); 
 * Creates a KuduClient with the specified Kudu master addresses (as a comma-separated 
 private final boolean lowerBoundInclusive_; 
 upperBoundInclusive_ = upperBoundInclusive; isSingletonRange_ = (upperBoundInclusive && lowerBoundInclusive && lowerBoundValues == upperBoundValues); 
 if (!isSingletonRange_) analyzeBoundaryValues(upperBound_, analyzer); 
 RpcTraceFrame.Action.QUERY_MASTER) 
 TestUtils.assumeKuduIsSupported(); 
 // error if the estimate is greater than --inc_stats_size_limit_bytes in bytes 
 cfg.authorization_policy_file, cfg.sentry_config, cfg.authorization_policy_provider_class); 
 List<Expr> child1Conjuncts = expr.getChild(1).getConjuncts(); Preconditions.checkState(!child0Conjuncts.isEmpty() && !child1Conjuncts.isEmpty()); 
 if (child1Conjuncts.contains(conjunct)) { // The conjunct may have parenthesis but there's no need to preserve them. // Removing them makes the toSql() easier to read. 
 throw new AnalysisException(String.format("Changing the '%s' table property is " + "not supported to protect against metadata corruption.", hive_metastoreConstants.META_TABLE_STORAGE)); 
 throw new AnalysisException(String.format("Changing the '%s' table property is " + "not supported to protect against metadata corruption.", hive_metastoreConstants.META_TABLE_STORAGE)); 
<|del|> 
<|del|> 
 Expr castLiteral = literal.uncheckedCastTo(colType); Preconditions.checkNotNull(castLiteral); literal = LiteralExpr.create(castLiteral, analyzer.getQueryCtx()); 
 protected final boolean inputIsClustered_; 
 boolean overwrite, boolean ignoreDuplicates, boolean inputIsClustered) { 
<|del|> 
<|del|> 
 // Kudu client timeout (ms). private static int kuduOperationTimeoutMs_ = 3 * 60 * 1000; 
 * Retrieves a formatted representation of this table's range partitions. The 
 if (!Iterators.all(partition.getHashBuckets().iterator(), Predicates.equalTo(0))) { continue; } 
 * Checks if the specified cell is equal in both rows. 
 return a.rowAlloc[offset] == b.rowAlloc[offset]; 
 * Checks if the specified cell is in the upper row is an incremented version * of the cell in the lower row. 
<|del|> 
 // Fire the callback after collecting the error so that the error is visible should the // callback interrogate the error collector. 
 public RpcTraceObject build() { return new RpcTraceObject(rpcMethod, action, serverInfo, callStatus); 
 (statsSizeEstimate < MAX_INCREMENTAL_STATS_SIZE_BYTES); 
 public JniCatalog(byte[] thriftBackendConfig) throws InternalException, 
 public JniFrontend(byte[] thriftBackendConfig) throws ImpalaException, TException { 
 case UNIXTIME_MICROS: row.addLong(idx, buf.getLong() ^ Long.MIN_VALUE); break; 
 return a.rowAlloc[offset] == b.rowAlloc[offset]; 
<|del|> 
 * Formats the range partition into a string suitable for debug printing. 
 * @param table that this partition belongs to * @return a string containing a formatted representation of the range partition 
 boolean handleKuduException = e instanceof KuduException; if (handleKuduException) { 
 private TabletServerErrorPB makeTabletServerError() { 
 // Set to true if this column may contain null values. Can be NULL if 
 // Encoding for this column; set in analysis. 
<|del|> 
 public boolean hasKuduOptions() { 
 throw new AnalysisException("Primary key columns cannot be nullable: " + 
 throw new AnalysisException(String.format("Default value of NULL not allowed " + "non-nullable column: '%s'", getColName())); 
 throw new AnalysisException(String.format("Default value of NULL not allowed " + "non-nullable column: '%s'", getColName())); 
 if (!blockSize_.getType().isIntegerType()) { 
 ColumnDef colDef = new ColumnDef(colLabel, null); 
 private final LiteralExpr defaultValue_; 
 throw new ImpalaRuntimeException(String.format("Error parsing default value: " + "'%s'", defaultValue), e); 
 String comment = avroCol.getComment(); if (comment != null) option.put(ColumnDef.Option.COMMENT, comment); 
 ParsesOk("select a from default.`t`"); ParsesOk("select 01a from default.`01_t`"); 
 // Inits the auth_to_local configuration in the static KerberosName class. 
 * A NumericLiteral is backed by a BigDecmial which cannot represent special float values * like NaN, infinity, or negative zero. 
 * query statements. A hint consist of a name and an optional list of arguments. 
 throws Exception { 
 throws Exception { 
 /// Check whether this hint equals to a given string, ignoring case. 
 /// Check whether this hint equals to a given string, ignoring case. 
 prefix, suffix), "Could not find SORTBY hint column 'foo' in table."); 
 "SORTBY hint column list must not contain Hdfs partition column: 'year'"); 
 "SORTBY hint column list must not contain Kudu primary key column: 'id'"); 
<|del|>
 Thread.currentThread().interrupt(); 
<|del|> 
<|del|> 
 if (v == 0 && 1.0 / v == Double.NEGATIVE_INFINITY) return false; 
 private static String localLibraryPath_; 
 LOG.warn("Failed to connect to Hive MetaStore. Retrying.", e); 
 if (!hasGrouping) { mergeFragment.getPlanRoot().setDisableCodegen(true); mergeAggNode.setDisableCodegen(true); } 
 for (byte b: bytes) if (b < 0) return null; 
 * produce, so it's better to defer to a single source of truth (the BE implementation). 
<|del|> 
<|del|> 
 emptySetNode.init(analyzer); 
 * Only contains very basic tests for a few interesting cases. More thorough 
 // Describing a table. if (path_.destTable() != null) return; if (path_.destType().isComplexType()) { 
 Joiner.on('.').join(rawPath_) + "' targeting scalar type: " + 
 throw new AnalysisException("ALTER TABLE REPLACE COLUMNS is not " + 
 throw new AnalysisException("The specified column options are only supported " + "in Kudu tables: " + c.toString()); 
 return rangeDistribution.getColumnNames(); 
 columnNames.add(getColumnNameById(tableSchema, colId)); 
 columnNames.add(getColumnNameById(tableSchema, colId)); 
<|del|> 
 bytes = (byte[]) value; } else if (value instanceof ByteBuffer) { bytes = ((ByteBuffer) value).array(); 
 // Remove the default, checking that new rows default to NULL and old rows remain the same. ato = new AlterTableOptions().removeDefault("value"); submitAlterAndCheck(ato, tableName); 
 } } catch (TableLoadingException e) { // We should still try to DROP tables that failed to load, so that tables that are // in a bad state, eg. deleted externally from Kudu, can be dropped. return; 
 throw new AnalysisException("ALTER TABLE ADD PARTITION is not supported for " + 
 throw new AnalysisException("ALTER TABLE DROP PARTITION is not supported for " + 
 private void analyzeExternalKuduTableParams() throws AnalysisException { 
<|del|> 
<|del|> 
<|del|> 
 // IMPALA-4000: ALL privileges on SERVER are not required to create managed tables. AuthzOk("create table tpch.kudu_tbl (i int, j int, primary key (i))" + 
<|del|> 
 for (Expr child: expr.getChildren()) if (!child.isLiteral()) return expr; 
 private final boolean ignoreErrors_; 
 private static HashMap<String, Integer> storageIdGenerator = Maps.newHashMap(); 
<|del|> 
 if (hasPrimaryKey() || getTblProperties().containsKey(KuduTable.KEY_KEY_COLUMNS)) { 
 // We only support the ALL privilege on Kudu tables since many of the finer-grained // levels (DELETE/UPDATE) are not available. // See IMPALA-4000 for details. 
 } if (scope_ == TPrivilegeScope.COLUMN) { 
 AnalysisError(String.format( "%s SELECT ON TABLE functional_kudu.alltypessmall %s myrole", formatArgs), "Kudu tables only support the ALL privilege level."); AnalysisError(String.format( 
<|del|> 
<|del|> 
 public static final int MAX_VARCHAR_LENGTH = (1 << 16) - 1; // 65535 public static final int MAX_CHAR_LENGTH = (1 << 8) - 1; // 255 
<|del|> 
 // levels (DELETE/UPDATE) are not available. See IMPALA-4000 for details. 
 private static DiskIdMapper INSTANCE = new DiskIdMapper(); 
 private static ConcurrentHashMap<String, Integer> storageIdToInt = new ConcurrentHashMap<String, Integer>(); 
 public int getDiskId(String host, String storageUuid) { 
 Integer intId = storageIdToInt.get(storageId); if (intId != null) return intId.intValue(); 
 fd.addFileBlock(new FileBlock(loc.getOffset(), loc.getLength(), replicas)); 
<|del|> 
 perPartitionFileDescMap_.get(partition.getLocation()); 
<|del|> 
 final long scanTimestamp) { 
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; 
<|del|> 
<|del|> 
 public static DiskIdMapper INSTANCE = new DiskIdMapper(); 
 if (unknownDiskIdCount > 0) { LOG.warn("Unknown disk id count for filesystem " + fs + ":" + unknownDiskIdCount); } 
<|del|> 
 for (Path location: locations) { loadBlockMetadata(fs, location, partsByPath); } 
 * reloaded from scratch. If 'partitionsToUpdate' is not specified, file metadata of all 
 * Returns a disk id (0-based) index for storageUuid on host 'host'. Generates a * new disk ID for storageUuid if one doesn't already exist. We cache the mappings * already generated for faster lookups. * 
 if (intId != null) return intId; 
 if (intId != null) return intId; 
 if (intId != null) return intId; // No mapping exists, create a new disk ID for 'storageUuid' 
 if (!FileSystemUtil.isDescendantPath(partDir, dirPath)) continue; 
 if (!FileSystemUtil.isDescendantPath(partDir, dirPath)) continue; 
 partsByPath) throws IOException { 
 * Returns true if the filesystem supports storage UUIDs in BlockLocation calls. 
 * Returns true if Path 'p' is a descendant of Path 'parent', false otherwise. 
<|del|> 
 if (LOG.isDebugEnabled()) LOG.debug("partsByPath size: " + partsByPath.size()); 
 // sequential 0-based integer disk id used by the BE scanners. This assumes that 
 // to the corresponding latest 0-based integer ID. 
 // to the corresponding latest 0-based integer ID. 
<|del|> 
 // across the cluster, we expect to have a good hit rate. Integer intId = storageUuidToDiskId.get(storageUuid); 
 // Mapping might have been added by another thread that entered the synchronized // block first. intId = storageUuidToDiskId.get(storageUuid); 
 // First diskId of this host. 
 // Clear the current state of partitions under dirPath from perPartitionFileDescMap_ 
 // Clear the current state of partitions under dirPath from perPartitionFileDescMap_ 
<|del|> 
 // Skip if this file does not belong to any known partition. 
 if (LOG.isDebugEnabled()) { LOG.debug("File " + fileStatus.getPath().toString() + " doesn't correspond " + " to a known partition. Skipping metadata load for this file."); } 
 Map<String, FileDescriptor> fileDescMap = perPartitionFileDescMap_.get(partPathDirName); Preconditions.checkState(fileDescMap != null); fileDescMap.put(fileName, fd); // Update the partitions' metadata that this file belongs to. 
 Map<String, FileDescriptor> fileDescMap = perPartitionFileDescMap_.get(partPathDirName); Preconditions.checkState(fileDescMap != null); fileDescMap.put(fileName, fd); // Update the partitions' metadata that this file belongs to. 
 if (LOG.isWarnEnabled()) { LOG.warn("Unknown disk id count for filesystem " + fs + ":" + unknownDiskIdCount); } 
 throw new RuntimeException("Error loading block metadata for directory " 
 if (!FileSystemUtil.isValidDataFile(fileStatus)) continue; 
 // For the purpose of synthesizing block metadata, we assume that all partitions // with the same location have the same file format. 
<|del|> 
 LOG.debug("partsByPath size: " + partsByPath.size()); 
 throw new CatalogException("Error loading block location metadata for partition " + 
<|del|> 
 // in a bad state, eg. deleted externally from Kudu, can be dropped. analyzer.addAccessEvent(new TAccessEvent( tableName_.toString(), TCatalogObjectType.UNKNOWN, Privilege.DROP.toString())); 
 for (UnionOperand op: distinctOperands_) op.setQualifier(Qualifier.DISTINCT); for (UnionOperand op: allOperands_) op.setQualifier(Qualifier.ALL); 
 * a decimal ColumnType if successful. 
 * constant Expr into the following form: <SlotRef> <Op> <LiteralExpr> * If 'predicate' cannot be expressed in this way, null is returned. 
 Analyzer analyzer) { try { predicate = (BinaryPredicate) predicate.clone(); predicate.foldConstantChildren(analyzer); } catch (AnalysisException ex) { // Throws if the expression cannot be evaluated by the BE. return null; } 
 public void analyze(Analyzer analyzer, List<ColumnDef> partColDefs) 
 "Unsupported logicalType: '%s' for column '%s' with type BYTES", logicalType, colName)); 
 private static Type getDecimalType(Schema schema) { 
 comp, def, nul, block)); 
 "Unsupported non-deterministic predicate: " + predicate_.toSql())); 
 throw new NotImplementedException( "Unsupported non-deterministic predicate: " + predicate_.toSql()); 
 protected final TShowStatsOp op_; 
 * exprs. In the future, we can extend it to support arbitrary exprs without * SlotRefs. 
 Preconditions.checkState(!expr.contains(SlotRef.class)); 
<|del|> 
 if (table_.getNumClusteringCols() == 0 && op_ == TShowStatsOp.PARTITIONS) { 
<|del|> 
 * out-of-order writes to Kudu. This is because the 2 available buffers may flush * simultaneously. 
 private void analyzeSortByHint(PlanHint hint) throws AnalysisException { // HBase tables don't support insert hints at all (must be enforced by the caller). Preconditions.checkState(!(table_ instanceof HBaseTable)); 
 private final String name_; 
 sb.append(name_); if (!args_.isEmpty()) { 
 protected List<PlanHint> joinHints_ = Lists.newArrayList(); 
 } 
 } 
 Preconditions.checkNotNull(planHints); planHints_ = planHints; 
 Preconditions.checkNotNull(hints); joinHints_ = hints; 
 Preconditions.checkNotNull(hints); tableHints_ = hints; 
 if (!keyNames.add(pk.getColName().toLowerCase())) { 
 } 
<|del|>
<|del|> 
<|del|> 
 msg.is_constant = isConstant_; 
 whenExpr_ = whenExpr; thenExpr_ = thenExpr; 
 BinaryPredicate.Operator.EQ, encoded.clone(), candidate)); 
 /** * Simplifies IF by returning the corresponding child if the condition has a constant * TRUE, FALSE, or NULL (equivalent to FALSE) value. */ 
 FunctionName fnName = expr.getFnName(); // TODO: Add the other conditional functions, eg. ifnull, istrue, etc. 
 private Expr simplifyCompoundPredicate(CompoundPredicate expr) { Expr leftChild = expr.getChild(0); if (!(leftChild instanceof BoolLiteral)) return expr; 
 * per session. 
 * out-of-order writes to Kudu. This is because in this mode multiple write * operations may be sent to the server in parallel. 
 * using * {@link FlushMode#AUTO_FLUSH_BACKGROUND AUTO_FLUSH_BACKGROUND} or * {@link FlushMode#MANUAL_FLUSH MANUAL_FLUSH} mode. 
 if (fnName.getFunction().equals("if")) { Preconditions.checkState(expr.getChildren().size() == 3); 
<|del|> 
 List<CaseWhenClause> newWhenClauses = new ArrayList<CaseWhenClause>(); Expr elseExpr = null; 
 if (child instanceof NullLiteral) continue; 
 // Otherwise, this WHEN is always FALSE, so it can be removed. } else if (!(whenExpr instanceof NullLiteral)) { 
<|del|> 
<|del|> 
 // Contains all 'when' clauses with non-constant conditions, used to construct the new 
 List<CaseWhenClause> newWhenClauses = new ArrayList<CaseWhenClause>(); // Set to THEN of first constant TRUE clause, if any. 
 } else { 
 // IS NOT NULL //-------------------- 
 // IS NULL //-------------------- 
<|del|> 
 LOG.debug("load table from Hive Metastore: " + db_.getName() + "." + name_); 
<|del|> 
 // TODO: add normalization for other expr types. 
<|del|> 
 // Only queue for background loading if the isn't already queued or being loaded. 
 // | | | 
 // | | | | 
 private final ReentrantLock tableLock_ = new ReentrantLock(true); 
<|del|> 
<|del|> 
 int numTargetedPartitions = 0; int numUpdatedColumns = 0; try (MetaStoreClient msClient = catalog_.getMetaStoreClient()) { 
 Preconditions.checkState(params.getColumns() != null && params.getColumns().size() > 0, "Null or empty column list given as argument to Catalog.createTable"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 isConstant_ = isConstantImpl(); 
 * - Functions that should be always return the same value within a query but may * return different values for different queries. E.g. now(), which we want to * evaluate only once during planning. 
<|del|> 
 // Used when persisting the results of COMPUTE STATS statements. // It is also used as an upper limit for the number of partitions allowed in one ADD // PARTITION statement. 
 * 2. If a partition exists in HMS but not in catalog cache, reload partition from HMS. * Caching directives are only applied to new partitions that were absent from both the * catalog cache and the HMS. 
 * Get the log4j log level corresponding to a serialized TGetLogLevelParams. 
 return name_ + getNameSeparator() + parentFieldName; 
 FlattenedSchema dstDataset = new FlattenedSchema(srcSchema.getName()); 
 fieldSchema, field.doc(), field.defaultValue())); 
 LinkedList<Field> fields = Lists.newLinkedList(); 
 org.apache.hadoop.hive.metastore.api.Partition part) throws ImpalaException { 
 unionNode.addChild(opPlan, op.getQueryStmt().getResultExprs()); 
 // If false, no batches from child nodes would be passed through in the backend. protected boolean isInSubplan_; 
 isChildPassthrough_.add(computePassThrough( analyzer, children_.get(i).getTupleIds(), resultExprLists_.get(i))); 
 // sum the number of distinct constants with the maximum NDV for the non-constants. 
 * Tests computeNumDistinctValues() estimates for Exprs 
 public void verifyNdv(String expr, long expectedNdv) 
 public void verifyNdvStmt(String stmtStr, long expectedNdv) 
<|del|> 
 verifyNdvTwoTable("case when a.id = 1 then 'yes' " + 
 public void VerifyNdvBasic(String expr, long expectedNdv) throws AnalysisException { String stmtStr = "select " + expr + " from functional.alltypes"; VerifyNdv(stmtStr, expectedNdv); 
 public void VerifyNdv(String stmtStr, long expectedNdv) 
<|del|> 
<|del|> 
<|del|> 
 unionResultExprs_ = Expr.cloneList(other.unionResultExprs_); 
<|del|> 
 // If false, no batches from child nodes would be passed through in the backend. protected boolean isInSubplan_; 
 // Indicates for which child nodes batches can be passed through in the backend. protected List<Boolean> isChildPassthrough_ = Lists.newArrayList(); 
 super(id, tupleId.asList(), "UNION"); resultExprs_ = Lists.newArrayList(); 
 isChildPassthrough_.clear(); 
 } Preconditions.checkState(children_.size() == isChildPassthrough_.size()); 
 // Number of scan-ranges/files/partitions that have missing disk ids. Reported in the // explain plan. 
<|del|> 
<|del|> 
 // TODO: come up with estimate based on window perInstanceMemCost_ = 0; 
 * Computes the estimated per-host resource requirements of this plan node set. 
 sink.computeCosts(queryOptions); 
 // TODO: IMPALA-4862: can overestimate resource consumption of UnionNodes - the // execution of union branches is serialised within a fragment (but not across // fragment boundaries). 
 ignoreExplainHeader, errorLog, actualOutput); 
 actualOutput); 
 * @return the number of remaining partition ranges for the scan 
 * @return a bitset containing {@code false} bits for hash buckets which may be pruned 
 if (negoUnderway) { 
 for (String clientMech : PRIORITIZED_MECHS) { if (!serverMechs.contains(clientMech)) { errorsByMech.put(clientMech, "not advertised by server"); continue; } 
 Throwables.propagateIfInstanceOf(e, SaslException.class); throw Throwables.propagate(e); 
 private KuduRpc<?> parentRpc; 
<|del|> 
 "in original expr %s", toSql(), copiedInputType.toSql(), inputType.toSql(), inputAggFn.toSql())); 
<|del|> 
 for (RpcHeader.NegotiatePB.SaslMechanism mech : response.getSaslMechanismsList()) { serverMechs.add(mech.getMechanism()); 
<|del|>
 assertEquals(Negotiator.SASL_CALL_ID, msg.getHeader().getCallId()); 
 if (certs.length == 0) { throw new SSLPeerUnverifiedException("no peer cert found"); 
 // The above list is exhaustive as of JDK8's implementation of 
 * Returns true if 'exprs' reference a tuple that is made nullable in this fragment, * but not in any of its input fragments. 
 List<TupleId> tids = Lists.newArrayList(); for (Expr e: exprs) e.getIds(tids, null); 
 // TODO: check that the message type matches the expected one in all // of the below implementations. 
 public static ScalarType createClippedDecimalType(int precision, int scale) { Preconditions.checkState(precision >= 0); Preconditions.checkState(scale >= 0); 
 * preserve at least MIN_ADJUSTED_SCALE for scale (unless the desired scale was less). 
 public static final ScalarType DEFAULT_DECIMAL = 
 // Limit the message size we get from the servers as it can be quite large. @VisibleForTesting 
 // Limit the message size we get from the servers as it can be quite large. @VisibleForTesting 
<|del|> 
<|del|> 
 ArithmeticExpr.Operator op, boolean decimal_v2) throws AnalysisException { 
 * on whether DECIMAL version 1 or DECIMAL version 2 is enabled. * * TODO: IMPALA-4924: remove DECIMAL V1 code. 
 * precision. But an algorithm of reducing scale to a minimum of 6 is used. 
<|del|> 
<|del|> 
 public boolean isEquivalentLayout(SlotDescriptor other) { 
 protected final List<Expr> unionResultExprs_; 
 // Indicates if this UnionNode is inside a subplan. 
 // Indicates if batches can be passed through without evaluating and materializing exprs // for each child. 
 unionResultExprs_ = Lists.newArrayList(); 
 List<Expr> unionResultExprs, boolean isInSubplan) { 
 // Verify that the union tuple descriptor has one slot for every expression. 
 if (unionResultExprs_.size() != childTupleDescriptor.getSlots().size()) return false; 
 for (int i = 0; i < unionResultExprs_.size(); ++i) { 
 // Compute which child nodes can be passed through. 
 if (!colType.equals(kuduColType)) { 
 // Remember the THdfsFileBlocks and corresponding BlockLocations. Once all the // blocks are collected, the disk IDs will be queried in one batch per filesystem. addPerFsFileBlocks(perFsFileBlocks, fs, fd.getFileBlocks(), Arrays.asList(locations)); 
<|del|> 
 private final ReentrantLock lock = new ReentrantLock(); 
 private final ReentrantLock lock = new ReentrantLock(); 
 * Triggers the channel to be disconnected, which will asynchronously cause all * pending and in-flight RPCs to be failed. This method is idempotent. 
 * @param masterAddresses the addresses of masters to fetch from 
 hasNoClusteredHint = true; 
 analyzer.getQueryOptions().isDecimal_v2()) { // AVG() always get at least MIN_ADJUSTED_SCALE decimal places since it performs // an implicit divide. 
 if (!(m instanceof CallResponse)) { ctx.sendUpstream(evt); return; 
 computeDictionaryFilterConjuncts(analyzer); 
 * that are eligible for dictionary filtering. This populates the * dictionaryFilterConjuncts_ map. 
 } 
 } // Since the conjuncts are stored by the slot id, they are not necessarily // in the same order as the normal conjuncts. Sort the indices so that the // order matches the normal conjuncts. 
 for (Integer idx : totalIdxList) { exprList.add(conjuncts_.get(idx)); } output.append(String.format("%sdictionary filter predicates: %s\n", detailPrefix, getExplainString(exprList))); 
 /** The negotiated authentication type, set after NEGOTIATE state. */ private AuthenticationTypePB.TypeCase chosenAuthnType; 
<|del|> 
<|del|>
<|del|> 
<|del|> 
 /** whether the fake resolver has been installed */ @GuardedBy("this") 
 if (checkMissingDiskIds && block.getDiskId(i) == -1) { 
 if (checkMissingDiskIds && block.getDiskId(i) == -1) { 
<|del|> 
<|del|> 
 for (Integer idx : totalIdxList) exprList.add(conjuncts_.get(idx)); output.append(String.format("%sparquet dictionary predicates: %s\n", 
 options.setExplain_level(TExplainLevel.EXTENDED); 
<|del|> 
 // IMPALA-4902: Shallow-clone the map to avoid concurrent modifications. One thread 
 response.setTotal_thread_count(threadBean.getThreadCount()); 
 public String getDb() { return dbName_; } 
 public HdfsUri getLocation() { return location_; } 
 public TableName getTableName() { return tableName_; } 
 public boolean isStar() { return isStar_; } public String getAlias() { return alias_; } 
<|del|> 
 } loadMetadataAndDiskIds(partition); 
 } loadMetadataAndDiskIds(partition); 
<|del|> 
 if (analyzer.getQueryOptions().isSetMt_dop() && analyzer.getQueryOptions().mt_dop > 0 && 
 * columns of the target table that are mentioned in the 'sortby()' hint. 
 boolean overwrite, boolean inputIsClustered, List<Integer> sortByColumns) { Preconditions.checkNotNull(partitionKeyExprs); Preconditions.checkNotNull(referencedColumns); Preconditions.checkNotNull(sortByColumns); 
 boolean overwrite, boolean inputIsClustered, List<Integer> sortByColumns) { Preconditions.checkNotNull(partitionKeyExprs); Preconditions.checkNotNull(referencedColumns); Preconditions.checkNotNull(sortByColumns); 
 if (isExternal()) { analyzeExternalKuduTableParams(); 
 long perHostMemEstimate = Math.max(MIN_PER_HOST_MEM_ESTIMATE_BYTES, hdfsScanMemEstimate + hbaseScanMemEstimate + nonScanMemEstimate + dataSinkMemEstimate); 
 public int getNumInstancesPerHost(int mt_dop) { Preconditions.checkState(mt_dop >= 0); 
 int numInstances = getNumInstances(mt_dop); 
 // estimated per-instance memory consumed for this plan node in bytes; 
 // Minimum number of buffers required to execute an instance of this plan node. 
 // Print tuple ids, row size and cardinality. 
<|del|> 
 public void testSortExprMaterialization() { 
 // For hash and kudu partitioning: exprs used to compute hash value. 
 // For kudu, maps exprs in partitionExprs_ to their column index in the table. 
 // Should be called only by the static factory method for Kudu partitioned tables. 
<|del|> 
 public static String printNumInstances(String prefix, long numInstances) { 
 // If the computed values are valid. 
 // Returns true if timezone String is valid according to the BE timezone database, false // otherwise. public native static boolean NativeCheckIsValidTimeZone(String timezone); 
 analyzeExternalKuduTableParams(); 
<|del|> 
 } catch (AnalysisException e) { throw e; } 
<|del|> 
 catch (AnalysisException e) { LOG.error("Not able to analyze after rewrite: " + e.toString()); } Expr.removeDuplicates(conjuncts); 
Licensed to the Apache Software Foundation (ASF) under one 
<|del|> 
 // were modified and false if nothing has changed. May throw AnalysisException if // the rewriter fails to generate correct output, in which case conjuncts will be // unchanged. private static boolean propagateConstants(List<Expr> conjuncts, Analyzer analyzer) 
 Preconditions.checkNotNull(conjuncts); // When propagating constants, we may end up de-normalizing expressions, so // we must normalize binary predicates. 
 rewritten = rewriter.rewrite(rewritten, analyzer); output.set(i, rewritten); 
<|del|> 
 } if (anyChange) Collections.copy(conjuncts, output); 
 // Propogates constants, removes duplicates and optionally performs expr rewriting // Errors during rewriting will be logged but ignored and conjuncts will only have // duplicates removed. 
<|del|> 
<|del|> 
<|del|> 
 REQUIRED, COMPLETE, 
 // Index of the first non-passthrough child. 
 * children come before the children that need to be materialized. Also reorder * 'resultExprLists_'. The children are reordered to simplify the implementation in the * BE. 
 * children come before the children that need to be materialized. Also reorder * 'resultExprLists_'. The children are reordered to simplify the implementation in the * BE. 
 */ @InterfaceAudience.Public @InterfaceStability.Evolving 
 } public THdfsFileDesc toThrift() { THdfsFileDesc fd = new THdfsFileDesc(); ByteBuffer bb = fbFileDescriptor_.getByteBuffer(); fd.setFile_desc_data(bb); return fd; } 
 .add("Length", getFileLength()) .add("Compression", getFileCompression()) .add("ModificationTime", getModificationTime()) .add("Blocks", Joiner.on(", ").join(blocks)).toString(); 
 private final short hostIdx_; 
<|del|> 
 if (!sortByColumns_.isEmpty()) { 
 TablePropertyAnalyzer.analyzeSortByColumns(sortByColumns_, srcTable); 
 * expressions, unless the target is a Kudu table. 
 public static List<Integer> analyzeSortByColumns(Table table) throws AnalysisException { 
 List<String> tableCols, List<String> partitionCols, List<String> primaryKeyCols) throws AnalysisException { 
 for (String colName: sortByCols) { 
 throw new AnalysisException(String.format("SORT BY column list must not " + "contain partition column: '%s'", colName)); 
 List<String> colNames = Lists.newArrayList(); 
 List<String> colNames = Lists.newArrayList(); 
 @Test(timeout=60000) 
 AnalysisUtils.throwIfNotNull(getTblProperties().get(KuduTable.KEY_KEY_COLUMNS), String.format("PRIMARY KEY must be used instead of the table property '%s'.", KuduTable.KEY_KEY_COLUMNS)); 
 // the tuple operated on and returned by the sort node. 
<|del|> 
 * to construct a ValueRange, only the first one from each category is chosen. 
<|del|> 
<|del|> 
 TupleId tid = tblRef.getId(); conjuncts.addAll(analyzer.getBoundPredicates(tid)); 
 // Conjuncts implied false; convert to EmptySetNode EmptySetNode node = new EmptySetNode(ctx_.getNextNodeId(), tid.asList()); 
 // Conjuncts implied false; convert to EmptySetNode EmptySetNode node = new EmptySetNode(ctx_.getNextNodeId(), tid.asList()); 
 !(upperBound_ instanceof LiteralExpr) || !(lowerBound_ instanceof LiteralExpr)) { 
 public Expr rewrite(Expr expr, Analyzer analyzer) throws AnalysisException { 
 // Disallow setting sort by columns on HBase tables. Table t = getTargetTable(); if (t instanceof HBaseTable) { throw new AnalysisException("ALTER TABLE SORT BY not currently supported on " + "HBase tables."); } 
 return Lists.newArrayList(); 
 * 'partitionCols' nor in 'primaryKeyCols'. 
 for (String sortByColName: sortByCols) { 
 for (String sortByColName: sortByCols) { 
 // Determine the index of each sort by column in the list of table columns. 
 throw new AnalysisException(String.format( "Invalid time zone in the the '%s' table property: %s", HdfsTable.TBL_PROP_PARQUET_MR_WRITE_ZONE, timezone)); 
<|del|> 
 if (!children_.get(i).getType().equals(partitionKeyTypes_.get(i))) { children_.get(i).uncheckedCastTo(partitionKeyTypes_.get(i)); 
 inputFragment.setOutputPartition(partition); inputFragment.setOutputPartitionExpr(partitionExpr); 
 // Bit mask used to extract the replica host id and cache info of a file block. // Use ~REPLICA_HOST_IDX_MASK to extract the cache info (stored in MSB). private static short REPLICA_HOST_IDX_MASK = (1 << 15) - 1; 
 * given directory 'dirPath'. Only blocks corresponding to paths from 'filteredParts' * are loaded. * TODO: Split this method into more logical methods for cleaner code. 
 return ImmutableList.of(); 
 return ImmutableList.of(); 
 LinkedHashSet<Integer> colIdxs = new LinkedHashSet<Integer>(); 
<|del|> 
 if (sortByColumns_ != null && !sortByColumns_.isEmpty()) { 
 return ImmutableList.of(); 
<|del|> 
 if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } 
class ScannerExpiredException extends RecoverableException { 
 * trace 
 * @param cause the exception that caused this one to be thrown 
 LOG.debug(getPeerUuidLoggingString() + "Unexpected exception while handling RPC #" + rpcid + ", rpc=" + rpc, e); 
 builder.addHashPartitions( Lists.newArrayList(schema.getColumnByIndex(0).getName()), TABLET_COUNT); 
 AnalysisError("create external table t (x int primary key) partition by hash (x) " + "partitions 7 stored as kudu", "Creating EXTERNAL tables with column " + "definitions is not supported for Kudu tables."); 
 // Arbitrary max exprs considered for constant propagation due to O(n^2) complexity. private final static int CONST_PROPAGATION_EXPR_LIMIT = 200; 
 // Arbitrary max exprs considered for constant propagation due to O(n^2) complexity. private final static int CONST_PROPAGATION_EXPR_LIMIT = 200; 
 * Fault-tolerant scans typically have lower throughput than non * fault-tolerant scans. Fault tolerant scans use READ_AT_SNAPSHOT read mode. * If no snapshot timestamp is provided, the server will pick one. 
<|del|> 
 } 
 client.closeScanner(this).addCallback(closedCallback()); // TODO errBack ? 
 * Tests fault tolerant scanner by killing the tablet server while scanning and 
 * Tests fault tolerant scanner by restarting the tablet server while scanning and 
 private final List<Boolean> nullsFirstParams_; // Subset of ordering exprs that are materialized. Populated in // createMaterializedOrderExprs(), used for EXPLAIN output. private List<Expr> materializedOrderingExprs_; 
 private final List<Boolean> nullsFirstParams_; // Subset of ordering exprs that are materialized. Populated in // createMaterializedOrderExprs(), used for EXPLAIN output. private List<Expr> materializedOrderingExprs_; 
 // The descriptor for the tuples on which the sort operates. 
 // ones that point to the slot refs into the sort's output tuple. 
 computeMemLayout(analyzer); 
 // threads. Corresponds to the default value of --num_threads_per_core in the backend. 
 long numPartitionsPerInstance = 
<|del|> 
 long minReservationBytes = 0L; 
 Preconditions.checkState(nodeProfile.getMemEstimateBytes() >= 0); long memEstimate = instancesPerHost * nodeProfile.getMemEstimateBytes(); 
 Preconditions.checkState(sinkProfile.getMemEstimateBytes() >= 0); dataSinkMemEstimate += instancesPerHost * sinkProfile.getMemEstimateBytes(); 
 * Estimates the number of distinct values of exprs per fragment instance based on the 
 long perHostMinReservation = -1; 
 private final long memEstimateBytes_; 
 long perInstanceMinReservation = 3 * SPILLABLE_BUFFER_BYTES; 
// under the License. 
 "Invalid time zone in the '%s' table property: %s", 
 // substituting the materialized ordering exprs. 
 private static int[] createBlockMetadata(FlatBufferBuilder fbb, 
 private final boolean hasCachedReplica_; 
 private static short[] createDiskIds(BlockLocation location, FileDescStats stats) { 
 return new short[0]; 
 short[] diskIDs = new short[storageIds.length]; 
<|del|> 
 * Finalize plan tree and create stream sink, if needed. * Computes resource profiles for all nodes and sinks in this fragment. 
 * Compute resources consumed when executing this PlanNode, initializing * 'resource_profile_'. May only be called after this PlanNode has been placed in a 
 if (!tblProperties.containsKey( AlterTableSortByColumnsStmt.TBL_PROP_SORT_BY_COLUMNS)) { 
 // ALTER TABLE SET is not supported on HBase tables altogether. Preconditions.checkState(!(table instanceof HBaseTable)); 
<|del|> 
 public static List<Integer> analyzeSortByColumns(List<String> sortByCols, 
 Joiner.on(", \n ").join(sortColsSql))); 
 * the caller must make sure that the value matches any columns he/she added to the 
 String oldColumns = msTbl.getParameters().get(sortByKey); String alteredColumns = MetaStoreUtil.intersectCsvListWithColumNames(oldColumns, columns); msTbl.getParameters().put(sortByKey, alteredColumns); 
 String oldColumns = msTbl.getParameters().get(sortByKey); String alteredColumns = MetaStoreUtil.replaceValueInCsvList(oldColumns, colName, newCol.getColumnName()); msTbl.getParameters().put(sortByKey, alteredColumns); 
 String oldColumns = msTbl.getParameters().get(sortByKey); String alteredColumns = MetaStoreUtil.removeValueFromCsvList(oldColumns, colName); msTbl.getParameters().put(sortByKey, alteredColumns); 
<|del|> 
<|del|> 
 // for hash partition: exprs used to compute hash value 
 public DataStreamSink(ExchangeNode exchNode, DataPartition partition) { 
public class PlanFragment extends TreeNode<PlanFragment> { private final static Logger LOG = LoggerFactory.getLogger(PlanFragment.class); 
<|del|> 
<|del|> 
 * a given row. Returns -1 for rows that do not correspond to a partition. The children of * this Expr produce the values for the partition columns. 
 rowCount += rri.getNumRows(); 
 rowCount += rri.getNumRows(); 
<|del|> 
<|del|> 
 } 
<|del|> 
 return TableSink.create(table_, isUpsert_ ? TableSink.Op.UPSERT : TableSink.Op.INSERT, partitionKeyExprs_, ImmutableList.<Integer>of(), overwrite_, ignoreDuplicates_); 
 // produces the value for column partitionColPos_[i]. private List<Integer> partitionColPos_; 
 // produces the value for column partitionColPos_[i]. private List<Integer> partitionColPos_; 
 public static DataPartition kuduPartitioned( List<Expr> exprs, List<Integer> partitionIdxs, int tableId) { return new DataPartition(TPartitionType.KUDU, exprs, partitionIdxs, tableId); 
 * a given row. Returns -1 for rows that do not correspond to a partition. The children of * this Expr produce the values for the partition columns. 
 if (i != 0) sb.append(", "); 
 /** * Job parameter that specifies if the scanner should be fault tolerant * or not (default: false). 
 * @param isFaultTolerant whether the job should use fault tolerant scanners 
 /** * Returns the last timestamp received from a server. Used for CLIENT_PROPAGATED * external consistency. * * @return a long indicating the last timestamp received from a server */ 
 return INSTANCE; 
 intId = storageIdToInt.get(storageId); if (intId != null) return intId.intValue(); 
 public byte toFb() { 
 public static FileDescriptor createWithSynthesizedBlockMd(FileStatus fileStatus, 
 FileStatus fileStatus, int[] fbFileBlockOffets) { 
 fbFileBlockOffets.add(FileBlock.createFbFileBlock(fbb, start, len, (short) hostIndex.getIndex(REMOTE_NETWORK_ADDRESS))); 
 public HdfsCompression getFileCompression() { return HdfsCompression.valueOf(FbCompression.name(fbFileDescriptor_.compression())); 
 public FbFileBlock getFbFileBlock(int idx) { return fbFileDescriptor_.fileBlocks(idx); 
 * table type. If it is null, then this check is omitted. 
 // ALTER TABLE SET is not supported on HBase tables at all, see // AlterTableSetStmt::analyze(). 
 Map<String, String> properties = Maps.newHashMap(); 
 * must be an HDFS table. If there are errors during the analysis, this will throw an 
 ListMap<TNetworkAddress> hostIndex, Reference<Long> numUnknownDiskIds) 
 * Static utility methods to serialize and access file block metadata from FlatBuffers. 
 * Constructs an FbFileBlock object from the block location metadata * 'loc'. Serializes the file block metadata into a FlatBuffer using 'fbb' and 
 ListMap<TNetworkAddress> hostIndex, Reference<Long> numUnknownDiskIds) 
 // True if this scan node should use codegen for evaluting conjuncts. private boolean codegenConjuncts_; 
<|del|> 
 assignedConjuncts_ = analyzer.getAssignedConjuncts(); // Decide whether codegen should be used for evaluating conjuncts. checkForCodegen(analyzer); 
 assignedConjuncts_ = analyzer.getAssignedConjuncts(); // Decide whether codegen should be used for evaluating conjuncts. checkForCodegen(analyzer); 
 assignedConjuncts_ = analyzer.getAssignedConjuncts(); // Decide whether codegen should be used for evaluating conjuncts. checkForCodegen(analyzer); 
<|del|> 
 inputFragment.setOutputPartition(partition); inputFragment.setOutputPartitionExpr(partitionExpr); 
 sortColumns_ = Lists.newArrayList(sortColumns_); 
 String sortByKey = AlterTableSortByStmt.TBL_PROP_SORT_COLUMNS; 
 private static List<String> getSortColumns(Map<String, String> properties) { final String sortByKey = AlterTableSortByStmt.TBL_PROP_SORT_COLUMNS; 
 addTestTable("create table test_sort_by.t (id int, int_col int, " + 
 pb.setLowerBound(UnsafeByteOperations.unsafeWrap(this.lowerBound)); 
<|del|> 
 "contain partition column: '%s'", sortColName)); 
 analyzeSortColumns(sortCols, Column.toColumnNames(table.getNonClusteringColumns()), 
 private final boolean upperBoundType_; 
 lowerBoundType_ = lowerBoundType; 
 result.setCatalog_version(catalogVersion_); 
 return AnalyzeAccessEvents(stmt, Catalog.DEFAULT_DB); 
<|del|> 
 private final ReentrantLock tableLock_ = new ReentrantLock(true); 
 if (!(this instanceof BaseTableRef) || !(resolvedPath_.destTable() instanceof HdfsTable)) { 
 // True if this scan node should use codegen for evaluting conjuncts. private boolean codegenConjuncts_; 
 if (randomSeed_ != null) builder.append(" REPEATABLE(" + randomSeed_ + ")"); 
 fileDescriptor.getFileName(), errorMsg)) { 
 @VisibleForTesting 
<|del|> 
<|del|> 
 loadDiskIds(blocksToLoad); 
 removeFunction(catalogObject.getFn(), catalogObject.getCatalog_version()); 
 * Remove all functions. 
 // comments[i][j] is the comment of tableNames[j] in dbs[i]. 
 // Updated during analysis. Null if invalidating the entire catalog or refreshing // database functions. 
<|del|> 
<|del|> 
 // into tmpDb. db.addFunction(fn); addedFuncs.add(fn.toTCatalogObject()); 
<|del|> 
 return !(fs instanceof S3AFileSystem || fs instanceof LocalFileSystem || fs instanceof AdlFileSystem); 
<|del|> 
 protected static long minSpillableBufferBytes_ = DEFAULT_SPILLABLE_BUFFER_BYTES; 
 bufferSize = Math.min(bufferSize, Math.max( RuntimeEnv.INSTANCE.getMinSpillableBufferBytes(), 
 return new Role(thriftRole); 
 * case when false then 0 when true then 1 end -> 1 * coalesce(1, 0) -> 1 
 private Expr simplifyIfFunctionCallExpr(FunctionCallExpr expr) { 
 private Expr simplifyCoalesceFunctionCallExpr(FunctionCallExpr expr) { int numChildren = expr.getChildren().size(); Expr result = NullLiteral.create(expr.getType()); for (int i = 0; i < numChildren; ++i) { 
 // Skip leading nulls. if (childExpr.isNullLiteral()) continue; if ((i == numChildren - 1) || canSimplifyCoalesceUsingChild(childExpr)) { result = childExpr; } else if (i == 0) { result = expr; 
 // Return true if this partition column do not has NULL value. 
 sb.append(type_.toSql()); 
 sb.append(typeDef_.toSql()); 
 setMaterializedTupleInfo(sortTupleDesc, sortTupleExprs); return substOrderBy; 
 loadPartitionFileMetadata(sd, partition, fileFormatDescriptor.getFileFormat(), perFsFileBlocks); 
<|del|> 
 Preconditions.checkState(mergeAggInfo_ == null); 
 if (getMaterializedAggregateExprs().size() != 1) return false; if (isDistinctAgg()) return false; 
 protected boolean isAnalyzed_; // true after analyze() has been called 
 // First process all updates 
 // These include both table-level and column-level privilege requests. We use a // LinkedHashMap to preserve the order in which requests are inserted. 
<|del|> 
 * Coalesce disjunctive equality predicates to an IN predicate, and * merges the compatible equality or IN predicate into existing IN predicate. 
 Expr orChildExpr = rewriteEqEqPredicate(expr.getChild(0), expr.getChild(1)); 
 if (inPred.isNotIn()) return null; 
 * Takes in two predicates of type 'Expr = literal' and returns the rewritten IN predicate. * returns null if the two predicates are not compatible 
 if (!Expr.IS_EXPR_EQ_LITERAL_PREDICATE.apply(child0)) return null; if (!Expr.IS_EXPR_EQ_LITERAL_PREDICATE.apply(child1)) return null; 
 * Coalesces disjunctive equality predicates to an IN predicate, and merges compatible * equality or IN predicates into an existing IN predicate. 
 } else if (otherPred instanceof InPredicate && !((InPredicate) otherPred).isNotIn()) { 
 * Coalesce disjunctive equality predicates to an IN predicate, * merges compatible equality or IN predicates into an existing IN predicate. 
<|del|> 
 if (inPred == null || inPred.isNotIn()) return null; 
 List<Expr> newInList = Lists.newArrayList( 
 if (!Expr.IS_EXPR_EQ_LITERAL_PREDICATE.apply(child0)) return null; if (!Expr.IS_EXPR_EQ_LITERAL_PREDICATE.apply(child1)) return null; 
 * Normalizes binary predicates of the form <constant> <op> <slot> so that the slot is * on the left hand side. 
 * Normalizes binary predicates of the form <constant> <op> <slot> so that the slot is * on the left hand side. 
<|del|> 
 // No need to call super.channelClosed(ctx, e) -- there should be nobody in the upstream // pipeline after Connection itself. So, just handle the disconnection event ourselves. 
<|del|> 
 if (state == State.DISCONNECTED) { // The caller should retry with other connection. new RecoverableException(Status.IllegalState("disconnected: cannot enqueue a message")); } if (state == State.NEW) { // Schedule connecting to the server. 
 * Container class used as a response when retrieving pending row errors. 
 // Distribution schemes of this Kudu table. Both rang and hash-based distributions are 
 public void verifySel(String predicate, double expectedSel) throws AnalysisException { String stmtStr = "select " + predicate + " from functional.alltypes"; verifySelectivityStmt(stmtStr, expectedSel); } 
 public void verifySel(String predicate, double expectedSel) throws AnalysisException { String stmtStr = "select " + predicate + " from functional.alltypes"; verifySelectivityStmt(stmtStr, expectedSel); } 
 } } 
 } else { 
 if (this.lastPropagatedTimestamp == NO_TIMESTAMP || this.lastPropagatedTimestamp < lastPropagatedTimestamp) { 
 params.setAlter_type(TAlterTableType.ALTER_COLUMN); TAlterTableAlterColParams colParams = new TAlterTableAlterColParams(); 
<|del|> 
 LinkedHashMap<String, List<PrivilegeRequest>> tablePrivReqs = Maps.newLinkedHashMap(); 
 public LinkedHashMap toJson() { LinkedHashMap obj = new LinkedHashMap(); 
 for (String target: ImmutableSortedSet.copyOf(targets)) { 
 LinkedHashMap<String, String> properties = 
 LinkedHashMap<String, String> properties = Maps.newLinkedHashMap(msTable.getParameters()); 
 // Since RPCs to the masters also go through RpcProxy, we need to treat them as if they were a // normal table. We'll use the following fake table name to identify places where we need special 
 * This handler manages the RPC IDs, and keeps track of the RPCs in flights for which * a response is currently awaited, as well as temporarily buffered RPCs that are waiting 
 * This handler manages the RPC IDs, and keeps track of the RPCs in flights for which * a response is currently awaited, as well as temporarily buffered RPCs that are waiting 
 * channel isn't connected. * TODO(aserbin) clarify on on the socketReadTimeoutMs and using per-RPC timeout settings. 
<|del|> 
 final String message = getPeerUuidLoggingString() + "server sent error " + error.getMessage(); 
 List<QueuedMessage> queued; Map<Integer, Callback<Void, CallResponseInfo>> inflight; 
 List<QueuedMessage> queued; Map<Integer, Callback<Void, CallResponseInfo>> inflight; 
<|del|> 
 * The ConnectionCache is responsible for managing connections to Kudu masters and tablet servers. 
 public void computeResourceConsumption(TQueryOptions queryOptions) { 
 rootFragment.setSink(ctx_.getAnalysisResult().getDeleteStmt().createDataSink()); } else if (ctx_.isQuery()) { rootFragment.setSink(ctx_.getAnalysisResult().getQueryStmt().createDataSink()); 
 rootFragment.setSink(ctx_.getAnalysisResult().getDeleteStmt().createDataSink()); } else if (ctx_.isQuery()) { rootFragment.setSink(ctx_.getAnalysisResult().getQueryStmt().createDataSink()); 
 // True if we should abort because we don't have valid estimates 
 || (missingStats && !(scan.hasLimit() && scan.getConjuncts().isEmpty()))) { 
 maxRowsProcessedPerNode_ = Math.max(maxRowsProcessedPerNode_, (long)Math.ceil(numRows / (double)numNodes)); 
 maxRowsProcessedPerNode_ = Math.max(maxRowsProcessedPerNode_, (long)Math.ceil(numRows / (double)numNodes)); 
 public boolean foundJoinNode() { Preconditions.checkState(valid_); 
 public static SortNode createTotalSortNode( PlanNodeId id, PlanNode input, SortInfo info, long offset) { return new SortNode(id, input, info, offset, TSortType.TOTAL); 
 return this.id_.equals(vertex.id_); 
 private List<Vertex> getOrderedSources() { List<Vertex> result = Lists.newArrayList(sources_); Collections.sort(result); return result; 
 false); 
 * @return true iff the connection is in the READY state 
 * {@link Connection} objects. 
<|del|> 
 * @param client top-level Kudu client object * @param connection the connection associated with the target Kudu server 
 /** * TODO(aserbin): the re-acquirer should be able to mark all the queued messages as failed * if after some number or retries it cannot get new authn token. */ 
<|del|> 
 // Inject additional INVALID_AUTHENTICATION_TOKEN responses from both the master and tablet // servers, even for not-yet-expired tokens. 
 for (Connection c : client.getConnectionListCopy()) { 
 // Here, instead of calling super.setUpBeforeClass(), there is some modifided code from it // because we want to have a cluster with single master. 
 return MoreObjects.toStringHelper(this) 
 LOG.warn("Got per errors for {} rows, the first one being {}", rowErrorsCount, errors.get(0).getErrorStatus()); 
 .add("a", a) .add("b", b) .add("c", c) .toString(); 
 formatArgs)); AnalyzesOk(String.format("%s ALL ON TABLE functional_kudu.alltypes %s myrole", formatArgs)); 
 * The resources that will be consumed by some part of a plan, e.g. a plan node or * plan fragment. 
<|del|> 
import org.apache.kudu.client.shaded.com.google.common.base.Preconditions; 
 * Get a proxy to send RPC calls to the specified server. 
 return delayedSendRpcToTablet(nextRequest, new RecoverableException(Status.RemoteError( String.format("No information on servers hosting tablet %s, will retry later", tablet.getTabletId())))); 
 final RpcProxy masterProxy, 
 * It's a stateful handler that manages a connection to a Kudu server. 
 private final ServerInfo serverInfo; 
 private static final byte RPC_CURRENT_VERSION = 9; 
 Set<RpcFeatureFlag> features = null; lock.lock(); try { if (negotiationResult != null) { features = negotiationResult.serverFeatures; } } finally { lock.unlock(); 
 /** Read timeout for connections (used by Netty's ReadTimeoutHandler) */ 
 * RPCs. 
 */ @VisibleForTesting 
 int attempt; // package-private for RpcProxy and AsyncKuduClient only. 
 * Injecting failures (i.e. drop client connection) while scanning, to verify: 
<|del|> 
<|del|> 
 // Give plenty of time for threads to stop. thread.join(DEFAULT_SLEEP); 
 * The given 'aggInfo' is used for detecting and applying optimizations that span both * the scan and aggregation. 
 * The given 'aggInfo' is used for detecting and applying optimizations that span both * the scan and aggregation. Only applicable to HDFS table refs. 
 * The given 'aggInfo' is used for detecting and applying optimizations that span both * the scan and aggregation. Only applicable to HDFS table refs. 
 * Create a table on the cluster with the specified name, schema, and table configurations. * If the primary key columns of the table schema aren't specified first, the deferred result * will be a {@link NonRecoverableException} * 
 // Calling Channels.close() triggers the cleanup() which will handle the negotiation // failure appropriately. Channels.close(evt.getChannel()); 
 return Channels.disconnect(channel); 
 /** The object has just been created. */ 
 public Connection getConnection(final ServerInfo serverInfo, Connection.CredentialsPolicy credentialsPolicy) { 
 LOG.debug("peer {} sent connection negotiation error: {}", chan.getRemoteAddress(), error.getMessage()); 
 /** The RPC error received from the server. */ 
<|del|> 
 } catch (Throwable e) { //noinspection ThrowableResultOfMethodCallIgnored exceptions.put(threadIdx, e); 
<|del|> 
 // simultaneously when mt_dop = 0 because of the async build thread. 
<|del|> 
<|del|> 
 long perHostMemEstimate = -1; long perHostMinReservationBytes = -1; // Compute pipelined plan node sets. ArrayList<PipelinedPlanNodeSet> planNodeSets = PipelinedPlanNodeSet.computePlanNodeSets(fragments.get(0).getPlanRoot()); 
 // The union executes concurrently with Open() and GetNext() on each of it's // children. 
 // tableTypes[i] are the type of tables within dbs[i] public List<List<String>> tableTypes = Lists.newArrayList(); // comments[i][j] is the comment of tableNames[j] in dbs[i]. 
 // tableTypes[i] are the type of tables within dbs[i] public List<List<String>> tableTypes = Lists.newArrayList(); // comments[i][j] is the comment of tableNames[j] in dbs[i]. 
 thrown.set(t); 
 assertTrue(pool.awaitTermination(10, TimeUnit.SECONDS)); 
 Preconditions.checkState(perHostPeakResources.getMemEstimateBytes() >= 0, perHostPeakResources.getMemEstimateBytes()); Preconditions.checkState(perHostPeakResources.getMinReservationBytes() >= 0, perHostPeakResources.getMinReservationBytes()); 
 // Memory limit for partial sorts, specified in bytes. TODO: run experiments to // determine the value for this, consider making it configurable, enforce it in the BE. private final long PARTIAL_SORT_MEM_LIMIT = 128 * 1024 * 1024; 
 * Computes the per-host resource profile for the given plans, i.e. the peak resources * consumed by all fragment instances belonging to the query per host. Sets the * per-host resource values in 'request'. 
 // Total of initial reservation claims in bytes by all operators in all fragment // instances per host. Computed by summing the per-host minimum reservations of // all plan nodes and sinks. 
 * @return the proxy object bound to the target server 
<|del|> 
 * Callback upon 'successful' completion of an attempt to acquire a new token, * i.e. an attempt where no exception detected in the code path. 
 * @param tokenAcquired {@code true} if a new token acquired, {@code false} if * the ConnectToCluster yielded no authn token. 
 * token might be null, so in that case primary credentials will be used for future * connection negotiations. 
 * re-acquisition failed after some number of retries (currently, it's 5 attempts). * * TODO(aserbin): perhaps we should retry indefinitely with increasing backoff, but aggressively * timeout RPCs in the queue after each failure. 
<|del|> 
<|del|> 
<|del|> 
 * @return the helper object bound to the target server 
 return MASTER_TABLE_NAME_PLACEHOLDER == tableId; 
 public static final class AffectedRpcInfo { 
 affectedRpcInfoList.add(new AffectedRpcInfo(rpc, ex)); 
 final class NewAuthnTokenCB implements Callback<Void, Boolean> { 
 public Void call(Boolean unused) throws Exception { 
 /** * Handle the affected RPCs on the completion of authn token re-acquisition. The result authn * token might be null, so in that case Kerberos credentials will be used to negotiate future * connections. */ 
 if (e instanceof RecoverableException && attempts < MAX_ATTEMPTS) { client.reconnectToCluster(cb, this); ++attempts; 
<|del|> 
 defaultAdminOperationTimeoutMs, Connection.CredentialsPolicy.ANY_CREDENTIALS).addCallback( 
 /** A dedicated synchronization object for #queuedRpcs */ private final Object queuedRpcsLock = new Object(); 
 @GuardedBy("queuedRpcsLock") private ArrayList<KuduRpc<?>> queuedRpcs = Lists.newArrayList(); 
 synchronized (queuedRpcsLock) { rpcList = queuedRpcs; queuedRpcs = Lists.newArrayList(); 
 synchronized (queuedRpcsLock) { rpcList = queuedRpcs; queuedRpcs = Lists.newArrayList(); 
<|del|> 
 void retryQueuedRpcs() { List<KuduRpc<?>> list = swapQueuedRpcs(); 
 void failQueuedRpcs() { List<KuduRpc<?>> rpcList = swapQueuedRpcs(); 
 // URIs are case sensitive 
 toLowerCase())); 
<|del|> 
<|del|> 
 // The valid range is [minReservationBytes_, Long.MAX_VALUE]. 
 // Memory limit for partial sorts, specified in bytes. TODO: determine the value for // this, consider making it configurable, enforce it in the BE. (IMPALA-5669) 
 // (IMPALA-2695) URIs are case sensitive 
 * Map-only job that reads Kudu rows and writes them into a CSV file. 
 * @param conf the current configuration * @param args the command line parameters * @return the newly created job * @throws java.io.IOException when setting up the job fails 
 "Exports the given table and columns into the specified output path.\n" + "The column names of the Kudu table must be specified in the form of \n" + 
 "Exports the given table and columns into the specified output path.\n" + "The column names of the Kudu table must be specified in the form of \n" + 
 "Exports the given table and columns into the specified output path.\n" + "The column names of the Kudu table must be specified in the form of \n" + 
<|del|> 
 this.separator = conf.get(ExportCsv.SEPARATOR_CONF_KEY, ExportCsv.DEFAULT_SEPARATOR); 
 * Converts Kudu RowResult into a line of CSV text. 
 * converts RowResult to string. 
 break; case UNIXTIME_MICROS: buf.append(value.getLong(i)); break; 
<|del|> 
 * @param conf the current configuration * @param args the command line parameters * @return the newly created job * @throws java.io.IOException when setting up the job fails 
<|del|> 
 "Imports the given input directory of Apache Parquet data into the specified table.\n" + 
 * Mapper that ingests Apache Parquet lines and turns them into Kudu Inserts. 
<|del|> 
<|del|> 
 for (int i = 0; i < 3; i++) { 
 for (int i = 0; i < 3; i++) { 
 assertEquals(6, countRowsInScan(scanner)); 
<|del|> 
 HashSet<HdfsPartition> targetPartitions = Sets.newHashSet(partitionSet_.getPartitions()); 
 // Make sure that the user is allowed to modify the target table. Use ALL because no // UPDATE / DELETE privilege exists yet (IMPALA-3840). 
 // Make sure that the user is allowed to modify the target table. Use ALL because no // UPDATE / DELETE privilege exists yet (IMPALA-3840). 
 } 
 * rows, and finally restarts the tablet server it killed. Verifying with a read as it goes. 
 final int ROWS_PER_ITERATION = 3; 
 final int TOTAL_ROWS_TO_INSERT = ROWS_PER_ITERATION + OUTER_LOOP * ROWS_PER_ITERATION; 
 waitUntilRowCount(table, ROWS_PER_ITERATION, 30000); 
<|del|> 
 Function fn = getFnCall().getFn(); if (getFnCall().getParams().isIgnoreNulls() && !isFirstOrLastValueFn(fn)) { throw new AnalysisException("Function " + fn.functionName().toUpperCase() 
 if (!isFirstOrLastValueFn(fn) && orderByElements_.isEmpty()) { 
 return isAnalyticFn(fn, LAST_VALUE) || isAnalyticFn(fn, FIRST_VALUE) || isAnalyticFn(fn, LAST_VALUE_IGNORE_NULLS) || isAnalyticFn(fn, FIRST_VALUE_IGNORE_NULLS); 
 private void waitUntilRowCount(final KuduTable table, final int rowCount, long timeoutMs) 
 final int NUM_ITERATIONS = 10; final int TOTAL_ROWS_TO_INSERT = ROWS_PER_ITERATION + NUM_ITERATIONS * ROWS_PER_ITERATION; 
 waitUntilRowCount(table, ROWS_PER_ITERATION, DEFAULT_SLEEP); 
 waitUntilRowCount(table, currentRows, DEFAULT_SLEEP); 
 waitUntilRowCount(table, currentRows, DEFAULT_SLEEP); 
 waitUntilRowCount(table, TOTAL_ROWS_TO_INSERT, DEFAULT_SLEEP); 
 // up. 
 // up. 
<|del|> 
 // Kudu doesn't support Parquet's TIMESTAMP. 
// under the License. 
 // create a table with on empty tablet and 3 tablets of 3 rows each. 
// under the License. 
 client.newScannerBuilder(openTable).build())); assertEquals("INT32 key=1, INT32 column1_i=3, DOUBLE column2_d=2.3, STRING column3_s=some string, " + "BOOL column4_b=true",scanTableToStrings(openTable).get(0)); 
 TRuntimeFilterMode runtimeFilterMode = ctx.getQueryOptions().getRuntime_filter_mode(); 
 for (SlotId sid : sids) { 
<|del|> 
<|del|> 
 public boolean hasPushedConjuncts() { 
 public boolean hasPushedConjuncts() { 
<|del|> 
 getTypeName(columnSchema.getType()) + " does not exist in Parquet schema"); 
 getTypeName(columnSchema.getType()) + " does not exist in Parquet schema"); 
 if (success) break; Thread.sleep(50); // Sleep for 50ms } while (System.nanoTime() < deadlineNanos); 
 super(id, msTbl, db, name, owner); 
 void analyze(Analyzer analyzer) throws AnalysisException { if (isAnalyzed_) return; 
 List<Boolean> isAscOrder = Collections.nCopies(orderingExprs.size(), true); 
 // Two of the buffers need to be buffers large enough to hold the maximum-sized row // to serve as input and output buffers while repartitioning. 
 // Two of the buffers need to be buffers large enough to hold the maximum-sized row // to serve as input and output buffers while repartitioning. 
 final String TABLE_NAME = TestClientFailoverSupport.class.getName(); 
 final String TABLE_NAME = TestClientFailoverSupport.class.getName(); 
 createTable(TABLE_NAME, basicSchema, getBasicCreateTableOptions()); KuduTable table = openTable(TABLE_NAME); 
 waitUntilRowCount(table, 2*TOTAL_ROWS_TO_INSERT, DEFAULT_SLEEP); syncClient.deleteTable(TABLE_NAME); assertFalse(syncClient.tableExists(TABLE_NAME)); 
 return hostname; 
<|del|> 
 if (forwardResolutions.containsKey(host)) { return new InetAddress[]{forwardResolutions.get(host)}; 
 ChannelFuture disconnect() { Preconditions.checkNotNull(channel); 
 (missingStats && !(scan.hasLimit() && !scan.hasEffectiveScanConjuncts()))) { 
<|del|> 
 private static void canRewriteCorrelatedSubquery(Expr expr, List<Expr> correlatedPredicates) throws AnalysisException { 
 canRewriteCorrelatedSubquery(expr); // For correlated subqueries, a LIMIT clause has no effect on the results, so we can 
 "where t.int_struct_col.f1 < v.id)", cmpOp, aggFn), 
<|del|> 
 return "DATA_SOURCE:" + catalogObject.getData_source().getName().toLowerCase(); default: throw new IllegalStateException( "Unsupported catalog object type: " + catalogObject.getType()); 
 String serviceName() { return TABLET_SERVER_SERVICE_NAME; } 
 return "ScanRequest(scannerId=" + Bytes.pretty(scannerId) + (tablet != null ? ", tabletSlice=" + tablet.getTabletId() : "") + ", attempt=" + attempt + ", " + super.toString() + ")"; 
 return "ScanRequest(scannerId=" + Bytes.pretty(scannerId) + (tablet != null ? ", tabletSlice=" + tablet.getTabletId() : "") + ", attempt=" + attempt + ", " + super.toString() + ")"; 
 return "ScanRequest(scannerId=" + Bytes.pretty(scannerId) + (tablet != null ? ", tabletSlice=" + tablet.getTabletId() : "") + ", attempt=" + attempt + ", " + super.toString() + ")"; 
 * Returns true if this node has conjuncts to be evaluated by Impala against the scan * tuple. 
 * Returns true if this node has conjuncts to be evaluated by the underlying storage * engine. 
 } else if (dummyTable instanceof KuduTable) { 
 } else if (dummyTable instanceof KuduTable) { 
 public synchronized void install() { 
 // SIngle TRUE case with no preceding non-constant case. 
 whenExpr = child; 
 public synchronized void addForwardResolution(String hostname, InetAddress ip) { forwardResolutions.put(hostname, ip); } public synchronized void addReverseResolution(InetAddress ip, String hostname) { reverseResolutions.put(ip, hostname); } 
 final String msg = getLogPrefix() + " invalid callID: " + callId; 
 final String message = getLogPrefix() + " server sent error " + error.getMessage(); 
 final String message = getLogPrefix() + " server sent error " + error.getMessage(); 
 // SIngle TRUE case with no preceding non-constant case. 
 public final boolean isBoundByPartitionColumns; // Indicates if 'node' is in the same fragment as the join that produces the filter public final boolean isLocalTarget; 
<|del|> 
 if (!(scanNode instanceof HdfsScanNode)) return; TupleId tid = scanNode.getTupleIds().get(0); if (!runtimeFiltersByTid_.containsKey(tid)) return; 
 public static String toCatalogObjectKey(TCatalogObject catalogObject) throws IllegalStateException { 
 RewritesOk(f + "(null, null)", rule, "NULL"); 
 Path createServiceKeytab(String spn) throws IOException { 
<|del|> 
<|del|> 
 * Simplifies compound predicates with at least one BoolLiteral child according to the * following rules: 
<|del|> 
 } 
 if (caseExpr.isLiteral() && expr.getChild(i).isLiteral()) { 
 whenExpr = expr.getChild(i); 
public final class NativeByteArrayOutputStream extends OutputStream { 
public final class NativeByteArrayOutputStream extends OutputStream { 
 private static final long BUFFER_DOUBLING_RESIZE_LIMIT = 1 * 1024 * 1024 * 1024; // 1GB 
 // Limit on the size to which the underlying buffer can grow private static final long BUFFER_MAX_SIZE = 4 * 1024 * 1024 * 1024; // 4GB // Pointer and length (in bytes) of the underlying native buffer. 
<|del|> 
 while (newBufferSize < bytesWritten_ + len) { newBufferSize <<= 1; } 
 * native byte array using NativeByteArrayOutputStream class. Not thread-safe. 
<|del|> 
 return "[Peer " + serverInfo.getUuid() + "] "; 
<|del|> 
 * implements a single write() because that is used by the thrift * seriliazation code. The write() method automatically resizes the * underlying buffer if the data to be written exceeds the current 
 throw e; 
 * BUFFER_DOUBLING_RESIZE_LIMIT and then expand it with increments of * BUFFER_RESIZE_INCREMENTS; 
 // Limit on the size to which the underlying buffer can grow. This limit is chosen // since thrift uses uint32_t for representing the buffer size internally, thus capping // the message size to a little over 4 gigabytes (uint32_max). 
 * Write a byte array 'b' of length 'len at offset 'offset'. Resizes the buffer 
 } else { 
 public synchronized void reset() {} 
<|del|> 
 evalCost_ = getChildCosts() + BINARY_PREDICATE_COST * (children_.size() - 1); 
 if (!getChild(0).hasCost()) return UNKNOWN_COST; return getChild(0).getCost() + IS_NOT_EMPTY_COST; 
 "Failed to allocate/re-allocate memory using Unsafe"; 
 public NativeByteArrayOutputStream() { tryAllocate(BUFFER_INITIAL_SIZE_DEFAULT); 
 * call fails. We always call Unsafe.reAllocateMemory() since that falls back to * allocateMemory() if bufferPtr_ is 0. Updates bufferLen_ if the allocation is * successful. 
 throw new IllegalArgumentException(BUFFER_LIMIT_EXCEEDED_MSG + ": " + len); 
/** * Tests the implementation of TNativeSerializer and the resizing behavior * of underlying TNativeByteBuffer implementation by serializing thrift * objects of varied sizes. */ 
 * Tries to serialize objects of sizes 512MB, 1GB and 1.5GB. This tests the * buffer resizing capability in the underlying NativeByteArrayOutputStreami and * the reallocation logic. 
 // Create an object with a serialization size which is larger than 4GB. // The reason we split the object into 8 strings instead of allocating a single 
<|del|> 
 public void freeNativeByteBuffer(byte[] nativeBuffer) throws ImpalaException { 
 try { Preconditions.checkState(bufferPtr_ >= 0); 
 } catch (Throwable e) { 
 if (newBufferSize >= BUFFER_MAX_SIZE_LIMIT || newBufferSize < 0) { 
<|del|> 
 Preconditions.checkState(buffer.buffer_ptr >= 0); 
 * allocations use the native memory and this class tracks the 
 * BUFFER_RESIZE_INCREMENTS. 
 private NativeByteArrayOutputStream(long initialSize) { 
 * Writes 'len' bytes of 'b' starting at 'offset' into the stream. Resizes the buffer 
 || ((offset + len) - b.length > 0)) { UnsafeUtil.UNSAFE.freeMemory(bufferPtr_); 
<|del|> 
/** * Tests the implementation of TNativeSerializer and the resizing behavior * of underlying TNativeByteBuffer implementation by serializing thrift * objects of varied sizes. */ 
<|del|> 
 testThriftLimits(factory); callSerializeTwice(factory); 
 PrintUtils.printBytes(NativeByteArrayOutputStream.BUFFER_MAX_SIZE_LIMIT); String currentSerializedSize = PrintUtils.printBytes(serializedByteSize); 
 public long reallocate(long bufferPtr, long size) { 
 throw new OutOfMemoryError(); 
 public void write(byte b[], int offset, int len) { if (b == null) return; 
 writeAndCheck(b, 0, 1024 * 1024); 
 writeAndCheck(b, 0, 1024 * 1024); 
 writeAndCheck(b, 0, 1024 * 1024); 
 writeAndCheck(b, 1, 0); 
 writeAndCheck(b, 5, 10); writeAndCheck(null, 0, 0); 
 * Tries to serialize objects of sizes 512MB, 1GB, 1.5GB, 3.5GB. This tests the * buffer resizing capability in the underlying NativeByteArrayOutputStream and 
 private final String UNKNOWN_LITERAL = "UNKNOWN"; 
 Preconditions.checkState(rhs.getType().isBoolean() || rhs.getType().isNull()); 
 if (!(expr instanceof BoolTestPredicate)) return expr; 
 IsCreateTableDoneRequest(KuduTable table, String id, String name) { 
 * determine which catalog objects were deleted since the last catalog topic update. * Once the catalog topic update is constructed, the old deleted catalog objects are 
 * determine which catalog objects were deleted since the last catalog topic update. * Once the catalog topic update is constructed, the old deleted catalog objects are 
 /** * Retrieve all the removed catalog objects with version > 'fromVersion'. */ 
 * referenced by "function" to a temporary file in "LOCAL_LIBRARY_PATH" and loads it 
<|del|> 
 * - bufferPtr_ >= 0 
<|del|> 
 // Custom NativeAllocator that accounts the allocated/freed bytes and simulates // allocation failures. 
 if (throwOnReallocate_ || size >= NativeByteArrayOutputStream.BUFFER_MAX_SIZE_LIMIT) { 
 // Deserialize the object at result.buffer_ptr and confirm it is the same. 
 @Test 
<|del|> 
<|del|> 
 } Preconditions.checkNotNull(result); 
 private final String UNKNOWN_LITERAL = "UNKNOWN"; 
 isNegated_ = isNegated; 
 addChild(e); addChild(v); 
 Preconditions.checkState(rhs.getType().isBoolean() || rhs.getType().isNull()); 
 req.get_tables_req.setSchemaName(dbName); 
 private static final String LOCAL_LIBRARY_PATH = new String("file://" + System.getProperty("java.io.tmpdir")); 
 LOG.warn("Serialized size of the catalog update is approaching the hard limit of " 
 // Expects the write() to fail and checks that the memory is freed after the // unsuccessful write(). 
 nbaos.write(b, offset, len); Assert.fail("Write() succeeded when it is expected to fail"); 
 // Check initial allocation failure in NBAOS c'tor 
 // Check initial allocation failure in NBAOS c'tor 
 if (throwOnReallocate_) throw new OutOfMemoryError(); allocatedBytes_ = size; 
 // Makes sure the nboas.write() succeeds. private void writeOk(NativeByteArrayOutputStream nbaos, 
 public void TestBasicSerialization() 
 private static String outDir_; 
 public static Expr createExpr(FunctionName fnName, FunctionParams params) { 
 public static Expr createExpr(FunctionName fnName, FunctionParams params) { 
 new NullLiteral() // NULL 
 List<CaseWhenClause> newWhenClauses = new ArrayList<CaseWhenClause>(); Expr elseExpr = null; 
 List<CaseWhenClause> newWhenClauses = new ArrayList<CaseWhenClause>(); Expr elseExpr = null; 
 public Expr apply(Expr expr, Analyzer analyzer) { 
 * Test expressions involving decimal types that return different numeric types * depending on the DECIMAL_V2 setting. 
 * Test expressions that return the same type with either DECIMAL_V2 setting. 
 // // DECIMAL_V1: floating point + any numeric literal = floating point // DECIMAL_V2: floating point + any expr of type decimal = decimal 
 checkDecimalReturnType("select round(1.2345, 2) * pow(10, 10)", Type.DOUBLE); checkDecimalReturnType("select round(1.2345, 2) + pow(10, 10)", Type.DOUBLE, ScalarType.createDecimalType(38, 17)); 
 // Test behavior of compound expressions with a single slot ref and many literals. 
 * Whether to wait for the table to be fully altered before this alter * operation is considered to be finished. 
 * The catalogd uses this log to identify deleted catalog objects. Deleted 
<|del|> 
 class CountingRewriteRuleWrapper implements ExprRewriteRule { 
 if (expr != ret) rewrites++; 
 public void TestSimplifyDistinctFromRule() throws AnalysisException { 
 * it can be further simplified via SimplifyDistinctFromRule. 
 builder.setTable(table); 
<|del|> 
 private static final String TABLE_TYPE_TABLE = "TABLE"; private static final String TABLE_TYPE_VIEW = "VIEW"; 
 // GetTableTypes returns values: "TABLE", "VIEW" 
 // tableTypes[i] are the type of tables within dbs[i] public List<List<String>> tableTypes = Lists.newArrayList(); 
 row.colVals.add(createTColumnValue(tableType)); 
 // Issue the statement to make sure the view is loaded 
<|del|> 
<|del|> 
<|del|> 
 private static String outDir_; 
<|del|> 
<|del|> 
 } } finally { tbl.getLock().unlock(); 
 private PartitionSpec partitionSpec_ = null; 
 private PartitionSpec partitionSpec_ = null; 
 if (partitionSpec_ == null) { 
 LOG.trace(p.toString() + " does have statistics"); 
 LOG.debug("Table stats query: " + tableStatsQueryStr_); 
 LOG.info("No supported column types in table " + table_.getTableName() + ", no column statistics will be gathered."); 
<|del|> 
 public StructField(String name, Type type, String comment) { // Impala expects column names to be lower cased, but this is not always true for // struct fields when loading external Hive tables (IMPALA-5994). 
 // Impala expects field names to be in lower case, but type strings stored in the HMS // are not guaranteed to be lower case. 
<|del|> 
<|del|> 
 // Returns a byte[] with [0, 1, 2, ..., 9, 0, 1, 2 ...] 
 for (String tableType : tableTypes) { tableType = tableType.toUpperCase(); 
<|del|> 
<|del|> 
 // Ignore. } finally { tableLoadingBarrier_.remove(tblName); 
 public TQueryOptions getOptions() { return this.options; } 
 Preconditions.checkNotNull(result); 
 .setStartDaemon(StartDaemonRequestPB.newBuilder().setId(d.id).build()) .build()); 
 * TODO(KUDU-2186): If used directly from {@link ProtobufHelper}, tests from * other modules break when run by Gradle. 
 synchronized (this) { 
 private static Table newTable(String name) { 
 } catch (TException e) { 
 // Create runtime filters. PlanFragment rootFragment = fragments.get(fragments.size() - 1); 
 } 
<|del|> 
 * The assigned filters are the ones for which 'scanNode' can be used as a destination 
 boolean isLocalTarget = isLocalTarget(filter, scanNode); if (runtimeFilterMode == TRuntimeFilterMode.LOCAL && !isLocalTarget) continue; 
 static private boolean isLocalTarget(RuntimeFilter filter, ScanNode targetNode) { 
 static private boolean isBoundByPartitionColumns(Analyzer analyzer, Expr targetExpr, 
 // TQueryOptions object that contains the updated query options. public native static byte[] NativeParseQueryOptions(String csvQueryOptions, byte[] queryOptions); 
 // TQueryOptions object that contains the updated query options. public native static byte[] NativeParseQueryOptions(String csvQueryOptions, byte[] queryOptions); 
 public void testRuntimeFilterQueryOptions() { runPlannerTestFile("runtime-filter-query-options"); 
 dummyTable.addColumn( new Column(colDef.getColName(), colDef.getType(), colDef.getComment(), i)); 
 * Condense the original graph 'g' to a new graph in SCC space. * Time complexity: O(V^2+E) 
 * the first catalog update is received from the statestore. 
 Preconditions.checkState(getCatalog().isReady(), 
<|del|> 
 org.apache.hadoop.hive.metastore.api.Partition msPartition, boolean loadBlockMd) 
 HdfsPartition hdfsPartition = createPartitionInternal(storageDescriptor, msPartition); if (loadBlockMd) loadMetadataAndDiskIds(hdfsPartition); 
 HdfsPartition hdfsPartition = createPartitionInternal(storageDescriptor, msPartition); if (loadBlockMd) loadMetadataAndDiskIds(hdfsPartition); 
<|del|> 
 // TODO: Modify the StmtRewriter to allow this case with relative refs. 
 // Uncorrelated group by with only aggregate function. 
 // is a constant on the left-hand side and a correlation. 
 LOG.info("Waiting for first catalog update from the statestore."); int numTries = 0; 
 LOG.info("Waiting for first catalog update from the statestore."); int numTries = 0; 
 "Local catalog has not been initialized. Aborting query analysis."); 
 public void setCatalogIsReady() { 
 " - " + e.getMessage(), e); 
 BoolLiteral boolLiteral = replaceExistsPredicate((ExistsPredicate) rewrittenConjunct); 
<|del|> 
 List<String> strs = new ArrayList<>(pbs.size()); 
 // Typically, one of the connections will have succeeded. However, it's possible // that 0 succeeded in the case that the masters were slow at electing // themselves. Assert.assertTrue(successes <= 1); 
 if (v == 0 && 1.0 / v == Double.NEGATIVE_INFINITY) return false; 
<|del|> 
 int[][] tcAdjList = new int[numVertices()][]; 
 queue.clear(); 
 // Adjacency list. Lists in the adjacency list are not sorted. 
 * Construct from an adjacency list. * Each list in the adjacency list must have been sorted. 
 * instead of a standalone hash table because the typical use case has less than * 10,000 vertices. 
 final int vid; // The current position in the vertex's dst list. In each iteration, the dst 
 int nextDfsIndex = 0; 
 if (!ctx.dstIt.hasNext()) { // All successors have been searched. Check if this is the root of an SCC. if (lowLinks[ctx.vid] == dfsIdxs[ctx.vid]) { 
public class IntArrayList { private int[] data_; 
 public IntArrayList() { this(0); } 
 System.arraycopy(data_, 0, newData, 0, data_.length); 
 * Remove elements from the end the of list. 
 public void testIntArrayList() { // Test add() 
<|del|> 
 * Assume RHS is of the form SELECT expr FROM T WHERE ... 
<|del|> 
 * NOT EXISTS (SELECT x FROM (SELECT x FROM RHS) tmp * WHERE C IS NULL OR IFNULL(tmp.x, C) = C) 
 /** * Utility class for retrieving metrics from the Impala webserver. */ 
 // must be a SlotRef pointing to a column. We can allow implicit integer casts // by casting the min/max values before sending them to Kudu. 
 // must be a SlotRef pointing to a column. We can allow implicit integer casts // by casting the min/max values before sending them to Kudu. 
<|del|> 
<|del|> 
 * Singleton class that monitors catalog usage. Currently, it tracks the most 
 }, num_tables_tracked, true); 
 // Map of file names to file descriptors for each partition location (directory). private Map<String, Map<String, FileDescriptor>> perPartitionFileDescMap_ = Maps.newHashMap(); 
 if (analyzer.getQueryOptions().isSetMt_dop() && analyzer.getQueryOptions().mt_dop > 0 && 
<|del|> 
<|del|> 
 private static String localLibraryPath_; 
 localJarPath = new Path(localLibraryPath_, UUID.randomUUID().toString() + ".jar"); 
<|del|> 
<|del|> 
<|del|> 
 private final int[] condensedAdjList = condensed_.adjList_[sccIds_[srcVid]]; private int adjListPos = 0; private int memberPos = 0; 
 ++adjListPos; 
 ++memberPos; 
 // Step 2: Compute the reflexive transitive closure. O(V(V+E)) 
<|del|> 
 private int pos_ = 0; 
 private int pos_ = 0; 
<|del|> 
 public static String PrintId(TUniqueId id) { 
 public static String PrintId(TUniqueId id) { 
 public static TUniqueId ParseId(String id) { String[] splitted = id.split(":"); 
 // deleted from this set and we are left with the set of privileges that // need to be removed. 
 // deleted from this set and we are left with the set of privileges that // need to be removed. 
 String roleName = role.getName() != null ? role.getName(), "null value"; LOG.error("Error listing the Role name:" + roleName, e); } 
 if (isSetAll_) return "SET ALL"; 
 if (isSetAll_) request.setIs_set_all(true); 
 * Checks if this slotRef refers to an array "pos" pseudo-column. 
 } catch (ImpalaException e) { 
 public String toSql() { 
<|del|> 
 public long getNextTableId() { return nextTableId_.getAndIncrement(); } 
 if ((expr.getChild(0) instanceof CastExpr) && 
<|del|> 
<|del|> 
 rhsQuery.reset(); 
 // [NOT] IN subquery with a correlated non-equi predicate is ok if the subquery only 
 "Unsupported correlated subquery with a LIMIT clause"); 
 if (splitted.length != 2) throw new NumberFormatException( "Invalid unique id format: " + id); 
 for (LocatedTablet tablet : getTabletsLocations(deadline)) { Partition partition = tablet.getPartition(); 
 lastTimeSessionActive.add(System.currentTimeMillis() / 1000); 
 long lastExecStatementTime = System.currentTimeMillis() / 1000; 
 try (ResultSet rs = connection.createStatement().executeQuery("SELECT 1+2")) { 
 * columns. Throws an ImpalaRuntimeException if Kudu column data types cannot be * mapped to Impala data types. 
<|del|> 
<|del|> 
 public void updateVersions(long oldVersion, long newVersion) { removeVersion(oldVersion); addVersion(newVersion); 
 public long getMinimumVersion() { 
 CatalogObjectVersionQueue.INSTANCE.addVersion( 
 List<Expr> relevantRhsExprs = Lists.newArrayList(); 
 LOG.debug("cardinality_=" + Long.toString(cardinality_) + " sel=" + Double.toString(computeSelectivity())); 
 * It relies on NormalizeBinaryPredicatesRule and FoldConstantsRule so that * <constant> is always on the right hand side and all constant Exprs have been * evaluated and converted to LiteralExprs. 
 if ((expr.getChild(0) instanceof CastExpr) && 
 (op == BinaryPredicate.Operator.EQ || op == BinaryPredicate.Operator.NE)) { 
 if (resultOfCast.isNullLiteral()) return expr; 
 if (resultOfCast.isNullLiteral()) return expr; 
 if (!alwaysEvictAtCapacity_ && compareRanks(item, heap_.peek()) <= 0) { 
<|del|> 
 // Set to True if statement is being re-analyzed. protected boolean isReAnalyzed_ = false; 
 // Set to True if statement is being re-analyzed. protected boolean isReAnalyzed_ = false; 
 if (tbl != null && !tbl.isStoredInImpaladCatalogCache()) { CatalogUsageMonitor.INSTANCE.removeTable(tbl); } 
 ignoreDuplicates_ = other.ignoreDuplicates_; 
 List<String> actualHints = Lists.newArrayList(); List<PlanHint> hints = insertStmt.getPlanHints(); for (PlanHint hint: hints) actualHints.add(hint.toString()); if (actualHints.isEmpty()) actualHints = Lists.newArrayList((String) null); 
 List<String> actualHints = Lists.newArrayList(); List<PlanHint> hints = insertStmt.getPlanHints(); for (PlanHint hint: hints) actualHints.add(hint.toString()); if (actualHints.isEmpty()) actualHints = Lists.newArrayList((String) null); 
 List<String> actualHints = Lists.newArrayList(); List<PlanHint> hints = insertStmt.getPlanHints(); for (PlanHint hint: hints) actualHints.add(hint.toString()); if (actualHints.isEmpty()) actualHints = Lists.newArrayList((String) null); 
 List<String> actualHints = insertStmt.getPlanHints(); if (actualHints == null) actualHints = Lists.newArrayList((String) null); 
 * ByteBuffer-backed implementation of TTransport. This is copied from thrift 0.10.0. * TODO: Upgrade thrift to 0.10.0 or higher and remove this file. 
 * "cast(<non-const expr> to <string type>) <eq/ne op> <string literal>" 
 * if the following is true: cast(cast(<string literal> as typeOf(<non-const expr>)) * as typeOf(<original cast expr>)) == <string literal> 
 * if the following is true: cast(cast(<string literal> as typeOf(<non-const expr>)) * as typeOf(<original cast expr>)) == <string literal> 
 * <string literal> is always on the right hand side and all constant Exprs have been 
 * Few cases that are not rewritten: 
 expr.getChild(1).isLiteral(); 
 expr.getChild(1).isLiteral(); 
 LiteralExpr literalExpr = (LiteralExpr) expr.getChild(1); 
 Analyzer analyzer) throws AnalysisException { 
 String msg = "\n<<< Expected(length:" + expected.length() + "): [" + expected + "]\n>>> Actual(length:" + actual.length() + "): [" + actual + "]\n"; 
 "for non-HDFS table " + table_.getTableName()); 
<|del|> 
<|del|> 
 int timeoutToleranceMs = 1500; int sleepPeriodMs = timeout * 1000 + timeoutToleranceMs; Thread.sleep(sleepPeriodMs); 
 int timeoutToleranceMs = 1500; int sleepPeriodMs = timeout * 1000 + timeoutToleranceMs; Thread.sleep(sleepPeriodMs); 
 long now = System.currentTimeMillis() / 1000; 
 distributeParam.setPkColumnDefMap(pkColDefsByName); 
 distributeParam.setPkColumnDefMap(pkColDefsByName); 
 // Test timestamp propagation with single operation. 
<|del|> 
<|del|> 
 * fileFormat' is the file format of the partition where this file resides and * 'hostIndex' stores the network addresses of the hosts that store blocks of * the parent HdfsTable. 
 * given directory 'dirPath'. Only blocks corresponding to paths from 'filteredParts' * are loaded. * TODO: Split this method into more logical methods for cleaner code. 
 PartitionSet partitionSet, RowFormat rowFormat) { 
 if (!Iterators.all(partition.getHashBuckets().iterator(), Predicates.equalTo(0))) { continue; } 
 private KuduClient buildKuduClient() { 
 // Test timestamp propagation with AUTO_FLUSH_SYNC flush mode. 
 assertTrue(client.hasLastPropagatedTimestamp()); 
 rowFormat_ = rowFormat; 
 rowFormatParams.setPartition_set(getPartitionSet().toThrift()); } 
 if (!(tbl instanceof HdfsTable)) { throw new AnalysisException("ALTER TABLE SET ROW FORMAT is only supported " + "on HDFS tables: " + tbl.getFullName()); 
<|del|> 
 private String getEscapedSingleQuotedValue() { 
 if (!Table.isExternalTable(table_.getMetaStoreTable()) && !setsToExternal) { 
<|del|> 
 if (nextChar != '"') { 
 * Generates a Kudu table name based on the target database and table and stores * it in TableDef.generatedKuduTableName_. Throws if the Kudu table 
 public void collectTableRefs(List<TableRef> tblRefs) { tblRefs.add(new TableRef(tableName_.toPath(), null)); 
 Table table = analyzer.getTable(tableName_, Privilege.DROP, true); 
 "Database does not exist: UNKNOWNDB"); 
 Preconditions.checkNotNull(params.getPartition_set()); 
 } numUpdatedPartitions.setRef((long) modifiedParts.size()); 
 Preconditions.checkArgument(tbl.getLock().isHeldByCurrentThread()); 
 // e.g. \u1111 as delimVal will return a valid byte '11' 
 if (cp >= 0 && cp <= 255) return (byte) cp; 
 // Test that a unicode character out of the valid range will not be accepted. 
 // Validate that unicode character in the valid range will be accepted. 
 // LIMIT 2 is enough to check if the child returns a scalar value. // Also, an optimized plan is generated with LIMIT 2. 
 } 
 // Assumes a string literal from single quotes and escapes it because: 
 // A string literal can come from a given string or the expression rewritter rule. It is 
 } 
 private String getDictionaryConjunctsExplainString(String prefix) { StringBuilder output = new StringBuilder(); 
 if (expr instanceof SlotRef) { substituteExpr = expr.trySubstitute(aliasSmap_, analyzer, false); } else { expr.analyze(analyzer); substituteExpr = expr; } return substituteExpr; 
 * Substitutes top-level ordinals and aliases. Does not substitute ordinals and * aliases in subexpressions. * Modifies the 'exprs' list in-place. * The 'exprs' are all analyzed after this function regardless of whether * substitution was performed. 
 private String getNormalizedValue() { 
 + value_ + "' to number."); 
 "supported on HDFS tables. Conflicting table: %1$s", tbl.getFullName())); 
 "only supported on TEXT or SEQUENCE file formats. Conflicting " + 
 "'s3a://bucket/test-warehouse/a/b'"); 
 * If given expr is rewritten into an integer literal, then return the original expr, * otherwise return the rewritten expr. 
 private Expr rewriteCheckOrdinalResult(ExprRewriter rewriter, Expr expr) 
 if (rewrittenExpr.isLiteral() && rewrittenExpr.getType().isIntegerType()) { return expr; } else { return rewrittenExpr; } 
 /** Holds indexes of operations in the original user's batch. */ 
 // Constant exprs should not be interpreted as ordinals 
 List<String> tblNames = impaladCatalog_.getTableNames(dbName, matcher); 
import org.apache.impala.catalog.Role; import org.apache.impala.catalog.StructType; import org.apache.impala.catalog.Type; 
<|del|> 
 String tabName = table.getName(); 
 return BaseSemanticAnalyzer.unescapeSQLString("'" + getNormalizedValue() 
 final int len = value_.length(); final StringBuilder sb = new StringBuilder(len); for (int i = 0; i < len; ++i) { 
 if (blockVectorOffset >= 0) FbFileDesc.addFileBlocks(fbb, blockVectorOffset); 
 * String literals can come directly from the SQL of a query or from rewrites like * constant folding. So this value normalization to a single-quoted string is necessary 
 // Original table name property for backwards compatibility with the original spec. // This changed upstream in Hive 3.0 with HIVE-18366 and may be backported by vendors. 
 // the newer table name, as specified in HBaseSerDe.HBASE_TABLE_NAME, and if that // fails, try looking for the original table name property in SERDEPROPERTIES. // If everything fails, return dbName.tableName, stripped of any default prefix. 
 // the newer table name, as specified in HBaseSerDe.HBASE_TABLE_NAME, and if that // fails, try looking for the original table name property in SERDEPROPERTIES. // If everything fails, return dbName.tableName, stripped of any default prefix. 
 // the newer table name, as specified in HBaseSerDe.HBASE_TABLE_NAME, and if that // fails, try looking for the original table name property in SERDEPROPERTIES. // If everything fails, return dbName.tableName, stripped of any default prefix. 
<|del|> 
<|del|> 
 // set the child explicitly, an ExchangeNode might have been inserted 
<|del|> 
 for (TScanRangeLocations range: scanRanges_) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 long actualExtrapNumRows = ((HdfsTable)tbl).getExtrapolatedNumRows(fileBytes); assertEquals(expectedExtrapNumRows, actualExtrapNumRows); 
 // Should be in sync with corresponding values in runtime-filter-bank.cc. private static final long MIN_BLOOM_FILTER_SIZE = 4 * 1024; private static final long MAX_BLOOM_FILTER_SIZE = 512 * 1024 * 1024; 
 for (ColumnDef pkColDef: primaryKeyColumnDefs) { tmpTable.primaryKeyColumnNames_.add(pkColDef.getColName()); } 
 // Test clustered hint. 
 public CreateTableStmt createStmt; public QueryStmt queryStmt; public List<String> partitionKeys; 
 protected CardinalityCheckNode(PlanNodeId id, PlanNode child, String displayStmt) { 
<|del|> 
 for (Expr child: children_) { Expr operand = (Expr) child; 
 Type[] argTypes = collectChildReturnTypes(); Function searchDesc = new Function(fnName_, argTypes, Type.INVALID, false); fn_ = db.getFunction(searchDesc, Function.CompareMode.IS_NONSTRICT_SUPERTYPE_OF); 
<|del|> 
<|del|> 
<|del|> 
 public ColumnSchemaBuilder typeAttributes(ColumnTypeAttributes typeAttributes) { if (type != Type.DECIMAL && typeAttributes != null) { throw new IllegalArgumentException( "ColumnTypeAttributes are not used on " + type + " columns"); } 
 return Objects.hash(hasPrecision, precision, hasScale, scale); 
 * @param b The zeroed byte array to write to. 
 reverseBytes(bytes); 
 private static void reverseBytes(final byte[] b) { 
 if (bigInt.compareTo(BIGINT32_MIN) >= 0 && bigInt.compareTo(BIGINT32_MAX) <= 0) { setInt(b, bigInt.intValue(), offset); } else { throw new ArithmeticException("BigInteger out of int range"); } 
 return Bytes.getDecimal(value, typeAttributes.getPrecision(), typeAttributes.getScale()).toString(); 
 * Get the specified column's Decimal. 
 BigDecimal smallest = DecimalUtil.smallestValue(scale); Bytes.setBigDecimal(rowAlloc, existing.add(smallest), precision, offset); 
 * Get the specified column's Decimal. 
 new BigInteger(Strings.repeat("9", MAX_DECIMAL128_PRECISION)); 
 return new ColumnTypeAttributes.ColumnTypeAttributesBuilder() 
 private static final ColumnSchema decimal32Col = new ColumnSchema.ColumnSchemaBuilder("decimal32", Type.DECIMAL) .typeAttributes(DecimalUtil.typeAttributes(DecimalUtil.MAX_DECIMAL32_PRECISION, 2)) 
 isReAnalyzed_ = other.isReAnalyzed_; 
 // CROSS JOIN query: tests that multiplying the input cardinalities does not overflow // the cross-join's estimated cardinality 
 // CROSS JOIN query: tests that multiplying the input cardinalities does not overflow // the cross-join's estimated cardinality 
 // JOIN query: tests that multiplying the input cardinalities does not overflow // the join's estimated cardinality 
 // creates a table with negative row count and // tests that the cardinality is not negative 
<|del|> 
 String tblName = "tpch.cardinality_overflow"; String colDefs = "(" + "l_orderkey BIGINT, " 
 String tblName = "tpch.cardinality_overflow"; String colDefs = "(" + "l_orderkey BIGINT, " 
 + "tpch.cardinality_overflow b, tpch.cardinality_overflow c"; 
 query = "select l_shipmode from tpch.cardinality_overflow " + "union select l_comment from tpch.cardinality_overflow"; 
 + "tpch.cardinality_overflow b on a.l_linenumber < b.l_orderkey"; 
 private Table addAndLoadTable(String dbName, String tableName) throws CatalogException { 
 * EventSequence. 
 private final static Logger LOG = LoggerFactory.getLogger(StmtMetadataLoader.class); 
 // Number of prioritizedLoad() RPCs issued to the catalogd. private int numLoadRequestsSent_; // Number of catalog topic updates received from the statestore. private int numCatalogUpdatesReceived_; 
 * Collects and loads all tables and views required to analyze the given statement. 
 this.createStmt = Preconditions.checkNotNull(createStmt); this.queryStmt = Preconditions.checkNotNull(queryStmt); 
 * Creates an insert into, an insert overwrite, and a CTAS statement with * the given hints and checks that the parsed hints are the same as the expected hints. 
 * does not exists. Returns null if the table does not exist. * TODO: Clean up the inconsistent error behavior (throwing vs. returning null). 
 long idealReservationBytes = Math.max(minReservationToExecute, 
 // Read size for Parquet and ORC footers. Matches HdfsScanner::FOOTER_SIZE in backend. private static final long FOOTER_SIZE = 100L * 1024L; 
 // Read size for Parquet and ORC footers. Matches HdfsScanner::FOOTER_SIZE in backend. private static final long FOOTER_SIZE = 100L * 1024L; 
 Preconditions.checkNotNull(scanRanges_, "Cost estimation requires scan ranges."); if (scanRanges_.isEmpty()) { 
 Preconditions.checkState(0 < numNodes_ && numNodes_ <= scanRanges_.size()); 
 } loadDiskIds(perFsFileBlocks); 
<|del|> 
 try (KuduClient client = new KuduClient.KuduClientBuilder(miniCluster.getMasterAddresses()).build()) { 
 // TODO(KUDU-2344): This should fail with NotAuthorized. 
 try (KuduClient client = new KuduClient.KuduClientBuilder(miniCluster.getMasterAddresses()).build()) { 
 if (isColumnVisible()) { 
 * caller did not provide a Subject with appropriate credentials). 
<|del|> 
 /** * Check if the Subject associated with this SecurityContext needs to be refreshed, * and if so, do so. If there is no associated subject this is a no-op. */ 
 return tgt.getEndTime().getTime() < deadlineMillis; 
 private enum Option { 
 // we'd just hang onto our existing authenticated connections which // would continue to work even though our credentials might have // expired (we only authenticate when a connection is negotiated, not // for each call). 
 private Path candidatePath_; 
 .onTable(analyzer.getDefaultDb(), rawPath_.get(0)).any().toRequest()); 
 List<HdfsPartition> orderedPartitions = null; if (partitionSpec == null) { 
 * might produce results and incorrectly return them to the client. If the child of this 
 List<Expr> slotExprs = info_.getSortTupleSlotExprs(); 
 * This enum provides a list of Sentry actions used in Impala. 
 return getTabletId(); 
 // User has REFRESH privilege on functional_text_lzo database, = 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 new Object[] {policyFile, engine, HivePrivilegeModel.getInstance()}); 
 } catch (SentryUserException e) { 
 // backend lib-cache entry. Returns -1 if a modified time is not applicable. // If an error occurs and the mtime cannot be retrieved, a default of Long.MAX_VALUE // is returned. 
 TSymbolLookupParams lookup = Preconditions.checkNotNull(getLookupParams()); 
 // There was an error looking up the lib. A max mtime will result in a query // runtime error. 
 testMTime("avg(int_col)", false); 
 if (getBinaryType() != TFunctionBinaryType.BUILTIN && getLocation() != null) { Preconditions.checkState(!getLocation().toString().isEmpty()); 
 } // There was an error looking up the lib. A max mtime will result in an error. 
 } // There was an error looking up the lib. A max mtime will result in an error. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // set as expected. 'expr' must be a single function call. 
 private void checkSerializedMTime(Expr expr, boolean expectMTime) { Preconditions.checkNotNull(expr.getFn()); TExpr thriftExpr = expr.treeToThrift(); 
 // Checks that 'expr', when serialized to thrift, has mtime 
 private void testMTime(String expr, boolean expectMTime) { 
 final private String name; final private int code; 
<|del|> 
<|del|> 
 List<KuduScanToken> scanTokens = new KuduScanToken.KuduScanTokenBuilder(client, this) .setTimeout(deadline).build(); for (KuduScanToken token : scanTokens) { 
<|del|> 
 * Some rules regarding how the database name is set when analyze is called: 
 * - If the function name specified has the same name as a built-in function, 
 * - If the function name specified has the same name as a built-in function, 
 throw new AnalysisException(String.format("%s is not partitioned", 
<|del|> 
 * Function resolution happens as follows. 
 * Function resolution happens as follows. 
 } Preconditions.checkNotNull(db_); 
 subquery_.getStatement().setIsRuntimeScalar(false); 
 List<HdfsPartition> hdfsPartitions = hdfsTable.createAndLoadPartitions(partitions); for (HdfsPartition hdfsPartition: hdfsPartitions) { catalog_.addPartition(hdfsPartition); } return hdfsTable; 
<|del|> 
<|del|> 
 db_ = fnNamePath_.get(0).toLowerCase(); 
 Analyzer dummyAnalyzer = ((StatementBase) AnalyzesOk("select 1")).getAnalyzer(); 
 if (partitions.isEmpty()) { return; } 
 if (insertCount % 1000 == 0 && session.countPendingErrors() > 0) { throw new RuntimeException(session.getPendingErrors().getRowErrors()[0].toString()); 
/* * A simple example of using the synchronous Kudu Java client to * - Create a table. * - Insert rows. * - Alter a table. * - Scan rows. * - Delete a table. */ 
 // Check for errors. This is done periodically since inserts are batched. 
 Preconditions.checkState(Thread.holdsLock(table)); 
 ImpalaActionFactory factory = new ImpalaActionFactory(); 
 expected = Lists.newArrayList( 
 assertBitFieldActions(expected, actual); // A value that's bigger than ALL. actual = factory.getActionsByCode(1 << 9); expected = Lists.newArrayList(); assertBitFieldActions(expected, actual); 
<|del|> 
 public boolean returnsSingleRow() { Preconditions.checkState(isAnalyzed()); 
<|del|> 
 SelectStmt subqueryStmt = (SelectStmt)expr.getSubquery().getStatement(); boolean isScalarSubquery = expr.getSubquery().isScalarSubquery(); boolean isRuntimeScalar = subqueryStmt.isRuntimeScalar(); 
<|del|> 
<|del|> 
 // Scalar subquery check is done at runtime, not during analysis 
 // Scalar subquery check is done at runtime, not during analysis 
 if (node instanceof QueryStmt) { actual = ((QueryStmt)node).getOrigSqlString(); 
<|del|> 
 // Test altering a Kudu table. Table table = table("table"); 
<|del|> 
 public static Type getAssignmentCompatibleType(Type t1, Type t2, boolean strict) { 
 // need 41 digits). Return a clipped decimal if decimal_v2 is disabled. 
 // Suppress warnings from OptionBuilder. @SuppressWarnings("static-access") public static void main(String[] args) throws Exception { 
<|del|> 
 static final String LEGACY_KUDU_STORAGE_HANDLER = "com.cloudera.kudu.hive.KuduStorageHandler"; 
 // Check the altered table's properties. This implies legacy Kudu table // can only be upgraded to the new format. 
 * Checks whether the table is a Kudu table with legacy Kudu 
<|del|> 
 if (isRuntimeScalar) subqueryStmt.setLimit(2); 
 throw new AnalysisException( "Unsupported correlated subquery with runtime scalar check: " + stmt.toSql()); 
<|del|> 
<|del|> 
 public void before() throws ImpalaException { // Remove existing roles in order to not interfere with these tests. 
<|del|> 
 // Select with an alias. authorize("select t.id from functional.alltypes t") 
<|del|> 
<|del|> 
 * Marks the given sequence id as complete. The provided sequence ID must be a valid * number that was previously returned by {@link #newSeqNo()}. It is illegal to call * this method twice with the same sequence number. 
 AnalyticWindow.Boundary boundary) throws AnalysisException { 
 type_ = Type.getAssignmentCompatibleType(t0, t1, false); 
 * message. * * If strictDecimal is true, only consider casts that result in no loss of information * when casting between decimal types. 
<|del|> 
 Set<String> expectedPrivileges = Sets.newHashSet( 
 .error(selectError("functional.view_view")) .error(selectError("functional.view_view"), onServer(allExcept( 
 // Populate stackdepth to monitorinfo map 
 result.append("\n\tNumber of locked synchronizers = " + locks.length + '\n'); 
 kuduPartitionParams_.clear(); 
<|del|> 
 privileges[i].setServer_name(SENTRY_SERVER); privileges[i].setPrivilege_name(RolePrivilege.buildRolePrivilegeName( privileges[i])); 
 privileges[i].setDb_name(db); privileges[i].setPrivilege_name(RolePrivilege.buildRolePrivilegeName( privileges[i])); 
 } catch (ReflectiveOperationException e) { Throwables.propagateIfPossible(e.getCause(), UnknownHostException.class); throw new AssertionError("unexpected reflection issue", e); 
 } catch (ReflectiveOperationException e) { Throwables.propagateIfPossible(e.getCause(), UnknownHostException.class); throw new AssertionError("unexpected reflection issue", e); 
<|del|> 
 Table.updateTimestampProperty(msTbl, HdfsTable.TBL_PROP_LAST_COMPUTE_STATS_TIME); 
 Table.updateTimestampProperty(msTbl, HdfsTable.TBL_PROP_LAST_DDL_TIME); 
 Table.updateTimestampProperty(msTbl, HdfsTable.TBL_PROP_LAST_DDL_TIME); 
 public IgnoreValueFilter(String key, String valueRegex) { // Include leading space to avoid matching partial keys, e.g. if key is "bar" we // don't want to match "foobar=". 
 List<ResultFilter> lineFilters) { 
 Math.min(scanRangeSpecs_.getConcrete_rangesSize(), 
 " Id=" + threadInfo.getThreadId() + " " + threadInfo.getThreadState()); 
 "\" Id=" + threadInfo.getLockOwnerId()); 
 if (miList == null) { 
<|del|> 
 Preconditions.checkState(result.isDecimal() || result.isInvalid()); Preconditions.checkState(!result.isWildcardDecimal()); 
 * Deterministically assigns regions to region servers. 
 * Wrapper classes to abstract away differences between HDFS versions in 
 boolean fsHasBlocks = FileSystemUtil.supportsStorageIds(partitionFs); if (!fsHasBlocks) { 
 partition, fileDesc, fsHasBlocks, scanRangeBytesLimit, analyzer); 
 if (fsHasBlocks && !fileDesc.getIsEc() && FileBlock.getDiskId(block, j) == -1) { 
 ColumnSchema col = schema.getColumnByIndex(idx); Preconditions.checkState(columnsBitSet.get(idx), "Column %s is not set", col.getName()); 
 * Converts a {@link Timestamp} to microseconds since the Unix epoch (1970-01-01T00:00:00Z). 
 /** * construct an in-list: string_col in [offset ... offset + length) */ 
 HdfsStorageDescriptor.fromStorageDescriptor(this.name_, msTbl.getSd()); Map<FsKey, FileBlocksInfo> perFsFileBlocks = Maps.newHashMap(); 
 if (!Iterators.all(partition.getHashBuckets().iterator(), Predicates.equalTo(0))) continue; 
 if (loadPartitionFileMetadata) { 
 return Objects.equal(name, that.name) && Objects.equal(type, that.type) && Objects.equal(key, that.key) && Objects.equal(nullable, that.nullable) && 
 encoding, compressionAlgorithm, typeAttributes, typeSize); 
 return Objects.equal(columnIds, that.columnIds) && Objects.equal(numBuckets, that.numBuckets) && Objects.equal(seed, that.seed); 
 assertEquals(BaseKuduTest.getBasicSchema(), BaseKuduTest.getBasicSchema()); assertNotSame(BaseKuduTest.getBasicSchema(), BaseKuduTest.getBasicSchema()); 
 for (Type t : values()){ if (t.name().equals(name)){ 
 for (Type t : values()){ if (t.name().equals(name)){ 
 output.append(checkShortCircuitRead(CONF)); if (request.isCheck_hadoop_groups_mapping()) { output.append(checkGroupsMappingProvider(CONF)); } 
 * Check if the stmt returns at most one row. This can happen 
 // Select from an inline view that returns at most one row. 
 // TODO(todd) is this necessary in the case of the LocalCatalog impl? 
 * Returns the FS path where the metastore would create the given table. If the table 
 * Frontend interface for interacting with a database. 
 * Frontend interface for interacting with data sources. 
 AuthzOk("drop function if exists pi()"); 
 msClientPool_ = new MetaStoreClientPool(cfg.num_metadata_loading_threads, 
 * Implementation of FeCatalog which runs within the impalad and fetches metadata * on-demand using a {@link MetaProvider} instance. 
 metaProvider_ = Preconditions.checkNotNull(metaProvider); 
 return Catalog.filterCatalogObjectsByPattern(dbs_.values(), matcher); 
 throw new LocalCatalogException("Unable to load database names", e); 
 private final LocalDb db_; /** The lower-case name of the table. */ 
 * or may include caching, etc. * * TODO(IMPALA-7127): expand this to include file metadata, sentry metadata, * etc. 
 TDatabase tdb = new TDatabase(name_); 
 * Manages the Catalog implementation used by the frontend. 
 * Manages the Catalog implementation used by the frontend. 
 } 
 * (filesystem, HMS, etc) with no caching. 
 * Interface for loading metadata. See {@link LocalCatalog} for an example. 
 * * Throws a TableLoadingException if the FieldSchema could not be parsed. In this * case, 'tableName' is included in the error message. 
 * @param tableName the fullly qualified table name, for use in exception * messages 
 * @param tableName the fully qualified name of the table, for error messages 
<|del|> 
 return FeCatalogUtils.getRowCount(schemaInfo_.msTable_.getParameters()); 
 * table-level stats. * * TODO(todd): some of this code is lifted from 'Table' and, with some * effort, could be refactored to avoid duplication. 
 * table-level stats. * * TODO(todd): some of this code is lifted from 'Table' and, with some * effort, could be refactored to avoid duplication. 
 * table-level stats. * * TODO(todd): some of this code is lifted from 'Table' and, with some * effort, could be refactored to avoid duplication. 
 public static Type getTypeForName(String name) { for (Type t : values()) { if (t.name().equals(name)) { 
 output.append(tableRefToSql(rewritten)); 
 public String toSql(boolean rewritten) { if (!rewritten) { // Return the SQL string before inline-view expression substitution. if (sqlString_ != null) return sqlString_; } 
<|del|> 
<|del|> 
 return getLongParam(StatsSetupConst.ROW_COUNT, parameters); 
 * Returns the map from partition identifier to prunable partition. 
 * Returns the full partition objects for the given partition IDs, which must 
 * be implemented by only fetching partition names and not the complete 
 * Returns the identifier of this partition, suitable for later passing 
 * Returns the values associated with this partition 
 scanNode.init(analyzer); 
 HdfsPartition part = (HdfsPartition)Iterables.getFirst( hdfsTable.getPartitions(), null); Assert.assertNotNull(part); 
 HdfsPartition part = (HdfsPartition)Iterables.getFirst( hdfsTable.getPartitions(), null); Assert.assertNotNull(part); 
 public Map<Long, List<FileDescriptor>> getFilesSample( Collection<? extends FeFsPartition> inputParts, 
<|del|> 
 // TODO(todd): copy-paste from HdfsPartition // TODO(todd): as in the equivalent method in HdfsPartition, this is // expensive because it deserializes the stats completely. 
 private final ImmutableList<LiteralExpr> partitionValues_; 
 CatalogTest.checkAllTypesPartitioning(t, /*checkFileDescriptors=*/false); 
 // Check the altered table's properties. Kudu tables can be downgraded 
 private void addToLocationMapping(HdfsPartition partition) { 
 * Given a set of partition names, returns the corresponding HdfsPartition * objects grouped by their base directory path. 
 tbl_hdfs.isLocationSharedWithOtherPartitions(part)) { 
 tbl_hdfs.getPartitionNamesOnLocation(part.getLocation()); Preconditions.checkState(partitionNameList.size() > 1); 
 partition.setLocation(location); 
 import static org.junit.Assert.fail; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Random; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; 
 join(viewMetadataPrivileges(), TPrivilegeLevel.CREATE)))) 
 int startPort = startMasters(PORT_START, numMasters, baseDirPath, bindHost); 
<|del|> 
<|del|> 
class LocalTable implements FeTable { private final LocalDb db_; private final String name_; 
 // TODO: the org.apache.impala.catalog.View class is still used for local views // even in the LocalCatalog implementation. 
 // Returning null indicates that the column labels are derived 
 * Supports optionally specifying the backend and the deadline: either shutdown(), 
<|del|> 
<|del|> 
 * Scheduler). A new snapshot is created whenever the cluster membership changes 
<|del|> 
 createTable(view, params.if_not_exists, null, response); 
 // expose the table name. 
 Type retType, String uriPath, String symbolName) { 
 /** * Structured to generate Json that matches the expected .isolate format. * See here for a description of the .isolate format: * https://github.com/cloudera/dist_test/blob/master/grind/python/disttest/isolate.py */ 
 return new LocalKuduTable(db, msTable, cmap, kuduTable); 
 if (!rewritten && toSqlString_ != null) return toSqlString_; 
 if (!rewritten && sqlString_ != null) return sqlString_; 
 "(SELECT 2) `$a$1` (`$c$1`) ON id = `$a$1`.`$c$1`) a"); 
 LOG.trace("Rewritten SQL: " + analysisResult_.stmt_.toSql(true)); 
 LOG.trace("Rewritten SQL: " + analysisResult_.stmt_.toSql(true)); 
 if (!rewritten && sqlString_ != null) return sqlString_; 
 // Return the SQL string before inline-view expression substitution. if (!rewritten && sqlString_ != null) return sqlString_; 
 * If rewritten is true, returns the rewritten SQL only if the statement was * rewritten. Otherwise, the original SQL will be returned instead. 
<|del|> 
 * rewritten. Otherwise, the original SQL will be returned instead. It is the caller's * responsibility to know if/when the statement was indeed rewritten. 
 return null; // TODO(todd): implement auth policy 
 * Creates a temporary KuduTable object populated with the specified properties but has * an invalid TableId and is not added to the Kudu storage engine or the * HMS. This is used for CTAS statements. 
 static LocalTable loadFromKudu(LocalDb db, Table msTable) { 
 public TTableDescriptor toThriftDescriptor(int tableId, Set<Long> referencedPartitions) { 
 public TTableDescriptor toThriftDescriptor(int tableId, Set<Long> referencedPartitions) { 
<|del|> 
<|del|> 
<|del|> 
 LOG.trace(String.format("Skip recovery of path '%s' because it already exists " + "in metastore", path.toString())); 
 List<LiteralExpr> keyValues = Lists.newArrayList(); boolean isMarkedCached = isMarkedCached_; 
 // refer to this to understand how to create new partitions. If this method is called // on a table that already has a default partition, it will be overwritten. 
 FsPermissionChecker checker = FsPermissionChecker.getInstance(); FileSystem fs = location.getFileSystem(CONF); 
 private static final int RETRY_COUNT = Integer.getInteger("rerunFailingTestsCount", 0); 
 private static final int RETRY_COUNT = Integer.getInteger("rerunFailingTestsCount",0); 
 addPartition(hdfsPart); totalHdfsBytes_ += hdfsPart.getSize(); numHdfsFiles_ += hdfsPart.getNumFileDescriptors(); 
 if (msPartition != null) { isMarkedCached = HdfsCachingUtil.validateCacheParams(msPartition.getParameters()); 
<|del|> 
 // MBean server instance 
<|del|> 
 tThreadInfo.setSummary(threadInfo.toString()); 
 // MBean server instance 
 // MBean server instance 
 // Singleton instance of this pause monitor. 
 public void updateBF(byte[] data) { keyProbe.refresh(data); 
 public void updateBF(String data) { updateBF(data.getBytes(StandardCharsets.UTF_8)); 
 public BloomKeyProbe() { } public void refresh(byte[] key) { 
 static final Configuration HBASE_CONF = HBaseConfiguration.create(); 
 public static Pair<Long, Long> getEstimatedRowStats(FeHBaseTable tbl, byte[] startRowKey, byte[] endRowKey) { 
 // Cached column families. Used primarily for speeding up row stats estimation 
import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Implementation of FeCatalog which runs within the impalad and fetches metadata * on-demand using a {@link MetaProvider} instance. 
<|del|> 
import org.apache.impala.common.NotImplementedException; import org.apache.impala.common.RuntimeEnv; 
 * entries only get applied if the new/updated object has a larger catalog version. * add() and remove() functions also update the entries of the global instance of * CatalogObjectVersionQueue which keeps track of the catalog objects versions. 
 minVersion_ = Catalog.INITIAL_CATALOG_VERSION; 
 * Table client objects are thread-unsafe and cheap to create. The HBase docs * recommend creating a new one for each task and then closing when done. 
 // This should never happen - Hive blocks creating a mismatched table and both // Hive and Impala currently block all column-level DDL on HBase tables. 
 * @return The estimated number of rows in the regions between the row keys (first) * and the estimated row size in bytes (second). 
@InterfaceStability.Unstable 
<|del|> 
 public synchronized Principal dropRole(User user, String roleName) throws ImpalaException { 
 public synchronized Principal grantRoleGroup(User user, String roleName, String groupName) throws ImpalaException { 
 public synchronized Principal revokeRoleGroup(User user, String roleName, String groupName) throws ImpalaException { 
 PrincipalPrivilege existingPriv = catalog_.getPrincipalPrivilege(roleName, privilege); 
 AggregateInfo result = AggregateInfo.create(transGroupingExprs, transAggExprs, analyzer); 
 for (Integer idx : simplifiedAggInfo.getMaterializedSlots()) { rhsExprs.add( new SlotRef(matAggClassTupleDesc.getSlots().get(numGroupingExprs + idx))); 
 minVersion_ = Catalog.INITIAL_CATALOG_VERSION; 
@InterfaceStability.Unstable 
<|del|> 
 * "principal ID" rather than embedding the principal name. When a privilege is added to * a principal type, we do a lookup to get the principal ID to probe the principalIds_ * map. 
 // Need to keep separate caches of role names and user names since there is 
 public synchronized List<Role> getGrantedRoles(String groupName) { List<Role> grantedRoles = Lists.newArrayList(); 
 public ReentrantLock getLock() { return tableLock_; } 
 protected Principal(String principalName, TPrincipalType type, Set<String> grantGroups) { 
 * Stash the HMS Table object since we need this in order to handle some strange * behavior whereby the catalogd returns a Partition with no HMS partition object * in the case of unpartitioned tables. 
 OWNER("owner", ALL.getCode()); 
<|del|> 
 * removing, and replacing the catalog objects to match those in Sentry since 
 * A mix of distinct and non-distinct aggregation functions is allowed as long as all 
 * A mix of distinct and non-distinct aggregation functions is allowed as long as all 
 * SELECT block including their distributed execution by wrapping a list of * AggregateInfos. * 
 private List<Expr> getTransposeGroupingExprs( 
 return new ExprSubstitutionMap(lhsExprs, rhsExprs); 
 // Perhaps we should store the result in this class, instead of relying on 
 * Track the names and the number of usages of the recently used tables and the data to * catalogd asynchronously in order to invalidate the recently unused tables. 
 private static final Logger LOG = Logger.getLogger(ImpaladTableUsageTracker.class); @VisibleForTesting private final static long REPORT_INTERVAL_MS = 10000; private TReportTableUsageRequest req_; private Thread reportThread_; 
 try { Thread.sleep(REPORT_INTERVAL_MS); 
 LOG.warn("Unable to report table usage information to catalog server", e); 
<|del|> 
<|del|> 
 ret.add(stats); colsWithoutStats.remove(stats.getColName()); 
 for (Map.Entry<PartitionRef, PartitionMetadata> e: refToMeta.entrySet()) { 
 public void testCachePartitionsByRef() throws Exception { 
 ListMap<TNetworkAddress> hostIndex = new ListMap<>(); CacheStats stats = diffStats(); 
 analyzer.getDb(dbName_, Privilege.ALL, /* throw if does not exist */ true, /* grant option */ true); 
 boolean grantOption_ = false; 
 LOG.fatal("Aborting because of deadlocked threads in JVM."); System.exit(1); 
 * - Only a non-distinct class: * - Example: SELECT max(a) FROM... 
 * - Multiple distinct classes, and optionally a non-distinct class * - Example: SELECT count(distinct a), count(distinct b)[, max(c)] FROM... 
<|del|> 
 req.table_info_selector.want_stats_for_column_names = missingCols; 
 Set<String> colsWithoutStats = new HashSet<>(missingCols); for (ColumnStatisticsObj stats: resp.table_info.column_stats) { 
 } // Cache negative entries for any that were not returned. for (String missingColName: colsWithoutStats) { cache_.put(new ColStatsCacheKey((TableMetaRefImpl)table, missingColName), NEGATIVE_COLUMN_STATS_SENTINEL); } 
 req.table_info_selector.want_partition_names = true; 
 for (Map.Entry<PartitionRef, PartitionMetadata> e: refToMeta.entrySet()) { 
 * invalidation was executed. 
 daemonThread_.setName("CatalogTableInvalidator timer"); 
 BackendConfig.INSTANCE.getInvalidateTablesGcOldGenFullThreshold(), BackendConfig.INSTANCE.getInvalidateTablesFractionOnMemoryPressure()); 
 * Track the names and the number of usages of the recently used tables and report the * data to catalogd asynchronously in order to invalidate the recently unused tables. 
<|del|> 
<|del|> 
 catalog_ .invalidateTable(new TTableName(/*dbName=*/"functional", /*tblName=*/"alltypes"), tblWasRemoved, dbWasAdded); 
 new CatalogdTableInvalidator(catalog_, /*unusedTableTtlSec=*/ 2, /*invalidateTablesOnMemoryPressure=*/false, /*oldGenFullThreshold=*/ 0.6, /*gcInvalidationFraction=*/0.1)); Assert.assertFalse(catalog_.getDb(dbName).getTable(tblName).isLoaded()); 
 new CatalogdTableInvalidator(catalog_, /*unusedTableTtlSec=*/ 2, /*invalidateTablesOnMemoryPressure=*/false, /*oldGenFullThreshold=*/ 0.6, /*gcInvalidationFraction=*/0.1)); Assert.assertFalse(catalog_.getDb(dbName).getTable(tblName).isLoaded()); 
 ticker.set(TimeUnit.SECONDS.toNanos(3)); previousTriggerCount = waitForTrigger(previousTriggerCount); 
<|del|> 
 private KuduTable createNewTable(String tableName) throws Exception { 
<|del|> 
 private KuduSink createSink(String tableName) { 
 parameters.put(KuduSinkConfigurationConstants.KERBEROS_KEYTAB, clusterRoot + "/krb5kdc/test-user.keytab"); parameters.put(KuduSinkConfigurationConstants.KERBEROS_PRINCIPAL, "test-user@KRBTEST.COM"); 
 * are stored as a deflate-compressed byte array to reduce memory footprint. Use * 'getPartitionStats()' to get the corresponding TPartitionStats object. 
 * @return the HMS parameters stored for this partition. Partition stats in this map * are filtered when the partition is loaded. Hence the returned map here does 
 byte[] serialized = CompressionUtil.deflateCompress(serializer.serialize(partStats)); 
 byte[] compressedStats = partition.getPartitionStatsCompressed(); if (compressedStats == null) return; 
 LOG.error("Error compressing input bytes.", e); 
 LOG.error("Error decompressing input bytes.", e); 
 * @return the HMS parameters stored for this partition. Partition stats serialized into * this map are filtered when the partition is loaded. Hence the returned map here does * not include them. To access partition stats, use getPartitionStatsCompressed(). 
 PartitionMetadata oldVal = ret.put(partName, metaImpl); 
 @Override 
 getOrFetchPartitionStats(analyzer, hdfsTable, allPartitions, /* excludedPartitions= */ Collections.<Long>emptySet()); 
 int expectedNumStats = partitions.size() - excludedPartitions.size(); Preconditions.checkArgument(expectedNumStats >= 0); 
 versionLock_.readLock().unlock(); 
 // statistics and a local catalog are not specified. 
 * @return the HMS parameters stored for this partition. Keys that store chunked * TPartitionStats for this partition are not included. To access partition stats, use * getPartitionStatsCompressed(). 
 * byte array. The output byte array is deflate-compressed. Sets hasIncrStats to 
<|del|> 
<|del|> 
 LOG.error(debugString, e); throw new ImpalaRuntimeException(debugString, e); 
 LOG.error(debugString, e); throw new ImpalaRuntimeException(debugString, e); 
 public static byte[] deflateCompress(byte[] input) { if (input == null) return null; 
 "Could not load functions for database '%s' from HMS", name_), e); 
 return fetchPartitionStats(analyzer, table, partitionsToFetch); 
<|del|> 
<|del|> 
 * Utility method that applies getPartitionKeyValueString to each literal to return * a list of partitioning key values as strings. 
 analyzer.registerPrivReq(new PrivilegeRequest(Privilege.ALL)); 
 private static class PartitionCacheKey extends VersionedTableCacheKey { 
<|del|> 
<|del|> 
 setOwnerParams.setServer_name(serverName_); 
<|del|> 
 LOG.debug("Creating database " + dbName); 
<|del|> 
 @Override protected MiniKuduClusterBuilder getMiniClusterBuilder() { return super.getMiniClusterBuilder() 
 List<Event> events = new ArrayList<>(); 
 sb.append(":").append(fnName_).append("("); 
 * computation (grouping exprs are identical to aggInfo) 
<|del|> 
 * contains a list of aggregate functions that have the same list of DISTINCT exprs. 
 for (AggregateInfo aggInfo : aggInfos_) { ExprSubstitutionMap aggSmap = aggInfo.getResultSmap(); 
 * appropriate slot to group on based on which tuple is non-NULL in an input row. 
 AggregateInfo lastAggInfo = aggInfos_.get(aggInfos_.size() - 1); 
 lastAggInfo.materializeRequiredSlots(analyzer, smap); materializedAggInfos_.add(lastAggInfo); } if (materializedAggInfos_.size() == 1) { 
 for (AggregateInfo aggInfo : aggInfos_) { if (aggInfo.isDistinctAgg()) return AggPhase.SECOND; 
 validPartStats_.add(partStats); 
 validPartStats_.addAll(partitionStats.values()); 
 if (excludedPartitions.contains(p.getId())) continue; 
 * - the partition is whitelisted in 'partitions' 
 PartitionStatsUtil.partStatsFromCompressedBytes( compressedStatsBytes, part); 
 "Partition statistics can only be requested for FS tables, type is: %s", 
 Preconditions.checkState(partition instanceof FeFsPartition); 
 * returns a null value. The partition, 'part', provides debugging context. 
 LOG.warn("Error decompressing partition stats for partition: " + part.getPartitionName()); 
import org.apache.impala.catalog.Db; import org.apache.impala.catalog.FeDb; 
 * Last time an time-based invalidation is executed in nanoseconds. 
 // Wait for a fraction of unusedTableTtlNano_ if time-based invalidation is // enabled if (unusedTableTtlNano_ > 0 && now >= lastInvalidationTime + sleepTimeNano) { 
 LOG.warn("Unexpected exception thrown while attempting to automatically" + "invalidate tables. will retry in 5 seconds.", e); Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS); 
 .invalidateTable(new TTableName(dbName, tblName), 
 resp.result.setVersion(dataSource.getCatalogVersion()); addSummary(resp, "Data source has been dropped."); 
 // Look up in cache first, keeping track of which ones are missing. // We can't use 'loadWithCaching' since we need to fetch several entries batched // in a single RPC to the catalog. 
 "Could not load function names for database '%s'", name_), e); 
 throw new LocalCatalogException(String.format("Could not load function '%s.%s'", 
 Preconditions.checkNotNull(partitions); Preconditions.checkState(BackendConfig.INSTANCE.pullIncrementalStatistics() && !RuntimeEnv.INSTANCE.isTestEnv()); 
 throws CatalogException { Preconditions.checkState(BackendConfig.INSTANCE.pullIncrementalStatistics() && !RuntimeEnv.INSTANCE.isTestEnv()); 
 + " loaded table: " + request.table_name, ((IncompleteTable) table).getCause()); 
 byte[] compressedStats, FeFsPartition part) throws ImpalaException { 
 String partitionName = (part == null ? "N/A" : part.getPartitionName()); LOG.warn("Error decompressing partition stats for partition: " + partitionName); 
 * 2. If invalidate_tables_timeout_s is set in the backend, unused tables older than the * threshold are invalidated periodically. 
 * A thread waking up periodically to check if eviction is needed. 
<|del|> 
 * Returns the server name if authorization is enabled. Returns null when authorization * is not enabled. 
 throw new InternalException("Error making 'getConfigValue' RPC to Sentry Service: ", 
 StorageDescriptor sd = new StorageDescriptor(); // Add all the columns to a new storage descriptor. 
 List<PrincipalPrivilege> addedRolePrivileges = null; List<PrincipalPrivilege> removedGrantOptPrivileges = Lists.newArrayListWithExpectedSize(privileges.size()); 
 fe_.getImpaladTableUsageTracker().recordTableUsage(loadedTbls_.keySet()); 
<|del|> 
 "Invalidated " + table.getFullName() + " due to inactivity for " + 
 LOG.warn("Unexpected exception thrown while attempting to automatically " + "invalidate tables. Will retry in 5 seconds.", e); 
 LOG.warn("Unexpected exception thrown while attempting to automatically " + "invalidate tables. Will retry in 5 seconds.", e); 
 * invalidation is disabled, but in that case, it will be a no-op. 
 for(SelectionKey sk : selectedKeys) { 
 if (op != null && op.getHandlingNode() != null) { op.getHandlingNode().setContinuousTimeout(true); } 
 if (op != null && op.getHandlingNode() != null) { op.getHandlingNode().setContinuousTimeout(false); } 
 if (op != null && op.getHandlingNode() != null) op.getHandlingNode().setContinuousTimeout(true); 
 /** * Mark this operation as one which has exceeded it's timeout value. */ public void timeOut(); 
 /** * Mark this operation as one which has exceeded it's timeout value. */ public void timeOut(); 
 private boolean timedout; private long creationTime; 
 public boolean isTimedOut(long ttlMillis) { 
 long ttlNanos = ttlMillis * 1000 * 1000; if (elapsed - creationTime > ttlNanos) { 
<|del|> 
<|del|> 
<|del|> 
 getLogger().info( 
 private final String name; 
 private final Status status; private final String hostname; 
 private final Status status; private final String hostname; 
 Config create(File file); 
 private final int vbucketsCount; 
public class ConfigurationParserJSON extends SpyObject implements ConfigurationParser { 
 private final Status status; private final String hostname; 
<|del|> 
 private final HashAlgorithm hashAlgorithm; 
<|del|> 
 throw new IllegalArgumentException("Filename is empty."); 
 private volatile int master; 
 replicas = r.clone(); 
<|del|> 
 ChannelPipeline pipeline = pipeline(); 
 this.partialResponse = new StringBuilder(); 
<|del|> 
<|del|> 
<|del|> 
 private void readPools(String bucketToFind) throws ConfigurationException { 
 bucketFound = true; break; 
 serversString.append(server).append(' '); 
 public void subscribe(String bucketName, Reconfigurable rec) throws ConfigurationException { 
 private final Reconfigurable rec; 
<|del|> 
<|del|> 
 byte[] e = String.valueOf(exp).getBytes(); 
 * @param exp the amount of time the lock should be valid for in seconds. * By default the maximum allowed timeout is 30 seconds. Timeouts greater * than this will be set to 30 seconds. 
 byte[] e = (exp + "").getBytes(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 this.partialResponse = new StringBuilder(); 
<|del|> 
 private StringBuilder partialResponse; 
<|del|> 
 * Gets and locks the given key asynchronously. By default the maximum allowed 
 * @param exp the amount of time the lock should be valid for in seconds. 
<|del|> 
 Config config = cf.create(bucketJO); 
<|del|> 
<|del|> 
 private StringBuilder partialResponse; 
<|del|> 
<|del|> 
 private final AtomicReference<Map<String, Bucket>> currentBuckets = new AtomicReference<Map<String, Bucket>>(); 
 private AtomicReference<Map<String, Bucket>> getCurrentBuckets() { 
 return Collections.unmodifiableMap(currentBuckets.get()); 
 HashMap<String, Bucket> swapMap = new HashMap<String, Bucket>(replacingMap); //TODO: replace this with a deep copy 
 void gotData(String key, int flags, long cas, byte[] data); 
 public GetAndTouchOperationImpl(String c, int e, GetAndTouchOperation.Callback cb, 
 bb.putShort((short) vbucket); // reserved 
 } 
 if (addrs.isEmpty()) { throw new IllegalArgumentException("servers cannot be empty"); //servers was passed in empty, and shouldn't have been } 
 HashMap<String, MemcachedNode> vbnodesMap = new HashMap<String, MemcachedNode>(); 
 // configuration config private final Config configuration; 
 private final HashAlgorithm hashAlgorithm = HashAlgorithm.NATIVE_HASH; 
 private final int serversCount; 
<|del|> 
 TapOperation tapBackfill(String id, long date, OperationCallback cb); 
 private BlockingQueue<ResponseMessage> rqueue; 
 shutdown(); 
 /* Not caught because if we are interrupted early * the stream should close anyways. */ 
 if (this.configurationProvider != null) { this.configurationProvider.shutdown(); } 
 public void setFlags(TapFlag f) { if (flags.length != FLAGS_FIELD_LENGTH) { 
 Util.valueToField(backfilldate, 0, BACKFILL_DATE_FIELD_LENGTH, date); 
 if (flags.length != FLAGS_FIELD_LENGTH) { 
 if (i == 0) { 
 if (len >= (int)Math.pow(256, (double) (KEY_LENGTH_FIELD_LENGTH))) { throw new IllegalArgumentException("Name too big"); } 
 if (FLAGS_OFFSET + FLAGS_FIELD_LENGTH > getExtralength()) { return 0; } 
<|del|>
 public TapClient(final List<URI> baseList, final String bucketName, 
 * with this client. This will include a count of all tap * response types. 
<|del|>
 Thread.currentThread().interrupt(); 
 for (Map.Entry<Operation,TapConnectionProvider> me: omap.entrySet()) { me.getValue().shutdown(); } 
 final String usr, final String pwd) { for (URI bu : baseList) { if (!bu.isAbsolute()) { throw new IllegalArgumentException("The base URI must be absolute"); } } 
 throw new UnsupportedOperationException("Touch is not supported for " + "ASCII protocol"); 
<|del|>
 assert client.set("touchkey", 1, "touchvalue").get().booleanValue(); assert client.touch("touchkey", 2).get().booleanValue(); Thread.sleep(1300); 
 * Creates a TapClient against the specified servers. 
 * Allows the user to specify a custom tap message. 
 * @param id the named tap id that can be used to resume a disconnected 
 public Operation tapBackfill(String id, final int runTime, final TimeUnit timeunit) throws IOException, ConfigurationException { return tapBackfill(id, -1, runTime, timeunit); 
 * @param timeunit the unit of time for the runtime parameter. * @return the operation that controls the tap stream. * @throws ConfigurationException a bad configuration was recieved from the 
 Thread.sleep(TimeUnit.MILLISECONDS.convert(runTime, timeunit)); 
 * Tap operation. 
 throw new UnsupportedOperationException("Tap is not supported for ASCII" + " protocol"); 
 /** * Since the tap custom doesn't specify any specific keys to get * this function always returns null; */ 
kage net.spy.memcached.tapmessage; 
public class BaseMessage extends SpyObject { 
import net.spy.memcached.compat.SpyObject; 
<|del|> 
<|del|> 
 public static void valueToFieldOffest(byte[] buffer, int offset, int length, long l) { 
 getLogger().error("vBucket ignored " + vbs[i-1] + "is not a valid vBucket number"); 
<|del|> 
 private static final long serialVersionUID = -9180877058910807939L; 
 private static final long serialVersionUID = -6513198067127603979L; 
 * in the environment variable SPY_MC_TEST_SERVER or * localhost:11211 by default. 
 /** * An individual sync key request. */ 
 this.cas = cas; 
 /** * An individual sync response from the server. */ 
<|del|>
<|del|> 
 } catch (IOException e) { 
 if (TestConfig.defaultToIPV4()) { 
 InetSocketAddress.createUnresolved("localhost", 11211), 
 new Node(Status.healthy, "localhost", Collections.singletonMap(Port.direct, "11210"))); 
 /** * Operations that depend on a VBucket number being sent to the server * are required to implement this interface. */ 
 /** * Binary operations that contain multiple keys and are VBucket aware * operations should extend this class. */ 
 /** * Binary operations that contain a single key and are VBucket aware * operations should extend this class. */ 
<|del|>
 return failureMode; 
 /** * This interface is provided as a helper for testing clients of the MembaseClient. */ 
<|del|> 
 public void updateLocator(final List<MemcachedNode> nodes, final Config conf); 
<|del|>
 @Override public void updateLocator(List<MemcachedNode> nodes, Config conf) { this.nodes=nodes.toArray(new MemcachedNode[nodes.size()]); } 
 @Override public void updateLocator(List<MemcachedNode> nodes, Config conf) { setKetamaNodes(nodes); } 
 public void updateLocator(final List<MemcachedNode> nodes, final Config conf); 
 /** 
 protected abstract String getBucketType(); 
<|del|> 
 InetSocketAddress address = (InetSocketAddress) memcachedClient.getNodeLocator().getPrimary(OBJ_KEY).getSocketAddress(); int port = address.getPort(); 
 String encodedText = Base64.encodeBase64String(clearText.toString().getBytes()); 
 String encodedText = Base64.encodeBase64String(clearText.toString().getBytes()); 
 private final AtomicReference<TotalConfig> fullConfig; 
<|del|>
 case VBUCKET: 
 * Get a MembaseClient based on the REST response from a Membase server. 
 * Get a MembaseClient based on the REST response from a Membase server 
 /** * This function is called when there is a topology change in the * cluster. This function is intended for internal use only. */ 
 getLogger().info("Shut down membase client"); 
<|del|>
<|del|>
 }); crv.setOperation(op); addOp(op); return crv; 
 return super.shutdown(duration, units) && cconn.shutdown(); 
 protected void checkState() { 
 if (unit != TimeUnit.MILLISECONDS) { 
 getLogger().debug("Connection open: " + conn); 
 protected View(String dn, String ddn, String vn, boolean m, boolean r) { 
<|del|>
<|del|> 
 private static final String SERVER_URI = "http://" + TestConfig.IPV4_ADDR 
 Thread.sleep(1000); 
 Thread.sleep(1000); 
 Thread.sleep(500); 
<|del|>
 "Unhandled hash algorithm type: " + algorithm); 
 * Asynchronously queries a Couchbase view by calling its map function. This 
 * Asynchronously queries a Couchbase view by calling its map function and 
 * Queries a Couchbase view by calling its map function. This type of query 
 * Queries a Couchbase view by calling its map function and then the views 
 * Copyright (C) 2009-2011 Couchbase, Inc. 
<|del|> 
// if (!authorize(request.getHeader("Authorization"))) { // request.setReasonCode(HttpReasonCode.Unauthorized); // return; // } 
 * Copyright (C) 2009-2011 Couchbase, Inc. 
 * Copyright (C) 2009-2011 Couchbase, Inc. 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALING * IN THE SOFTWARE. 
 createReadOperationQueue(), createWriteOperationQueue(), createOperationQueue(), getOpQueueMaxBlockTime(), doAuth, 
 return opFact.saslAuth(authDescriptor.getMechs(), node.getSocketAddress().toString(), null, authDescriptor.getCallback(), cb); 
 if (level == Level.INFO || level == Level.WARN || level == Level.ERROR 
 rows.add(new RowWithDocs(r.getId(), r.getKey(), r.getValue(), docMap.get(r.getId()))); 
 * <bean id="memcachedClient" * class="net.spy.memcached.utils.MemcachedClientFactoryBean"> 
 validateName(name); validateAlgorithm(alg); REGISTRY.put(name.toLowerCase(), alg); 
 validateName(name); return REGISTRY.get(name.toLowerCase()); 
 throw new UnsupportedOperationException("Reduced views don't contain " + "document ids"); 
<|del|>
<|del|> 
<|del|> 
 ((ViewCallback) callback).gotData(vr); callback.receivedStatus(status); } catch (ParseException e) { exception = new OperationException(OperationErrorType.GENERAL, "Error parsing JSON"); } callback.complete(); } 
 this.query = query.copy(); 
 */ 
 return super.toString() + " Keys: " + StringUtils.join(getKeys(), " "); 
<|del|> 
 this(0, cb); 
 super((byte)0xFF, -1, cb); 
 assert rv != DUMMY_OPCODE : "Unhandled store type: " + t; 
 super(DUMMY_OPCODE, -1, NOOP_CALLBACK); 
 private static byte cmdMap(StoreType t) { byte rv=DUMMY_OPCODE; 
 assert rv != DUMMY_OPCODE : "Unhandled store type: " + t; 
 private static byte cmdMap(StoreType t) { byte rv=DUMMY_OPCODE; 
 for (TapFlag flag : response.getFlags()) { if (flag.flag == TAP_FLAG_ACK) { ((Callback)getCallback()).gotAck(response.getOpcode(), response.getOpaque()); } 
 * Export data stored in HDFS into Membase/Couchbase. 
 LOG.error("Tap stream closing early Reason: " + e.getMessage()); 
<|del|> 
 LOG.error("Tap stream closing early. Reason: " 
 // TODO: This isn't the best way of doing this. In the future // this should be split into mutiple classes. 
 * 
 + "\"clusterMembership\": \"active\"\n," + "\"couchApiBase\": \"http://10.2.1.67:5984/\"\n" 
 assertTrue(Arrays.equals(json.getBytes(), cd.getData())); assertNotSame(SerializingTranscoder.COMPRESSED, cd.getFlags()); 
<|del|> 
 f.get(1, TimeUnit.SECONDS); 
 f.get(1, TimeUnit.SECONDS); 
<|del|>
 if (i == null) { 
 public void enqueueOperation(String key, Operation o) { 
 * Copyright (C) 2009-2012 Couchbase, Inc. 
 @Override 
 * @param bucketName the name of the bucket to tap. * @param usr the buckets username. 
<|del|> 
 @Override 
 * @param bucketName the name of the bucket to tap. * @param usr the buckets username. 
<|del|> 
 // Since return type is Boolean, nothing to do 
 OperationCallback operationCallback); 
 private static final String CMD = "unl"; 
 setArguments(b, CMD, key); 
 return "Cmd: " + CMD + " Key: " + key + " Cas Value: " + cas ; 
<|del|> 
<|del|> 
 return "Cmd: " + CMD + " Key: " + key + " Cas Value: " + cas ; 
<|del|> 
 getLogger().error("Critical reconfiguration error: " + "Server list from Configuration and Nodes " + "are out of synch. causing %s to be removed", 
<|del|> 
 * Holds multiple operations put together for a tap stream. * * A TapStream handles the series of messages coming back from a given node * which is sending data over TAP. The TapClient will typically manage a * set of TapStreams. 
import java.net.Socket; import java.util.Arrays; 
 import org.couchbase.mock.Bucket.BucketType; 
 private class RespawnCommandHandler extends BucketCommandHandler { void doBucketCommand() { 
 public CouchbaseMock(String hostname, int port, int numNodes, int bucketStartPort, int numVBuckets) throws IOException { this(hostname, port, numNodes, bucketStartPort, numVBuckets, null); 
 } } } finally { try { server.close(); selector.close(); 
<|del|> 
 * Copyright 2012 Couchbase, Inc. 
<|del|> 
<|del|> 
 private final Map<String, Bucket> buckets; 
<|del|> 
 System.err.printf("Got exception: %s\n", ex.toString()); 
 Logger.getLogger(CouchbaseMock.class.getName()).log(Level.SEVERE, "Fatal error! failed to create socket: ", e); 
<|del|> 
 Map<MemcachedServer, Boolean> servers_set = new HashMap<MemcachedServer, Boolean>(); for (Bucket bucket : mock.getBuckets().values()) { if (bucket == null) { 
<|del|> 
 throws IOException, ClosedChannelException 
 throw new IllegalArgumentException("Time and offset must be >= 0"); 
 } 
 HttpProcessor httpproc = new ImmutableHttpProcessor(new HttpRequestInterceptor[]{ new RequestContent(), new RequestTargetHost(), new RequestConnControl(), new RequestUserAgent(), new RequestExpectContinue(), }); 
 * Asynchronously queries a Couchbase view and returns the result. * The result can be accessed row-wise via an iterator. This 
 new ImmutableHttpProcessor(new HttpRequestInterceptor[]{ new RequestContent(), new RequestTargetHost(), new RequestConnControl(), new RequestUserAgent(), new RequestExpectContinue(), }); 
 new ImmutableHttpProcessor(new HttpRequestInterceptor[]{ new RequestContent(), new RequestTargetHost(), new RequestConnControl(), new RequestUserAgent(), new RequestExpectContinue(), }); 
 public void startStreaming() throws IOException, InterruptedException { byte[] configBytes; 
 .setParameter(CoreProtocolPNames.USER_AGENT, "Couchbase Java Client 1.0.2"); 
 * 
 static final long MAX_VALUE = 10000; 
 * Copyright (C) 2009-2012 Couchbase, Inc. 
 LOGGER.log(Level.WARNING, "No reconnect required, though check requested." 
 c = new MemcachedClient(new InetSocketAddress(args[0], 11211)); URI base = new URI(String.format("http://%s:8091/pools", args[0])); 
 c = new MemcachedClient(new InetSocketAddress(args[0], 11211)); URI base = new URI(String.format("http://%s:8091/pools", args[0])); 
 * Copyright (C) 2009-2011 Couchbase, Inc. 
 private final HashAlgorithm hashAlgorithm = DefaultHashAlgorithm.NATIVE_HASH; 
 return ErrorCode.UNKNOWN_ERROR; 
 line, ErrorCode.SUCCESS)); 
 * The client received an unknown error code from the server. 
 public Iterator<MemcachedNode> getSequence(String k) { 
 fail("No view response received. ExecutionException: " + e.getMessage()); 
 getLogger().error("No server connections. Cancelling op."); 
<|del|> 
 public static final String CLUSTER_PASS = 
<|del|>
 ObserveResponse r; 
 } 
 ObserveResponse r; 
<|del|>
 c.set(key, 0, value); 
 c.set(key, 0, value); 
 c.set(key, 0, value); 
<|del|> 
<|del|> 
 /** * {@inheritDoc}. */ 
 /** * {@inheritDoc}. */ 
 private static final String SERVER = TestConfig.IPV4_ADDR; 
 } @Test public void testClear() throws URISyntaxException, IOException { CouchbaseCache cbCache = cbCacheManager.getCache("colorsCache"); assertNotNull(cbCache); cbCache.clear(); assertNull((cbCache.get("GREEN").get())); } 
<|del|> 
 c = new CouchbaseClient(cfb.buildCouchbaseConnection(baseList, bucketName, password)); tapClient = new TapClient(baseList, bucketName, password); 
 throw new CouchbaseCacheException("Exception in Couchbase Cache put for " + "key = " + key + "value = " + value, ex); 
<|del|> 
 * Get the View Mode. 
 ArrayList<URI> serverList = new ArrayList<URI>(); 
 * Provide the IP address of the nodes as below to run the test. 
<|del|>
<|del|> 
 resubscriber.run(); assertNotNull(factory.getWaitTime()); 
 configProvider = new ConfigurationProviderHTTP(baseList, REST_USER, REST_PWD); 
 * Copyright 2013 Couchbase, Inc. 
<|del|> 
 * Copyright 2013 Couchbase, Inc. 
<|del|>
 private static final Map<String,Command> commandMap; 
 private static final Map<String,Command> commandMap; 
 private static final Gson gs = new Gson(); 
 public short getVbIndexForKey(String key) { return -1; } 
 if (bucket.getPassword().isEmpty()) { 
 if (!currentBucketName.equals(username)) { 
<|del|> 
 private static final byte[] chunkedDelimiter = { '\n', '\n', '\n', '\n' }; 
 static String getPoolInfoJSON(CouchbaseMock mock) { 
 private final Map<KeySpec, Item> kv = new ConcurrentHashMap<KeySpec, Item>(); 
 private final Map<KeySpec, Item> kv = new ConcurrentHashMap<KeySpec, Item>(); 
 private ErrorCode modifyItemValue(Item i, boolean isAppend) { 
 * @param original The original value passed in from the client. This can * be a relative or absolute (unix) timestamp 
<|del|> 
 private final List<KeySpec> keySpecs = new ArrayList<KeySpec>(); 
 private final List<KeySpec> keySpecs = new ArrayList<KeySpec>(); 
 private static final Map<String,Class> commandMap = new HashMap<String, Class>(); private static final Map<HarakiriCommand.Command, Class> classMap 
 private static final Map<String,Class> commandMap = new HashMap<String, Class>(); private static final Map<HarakiriCommand.Command, Class> classMap 
 private static void registerClass(HarakiriCommand.Command cmd, Class cls) { 
 public HarakiriCommand getCommand(PayloadFormat fmt, String cmdstr, Object payloadObj) { 
 private static final Map<String,Object> helpInfo = new HashMap<String, Object>(); 
 if (!parts[0].equals("Basic")) { 
 private static class InvalidQueryException extends Exception { } private class WantHelpException extends Exception { } 
 private static void sendHelpText(HttpExchange exchange, int code) throws IOException { 
 private static final byte[] chunkedDelimiter = { '\n', '\n', '\n', '\n' }; 
public class KeyInfoRequest extends MockRequest { public KeyInfoRequest(@NotNull String key) { this(key, ""); 
 } 
<|del|>
 Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); 
<|del|> 
 private ExecutorService service = DefaultConnectionFactory.DEFAULT_LISTENER_EXECUTOR_SERVICE; 
 * Copyright (C) 2009-2011 Couchbase, Inc. 
<|del|> 
<|del|> 
<|del|> 
 CouchbaseNodeOrder.RANDOM; 
 getLogger().warn("Could not add node to updated bucket list because " 
 return config.nodeHasActiveVBuckets(node.getSocketAddress()); 
 executorService = new ThreadPoolExecutor( 0, Runtime.getRuntime().availableProcessors(), 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>() ); 
<|del|> 
<|del|> 
 /** * Add a {@link GetFuture} to mointor. * * Note that this method is for internal use only. * * @param future the future to monitor. */ 
<|del|> 
import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.List; import java.util.Random; 
 /** * Get the node locator used by this connection. */ NodeLocator getLocator() { return locator; } 
 ioReactor = new DefaultConnectingIOReactor(IOReactorConfig.custom() .setConnectTimeout(connectionTimeout) .setSoTimeout(socketTimeout) .setTcpNoDelay(tcpNoDelay) .setIoThreadCount(ioThreadCount) .build()); 
 public void createDefaultBucket(BucketType type, int memorySizeMB, int replicas, boolean flushEnabled) { 
 * @param flushEnabled whether flush is enabled. 
 }, "Couchbase ClusterManager Thread"); 
 getLogger().warn("No View nodes are present, this could be a bug or " + "no node has vBuckets attached."); 
 && (body.contains("missing") || body.contains("deleted"))) { LOGGER.debug("Design Document not found, body: " + body); 
 && body.contains("{not_found, missing_named_view}")) { LOGGER.debug("Design Document not found, body: " + body); 
<|del|> 
<|del|>
<|del|> 
 cf = new CouchbaseConnectionFactory(uris, "SaslBucket", "SaslBucket"); 
 Set<?> authMechanism = saslClient.listSaslMechanisms(); 
 atm.authConnection(mconn, opFact, authDescriptor , node); String[] saslMechs = AuthThreadMonitor.saslMechs; double serverVersion = getServerVersion(); 
 + "Staying with old one.", ex); getLogger().debug("Problematic config is:" + config); 
 throw new IOException("Could not locate URIs from DNS SRV.", ex); 
 assertEquals(saslMechs[0],"PLAIN"); assertTrue(saslMechs.length==1); 
 assertEquals("PLAIN", saslMechs[0]); assertEquals(1, saslMechs.length); 
 assertEquals("PLAIN", saslMechs[0]); assertEquals(1, saslMechs.length); 
 getLogger().info("Could bootstrap through carrier publication."); 
 synchronized (seedNodes) { seedNodes.clear(); seedNodes.addAll(newNodes); } 
 getLogger().info("Could not load config from existing " 
<|del|> 
 return "{OperationStatus success=" + isSuccess + ": " + message + "}"; 
 return ERR_CLIENT; 
 return ERR_CLIENT; 
import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationErrorType; import net.spy.memcached.ops.OperationState; import net.spy.memcached.ops.OperationStatus; import net.spy.memcached.ops.StatusCode; 
 static final byte REPLICA_GET_CMD = (byte)0x83; 
 * Helper method which collects all currently set arguments. 
 assertEquals("?key=0.123", result); 
 assertEquals("?group_level=2&group=true", query.toString()); 
<|del|> 
 + "complete on node " + this); 
 reconnectQueue.put(reconTime, qa); 
 long now = TimeUnit.NANOSECONDS.toSeconds(System.nanoTime()); if (lastWrite != now) { lastWrite = now; } 
 final ByteBuf extrasReleased = msg.getExtras(); final ByteBuf extras = ctx.alloc().buffer(msg.getExtrasLength()); extras.writeBytes(extrasReleased, extrasReleased.readerIndex(), extrasReleased.readableBytes()); 
<|del|> 
 * @author Sergey Avseyev * @since 2.0 
 public boolean stopOnError() { 
 * Copyright (C) 2014 Couchbase, Inc. 
public enum BootstrapProviderType { /** * No bootstrap provider has been specified */ NONE, /** * Configuration Carrier Publication Protocol (CCCP) */ 
 + "\" (carrier publication: " + bootstrapProvider.isCarrier() + "): " + config); 
 while (bootstrapProvider.isCarrier() && getConfig().getConfig().isTainted()) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * A RuntimeException being thrown whenever an operation on a {@link Bucket} * that has been {@link Bucket#close() closed} is attempted. * * @author Simon Basl * @since 2.0.1 
 * A RuntimeException being thrown whenever an operation on a {@link Bucket} * that has been {@link Bucket#close() closed} is attempted. * * @author Simon Basl * @since 2.0.1 
 * Flag method to auto release decoded buffers. Override to change default behaviour (true). 
 * Converts a {@link ByteBuf} to a {@link JsonObject}, <b>without releasing the buffer</b> * 
 ByteBuf content = Unpooled.copiedBuffer("false", CharsetUtil.UTF_8); 
 ByteBuf content = Unpooled.copiedBuffer("1.7976931348623157E308", CharsetUtil.UTF_8); 
 ByteBuf content = Unpooled.copiedBuffer("9223372036854775807", CharsetUtil.UTF_8); 
 ByteBuf content = Unpooled.copiedBuffer("\"value\"", CharsetUtil.UTF_8); 
<|del|> 
<|del|> 
 if (items == null) { throw new NullPointerException("Null list unsupported"); } else if (items.isEmpty()) { 
<|del|> 
import io.netty.util.concurrent.Future; import io.netty.util.concurrent.GenericFutureListener; 
 return null; 
 done.set(true); // Connection is shutting down, tear.down. return null; 
 * * The returned {@link Observable} can error under the following conditions: * 
<|del|> 
 throw new IllegalStateException("Node not found for request" + request); 
 return null; 
 SSL(3, 0, 0), DCP(3, 0, 0), N1QL(3, 5, 0), 
 int endOfId = bytesBefore('"'); ByteBuf slice = responseContent.readSlice(endOfId); 
 if (responseContent.readableBytes() >= MINIMUM_WINDOW_FOR_CLIENTID_TOKEN && bytesBefore(':') < MINIMUM_WINDOW_FOR_CLIENTID_TOKEN) { 
 if (channel.isWritable()) { 
 private AsyncSubject<String> queryStatusObservable; 
<|del|> 
 * Note that this relies on {@link #getMinVersion()}. If said method returns {@link Version#NO_VERSION} then the 
 * Returns the smallest node version (thus oldest version) in the cluster from which this {@link ClusterInfo} was * taken. If list of version cannot be obtained then this returns {@link Version#NO_VERSION}. 
 Version minVersion = versions.get(0); 
 } catch (Exception e) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("Could not obtain cluster list of versions", e); } 
<|del|> 
 (CouchbaseResponse) new GetBucketConfigResponse(ResponseStatus.FAILURE, "bucket", Unpooled.EMPTY_BUFFER, host) 
 dcpEnabled = booleanPropertyOr("dcpEnabled", builder.dcpEnabled()); 
 * {@link OpenConnectionRequest} have to be broad casted. 
 super(hostname, bucket, password, port, env, NUM_ENDPOINTS, STRATEGY, responseBuffer, FACTORY); 
 List<DCPRequest> rest = addStream.stream() 
 request = new MutationMessage(msg.getStatus(), msg.getKey(), msg.content().retain(), 
 * Note that they can flow in both directions. For example, {@link ConnectionType#CONSUMER} * connection, means that messages will flow from server to client. 
 this.tainted = forwardPartitions != null && !forwardPartitions.isEmpty(); 
 @JsonProperty("nodesExt") List<PortInfo> portInfos) { super(name, BucketNodeLocator.VBUCKET, uri, streamingUri, nodeInfos, portInfos); 
<|del|> 
 transitionState(zipWith(currentStates)); 
 class InstrumentedService extends AbstractPoolingService { 
 public boolean queryEnabled() { return queryEnabled; 
 public void put(Item item, VBucketCoordinates coords) { 
 subscriber.onError(new IllegalStateException("This Observable can only have one subscription. " + "Use Observable.publish() if you want to multicast.")); 
 content = ctx.alloc().buffer(splitIfPostNeeded.value2().length()); content.writeBytes(splitIfPostNeeded.value2().getBytes(CHARSET)); 
 private AsyncSubject<String> queryStatusObservable; 
 * The time in milliseconds after which a non-subscribed observable is going to be automatically released. 
<|del|> 
 state.bufferedSubject.onNext(t); 
 private KetamaNodeKeyFormatter.Format ketamaNodeKeyFormat; 
 * Note that if the hostname is null (not provided by the server), it is explicitly set to null because otherwise 
 * A {@link CouchbaseException} that denotes that a retry cycle failed because the maximum allowed attempt * count was reached. 
 /** Make at most maxAttempts retry attempts */ public RetryBuilder max(int maxAttempts) { this.maxAttempts = maxAttempts; 
 /** Make at most maxAttempts retry attempts */ public RetryBuilder max(int maxAttempts) { this.maxAttempts = maxAttempts; 
 public RetryBuilder delay(Delay delay) { 
 return Observable.error(error); 
 * Returns an expression representing NULL. 
 * Returns an expression representing MISSING. 
 if (newConfig.password() == null && oldConfig != null) { newConfig.password(oldConfig.password()); 
 public static Sort def(final Expression expression) { 
 */ @InterfaceStability.Experimental @InterfaceAudience.Public 
<|del|> 
 return EMPTY_INSTANCE; 
 */ @InterfaceStability.Experimental @InterfaceAudience.Public 
 } public static Expression round(Number expression) { return round(x(expression)); } public static Expression round(Number expression, int digits) { return round(x(expression), digits); } 
 public void shouldCheckStreamListBoundsOnSet() throws Exception { 
 public void shouldNotCheckStreamListBoundsOnGet() throws Exception { 
<|del|> 
 public static final BucketStreamAggregatorState BLANK = new BucketStreamAggregatorState(0); private final BucketStreamState[] feeds; 
 feeds[partition] = state; 
 * @author Sergey Avseyev * @since 1.2.0 
 * Consumes {@link CouchbaseEvent}s and logs them into a bucket as JSON. 
 private final byte[] keyBytes; 
 this.keyBytes = key == null || key.isEmpty() ? new byte[] {} : key.getBytes(CharsetUtil.UTF_8); 
 * @since 1.2 
 super(key, bucket, null, ReplaySubject.<CouchbaseResponse>create(1024).toSerialized()); 
 String key = msg.key(); short keyLength = (short) msg.keyBytes().length; 
 private static BinaryMemcacheRequest handleStatRequest(StatRequest msg) { 
 private static CouchbaseResponse handleOtherResponseMessages(BinaryRequest request, FullBinaryMemcacheResponse msg, ResponseStatus status, boolean seqOnMutation, String remoteHostname) { 
 * Main synchronous entry point to a Couchbase Cluster. 
 * Named Params: 
 break; case EVERYTHING: start = 0; end = 0xffffffff; break; 
public enum Direction { /** * Start from the earliest point in history and * stop, when current view has reached. */ 
 String statement = "SELECT sum(c1) FROM `" + ctx.bucketName() + "`"; 
 LOGGER.info(indexedBucket + " created and opened"); List<IndexInfo> initialIndexes = indexedBucket.bucketManager().listIndexes(); assertEquals("Newly created bucket unexpectedly has indexes: " + initialIndexes, 0, initialIndexes.size()); 
 private volatile DCPConnection connection = null; 
 if (connection.get() == null) { 
 * The {@link Observable} can error under the following conditions: 
<|del|> 
 this.arrayOp = arrayOp; if (path.isEmpty() && arrayOp == ArrayOperation.INSERT) { cleanUpAndThrow(EXCEPTION_EMPTY_PATH); } 
 super(key, path, deltaToFragment(delta), bucket, expiration, cas); if (path.isEmpty()) { cleanUpAndThrow(EXCEPTION_EMPTY_PATH); } 
 super(key, path, fragment, bucket, expiration, cas); if (path.isEmpty()) { cleanUpAndThrow(EXCEPTION_EMPTY_PATH); } 
 super(key, path, bucket); if (path.isEmpty()) { cleanUpAndThrow(EXCEPTION_EMPTY_PATH); } 
 super(key, path, bucket); if (path.isEmpty()) { cleanUpAndThrow(EXCEPTION_EMPTY_PATH); } 
 super(key, path, fragment, bucket, expiration, cas); if (path.isEmpty()) { cleanUpAndThrow(EXCEPTION_EMPTY_PATH); } 
 return insertInto(i(bucket)); 
 return upsertInto(i(bucket)); 
 return deleteFrom(i(bucket)); 
 return update(i(bucket)); 
 @Override public DocumentFragment<T> call(SimpleSubdocResponse response) { //empty response for mutations if (response.content() != null && response.content().refCnt() > 0) { response.content().release(); } 
public class DocumentFragment<T> implements IDocumentFragment<T> { 
public class DocumentFragment<T> implements IDocumentFragment<T> { 
public enum ExtendDirection { /** * Extend the array by placing the value at the front of the array (index 0). */ 
 private LookupSpec(Lookup type, String path) { 
 * Represents a successful multi-mutation. This object allows to retrieve the CAS 
 private MutationSpec(Mutation type, String path, T fragment, boolean createParents) { 
 public static <T> MutationSpec addUnique(String path, T value, boolean createParents) { return new MutationSpec<T>(Mutation.ARRAY_ADD_UNIQUE, path, value, createParents); 
 * The value is interpreted as 64 bit on the server side so the acceptable range * is that of Java's long ({@link Long#MIN_VALUE} to {@link Long#MAX_VALUE}). 
 private static final int MINIMUM_HEADER_SIZE = 24; 
 if (!query.isIncludeDocs()) { return observable.concatMap(buildAsyncViewRow()); } else if (query.isRetainOrder()) { 
 private String clientFirstMessage; private String clientFirstMessageBare; private String clientFinalMessageNoProof; private String serverFirstMessage; private String serverFinalMessage; 
 throw new SaslException("Missing callback fetch password", e); 
 byte[] serverKey = hmac(saltedPassword, SERVER_KEY); 
 throw new IllegalArgumentException("At least one Document needs to be provided."); 
 throw new IllegalArgumentException("At least one DocumentFragment needs to be provided."); 
 "Document ID fallback for AT_PLUS not yet supported. ID: " + id); 
<|del|> 
 private void assertMutationWithExpiry(String expiredKey, MutateInBuilder builder, int expirySeconds) throws InterruptedException { 
<|del|>
 private Observable<DocumentFragment<Lookup>> existsIn(final String id, final String path) { 
 * dispatches the request into them. 
 // FIXME: preserve context to allow consumer to signal about progress. 
 * @since 1.2.6 
 * @since 1.2.6 
 * @since 1.2.6 
 /*package*/ void consumed(final FullBinaryMemcacheResponse response) { 
 public void shouldUseFlowControl() throws InterruptedException { 
 seedNode = System.getProperty("seedNode", "127.0.0.1"); 
 * @author Sergey Avseyev * @since 1.2.6 
 @Override public int viewEndpoints() { return viewServiceEndpoints; 
 * Once the channel is marked as active, the open DCP connection. 
 * Dispatches incoming OPEN_CONNECTION responses and also initialize flow control. 
 this.mutationSpecs.add(new MutationSpec(Mutation.DICT_ADD, path, fragment, createParents)); 
 if (documents == null || documents.length == 0) { 
 if (documentFragments == null || documentFragments.length == 0) { 
 tokenIterator.set(token); 
 * @since 1.3.0 
 * @since 1.3.0 
 * 
 protected void checkRange(String name, Double min, Double max) { 
 private int min = -1; 
 this.terms = new ArrayList<String>(); 
public interface SearchQueryResult extends Iterable<SearchQueryRow> { 
 @InterfaceStability.Experimental @InterfaceAudience.Private public abstract class AbstractFacetResult implements FacetResult { 
 //note: it is not expected that multiple threads concurrently add a HitLocation, as even a //streaming parser would parse a single hit in its entirety, not individual locations. 
<|del|>
public abstract class AbstractStringAwareBufProcessor { 
 disruptorThreadFactory 
 public boolean queryEnabled() { return queryEnabled; 
 protected static final int KEEPALIVE_INTERVAL = 1000; 
 for (String path : paths) { if (StringUtil.isNullOrEmpty(path)) { throw new IllegalArgumentException("Path is mandatory for subdoc get"); } 
<|del|> 
<|del|> 
<|del|> 
 public Builder createBucketIfMissing(boolean createIfMissing) { 
 public Builder sampleBucket(String sampleName) { 
 this.timeout, TIMEOUT_UNIT); //uses the management timeout as default for API calls as well 
@InterfaceAudience.Private 
 public String login() { 
 public String password() { 
 BUCKET_KV, BUCKET_VIEW, BUCKET_N1QL, BUCKET_FTS, CLUSTER_N1QL, CLUSTER_FTS, BUCKET_MANAGEMENT, CLUSTER_MANAGEMENT; 
 * @since 1.3 
 protected volatile int skip = 0; 
 cluster.openBucket(null); 
 Bucket bucket = ctx.cluster().openBucket("travel-sample"); 
<|del|> 
<|del|> 
<|del|>
<|del|>
 } catch (AuthenticatorException e) { 
 return openBucket(name, environment.connectTimeout(), TIMEOUT_UNIT); 
 List<Credential> getCredentials(CredentialContext context, String specific); /** * @return true if this {@link Authenticator} doesn't have any credentials set. */ boolean isEmpty(); 
<|del|> 
<|del|> 
<|del|> 
 * This method throws under the following conditions: 
 releasePauseDetector(); } 
 int offset = (int) MathUtils.floorMod(counter++, nodeSize); 
 this.sentQueueLimit = Integer.parseInt(System.getProperty("com.couchbase.sentRequestQueueLimit", "5120")); 
<|del|> 
 ctx.bucket().mapGet("dsmap", "9999", String.class); 
 @Test(expected = RequestTooBigException.class) 
 * Add a key value pair into CouchbaseMap * * If the underlying document for the map does not exist, this operation will create a new document to back * the data structure. * 
 private static final int MAX_CAS_RETRIES_DATASTRUCTURES = Integer.parseInt(System.getProperty("com.couchbase.datastructureCASRetryLimit", "10")); 
 * MutationOptionBuilder allows to set following constraints on data structure mutation operations * 
 * @author Subhashni Balakrishnan * @since 2.3.5 
 private int expiry; private long cas; private PersistTo persistTo; private ReplicateTo replicateTo; 
 public static MutationOptionBuilder builder() { 
 public MutationOptionBuilder expiry(int expiry) { 
 public MutationOptionBuilder cas(long cas) { this.cas = cas; 
 private boolean createDocument; 
 public MutationOptionBuilder createDocument(boolean createDoc) { 
 public boolean createDocument() { 
 super(); 
<|del|> 
<|del|> 
 public DesignDocumentDoesNotExistException() { super(); } 
 public DesignDocumentDoesNotExistException() { super(); } 
 * @since 2.4.0 
<|del|> 
 super(minEndpoints, maxEndpoints, true, NO_IDLE_TIME); 
 return create(minEndpoints, maxEndpoints, DEFAULT_IDLE_TIME); 
 boolean enableV2 = Boolean.parseBoolean(System.getProperty("com.couchbase.enableYasjlQueryResponseParser", "false")); 
 final private YasjlQueryResponseParser parser; 
public class YasjlQueryResponseParser { 
 createResponse(); LOGGER.trace("Started receiving results for requestId {}", requestID); 
 tree.addJsonPointer(jp); //ignores if the json pointers were actually inserted, whatever is valid gets inserted 
 throw new IllegalStateException("Invalid json, json object can only be a hash value not key"); 
 this.stProcessor = stProcessor; reset(); 
 BOM //byte order mark 
 public static boolean isNumber(final byte value) { 
 return ServiceType.ANALYTICS; 
 DcpChannel theChannel = channels.get(node.hostname()); if (theChannel == null) { 
 DcpChannel theChannel = channels.get(node.hostname()); if (theChannel == null) { 
 LOGGER.log(Level.WARN, "Rollback for a vbucket. abort"); 
 LOGGER.log(Level.WARN, "Rollback for a vbucket. abort"); 
 // Preparing to rebalance, update the config // get the new master for the partition and resume from there 
 // Preparing to rebalance, update the config // get the new master for the partition and resume from there 
 LOGGER.log(Level.WARN, "Need more analytics ingestion nodes. we are slow for the producer node"); 
 return Collections.unmodifiableList(failoverLog); 
<|del|> 
 * index of more recent history entry > index of less recent history entry 
 LOGGER.warn("Failed to re-establish a failed dcp connection. Must notify the client", th); 
 fail("Expected exception, none thrown."); 
 return "DcpChannel{inetAddress=" + inetAddress + ", state=" + state + '}'; 
 } fixerThread = null; 
 inbox.addAll(failed); failed.clear(); 
 giveUp(streamEndEvent, e); 
 return registerBucket(name, name, password); 
 Thread.sleep(100); //sleep a bit for the user to be async updated to memcached before opening bucket 
<|del|> 
<|del|> 
 if (this.authenticator instanceof PasswordAuthenticator) { return Observable.error(new MixedAuthenticationException("Mixed mode authentication not allowed, use Bucket credentials or User credentials (rbac)")); 
 final private String username; final private String password; 
 final private String name; final private String userId; final private String type; final private UserRole[] roles; 
 public UserRole(String role) { this.role = role; this.bucket = ""; } 
 System.err .println("Need more analytics ingestion nodes. we are slow for the producer node"); 
 return "{\"" + DcpEvent.class.getSimpleName() + "\":\"" + getClass().getSimpleName() + "\",\"exception\":\"" + cause.toString() + "\"}"; 
 return "{\"" + DcpEvent.class.getSimpleName() + "\":\"" + getClass().getSimpleName() + "\",\"exception\":\"" + cause.toString() + "\"}"; 
 return "{\"" + DcpEvent.class.getSimpleName() + "\":\"" + getClass().getSimpleName() + "\",\"exception\":\"" + cause.toString() + "\"}"; 
 return "{\"" + DcpEvent.class.getSimpleName() + "\":\"" + getClass().getSimpleName() + "\",\"vbid\":" + vbid + ",\"seq\":" + seq + "}"; 
 return "{\"" + DcpEvent.class.getSimpleName() + "\":\"" + getClass().getSimpleName() + "\",\"vbid\":" + vbid + ",\"seq\":" + seq + "}"; 
 */ @InterfaceStability.Experimental @InterfaceAudience.Public 
<|del|> 
 if (nodeInfo.hostname().equals(convertedHost) && (nodeInfo.services().get(ServiceType.BINARY) == directPort || directPort == 0)) { 
 if (request.getExtras() != null && request.getExtras().refCnt() > 0) { try { request.getExtras().release(); } catch (Exception e) { //ignore } } 
 if (request.getExtras() != null && request.getExtras().refCnt() > 0) { try { request.getExtras().release(); } catch (Exception e) { //ignore } } 
 controlEventHandler.onEvent(this, message); 
 public ClientEnvironment build() { return new ClientEnvironment(this); 
 public ClientEnvironment build() { return new ClientEnvironment(this); 
 public static final byte SELECT_BUCKET_OPCODE = (byte) 0x89; 
 * The username (used for http auth). 
 + toString(step) + " step, response status is " + status)); 
 case VERSION: 
 "Unauthorized - Incorrect credentials or bucket " + bucket + " does not exist"); 
<|del|> 
 private final Set<NetworkAddress> clusterNodes; 
<|del|> 
 if (NetworkAddress.ALLOW_REVERSE_DNS) { 
<|del|> 
 public static ResponseStatus fromBinary(final short code) { 
 private final Map<Short, ErrorCode> errors; 
 LOGGER.debug("ResponseStatus with Extended Error Code {}", errorCode.toString()); 
<|del|> 
 public static KeyValueStatus valueOf(final short code) { 
 if(!request.isActive()) { 
 @InterfaceAudience.Private boolean isActive(); 
 @InterfaceAudience.Private void subscriber(Subscriber subscriber); 
 ctx.close(); 
 public InetSocketAddress getAddress() { 
 if (config.hasPrimaryPartitionsOnNode(channel.getAddress().getAddress())) { 
 Set<Integer> ports = sockets.get(address.getHostAddress()); if (ports == null) { ports = new HashSet<>(); sockets.put(address.getHostAddress(), ports); } ports.add(port); 
 Set<Integer> ports = sockets.get(hostname); if (ports == null) { ports = new HashSet<>(); sockets.put(hostname, ports); } ports.add(port); 
 exception = new CouchbaseException("Bucket " + bucket + " does not exist"); 
 && hasPrimaryPartition(config, channel.getAddress())) { 
 && hasPrimaryPartition(config, channel.getAddress())) { 
 public User getUser(AuthDomain domain, String userid) { return Blocking.blockForSingle(asyncClusterManager.getUser(domain, userid).single(), timeout, TIMEOUT_UNIT); 
 if ((dataType & JSON_DATATYPE) != 0) { 
 private volatile Subscriber subscriber; 
 @InterfaceAudience.Private @InterfaceStability.Uncommitted 
 @InterfaceAudience.Private @InterfaceStability.Uncommitted 
 if (!subscription.isUnsubscribed()) { subscription.unsubscribe(); } 
 new IllegalStateException("Only AsyncSubject is allowed with deferAndWatch (is " + o.getClass().getSimpleName() + ")"), s); 
<|del|> 
<|del|> 
 byte[] inputBytes = input.array(); int offset = input.arrayOffset() + input.readerIndex(); 
 * to operating on a soft-deleted document. 
 if (queryRowClosingPositionProcessor == null) { 
 // Disconnect succeeded but connect failed LOGGER.log(CouchbaseLogLevel.WARN, "Dead connection detected, channel was disconnected successfully but connecting failed. Creating a channel dropped event", e); 
<|del|> 
 DISCONNECT 
 ctx.ignoreIfClusterUnder(new Version(5, 0, 0)); 
 } @Test(expected = PathMismatchException.class) public void shouldFailSingleLookupGetCountOnPrimitiveError() { ctx.ignoreIfClusterUnder(new Version(5, 0, 0)); ctx.bucket().lookupIn(key).getCount("boolean").execute(); } 
 * 
 } boolean seenNonXattr = false; 
 return lockedError(xerrorEnabled); 
<|del|> 
<|del|> 
 private static final int VERSION = 0; // 0 because this is experimental right now. 
 /** * True if X.509 client certificate authentication is enabled. */ @InterfaceStability.Uncommitted @InterfaceAudience.Public boolean certAuthEnabled(); 
 failPrepared = payload.get("fail_prepared").getAsBoolean(); 
 assertEquals(OPCODE, request.getOpcode()); 
 assertEquals(OPCODE, request.getOpcode()); 
<|del|> 
 public FlowControlCallback flowControlCallback() { return flowControlCallback; 
 public Builder setFlowControlCallback(final FlowControlCallback flowControlCallback) { this.flowControlCallback = flowControlCallback; 
 if (env.flowControlCallback() != null) { env.flowControlCallback().bufferAckWaterMarkReached(this, dcpChannel, ackCounter, ackWatermark); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 inbox.addAll(failed); failed.clear(); 
 * Handles a byte array as the document value. 
 throw new IllegalStateException("At least either a KeyStore or a TrustStore " + 
 } else if (ks == null) { 
 } else if (ks == null) { 
 * the number of attempts to refresh the configurations. if 0, will use configured max attempts value * @param waitBetweenAttempts * the time to wait between attempts 
 private boolean tryConnectHost(NetworkAddress hostname, Integer port, int timeout, int attempts, long waitBetweenAttempts) throws Exception { 
 while (next != POISON_PILL) { fix(next); next = inbox.take(); 
 if (env.flowControlCallback() != null) { env.flowControlCallback().bufferAckWaterMarkReached(this, dcpChannel, ackCounter, ackWatermark); 
 * @deprecated Please use {@link #createPath(boolean)} instead, this method will be removed * in the next major version. 
 * @deprecated Please use {@link #createPath()} instead, this method will be removed * in the next major version. 
 if (errorInterruptingPredicate != null && Boolean.TRUE.equals(errorInterruptingPredicate.call(error))) { 
 if (cause instanceof BadBucketConfigException) { Thread.sleep(BAD_CONFIG_WAIT_TIME); } else { Thread.sleep(waitBetweenAttempts); } 
 if (cause != null && !(cause instanceof SocketException)) { 
 public synchronized void configure(CouchbaseBucketConfig config) { 
 redacted[i] = "-REDACTED-"; 
<|del|> 
 LOGGER.info("{}Could not complete config stream, scheduler shut " + "down already.", logIdent(ctx, endpoint())); 
 LOGGER.warn("Unknown index type {} for index {}", rawType, meta(name)); 
 sessionState = new SessionState(config.numberOfPartitions()); } else { sessionState.setConnected(); 
 // memcached process down? Thread.sleep(Long.min(Math.abs(50 << attempt), timeout)); 
 final Set<ServiceType> typeSet = EnumSet.copyOf(Arrays.asList(types)); 
 public static final int BOOTSTRAP_HTTP_SSL_PORT = 18091; public static final int DCP_DIRECT_PORT = 11210; public static final int DCP_SSL_PORT = 11207; 
 public static final int BOOTSTRAP_HTTP_SSL_PORT = 18091; public static final int DCP_DIRECT_PORT = 11210; public static final int DCP_SSL_PORT = 11207; 
 public String username() { return username; 
 request.setDataType((byte)(request.getDataType() | DATATYPE_SNAPPY)); 
<|del|> 
 HashMap<String, String> result = new HashMap<String, String>(); result.put("a", agent); result.put("i", id); return JACKSON.writeValueAsBytes(result); 
 return String.format("%016X", number); 
 if (environment.encryptionEnabled()) { 
 CrytoProvider provider = this.encryptionConfig.getCryptoProvider(alg); if (provider == null && provider.getKeyName().contentEquals(key)) { 
 this.encryptionPathInfo.put(name, encryptionProvider); content.put(name, null); 
<|del|> 
 * Copyright (c) 2018 Couchbase, Inc. 
 byte[] encrypted = cipher.doFinal(data); 
 return cipher.doFinal(data); 
 return "CUSTOM"; 
 LOGGER.log(Level.DEBUG, "Received Config: {}", rawConfig); 
 Set<Integer> ports = sockets.computeIfAbsent(address, arg -> new HashSet<>()); 
 private boolean tryConnectHost(NetworkAddress hostname, int port, long attemptTimeout, long totalTimeout, 
 if (LOGGER.isInfoEnabled()) { LOGGER.log(CouchbaseLogLevel.INFO, "Getting bucket config from {}:{}", hostname.nameOrAddress(), port); } 
 if (elapsed(startTime, totalTimeout)) { 
 Set<Integer> ports = sockets.computeIfAbsent(address, args -> new HashSet<>()); 
 return System.nanoTime() - startTimeNano >= (timeoutMillis * 1000000); 
 return System.nanoTime() - startTimeNano >= TimeUnit.MILLISECONDS.toNanos(timeoutMillis); 
 LOGGER.log(Level.INFO, "Getting bucket config from {}:{}", hostname.nameOrAddress(), port); 
 this.allHosts = parseHosts(input); this.hosts = tryResolveHosts(this.allHosts); 
<|del|> 
 .cacheWithInitialCapacity(type.maxAffectedNodes()); 
 LOGGER.log(Level.DEBUG, "Received Config: {}", rawConfig); 
 public static final int MIN_COMPRESSION_SIZE = 32; public static final double MIN_COMPRESSION_RATIO = 0.9; 
 public static final int MIN_COMPRESSION_SIZE = 32; public static final double MIN_COMPRESSION_RATIO = 0.9; 
 minCompressionRatio = doublePropertyOr("compressionMinRatio", builder.minCompressionRatio); minCompressionSize = intPropertyOr("compressionMinSize", builder.minCompressionSize); 
import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.Map; 
<|del|> 
 private JsonBinaryDocument convert(SinkRecord record) { 
 UPDATE, UPSERT; 
 statement.append(String.format("UPDATE `%s` USE KEYS $%s SET ", keySpace, idField)); 
 return result.substring(0, result.length() - 2) + " RETURNING meta().id;"; 
 statement.append(String.format("UPSERT INTO `%s` (KEY,VALUE) VALUES ($%s, ", keySpace, idField)); 
 if(createDocuments && throwable instanceof DocumentDoesNotExistException) { 
 for (String name : values.getNames()) { statement.append(String.format("%s = $%s, ", name, name)); 
 LOGGER.warn("OpenStream unexpected response: {} (0x{}) for vbucket ", MemcachedStatus.toString(status), Integer.toHexString(status), vbid); 
 LOGGER.warn("FailoverLog unexpected response: {} (0x{}) for vbucket ", MemcachedStatus.toString(status), Integer.toHexString(status), vbid); 
<|del|> 
 client.connect().await(30, TimeUnit.SECONDS); 
 public void upsert(String bucket, String documentId, String documentBodyJson) { // todo Open the bucket once on startup? 
 pathSplit[i] = path.replace("~1", "/").replace("~0", "~"); 
 String keyName = config.getEncryptionKey() != null ? config.getEncryptionKey() : provider.getKeyName(); 
 * Specifies if there should be a profile section returned with the request results. * @see <a href="https://developer.couchbase.com/documentation/server/current/monitoring/monitoring-n1ql-query.html">Monitoring N1QL Queries</a> 
@InterfaceStability.Committed @InterfaceAudience.Public 
 public long mutationCas() { if (cas == null) { throw new IllegalStateException("Mutation CAS not available"); } 
 + "Need to open a new Endpoint (current size {})", endpoints.size()); 
 short[] vbuckets = vbuckets(); for (int i = 0; i < vbuckets.length; i++) { short next = vbuckets[i]; 
 private static List<Field> getAllDeclaredFields(final Class<?> sourceEntity) { 
 dataEventHandler.onEvent(ackHandle, event, uuidChanged ? ps.getUuidChangeEvent() : null); 
<|del|> 
 public boolean hasBucketUuidChanged(long seqno) { 
 seqno = streamRequest.getStartSeqno(); uuid = streamRequest.getVbucketUuid(); 
<|del|>
<|del|> 
 LOGGER.warn("New Configuration doesn't contain any config nodes {}.", config); throw new BadBucketConfigException("New Configuration doesn't contain any config nodes"); 
 String terseUri = "/pools/default/b/" + bucket + (uuid.isEmpty() ? uuid : ('?' + Conductor.KEY_BUCKET_UUID + uuid)); 
<|del|> 
 @Override public String toString() { StringBuilder sb = new StringBuilder("Backpressure, ringbuffer contains "); sb.append(diagnostics == null ? "unavailable" : diagnostics.toString()); return sb.toString(); } 
 private String determineNetworkResolution(final BucketConfig config) { 
<|del|> 
 @Argument(index = 1) @Option(name = "--", metaVar = "metaVar_path", multiValued = true, handler = StopOptionHandler.class) private List<String> paths = new ArrayList<String>(); 
 nativeLoadError = e; 
 public static final Throwable getNativeImplementationLoadException() { return nativeLoadError; 
 * the underlying file system. Other than stat() for symbolic links it * returns the data for the symbolic link and not for the file the link * points at * * @param fs * file system abstraction 
 System.loadLibrary("jgitnative"); 
 FSAccessNative() { // empty 
 public long getSize() { return size; 
 * * TODO: To be replaced by java.nio.file.AccessDeniedException as soon as Java 7 * is our minimum supported platform 
 * * TODO: To be replaced by java.nio.file.AccessDeniedException as soon as Java 7 * is our minimum supported platform 
 super(MessageFormat.format(JGitText.get().accessFileDenied, file, other, reason)); 
<|del|> 
 * 
 long sz = file.length(); if (sz < 0) throw new NoSuchFileException(file.getAbsolutePath()); return new LStat(file.lastModified(), mode, sz); 
 throw new IllegalArgumentException( JGitText.get().lstatImplIllegalResult); 
 size = (((long) rawlstat[9]) << 32) + rawlstat[10]; 
 * TODO: To be replaced by java.nio.file.NoSuchFileException as soon as Java 7 * is our minimum supported platform 
 super(MessageFormat.format(JGitText.get().noSuchFile, file, other, reason)); 
 * * TODO: To be replaced by java.nio.file.NotDirectoryException as soon as Java 7 * is our minimum supported platform 
 String path = file.getPath(); 
 public Map<AnyObjectId, List<ObjectId>> getGrafts() throws IOException; 
 Map<AnyObjectId, List<ObjectId>> grafts = walk.getGrafts(); if (grafts != null && grafts.size() > 0) { List<ObjectId> graftedParents = grafts.get(getId()); 
 private Map<AnyObjectId, List<ObjectId>> grafts; 
 Object b = scan(table.get(slot(key, position)), key, position); 
<|del|> 
<|del|> 
 * Copyright (c) 2010, SAP AG * 
<|del|> 
 locationPage = new LocationPage(pageTitle, pageTitle, UIIcons.WIZBAN_CREATE_PATCH); 
 private void find(final IProgressMonitor m, final IContainer c, boolean searchLinkedFolders) throws CoreException { if (!searchLinkedFolders && c.isLinked()) return; // Ignore linked folders 
 return getProjectsInRepositoryOfSelectedResources().length > 0 && !selectionContainsLinkedResources(); 
 return selectionMapsToSingleRepository(); 
 return (int) Math.min(5 * (limit / wsz) / 2, Integer.MAX_VALUE); 
<|del|> 
 * exist the old value has a storage of * {@link org.eclipse.jgit.lib.Ref.Storage#NEW} and an ObjectId * value of {@code null}. 
<|del|> 
 if (c == 0) 
 assertThat(Long.valueOf(status.getChanged().size()), is(Long.valueOf(1L))); 
 // then file FILE1 should be unchanged in working tree 
 assertThat(Long.valueOf(status.getModified().size()), is(Long.valueOf(1))); 
 for (int i = 0; i < tmpListeners.length; i++) { 
 assertEquals("* master 9c58deb Initial commit", execute("git branch -v")[0]); 
 assertEquals("[tracked-dst.txt, mode:100644, content:I am tracked]", 
 * Copyright (c) 2010-2011 SAP AG. 
 * Mathias Kinzler (SAP AG) - initial implementation * Stefan Lay (SAP AG) - improvements 
 Activator.error(UIText.GitImportWizard_errorParsingURI, e); 
 // nothing to do 
<|del|> 
 // nothing to do 
 // nothing to do 
 for (RepositoryServerInfo info : repositoryServerInfos) 
<|del|> 
<|del|> 
 public void logAllCommitsWithMaxCount() throws Exception { 
 private final int skip; 
<|del|> 
 /***/ public String maxCountMustBeNonNegative; 
 * the number of commits to skip 
 || ConfigConstants.CONFIG_KEY_REMOTE.equals(autosetupRebase)) 
 if (m == null || equalIdAndMode(mId, mMode, iId, iMode)) { 
 // TODO: check whether something other than a WorkingSet can // appear here, and calculate a proper name for it. 
 if (Activator.getDefault() == null) 
 c1.objectId = c2.objectId = MISC_ID; 
 c1.objectId = c2.objectId = MISC_ID; 
 private final String label; 
 private final IConfigurationElement repositorySearchPageELement; 
 if (object instanceof IRepositoryServerProvider) 
 && object instanceof IRepositorySearchResult) 
 private final List<String> fetchRefSpecs = new ArrayList<String>(); 
<|del|> 
 private String pushRefSpec; private String pushUri; 
<|del|> 
<|del|> 
 private String section; private String subsection; private String name; private String value; 
 private String section; private String subsection; private String name; private String value; 
 public GitRepositoryInfo getGitRepositoryInfo(); 
 public Collection<RepositoryServerInfo> getRepositoryServerInfos(); 
 if (m == null || equalIdAndMode(mId, mMode, iId, iMode)) { 
 if (config.length > 0) 
 * The constant provider used for local repositories 
 * contain repositories 
 * @return a class which provides a list of servers which host git 
 * @return A wizard page which can return information of a git 
 * @return the credentials needed to log in 
 * the path where a clone has been created in 
 /** * Do the clone using data which were collected on the pages * {@code validSource} and {@code cloneDestination} * 
<|del|> 
 repoDir[0] = getClonedRepository().getDirectory(); 
 * Sets config properties for a repository 
 for (String fetchRefSpec : gitRepositoryInfo.getFetchRefSpecs()) 
 for (Image image : images) 
 * <p> 
 * @return a list of CloneSourceProviders, may be extended by a subclass 
 // TODO: check whether something other than a WorkingSet can // appear here, and calculate a proper name for it. 
 if (Activator.getDefault() == null) 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Activator.logError(e.getMessage(), e); 
<|del|> 
 c1.objectId = c2.objectId = MISC_ID; 
 if (repositoryAlreadyExistsForUrl(repositoryPath, gitUrl)) 
 if (existingUrl.equals(url)) 
 private final String label; 
 private final IConfigurationElement repositoryServerProviderElement; 
 private final IConfigurationElement repositorySearchPageELement; 
 if (object instanceof IRepositoryServerProvider) 
 && object instanceof IRepositorySearchResult) 
 private final List<String> fetchRefSpecs = new ArrayList<String>(); 
 if (gitPath == null) { 
 * Copyright (c) 2010, 2011 SAP AG and others. 
 if (resource == null) 
 } else if (!evaluated.isEmpty()) 
 for (String string : evaluated) 
 * Copyright (c) 2010-2012 SAP AG and others. 
 // left assertions 
 // right assertions 
 private void commonFileAssertions(RevCommit actual, RevCommit parent, 
 * Thrown when commit direction cannot be determined in 
 if (item instanceof IViewReference) 
 UIText.GitCloneSourceProviderExtension_Local, null, null, true); 
 } catch (IOException e) { // bad luck, we can't extend the drop down; let's log an error Activator.logError( "Exception while trying to find Refs for Commit", e); //$NON-NLS-1$ 
 GC.gc(null, repo); 
 GitCreatePatchWizard.run(getShell(), commit, repository, null); 
 * @param style SWT style bits 
 if (Activator.getDefault().getPreferenceStore().getBoolean( UIPreferences.RESOURCEHISTORY_COMPARE_MODE)) { 
 UIText.CommitFileDiffViewer_notContainedInCommit, d .getPath(), d.getCommit().getId().getName()); 
<|del|>
<|del|>
<|del|>
public class BlameRevision extends Revision { 
 * concurrent threads all try to delete the same file. 
<|del|> 
<|del|> 
 public static void disableSecureStoragePasswordProviders() { 
 if (directories) for (String dir : status.getUntrackedFolders()) 
<|del|> 
 public boolean isAllowNonFastForwards() { return allowNonFastForwards; 
 * @param allow * true if this update batch should ignore merge tests. * @return {@code this}. 
 public BatchRefUpdate setAllowNonFastForwards(boolean allow) { allowNonFastForwards = allow; 
 return addCommand(Arrays.asList(cmd)); 
<|del|> 
 * Set the result of this command. 
 RevBlob a = tr.blob("a"); fsTick(); 
 return ((ICVSRemoteFolder) o).members(Policy.subMonitorFor(monitor, 50)); 
 * * NOTE: Resources are cached only for tags of type CVSTag.Branch and * CVSTag.Version. Other types of tags will always return empty list. * 
 CVSTag knownTags[] = repositoryManager.getKnownTags(CVSWorkspaceRoot .getCVSFolderFor(project)); assertEquals(0, knownTags.length); knownTags = refreshTags(project); assertEquals(0, knownTags.length); 
 Activator.error(UIText.StagingViewContentProvider_SubmoduleError, e); 
<|del|>
 if (entry.isEmpty()) { 
 if (entry.parent.isEmpty()) { 
 if (child.isEmpty()) { 
<|del|> 
 TagCacheEntry entry = getTagCacheEntryFor(path, false); 
<|del|> 
 return; 
<|del|> 
<|del|> 
 myTitle = UIText.BranchConfigurationDialog_BranchConfiguration; 
 branchLabel.setText(UIText.BranchConfigurationDialog_UpstreamBranchLabel); 
 * Copyright (c) 2012 SAP AG. 
 ConfigConstants.CONFIG_KEY_MERGE, UIText.BranchPropertySource_UpstreamBranchDescriptor); desc.setCategory(UIText.BranchPropertySource_UpstreamConfigurationCategory); 
 private enum SourceType { UNDEFINED, REPOSITORY, REMOTE, BRANCH } 
 * Copyright (c) 2012 SAP AG. 
 // check whether we had this path to possibly (likely) skip the // expensive lookup. String absPath = file.getAbsolutePath(); if (handledPaths.contains(absPath)) continue; 
 int ptr = t.getNameOffset(); byte[] raw = t.getEntryPathBuffer(); int end = ptr + t.getNameLength(); 
 while (ptr < end) { 
 if ("Windows".equals(SystemReader.getInstance().getProperty( "os.name"))) 
<|del|> 
 NLS.initializeMessages( Messages.class.getName(), Messages.class ); 
 public static String GdbDebugPreferencePage_Advanced_Timeout_Settings; 
 public static final String PREF_COMMAND_TIMEOUT = PREFIX + "commandTimeout"; //$NON-NLS-1$ 
 public static final String PREF_COMMAND_CUSTOM_TIMEOUTS = PREFIX + "commandCustomTimeouts"; //$NON-NLS-1$ 
<|del|> 
 NLS.initializeMessages( Messages.class.getName(), Messages.class ); 
 public void commandTimedOut(final ICommandToken token) { getExecutor().execute(new DsfRunnable() { @Override public void run() { GDBControl.this.commandTimedOut(token); } }); 
 protected GdbCommandTimeoutManager createCommandTimeoutManager(ICommandControl commandControl) { 
 /** * @since 4.1 */ protected void commandTimedOut(ICommandToken token) { 
 if (fInitialized) { 
 if (fInitialized) { 
 public void run() { // The session is terminated if a command is timed out. 
 public static void setDefaultStreamFileThreshold(int threshold) { defaultStreamFileThreshold = threshold; 
 * Default big file threshold: {@value} * * @see #setBigFileThreshold(int) 
 * Default setting: {@value #DEFAULT_BIG_FILE_THRESHOLD} 
<|del|> 
 return ldr.getCachedBytes(); 
 if ( tokenParts.length == 2 && tokenParts[0].length() > 0 && tokenParts[1].length() > 0 ) { 
 private class QueueEntry { private long fTimestamp; private ICommandToken fCommandToken; 
 private enum TimerThreadState { 
 private class TimerThread extends Thread { 
<|del|> 
 while( fState == TimerThreadState.RUNNING ) { // Use the minimum of all timeout values > 0 as the wait timeout. 
 // start executing it only when the execution of the previous command // is completed. 
<|del|> 
<|del|> 
 fState = state; interrupt(); 
 private ICommandControl fCommandControl; 
 public GdbCommandTimeoutManager( ICommandControl commandControl ) { 
 if ( event.getNewValue() == null || !event.getNewValue().equals( event.getOldValue() ) ) { 
import org.junit.Test; import org.junit.runner.RunWith; 
 final CommandHandle commandHandle = fRxCommands.remove(id); 
 CommandHandle h = fRxCommands.remove(tokenId); if (h == null) // Command has already been processed by RxThread. return; 
 public Date getTimestamp(MavenSession session, MavenProject project, MojoExecution execution) throws MojoExecutionException; 
 * Thomas Demande (BSB group) - added support for annotation processors (bug 360427) 
 * Copyright (c) 2012 Google, Inc and others. 
 * Alex Ruiz (Google) - initial API and implementation 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 return factory.createProblemLocation( (IFile) info.file, info.startChar, info.endChar, info.lineNumber); 
 // Arrays.copyOf leaves empty cells at the end. We need an empty cell at the beginning of // the array. 
 private static final String[] ENV = {}; private static final NullProgressMonitor NULL_PROGRESS_MONITOR = new NullProgressMonitor(); 
 private static final String[] ENV = {}; private static final NullProgressMonitor NULL_PROGRESS_MONITOR = new NullProgressMonitor(); 
 * Copyright (C) 2010, Robin Rosenberg <robin.rosenberg@dewire.com> 
 * Copyright (C) 2012, Robin Rosenberg <robin.rosenberg@dewire.com> 
 super(); setName( "GDB Command Timer Thread" ); //$NON-NLS-1$ 
<|del|> 
 private synchronized void setTimerThreadState( TimerThreadState state ) { 
 // regardless how long it has been in the queue GDB will start // executing it only when the execution of the previous command // is completed. 
 fTimerThread.setTimerThreadState( ( fTimerThread.getWaitTimeout() > 0 ) ? 
 if ( event.getNewValue() == null || !event.getNewValue().equals( event.getOldValue() ) ) { 
 children = result.toArray(new GitModelObject[result.size()]); 
 * Separates the arguments, stored as a single {@code String}, to pass to an external tool. It uses * an empty space as the delimiter and supports quoted arguments. 
 * Separates the arguments, stored as a single {@code String}, to pass to an external tool. It uses * an empty space as the delimiter and supports quoted arguments. 
<|del|> 
 allArgs[0] = actualFilePath; // Copy arguments System.arraycopy(configuredArgs, 0, allArgs, 1, argCount); 
 * @deprecated Replaced by {@code CheckersRegistry.isCheckerEnabled((IChecker IResource, CheckerLaunchMode)} * and {@code ICheckerEnablementVerifier.isCheckerEnabled(IChecker IResource, CheckerLaunchMode)}. 
 public boolean isCheckerEnabled(IChecker checker, IResource resource, CheckerLaunchMode mode) { 
 ProblemMarkerInfo info = new ProblemMarkerInfo(fileName, lineNumber, description, severity, null); 
<|del|> 
 return (pair.second & context) != 0; 
 * Checker runs when a file is saved or opened. Checker will not run if the file is an editor 
 checkerEnablementVerifier = (ICheckerEnablementVerifier) ce.createExecutableExtension(CLASS_ATTR); 
import org.eclipse.core.runtime.PlatformObject; import org.eclipse.jface.fieldassist.ControlDecoration; import org.eclipse.jface.fieldassist.FieldDecorationRegistry; 
 gd = new GridData(SWT.FILL, SWT.CENTER, false, false); gd.horizontalIndent = FieldDecorationRegistry.getDefault().getMaximumDecorationWidth(); fTreatCharPtrAsStringsLimit.setLayoutData(gd); 
 try { Integer limit = getCharPtrAsStringLimit(fTreatCharPtrAsStringsLimit.getText()); fCollectAction.setCharPtrAsStringsLimit(limit); } catch (IllegalCollectStringLimitException e) { // ignore and keep old value } 
 GdbPlugin.log(e); 
 return collectCmd.toString(); 
<|del|> 
 int contexts = 0; 
 * Returns a bit mask of contexts where an error parser can be used. Valid values for context * are defined in <code>{@link ErrorParserContext}</code>. 
 private static int contextTypes(IConfigurationElement cfgEl) { 
 checkerEnablementVerifiers.add((ICheckerEnablementVerifier) ce.createExecutableExtension(CLASS_ATTR)); 
 if ("build".equals(text)) { //$NON-NLS-1$ 
 gd = new GridData(SWT.FILL, SWT.CENTER, false, false); gd.horizontalIndent = FieldDecorationRegistry.getDefault().getMaximumDecorationWidth(); fTreatCharPtrAsStringsLimit.setLayoutData(gd); 
<|del|> 
 URI buildArtifactURI = EFSExtensionManager.getDefault().append(buildLocationURI, artifactName); 
 assertEquals(4, files.size()); 
 configureBranchDialog.bot().button("OK").click(); 
 fail("We should have received a config change event"); 
 myTitle = UIText.BranchConfigurationDialog_BranchConfigurationTitle; 
<|del|> 
 if (baseDirectoryURI != null) { 
 private void enableErrorParsers(String[] parserIDs) { if (parserIDs == null) { parserIDs = ErrorParserExtensionManager.getDefaultErrorParserIds(); 
 if (!fDirectoryStack.isEmpty()) { 
 if (!dir.isAbsolute()) { 
 if (dir.isAbsolute()) { 
 if (lineTrimmed.length() > 1000) { 
 if (parser instanceof IErrorParserNamed) { id = ((IErrorParserNamed) parser).getId(); } 
 if (marker==null) { 
 if (consume) { 
 org.eclipse.core.filesystem.URIUtil.equals(getWorkingDirectoryURI(), cachedWorkingDirectory)) { 
 if (files.length == 0) { 
 if (files.length == 0) { 
 if (uri == null) { 
 if (!uri.isAbsolute()) { 
 if (f != null && f.isAccessible()) { 
 if (problemMarkerInfo.severity == IMarkerGenerator.SEVERITY_ERROR_RESOURCE) { 
 if (outputStream != null) { 
 if (line.endsWith("\r")) { //$NON-NLS-1$ 
 if (path.isAbsolute() && uriString.charAt(0) != IPath.SEPARATOR) { uriString = IPath.SEPARATOR + uriString; } 
<|del|>
 IResource resource = (IResource) editor.getEditorInput().getAdapter(IResource.class); if (resource != null) { processResource(resource); } 
 rw.markStart(dstRev); rw.markStart(srcRev); 
 setupFileViewer(walk, db, paths); 
 private void scheduleNewGenerateHistoryJob(RevWalk walk) { 
<|del|> 
 Label label = asLabel(sb.toString()); 
 || headChanged || repoChanged || allBranchesChanged 
 private void markStartAllRefs(RevWalk walk, String prefix) throws IOException, 
 private void markStartAdditionalRefs(RevWalk walk) throws IOException { 
 private void markStartRef(RevWalk walk, Ref ref) throws MissingObjectException, 
 private void markUninteresting(RevWalk walk, String prefix) throws IOException, 
<|del|> 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
 sb.append(' '); // DOWNWARDS ARROW 
 private List<Ref> getBranches() { 
 final Repository repo = getRepository(); return repo != null && containsHead(repo); 
 addLastModifiedInfo(layout, project); 
<|del|> 
<|del|> 
<|del|> 
 * Unit tests of {@link CommitCommand} 
 // determine the current HEAD and the commit it is referring to 
 if (headId != null) 
import org.eclipse.jgit.lib.Constants; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.lib.RepositoryState; import org.eclipse.jgit.lib.RepositoryTestCase; import org.eclipse.jgit.lib.StoredConfig; 
<|del|>
 checkCallable(); pullRebaseMode = useRebase ? PullRebaseMode.REBASE : PullRebaseMode.NO_REBASE; return this; 
<|del|> 
 if (!parent.getFS().isCaseSensitive() 
 .addFilepattern("file2.txt").addFilepattern("file3.txt").call()); 
 private synchronized void cancelRxCommands() { 
 public MIInfoOs(IDMContext ctx) 
<|del|> 
 * 
 GitAPIException { 
 RevCommit newCommit) throws IOException, GitAPIException { 
 private Repository init(URIish u) throws GitAPIException { 
 throws URISyntaxException, IOException, GitAPIException { 
 throws MissingObjectException, IncorrectObjectTypeException, IOException, GitAPIException { 
 GitAPIException { 
 IncorrectObjectTypeException { 
 IncorrectObjectTypeException { 
 throws MissingObjectException, IncorrectObjectTypeException { 
 GitAPIException { 
 private ObjectId getHeadTree() throws GitAPIException { 
 private ObjectId getStashId() throws GitAPIException { 
 public MIInfoOs(IDMContext ctx) 
 GitAPIException { 
 GitAPIException { 
 public Git call() throws GitAPIException, InvalidRemoteException, org.eclipse.jgit.api.errors.TransportException { 
<|del|> 
 isDirty = work.isModeDifferent(modeO) 
 * 
 * 
 * @return an object describing the result of this command * @throws GitAPIException * @throws WrongRepositoryStateException * @throws NoHeadException * @throws RefNotFoundException 
 * 
 * 
 * 
 * 
 String id = head.getObjectId().name(); String ref = mapCommitToRef(repository, id, false); if (ref != null) return Repository.shortenRefName(ref) + ' ' + id.substring(0, 7); 
 return id.substring(0, 7); 
 totalBranchCount = getBranchesOfCommit(page, repository, false).size(); 
 * Copyright (C) 2010, Mac Trzcinski <mtrzcinski@nvidia.com> 
 return delegate.createRepository(translate(location), name, type, properties); 
 * Copyright (c) 2010, 2012 David Green and others. 
 + URLEncoder.encode(productAttribute.getValue(), IBugzillaConstants.ENCODING_UTF_8), monitor); 
 if (isCommentOnSameLine(node) || offset > commentNodeLocation.getNodeOffset() && offset < statementOffset) { isPreStatementComment = false; 
 addAll(names, props); addAll(names, props2); 
 name = name.toLowerCase(Locale.ENGLISH); 
 if (repository == null) 
 if (lastBranch != null) 
 if (rootTree == null) { 
 generator.useWorkingTree = true; 
 * Copyright (c) 2009, 2012 David Green and others. 
 * Copyright (c) 2010, 2012 David Green and others. 
 List<IASTPreprocessorStatement> preprocessorStatements = Arrays.asList(preprocessorStatementsArray); 
 if (isCommentOnSameLine(node) || offset > commentNodeLocation.getNodeOffset() && offset < statementOffset) { isPreStatementComment = false; 
 IASTPreprocessorStatement statement, IASTTranslationUnit tu) { if (tu == null || tu.getDeclarations().length == 0) { 
 List<IASTPreprocessorStatement> preprocessorStatements = Arrays.asList(preprocessorStatementsArray); 
 while (curStatement != null && curComment != null) { int statementLineNr = curStatement.getFileLocation().getStartingLineNumber(); 
import static org.eclipse.jgit.http.server.ServletUtils.isChunked; 
 if (acc > 0) acc--; 
 List<String> paths = new ArrayList<String>(128); 
 /** * @author Frank Becker */ 
 RefreshRepositoryTasksAction action = new RefreshRepositoryTasksAction(); action.selectionChanged((IStructuredSelection) selection); action.run(); 
 /** * @author Frank Bwcker */ 
 public boolean isFirstChildDiff(char contributor, int childStart, Diff diff) { 
 * Copyright (c) 2010,2012 David Green and others. 
 } catch (NumberFormatException e) { 
 Set<IProject> result = new LinkedHashSet<IProject>(); File workTree = repository.getWorkTree(); 
 File file = new File(workTree, member); 
<|del|> 
 * Copyright (c) 2010,2012 David Green and others. 
 qualifiedUrl += "index.php?title=" + URLEncoder.encode(path, "UTF-8") + "&action=raw"; //$NON-NLS-1$ //$NON-NLS-2$//$NON-NLS-3$ 
 internalLinkPattern += "index.php/{0}"; //$NON-NLS-1$ 
 logGoneMappedResource(m); 
 logGoneMappedResource(m); 
 private static final Pattern templateParameterPattern = Pattern.compile("\\{\\{\\{([a-zA-Z0-9]+)\\s*(?:|([^\\}]+))\\}\\}\\}"); //$NON-NLS-1$ 
 * Copyright (c) 2007, 2012 David Green and others. 
 * @author David Green, Carsten Hammer 
 verifier.executeGoal("validate"); verifier.verifyErrorFreeLog(); 
 verifier.setSystemProperty("tycho.target-platform-plugin.validation.skip", Boolean.TRUE.toString()); 
 * @parameter default-value="${project}" * @read-only 
 this.logger.error("Failed, see Error log below"); 
 if ( ! this.failOnError) { this.logger.error(message); } else { 
import java.util.Comparator; import java.util.List; 
 boolean hasMore = traceReader.advance(); if( hasMore ){ // you can know the trace has more events. } 
 * Copyright (c) 2012 Sebastian Schmidt and others. 
 /** * @since 3.9 */ 
 public void setUp() throws IOException, CoreException { 
 public void setUp() throws IOException, CoreException { 
 List<IBreakpoint> breakpoints = BreakpointsContextUtil.importBreakpoints(testContext, null); assertEquals(Collections.emptyList(), breakpoints); 
 assertTrue(breakpoints.size() == 2); 
 * Copyright (c) 2012 Sebastian Schmidt and others. 
 public static String ID_PLUGIN = "org.eclipse.mylyn.debug.ui"; //$NON-NLS-1$ 
 public static String ID_PLUGIN = "org.eclipse.mylyn.debug.ui"; //$NON-NLS-1$ 
 public static InputStream exportBreakpoints(Collection<IBreakpoint> breakpoints, IProgressMonitor progressMonitor) { if (breakpoints.size() == 0) { 
 importBreakpointOperation.run(progressMonitor); 
<|del|> 
 * 
/** * A trace manager * * @author Matthew Khouzam */ class CtfTraceManager { 
 public CtfTraceManager(CtfTmfTrace trace) { 
<|del|> 
 private final static int MAX_SIZE = 100; 
 * @version 1.0 * @since 1.1 
 private static HashMap<CtfTmfTrace, CtfTraceManager> map = new HashMap<CtfTmfTrace, CtfTraceManager>(); 
 * Registers a trace to the iterator manager, the trace can now get 
 public static synchronized void removeTrace(final CtfTmfTrace trace) { 
class CtfTraceManager { /* * Cache size. Under 1023 on linux32 systems. Number of file handles * created. */ 
 assertSearchResults("src/Main.java void Main.main(String[]) [Foo] EXACT_MATCH\n" + "src/Main.java void Main.main(String[]) [Foo] EXACT_MATCH"); 
 JavaModelManager manager = JavaModelManager.getJavaModelManager(); 
 return manager.getPreviousSessionContainer(containerPath, project); 
 JavaModelManager manager = JavaModelManager.getJavaModelManager(); 
 return manager.getPreviousSessionVariable(variableName); 
 JavaModelManager manager = JavaModelManager.getJavaModelManager(); 
 return message; 
 return newSourceEntry(path, ClasspathEntry.INCLUDE_ALL, exclusionPatterns, specificOutputLocation); 
 nameEnvironment.cleanup(); 
 Map<String, String> retMap = new LinkedHashMap<String, String>(); 
 // For "small" dialogs with label-only results, use the default // height and the persisted width Point size = super.getInitialSize(); size.x = getPersistedSize().x; return size; 
 assertSearchResults("src/Main.java void Main.main(String[]) [Foo] EXACT_MATCH\n" + "src/Main.java void Main.main(String[]) [Foo] EXACT_MATCH"); 
 return manager.getPreviousSessionContainer(containerPath, project); 
 JavaModelManager manager = JavaModelManager.getJavaModelManager(); 
 return manager.getPreviousSessionVariable(variableName); 
<|del|> 
 this.lookupEnvironment.addResolutionListener((TypeReferenceLocator) this.patternLocator); 
public void recordResolution(QualifiedTypeReference typeReference, TypeBinding resolution) { List/*<TypeBinding>*/ resolutionsForTypeReference = (List) this.recordedResolutions.get(typeReference); if (resolutionsForTypeReference == null) { resolutionsForTypeReference = new ArrayList(); 
 * Notifies that the given resolution has been found for the given type reference. Some of the bindings are * intermediate types i.e. qualifying types. * 
<|del|> 
<|del|> 
 findNextTypeBinding(i, scope, packageBinding); 
 public static final String EVENTS_TABLE_TYPE_ELEM = "eventsTableType"; //$NON-NLS-1$ /** * Extension point element 'Statistics viewer type' * * @since 2.0 */ 
 return viewerCE[0].createExecutableExtension(TmfTraceType.CLASS_ATTR); 
 protected TreeViewer fTreeViewer; 
 * Constructor for CtfLocation. Uses a default index of 0. 
 * This interface provides the different components (e.g. views) with a mean to 
<|del|> 
 CtfLocation ctfLocation = new CtfLocation(new CtfLocationData(1, 0)); ctfLocation.setLocation(new CtfLocationData(1, 0)); 
 CtfLocationData location = new CtfLocationData(1337, 7331); 
 final CtfLocationData location2 = new CtfLocationData(1L, 0L); CtfLocation ctfLocation = new CtfLocation(location2); 
 for (long i = 0; i < ctfLocationData.getOffset(); i++) { if (currTimestamp == this.getCurrentEvent().getTimestampValue()) { 
 } else { 
 return "Element [" + timestamp + '/' + offset + ']'; //$NON-NLS-1$ 
 } /* * Check if there is already one or more events for that timestamp, and * assign the location index correctly */ 
 String osDotName = AccessController .doPrivileged(new PrivilegedAction<String>() { public String run() { return getProperty("os.name"); } }); 
 String osDotName = AccessController .doPrivileged(new PrivilegedAction<String>() { public String run() { return getProperty("os.name"); } }); return osDotName.startsWith("Windows"); 
<|del|> 
 this.resolutionListeners[length] = resolutionListener; 
 if (commonTraceType != null && !commonTraceType.equals(traceType)) { 
 if (statisticsViewer == null || statisticsViewer.length() == 0) { 
public interface ITmfViewer extends ITmfComponent { 
 * Constructor that initializes the parent of the viewer 
 public static Object getTraceTypeElement(IResource resource, String element) { 
 * Counts the number of times waitCursor() has been called. It avoids * removing the waiting cursor, since there may be multiple requests running * at the same time. 
 * Checks if a statistics update is ongoing. If it is ongoing, the new time 
 * The ID correspond to the package in which this class is embedded 
 for (ITmfViewer viewer : fStatsViewers.getViewers()) { if (!(viewer instanceof TmfStatisticsViewer)) { Activator.getDefault().logError("Error - cannot cast viewer to a statistics viewer"); //$NON-NLS-1$ continue; } 
 fStatsViewer.dispose(); /* * Make sure there is no request running before removing the statistics * tree. */ cancelOngoingRequest(fRequestRange); cancelOngoingRequest(fRequest); 
 * * Handles the time range updated signal. It updates the time range * statistics. 
 * @return a statistics viewer of the appropriate type 
 // Creates a statistics viewer for each traces. 
 * simplifies the management of the viewer contained in each tab. 
 /** * Returns the name of the trace. * 
 requestTimeRangeData(experiment, timeRange); } 
 * The ID corresponds to the package in which this class is embedded. 
 protected final TmfViewerFolder fStatsViewers; 
 * Flag to force request the data from trace. 
 protected boolean fRequestData = false; 
 fStatsViewers.clear(); 
 if (res.object.isEdge() || res.object.doNotAttemptDelta()) { 
 if (input instanceof TmfStatisticsTreeNode) { 
 .getDefaultLaunchShortcutProviderId(TYPE); configScopeInstance.getNode(QUALIFIER).put(KEY, providerId); 
 Composite top = new Composite(parent, SWT.NONE); 
 if (isForceUpdate()) 
 private String calculateOurName(Ref headRef) { 
 /* Shallow-copying the CtfLocationData, which we know to be immutable */ return new CtfLocation(this.getLocationData()); 
 * 
<|del|>
 if (squash) 
<|del|> 
 String trackingBranch = branchConfig.getTrackingBranch(); 
<|del|> 
<|del|> 
 throw new CoreException(new Status(IStatus.ERROR, "org.eclipse.linuxtools.systemtap.ui.editor", "Incorrect URL", e)); //$NON-NLS-1$ //$NON-NLS-2$ 
<|del|> 
 wb.getActiveWorkbenchWindow().getActivePage().openEditor(input, CEditor.ID); 
<|del|> 
<|del|> 
 public static final String PREFS_KEY = "provider"; //$NON-NLS-1$ public static final String GENERIC_TYPE = "generic"; //$NON-NLS-1$ 
 configScopeInstance, getProfilingType()); 
 if (!getProfilingType().equals(ProviderPreferencesPage.TYPE)) { 
 String providerId = initial.getAttribute(PROVIDER_CONFIG_ATT, ""); 
 throw new CoreException(new Status(IStatus.ERROR, "org.eclipse.linuxtools.systemtap.ui.editor",Localization.getString("SimpleDocumentProvider.incorrectURL"), e)); //$NON-NLS-1$ //$NON-NLS-2$ 
<|del|> 
<|del|> 
 * The sum of the sizes of all files used to persist loose objects. 
 * The number of loose refs. 
 * The number of refs stored in pack files. 
 Git git = new Git(repo); GarbageCollectCommand gc = git.gc(); try { Properties stats = gc.getStatistics(); 
 private IResourcesInformation data; private boolean[] columnIsInteger; private List<Integer> remap; public OSData(String resourceClass, IResourcesInformation data) { 
 // Move the element to the end of the list remap.add(remap.remove(index)); 
 Composite parent = new Composite(xparent, SWT.NONE); 
 setDebugContext((IDMContext)null); DsfSession.removeSessionEndedListener(this); 
 *4 D F D N N N Conflict 
 assertTrue(a1.equals(a1)); assertTrue(a1.equals((Object) a1)); 
 private IResourcesInformation data; private boolean[] columnIsInteger; private List<Integer> remap; public OSData(String resourceClass, IResourcesInformation data) { 
<|del|> 
<|del|> 
 Composite parent = new Composite(xparent, SWT.NONE); 
 IDebugContextManager contextManager = DebugUITools.getDebugContextManager(); 
 IDebugContextManager contextManager = DebugUITools.getDebugContextManager(); 
 setDebugContext((IDMContext)null); DsfSession.removeSessionEndedListener(this); 
 hideTable(NLS.bind(Messages.OSView_7, FETCH_LINK_TAG)); 
 toolItem.setWidth(width); 
 private IGDBHardwareAndOS2 fHardwareOs; private ICommandControlDMContext fContext; 
 public SessionOSData(DsfSession session, final ICommandControlDMContext executionContext) 
<|del|> 
 if (!c.isDisposed()) 
 IGDBControl control = getServicesTracker().getService(IGDBControl.class); CommandFactory factory = control.getCommandFactory(); control.queueCommand(factory.createMIInfoOS(dmc, resourceClass), new DataRequestMonitor<MIInfoOsInfo>(getExecutor(), rm) { 
 classes.add(new IGDBHardwareAndOS2.IResourceClass() { 
 classes.add(new IGDBHardwareAndOS2.IResourceClass() { 
 resourceClasses = classes.toArray(new IGDBHardwareAndOS2.IResourceClass[classes.size()]); 
 resourceClasses = classes.toArray(new IGDBHardwareAndOS2.IResourceClass[classes.size()]); 
<|del|>
 for (String filePath: pathsToOpen) openFileInEditor(filePath); 
 assertTrue(a1.equals(a1)); assertTrue(a1.equals((Object) a1)); 
 assertTrue(a1.equals(a1)); assertTrue(a1.equals((Object) a1)); 
 assertTrue(a1.equals(a1)); assertTrue(a1.equals((Object) a1)); 
 String pageId = MediaWikiIdGenerationStrategy.escapeId(pageName); 
 * * @deprecated Use outw instead 
 * @since 2.1 
 * 
 public GarbageCollectCommand gc() { 
 * * The default is false. * 
 * * The default is false. * 
 /** Information about OS resource class. */ 
<|del|> 
 */ 
 * Return table describing resources of specificied class. */ 
 * Return table describing resources of specificied class. */ 
<|del|> 
<|del|> 
<|del|> 
 public ICommand<MIInfoOsInfo> createMIInfoOS(IDMContext ctx) { 
<|del|> 
 * 
 * 
 StringBuilder sb = new StringBuilder(cmdString(cmds[0])); 
 System.err.println(CLIText.get().unknownIoErrorStdout); 
 // No idea how to present an error here, most likely disk full or // broken pipe 
 private final String LF; 
 assertEquals(0, files.size()); 
 assertEquals(1, repositoryPaths.size()); 
<|del|> 
<|del|> 
 IWorkbenchWindow activeWorkbenchWindow = PlatformUI.getWorkbench().getActiveWorkbenchWindow(); 
 private Date expire; 
 throw new IllegalArgumentException(MessageFormat.format( HttpServerText.get().invalidIndex, valueOf(groupIdx))); 
<|del|> 
 // simply proceed with the next parser 
 * Allows configure rebase interactive process and modify commit message 
 * 
<|del|> 
 fCommandFactory.createMIDataWriteMemoryBytes(dmc, address.add(offset).toString(), (buffer.length == count) ? buffer : Arrays.copyOf(buffer, count)), new DataRequestMonitor<MIInfo>(getExecutor(), rm) ); 
 * Copyright (c) 2012 QNX Software Systems and others. 
 * John Dallaway - MIDataWriteMemoryBytes based on MIDataWriteMemory (bug 387793) 
 * -data-write-memory-bytes ADDRESS CONTENTS * 
 */ public class MIDataWriteMemoryBytes extends MICommand<MIInfo> { 
 // TODO: This doesn't work due to https://bugs.eclipse.org/388667 : 
<|del|> 
 ICommandControlService commandControl = tracker.getService(ICommandControlService.class); tracker.dispose(); 
 assert id != null; if (id != null && !id.equals(fResourceClassId)) 
<|del|> 
 * Return table describing resources of specified class. 
 if (activeWorkbenchWindow != null && activeWorkbenchWindow.getActivePage() != null) { 
 * @version 1.0 
 // TODO: This doesn't work due to https://bugs.eclipse.org/388667 : 
 if (dialogs.size() > 0) 
 * Return table describing resources of specified class. 
 assertEquals(1.273f, state.sizeFactor, 0.001f); // 1.2727273 
 handleFail(Messages.ProviderLaunchShortcut_0 + " " + type); 
<|del|> 
<|del|> 
 sb.append(new String(step.shortMessage, Constants.CHARACTER_ENCODING).trim()); 
 this.checkoutStage = stage; 
<|del|> 
<|del|> 
 /* Unknown event attribute, we'll simply ignore it */ // FIXME log this? 
 public void testParseRewordCommand() throws Exception { String todo = "pick 1111111 Commit 1\n" + "reword 2222222 Commit 2\n"; 
<|del|> 
 public static final String STATE_ID = "org.eclipse.linuxtools.lttng2.kernel"; //$NON-NLS-1$ 
 public static final String STATE_ID = "org.eclipse.linuxtools.tmf.statistics"; //$NON-NLS-1$ 
 assertTrue(file1.setLastModified(file1.lastModified() + 2500)); 
 ISchedulingRule rule = ruleFactory.modifyRule(container); if (rule != null) rules.add(rule); 
 textWidget.setText(textWidget.getText()); // XXX: workaround for https://bugs.eclipse.org/384886 
 for (int i = 0; i < size; i++) { 
 label.setText(Messages.getString("StapNewWizardPage.ScriptName")); //$NON-NLS-1$ 
 public void setType(TimestampType value) { type = value; 
<|del|> 
 git.branchCreate().setName("side").call(); 
 git.add().addFilepattern("file1").call(); git.commit().setMessage("file1 commit").call(); 
 /***/ public String switchedToNewBranch; /***/ public String switchedToBranch; 
 throw new WrongRepositoryStateException( 
 textWidget.setText(textWidget.getText()); // XXX: workaround for https://bugs.eclipse.org/384886 
 if (shouldHardWrap()) 
 for (int j = cur; j > prev && builder.charAt(builder.length() - 1) == ' '; j--) 
 * 
 @Test 
 List<IAssignCategory> fFromAllowed = defaultFromCategories(); 
 if (exp.getExpressionLanguage() == null) return true; return exp.getExpressionLanguage().equals(getExpressionLanguage()); 
 return BPELConstants.XMLNS_XPATH_EXPRESSION_LANGUAGE_2007; 
 assertTrue(html.contains("<body><p>normal <b> bold text</b> normal</p></body>")); 
 assertTrue(html.contains("<body><p>normal <i> italic text</i> normal</p></body>")); 
<|del|> 
 * @return the callsite just before that IP in the list remember the IP is backwards on X86 
 * @return the callsite just before that IP in the list remember the IP is backwards on X86 
public class OpenCommitAction implements IActionDelegate { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 for (ObjectId id : reader.getShallowCommits()) lookupCommit(id).parents = RevCommit.NO_PARENTS; 
<|del|> 
 while ((line = reader.readLine()) != null) ids.add(ObjectId.fromString(line)); 
 super(timestamp, ITmfTimestamp.NANOSECOND_SCALE, 0); 
 * @version 2.0 
<|del|> 
 /** * Default constructor */ private TmfTimeRange() { fStartTime = TmfTimestamp.BIG_BANG; fEndTime = TmfTimestamp.BIG_BANG; } /** 
 return this; 
<|del|> 
 trace.getCacheSize(), ITmfDataRequest.ExecutionType.BACKGROUND); 
 trace.getCacheSize(), ITmfDataRequest.ExecutionType.BACKGROUND); 
 long startTime = checkStartTime(start); long endTime = checkEndTime(end); 
 super(timestamp.normalize(0, ITmfTimestamp.SECOND_SCALE).getValue(), 0, 0); 
 Pattern configNamePattern = Pattern.compile(".+\\s\\[.+\\](\\s\\(\\d+\\))?$"); //$NON-NLS-1$ 
 * Tasktop Technologies - initial API and implementation * Yatta Solutions - WorkingSet tests (bug 334024) 
 * @author Mik Kersten * @author Carsten Reckord (bug 334024: focused package explorer not working if top level element is working set) 
 * @author Mik Kersten * @author Carsten Reckord (bug 334024: focused package explorer not working if top level element is working set) 
 * @author Mik Kersten * @author Carsten Reckord (bug 334024: focused package explorer not working if top level element is working set) 
import java.io.IOException; 
 } catch (IOException ex) { 
 getFS(), // new File(getDirectory(), Constants.SHALLOW)); 
 if (shallowFile == null || !shallowFile.isFile()) 
 ObjectDirectory db = new ObjectDirectory(config, objdir, null, fs, null); 
 .getShortBranch(repository)); if (branches.size() > 1) break; 
<|del|> 
<|del|> 
/** * Test the performance of the callsite storage in the CTF trace. * @author Matthew Khouzam * */ 
 "Dolphin", "Echidna", "Gazelle", "Heron", "Ibex", "Jackalope", "Koala", "Lynx", "Meerkat", "Narwhal", "Ocelot", "Pangolin", 
<|del|> 
<|del|> 
 System.out.println( "perf ( " + callsiteSize + ", " + ns + ")"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ 
<|del|> 
 final private long LineNumber; 
<|del|>
 for (; index < csl.size(); index++) { if (iter.next().compareTo(cs) < 0) { 
 * @return the callsite list can be empty 
 * @return the first callsite that has that event name, can be null 
 * @return the callsite just before that IP in the list remember the IP is * backwards on X86, can be null if no callsite is before the IP. 
 * @return the closest matching callsite, can be null 
 String left; /* this is a regex to find the leading and trailing quotes*/ 
 if (entry.getKey().equals("_ip") && //$NON-NLS-1$ (entry.getValue() instanceof IntegerDefinition)) { 
 curContext = CtfTmfEventField.parseField(curContextDef, curContextName); 
 List<CTFCallsite> eventList = fTrace.getCTFTrace().getCallsiteCandidates(name); 
public class BugzillaHarness { 
 void noff(@SuppressWarnings("unused") final boolean ignored) { ff = FastForwardMode.NO_FF; 
import java.io.IOException; 
 c.parseCanonical(walk, Constants.encode(buf.toString())); 
 } catch (IOException ex) { 
 * 
 * 
 throw new IllegalStateException( JGitText.get().shallowCommitsAlreadyInitialized); 
 getFS(), // new File(getDirectory(), Constants.SHALLOW)); 
 if (shallowFile == null || !shallowFile.isFile()) 
 ObjectDirectory db = new ObjectDirectory(config, objdir, null, fs, null); 
<|del|>
 * @return the callsite list can be empty 
 * @return the first callsite that has that event name, can be null 
 * @return the callsite just before that IP in the list remember the IP is * backwards on X86, can be null if no callsite is before the IP. 
 * @return the closest matching callsite, can be null 
<|del|> 
 StringBuilder response = new StringBuilder(); 
 final StringBuilder builder = new StringBuilder(); for (ObjectId commit : shallowCommits) builder.append(commit.getName() + "\n"); JGitTestUtil.write(new File(rw.repository.getDirectory(), "shallow"), builder.toString()); 
/** * Unit tests for {@link IOStructGen} 
 private static final String metadataDecs = "typealias integer { size = 8; align = 8; signed = false; } := uint8_t;\n" 
 private final Map<Long, Stream> streams = new HashMap<Long, Stream>(); 
<|del|> 
 static private final long MASK32 = 0x00000000ffffffffL; 
 private final String EventName; 
<|del|> 
 CtfTmfLightweightContext iter = new CtfTmfLightweightContext(this); /* seek the context to the timestamp value in nanoseconds */ 
 GitSynchronizeData data = gsds.getData(resource.getProject()); 
 /** * @return The trace */ public ITmfTrace getTrace() { return fTrace; } 
 /* the signal is for this trace or experiment */ if (getNbEvents() == 0) { 
 fileEditorInput = new FileEditorInput(fFile); 
 if ((fTimeRangeRequest != null) && !fTimeRangeRequest.isCompleted()) { fTimeRangeRequest.cancel(); } 
 } catch (final TmfTraceException e) { throw new PartInitException(Messages.OpenTraceHandler_NoTrace, e); 
 public long getEventsInRange(long start, long end) { // FIXME Instead of waiting until the end, we could check the current // end time, and answer as soon as possible... stats.waitUntilBuilt(); 
 public static boolean canDirectlyOpenInCompare(IFile file) { 
 * give the model provider a chance to resolve the remote logical model 
 * be done by relying on the local model only. 
 if (!resource.equals(file)) 
 fTrace = trace; } else { return; 
 final MutableObjectId idBuf = new MutableObjectId(); final ZipOutputStream out = new ZipOutputStream(outs); 
<|del|> 
 // ZIP entries for directories are optional. // Leave them out, mimicking "git archive". continue; 
<|del|> 
 List<IReview> lastReviews = reviews; 
<|del|> 
<|del|> 
<|del|> 
 TimeFormat getTimeFormat(); 
 TimeFormat getTimeFormat(); 
 assertEquals(99, ctx.getRank()); assertEquals(0, seekTs.compareTo(event.getTimestamp(), false)); 
<|del|> 
 IWorkbenchPage persp = window.getActivePage(); 
 IEditorPart editor = fView.getSite().getPage().getActiveEditor(); 
 plan.setName(matcher.group(2)); plan.setId(matcher.group(2)); plan.setUrl(matcher.group(1)); 
 build.setPlan(plan); build.setUrl(url); 
 if (fZoom != null) { fZoom.setFullRange(0L, 0L); fZoom.setNewRange(0L, 0L); fZoom.stop(); } 
 } if (R4EUIModelController.isUserQueryAvailable()) { 
 /** * @author Frank Becker */ 
 // this hash is for elements which has more then one RepositoryConfigurationItem for an element. // We store an RepositoryConfigurationItem for every RepositoryConfigurationItem.name // Bugzilla use this for the Products where every Product has its own Components,... 
 synchronized (this) { Map<String, RepositoryConfigurationItem> elementEntry = itemsByNamedAttribute.get(element); if (elementEntry != null) { return elementEntry.get(name); } return null; 
 List<RepositoryConfigurationItem> elementEntry = itemsByAttribute.get(element); return elementEntry != null ? elementEntry.toArray(new RepositoryConfigurationItem[0]) : null; 
 * Returns changes associated with the logged in user. This includes all open, closed and review requests for the * user. On Gerrit 2.4 and earlier closed reviews are not included. 
<|del|> 
 Date d0 = new Date(ts0.getValue()*1000); Date d1 = new Date(ts1.getValue()*1000); Date d2 = new Date(ts2.getValue()*1000); 
<|del|> 
<|del|> 
 if (element instanceof Object[]) 
<|del|> 
 protected Repository getRepository() { 
 name = CoreUtil.asFileName(name); 
<|del|> 
 if (value instanceof FastForwardMode) { n = ((FastForwardMode) value).toString(section, subsection, name); } 
 * 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } 
 * <li>{@link TimeFormat#RELATIVE} relative time, displayed as seconds/ms/us/ns 
 * <li>{@link TimeFormat#RELATIVE} relative time, displayed as seconds/ms/us/ns 
 parseAndCheckBindings(); 
 if (!(deducedTypeArg.getTypeValue() instanceof ISemanticProblem)) { 
 // TODO: Check for problems in non-type or template template parameters? 
 } else if (binding instanceof ICPPField) { IBinding owner = binding.getOwner(); 
 private static int indexOfAny(String toSearch, String choices) { for (int i = 0; i < toSearch.length(); ++i) { if (choices.indexOf(toSearch.charAt(i)) != -1) return i; } return -1; 
 long sizeofSource = sourceSizeAndAlignment == null ? getApproximateSize(source) : sourceSizeAndAlignment.size; long sizeofTarget = targetSizeAndAlignment == null ? getApproximateSize(target) : targetSizeAndAlignment.size; 
 basicSource = (CPPBasicType) source; } 
 if (basicSource == null) { // C enumeration or no fixed type return !(ArithmeticConversion.fitsIntoType(basicTarget, enumSource.getMinValue()) 
 if (basicSource == null) { // C enumeration or no fixed type return !(ArithmeticConversion.fitsIntoType(basicTarget, enumSource.getMinValue()) 
 if (BuiltinOperators.isFloatingPoint(basicSource) && BuiltinOperators.isIntegral(basicTarget)) { 
 if (inputBinding == null || inputBinding instanceof IProblemBinding || inputBinding instanceof IParameter) { 
 String toStringWithId(); 
<|del|> 
 artifact = WorkItemUtil.get(atsObject); 
 } Conditions.checkNotNull(artifact, "workItem", "Can't Find Artifact matching " + atsObject.toStringWithId()); return artifact.getAttributeValues(attributeType); 
 * Copyright (c) 2012 Boeing. 
 /** * Test case for {@link WorkDefinitionFactory} * * @author Donald G. Dunne */ 
 (XResultData) Matchers.anyObject())).thenReturn(workDefinition); 
 (XResultData) Matchers.anyObject())).thenReturn(workDefinition); 
 return factory.getWorkDefinition(id); 
 factory.addWorkDefinition(workDef); 
<|del|> 
 Conditions.notNull(review, getClass().getSimpleName()); 
 Conditions.notNull(teamWf, getClass().getSimpleName()); 
 Conditions.notNull(actionableItem, getClass().getSimpleName()); 
 Conditions.notNull(teamDefinition, getClass().getSimpleName()); WorkDefinitionMatch match = new WorkDefinitionMatch(); 
 if (result == Window.OK) { 
 transaction.execute(); AtsUtil.openATSAction(peerArt, AtsOpenOption.OpenAll); 
 @Override public void doSubmit() { super.doSubmit(); } @Override protected void handleTaskSubmitted(SubmitJobEvent event) { super.handleTaskSubmitted(event); } @Override 
<|del|> 
<|del|> 
 * The feature id for the '<em><b>All Comments</b></em>' reference list. <!-- begin-user-doc --> <!-- end-user-doc * --> * 
<|del|> 
 long sizeofSource = sourceSizeAndAlignment == null ? getApproximateSize(source) : sourceSizeAndAlignment.size; long sizeofTarget = targetSizeAndAlignment == null ? getApproximateSize(target) : targetSizeAndAlignment.size; 
 // If not, check whether the target type can represent its min and max values. 
<|del|> 
 } 
 * Creates a CPPDeferredFunction given a set of overloaded functions 
 if (requireTemplate && hasDependentArgument(tmplArgs)) return new ICPPFunction[] {CPPDeferredFunction.createForCandidates(fns)}; 
<|del|> 
 CPPFunctionSet functionSet = new CPPFunctionSet(deferredFunction.getCandidates(), templateArgs, null); return new EvalFunctionSet(functionSet, isAddressOf(expr)); 
 if (inputBinding == null || inputBinding instanceof IProblemBinding || inputBinding instanceof IParameter) { 
<|del|> 
 // namespace N { // void foo(int); // } // using N::f/*cursor*/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 IAtsWorkData getWorkData(IAtsWorkItem workItem) throws OseeCoreException; 
 } catch (OseeCoreException ex) { 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 public ReviewsUiPlugin() { } 
<|del|> 
 .get().enumValueNotSupported3, section, name, value)); 
 // and its install count is 1 if the breakpoint is installed // and 0 if the breakpoint is pending. // Check for a duplicate target breakpoint. 
<|del|> 
<|del|> 
<|del|> 
 public void createTraceFile() throws Throwable { deleteOldTraceFile(); 
<|del|> 
 bm.removeBreakpoint(b, true); 
 if (isSuccess() && getData().isTracingSupported()) { 
 public GDBPatternMatchingExpressions(DsfSession session, IMIExpressions delegate) { 
 @Override 
 @Override 
 if (projectElement.getResource().equals(file)) { 
 TmfTraceElement traceElement = ((TmfTraceElement)aSelection.getFirstElement()); 
 localEditor = editorReference.getEditor(true); if (localEditor != null) { aPage.bringToTop(localEditor); } 
 // Return the corresponding IProject as parent because from CNF point of view the IProject is the parent. 
<|del|> 
 manager.add(new Separator("Separator")); 
 super.doAfterTest(); 
 Status status = new Status(IStatus.ERROR, GerritUiPlugin.PLUGIN_ID, "Error while clearing task status.", e); TasksUiInternal.displayStatus("Clear outgoing task status failed", status); 
 } if (xCol.equals(CoverageXViewerFactory.Guid)) { return coverage.getGuid(); } 
 SortDataType.String, false, ""); public static XViewerColumn Guid = new XViewerColumn(NAMESPACE + ".guid", "Guid", 80, SWT.LEFT, true, SortDataType.String, false, ""); 
 } if (xCol.equals(CoverageXViewerFactory.Guid)) { return coverage.getGuid(); } 
 Parent_Coverage_Unit, Line_Number, Location, Full_Path, Guid)) { 
 Coverage_Method, Line_Number, Coverage_Test_Units, Assignees_Col, Location, Full_Path, Guid); 
<|del|> 
<|del|> 
 static final String COVERAGE_TEST_UNIT_NAME_SEQ = "COVERAGE_TEST_UNIT_NAME_SEQ"; 
 static final String COVERAGE_TEST_UNIT_NAME_SEQ = "COVERAGE_TEST_UNIT_NAME_SEQ"; 
 Notes_Col, Parent_Coverage_Unit, Line_Number, Location, Full_Path, Guid); 
 int getNextCoverageTestUnitId() throws OseeCoreException; 
 public GDBPatternMatchingExpressions(DsfSession session, IMIExpressions delegate) { 
 * @return True if expr follows the rules of an register-pattern 
 * @return True if expr follows the rules of an array-pattern 
<|del|> 
 checkChildren(exprDmc, -1, -1, children); 
 List<IAtsUser> assigneesBefore = teamArt.getAssignees(); Assert.assertTrue(assigneesBefore.size() > 0); 
 List<IAtsUser> assigneesBefore = teamArt.getAssignees(); Assert.assertTrue(assigneesBefore.size() > 0); 
<|del|> 
<|del|> 
 if (helper.getToAssignees(awa) != null) { 
<|del|> 
<|del|> 
 return awa.getAssignees(); 
 Status status = new Status(IStatus.ERROR, GerritUiPlugin.PLUGIN_ID, "Error while clearing task status.", e); TasksUiInternal.displayStatus("Clear outgoing task status failed", status); 
 Status status = new Status(IStatus.ERROR, GerritUiPlugin.PLUGIN_ID, "Error while clearing task status.", e); TasksUiInternal.displayStatus("Clear outgoing task status failed", status); 
 GridDataFactory.fillDefaults().grab(true, true).hint(600, 200).applyTo(messageEditor.getControl()); 
 GridDataFactory.fillDefaults().grab(true, true).hint(600, 200).applyTo(messageEditor.getControl()); 
 if (nextStateName.equals(currentStateName)) { 
 return Widgets.isAccessible(shell); 
 /** * Provides common features for tree content providers including support for gathering children of collections * efficiently. * * @author Miles Parker */ 
 } streamInputReaders.clear(); 
 assertThat(changedResources, hasItem(root.findMember(file))); assertEquals(changedResources.size(), expected.length); 
 assertThat(changedResources, hasItem(root.findMember(file))); assertEquals(changedResources.size(), expected.length); 
 return true; 
 return getProjectsInRepositoryOfSelectedResources().length > 0; 
 return true; 
 ResourcesPlugin.getWorkspace().addResourceChangeListener( resourceChangeListener, IResourceChangeEvent.POST_CHANGE); 
 for (String file : expected) 
 * Copyright (c) 2010-2012 IBM Corporation and others. 
 return getRepository() != null; 
 Map<AnyObjectId, List<ObjectId>> grafts = walk.getGrafts(); if (grafts != null && grafts.size() > 0) { List<ObjectId> graftedParents = grafts.get(getId()); 
 if (filterResults) { if (isTemplate) { 
 fFilterText.setMessage(Messages.GmonView_type_filter_text); fFilterText.setToolTipText(Messages.GmonView_filter_by_name); 
 @Override 
 MessageDialog.openError(Display.getCurrent().getActiveShell(), Messages.RunScriptChartAction_couldNotSwitchToGraphicPerspective, Messages.RunScriptChartAction_couldNotSwitchToGraphicPerspective + ": " + we.getMessage()); //$NON-NLS-1$ 
 IStatus status = new Status(IStatus.ERROR, GraphicalRunPlugin.ID, 1, Messages.RunScriptChartAction_couldNotSwitchToGraphicPerspective , we); ErrorDialog.openError(Display.getCurrent().getActiveShell(), 
 } scriptConsoleInitialized(console); 
 if (project != null && project instanceof IProject) 
 if (preDeleteProjectListener == null) { preDeleteProjectListener = new IResourceChangeListener() { 
 if (preDeleteProjectListener != null) { ResourcesPlugin.getWorkspace().removeResourceChangeListener(preDeleteProjectListener); preDeleteProjectListener = null; 
 if (absPrj.equals(absFile)) 
 * Determine if a proposed reference cannot coexist with existing ones. If 
 * @throws IOException * @since 2.3 * @see #isNameConflicting(String) 
 registerAutoShareProjects(); registerPreDeleteResourceChangeListener(); } private void registerPreDeleteResourceChangeListener() { 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 String tempLocation = Activator.getPluginLocation()+"eag.graph2"; 
 if (graph.getDrawMode() == StapGraph.CONSTANT_DRAWMODE_TREE 
<|del|> 
<|del|>
<|del|> 
<|del|>
<|del|>
<|del|>
 } 
 if (out != null) { 
 this.sizeMap = new HashMap<String, Long>(5); 
 return packName.equals(desc.packName) && getRepositoryDescription().equals(desc.getRepositoryDescription()); 
 public final static String MODEL_URI_KEY = "model.emf.uri"; //$NON-NLS-1$ 
 if (!keepExtension) { 
 IAtsVersion getById(Identity<String> id) throws OseeCoreException; 
 Set<ActionArtifact> actions = createActions(DemoDbActionData.getNonReqSawActionData(), DemoArtifactToken.SAW_Bld_3, null, transaction); 
 Artifact verArt = ArtifactQuery.getArtifactFromId(id.getGuid(), AtsUtilCore.getAtsBranchToken()); 
<|del|> 
 atsAi = AtsConfigCache.instance.getSoleByGuid(ATS_Actionable_Item_Guid_For_Training_And_Demos, IAtsActionableItem.class); 
 atsAi = AtsConfigCache.instance.getSoleByGuid(ATS_Actionable_Item_Guid_For_Training_And_Demos, IAtsActionableItem.class); 
 return Collections.emptyList(); 
 private IAtsTeamDefinition getTeamDefinition() { 
 public static enum ReleasedOption { 
 // this helps debugging 
 } @Override public String toString() { return String.format("PackExt[%s]", getExtension()); //$NON-NLS-1$ } 
 if (StringUtils.isEmptyOrNull(in)) return false; if (!in.startsWith("--")) //$NON-NLS-1$ return false; return name().equalsIgnoreCase(in.substring(2).replace('-', '_')); 
 if (defaultValue instanceof FastForwardMode) { return (T) FastForwardMode.valueOf(section, subsection, name, value); } 
 EObject container = d.getSourceEObject(); 
 * A kernel event type. This is an {@link CtfTmfEvent} with a getPid function. * @author Matthew Khouzam 
<|del|> 
<|del|> 
<|del|> 
 return getMapping(resource.getLocation()); 
public class CProfilingOptionsTab extends AbstractProfilingOptionsTab { 
 Assert.assertEquals(expected, actual); 
 private final AtomicBoolean isRegisteredForEvents = new AtomicBoolean(false); 
 return (int) ConnectionHandler.getSequence().getNextSequence(COVERAGE_TEST_UNIT_NAME_SEQ); 
<|del|> 
<|del|> 
 // this means the state system is not built yet // this is an "expected" exception // you will get here when querying the state system, so retval will still be -1 
<|del|> 
 Assert.assertEquals(expected, actual); 
 private final AtomicBoolean isRegisteredForEvents = new AtomicBoolean(false); 
<|del|> 
public final class CtfKernelEvent extends CtfTmfEvent { 
 ITmfStateSystem ss = getTrace().getStateSystem(CtfKernelTrace.STATE_ID); 
 // this means the state system is not built yet // this is an "expected" exception // you will get here when querying the state system, so retval will still be -1 
<|del|> 
public class CProfilingOptionsTab extends AbstractProfilingOptionsTab { 
<|del|> 
 // [expr.sizeof]/2: "When applied to a reference or a reference type, the 
 CustomEventContent curContent = (CustomEventContent) getContent(); setContent(new CustomEventContent(curContent.getName(), curContent.getValue(), fColumnData)); 
 for (IUpdateListener listener : listeners) { listener.handleUpdateEvent(); } 
<|del|> 
<|del|> 
 public void testSeverityDefinedInExtensionPoint() throws CoreException { 
 * additional pack file extensions with the same base as the pack 
 int bits = 0; for (PackExt ext : extensions) bits |= 1 << ext.getPosition(); this.extensions = bits; 
 } else if (!(b instanceof IType)) { 
 if (currEvent == null || currEvent.getTime() != nextStartTime || (nextStartTime != time && currEvent.getDuration() != nextEvent.getDuration())) { 
 * 
 // same as above 
 if (names.contains(base + ext.getExtension())) 
 int bits = 0; for (PackExt ext : extensions) bits |= 1 << ext.getPosition(); this.extensions = bits; 
 pm.beginTask(JGitText.get().selectingCommits, ProgressMonitor.UNKNOWN); 
<|del|>
 IPath path = new Path( repositoryMapping.getRepoRelativePath(childResource)); 
 /** * @author Miles Parker */ 
 /** * @author Miles Parker */ 
 * additional pack file extensions with the same base as the pack 
 } else if (!(b instanceof IType)) { 
 if(ed.getEditorInput() instanceof PathEditorInput){ return ((PathEditorInput)ed.getEditorInput()).getPath().toString(); } else { return ResourceUtil.getFile(ed.getEditorInput()).getLocation().toString(); } 
 int extensions = 1 << PACK.getPosition() | 1 << INDEX.getPosition(); 
 int extensions = 0; 
 return String.format("PackExt[%s, bit=0x%s]", getExtension(), //$NON-NLS-1$ Integer.toHexString(1 << getPosition())); 
 return String.format("PackExt[%s, bit=0x%s]", getExtension(), //$NON-NLS-1$ Integer.toHexString(1 << getPosition())); 
 * 
 protected IReview createReview() { return getRemoteManager().getBroker(GerritRemoteBroker.REVIEW).create(getModel().getTaskData()); } @Override protected RemoteServiceBroker createRemoteManager() { 
 * 
 if (walk.getPathString().equals(repoRelativePath)) 
 if (diffResourceURI != null && (diffResourceURI.equals(matchResource.getLeftURI()) || diffResourceURI.equals(matchResource.getRightURI()) || diffResourceURI .equals(matchResource.getOriginURI()))) { 
 * @return true if the path matches an ignore rule or no repository mapping * could be found, false otherwise 
 public static final IAttributeType RelatedPeerWorkflowDefinition = createType(0x100000000000037EL, "Related Peer Workflow Definition", "Specific work flow definition id used by Peer To Peer Reviews for this Team"); 
 List<Artifact> artifacts = getSelectedArtifacts(); for (IRenderer renderer : RendererManager.getCommonRenderers(artifacts, PresentationType.F5_DIFF)) { for (Artifact art : artifacts) { 
 if (currentResourceSelection.isEmpty()) { IResource selected = currentResourceSelection.iterator().next(); directoryFileSelector.setDirectorySelected(selected.getType() != IResource.FILE); text = selected.getLocation().toString(); } else { 
<|del|> 
<|del|> 
 private static IAtsActionableItem atsAi; private static String ATS_Actionable_Item_Guid_For_Training_And_Demos = "AAABER+4zV8A8O7WAtxxaA"; 
 return Collections.emptyList(); 
 return (extensions & ext.getBit()) != 0; 
 public void validateTransition(List<WidgetResult> results, IValueProvider valueProvider, IAtsWidgetDefinition widgetDef, IAtsStateDefinition fromStateDef, IAtsStateDefinition toStateDef) { 
<|del|> 
<|del|> 
 * The name of the p2 installation flavor to create. De facto, this parameter is set to * "tooling" in all uses of p2. 
 * By default, this goal creates a p2 repository. Set this to <code>false</code> if only a p2 * metadata repository (without the artifact files) shall be created. 
 * Copyright (c) 2012, 2013 Ericsson, others 
 * Patrick Tasse - Initial API and implementation * Franois Rajotte - Filter implementation 
 * This filter simply keeps a list of elements that should be filtered out. * All the other elements will be shown. 
 * This filter simply keeps a list of elements that should be filtered out. * All the other elements will be shown. 
<|del|> 
 // If object has children team workflows, roll-up results of all ais 
 final IPath newPath = getParent().getResource().getFullPath().addTrailingSeparator().append(newName); 
 fExperiment.copy(newName, true); 
 * Copyright (c) 2011, 2013 Ericsson, cole Polytechnique de Montral 
 fTrace.copy(newName, true); 
 /** * This class handles the execution of the perf stat command * and stores the resulting data. */ 
 public static void refreshView () { 
 public boolean isBooleanUsingCache(String key) throws OseeCoreException; 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 // If object has children team workflows, roll-up results of all ais 
 return isCacheEnabled(key); 
 return isCacheEnabled(key); 
 for(Transition trans : roomExt.getOutgoingTransitionsHierarchical(xpAct, st)){ 
 ScriptDetails sd = new ScriptDetails(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()); 
<|del|> 
 private final Map<String, Set<String>> projectsScriptsMap = new HashMap<String, Set<String>>(); private final Map<String, File> scriptNameToScriptFileMap = new HashMap<String, File>(); private final IProject[] workspaceProjects; 
 private final Map<String, Set<String>> projectsScriptsMap = new HashMap<String, Set<String>>(); private final Map<String, File> scriptNameToScriptFileMap = new HashMap<String, File>(); private final IProject[] workspaceProjects; 
 String projectName = project.getName(); 
 private DefaultFileSet[] additionalFileSets; 
 private final Map<String, Set<String>> projectsScriptsMap = new HashMap<String, Set<String>>(); private final Map<String, File> scriptNameToScriptFileMap = new HashMap<String, File>(); private final IProject[] workspaceProjects; 
 private final Map<String, Set<String>> projectsScriptsMap = new HashMap<String, Set<String>>(); private final Map<String, File> scriptNameToScriptFileMap = new HashMap<String, File>(); private final IProject[] workspaceProjects; 
 private final Map<String, Set<String>> projectsScriptsMap = new HashMap<String, Set<String>>(); private final Map<String, File> scriptNameToScriptFileMap = new HashMap<String, File>(); private final IProject[] workspaceProjects; 
 String scriptName = scriptFile.getName(); 
 String projectName = project.getName(); 
 String projectName = project.getName(); 
 String projectName = project.getName(); 
 URI scriptProjectLocationUri = scriptProject.getLocationURI(); File scriptProjectFile = new File(scriptProjectLocationUri); String scriptProjectLocation = scriptProjectFile.toString(); 
 String itemToMatch = svnEntryPath.substring(svnEntryPath.lastIndexOf("/") + 1); 
 OseeLog.logf(getClass(), Level.SEVERE, "SVNConnectorException while retrieving script SVN info ", ex); 
 /** The 'byte' value associated to string state values (1) */ 
 * The 'byte' value associated to long state values (2) 
 /* Stack depth = 5 */ state = ss.queryFullState(10); assertEquals(5, state.get(attribute).getStateValue().unboxInt()); 
<|del|> 
<|del|> 
 private interface DocumentBuilderExtensionVisitor { public boolean accept(DocumentBuilderExtension extension); } 
 e.printStackTrace(); } finally { try { readStream.close(); } catch (IOException e) { } 
 * Contributors: * Franois Rajotte - Initial API and implementation 
 return null; 
 public static TmfStateValue newValueLong(long longValue) { if (longValue == -1) { return nullValue(); } 
 if (this.getType() != Type.LONG) { 
 private final AbstractRemoteService service; 
 * Associates a remote object to it's model object. See {@link RemoteEmfConsumer#apply()}. 
 * Copyright (c) 2013 Ericsson and others. 
 * Copyright (c) 2013 Ericsson and others. 
 * GDB Tracepoint Analysis Core plug-in activator * @author Francois Chouinard 
 * GDB Trace implementation of TmfEvent * @author Francois Chouinard 
 * GDB Trace implementation of TmfEventField * @author Francois Chouinard 
<|del|> 
<|del|> 
 * GDB Tracepoint Analysis UI plug-in activator * @author Francois Chouinard 
 * GDB Trace perspective factory * @author Francois Chouinard 
<|del|> 
 assertEquals("a", ent_a.getName()); assertEquals("b", ent_b.getName()); assertEquals("d", ent_d.getName()); 
 switch (getByteFromType(sv.getType())) { 
 } 
 } 
 private final Map<String, Definition> definitions = new LinkedHashMap<String, Definition>(); 
<|del|> 
<|del|> 
 String itemToMatch = svnEntryPath.substring(svnEntryPath.lastIndexOf("/") + 1); 
 OseeLog.logf(getClass(), Level.SEVERE, "SVNConnectorException while retrieving script SVN info ", ex); 
 } 
 copyCommentDetailsURL.setEnabled(((ITaskComment) firstElement).getUrl() != null); 
<|del|> 
 } else if (refs.isEmpty()) 
 git.add().addFilepattern("src").call(); writeTrashFile("sr/com/X1.java", ""); 
 if (firstElement instanceof ITaskComment) { 
<|del|> 
 @AfterClass public static void tearDown() { fExperiment.dispose(); } 
<|del|> 
<|del|> 
<|del|> 
 private static final String NAME_NOT_FOUND_SYMBOL = "???"; //$NON-NLS-1$ 
 tooltip = Messages.getString("CachegrindViewPart.Tooltip_no_debug_info"); //$NON-NLS-1$ 
 tooltip = Messages.getString("CachegrindViewPart.Tooltip_no_debug_info"); //$NON-NLS-1$ 
 Pattern.compile("http://www.eclipse.org/gmf/runtime/\\d.\\d.\\d/notation"), null, new CompareDiagramPostProcessor(), 30)); 
 final Comparison comparison = compareWithPostProcessing(left, right, Pattern.compile(".*/nides"), null); 
<|del|> 
 20)); 
 protected TmfTraceFolder getTraceFolder() { 
 * @author Matthew Khouzam 
 protected static final String BATCH_IMPORT_WIZARD_PAGE = "BatchImportWizardPage"; //$NON-NLS-1$ /** * The trace folder, something like "/<project name>/Traces/" */ 
 protected static final String BATCH_IMPORT_WIZARD_PAGE = "BatchImportWizardPage"; //$NON-NLS-1$ /** * The trace folder, something like "/<project name>/Traces/" */ 
 * @param name * the name of the page 
<|del|> 
 // the following classes are stubbed out on purpose. 
<|del|> 
 fFile = f; fName = n; fTraceTypeId = null; 
 /** * Sets the configuration element of the * * @param elem * the element */ public void setConfigurationElement(IConfigurationElement elem) { 
 * A helper class to show the trace types and files and names. it contains the * model which can be defined as follows : {tracetype -> { file1, file2, ... } * }+ * * @author Matthew Khouzam 
class ImportTraceContentProvider implements ITreeContentProvider { 
 /** * reset all the candidates */ public synchronized void clearCandidates() { 
 * Trace label provider for the candidate tree * * @author Matthew Khouzam 
class ImportTraceLabelProvider extends LabelProvider { 
 final File file = ((FileAndName) element).getFile(); if (file != null) { // should never not happen since file is final // and always set automatically return file.getName(); } 
 * @author Matthew Khouzam 
<|del|> 
 fLink.setText(Messages.ImportTraceWizardPageOptions_0); 
 fCopy.setText(Messages.ImportTraceWizardPageOptions_1); 
 fOverwrite.setText(Messages.ImportTraceWizardPageOptions_2); 
<|del|> 
 public void dispose() { fCanRun = false; try { fScanThread.interrupt();// break the wait fScanThread.join(); // it will join } catch (InterruptedException e) { } super.dispose(); 
 column.getColumn().setText(Messages.ImportTraceWizardPageScan_0); 
 column.getColumn().setText(Messages.ImportTraceWizardPageScan_1); 
 column.getColumn().setText(Messages.ImportTraceWizardPageScan_1); 
 while (fCanRun == true) { boolean updated = false; 
<|del|> 
<|del|> 
 * <b>Select the directories to scan for traces</b> this page is the second of * three pages shown. This one selects the files to be scanned. 
 final Table selectedFiles = new Table(control, SWT.H_SCROLL | SWT.V_SCROLL); 
 selectedFiles.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); selectedFiles.setLinesVisible(true); 
 addFile.setText(Messages.ImportTraceWizardPageSelectDirectories_0); 
 addFile.setText(Messages.ImportTraceWizardPageSelectDirectories_0); 
 setErrorMessage(Messages.ImportTraceWizardPageSelectDirectories_4); 
 * <b>Select trace types to import</b>, this page is the first of three pages * shown. This one selects the type of traces that are to be scanned. 
 private CheckboxTreeViewer fTreeView; private final TraceTypeContentProvider fProvider = new TraceTypeContentProvider(); 
 selectAll.setText(Messages.ImportTraceWizardPageSelectTraceType_0); 
 selectNone.setText(Messages.ImportTraceWizardPageSelectTraceType_1); 
 else { 
 getWizard().getContainer().updateButtons(); 
final public class ImportUtils { 
 throw new SQLException(ex); } finally { if (connection != null) { try { connection.close(); } catch (SQLException ex) { // Do nothing on close exception; } } 
 private int getMargin(StateGraphNode node) { 
 checkElement(element); 
 Clipboard clipboard = new Clipboard(null); try { String detailsStr = new CopyActionDetails(awa).getDetailsString(); clipboard.setContents(new Object[] {detailsStr}, new Transfer[] {TextTransfer.getInstance()}); } finally { clipboard.dispose(); 
<|del|> 
<|del|> 
 public void dispose() { if (clipboard != null) { clipboard.dispose(); } 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private boolean hasContent = false; 
 private final ITmfComponent fComponent; private final long fDelay; private final Timer fTimer; private TimerTask fCurrentTask; 
 if (percentComplete == COMPLETED_CANCELLED_PERCENT) { 
 shell.setText(Messages.SelectServerDialog_RemoteServerDetails); 
 public void addFileToScan(String fileName) { 
/** * Trace import helper class * @author Matthew Khouzam * @since 2.0 */ class TraceToValidate implements Comparable<TraceToValidate>{ 
 Conditions.checkNotNullOrEmpty(input, ARTIFACT_IDS_WIDGET_NAME); List<String> inputArtIds = Arrays.asList(input.split("[,\\s]+")); 
 logf("Artifact [%s] attribute type [%s] is valid - did not delete\n", art.toStringWithId(), attrType.toString()); 
 logf("Artifact [%s] attribute type [%s] is valid - did not delete\n", art.toStringWithId(), attrType.toString()); 
 public void shutdown(RequestMonitor requestMonitor) { unregister(); getSession().removeServiceEventListener(this); 
 execContext, 
 private static final String DESCRIPTION = 
 protected static final String BATCH_IMPORT_WIZARD_PAGE = "BatchImportWizardPage"; //$NON-NLS-1$ /** * The trace folder, something like "/<project name>/Traces/" */ 
 //----------------- // Constants //----------------- private static final int MAX_FILES = 32768; 
<|del|> 
 setDialogSettings(section); setNeedsProgressMonitor(true); 
<|del|> 
 public void addFileToScan(String fileName) { 
 public boolean hasFileToScan(String absolutePath) { 
 private void updateFiles() { 
 final private File fFile; private String fTraceTypeId; private String fName; 
 fFile = f; fName = n; fTraceTypeId = null; 
 result = prime * result + ((fTraceTypeId == null) ? 0 : fTraceTypeId.hashCode()); result = prime * result + ((fFile == null) ? 0 : fFile.hashCode()); 
<|del|> 
 final Table selectedFiles = new Table(control, SWT.H_SCROLL | SWT.V_SCROLL); 
 selectedFiles.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true)); selectedFiles.setLinesVisible(true); 
final public class ImportUtils { 
 logf("Artifact [%s] attribute type [%s] is valid - did not delete\n", art.toStringWithId(), attrType.toString()); 
<|del|> 
 if (event.getDMContext() instanceof IContainerDMContext) { IMemoryDMContext context = DMContexts.getAncestorOfType(event.getDMContext(), IMemoryDMContext.class); if (context != null) { fAddressSizes.remove(context); } 
 new DataRequestMonitor<Integer>(ImmediateExecutor.getInstance(), null) { 
 new DataRequestMonitor<Boolean>(ImmediateExecutor.getInstance(), null) { 
 commandFactory.createMIDataEvaluateExpression(exprContext), new DataRequestMonitor<MIDataEvaluateExpressionInfo>(ImmediateExecutor.getInstance(), drm) { 
 commandFactory.createMIDataEvaluateExpression(exprContext), new DataRequestMonitor<MIDataEvaluateExpressionInfo>(ImmediateExecutor.getInstance(), drm) { 
 protected void doReadEndianness(IMemoryDMContext memContext, final DataRequestMonitor<Boolean> drm) { 
 new DataRequestMonitor<CLIShowEndianInfo>(ImmediateExecutor.getInstance(), drm) { 
 public CLIShowEndian(IMemoryDMContext ctx) { 
 public CLIShowEndian(IMemoryDMContext ctx) { 
<|del|> 
 ImageDescriptor overlay = ReviewsImages.OVERLAY_ADDED; image = CommonImages.getImageWithOverlay(baseImage, overlay, false, false); 
 ImageDescriptor overlay = ReviewsImages.OVERLAY_ADDED; image = CommonImages.getImageWithOverlay(baseImage, overlay, false, false); 
 if (!base.getPath().equals(target.getPath())) { ImageDescriptor overlay = ReviewsImages.OVERLAY_RENAMED; image = CommonImages.getImageWithOverlay(baseImage, overlay, false, false); 
 if (!base.getPath().equals(target.getPath())) { ImageDescriptor overlay = ReviewsImages.OVERLAY_RENAMED; image = CommonImages.getImageWithOverlay(baseImage, overlay, false, false); 
<|del|> 
 Command tc; static boolean stapInstalled; 
 LinkedHashSet<Diff> processedDiffs, boolean leftToRight) { 
 final Collection<Diff> reqs = new LinkedHashSet<Diff>(); 
 return Collections.emptyList(); 
<|del|> 
 // Eclipse has been run with -data @none or -data @noDefault options so // we don't need to validate the location if (instanceLocation == null && Boolean.FALSE.equals(context.get(IWorkbench.PERSIST_STATE))) { 
<|del|> 
<|del|> 
<|del|> 
 final Collection<Diff> reqs = new LinkedHashSet<Diff>(); 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 private static final IStatus promptStatus = new Status(IStatus.WARNING, Activator.PLUGIN_ID, 256, "", null); 
 private static final String OSEE_WORD_DIFF_SLEEP_MS = "osee.word.diff.sleep.ms"; 
<|del|> 
 private void createActions() { 
<|del|> 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
<|del|> 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Donald G. Dunne */ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Donald G. Dunne */ 
 protected IAtsVersion getOrCreateVersion(AtsArtifactConfigCache cache, Artifact artifact) throws OseeCoreException { Conditions.checkNotNull(artifact, "artifact"); 
 protected Collection<Artifact> setRelationsOfType(AtsArtifactConfigCache cache, Artifact artifact, Collection<? extends IAtsObject> atsObjects, IRelationTypeSide side) throws OseeCoreException { Conditions.checkNotNull(artifact, "artifact"); 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 Artifact versionArt = ArtifactQuery.checkArtifactFromId(version.getGuid(), AtsUtilCore.getAtsBranchToken()); 
 Artifact versionArt = ArtifactQuery.checkArtifactFromId(version.getGuid(), AtsUtilCore.getAtsBranchToken()); 
 Artifact verArt = ArtifactQuery.getArtifactFromId(version.getGuid(), AtsUtilCore.getAtsBranchToken()); 
 Artifact verArt = ArtifactQuery.getArtifactFromId(version.getGuid(), AtsUtilCore.getAtsBranchToken()); 
 Artifact teamDefArt = ArtifactQuery.getArtifactFromId(teamDef.getGuid(), AtsUtilCore.getAtsBranchToken()); 
 Artifact teamDefArt = ArtifactQuery.getArtifactFromId(teamDef.getGuid(), AtsUtilCore.getAtsBranchToken()); 
 Artifact verArt = ArtifactQuery.getArtifactFromId(version.getGuid(), AtsUtilCore.getAtsBranchToken()); 
 Artifact verArt = ArtifactQuery.getArtifactFromId(version.getGuid(), AtsUtilCore.getAtsBranchToken()); 
 result = loadFromStore(teamDefArt); 
 /** * @author Donald G. Dunne */ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 *******************************************************************************/ package org.eclipse.osee.ats.core; 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 // do nothing 
 // do nothing 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Provided for testing purposes only. 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Roberto E. Escobar */ 
 /** If we have {@link #bestDelta}, the window entry it was created from. */ 
 for (; maxMemory < loaded + need; n = n.next) { 
 public static TracFixture TRAC_1_0_XML_RPC = new TracFixture(Version.XML_RPC, TracTestConstants.TEST_TRAC_10_URL, "1.0", "XML-RPC"); 
<|del|> 
 } IStatus status = buildJob.getResult(); if (status.getCode() != IStatus.OK) { fail(NLS.bind(Messages.getString("AbstractTest.Build_failed"), curProject.getName(), status.getMessage())); //$NON-NLS-1$ } 
<|del|> 
 super(resource.getLocation().toString()); 
 return null; 
 tempException = new CTFReaderException(e); 
 if (fileExists(path)) { 
 return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.GdbTrace_FileNotFound + ": " + path); //$NON-NLS-1$ 
 validStatus = new Status(IStatus.ERROR, Activator.PLUGIN_ID, e.toString(), e); 
 return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.TmfTraceStub_FileNotFound + ": " + path); //$NON-NLS-2$ 
 validTrace = new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.CtfTmfTrace_MajorNotSet); 
 validTrace = new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.CtfTmfTrace_ReadingError +": " + e.toString()); //$NON-NLS-1$ 
 if (!status.isOK()) { 
 if (tmfTrace != null) { 
 * @see org.eclipse.linuxtools.tmf.core.trace.ITmfTrace#validate(IProject, String) 
 validTrace = new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.CtfTmfTrace_ReadingError +": " + e.toString()); //$NON-NLS-1$ 
 if (file.getProject().equals(preferredProject) && file.isAccessible() && 
 if (!base.getPath().equals(target.getPath())) { ImageDescriptor overlay = ReviewsImages.OVERLAY_RENAMED; image = CommonImages.getImageWithOverlay(baseImage, overlay, false, false); 
 * Matthew Khouzam - Changed to LTTngKernelTrace from CtfKernelTrace 
 protected Map<String, String> getEnvironmentSetup(final String path) { 
 if (temp != null) { 
 * Copyright (c) 2012, 2013 Ericsson 
 Map<String, String> temp = getEnvironmentSetup(path); if(temp!= null) { return true; 
 private String shellTitle; private String viewTitle; 
 public List<GenerationSimpleRule> createSimpleRules(); public List<GenerationComplexRule> createComplexRules(); public String getLabel(); 
 private void parseMismatchedException(MismatchedTokenException m) { 
 // actually useful since f may not have a // value 
 if (!this.fExpectingName.isEmpty() && !this.fActualName.isEmpty()) { 
 public static final String PLUGIN_ID = "org.eclipse.linuxtools.gdbtrace.core"; //$NON-NLS-1$ 
 return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.TmfTraceStub_FileNotFound + ": " + path); //$NON-NLS-1$ 
<|del|> 
 return new Status(IStatus.ERROR, Activator.PLUGIN_ID ,Messages.CustomTrace_FileNotFound + ": " + path); //$NON-NLS-1$ 
 return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.CustomTrace_FileNotFound + ": " + path); //$NON-NLS-1$ 
 if (!status.isOK()) { 
<|del|> 
 cleanUp(menu); 
<|del|> 
 iBodyStart = iBodyStart + 1 + input.substring(iBodyStart).indexOf('>'); 
 * * 
 public static String convertToNormalizedHTML(String inputHTML) throws SAXException, IOException, TransformerException { 
<|del|> 
 static String getNamesAttrFeature() { 
 String theText = node.getNodeValue(); 
 private String getFontSize(int theSize, boolean isSizeAttribute) { 
 if (isSizeAttribute) { String[] theSizes = FONT_MAP.values().toArray(new String[0]); 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * This class will convert an HTML string to a normalized format. 
 private Node processNodeWithoutAttributes(Node node, Document doc) { 
 String URI = Strings.nullToEmpty(node.getNamespaceURI()); String name = node.getNodeName().toLowerCase(); 
 String URI = Strings.nullToEmpty(node.getNamespaceURI()); String name = node.getNodeName().toLowerCase(); 
 return node; 
 private Node processFontTag(Node node, Document doc, NamedNodeMap attributes) { 
 String URI = Strings.nullToEmpty(node.getNamespaceURI()); node = doc.renameNode(node, URI, "span"); elem = (Element) node; 
 String URI = Strings.nullToEmpty(node.getNamespaceURI()); node = doc.renameNode(node, URI, "span"); elem = (Element) node; 
 // removing attributes affects the NamedNodeList -- do not do this in the loop 
 if (thePointStart >= thePointEnd) { 
 String URI = Strings.nullToEmpty(node.getNamespaceURI()); String name = node.getNodeName().toLowerCase(); 
 * 
 for (String refPrefix : refPrefixes) 
 * Copyright (c) 2012, 2013 Ericsson 
 * Copyright (c) 2012, 2013 Ericsson 
 * Copyright (c) 2012, 2013 Ericsson 
<|del|> 
<|del|> 
 * Copyright (c) 2012, 2013 Ericsson and others 
 * Copyright (c) 2012, 2013 Ericsson 
<|del|> 
 * Copyright (c) 2013 Ericsson 
 * Copyright (c) 2013 Ericsson 
 * Copyright (c) 2013 Ericsson and others 
 * Copyright (c) 2013 Ericsson 
 * Copyright (c) 2013 Ericsson 
 public static synchronized TmfTraceManager getInstance() { 
 public synchronized void timeRangeUpdated(final TmfRangeSynchSignal signal) { 
 if (theSize <= FONT_VALUES.length) { theReturn = FONT_VALUES[theSize - 1]; 
 String toReturn = ""; 
 repository2 = FileRepositoryBuilder.create(gitDir2); 
 Repository myRepository = FileRepositoryBuilder.create(gitDir); 
 Repository repository = FileRepositoryBuilder.create(new File(destRepo, Constants.DOT_GIT)); 
 Repository repository = new FileRepository(new File(destinationRepo, Constants.DOT_GIT)); 
 Repository repo1 = FileRepositoryBuilder.create(new File( createProject(projectName1), "../.git")); 
 final Repository db = FileRepositoryBuilder .create(new File("/tmp")); //$NON-NLS-1$ 
 repository = FileRepositoryBuilder.create(new File(repo)); 
 Repository repository = FileRepositoryBuilder .create(gitDir); 
<|del|> 
<|del|> 
 StringBuilder styleString = new StringBuilder(""); String theSizeString = ""; 
 return processText(doc); 
 StringBuffer theSizeString = new StringBuffer(""); 
 int theSize = Integer.valueOf(attributeValue.trim()); if (theSize <= FONT_VALUES.length) { theSizeString.replace(0, theSizeString.length(), FONT_VALUES[theSize - 1]); } 
 if (theSizeString.length() > 0) { 
 if (theSizeString.length() > 0) { 
 return new Status(IStatus.ERROR, GerritCorePlugin.PLUGIN_ID, message + " (Repository Unknown)"); 
 return "Originally: " + fileItem.getBase().getPath() + " " + target.getDescription(); } else { return target.getPath() + " Revision: " + target.getDescription(); 
 if (dslUserDef.getUserDefOption().contains("GetOrCreate")) { userArt = UserManager.createUser(getOseeUser(dslUserDef), transaction); } 
 return String.format("UserToken [userId=[%s], active=[%s], admin=[%s], email=[%s], creationRequired=[%s]", userId, active, admin, email, creationRequired); 
 try { duringCreateUser.set(true); currentUser = writer.createUser(currentUserToken, "Populate current user"); ClientSessionManager.clearUserCreationRequired(); } finally { duringCreateUser.set(false); } 
 toReturn = tempUser; break; 
 private static boolean containsCurrentUser(Collection<User> users) throws OseeCoreException { 
 * @param dependents The dependent images 
 * Get children elements * @return array of children or null 
 * Return whether the element has any children * @return true if the element has any children, false otherwise 
 int matchIndex = -1; 
 * Test suite for the {@link TmfTraceManager}. 
 private static final long t1start = 1331668247314038062L; private static final long t1end = 1331668259054285979L; 
 public synchronized ITmfTimestamp getCurrentTime() { 
 public synchronized TmfTimeRange getCurrentRange() { 
 public synchronized ITmfTrace getActiveTrace() { 
 public synchronized ITmfTrace[] getActiveTraceSet() { 
 * Return whether the element has any children * @return true if the element has any children, false otherwise 
 int matchIndex = -1; 
 String searchString = text.getText(); String findRegex = findString; 
 // offset is -1 when text boundaries are reached during a wrapped search 
<|del|> 
 ITmfSyncSequenceDiagramEvent sdEvent = getSequenceDiagramEvent(event); 
 public static String ScpExec_errorConnectingToServer; 
 public static String RunModuleAction_connectionError; public static String RunModuleAction_ioError; 
 public static String SystemTapScriptLaunchConfigurationTab_errorInitializingTab; 
 * threads * * @noextend This class is not intended to be subclassed by clients. 
 * @since 1.0 * @noimplement This interface is not intended to be implemented by clients. 
 * below the "Place Generated Code Here" comment * * @noextend This class is not intended to be subclassed by clients. * @noinstantiate This class is not intended to be instantiated by clients. * @since 1.0 
<|del|> 
public class ImportTraceWizardPageSelectDirectories extends AbstractImportTraceWizardPage { 
 } else { 
 } else { 
 if (workbench != null) { final IWorkbenchWindow activeWorkbenchWindow = workbench.getActiveWorkbenchWindow(); if (activeWorkbenchWindow != null) { Shell shell = activeWorkbenchWindow.getShell(); 
public final class ImportUtils { 
 protected final TmfTraceManager fTraceManager; 
 if (oldInput != newInput && newInput != null) { ImportTraceContentProvider input = (ImportTraceContentProvider) newInput; clearCandidates(); fTraceTypes.putAll(input.fTraceTypes); fTraceFiles.putAll(fTraceFiles); 
 }else if (fCategoryName.equals(ImportUtils.CUSTOM_TXT_CATEGORY) || fCategoryName.equals(ImportUtils.CUSTOM_XML_CATEGORY)) { 
 if (traceFolder == null) { 
<|del|> 
<|del|> 
 protected static final String BATCH_IMPORT_WIZARD_PAGE = "BatchImportWizardPage"; //$NON-NLS-1$ 
 // the following methods are stubbed out on purpose. 
<|del|> 
<|del|> 
 } // if this turns out to be too slow, put in a progress monitor. Does not // appear to be slow for the moment. 
 } } catch (InterruptedException e) { monitor.done(); return new Status(IStatus.ERROR, Activator.PLUGIN_ID, e.getMessage(), e); 
class CElement implements IConfigurationElement { 
 @SuppressWarnings("deprecation") 
 // ------------------------------------------------------------------------ 
<|del|> 
<|del|> 
 /** * Add a trace candidate to display * 
 * Reset all the candidates 
<|del|> 
 // -------------------------------------------------------------------------------- // Constructor and destructor // -------------------------------------------------------------------------------- 
<|del|> 
 } else { 
 } else { 
public final class ImportUtils { 
 private static ImportUtils fInstance = null; 
 /** * The import utils instance * 
 /** * Returns a list of "category : tracetype , ..." * 
<|del|> 
 for (String key : this.fTraceTypes.keySet()) { 
 /** * gets the custom trace types (custom text and friends) * 
 * Gets a trace type for a given canonical id * * @param id * the ID of the trace 
<|del|> 
 /** * the list of trace categories * 
 /** * Get the trace types * 
 /** * Validate a trace type * 
 private ProgressMonitorPart fProgressMonitor; 
 /** * Gets the progress monitor, can be null * 
 * Background job to run 
 private class HelperThread extends Thread { 
/** * TraceType, a helper that can link a few names to a configuation element and a * trace * 
<|del|> 
<|del|> 
 *******************************************************************************/ 
/** * Trace type content provider, a helper for showing trace types * 
 private final List<String> fTraceCategory = new ArrayList<String>(); private final Map<String, List<TraceType>> fTraceType = new HashMap<String, List<TraceType>>(); 
 if (workbench != null) { final IWorkbenchWindow activeWorkbenchWindow = workbench.getActiveWorkbenchWindow(); if (activeWorkbenchWindow != null) { Shell shell = activeWorkbenchWindow.getShell(); 
public final class ImportUtils { 
 return target.getPath() + "\n renamed from: " + base.getPath() + " " + target.getDescription(); 
 return target.getPath() + "\n renamed from: " + base.getPath() + " " + target.getDescription(); 
 * @return An array of child elements or null 
 * @return The parent element or null 
 * Returns the children of this element. * @return An array of child elements or null 
 * @return parent The parent element or null 
 * Returns the children of this element. * @return An array of child elements or null 
 * @return parent The parent element or null 
 * Returns the children of this element. * @return An array of child elements or null 
 * @return The parent element or null 
 * Returns the children of this element. * @return An array of child elements or null 
 * this may be a Java7 subclass with detailed information * @since 3.3 
<|del|> 
 if (ce == null) { 
<|del|> 
 /** * Returns the ScannedTraces model * 
 /** * Gets the configuration element canonical name * 
 // Comparator & Equals 
<|del|> 
<|del|> 
 final private BlockingQueue<TraceValidationHelper> fTracesToScan = new ArrayBlockingQueue<TraceValidationHelper>(MAX_TRACES); 
 if (!control.isDisposed()) { control.getDisplay().asyncExec(new Runnable() { 
 private static final String BUNDLE_NAME = "org.eclipse.linuxtools.tmf.ui.project.wizards.importtrace.messages"; //$NON-NLS-1$ 
 public static String BatchImportTraceWizard_add; 
 * @return An array of child elements or null 
 * @return the repository this iterator works with * * @since 3.3 
 /** * @return how we handle symbolic links * @since 3.3 */ 
 * 
 } else if (parent instanceof IASTIdExpression) { 
<|del|> 
 // int* a = new int[10]; 
/* final IASTNode parent = expr.getParent(); 
 private List<NestableBlock> blocks; 
 this.blocks = cloneBlocks(Arrays.asList(blocks)); 
class Messages { 
 String markup = "This is [ an example ](http://example.com/ \"Title\") inline link."; 
 XMLInputFactory factory = XMLInputFactory.newInstance(); Reader myStringReader = new StringReader(standardHTML); XMLEventReader reader = factory.createXMLEventReader(myStringReader); XMLEvent event = null; 
 String rowValue = row[rowIndex]; 
 String rowValue = row[rowIndex]; 
<|del|> 
public class BarChartEntry implements ITimeGraphEntry { 
 final private String fStateTypeName; 
 public void postDrawControl(ITmfTimeGraphDrawingHelper drawingHelper, Rectangle bounds, GC gc) { 
<|del|> 
// a.assertReadWriteFlags("*a = 5", "a", WRITE); 
 } 
 if (node instanceof IASTArraySubscriptExpression) { // multidimensional array ++indirection; 
 /** * @author Roberto E. Escobar */ 
 for (String key : columns.keySet()) { 
 return org.eclipse.osee.framework.jdk.core.util.Collections.toString(",\n", lines); 
 if (constraintStatements.isEmpty()) { toExecute.append(""); } else { toExecute.append(",\n"); } 
 toReturn.append("CONSTRAINT ").append(id).append(" ").append(type).append(" (").append(appliesTo).append(")"); 
 throw new OseeDataStoreException("Unsupported database type [%s] ", db); 
 return DriverManager.getConnection(url, props); 
 int numTimes = CHECK_ALIVE_NUMBER_OF_TIMES; 
 if (fEvent instanceof ITmfCustomAttributes) { ITmfCustomAttributes event = (ITmfCustomAttributes) fEvent; if(event.listCustomAttributes() != null && !event.listCustomAttributes().isEmpty()){ descriptors.add(new ReadOnlyTextPropertyDescriptor(ID_CUSTOM_ATTRIBUTE, NAME_CUSTOM_ATTRIBUTES)); } 
<|del|> 
 if((fEvent instanceof ITmfCustomAttribute) && !((ITmfCustomAttribute)fEvent).listCustomAttributes().isEmpty()){ if(((ITmfCustomAttribute)fEvent).listCustomAttributes().size() != 1) { 
 } else if (id.equals(ID_CUSTOM_ATTRIBUTE)) { 
 public static final String ID = "org.eclipse.linuxtools.lttng2.kernel.ui.views.controlflow"; //$NON-NLS-1$ 
 public static final String ID = "org.eclipse.linuxtools.lttng2.kernel.ui.views.resources"; //$NON-NLS-1$ 
 * @param weights * The relative weights of each side of the sash form 
 /** * @author Roberto E. Escobar */ 
 * Genevive Bastien - Add Struct and Variant field handling * Jean-Christian Kouame - Correct handling of unsigned integer fields 
 if (!signed && value < 0) { /* Since there are no 'unsigned long', handle this case with BigInteger */ 
 if (fileExists(path)) { if ((new File(path)).isFile()) { 
 return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.GdbTrace_GdbTracesMustBeAFile + ": " + //$NON-NLS-1$ path + " " + Messages.GdbTrace_IsNotAFile); //$NON-NLS-1$ 
<|del|> 
 if (translatedIncludesToPut.size() > 0 || symbols.size() > 0) { 
 "Include paths", includes, translatedIncludesToPut, "Defined symbols", symbols); //$NON-NLS-1$ //$NON-NLS-2$ 
 if (fAssociatedValue != null) 
<|del|> 
 else if (object instanceof IAtsTeamWorkflow) { 
 return artifact.isUseBackingdata() ? artifact.getGammaId() : ConnectionHandler.getSequence().getNextGammaId(); 
 return attribute.isUseBackingData() ? attribute.getGammaId() : ConnectionHandler.getSequence().getNextGammaId(); 
<|del|> 
 public final static String formatNumber(long value, int base, boolean signed) { 
 if (translatedIncludesToPut.size() > 0 || symbols.size() > 0) { 
 "Include paths", includes, translatedIncludesToPut, "Defined symbols", symbols); //$NON-NLS-1$ //$NON-NLS-2$ 
 * Matthew Khouzam - Initial API and implementation * Simon Delisle - Generate dummy trace 
<|del|> 
 f = new File(tempTraceDir + "/dummyChan"); 
 * * @throws CTFReaderException * something wrong happened 
 else if (object instanceof IAtsTeamWorkflow) { 
 AtsTest_Access_Suite.class, AtsTest_Action_Suite.class, AtsTest_Log_Suite.class, AtsTest_Column_Suite.class, AtsTest_Config_Suite.class, AtsTest_Editor_Suite.class, 
 return result; 
 for (IAtsWorkPackage workPkg : workPackages) { checkForCancelledStatus(monitor); 
 String temp[] = traceType.split(":", 2); //$NON-NLS-1$ 
<|del|> 
 if (item instanceof AbstractGroupMarker) { 
<|del|> 
 /** * Additional properties against which p2 filters are evaluated while aggregating. * * @parameter */ private Map<String, String> profileProperties; 
 // The byteBuffer needs to be flipped in file writing mode 
<|del|> 
 final int nbEvents = (DATA_SIZE / ev.getSize()) - 1; 
 // The byteBuffer need to be flip in file writing mode data.flip(); 
 if (m.getOldPath().equals(n.getOldPath())) 
 private final Map<String, List<String>> newCCProposals = new HashMap<String, List<String>>(); 
 * time will be updated. 
 * Patrick Tasse - Close editors to release resources * Jean-Christian Kouame - added trace properties to be shown into * the properties view * Genevive Bastien - New is_experiment parameter to trace type extension 
 void putEntry(T out, String path, FileMode mode, ObjectLoader loader) throws IOException; 
 final Format<?> fmt = lookupFormat(format); 
 } 
 public void testExperimentTimestampInvalid() { 
 private static final String BUNDLE_NAME = "org.eclipse.linuxtools.internal.systemtap.ui.ide.actions.messages"; //$NON-NLS-1$ 
<|del|> 
<|del|> 
 private final Color defaultForeground; 
 if (!scrollView.isDisposed()) { 
 * {@link ArchiveFormats#registerAll()}. This method is called by the OSGi 
 * {@link ArchiveFormats#unregisterAll}. 
<|del|> 
 edit = (gdata != null); if (edit) { 
 if (wizard.isEditing() && graphIDs[i].equals(wizard.model.getGraphID())) { 
 boolean cvisible = edit; 
 cboYItems[i].setVisible(cvisible); lblYItems[i].setVisible(cvisible); cvisible = (index > 0); 
 txtKey.setText(model.getGraphData().key); } 
 for (Thread thread : threads) { thread.join(); 
<|del|> 
 protected static class ControlFlowTreeLabelProvider extends TreeLabelProvider { 
 TimeEvent tcEvent = (TimeEvent) event; if (tcEvent.hasValue()) { return INVISIBLE; } 
 if (event instanceof TimeEvent) { TimeEvent tcEvent = (TimeEvent) event; if (tcEvent.hasValue()) { return null; } } return Messages.ResourcesView_multipleStates; 
 // In SOFT_IRQ state get the SOFT_IRQ that caused the interruption 
 e.printStackTrace(); } catch (StateSystemDisposedException e) { /* Ignored */ 
<|del|> 
<|del|> 
 lastIsNull = true; 
 lastIsNull = true; 
<|del|> 
 synchingToTime(time); 
 public static String AbstractTimeGraphtView_NextText; public static String AbstractTimeGraphView_NextTooltip; public static String AbstractTimeGraphView_PreviousText; public static String AbstractTimeGraphView_PreviousTooltip; public static String TimeGraphPresentationProvider_multipleStates; 
 /** Id field that may be used by views, so they don't have to extend this class if they don't need to */ 
 public void setName(String name) { fName = name; 
 public Iterator<ITimeEvent> getTimeEventsIterator(long startTime, long stopTime, long visibleDuration) { if (!hasTimeEvents()) { return null; } 
 * Get the trace object 
import org.eclipse.core.resources.IResource; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.Status; 
 * Move on to the next tag if an unusued level (tag == O) is encountered, 
 /** * Saves the choice of graph type to the model. * @param selected The ID of the selected graph. */ 
 @GET @Produces(MediaType.TEXT_HTML) 
 wizard = (SelectGraphAndSeriesWizard)getWizard(); 
 private String columnName; 
 private String columnName; 
 column.addSelectionListener(new SelectionAdapter() { 
 if (isDisplayLabel() && Strings.isValid(getLabel())) { 
<|del|> 
<|del|> 
 long end = System.currentTimeMillis(); long diff = end - start; 
 long end = System.currentTimeMillis(); long diff = end - start; 
 IComment comment = (IComment) element; if (comment.isMine()) { return CommonImages.getImage(CommonImages.PERSON_ME); } 
 if (!biDirectionalPipe) { if (requestPolicy == RequestPolicy.ADVERTISED) requestPolicy = RequestPolicy.REACHABLE_COMMIT; else if (requestPolicy == RequestPolicy.TIP) requestPolicy = RequestPolicy.REACHABLE_COMMIT_TIP; } 
 SpecfileLog.logError("Unable to evaluate " + toResolve, e); //$NON-NLS-1$ 
 if (detail == null) { 
 if (detail == null) { 
 checkIfModelIsCached(); 
 public static String Gdbserver_name_textfield_label; 
 private final Map<ITmfTrace, List<TimeGraphEntry>> fEntryListMap = new HashMap<ITmfTrace, List<TimeGraphEntry>>(); 
 private static final int[] DEFAULT_WEIGHTS = { 1, 1 }; 
 private static final String[] COLUMN_NAMES = new String[] { 
 private static final String[] FILTER_COLUMN_NAMES = new String[] { 
 if (columnIndex == NAME_COL) { 
 private final int fQuark; 
 private static final String[] COLUMN_NAMES = new String[] { 
 private static final String[] FILTER_COLUMN_NAMES = new String[] { 
 private static final int[] WEIGHTS = { 15, 85 }; 
 setStartTime(Long.MAX_VALUE); setEndTime(Long.MIN_VALUE); 
 /** The timegraph combo */ 
 /** The timegraph entry list */ private List<TimeGraphEntry> fEntryList; 
 /* The trace to build thread hash map */ private final Map<ITmfTrace, BuildThread> fBuildThreadMap = new HashMap<ITmfTrace, BuildThread>(); 
 /* The trace to build thread hash map */ private final Map<ITmfTrace, BuildThread> fBuildThreadMap = new HashMap<ITmfTrace, BuildThread>(); 
 /** The start time */ 
 /** The display width */ 
 /** The zoom thread */ 
 /** The redraw state used to prevent unnecessary queuing of display runnables */ 
 /** Tooltip for the "next" button */ 
<|del|> 
 * Copyright (c) 2013 cole Polytechnique de Montral 
<|del|> 
 ITmfTimeGraphDrawingHelper getDrawingHelper(); 
 /** Default weight of each part of the sash */ private static int[] DEFAULT_WEIGHTS = { 1, 1 }; 
 private ITmfTimeGraphDrawingHelper fDrawingHelper; private final String fStateTypeName; 
 private ITmfTimeGraphDrawingHelper fDrawingHelper; private final String fStateTypeName; 
 private final int fValue; 
 fEventList = new ArrayList<ITimeEvent>(eventList); 
 fZoomedEventList = new ArrayList<ITimeEvent>(eventList); 
 int getXForTime(long time); 
 * Copyright (c) 2007, 2013 Intel Corporation and others * 
 ((ITimeGraphPresentationProvider2) timeGraphProvider).setDrawingHelper(this); 
<|del|> 
<|del|> 
<|del|> 
 @Rule public OseeClientIntegrationRule integration = new OseeClientIntegrationRule(OSEE_CLIENT_DEMO); 
 private final IOseeCachingService cacheService; private final URI model; private final boolean isPersistAllowed; private final boolean createTypeChangeReport; 
 "Couldn't obtain patch set content for " + content.getId() + ". Check remote connection.", e)); 
<|del|> 
 TimeGraphPresentationProvider pres) { 
 final int current = bucketIndex[bucket]; bucketIndex[bucket] = bucketValuesPos; 
 * Client may ask for any commit reachable from any reference, even if that * reference wasn't advertised. 
 /** Label for the Filter button * @since 2.1*/ 
 if (ts == -1 || ts < ss.getStartTime() || ts > ss.getCurrentEndTime()) { ts = ss.getStartTime(); } 
<|del|> 
 if (editor != null && getTreeViewer().getTree() != null && Widgets.isAccessible(getTreeViewer().getTree())) { 
 return dateFmt + timeFmt + (ssecFmt.equals(SUBSEC_NO_FMT) ? "" : '.' + ssecFmt); //$NON-NLS-1$; 
 SEC_FORMAT, SEC_FORMAT_HEADER, MIN_FORMAT, MIN_FORMAT_HEADER, HOURS_FORMAT, HOURS_FORMAT_HEADER, DAY_FORMAT, DAY_FORMAT_HEADER, MONTH_FORMAT, YEAR_FORMAT 
 SEC_FORMAT, SEC_FORMAT_HEADER, MIN_FORMAT, MIN_FORMAT_HEADER, HOURS_FORMAT, HOURS_FORMAT_HEADER, DAY_FORMAT, DAY_FORMAT_HEADER, MONTH_FORMAT, YEAR_FORMAT 
<|del|> 
<|del|> 
 * Copyright (c) 2012, 2013 Obeo and others. 
 * Copyright (c) 2012, 2013 Obeo and others. 
 public static boolean isSourceFile(IIndexFile indexFile, IProject project) throws CoreException { 
 MessageDialog.openError(shell, Localization.getString("ToggleComment_error_title"), //$NON-NLS-1$ Localization.getString("ToggleComment_error_message")); //$NON-NLS-1$ 
<|del|> 
<|del|> 
 fEventList = new EventList(eventList, Long.MAX_VALUE, Long.MIN_VALUE); 
 fZoomedEventList = new EventList(eventList, Long.MAX_VALUE, Long.MIN_VALUE); 
 private boolean isVersion27OrLater(IProgressMonitor monitor) throws GerritException { Version version = getCachedVersion(monitor); return GerritVersion.isVersion27OrLater(version); 
 for (ITmfTrace childtrace : TmfTraceManager.getTraceSet(sender)) { if (sp.getTrace() == childtrace) { 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Angel Avila */ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 logf(String.format( "To allow this blam to set multiple values, please change an artifact under the folder [%s] to contain multiple values using Artifact Editor.", folder)); 
 logf(String.format( "Artifacts with multiple values for [%s] were found under the selected folder [%s], however, the \'Multiple values allowed for this attribute?\' check box was not selected.", attribute, folder)); 
<|del|> 
 *******************************************************************************/ 
/** * Test suite for the TmfTimePreferences class. */ 
<|del|> 
 *******************************************************************************/ 
 /** * Return the timestamp pattern * 
 /** * Return the interval pattern * 
 return ITmfTimePreferencesConstants.TIME_ELAPSED_FMT + "." + ssecFmt; //$NON-NLS-1$ 
 void setParent(Segment<?> parent) { 
 fEventList = eventList; fZoomedEventList = zoomedEventList; 
 private final List<ITimeEvent> fEventList; private final long fStartTime; private final long fEndTime; 
 fEventList = Collections.unmodifiableList(list); } else { fEventList = null; 
 fEventList = Collections.unmodifiableList(list); } else { fEventList = null; 
 MyModel[] model = createModel(); v.setInput(model); // Select the initial Element if (model.length > 0) { v.setSelection(new StructuredSelection(model[0])); } 
 MyModel[] model = createModel(); v.setInput(model); // Select the initial Element if (model.length > 0) { v.setSelection(new StructuredSelection(model[0])); } 
 * Copyright (c) 2013 Obeo. 
<|del|> 
<|del|> 
 FindReplaceDocumentAdapter adapter = new FindReplaceDocumentAdapter(getDocument()); adapter.find(leftSubexprEnd, 
 * Returns the (possibly cached) account for this client. 
 public boolean isWaitForMerge() { return wait_for_merge; 
 dispose(); 
 return "Check the consitency of Attribute values under a specified Folder Artifact."; 
 private String findMostPopularAttributeValue(List<Artifact> allDescendants, IProgressMonitor monitor) throws OseeCoreException { 
 if (multipleValuesFound) { 
 distanceCache = new AccessBasedLRUCache<Pair, Double>(10000, 1000, .75F); 
 * Copyright (c) 2012, 2013 Obeo. 
 * @param marker The {@link IMarker} from which the {@link IASTTranslationUnit} will be obtained * @return {@link IASTTranslationUnit} containing the marker 
 * @param marker {@link IMarker} from which the length will be obtained * @return length of the code enclosed in the {@link IMarker} 
 /** * Exception that is thrown when an error occurs while manipulating the messages * in the Valgrind view for valgrind's quick-fix execution. * @author rafaelmt * */ 
 if(allocFunction.contains(NEW)){ content = document.get(nodeOffset, nodeLength).replace(DELETE, DELETE + "[]"); //$NON-NLS-1$ 
 if (changeFlag == INavigatable.NEXT_CHANGE || changeFlag == INavigatable.PREVIOUS_CHANGE) { return true; } return false; 
 protected boolean containsChildrenWithDataEqualsToDiff(TreeNode treeNode, Diff diff) { 
 * @see org.eclipse.emf.compare.ide.ui.internal.contentmergeviewer.EMFCompareContentMergeViewer#createToolItems(org.eclipse.jface.action.ToolBarManager) 
 protected void createToolItems(ToolBarManager toolBarManager) { super.createToolItems(toolBarManager); 
<|del|> 
 IMergeViewerItem valueToAdd = createMergeViewerItemFrom((EObject)value); if (valueToAdd != null) { ret.add(valueToAdd); 
<|del|> 
<|del|> 
 String traceTypeId = CustomTxtTrace.class.getCanonicalName() + ':' + def.definitionName; 
 String traceTypeId = CustomXmlTrace.class.getCanonicalName() + ':' + def.definitionName; 
 String traceTypeId = CustomXmlTrace.class.getCanonicalName() + ':' + def.definitionName; 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorRefreshingProperty + getName(), e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorClosingEditor + getName(), e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorDeletingSF + supplFolder, e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorRenamingSF + oldSupplFolder, e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorCopyingSF + oldSupplFolder, e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorCopyingSF + oldSupplFolder, e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorDeletingSF + supplFolder, e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorDeletingSR + resources[i], e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorCreateSuppRes + supplFolder, e); 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorSettingProperty + TmfCommonConstants.TRACE_SUPPLEMENTARY_FOLDER, e); 
 Activator.getDefault().logError(Messages.TmfExperimentElement_ErrorInstantiatingTrace + getName(), e); 
 return (ce != null) ? (getCategory(ce) + ':' + ce.getAttribute(TmfTraceType.NAME_ATTR)) : new String(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 ObjectId c4 = merge(c2); 
 return git.commit().setAll(true).setMessage(content).call().getId(); 
<|del|> 
 DescribeCommand setTarget(String rev) throws IOException, RefNotFoundException { 
<|del|> 
<|del|> 
 * Called after the editor switched to another stylesheet. 
 * @return a {@link DescribeCommand}. * @since 3.1 
 boolean firstTime = getBooleanOption(FIRST_TIME); boolean secondTime = getBooleanOption(SECOND_TIME); 
 renderer.setOption(ALL_ATTRIBUTES, true); 
 if ((recurseChildren && !renderer.getBooleanOption(RECURSE_ON_LOAD)) || (renderer.getBooleanOption(RECURSE_ON_LOAD) && !renderer.getBooleanOption("Orig Publish As Diff"))) { 
 String attribName = (String) renderer.getOption(ATTRIBUTE_NAME); 
<|del|> 
 E element = filtered[i]; 
 List<E> selection = getSelectionFromWidget(); 
 fFile.seek((Long) context.getLocation().getLocationInfo() + 1); // +1 is for the < 
 fFile.seek((Long) context.getLocation().getLocationInfo() + 1); // +1 is for the < 
 public void error(final SAXParseException saxparseexception) throws SAXException {} 
 public void warning(final SAXParseException saxparseexception) throws SAXException {} 
<|del|> 
 List<ILinkEvent> events = getLinkList(fZoomStartTime, fZoomEndTime, fResolution, fMonitor); fTimeGraphCombo.setLinks(events); 
 public void setLinks(List<ILinkEvent> links) { 
 fTimeGraphCtrl.refreshArrows(links); 
<|del|> 
public class TimeLinkEvent extends TimeEvent implements ILinkEvent { 
 public void refreshArrows(List<ILinkEvent> events) { 
 drawLinks(bounds, fTimeProvider, fItemData.fLinks, nameSpace, gc); fTimeGraphProvider.postDrawControl(bounds, gc); 
<|del|> 
<|del|> 
 List<ILinkEvent> links, int nameSpace, GC gc) { for (ILinkEvent event : links) { 
 List<ILinkEvent> links, int nameSpace, GC gc) { for (ILinkEvent event : links) { 
 int offset = src.height / 2; 
 if (colorIdx < 0) { 
 * Hendrik Still <hendrik.still@gammas.de> - bug 412273 
 StringBuilder builder = new StringBuilder(getActivityId()); addWithHypen(builder, getActivityName()); addWithHypen(builder, getWorkPackageId()); addWithHypen(builder, getName()); return builder.toString(); 
 private void compareAllChildrenWithPopularValue(List<Artifact> allDescendants, String popularValue, Artifact folder, IProgressMonitor monitor) throws OseeCoreException { 
<|del|> 
 void setParent(Segment<?> parent) { 
 public static final String OUTLINE_CONTENT = "-vex-outline-content"; 
 * -vex-outline-content: titleabbrev, title; 
<|del|> 
 assertNotNull(testFile.getProject().findMember("test")); 
 if (resourceToOpen == null) { 
 if (sourcesFolder != null) { 
<|del|> 
<|del|> 
 * @author Jean-Christian Kouam 
 * @author Jean-Christian Kouam 
 private final static int GREATER = 1; private final static int EQUAL_OR_DIFFERENT_TYPE = 0; private final static int LOWER = -1; 
 * Alexandre Montplaisir - Initial API * Jean-Christian Kouam - make state values comparable 
 return 0; 
<|del|> 
 try { return this.unboxStr().compareTo(value.unboxStr()); } catch (StateValueTypeException e) { return 0; } 
 * IBM Corporation - initial API and implementation * Google Inc - added LongEventWatchdogKennel 
 return HistoryBuilder.openExistingHistory(htBackend); 
<|del|> 
 fEventList = new ArrayList<ITimeEvent>(eventList); 
 fZoomedEventList = new ArrayList<ITimeEvent>(eventList); 
 private static final int RESOLUTION = 16; static final long INTERESTINGTIMESTAMP = 12345000L; 
 public static final String AVG_STRING = "avg"; //$NON-NLS-1$ 
 public MipMapProvider(ITmfTrace trace, Class<? extends ITmfEvent> eventType, String id, boolean computeManually) { 
 * initialize the first interval at the timestamp where the 
 private void updateAvrg(int quark, int currentLevelAttribute, int nextLevelAttribute, int level) { 
 private ITmfStateValue getNewStateValue(int quark, long value) { Type type = attributes.get(quark).getType(); 
 manager.generateComment(testTask, "${task.status} ${TestVar( x )} ${task.description}")); assertEquals("Incomplete TestSummary", manager.generateComment(testTask, "${task.status} ${noexist( \"x\" )} ${task.description}")); 
 * For now you can change the scheduler by changing the fExecutor in * {@link TmfDataProvider#TmfDataProvider} and {@link TmfDataProvider#init} 
 Activator.logError(command + " Wrong thread type. Expecting TmfEventThread"); //$NON-NLS-1$ 
<|del|> 
 private synchronized void scheduleNext() { 
 private boolean hasTasks() { 
 File testDir = customTestDirectory(); if (testDir == null) { testDir = FS.DETECTED.userHome(); rootDir = new File(testDir, "egit.test.tmpdir"); } else rootDir = testDir; 
 private String shortenChangeId(String changeId) { if (StringUtils.countMatches(changeId, String.valueOf('~')) == 2) { // project~branch~change_id in Gerrit 2.6 and later 
 // ensure that concurrent test runs don't use the same directory baseTempDir = new File(rootDir, UUID.randomUUID().toString() .replace("-", "")); System.out.println(baseTempDir.getAbsolutePath()); 
public class SelectElementTypeContributionItem extends CompoundContributionItem { 
 TraceUtils.displayErrorMsg(NLS.bind(Messages.TmfOpenTraceHelper_OpenElement, experimentElement.getTypeName()), NLS.bind(Messages.TmfOpenTraceHelper_NoTraceOrExperimentType, experimentElement.getTypeName())); 
 private static final String TITLE_REGEX = "(?:\\s+[\"'\\(](.*?)[\"'\\)])?"; //$NON-NLS-1$ 
<|del|> 
 "You are the %s of [%s] in state [%s] titled [%s] created on [%s]", data.getEmailRecipient().name(), 
 boolean ret = false; 
 } catch (Exception e) { 
 if (!perspStackList.isEmpty()) { selectedPersp = perspStackList.get(0).getSelectedElement(); 
<|del|> 
<|del|> 
 workingSetGroup.setWorkingSets(EMPTY_WORKING_SET_ARRAY); 
 List<?> elements= treeSelection.toList(); 
 for (Object element : elements) { 
 if (!result.isEmpty()) { 
<|del|> 
 * * @param listener * the mouse wheel listener 
 final int beginBucket = scaledData.fSelectionBeginBucket; 
 int lostEventPerBucket = (int) Math.ceil((double) nbLostEvents / nbBucketRange); int lastLostCol = nbLostEvents - lostEventPerBucket * (nbBucketRange -1); 
 /** 
 if (arguments == null) 
 if (arguments==null) throw new NullPointerException("arguments"); //$NON-NLS-1$ 
<|del|> 
 if (updateRequests.contains(entryValue.getDiffEntry() .getPath())) 
 } else { 
 String entryPath = obj.getDiffEntry().getPath(); if (updateRequests.contains(entryPath)) 
 public void countLostEvent(TmfTimeRange timeRange, long nbLostEvents, boolean fullRange) { 
 throw new IllegalStateException( "Can't start rebase if repository state isn't SAFE"); //$NON-NLS-1$ 
 cache = GitSyncCache.getAllData(gsds, monitor); 
 GitSyncCache.mergeAllDataIntoCache(updateRequests, monitor, cache); 
 members.put(key, obj); 
 /** * Sets the height of the proposal form in pixel. (The proposal form is smaller if there are not enought values to fill the proposal.) * @param proposalFormHeight height in pixel */ 
 } catch (OseeCoreException ex) { OseeLog.log(Activator.class, Level.SEVERE, ex.toString(), ex); } 
<|del|> 
 MToolBarElement action = MenuHelper 
 toolBarContribution.getChildren().add(action); 
<|del|> 
public abstract class TmfCommonProjectElement extends TmfProjectModelElement { 
 * @return the {@link TmfExperiment} or <code>null</code> for an error * @since 3.0 
 if (element instanceof TmfTraceElement) { TmfTraceElement trace = (TmfTraceElement) element; 
 * Genevive Bastien - Moved trace type related methods to parent class 
 * Genevive Bastien - Added support for experiment types 
<|del|> 
 * Experiments can be set to the default experiment type. No * need to force user to select an experiment type 
 public static void log(@SuppressWarnings("rawtypes") Class clazz, String methodName, Throwable t) { 
<|del|> 
 column.addSelectionListener(new SelectionAdapter() { 
 returnValue = "DELETED"; 
 if (BranchManager.isUpdatable(branchToUpdate)) { 
 newArt.persist("Base Edit"); //wait for creation of artifact and persist to go through 
 if (BranchManager.isUpdatable(branchToUpdate)) { 
<|del|> 
 stagedViewer)); stagedViewer.addDropSupport(DND.DROP_MOVE, 
 int lastLostCol = nbLostEvents - lostEventPerBucket * (nbBucketRange - 1); 
 int lastLostCol = nbLostEvents - lostEventPerBucket * (nbBucketRange - 1); 
 rebaseSection.setText(UIText.StagingView_RebaseLabel); 
<|del|> 
 // Bug 417288, ilg@livius.net & freidin.alex@gmail.com filename = ensurePathIsGNUMakeTargetRuleCompatibleSyntax(filename); buffer.append(filename + WHITESPACE + LINEBREAK); 
 // Bug 417288, ilg@livius.net & freidin.alex@gmail.com filename = ensurePathIsGNUMakeTargetRuleCompatibleSyntax(filename); buffer.append(filename + WHITESPACE + LINEBREAK); 
 private static final String F_GROUP = "group"; 
 if (!IndexReader.indexExists(directory)) { index(); } 
 return s.equalsIgnoreCase(CSS.PSEUDO_TARGET); 
 if (currentLexicalUnit.getStringValue().equalsIgnoreCase(CSS.PSEUDO_TARGET)) { 
 final IElement before = styleSheet.getPseudoElement(node, CSS.PSEUDO_BEFORE, true); 
 final IElement after = styleSheet.getPseudoElement(node, CSS.PSEUDO_AFTER, true); 
 final IElement beforeElement = context.getStyleSheet().getPseudoElement(node, CSS.PSEUDO_BEFORE, true); 
 final IElement afterElement = context.getStyleSheet().getPseudoElement(node, CSS.PSEUDO_AFTER, true); 
<|del|>
 * 
<|del|>
<|del|>
<|del|> 
 switch (columnIndex) { case 0: return element.col1; case 1: return element.col2; 
<|del|> 
 if (Arrays.equals(packChecksum, idx.packChecksum)) 
 * Tom Schindl - initial API and implementation * Hendrik Still <hendrik.still@gammas.de> - bug 417676 
<|del|> 
 } catch (AttributeNotFoundException e) { e.printStackTrace(); 
 currentLevelInterval = querySingleState(range.getFirst(), baseQuark); if (!currentLevelInterval.getStateValue().isNull()) { intervals.add(currentLevelInterval); } 
 if (currentLevelInterval == null) { return; } if (!currentLevelInterval.getStateValue().isNull()) { intervals.add(currentLevelInterval); } 
 } catch (AttributeNotFoundException e) { e.printStackTrace(); 
 final StyleSheet styleSheet = context.getStyleSheet(); final IElement before = styleSheet.getPseudoElement(pi, "before", true); 
 private ListenerList dirtyListeners; 
 public void addDirtyListener(IDirtyListener dirtyListener) { if (dirtyListener == null) { throw new NullPointerException("Cannot add a null dirty listener"); //$NON-NLS-1$ 
 public void removeDirtyListener(IDirtyListener dirtyListener) { if (dirtyListener == null) { throw new NullPointerException( "Cannot remove a null dirty listener"); //$NON-NLS-1$ 
 final Object[] listeners = dirtyListeners.getListeners(); for (int i = 0; i < listeners.length; i++) { IDirtyListener dirtyListener = (IDirtyListener) listeners[i]; dirtyListener.dirtyChanged(dirty); 
<|del|> 
 throw e; } catch (CoreException e1) { IStatus multiStatus = createMultiStatus(result.getException(), e1); CoreException multiStatusCoreException = new CoreException( multiStatus); throw new RuntimeException( multiStatusCoreException); 
 protected abstract RebaseOperation createRebaseOperation( ExecutionEvent event) throws ExecutionException; 
<|del|> 
 * @param ctx the context * @return the editor input for the given context or <code>null</code> if not available 
 IPath modelPath = new Path(context.getRootModel().eResource().getURI().toPlatformString(true)); modelPath = ResourcesPlugin.getWorkspace().getRoot().getFile(modelPath).getLocation(); 
<|del|> 
 public Text getMaxNbEventsText() { 
 buffer.append(newLine); 
 * Jean-Christian Kouam, Simon Delisle - Added support to manage lost events 
 private long fFirstBucketTime; // could be negative when analyzing events with descending order!!! 
<|del|> 
 if (fullRange) { 
 if (event instanceof ITmfLostEvent) { 
 public final int[] fLostEventsData; 
 public static volatile boolean hideLostEvents = false; 
 this.jobname = jobname; this.dialogMessage = dialogMessage; 
 protected void execute(final RebaseOperation rebase) 
<|del|> 
 AbstractRebaseCommandHandler rebaseCurrentRef = new AbstractRebaseCommandHandler( jobname, UIText.RebaseCurrentRefCommand_RebaseCanceledMessage) { 
 @Option(name = "-sr", handler = ExtURLOptionHandler.class, usage = "URL of Maven Repository for source files") 
 @Option(name = "-d", metaVar = "DIRECTORY", usage = "Destination directory for the Javadoc HTML output files") 
 @Option(name = "-jar", usage = "Want to have an zipped jar output for Javadoc? Warning: Requires '-d <DIRECTORY>'") 
 @Option(name = "-t", handler = StringArrayOptionHandler.class, metaVar = "\"ovrm ovrp, ...\"", usage = "Choose Recommenders Taglets (Default: Use all registered Taglets): \n ovrm: Method Overrides \n ovrp: Method Override Patterns") 
<|del|> 
 resetSoftToParent(); 
 rebaseState.createFile(MESSAGE_SQUASH, content); 
 static int parseSquashFixupSequenceCount(String currSquashMessage) { 
<|del|>
<|del|>
<|del|> 
 Repository repo = getRepository((ISelection) selection, getActiveEditorInput(ctx)); 
public interface IdentityService { 
 if (isOsgiVersion310orNewer(classLoader)) { 
<|del|> 
 @Deprecated 
<|del|> 
 * Christian Halstrick (SAP AG) - initial implementation * Mathias Kinzler (SAP AG) - initial implementation * Robin Rosenberg - Adoption for the history menu * Tobias Pfeifer - Extracted from RebaseCurrentHandler 
 return new RebaseOperation(repository, Operation.ABORT); 
 * Copyright (c) 2002-2013 IBM Corporation and others. 
 * Copyright (c) 2002-2012 IBM Corporation and others. * All rights reserved. This program and the accompanying materials 
<|del|> 
 final int maxExpectedSize = leftInverseReference.size() + rightInverseReference.size() + originInverseReference.size() + resourceAttachmentChanges.size(); EList<Diff> result = new UniqueEList.FastCompare<Diff>(maxExpectedSize); 
 final int maxExpectedSize = leftInverseReference.size() + rightInverseReference.size() + originInverseReference.size() + resourceAttachmentChanges.size(); EList<Diff> result = new UniqueEList.FastCompare<Diff>(maxExpectedSize); 
 final Collection<EStructuralFeature.Setting> inverseReference; 
 String[] headings = { UIText.RebaseInteractiveView_HeadingStatus, UIText.RebaseInteractiveView_HeadingAction, UIText.RebaseInteractiveView_HeadingCommitId, UIText.RebaseInteractiveView_HeadingMessage }; 
 public static StringBuilder htmlLink(IMethodName method) { 
 @Test public void testRelativeUriType() throws URISyntaxException { 
 @Option(name = "-d", metaVar = "DIRECTORY", usage = "Destination directory for the Javadoc HTML output files") 
 @Argument(index = 0, metaVar = "GROUP_ID:ARTIFACT_ID:VERSION", required = true, usage = "The Maven coordinate for which you want to generate Javadoc", handler = ArtifactOptionHandler.class) 
 private String[] taglets = new String[] { "ovrm", "orvp" }; 
 public String[] getPackages() { 
 livedoc.setModelRepositories(settings.getModelsRepositories()); livedoc.setEncoding(settings.getCharset()); 
 File todoFile = new File(db.getDirectory(), "rebase-merge/git-rebase-todo"); 
 // Add only if corresponding TraceSessionComponent is an active snapshot session and not destroyed 
 * The snapshot ID property. 
 ManagedBuilderCorePlugin.log(e); 
 /** * @author Donald G Dunne */ 
 /** * @author Donald G Dunne */ 
 String t = getTrimmedRemoteName(); 
 name = getTrimmedRemoteName(); 
 .createAncestor(getAdapterFactory(), getComparisonObject()); 
 .createLeft(getAdapterFactory(), getComparisonObject()); 
 .createRight(getAdapterFactory(), getComparisonObject()); 
 * Copyright (c) 2012, 2013 Obeo. 
 * Copyright (c) 2012, 2013 Obeo. 
 * Copyright (c) 2012, 2013 Obeo. 
 * Copyright (c) 2012, 2013 Obeo. 
 * Copyright (c) 2012, 2013 Obeo. 
 * Copyright (c) 2012, 2013 Obeo. 
 case INTEGER: case LONG: if (max.isNull() || si.getStateValue().unboxLong() > max.unboxLong()) { max = si.getStateValue(); 
 } return value.unboxLong(); 
 /* This is a special case, so we'll add a message to the exception */ throw new StateValueTypeException("State system advertises mipmaps," + //$NON-NLS-1$ " but doesn't actually have them.", e); //$NON-NLS-1$ 
 String resolvedFileName = UiUtils.resolveDefines(editor.getSpecfile(), fileName); boolean validFile = RPMUtils.isValidFileName(resolvedFileName); boolean fileExists = RPMUtils.fileExistsInSources(original, resolvedFileName); 
 return tempHList.isEmpty() ? null : tempHList.toArray(new IHyperlink[tempHList.size()]); 
 return true; } catch (MalformedURLException e) { return false; } 
 // URL#getPath will ignore any queries after the filename String fileName = new URL(url).getPath(); int lastSegment = fileName.lastIndexOf("/") + 1; //$NON-NLS-1$ rc = fileName.substring(lastSegment).trim(); 
 * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * QNX Software Systems - initial API and implementation 
 return createTaglets(Lists.newArrayList(elements)); 
 } else if (existingRemotes.contains(t)) { 
 if (fileName.trim().isEmpty()) { 
<|del|> 
 final IFolder folder = experimentFolder.getFolder(experimentName); 
 public static TmfStatisticsViewerStub fLastInstance = null; 
 notesString = PERSONAL_NOTES.equals(noteEditor.getText()) ? "" : noteEditor.getText(); //$NON-NLS-1$ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 public abstract Date getLastStatusDate() throws OseeCoreException; 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 AssertionFailedErrorMessage = "got NoSuchMethodException " + e.getMessage(); 
 AssertionFailedErrorMessage = "got NoSuchMethodException " + e.getMessage(); 
 AssertionFailedErrorMessage = "got NoSuchMethodException " + e.getMessage(); 
<|del|> 
 this.getShell().setText("SWT Test Recorder"); setTitle("Record test for SWT application"); 
<|del|> 
 * Creates hyperlink using guid as name. Default editor will open. 
 rd.log("\n\nExample of hyperlinked guid: " + getHyperlink(UserManager.getUser())); 
 rd.log("Example of hyperlinked guid on another branch: " + getHyperlink(UserManager.getUser().getGuid(), 
 org.eclipse.linuxtools.tmf.ui.tests.swtbot.AllTests.class 
<|del|> 
 private static volatile BatchImportTraceWizard bitw = null; 
 private static volatile BatchImportTraceWizard bitw = null; 
 /** Time-out after 30 seconds */ @Rule public TestRule globalTimeout= new Timeout(30000); 
 private static void refreshUI(final Display display) { 
<|del|> 
<|del|> 
 long realEventsInRange = backend.getEventsInRange(rangeStart, rangeEnd); 
 @Override 
 @Override 
 @Override 
 String defaultOverwriteUrl = System.getProperty("mylyn.tests.configuration.url", ""); 
 private static final int VERSION = 2; 
 * information (which should ideally use a fast backend), and another one for * the rest (per event type, per CPU, etc.). 
 /** ID for the "event types" statistics state system 
 /** Filename for the "event totals" state history file */ 
 /** Filename for the "event types" state history file */ 
 if (!totalsStats.waitUntilBuilt()) { return list; } 
<|del|>
 * 
 * 
<|del|>
 } else { 
 } updateTimingInformation(repositoryQuery, start); } private void updateTimingInformation(RepositoryQuery repositoryQuery, long start) { 
 long duration_count = parseLongFromString(duration_count_string); if (duration_count == 0) { duration_count++; 
 /** 
 /** ID for the "event totals" statistics state system 
 /** ID for the "event types" statistics state system 
 boolean fontFamilySet = newFontData.getName() != null && newFontData.getName().trim().length() > 0; 
 if (eventBroker != null) { eventBroker.subscribe(UIEvents.UILifeCycle.THEME_CHANGED, themeChangedHandler); } 
 /** * Offset the buffer position wrt the current alignment * * @param input the bitbuffer that is being read * @param declaration the declaration which has an alignment */ protected static void alignRead(BitBuffer input, IDeclaration declaration){ 
 IComparisonScope getOldScope(); 
 private IComparisonScope oldScope; 
 * name of ref (usually tag or branch) to be checked out after * clone, e.g. full <code>refs/heads/master</code> or short * <code>v3.1.0</code>, or null for no checkout 
 MessageDialog .openError(Display.getDefault().getActiveShell(), 
 WizardDialog dlg = new WizardDialog( getShell(event), new GitCreateProjectViaWizardWizard(node.getRepository(), path)) { @Override protected IDialogSettings getDialogBoundsSettings() { // preserve dialog bounds return Activator.getDefault().getDialogSettings(); } }; 
 protected void fetchChildren(final IExpressionDMContext exprDmc, 
 private static CtfTmfTestTrace ctt = CtfTmfTestTrace.SYNTHETIC_TRACE; 
 CtfTmfTrace trace = CtfTmfTestTrace.SYNTHETIC_TRACE.getTrace(); if( trace == null ) { 
 long[] expected = new long[] { 2, 2 }; assertArrayEquals(expected, values); 
 private void readAllExtensions() { 
 Activator.getDefault().logError(Messages.TmfCommonProjectElement_ErrorCopyingSF + oldSupplFolder, e); 
 RebaseInteractivePlan plan = planRegistry.get(repo.getDirectory()); 
 planRegistry.remove(this.repository.getDirectory()); 
 * {@link RebaseInteractivePlan} if it has been registered before 
 /** * A class designated to handle the tasks of a specfile. * * @since 1.2.0 */ 
 /** * Construct a specfile task handler given a FileEditorInput. * * @param file The FileEditorInput to get the file from. * @param document The specfile document. * * @since 1.2.0 */ 
 public boolean isSkip() { 
<|del|> 
<|del|> 
 @Rule public TemporaryFolder tempFolder = new TemporaryFolder(); 
 } else if (changeDetail.getApprovalTypes() == null && getGerritConfig() != null) { 
 ApprovalType approvalType = findTypeByLabel(knownApprovalTypes, label.getLabel()); 
 public List<ICategoryItem> createTreeObjectsFromExtensions() { List<ICategoryItem> modelList = new ArrayList<ICategoryItem>(); 
 List<ICategoryItem> modelList = ExtensionPointReader.getInstance().createTreeObjectsFromExtensions(); 
 return "call-also"; 
<|del|> 
 * end * * @since 2.2 
 /** * The title for the select trace type dialog * @since 2.2 * */ public static String TmfTraceType_SelectTraceType; 
 /** * The title for the select trace type dialog * @since 2.2 * */ public static String TmfTraceType_SelectTraceType; 
<|del|> 
<|del|> 
 sb.append("'\n"); //$NON-NLS-1$ 
 * Exception thrown if a rebase step is invalid. E.g., a rebase must not start 
<|del|> 
 private static final int MAX_COLUMN_WIDTH = 4000; 
 public EternityTimeRange() { super(TmfTimestamp.BIG_BANG, TmfTimestamp.BIG_CRUNCH); } 
 public void testCollapsedByTheHour() { 
<|del|> 
 protected void getChildrenCount(IExpressionDMContext exprDmc, final int numChildrenLimit, 
 * Content provider feeding rebase interactive plan 
<|del|>
 for (RebaseInteractivePlan.PlanElement element : selected) 
 IAtsLog getLogLoaded(ILogStorageProvider storageProvider) throws OseeCoreException; 
 void writeToStore(IAtsWorkItem workItem); 
 public void writeToStore(IAtsWorkItem workItem) { ILogStorageProvider storageProvider = AtsCore.getWorkItemService().getLogStorageProvider(workItem); AtsLogWriter writer = new AtsLogWriter(workItem.getLog(), storageProvider); writer.save(); 
 public static final String PROPERTY_SECURITY_MANAGER = "configureSecurityManager"; //$NON-NLS-1$ 
<|del|> 
 securityManager.setAttribute("type", SecurityManagerFactory.Default.TYPE); //$NON-NLS-1$ 
 public static final String TYPE = CDOAdmin.DEFAULT_TYPE; 
 target.createRepository(repositoryName, CDOAdmin.DEFAULT_TYPE, repositoryProperties); 
 target.delete(CDOAdmin.DEFAULT_TYPE); 
 private final Object fSynchObject = new Object(); 
 return fIsPaused; 
 public void suspend() { fIsPaused = true; 
 case IStatus.OK: 
<|del|> 
 appendStatusAndChildren(status, indentation); 
 IOUtil.close(fos); 
 return "Gerrit Code Review (supports 2.4 and later)"; 
 monitor.beginTask("Executing query", IProgressMonitor.UNKNOWN); 
 return new Status(IStatus.ERROR, GerritCorePlugin.PLUGIN_ID, NLS.bind("Unknown query type: {0}", //$NON-NLS-1$ 
 public boolean isStarred() { 
 /** * @author Donald G. Dunne */ 
 /** * @author Donald G. Dunne */ 
 public boolean validateRealm_HasAdministrator(Realm realm, DiagnosticChain diagnostics, Map<Object, Object> context) 
 * @author Matthew Khouzam 
 } catch (StateSystemDisposedException e) { /* Ignored */ 
 Map<String, ITmfStateSystemAnalysisModule> modules = currentTrace.getAnalysisModules(ITmfStateSystemAnalysisModule.class); 
 throw new IllegalStateException(); 
 appendStatusAndChildren(status, indentation); 
 private Label label; 
 monitor.beginTask(Messages.ExportToTextJob_Export_trace_to + destination, TOTAL_WORK); 
 ex); 
 int index = (int) (request.getNbRead() * TOTAL_WORK / fTrace.getNbEvents()); 
 Thread.sleep(SLEEPING_INTERVAL); 
<|del|> 
 } catch (IOException ex) { fIOException = ex; 
 } catch (IOException ex) { fIOException = ex; 
 } catch (IOException ex) { fIOException = ex; 
 if (curTrace.getStartTime().compareTo(start) < 0) { 
 bw.write(fHeader); bw.append('\n'); 
 * a TmfFilter, if we want to filter some events. May be <code>null</code>. * @param table * the {@link TmfEventsTable} requesting the export (may be <code>null</code>) 
 Object value = field.getValue(); printValue(value); 
 printValue(content.getValue()); 
 private static final int MAX_CACHE_SIZE = 1000; /** * Empty ITmfEventField array, used by {@link #extractItemFields(ITmfEvent)} * @since 2.2 */ 
 /* * Start the mapping import in a separate thread (we do not want * to UI thread to do this). */ Job job = new ImportMappingJob(new File(filePath)); job.schedule(); 
 super("resources/templates/builtin"); 
 Conditions.checkNotNull(objects, "objects"); 
 public void addExecuteListener(IExecuteListener listener) { Conditions.checkNotNull(listener, "listener"); 
<|del|> 
<|del|> 
 public final static String ID = "org.eclipse.linuxtools.lttng2.kernel.analysis"; //$NON-NLS-1$ 
 protected @NonNull ITmfStateProvider createStateProvider() { ITmfTrace trace = getTrace(); if (!(trace instanceof LttngKernelTrace)) { 
 FileDialog dialog = new FileDialog(getViewSite().getShell()); 
 super(Messages.CallStackView_ImportMappingJobName); //$NON-NLS-1$ 
 if (map.isEmpty()) { 
 if (doAutoShare()) 
 if (mappings.size() == 1) 
<|del|> 
 for (long i = 0; i < ctfLocationData.getOffset(); i++) { if (currTimestamp == this.getCurrentEvent().getTimestampValue()) { 
<|del|> 
<|del|> 
<|del|> 
 return getCsnip().hashCode(); 
 assertEquals("getRange", TmfTimeRange.ETERNITY, request.getRange()); assertSame("getRange", TmfTimeRange.ETERNITY, request.getRange()); 
 private boolean ranksOverlap(ITmfEventRequest request) { 
 // ITmfEventRequest 
<|del|> 
 * An abstract base class that implements ITmfEventProvider. 
 * </p> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // Coalescing 
<|del|> 
 protected synchronized void newCoalescedEventRequest(ITmfEventRequest request) { 
 protected void coalesceEventRequest(ITmfEventRequest request) { 
 * priority). 
 protected static void alignRead(BitBuffer input, IDeclaration declaration) { int mask = (int) declaration.getAlignment() - 1; /* * The alignment is a power of 2 */ int pos = (input.position() + mask) & ~mask; 
 private static Map<Class<? extends ITmfEvent>, List<TmfEventProvider>> fProviders = new HashMap<Class<? extends ITmfEvent>, List<TmfEventProvider>>(); 
<|del|> 
<|del|> 
 private void readEndianness(IMemoryDMContext memContext) { 
 new DataRequestMonitor<CLIShowEndianInfo>(ImmediateExecutor.getInstance(), drm) { 
<|del|> 
 assertNotNull(reader.getCurrentEventDef()); 
 assertNotNull(reader.getCurrentEventDef()); 
 ContributionFactory theContributionFactory = (ContributionFactory) EPackage.Registry.INSTANCE.getEFactory(ContributionPackage.eNS_URI); 
 public String getSearch() throws Exception { 
 public void addUrl(String name, String url) { 
 * Copyright (C) 2010, 2013 Mathias Kinzler <mathias.kinzler@sap.com> and others. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 /* * TODO: add a check if the alignment is 0, use bytebuffer.getLong()... maybe it's faster? */ 
 /* Validate that the buffer has enough bits. */ int val = 0; if (!canRead(length)) { throw new BufferOverflowException(); 
 if (length > BIT_INT) { 
 if (length > BIT_INT) { 
 if (length < 0) { 
 if (length < 0) { 
 if (result.getStatus() == CheckoutResult.Status.CONFLICTS) { 
 * @return if the initial operation should continue when dialog is closed 
 long signedRead = getInt(length, false); // false or true, no effect. return (signed ? signedRead : (signedRead & 0xFFFFFFFFL)); 
 * Run the getLong method test. 
 * desired 
 /** * Read 32-bits BE * * @throws CTFReaderException * error */ 
 * An error occurred reading the long. This exception can be * raised if the buffer tries to read out of bounds 
 * An error occurred reading the data. when the buffer is read * beyond its end, this exception will be raised. 
<|del|> 
 * An error occurred writing the data. If the buffer is written * beyond its end, this exception will be raised. 
 * An error occurred reading the data. If the buffer is reading * beyond its end, this exception will be raised. 
 if (location != null && repoPath.isPrefixOf(location)) { 
 IPath location = resource.getLocation(); if (location != null && repoPath.isPrefixOf(resource.getLocation())) { if (repository == null || repoPath.segmentCount() > segmentCount) { 
 segmentCount = repoPath.segmentCount(); 
 * This will be called by the merge strategy on every file it processes that * needs a non-trivial merge (both ours and theirs have changed since their * common ancestor). 
 * @return The human-readable name of this merge driver. Note that this will * be used as an identifier by the 
 * Registry of all merge drivers. 
 * 
 containsConflicts = true; 
 final SupportedAlgorithm diffAlg = getRepository().getConfig() .getEnum(ConfigConstants.CONFIG_DIFF_SECTION, null, ConfigConstants.CONFIG_KEY_ALGORITHM, SupportedAlgorithm.HISTOGRAM); final MergeAlgorithm mergeAlgorithm = new MergeAlgorithm( DiffAlgorithm.getAlgorithm(diffAlg)); 
 // There were merge conflicts. The file will contain conflict // markers. The index will be populated with the three stages and // only the workdir (if used) contains the halfways merged content. 
 CanonicalTreeParser theirs, CanonicalTreeParser base) throws IOException { 
 * Output the merged content into the given stream. 
 * 
 * This path matcher will check whether a given path matches a glob pattern. 
<|del|> 
 private static final int LONG_CACHE_SIZE = 128; // Must be a power of 2 private static final LongStateValue longCache[] = new LongStateValue[LONG_CACHE_SIZE]; 
 IntegerStateValue newValue = new IntegerStateValue(intValue); intCache[offset] = newValue; return newValue; 
 @Ignore 
 private static void createBuffer(BitBuffer fixture, int j) { byte[] bytes = new byte[j]; 
 * Etienne Bergeron <Etienne.Bergeron@gmail.com> - fix zero size read + cleanup 
 * @throws CTFReaderException * If we get an error reading the packet 
 * @return boolean True if the seek was successful, false if there was an * error seeking. 
 String extension = scriptPath.getFileExtension(); if (extension == null || !extension.equals("stp")) { //$NON-NLS-1$ 
 setErrorMessage(Messages.SystemTapScriptLaunchConfigurationTab_fileNotStp); return false; 
 return Double.compare(this.value, other.value) == 0; 
 this.valueInt = valueAsInt; 
 * @return boolean True if the seek was successful, false if there was an * error seeking. 
 small_fixture.get(length, signed); 
 b &= (1L << highShift) - 1L; 
 b &= (1L << highShift) - 1L; 
 outw.println(CLIText.get().checkoutConflict); for (String path : e.getConflictingPaths()) outw.println(MessageFormat.format( CLIText.get().checkoutConflictPathLine, path)); 
<|del|> 
 * This will be called by the merge strategy on every file it processes that * needs a non-trivial merge (both ours and theirs have changed since their * common ancestor). 
 boolean merge(Config configuration, InputStream ours, InputStream theirs, InputStream base, OutputStream output, String[] commitNames) 
 } /* * This is going to take signed number (in two's complement) Therefore * if the value is negative, don't remove one from it. Then down shift * by one to divide it by two. */ 
 * Master test suite for TMF Xml Analysis UI plug-in. 
 * Test the Xml Analysis UI plug-in activator 
 public static boolean methodSignatureEquals(IMethodName methodName, MethodDoc methodDoc) { 
 /** * @return true, if declaring types and simple method names are equal */ private static boolean qualifiedNameMatches(IMethodName methodName, MethodDoc methodDoc) { 
 private static boolean declaringTypeMatches(IMethodName methodName, MethodDoc methodDoc) { return typeMatches(methodName.getDeclaringType(), methodDoc.containingClass()); 
 * the name of the identifier to search for. In the case of int * x; it would be "x" 
 public void registerIdentifier(String name, IDeclaration declaration) throws ParseException { 
 throw new ParseException("Identifier has already been defined:" + name); //$NON-NLS-1$ 
 public IDeclaration lookupIdentifierRecursive(String identifier) { 
 Composite parent = getFieldEditorParent(); 
 * Old default. Older versions of yum (3.0.x) not supported. 
<|del|> 
 private boolean isSignedIntegerField(String lengthName) { 
 * Recursively looks through the list of identifiers of a scope to find if * it exists. 
 * Gets a list of values that are guaranteed to be in each enum * * @return A list of values that are guaranteed to be in each enum, can be * empty but not null 
 private class Range { 
 final private long low, high; final private String str; 
 if (itemFont != null && !itemFont.equals(font)) { 
 scenarios.add(match( "Lorg/example/SomeClass.someMethod()Lorg/example/subexample/AnotherClass;", methodDoc("org.example.SomeClass", "org.example.subexample.AnotherClass", "someMethod"))); 
 scenarios.add(match( "Lorg/example/SomeClass.someMethod()Lorg/example/subexample/AnotherClass;", methodDoc("org.example.SomeClass", "org.example.subexample.AnotherClass", "someMethod"))); 
 parameters("int")))); 
 scenarios.add(match( "Lorg/example/SomeClass.someMethod()V;", methodDoc("org.example.SomeClass", "void", "someMethod"))); 
 scenarios.add(match( "Lorg/example/SomeClass.someMethod()V;", methodDoc("org.example.SomeClass", "void", "someMethod"))); 
 scenarios.add(match( "Lorg/example/SomeClass.someMethod(Lorg/example/SomeClass;, I;)V;", methodDoc("org.example.SomeClass", "void", 
 parameters("org.example.SomeClass", "org.example.AnotherClass")))); 
 private final List<LabelAndRange> ranges = new LinkedList<LabelAndRange>(); 
 private class LabelAndRange { 
 if (field == null) { throw new CTFReaderException("Variant was not defined for: "+ currentField); //$NON-NLS-1$ 
 if (field == null) { throw new CTFReaderException("Variant was not defined for: "+ currentField); //$NON-NLS-1$ 
 private int supportedHeadingLevel; 
 * Adds support for headings up to and including the specified level. 
 item.setFont(font); 
 && key.equals(((ResourceByDefinitionKey) obj).key); 
 private final HTConfig fConfig; 
 FileInputStream supplyATReader(int nodeOffset) { 
 "Lorg/example/SomeClass.someMethod()I", 
 "Lorg/example/SomeClass.someMethod(Lorg/example/SomeClass;, Lorg/example/AnotherClass;)V", 
 "Lorg/example/SomeClass.someMethod(Lorg/example/SomeClass;, I)V", 
 "Lorg/example/SomeClass.someMethod([Lorg/example/SomeClass;, [[I)[I", 
 MessageConsoleStream os = CreaterepoUtils.findConsole(Messages.CreaterepoProject_consoleName) .newMessageStream(); os.print(NLS.bind(Messages.ImportRPMDropListener_errorCopyingFileToProject, 
 if (content != null && content.startsWith("git clone")) //$NON-NLS-1$ 
<|del|> 
<|del|> 
<|del|> 
 public static final String ID = "org.eclipse.linuxtools.lttng2.kernel.analysis"; //$NON-NLS-1$ 
 super.setTrace(trace); 
 * The target repository name. 
 private static final int DEFAULT_COLUMN_WIDTH = 85; 
 if (Strings.isValid(styleId)) { 
 "<Style ss:ID=\"OseeDate\"><NumberFormat ss:Format=\"Short Date\"/></Style>\n" + // 
 delayThread(DEFAULT_DELAY); 
 client.addSupportedVersion(ver); 
 public static StringBuilder htmlLink(ITypeName type) { 
 final long deadline = System.nanoTime() + (DELAY_COUNTER * DEFAULT_DELAY * 1000000); do { 
 /** * Returns the shared instance * * @return the shared instance */ public static Activator getDefault() { return fPlugin; } 
 /** * JUnit tests for {@link AbstractBigIntegerColumn} * * @since 4.0.0 */ 
 * Column holding {@link BigInteger} 
<|del|> 
 updateTreeNode(e.getNode()); 
 updateTreeNode(e.getNode()); 
 public void testCompletionInDesignatedInitializor_353281a() throws Exception { 
 private CheckoutCommand newOrphanBranchCommand() { return git.checkout().setOrphan(true) .setName("orphanbranch"); 
 this.assertRepositoryCondition(1); 
 * @since 3.3 
<|del|> 
<|del|> 
 * Create and open editor for the model element. Called on the supported * creation of a new model element. 
 * 
 * 
 return ""; 
 return ""; 
 public static Iterable<IAnalysisModuleSource> getSources() { 
 for (IAnalysisModuleHelper helper : source.getAnalysisModules()) { fAnalysisModules.put(helper.getId(), helper); } 
 Verifier verifier = getVerifier("/424945_setLicenseFeatureVersion", false); 
<|del|> 
 * * @parameter expression="${outputDirectory}" * default-value="${project.build.directory}/reference/api" required=true 
 * * @parameter expression="${basedir}" * @required true * @readonly true 
 * * @parameter default-value="compile,provided" expression="${scopes}" 
 private JavadocOptions javadocOptions = new JavadocOptions(); 
 * Options for creating the toc files. * 
 * * @parameter default-value="${project.build.directory}/tocjavadoc.xml" expression="${tocFile}" 
 private class GatherClasspathVisitor implements ProjectVisitor { private final Set<String> classPath = new HashSet<String>(); 
 * as 'refCount' continues to be 1 even when JAWS is running. */ // if (refCount <= 1) return false; 
 "Could not determine GDB version using command: " + cmd, //$NON-NLS-1$ 
 "Error with command: " + cmd, e));//$NON-NLS-1$ 
 * Copyright (c) 2014 Darmstadt University of Technology. 
 * Andreas Sewe - initial API and implementation 
<|del|> 
<|del|> 
<|del|> 
 if (ch == '\n') { 
 * Copyright (c) 2014 cole Polytechnique de Montral 
 // ------------------------------------------------------------------------ 
 // ------------------------------------------------------------------------ 
 * Copyright (c) 2014 cole Polytechnique de Montral 
 * Return the name of this Livedoc Provider, must be equal to extension id and cmd line parameter 
 case INPUT: // Git used the repo format on checkout, but other tools // may change the format to CRLF. We ignore that here. 
 * Copyright (c) 2014 BlackBerry Limited and others. 
 * Copyright (c) 2014 BlackBerry Limited and others. 
 * informs the attached UI that a node has changed in a way that may affect its presentation (e.g. text, font, 
 * occurred * * @since 3.10.0-M5 
 redraw(); updateStatusLine(NO_STATUS); 
 private final static String EXTENSION_POINT = "ProblemMarkerFilter"; //$NON-NLS-1$ 
 ProblemMarkerFilterDesc filterDesc = new ProblemMarkerFilterDesc(element); filters.add(filterDesc); 
 * Class to represent a comment in a review 
 if (draft != other.draft) { 
 if (annotations.add(ca)) { 
 if (project == null || !project.isOpen()) 
 * * @since 5.6 
 * Copyright (c) 2014 Tasktop Technologies and others. 
 boolean setUp(ProjectCoordinate pc, ModelRepository repo, Optional<IModelIndex> index, ProviderConfiguration configuration, boolean highlight) throws LiveDocProviderException; 
 private static final long serialVersionUID = 8360169698758208743L; 
 if (annotations.add(ca)) { 
 * @return a class extending * {@link org.eclipse.e4.tools.emf.ui.common.component.AbstractComponentEditor} * capable of editing class returned in {@link #getEClass()} 
 * your contributions storage * {@link org.eclipse.emf.ecore.EReference} target 
<|del|> 
 OseeExceptions.wrapAndThrow(ex); } finally { Lib.close(fis); 
 } catch (IOException ex) { OseeExceptions.wrapAndThrow(ex); } finally { Lib.close(zout); } 
 else if (!printHelpInfo && !printIUList && !printRootIUList && !printTags && !purgeRegistry && rootsToInstall.isEmpty() && rootsToUninstall.isEmpty() && revertToPreviousState == NOTHING_TO_REVERT_TO) { 
 result.setLength(result.length() - LINE_SEP.length()); //remove trailing newline 
 String[] args = getSingleRepoArgsForListing("testListFormat", metadataRepo, artifactRepo, "-list", "", "-listFormat", "${id}_${version},${id},${org.eclipse.equinox.p2.name}"); 
 setStartTime(Math.min(getStartTime(), startTime)); setEndTime(Math.max(getEndTime(), endTime)); 
 throw new IllegalArgumentException("LttngKernelStateSystemModule: trace should be of type LttngKernelTrace"); //$NON-NLS-1$ 
 @NonNull protected ITmfStateProvider createStateProvider() { 
 for (ProviderConfiguration configuration : providerConfigurations.values()) { 
 // No-op Implementation 
 private static final Logger log = LoggerFactory.getLogger(RecommendersTaglet.class); 
 Iterator<ILivedocProvider> it = providers.iterator(); while (it.hasNext()) { ILivedocProvider provider = (ILivedocProvider) providers.iterator().next(); 
<|del|> 
<|del|> 
 public MethodSelfCallProvider() { 
 return methodDocMock; 
<|del|> 
 private static final Logger LOG = LoggerFactory.getLogger(RepositoryClient.class); 
 private static final Logger LOG = LoggerFactory.getLogger(RecommendersTaglet.class); 
 * Synchronize the given project to the given remote. 
 } // Return early if local changes have already been pushed and remote-to-local sync was not requested. 
 // Get hash code of the head of the remote repository 
 // Get hash code of the head of the remote repository 
 /** * @deprecated Use {@link #runUiInputVerifier(Control)} instead. Will be removed in the M-Release. */ @Deprecated public static void verifyUiInput(Control control) { runUiInputVerifier(control); } /** 
 for( ; extRefs.hasNext(); extRefs.next()) ++count; 
 while (head == null) { 
 } else { 
 if (head == null) { 
 } else { // Otherwise update the node's head field to point to the given name. 
 } else { // Otherwise update the node's head field to point to the given name. 
 if (linkage.equals(getLinkage())) { 
<|del|> 
 .registerService(org.eclipse.e4.ui.workbench.IWorkbench.class.getName(), this, properties); 
<|del|> 
 if (commit.getId().equals(commitToShow.getId())) { 
 String path = Zips.path(key.getName(), DOT_JSON); 
 return isRelevant(pattern) && isTopNumbered(pattern); 
 public boolean appliesTo(ISelection selection, IConfigurationElement configuration) { if (selection instanceof StructuredSelection) { Object firstSelectedElement = ((StructuredSelection) selection).getFirstElement(); 
 * @see #PURE_E4 * @see #LEGACY_E4STEP * @see #LEGACY_E3STEP 
<|del|> 
 * Node has changed in a way that may affect its presentation (e.g. text, font, color...) but no structural changes 
<|del|> 
 getSwtTreeViewer().update(node, null); 
 private final LinkedList<String> noTraceFiles = new LinkedList<String>(); 
 throw new OseeArgumentException("The path [%s] is invalid.", root); 
 /** * use prefixLength + 1 to account for trailing file separator which is not included in the root canonical path */ 
 /** * use prefixLength + 1 to account for trailing file separator which is not included in the root canonical path */ 
 return String.format("primary=[%s] secondary=[%s]", primaryMatcher.pattern(), secondaryMatcher.pattern()); 
 * @not-generated 
 * {@link org.eclipse.sirius.description.validation.ValidationPackage} ) and * feature corresponding to an Interpreted Expression. For example, for a 
<|del|> 
<|del|> 
 yvalue = ss.querySingleState(time, fMemoryQuarks.get(quark)).getStateValue().unboxLong() / BYTES_TO_KB; 
 * A vertical ruler column displaying line numbers. * Clients usually instantiate and configure object of this class. * 
 if (o instanceof Boolean) { 
 assertTrue(ok); assertTrue(file.exists()); 
 return new CtfTmfEvent(top.getCurrentEvent(), top.getFilename(), ctfTmfTrace); 
 * Copyright (c) 2014 cole Polytechnique de Montral 
 * Florian Wininger - Performance improvements 
 if (fCurLocation.hashCode() != fPreviousHashCode) { fPreviousHashCode = fCurLocation.hashCode(); fPreviousCurEvent = CtfTmfEventFactory.createEvent(top.getCurrentEvent(), 
 id = UNDEFINED_ID; 
<|del|> 
<|del|> 
<|del|> 
 txt = ELLIPSIS + txt.substring(txt.length() - maxLength); 
 return new CtfTmfEvent(top.getCurrentEvent(), top.getFilename(), ctfTmfTrace); 
 if ((extractor != null) && (extractor.artifactCreated(childArtifact))) { childArtifact.persist(transaction); 
 /** * @author Ryan D. Brooks * @author David W. Miller */ 
 * Copyright (c) 2000, 2014 IBM Corporation and others. 
 * Erik Chou <ekchou@ymail.com> - Bug 425962 
 * Erik Chou <ekchou@ymail.com> - Bug 425962 
 else if (fs.isDirectory(f)) 
 public boolean isModified(DirCacheEntry entry, boolean forceContentCheck) { 
 * * @deprecated Use outw instead 
 @Option(name = "--help", usage = "usage_displayThisHelpText", aliases = { "-h" }) private boolean help; 
<|del|> 
 if (LISTENING_COLOR_IDS.contains(changeColorEvent.getColorID())) { 
 return fColors.getUnchecked(rgb); 
 private RGB getBackground() { 
<|del|> 
 private final EventBus eventBus; 
 private void changeConflictingColor(ColorChangeEvent colorEvent) { Color oldConflictingChangeColor = getConflictingChangeColor(); updateConlictColor(); colorEvent.addColorChange(CONFLICTING_CHANGE_COLOR_THEME_KEY, oldConflictingChangeColor, getConflictingChangeColor()); } 
 inputChangedTask.setPriority(Job.LONG); config.getEventBus().register(this); 
<|del|> 
 final TreeNode treeNode = TreeFactory.eINSTANCE.createTreeNode(); 
<|del|> 
 Color getRequiredStrokeColor(); 
 Color getUnmergeableFillColor(); 
 IFolder folder = (IFolder)AdaptabilityUtility.getAdapter(object, IFolder.class); if (folder == null) { 
 boolean enabled = fTraceTypes.getText().equals(AUTO_DETECT); fImportUnrecognizedButton.setEnabled(enabled); 
 if (path != null && !path.isEmpty()) { 
 configureShellSize(); 
 Injector injector = new org.eclipse.etrice.core.RoomStandaloneSetup().createInjector(); 
 setMessage(null, NONE); 
 result = checkActionableItems(isAtsAdmin, artifacts); 
<|del|>
 Platform.getInstallLocation().getURL().getPath() + "configuration/org.eclipse.linuxtools/lttng/org.eclipse.linuxtools.tmf.core/" + //$NON-NLS-1$ CUSTOM_TXT_TRACE_DEFINITIONS_DEFAULT_FILE_NAME; 
 if (value == null) { 
 protected static final String CUSTOM_XML_TRACE_DEFINITIONS_DEFAULT_FILE_NAME = "custom_xml_default_parsers.xml"; //$NON-NLS-1$ 
 Platform.getInstallLocation().getURL().getPath() + "templates/org.eclipse.linuxtools.tmf.core/" + //$NON-NLS-1$ CUSTOM_XML_TRACE_DEFINITIONS_FILE_NAME; 
 if (!file.exists()) { 
 private static final String BUNDLE_NAME = "org.eclipse.linuxtools.lttng2.kernel.core.analysis.messages"; //$NON-NLS-1$ 
 if (value == null) { value = lookupXmlDefinition(definitionName, db, CUSTOM_XML_TRACE_DEFINITIONS_DEFAULT_PATH_NAME); 
 if (!file.exists()) { 
 protected static final String CUSTOM_XML_TRACE_DEFINITIONS_DEFAULT_FILE_NAME = "custom_xml_default_parsers.xml"; //$NON-NLS-1$ 
 File file = new File(source); if( !file.exists()){ return null; } 
 CUSTOM_XML_TRACE_DEFINITIONS_DEFAULT_FILE_NAME; 
 * select the outputFileButton and enable rest of the widgets if enable true * deselect the outputFileButton and disable rest of the widgets if enable false 
<|del|> 
<|del|>
 //resolve the addressable size int aSize; try { aSize = getAddressableSize(); } catch (DebugException e) { aSize = 1; } final int addressableSize = aSize; final int addressableUnits = bytes.length/addressableSize; 
 fContext, address, offset, addressableSize, addressableUnits, bytes, 
 int addressableSize; try { addressableSize = getAddressableSize(); } catch (DebugException e) { addressableSize = 1; } int addressesLength = fLength/addressableSize; 
<|del|> 
<|del|> 
 void invalidateMappingCache(); 
<|del|> 
 /** * {@inheritDoc} * * @see org.eclipse.sirius.business.api.dialect.DialectServices#getDeleteRepresentationTask(org.eclipse.sirius.viewpoint.DRepresentation) */ 
 final Switch switchOp = (Switch) op; task = new SwitchTask(context, extPackage, switchOp, session, uiCallback); 
 DeleteDRepresentationTask task = new DeleteDRepresentationTask((DRepresentation) dElement); task.setDeleteIncomingReferences(true); tasks.add(task); 
 if (representation instanceof DSemanticDecorator && ((DSemanticDecorator) representation).getTarget() == null) { representationsToDelete.add(representation); 
 if (dialect.getServices().canHandle(representation) && dialect.getServices().canExport(format)) { return true; 
 /* Requirements used in the tests */ private TmfAnalysisRequirement fRequirement; private TmfAnalysisRequirement fSubRequirement; 
 /* Requirements used in the tests */ private TmfAnalysisRequirement fRequirement; private TmfAnalysisRequirement fSubRequirement; 
<|del|> 
 int newValueLevel = Math.max(requirementValueLevel.ordinal(), subRequirementValueLevel.ordinal()); AnalysisRequirementValueLevel highestLevel = AnalysisRequirementValueLevel.values()[newValueLevel]; addValue(value, highestLevel); 
 /** * Determines if the analysis requirement has the same type of another * requirement. * 
 if (dialect.getServices().canHandle(representation) && dialect.getServices().canExport(format)) { return true; 
 String description = (detailedMessage == null) ? Messages.Breakpoint_attribute_problem : MessageFormat.format(Messages.Breakpoint_attribute_detailed_problem, new Object[] { detailedMessage}); 
 Ref branch_1 = git.branchCreate().setName("branch_1").call(); git.rm().addFilepattern("a").call(); File symlinkA = new File(db.getWorkTree(), "a"); 
 * 4.modify file 'a' 
<|del|> 
 ASTCommenter.addCommentsToMap(newNode.getTranslationUnit(), fCommentMap); 
 checkAttributeRelations(getAttributeSpecifiers(tu), IASTFunctionDeclarator.class); 
 // [[case_attr]] case 42: // [[default_attr]] default: 
 if (!acceptByAttributeSpecifiers(action)) return false; 
 super(CharArrayUtils.EMPTY_CHAR_ARRAY, null); 
 public void addAttribute(ICPPASTAttribute attribute) { assertNotFrozen(); 
<|del|> 
 CPPASTAttributeSpecifier copy = copy(new CPPASTAttributeSpecifier(), style); copy.attributes = ArrayUtil.trim(attributes, true); for (int i = 0; i < copy.attributes.length; i++) { copy.attributes[i] = copy.attributes[i].copy(style); 
import org.eclipse.cdt.core.dom.ast.cpp.ICPPASTAttribute; 
<|del|> 
<|del|> 
 protected enum SpaceLocation {BEFORE, AFTER} 
 return !(isJuno4Platform() || isKeplerPlatform()); 
 WEBKIT2 = webkit2 != null && webkit2.equals("1") && OS.GTK3; // $NON-NLS-1$ 
<|del|> 
 private static final String fTypeA = "Type A"; private static final String fTypeB = "Type B"; 
 if (ptr != 0) { OS.gtk_file_chooser_set_current_folder (handle, ptr); } 
 return part != null && part.getSelected() == EditPart.SELECTED_PRIMARY || part.getSelected() == EditPart.SELECTED; 
<|del|> 
 if (failures.size() == 1) { 
 // Range must not be in [3.103..3.106) return uiWorkbenchBundle != null && !Ranges.closedOpen(junoStart, lunaStart).contains(uiWorkbenchBundle.getVersion()); 
<|del|> 
<|del|> 
 addRefreshTask(parentTable, result, deleteTool); 
 if (TestsUtil.isDynamicTabbar()) { 
 if (TestsUtil.isDynamicTabbar()) { swtBotDesignerEditor.bot().toolbarButtonWithTooltip("Zoom Out (Ctrl+-)").click(); } else { 
 if (TestsUtil.isDynamicTabbar()) { 
 if (canBeDynamic()) { 
 * Indicates if the tabbar can be dynamic (if the workbench version supports it). 
 * @see org.eclipse.sirius.diagram.ui.tools.api.layout.SiriusLayoutDataManager#getInstance() 
 * @see org.eclipse.sirius.diagram.ui.tools.api.layout.SiriusLayoutDataManager#getInstance() 
 private static final int MAX_HTTP_HOST_CONNECTIONS_DEFAULT = 100; 
 return getSystemPropertyAndParseInt(MAX_HTTP_HOST_CONNECTIONS_PROPERTY, MAX_HTTP_HOST_CONNECTIONS_DEFAULT); 
 private void checkAttributeRelations(List<IASTAttributeSpecifier> specifiers, Class<? extends IASTAttributeOwner>... parentType) { 
<|del|> 
public interface IASTAttributeOwner extends IASTNode { @Deprecated 
 * @deprecated Ignored attributes should not be assigned to nodes directly, as an attribute 
 * @deprecated Ignored attributes should not be assigned to nodes directly, as an attribute 
 * Returns an array of all the node's attribute specifiers. 
 public IGCCASTAttributeSpecifier newGCCAttributeSpecifier(); 
public interface ICPPASTAttributeSpecifier extends IASTAttributeSpecifier { public static InstanceOfPredicate<IASTAttributeSpecifier> TYPE_FILTER = new InstanceOfPredicate<>(ICPPASTAttributeSpecifier.class); 
 @Override @Deprecated 
 protected boolean acceptByGCCAttributeSpecifiers(ASTVisitor action) { for (IASTAttributeSpecifier attributeSpecifier : attributeSpecifiers) { if (!(attributeSpecifier instanceof IGCCASTAttributeSpecifier)) continue; if (!attributeSpecifier.accept(action)) return false; } return true; 
 protected boolean acceptByGCCAttributeSpecifiers(ASTVisitor action) { for (IASTAttributeSpecifier attributeSpecifier : attributeSpecifiers) { if (!(attributeSpecifier instanceof IGCCASTAttributeSpecifier)) continue; if (!attributeSpecifier.accept(action)) return false; } return true; 
<|del|> 
 attribute.setParent(this); attribute.setPropertyInParent(IASTAttributeSpecifier.ATTRIBUTE); 
 @Override @Deprecated 
 public IGCCASTAttributeSpecifier newGCCAttributeSpecifier() { return new GCCASTAttributeSpecifier(); 
 } else if (cppFuncDef.isDeleted()) { 
 return SIGNIFICANT; 
 * Instantiate a new Edition Distance that will use * {@link WeightProviderDescriptorRegistryImpl#createStandaloneInstance()}. 
 Collection<WeightProvider.Descriptor> getDescriptors(); 
 * Constructor that instantiate a {@link DefaultMatchEngine}. This match engine will use a the standalone * weight provider registry {@link WeightProviderDescriptorRegistryImpl.createStandaloneInstance()}. 
 private static final String PROPERTY_MAX_HTTP_HOST_CONNECTIONS = "org.eclipse.mylyn.http.connections.per.host"; //$NON-NLS-1$ 
 assertEquals(MAX_HTTP_HOST_CONNECTIONS_DEFAULT, NetUtil.getMaxHttpConnectionsPerHost()); 
 monitor.beginTask( NLS.bind(Messages.GerritRepositorySearchPage_Refreshing_X, repository.getRepositoryLabel()), IProgressMonitor.UNKNOWN); 
<|del|> 
 if (feat instanceof EAttribute) { return feat.isDerived() || feat.isTransient(); } else { 
<|del|> 
 public static final Predicate<EReference> DSEMANTICDECORATOR_REFERENCE_TO_IGNORE_PREDICATE = new Predicate<EReference>() { 
 return 0; 
 // null checks on date variables Preconditions.checkNotNull(past, "Should not be null"); Preconditions.checkNotNull(now, "Should not be null"); 
 // null checks on date variables Preconditions.checkNotNull(past, "Should not be null"); Preconditions.checkNotNull(now, "Should not be null"); 
 return getMessageFormat("day").format(new Object[] { days }); 
 return getMessageFormat("minute").format(new Object[] { minutes }); 
 @Test(expected = NullPointerException.class) public final void testNullCheck() { 
 public final void testOneMinuteDifference() { String result = new DateFormatter().formatUnit(new Date(0), new Date( TimeUnit.MINUTES.toMillis(1))); assertEquals("1 minute ago", result); 
 public final void testOneDayDifference() { String result = new DateFormatter().formatUnit(new Date(0), new Date( TimeUnit.DAYS.toMillis(1))); assertEquals("1 day ago", result); 
 public final void testTwoDaysDifference() { String result = new DateFormatter().formatUnit(new Date(0), new Date( TimeUnit.DAYS.toMillis(2))); assertEquals("2 days ago", result); 
 * The name of the extension point attribute. 
 * 
 if (!isCorrectPhase(step, ce)) { 
 if (!isCorrectPhase(step, ce)) { 
 if (!isCorrectPhase(step, ce)) { 
 Preconditions.checkNotNull(past); Preconditions.checkNotNull(now); 
 Preconditions.checkNotNull(past); Preconditions.checkNotNull(now); 
 new DateFormatter().formatUnit(null, null); 
 new DateFormatter().formatUnit(null, null); 
 new DateFormatter().formatUnit(null, null); 
 DAYS.toMillis(1))); 
<|del|> 
 if (representation instanceof DDiagram) { gmfDiagramUpdater = new GMFDiagramUpdater(getSession(), (DDiagram) representation); 
 * @since 3.12 
 assertSortedLike("", ""); 
 if (o1.length() == 0 || o2.length() == 0) return o1.length() - o2.length(); 
 .format("{0,choice,0#0 minutes ago|1#1 minute ago|1<{0,number,integer} minutes ago}", 
 * Copyright (c) 2014 Akif Etkue. 
<|del|> 
 /** * Gets the list of the analysis requirements. * * @return List of the analysis requirements */ Iterable<TmfAnalysisRequirement> getRequirements(); 
 return new ArrayList<>(); 
 Set<String> values = subRequirement.getValues(); 
<|del|> 
<|del|> 
 public void testPerspeciveForViews() { SWTBotUtil.switchToPerspective(fPerspectiveId); 
<|del|> 
<|del|> 
<|del|> 
 /* The domain type */ TmfAnalysisRequirement domain = new TmfAnalysisRequirement(SessionConfigStrings.CONFIG_ELEMENT_DOMAIN); domain.addValue(SessionConfigStrings.CONFIG_ELEMENT_DOMAIN_TYPE_UST, AnalysisRequirementValueLevel.MANDATORY); 
 public void testPerspectiveComplete() { 
 * Gets the perspective and checks if all the views specified in the list * are present in the perspective 
 public void testPerspectiveForViews() { 
 * Message bundle for the ust memory analysis module * 
<|del|> 
 leftEditable = compareConfiguration.isLeftEditable(); 
 rightEditable = compareConfiguration.isRightEditable(); 
 switch (top.readNextEvent()) { case OK: { 
 public void dealloc () { OS.objc_msgSend (this.id, OS.sel_dealloc); } 
 IOseeBranch branch = getProgramBranch(program); 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 if (p instanceof ProcessFailureException) { 
<|del|> 
<|del|>
 OS.g_signal_connect (OS.gdk_keymap_get_default (), OS.keys_changed_event, keysChangedProc, 0); 
protected int findLatinKeyGroup () { 
 groupKeysCount.put (key_entry.group, keys_count); 
public int getLatinKeyGroup () { 
 latinKeyGroup = findLatinKeyGroup (); 
 && OS.gdk_keymap_get_entries_for_keycode (0, keyEvent.hardware_keycode, keys, keyvals, n_entries)) { GdkKeymapKey key_entry = new GdkKeymapKey (); 
 OS.memmove (keyval_entry, keyvals [0] + i * C.INT_SIZEOF, C.INT_SIZEOF); 
 * @param point the point of instantiation, determines the scope for name lookups 
 protected static boolean areAllConstantExpressions(ICPPEvaluation[] evaluations, IASTNode point) { 
 return areAllConstantExpressions(fArguments, point) && isConstexprFuncOrNull(getOverload(point)); 
 && isConstexprFuncOrNull(getOverload(point)); 
 private void adjustBuildPropertiesFile(IFile file) 
<|del|> 
 IThemeManager mgr = appContext.get(IThemeManager.class); 
<|del|> 
 public void smoketestClassDefinition() { 
<|del|> 
 * Returns a {@link IModelResolver} that handles the given IStorage. 
 * The descriptor holds optional field such as label or description. 
 * The descriptor holds optional field such as label or description. 
 Preconditions.checkArgument(resolver != null); Preconditions.checkArgument(id != null); 
<|del|> 
 private Map<String, ModelResolverDescriptor> descriptors = Collections .synchronizedMap(new LinkedHashMap<String, ModelResolverDescriptor>()); 
<|del|> 
 public ModelResolverDescriptor getUserSelectedResolved() { 
 * This registry implement its own strategy to define the "best" resolver to use. 
 * always returns a resolver that does not resolve anything else than the current resource. 
 m_label.setHorizontalAlignmentFromScout(LABEL_HORIZONTAL_ALIGNMENT_LEFT); 
 public void testForegroundColor() { 
<|del|> 
 return ImmutableList.<IDeclarationProvider>copyOf(fStreamInputReaders); 
 * @return Immutable map with the event declarations * @since 3.0 
public class StreamInputReader implements AutoCloseable ,IDeclarationProvider{ 
 } IPreferenceStore diagramUIPreferences = DiagramUIPlugin.getPlugin().getPreferenceStore(); for (String key : oldValueDiagramUiPreferences.keySet()) { resetDiagramUiPreference(key, diagramUIPreferences); } 
 perspectiveStack.setElementId(IWorkbenchConstants.PERSPECTIVE_STACK_ID); 
<|del|> 
 * 
 if (commit.getParentCount() != 1) 
 return root.getFile(storage.getFullPath()).isAccessible(); 
 final EObject sourceContainerNode = getNodeNamed(left, "root"); assertNotNull(sourceContainerNode); 
 final EObject sourceContainerNode = getNodeNamed(left, "value3"); assertNotNull(sourceContainerNode); 
 * Copyright (c) 2012, 2014 Obeo. 
<|del|> 
 } else { // FIXME Manage this case. See javadoc of eContainingFeature. This is possible and will happen // with feature maps. http: // //download.eclipse.org/modeling/emf/emf/javadoc/2.8.0/org/eclipse/emf/ecore/EObject.html#eContainingFeature%28%29 
 return URIUtil.toUnencodedString(getLocation()); 
<|del|> 
 * Copyright (c) 2000, 2014 IBM Corporation and others. 
 Activator .error("Error resolving HEAD for showing annotations in repository: " + repository, e); //$NON-NLS-1$ return; 
 if (fileRevision instanceof OpenWorkspaceVersionEnabled) { OpenWorkspaceVersionEnabled workspaceVersion = (OpenWorkspaceVersionEnabled) fileRevision; final File workspaceFile = new File(workspaceVersion .getRepository().getWorkTree(), workspaceVersion.getGitPath()); 
 manager.insertAfter("file", action); //$NON-NLS-1$ 
<|del|> 
<|del|> 
<|del|> 
 * Provides the workspace version of a file. <br> * 
 filteredTree = new FilteredTree(parent, styleBits, filter, true); filteredTree.setQuickSelectionMode(true); 
 if (descriptor.getId().equals(elementId) && WorkbenchActivityHelper.filterItem(descriptor)) { 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** The sub-attributes (<basename, attribute>) of this attribute */ private final Map<String, Attribute> subAttributes; 
 return getImageDescriptorFromPath(path).createImage(); 
 public static final String ID = "org.eclipse.linuxtools.tmf.analysis.xml.ui.views.xmlExplorer.XMLExplorerView"; //$NON-NLS-1$ 
 /** Listeners associated with this compare input. */ 
 * {@inheritDoc} 
 listeners.add(listener); 
 * A {@link LabelContentViewer} in case of a comparison with no differences. 
 * @author <a href="mailto:axel.richard@obeo.fr">Axel Richard</a> 
 * {@inheritDoc} 
 * Creates an empty viewer with a single centered label which says there is no differences for the comparison. 
 * A {@link LabelContentViewer} in case of a comparison with no differences. 
<|del|> 
<|del|> 
 } else { 
 public void setUuid(Long id) { this.guid = id; 
 Collection<Long> ids = criteria.getIds(); 
 public static final Long DEFAULT_UUID = -1L; 
 private static final String pathname = "test_xml_files/test_invalid"; 
 String tooltip = obj.getTooltip(event.x, event.y); 
 IComparisonScope scope = createComparisonScope(); assertSame(registryWrapper.getHighestRankingMatchEngineFactory(scope), factory3); assertTrue(registryWrapper.getMatchEngineFactories(scope).containsAll( 
 IComparisonScope scope = createComparisonScope(); assertEquals(registryWrapper.getHighestRankingMatchEngineFactory(scope), null); assertTrue(registryWrapper.getMatchEngineFactories(scope).isEmpty()); 
 IComparisonScope scope = createComparisonScope(); assertSame(registryWrapper.getHighestRankingMatchEngineFactory(scope), factory3); assertTrue(registryWrapper.getMatchEngineFactories(scope).containsAll( 
 * IBM Corporation - initial API and implementation * Stefan Winkler <stefan@winklerweb.net> - Bug 430848 
<|del|> 
 private void setCSSData() { this.setData(CSSSWTConstants.CSS_ID_KEY, SPLASH_PROGRESS_PART_ID); fProgressIndicator.setData(CSSSWTConstants.CSS_ID_KEY, SPLASH_PROGRESS_INDICATOR_ID); fLabel.setData(CSSSWTConstants.CSS_ID_KEY, SPLASH_PROGRESS_TEXT_ID); 
<|del|>
 * @return A {@link Set} of {@link IDifferenceFilter} that shall be used by default for next comparison. 
 * 'background-color: inherit;' Instead, the background-color is set to the * background-color of the parent widget. 
 return ImmutableList.copyOf(subAttributes.values()); 
 @Mock private DispoApi dispoApi; @Mock private DispoHtmlWriter htmlWriter; @Mock private DispoProgram id1; @Mock private DispoProgram id2; @Mock private DispoFactory dispoFactory; 
<|del|> 
<|del|> 
 @VisibleForTesting 
 public void setUp() throws Exception { 
 assertThat(actualOutput, is(nullValue())); 
 return Collections.EMPTY_SET; 
 private static final String fTypeA = "TEST TYPE A"; private static final String fTypeB = "TEST TYPE B"; 
 * Interface that provides the necessary methods for an analysis to define its 
 * requirement object could indicate the possible events handled by the * analysis. 
 private final Map<String, ValuePriorityLevel> fValues = new HashMap<>(); private final Set<String> fInformation = new HashSet<>(); 
 public enum ValuePriorityLevel { 
 public void addValue(String value, ValuePriorityLevel level) { synchronized (fValues) { fValues.put(value, level); } 
 public Set<String> getValues() { synchronized (fValues) { return fValues.keySet(); } 
 public Set<String> getInformation() { return fInformation; 
 public ValuePriorityLevel getValueLevel(String value) { synchronized (fValues) { return fValues.get(value); } 
 return Collections.EMPTY_SET; 
 * Moreover, useful information that can not be leveled with a priority but are 
 * Moreover, useful information that can not be leveled with a priority but are 
 assertTrue(fModule.appliesToTraceType(traceType)); assertEquals(traceTypeHelper.getTraceClass(), traceType); traceTypeCount++; 
 crossRefDetector.assertNoFoundCrossReferenceAdapter(); 
<|del|> 
 Assert.isLegal(searchRoot != null); 
<|del|>
<|del|> 
 parentOperation.results.putAll(pullOperationUI.results); int missing = parentOperation.tasksToWaitFor.decrementAndGet(); 
 addCleanupDisposeListener(toolbarModel, manager.getControl()); 
 * Sopot Cela <sopotcela@gmail.com> - Bug 431868 
<|del|> 
 createToolControlMenu(toolControl, newCtrl); 
 private void createToolControlMenu(final MToolControl toolControl, 
<|del|> 
<|del|> 
 public static final String ID = "org.eclipse.linuxtools.tmf.analysis.xml.ui.views.xmlExplorer.XMLExplorerView"; //$NON-NLS-1$ 
 final private Map<TreeItem, Path> fItemsPaths = new HashMap<>(); 
 final private IPath fXmlFilesPath; 
 super(ID); 
 final Map<String, TreeItem> fNodes = new HashMap<>(); final Map<TreeItem, ArrayList<Path>> fChildren = new HashMap<>(); 
 dFile.delete(); XmlAnalysisModuleSource.notifyModuleChange(); 
 dFile.delete(); XmlAnalysisModuleSource.notifyModuleChange(); 
 // This is a workaround for bug 401439. // widget (CTabFolder) is internally marked as inDispose 
<|del|> 
<|del|> 
 ICTabRendering renderer = (ICTabRendering) folder .getRenderer(); 
 Color backgroundSetByRenderer = (Color) control .getData(BACKGROUND_SET_BY_TAB_RENDERER); 
 public static void setBackgroundOverriddenDuringRenderering( Composite composite, Color background) { 
 /* There should be the event and domain type */ 
 /* The domain type of the analysis */ TmfAnalysisRequirement domainReq = new TmfAnalysisRequirement(SessionConfigStrings.CONFIG_ELEMENT_DOMAIN); domainReq.addValue(SessionConfigStrings.CONFIG_ELEMENT_DOMAIN_TYPE_KERNEL, AnalysisRequirementValueLevel.MANDATORY); requirements.add(domainReq); 
 List<TmfAnalysisRequirement> requirements = new LinkedList<>(); 
<|del|> 
 HashSet<String> allKeys = new HashSet<String>(Arrays.asList(getOriginal().keys())); for (Entry<String, Object> entry : temporarySettings.entrySet()) { String key = entry.getKey(); if (entry.getValue() != null) { 
 engine.restore(cssTheme); 
 /** * Allows us to know if the {@link #initToolbar(AbstractTreeViewer, INavigatable)} step has been executed. */ private boolean doOnce; 
 /** * Allows us to know if the {@link #initToolbar(AbstractTreeViewer, INavigatable)} step has been executed. */ private boolean doOnce; 
 if (!this.doOnce) { compareConfiguration.getEventBus().register(this); 
 MarkerMessages.errorsAndWarningsSummaryBreakdown, counts[0], counts[1], counts[2] + counts[3]), 
 /** 
 final private int forkedProcessTimeoutInSeconds; 
 assertThat(getOnlyElement(sut.getSnippets()).getProposal(), is(snippet)); 
<|del|> 
 public AttachSessionResponse attachToSession(SessionResponse lttngViewerSession) throws IOException { 
 public AttachSessionResponse attachToSession(SessionResponse lttngViewerSession) throws IOException { 
 fSessionId = sessionId; 
 fSeek = seekCommand; 
 * Gets the offset 
<|del|> 
 * Gets the live timer 
 * Gets the number streams 
 * Get the flags 
 final ITmfTimestamp ts = (ITmfTimestamp) other; return (compareTo(ts) == 0); 
 public static final Version JENKINS_1_511 = new Version("1.511"); //$NON-NLS-1$ 
 public HudsonServerInfo(Type type, String version) { 
 if (new IFileQuery(file).isResourceHandledByOpenedSession()) { 
 // This can happen when trying to get the label of a CDOObject // which transaction has just been closed 
 public boolean isResourceHandledByOpenedSession() { 
 return Type.JENKINS.equals(type) && JENKINS_1_511.compareTo(version) < 0; 
 State state = admin.getState(false); BundleDescription[] bundles = state.getBundles(); for (BundleDescription desc : bundles) { if (desc.getName() != null) { prefs.add(InstanceScope.INSTANCE.getNode(desc.getName())); } 
<|del|> 
 if (f != null 
<|del|> 
 update(name, mId, mMode); // 1 else if (m == null) 
 this.walk.getObjectReader())) { 
 /** the stream Id */ 
<|del|> 
 * Get packet return code * * @author Matthew Khouzam 
<|del|> 
 * Fixed size, helps if you have an array of that type * * @author Matthew Khouzam 
public interface IFixedSize { 
 * Command sent, needs a getBytes to stream the data * * @author Matthew Khouzam 
public interface IRelayCommand { 
 public byte[] serialize(); 
<|del|>
 * An Lttng packet index 
 private final long fOffset; 
 * VIEWER_LIST_SESSIONS payload. * 
public class ListSessionsResponse implements IRelayResponse, IFixedSize { 
 * * @author Matthew Khouzam 
 * * @author Matthew Khouzam 
 private final long fLength; 
<|del|> 
<|del|> 
 private final byte fChannelName[] = new byte[LTTngViewerCommands.LTTNG_VIEWER_NAME_MAX]; 
 public boolean newBuildReturnsCreated() { 
 /* * in GTK 3.8 computeNativeSize returning 0 for height. * So if the height is returned as zero calculate the table height * based on the number of items in the table */ 
 private static final String TYPE_A = "Test Type A"; private static final String TYPE_B = "Test Type B"; 
 return Collections.EMPTY_SET; 
 public static final String PLUGIN_ID = "org.eclipse.linuxtools.tmf.ctf.core"; //$NON-NLS-1$ 
 public static final String PLUGIN_ID = "org.eclipse.linuxtools.tmf.ctf.ui"; //$NON-NLS-1$ 
 public static final String PLUGIN_CORE_ID = "org.eclipse.linuxtools.tmf.ctf.core"; //$NON-NLS-1$ 
 private Set<URI> sessionFileLoading = Sets.newHashSet(); 
 response = Response.status(Response.Status.OK).entity(result).build(); 
<|del|> 
 * Test suite. 
 private static LttngKernelAnalysisModule fKernelAnalysisModule = new LttngKernelAnalysisModule(); 
 } else if (requirement.getType().equals(SessionConfigStrings.CONFIG_ELEMENT_DOMAIN)) { 
<|del|> 
 * Copyright (c) 2014 Ericsson 
<|del|> 
 public Iterable<StreamResponse> getNewStreams() throws IOException; 
 public static ILttngRelaydConnector getNewConnector(Socket myConnection) throws IOException { DataOutputStream outNet = new DataOutputStream(myConnection.getOutputStream()); DataInputStream inNet = new DataInputStream(myConnection.getInputStream()); 
<|del|> 
 * Return codes for "viewer attach" command * * @author Matthew Khouzam 
 * * @author Matthew Khouzam 
 public int size() { // long + int + seek command which is 2 ints 
 public byte[] serialize() { 
 * * @author Matthew Khouzam 
 private final AttachReturnCode fStatus; 
 private static int size() { return 8; 
 * Viewer commands * * @author Matthew Khouzam 
public enum Command implements IBaseCommand { 
 * * @author Matthew Khouzam 
 private final long fViewerSessionId; 
 private final ConnectionType fType; 
 * Get viewer connection type * * @author Matthew Khouzam 
public enum ConnectionType implements IBaseCommand { 
 private final CreateSessionReturnCode fStatus; 
<|del|> 
 * VIEWER_GET_METADATA payload. * * @author Matthew Khouzam 
 * Get metadata return code * * @author Matthew Khouzam 
 * VIEWER_GET_NEXT_INDEX payload. * * @author Matthew Khouzam 
 * VIEWER_GET_PACKET payload. * * @author Matthew Khouzam 
 public String getVersion() { 
 return null; 
 StringBuilder b = new StringBuilder("/"); //$NON-NLS-1$ 
 StringBuilder b = new StringBuilder('/'); b.append(path.lastSegment()); 
 } catch (URISyntaxException | IOException | TmfTraceException e) { throw new IllegalStateException(e); 
 /* TestAnalysis2 module with trace, should return an exception */ 
 /* TestAnalysis2 module with a TraceStub2 */ 
 * Set this flag to visit virt-specifiers. * @since 5.7 
 "ICPPASTFunctionDeclarator.TRAILING_RETURN_TYPE [IASTTypeId]"); //$NON-NLS-1$ /** @since 5.7 */ 
 final Map<String, TreeItem> Nodes = new HashMap<>(); final Map<TreeItem, ArrayList<Path>> Children = new HashMap<>(); 
 XmlAnalysisModuleSource.notifyModuleChange(); /* * TODO:Trigger a refresh of the workspace, so the analysis that are * removed are no longer shown */ 
 // So, in this case, if the bp applies to all threads of one process, it will 
 IOseeBranch branch = getProgramBranch(program); 
 protected HashMap<String, GraphicObjectContainer> m_childrenObjectsMap = new HashMap<String, GraphicObjectContainer>(); 
 private final SavingPolicy delegate; 
 if (f != null && isModifiedSubtree_IndexWorkingtree(name)) { 
 shell, dialogTitle, 
 List<ResourceMapping> result = new ArrayList<>(); 
<|del|>
 repoName), 
 // A memorySpaceDMContext should not be created if the memorySpaceId is not valid. 
<|del|> 
 private int getAddressableSize(IMemoryDMContext context) { 
 private int getAddressSize(IMemoryDMContext context) { 
<|del|> 
 private AbstractFocusViewAction focusAction; 
 if (focusAction != null) { focusAction.update(!focusAction.isChecked()); returnValue = true; 
<|del|> 
 * Sets whether the container's boundary should be drawn / filled-in. 
 Returns null if object is not found */ 
<|del|> 
 /** Returns a list of selectable objects */ 
 UIText.CommitFileDiffViewer_notContainedInCommit, d.getPath(), d.getCommit().getId().getName()); 
 createControlForFeature(feature); 
 super(modelFactory, node, container, Collections.EMPTY_LIST, eventField); 
public class StreamInput implements IDefinitionScope, AutoCloseable { 
 /** * File input stream, the parent input file */ 
 public void close() throws IOException { fFileChannel.close(); 
public final class LttngRelaydConnectorFactory { 
 ConnectResponse connectPayload = new ConnectResponse(0, MAJOR_VERSION, MINOR_VERSION, ConnectionType.VIEWER_CLIENT_COMMAND); 
 /* enum + stream count, first half of a packet */ return (Integer.SIZE + Integer.SIZE) / 8; 
 private final long fStreamId; 
public interface IRelayCommand extends Serializable { 
 * Copyright (c) 2014 Ericsson 
 * LTTng Relay Daemon API. needs a TCP connection, API is defined from * BSD-licensed implementation in Lttng tools: <a href= 
<|del|> 
 fStreamList = sl.build(); 
 VIEWER_SEEK_LAST(2); 
<|del|> 
<|del|> 
 // TODO change to context access once // https://bugs.eclipse.org/bugs/show_bug.cgi?id=445600 // is solved PlatformUI.getWorkbench().getHelpSystem().setHelp(shell, IWorkbenchHelpContextIds.SHOW_VIEW_DIALOG); 
 boolean hasTooltip = tooltip != null && tooltip.length() > 0; 
 if (obj instanceof ITooltipProvider) { 
 /** * @since 1.1 */ @Override public String getTooltip(int x, int y) { return null; } 
<|del|> 
 * Marc Dumais (Ericsson) - initial API and implementation * Xavier Raynaud (Kalray) - Bug 430804 
 //TODO: button default size //TODO: use GridLayoutFactory/ GridDataFactory 
 @VisibleForTesting Set<PrivateDatum> readRegistredDatums(IConfigurationElement[] configurationElements) { 
 return id; 
 DatumRegistry sut = new DatumRegistry(); Set<PrivateDatum> datums = sut.readRegistredDatums(null); assertThat(datums.size(), is(0)); datums = sut.readRegistredDatums(new IConfigurationElement[] {}); assertThat(datums.size(), is(0)); 
 DatumRegistry sut = new DatumRegistry(); Set<PrivateDatum> datums = sut.readRegistredDatums(null); assertThat(datums.size(), is(0)); datums = sut.readRegistredDatums(new IConfigurationElement[] {}); assertThat(datums.size(), is(0)); 
 assertThat(datums.size(), is(1)); PrivateDatum datum = Iterables.getOnlyElement(datums); 
 IConfigurationElement configElement = mockConfigElement("datum", ImmutableMap.of(ATTRIBUTE_ID, "some id", ATTRIBUTE_NAME, "some name", ATTRIBUTE_DESCRIPTION, "some description", ATTRIBUTE_ICON, "datum.png")); 
 * Obeo - initial API and implementation * IBM Corporation and others - The code for default load/save options was lifted * from GMF's org.eclipse.gmf.runtime.emf.core.resources.GMFResourceFactory. 
 * Obeo - initial API and implementation * IBM Corporation and others - The deresolve() method was lifted from GMF's * org.eclipse.gmf.runtime.emf.core.resources.GMFHelper 
 Set<PrivateDatum> readRegistredDatums(IConfigurationElement... configurationElements) { 
 Set<PrivateDatum> datums = sut.readRegistredDatums(configElement); assertThat(datums.size(), is(0)); 
 checkNotNull(id); checkNotNull(name); checkNotNull(description); 
 sut.readRegistredDatums(new IConfigurationElement[] { configElement }); 
 sut.readRegistredDatums(new IConfigurationElement[] { configElement }); 
 PrivateDatum datum = getOnlyElement(datums); assertThat(datum.getId(), is("some id")); assertThat(datum.getName(), is("some name")); assertThat(datum.getDescription(), is("some description")); 
 PrivateDatum datum = getOnlyElement(datums); assertThat(datum.getId(), is("some id")); assertThat(datum.getName(), is("some name")); assertThat(datum.getDescription(), is("some description")); 
 IConfigurationElement configElement = mockConfigElement(DATUM, ImmutableMap.of(ATTRIBUTE_ID, "some id", 
 assertThat(datums.size(), is(0)); 
 * A dummy viewer that displays a single label. 
 * Returns whether an immediate child of current object reports 
 /** * boolean * * @deprecated Use {@link MavenPreferenceConstants#P_DUP_OF_PARENT_GROUPID_PB} instead */ 
 /** * boolean * * @deprecated Use {@link MavenPreferenceConstants#P_DISABLE_VERSION_DUP_OF_PARENT_WARNING} instead */ 
 private static final boolean HAS_JAVA_NIO = checkForJavaNio(); 
 REQUIREMENTS = ImmutableSet.of(domainReq, new TmfAnalysisRequirement(SessionConfigStrings.CONFIG_ELEMENT_EVENT, REQUIRED_EVENTS, ValuePriorityLevel.MANDATORY)); 
 private UstMemoryAnalysisModule fUstAnalysisModule; 
 assertNotNull(requirements); assertTrue(requirements.iterator().hasNext()); 
 List<String> expectedEvents = ImmutableList.of( UstMemoryStrings.MALLOC, 
 UstMemoryStrings.POSIX_MEMALIGN ); 
 private static final ImmutableSet<String> REQUIRED_EVENTS = ImmutableSet.of( UstMemoryStrings.MALLOC, 
 private static final ImmutableSet<String> REQUIRED_EVENTS = ImmutableSet.of( UstMemoryStrings.MALLOC, 
 UstMemoryStrings.POSIX_MEMALIGN ); 
 Builder<SessionResponse> sl = new ImmutableList.Builder<>(); 
<|del|> 
 Set<String> expectedEvents = ImmutableSet.of( 
 /** The requirements as an immutable set */ private static final ImmutableSet<TmfAnalysisRequirement> REQUIREMENTS; 
 REQUIREMENTS = ImmutableSet.of(domainReq, new TmfAnalysisRequirement(SessionConfigStrings.CONFIG_ELEMENT_EVENT, REQUIRED_EVENTS, ValuePriorityLevel.MANDATORY)); 
 Set<String> expectedEvents = ImmutableSet.of( 
 /** The requirements as an immutable set */ private static final ImmutableSet<TmfAnalysisRequirement> REQUIREMENTS; 
 private final long fSessionId; 
 * Create a listener to react to mouse movements made in the provided chart region. 
 public Iterable<IEventDeclaration> getEventDeclarations() { ImmutableSet.Builder<IEventDeclaration> builder = new Builder<>(); for(StreamInputReader sir :fStreamInputReaders ){ builder.addAll(sir.getEventDeclarations()); } return builder.build(); 
 public Iterable<IEventDeclaration> getEventDeclarations() { ImmutableSet.Builder<IEventDeclaration> builder = new Builder<>(); for(StreamInputReader sir :fStreamInputReaders ){ builder.addAll(sir.getEventDeclarations()); } return builder.build(); 
public class StreamInputReader implements AutoCloseable{ 
<|del|> 
 * @since 1.5 
 } catch (InterruptedException e) { Thread.currentThread().interrupt(); 
 } catch (InterruptedException e) { Thread.currentThread().interrupt(); 
 } catch (InterruptedException e) { Thread.currentThread().interrupt(); 
 /** * This will lock will prevent concurrent modifications of this resolver's fields. Most notably, * {@link #currentlyResolving} and {@link #resolvedResources} must not be accessed concurrently by two * threads at once. */ 
 unloadingPool.execute(new ResourceUnloader(resourceSet, resource, monitor)); 
 * Copyright (c) 2006 IBM Corporation and others. 
 * Copyright (c) 2014 Red Hat, Inc. and others 
 new Object[] { null, manager, activeTaskSelectionProvider }, new Class[] { IWorkbenchPart.class, IMenuManager.class, ISelectionProvider.class }); 
 * @author Andras Szabolcs Nagy 
 * @author Andras Szabolcs Nagy 
 * @author Fldenyi Miklos & Nagy Andras Szabolcs 
 * @author Foldenyi Miklos 
 @Override public void start(BundleContext context) { IExtensionRegistry extensionRegistry = Platform.getExtensionRegistry(); 
<|del|> 
<|del|> 
<|del|> 
 * @author Miklos Foldenyi 
<|del|> 
 logger.error(e); 
<|del|> 
<|del|> 
 // Is the state exists? if yes then return false 
 state.addInTransition((Transition) sourceTransition); 
 // save new state 
 // finish modifying shared data 
<|del|> 
 logger.error(e); 
 RuleInfo precedingRuleInfo = context.getRuleInfos().get(node.getTransformationRule()); 
<|del|> 
<|del|> 
<|del|> 
 String lastHash = null; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private boolean checkDependencies; 
 private boolean checkDependencies; 
<|del|> 
 String path = proj.getPath(); 
<|del|>
<|del|> 
 * Gets an iterable of the event declarations, useful for foreaches 
 * Gets the event declaration Iterable for this StreamInput 
 UIText.GitModelSynchronize_fetchGitDataJobName) { 
<|del|> 
 * 
<|del|> 
 final protected void doRemove(Object[] selection) { 
 IFolder destinationFolder = traceFolder.getFolder(new Path(relativeTracePath.toOSString())); 
<|del|> 
<|del|> 
 * @param destinationFolder * The destination folder (full workspace path) 
 * Returns the destination folder to import the trace to (full workspace path). 
 return fDestinationFolder; 
 TraceUtils.createFolder(destinationFolder, monitor); 
 String[] entries = new String[fColumnData.length]; for (int i = 0; i < fColumnData.length; i++) { entries[i] = fColumnData[i].getValue().toString(); 
 * Copyright (c) 2009, 2014 IBM Corporation and others. 
 public String confirmation(@QueryParam("hash") String hash) throws Exception { Conditions.checkNotNull(hash, "Hash parameter"); 
 public String[] getEventStrings() { 
 TmfTraceElement tmfTraceElement = getMatchingTraceElement(traceElement); if (tmfTraceElement != null) { try { bookmarksFile = tmfTraceElement.createBookmarksFile(); 
 int modifierKeys = event.stateMask & SWT.MODIFIER_MASK; boolean ctrlKeyPressed = (event.stateMask & SWT.CTRL) != 0; boolean onlyCtrlKeyPressed = modifierKeys == SWT.CTRL; boolean macCmdKeyPressed = (event.stateMask & SWT.COMMAND) != 0; 
<|del|> 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Copyright (c) 2014 Boeing. 
 * Copyright (c) 2014 Boeing. 
public class StreamInputReader implements AutoCloseable { 
 for (StreamInputReader sir : fStreamInputReaders) { 
 return new ExceptionLogHandler<RT>(logger); 
 && (repos.getAccount() == getAuthor() || (repos.getAccount() != null && repos.getAccount().getEmail().equals(getAuthor().getEmail()))); 
<|del|> 
<|del|> 
<|del|> 
 if (status.isOK()) { 
 if (query.getAttribute(GerritQuery.QUERY_STRING).isEmpty()) { 
 }); 
 return HttpUtil.execute(getHttpClient(), HttpUtil.createHost(request), getContext(), request, monitor); 
<|del|> 
@Deprecated public final class ArrayDefinition extends Definition { 
<|del|> 
<|del|> 
<|del|> 
 @NonNull String ret = b.toString(); 
 return (ArrayDefinition) ((def instanceof ArrayDefinition) ? def : null); 
 return (ArrayDefinition) ((def instanceof ArrayDefinition) ? def : null); 
 if (isString()) { // Don't create "useless" definitions 
 return new FixedStringDefinition(this, definitionScope, fieldName, new String(data)); 
 String expectedFilePath3 = "some_directory/nested_directory/file_3.txt"; 
public final class TmfRemotePreferences { 
 public static final String PLUGIN_ID = "org.eclipse.linuxtools.tmf.remote.ui"; //$NON-NLS-1$ 
<|del|> 
<|del|> 
 /** * Return the width of the column at the creation. * * @return the width of the column. */ 
<|del|> 
 private void validateStashedCommit(final RevCommit commit, int parentCount) 
<|del|> 
<|del|> 
 if (ok) 
<|del|> 
<|del|> 
 * true (default) if the command should restore untracked files * @since 3.4 
 * @return {@code this} * @since 3.4 
 private final boolean includeUntracked; 
 private ICPPASTClassVirtSpecifier virtSpecifier; 
 @Override @Deprecated 
 // Don't use the 'kind' argument as there is currently only one kind. assert kind == ICPPASTClassVirtSpecifier.SpecifierKind.Final; 
 || token.getNode() instanceof ICPPASTClassVirtSpecifier; 
 } catch (RuntimeException e) { 
 } catch (RuntimeException e) { 
 * Copyright (c) 2012, 2014 Obeo and others. 
<|del|> 
<|del|> 
 /** * Thread safely Add the given diagnostic to the {@link #diagnostic} field. * * @param resourceDiagnostic * the diagnostic to be added to the global diagnostic. */ 
 * Copyright (c) 2012, 2014 Obeo. 
 * Checks to see if the statement is the last one in a GNU Statement-Expression 
 private boolean isLastExpressionInStatementExpression(IASTExpression e) { // Check if it is part of GNU compound stmt expression i.e. ({int a; foo(a); a;}) 
 // Are we evaluating the last statement in the list? 
 // There can be multiple candidate lanes. In that case the longest 
 // When there are no candidate lanes (i.e. the current commit has 
 // There can be multiple candidate lanes. In that case the longest 
 private static BranchUuidEventFilter commonBranchGuidEventFilter; 
 if (eeConfiguration.isIgnoredByResolver()) { return new AllKnownEEsResolutionHandler(); } else if (eeConfiguration.isCustomProfile()) { 
<|del|> 
<|del|> 
 * Finds the shell service SubSystem of this host. 
 return DiagramUIPlugin.getPlugin().getImage(SiriusEditPlugin.Implementation.getBundledImageDescriptor("icons/full/decorator/permission_denied.gif")); //$NON-NLS-1$ 
 protected IOseeBranch getBranchFromUuid(long uuid) { 
 private IOseeBranch getBranchFromUuid(long uuid) { return OrcsApplication.getOrcsApi().getQueryFactory(null).branchQuery().andUuids(uuid).includeArchived().includeDeleted().getResultsAsId().getExactlyOne(); 
 @NonNull public RepositoryInfo validateRepository(@NonNull TaskRepository repository, @Nullable IProgressMonitor monitor) throws CoreException { 
 public void applyDefaultCategory(@NonNull TaskRepository repository) { 
 private final DispoItemData item1 = new DispoItemData(); private final DispoItemData item2 = new DispoItemData(); 
 conn.setRequestProperty(HDR_AUTHORIZATION, getType().getName() 
 public String getSchemeName() { 
 /** * @return the name of the authentication scheme in the form to be used * in HTTP authentication headers as specified in RFC2617 and * RFC4559 */ public abstract String getSchemeName(); 
 public PackFile(final File packFile, int extensions) { 
<|del|> 
 Artifact modelCoordinate = settings.getModelCoordinate() != null ? settings.getModelCoordinate() : settings 
 @Argument(index = 0, metaVar = "GROUP_ID:ARTIFACT_ID:VERSION", required = true, usage = "The Maven coordinate of the source artifact for which you want to generate Javadoc", handler = ArtifactOptionHandler.class) 
 @Option(name = "-mc", metaVar = "GROUP_ID:ARTIFACT_ID:VERSION", usage = "Optional Maven coordinate for the model artifact used to enhance the Javadoc. If not set, the source coordinate is used for the model", handler = ArtifactOptionHandler.class) 
 // Features referenced in this list will not have corresponding new child creation menus. 
 // mappings, this is done for compatibility reasons with old VSMs. 
 // Specifier can reuse mappings on layers. // This section will be completely hidden in a future version. 
 // tools, this is done for compatibility reasons with old VSMs. 
 // Specifier can reuse tools on layers. // This section will be completely hidden in a future version. 
 "Comparison cannot be adapted to ICompareInput."); 
 "Cannot find a comparison from input " + input); 
 * 
 void setAtsId(ISequenceProvider sequenceProvider, IAtsObject newObject, IAtsTeamDefinition teamDef); 
 AtsCore.getUtilService().setAtsId(AtsClientService.get().getSequenceProvider(), goalArt, 
 if (!equals(control.getBackground(), newColor)) { 
 resourceMonitor.selectionChanged(part, new StructuredSelection(file)); 
 * 
 IRegisteredItem item = (IRegisteredItem) element; 
 if (definition != null && !initialDefinitionName.equals(def.definitionName)) { CustomTxtTraceDefinition.delete(initialDefinitionName); 
 if (selection instanceof IStructuredSelection && ((IStructuredSelection) selection).size() == 1) { 
 * Copyright (c) 2009, 2014 THALES GLOBAL SERVICES and others. 
 if (selection instanceof IStructuredSelection && ((IStructuredSelection) selection).size() == 1) { 
 * Copyright (c) 2009, 2014 THALES GLOBAL SERVICES and others. 
 Enumeration resources = b.getResources(name); while (resources != null && resources.hasMoreElements()) { URL url = (URL) resources.nextElement(); urlList.add(url); 
 if (isUseResourceFilteringEnabled()) { 
 if (project.isAccessible() && project.hasNature(TmfProjectNature.ID)) { 
 * Joao Martins <joaomartins27396@gmail.com> - Bug 436332 
 newChildDescriptors = domain.getNewChildDescriptors(object, null); } else if (stsel.size() > 1) { newChildDescriptors = Lists.newArrayList(); } 
<|del|> 
 * Copyright (c) 2008, 2014 Obeo. 
 * Copyright (c) 2008, 2014 Obeo. 
 allActions.add(new GroupIntoToolSectionAction(editor, selection)); allActions.add(new GroupIntoToolGroupAction(editor, selection)); allActions.add(new GroupIntoToolGroupExtensionAction(editor, selection)); 
 rootUri = defaultUri.substring(0, start) + "manifest"; 
 return tableViewerColumn; 
 try (Git git = Git.cloneRepository().setBare(true).setDirectory(dir) .setURI(uri).call()) { return readFileFromRepo(git.getRepository(), ref, path); 
 TmfTimeRange currentRange = TmfTraceManager.getInstance().getCurrentRange(); long windowStartTime = currentRange.getStartTime().normalize(0, ITmfTimestamp.NANOSECOND_SCALE).getValue(); long windowEndTime = currentRange.getEndTime().normalize(0, ITmfTimestamp.NANOSECOND_SCALE).getValue(); 
 public RepoCommand setGroups(final String groups) { 
 public boolean isValid(Collection<EObject> selection) { if (selection.size() <= 1) { return false; 
public class GroupIntoToolGroupExtensionAction extends AbstractEObjectRefactoringAction { 
 if (!(tool instanceof AbstractToolDescription)) { return false; 
<|del|> 
 public boolean isValid(Collection<EObject> selection) { if (selection.size() <= 1) { return false; 
<|del|> 
 * Interface for dialog for selecting a command script. 
 createButton(parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, true); createButton(parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, true); 
 return fCommandScriptDialog; 
 public static String TraceControl_ExecuteScriptSelectLabel; 
 public void executeCommands(IProgressMonitor monitor, List<String> commands) throws ExecutionException { 
 return new SetValueCommand(new SetRequest(partition, UMLPackage.eINSTANCE.getActivityPartition_Node(), req.getElementToConfigure())); 
 protected CreateElementRequest getCreatePartitionChildRequest(CreateElementRequest req) { if (req == null) { return null; } 
 * Contributors: * Matthew Khouzam - Initial API and implementation 
<|del|> 
 * @return The element at i, if i &gt; length, or i &lt; 0, the method 
<|del|> 
 public AbstractArrayDefinition lookupArray2(String name){ 
public class GroupIntoToolGroupCommand extends AbstractToolGroupIntoCommand { 
<|del|> 
 super(set, parent, selection); 
 public boolean canExecute() { if (selection != null && selection.size() > 1) { for (EObject tool : selection) { if (!(tool instanceof AbstractToolDescription)) { return false; } } } 
 * approval/org.eclipse.recommenders.privacy.datums.ipAddress/com.example.first=+; * approval/org.eclipse.recommenders.privacy.datums.ipAddress/com.example.second=-; 
 * Joao Martins <joaomartins27396@gmail.com> - Bug 434698 
 protected ToolSection findParentSection(Collection<EObject> selection) { Option<EObject> toolsection; 
 * Tool section in which the created item will be added. 
 protected Command createGroupIntoCommand(EditingDomain arg0, ToolSection parent, Collection<EObject> selection) { return new GroupIntoToolGroupCommand(arg0.getResourceSet(), parent, selection); 
 } 
 protected Command createGroupIntoCommand(EditingDomain arg0, ToolSection parent, Collection<EObject> selection) { return new GroupIntoToolSectionCommand(arg0.getResourceSet(), parent, selection); 
<|del|> 
 if (tool.eContainer() instanceof ToolSection) { 
 setTextIfDisable(GroupIntoToolGroupCommand.TEXT); 
 super(set, parent, selection); 
 return canExecute; 
 return canExecute; 
 super(set, parent, selection); 
 /** * check current selection. * * @return return true if selection are valid. */ 
 * @deprecated use {@link org.eclipse.linuxtools.internal.ctf.core.event.types.ArrayDeclaration} 
 * @deprecated use {@link org.eclipse.linuxtools.internal.ctf.core.event.types.SequenceDeclaration} 
<|del|> 
 super.addAdapter(notifier); 
 // we only want to display this action when we have several items 
 * Domain. 
 if (toolsection.some()) { 
 * Selected item[S] to group. 
 * Cheks current selection to determine if action can be executed. 
 canExecute = Iterables.all(selection, getSelectionFilter()); 
 * This action allow the user to group several tool (AbstractToolDescription) * into a new on ToolGroup. 
 * This String are needed to setTextIfDisable otherwise we get a * java.lang.NullPointerException due to * org.eclipse.sirius.editor.tools.api.menu.AbstractMenuBuilder$2.compare. 
 * This String are needed to setTextIfDisable otherwise we get a * java.lang.NullPointerException due to * org.eclipse.sirius.editor.tools.api.menu.AbstractMenuBuilder$2.compare. 
 } else if (popup != null) { 
 private transient @Nullable List<Definition> fDefs; 
 @NonNull List<Definition> ret = builder.build(); 
 byte[] bytes = (pos != -1) ? (Arrays.copyOf(fContent, pos)) : fContent; return new String(bytes); 
<|del|> 
<|del|> 
 String unsafeValue = fieldDef.toString(); /* * the string is a byte array and may contain more than the string * plus a null char, this will truncate it back to a null char */ 
 String fieldVal = (pos > 0) ? unsafeValue.substring(0, pos) : unsafeValue; 
 String fileName = path.lastPathComponent().getString(); 
 * Checks to see if the statement is the last one in a GNU Statement-Expression 
 private boolean isLastExpressionInStatementExpression(IASTExpression e) { // Check if it is part of GNU compound stmt expression i.e. ({int a; foo(a); a;}) 
 * Master test suite for all Linux Tools LTTng Core unit tests. 
 * Master test suite for all Linux Tools LTTng UI unit tests. 
<|del|> 
<|del|> 
 private Predicate<EObject> viewerFilterPredicate; 
 private static class DataInput extends AbstractInputData implements NotifierScopeProvider { 
 @NonNull 
 protected void handlePropertyChange(int propertyId) { 
<|del|> 
 * @since 3.1 
 /* * Make sure the String does not contain "weird" things, like ISO * control characters. */ 
<|del|> 
<|del|> 
 ITaskRepositoryPage page = wizard.getSettingsPage(); // we need this because save removes the static import of org.junit.Assert 
 ITaskRepositoryPage page = wizard.getSettingsPage(); // we need this because save removes the static import of org.junit.Assert 
 * Selected items to group. 
 * Checks current selection to determine if action can be executed. 
 * This action allows the user to group several tools (AbstractToolDescription) * into a new ToolGroup. 
 * Label of this command. 
 * This action allows the user to group several tools (AbstractToolDescription) * into a new ToolGroupExtension. 
 * This action allows the user to group several tools (ToolEntry) into a new 
 * Label of this command. 
 if (isDisposed()) SWT.error (SWT.ERROR_WIDGET_DISPOSED); 
 * Copyright (c) 2014 Obeo. 
<|del|> 
 * Copyright (c) 2012, 2014 Obeo. 
 * @since 2.2.2 
 * @since 2.2.2 
 * @since 2.2.2 
 * @since 2.2.2 
 * Copyright (c) 2014 SWTBot Committers and others 
 * @since 2.2.2 
 * @since 2.2.2 
 * @since 2.2.2 
 * Copyright (c) 2014 SWTBot Committers and others 
 * @since 2.2.2 
 * @since 2.2.2 
 * @since 2.2.2 
 * Copyright (c) 2014 SWTBot Committers and others 
 * @since 2.2.2 
 * @since 2.2.2 
 * @since 2.2.2 
 * @since 2.2.2 
 * @since 2.2.2 
 * @since 2.2.2 
 * Copyright (c) 2014 SWTBot Committers and others 
 * Copyright (c) 2014 SWTBot Committers and others 
 * Copyright (c) 2011, 2014 GitHub Inc * and other copyright owners as documented in the project's IP log. 
<|del|> 
<|del|> 
 if (contentEObject != null && contentEObject instanceof DAnalysis) { 
 if (contentEObject != null && contentEObject.eClass().equals(ViewpointPackage.Literals.DANALYSIS)) { 
<|del|> 
 * Contributors: * Cedric Dumoulin Cedric.dumoulin@lifl.fr - Initial API and implementation 
 * Contributors: * Cedric Dumoulin Cedric.dumoulin@lifl.fr - Initial API and implementation 
public class CompletionTypesChart extends AbstractChartPage { 
<|del|> 
 public static final String IMG_OBJS_OPEN_NEW_VIEW = NAME_PREFIX + "open_new.gif"; //$NON-NLS-1$ 
<|del|> 
 private IViewPart fView; 
 public void init(IViewPart view) { 
 DiffFormatter dfmt = new DiffFormatter(new SafeBufferedOutputStream(os)); dfmt.setRepository(db); dfmt.setPathFilter(PathFilter.create("folder")); dfmt.format(null, commit.getTree().getId()); dfmt.flush(); 
 boolean resultOK = result != null && result.getCompiledExpression() instanceof EObject && (result.getStatus() == null || result.getStatus().getSeverity() < IStatus.ERROR); 
 this.connector = BugzillaRestConnector.getDefault() == null 
 this.connector = BugzillaRestConnector.getDefault() == null 
 private final AbstractRepositoryConnectorUi connectorUi; 
 private final AbstractRepositoryConnectorUi connectorUi; 
<|del|> 
 if (traversal.getDiagnostic().getSeverity() >= Diagnostic.WARNING) { 
 showInHistoryLink.setText(UIText.BlameInformationControl_ShowInHistoryLink); 
 if (!visible) 
 * @author <a href="mailto:laurent.redor@obeo.fr">Laurent Redor</a> 
 result = 10; 
 if (!(binding instanceof ILabel)) { 
 fImageRegistry.put(CHECKED_IMAGE, GerritUi.getImageDescriptor(iconPath + CHECKED_IMAGE)); 
 if (state.equals(Boolean.toString(true))) { 
 } catch (ExecutionException excutionException) { StatusHandler.log(new Status(IStatus.ERROR, GerritCorePlugin.PLUGIN_ID, excutionException.getMessage(), excutionException)); 
<|del|> 
 public void setUp() { 
<|del|> 
 String lhContext = "${type:", templateKeyword = "argType", rhContext = "(vector, 0)}"; String result = exerciseAndVerify(lhContext, templateKeyword, rhContext); assertThat(result, is(TEMPLATE_KEYWORD_ID)); 
 String lhContext = "${type:", templateKeyword = "argType", rhContext = "(vector, 0)}"; String result = exerciseAndVerify(lhContext, templateKeyword, rhContext); assertThat(result, is(TEMPLATE_KEYWORD_ID)); 
<|del|> 
 if (isMacOS() && hasClassesDirWithJars()) {//$NON-NLS-1$//$NON-NLS-2$ 
 return Policy.getComparator().compare(arg0, arg1); 
public class StereotypedElementItemProviderDecorator extends ExtendedItemProviderDecorator implements IEditingDomainItemProvider, ITreeItemContentProvider, IItemLabelProvider, IItemPropertySource, IItemColorProvider, IItemFontProvider { 
 private String getStereotypedElementLabel(Element element, EList<Stereotype> appliedStereotypes) { 
 * Gets all icons from the stereotypes applied on the element. 
<|del|> 
 if (PHPFlags.isNamespace(sourceType.getFlags())) { 
 styled.append(" \u2192 " /*  */, StyledString.QUALIFIER_STYLER); //$NON-NLS-1$ 
 styled.append(" \u2192 " /*  */, StyledString.QUALIFIER_STYLER); //$NON-NLS-1$ 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 for (Object object : stereotypeItemProviderDecorators.values()) { if (object instanceof IDisposable) { ((IDisposable)object).dispose(); } } 
<|del|> 
 * @since 3.13 
 protected void setConnector(AbstractRepositoryConnector connector) { 
 branchUuids.add(Long.parseLong(uuid)); } else { console.writeln("UUID listed %s is not a valid UUID", uuid); 
 * Copyright (c) 2014 Boeing. 
 private final Map<Integer, SeriesData> fSeriesData = new HashMap<>(); 
 public @Nullable String getAttributeValue(@Nullable String name) { 
 public @Nullable Iterable<TmfXmlLocation> getLocations() { 
<|del|> 
 reinitialize(); 
 *******************************************************************************/ 
 Set<ITmfAnalysisModuleWithStateSystems> stateSystemModules = new HashSet<>(); 
 private final String fPath; private final long fIndex; 
 fPath = packet.getPcapFile().getPath(); 
<|del|> 
 private static CTFStreamInputReader getStreamInputReader(CTFTrace trace) throws CTFReaderException { 
 public abstract boolean equals(@Nullable Object obj); 
<|del|> 
 * Copyright (c) 2014 Daniel Deady and others. 
 /** * Sets the event context to a composite declaration 
 /** * Gets the context declaration 
 * Gets the event context declaration, can be a helper 
 /** * VTID key */ public static final String VTID = "_vtid"; //$NON-NLS-1$ /** * PROCNAME key */ public static final String PROCNAME = "_procname"; //$NON-NLS-1$ 
 if (!remoteBranchNameText.getText().startsWith(Constants.R_REFS)) 
 if (remoteName.equals(rc.getName())) 
 TmfUiRefreshHandler.getInstance(); // to classload/initialize it 
 * @since 3.1 
 return position.isBefore(new ContentPosition(box.getNode(), box.getStartOffset())); 
 return position.isAfterOrEquals(new ContentPosition(box.getNode(), box.getStartOffset())) && position.isBeforeOrEquals(new ContentPosition(box.getNode(), box.getEndOffset())); 
 private final Map<Integer, SeriesData> fSeriesData = new HashMap<>(); 
 private AdapterImpl adapter; 
 if (notification.getFeature() == VTablePackage.eINSTANCE 
 editingDomain.getCommandStack().execute(RemoveCommand.create(editingDomain, setting.getEObject(), setting.getEStructuralFeature(), selection.toList())); 
 clonedGit.close(); 
<|del|> 
 */ @SuppressWarnings("rawtypes") 
 private INavigatable navigatable; 
 private INavigatable navigatable; 
 static class FetchListener { 
 private final Runnable callback; 
 /** * The information related to one series on the chart */ 
 @NonNull List<Integer> quarks = Collections.singletonList(IXmlStateSystemContainer.ROOT_QUARK); 
 item.setText(1, getStatsAsString(stats, "numberOfLooseRefs")); //$NON-NLS-1$ item.setText(2, getStatsAsString(stats, "numberOfPackedRefs"));//$NON-NLS-1$ 
 // Attribute that allows a test to request not to start gdbserver even if the session is a remote one 
 MockCustomExpansionRegionCompartmentEditPart compartment = new MockCustomExpansionRegionCompartmentEditPart(decoratorView); 
 private static class MockCustomExpansionRegionCompartmentEditPart extends CustomExpansionRegionStructuredActivityNodeContentCompartmentEditPart { public MockCustomExpansionRegionCompartmentEditPart(View view) { super(view); } @Override public void createDefaultEditPolicies() { super.createDefaultEditPolicies(); } 
 enableCopyFromExeButton = createCheckButton(mainComp, ProxyLaunchMessages.copy_cpp_executable); 
 2, ProxyLaunchMessages.executable_origin, null); 
 System.err.println(ProxyLaunchMessages.uri_syntax_error); 
 * @param manPage * The man page to fetch. 
 * @param user * The name of the user to access the man page as. 
 Properties config = new Properties(); 
 * Jeff Briggs, Henry Hughes, Ryan Morse, Anithra P j * Roland Grunberg 
 * Sylvain Jouanneau (CNES) - bug 440107 
 private List<Port> getAllInheritedPorts(org.eclipse.uml2.uml.Class aClass) { ArrayList<Port> ports = new ArrayList<Port>(); 
<|del|> 
 schedule(1000L); } 
 private static class Range { 
<|del|> 
 queue.addAll(0, tmp); tmp.clear(); 
 * Create a new XML value change for label 
 * The state system container this value change belongs to * @return The new XML value change 
 * The state system container this value change belongs to * @return The new XML value change 
 * If a query is done on state system after it has been * disposed. * @since 2.0 
 if (fStateValue != null) { 
 ITmfStateValue valueXML = filter.getValue(null); 
<|del|> 
<|del|> 
 * This Class implements a condition in the view part of the XML-defined state * system. It is used, for example to specify the name/path of the state * attribute to label the items in the time-graph view. 
<|del|> 
 /** * @since 2.0 */ 
 /** * Base class for all state value. Contain default methods to handle event, * process or increment the value */ abstract class TmfXmlStateValueTypeReadOnly extends TmfXmlStateValueBase { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 subMonitor.setTaskName(NLS.bind(Messages.DeleteSupplementaryFiles_DeletionTask, element.getElementPath())); 
 assertEquals("Merge didn't return as expected: strategy:" 
 // Check replace modifications for the current node. Is required as nodes could have been replaced // externally, e.g. in ASTModificationHelper. 
 revealSemanticElement(semanticElementList); 
 reveal(elementList, getCommonViewer()); 
 overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.BOOLEAN, ContentAssistPreference.DEFAULT_ARGUMENT_DISPLAY_PARAMETERS_WITH_DEFAULT_ARGUMENT)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.BOOLEAN, ContentAssistPreference.DEFAULT_ARGUMENT_DISPLAY_ARGUMENTS)); 
 public final static String DEFAULT_ARGUMENT_DISPLAY_PARAMETERS_WITH_DEFAULT_ARGUMENT = "content_assist_default_argument_display_parameters_with_default_argument"; //$NON-NLS-1$ 
 public final static String DEFAULT_ARGUMENT_DISPLAY_PARAMETERS_WITH_DEFAULT_ARGUMENT = "content_assist_default_argument_display_parameters_with_default_argument"; //$NON-NLS-1$ 
<|del|> 
 public NestedReplaceTest() { 
 } else { LOG.info("sending Heartbeat not yet approved by the user."); 
 private String getBundleVersion(String bundleId) { 
 // ignore because it is expected that the URI doesn't represent a resource. 
 * Copyright (c) 2014 Andreas Sewe. 
 if (fFields instanceof StructDefinition) { return (StructDefinition) fFields; 
 if (fEventContext instanceof Definition) { 
 * Get the event context definition 
<|del|> 
 * FileRepositoryBuilder. 
 * @since 4.4 
 * @since 3.5 
 private static final String URI_PREFIX = "http://recommenders.eclipse.org/heartbeat"; //$NON-NLS-1$ 
 private static final String BUNDLE_VERSION = "Bundle-Version"; //$NON-NLS-1$ private static final String BUNDLE_NAME = "Bundle-Name"; //$NON-NLS-1$ 
 if (settingsService.isApproved(PRINCIPAL_ID, HEARTBEAT)) { 
 heartbeatService.sendHeartbeat(URI_PREFIX, getValueFromHeader(BUNDLE_ID, BUNDLE_NAME), getValueFromHeader(BUNDLE_ID, BUNDLE_VERSION), monitor); 
 for (Bundle b : getBundles()) { 
 Enumeration resources = b.getResources(name); while (resources != null && resources.hasMoreElements()) { URL url = (URL) resources.nextElement(); urlList.add(url); 
 if (isUseResourceFilteringEnabled()) { 
 * result of this method. 
 userId.generateUserId(); 
 // If the current element is a dangling representation, its icon // is grayed. The grayed image is computed only once for each // type of representation. if (img != null && isDanglingRepresentation(element)) { 
<|del|> 
 throws TargetDefinitionSyntaxException, TargetDefinitionResolutionException, ResolverException { return resolveContentWithExceptions(definition, IncludeSourcesMode.honor); 
<|del|> 
 * @return the merge base of two commits. If a criss-cross merge required a * synthetic merge base this commit is visible only the merger's * RevWalk and will not be in the repository. 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 throw new OseeCoreException("Can't parse User Role", ex); 
<|del|> 
<|del|> 
 if (atsNotifyEndpointImpl == null) { atsNotifyEndpointImpl = new AtsNotifyEndpointImpl(atsServer); } return atsNotifyEndpointImpl; 
<|del|> 
<|del|> 
 return "Session started: " + sessionStarted + " and Ended: " + sessionEnded; 
 private WorkspaceData(IDataPersistenceService service) { this.service = service; 
 return service.retrieve(EclipseWorkspaceObject.class, Constants.WORKSPACE_EVENTS); 
 getManagedForm().removePart(codePart); codePart.dispose(); 
 modified); 
 private final @NonNull ITmfStateSystem fSS; 
 public StateSystemEntry(@NonNull ITmfStateSystem ss) { 
 public @NonNull ITmfStateSystem getSS() { 
<|del|> 
<|del|> 
 * Matthew Khouzam - Initial API and implementation * Alexandre Montplaisir - Update to new Event Table API 
 * Patrick Tasse - Initial API and implementation * Alexandre Montplaisir - Update for TmfEventTableColumn 
 @NonNull Collection<? extends TmfEventTableColumn> getEventTableColumns(); 
 setTabName(name); // add secondary id to tab name, if the view is a clone PinCloneUtils.setPartTitle(this); 
 return future.get(ControlPreferences.getInstance().getCommandTimeout(), TimeUnit.SECONDS); 
<|del|> 
 previewTable = new TmfEventsTable(tableContainer, 0, CustomEventTableColumns.generateColumns(new CustomTxtTraceDefinition())); 
 * Create the event table 
 * This class allows a trace type to specify which columns it wants to display * in the Event Table. The "function" to populate the column for any given event * is defined in each {@link TmfEventTableColumn}. 
 * * The iteration order of the returned collection will correspond to the * initial order of these columns in the view (from left to right). * <p> * Note to implementers: * <p> 
<|del|> 
 if (singleTypeSelected) 
 for (Object selectedRow : structuredSelection.toList()) { if (selectedRow instanceof PlanElement) { PlanElement planElement = (PlanElement) selectedRow; planElement.setPlanElementAction(action); 
<|del|> 
 branchesIcon = UIIcons.BRANCHES.createImage(); 
 UIText.HistoryPage_findbar_changeto_reference); else if (menuItem == referenceItem) selectFindInItem(menuItem, PREFS_FINDIN_REFERENCE, branchesIcon, UIText.HistoryPage_findbar_changeto_all); 
<|del|> 
 * @param name the enumerator occurrence in the AST 
<|del|> 
 * @since 0.14.0 
 * @since 0.14.0 
 super("org.eclipse.tycho.nexus", "unzip-repository-plugin"); 
 static final String PROVIDER_ID = "unzipRepo-templates"; 
<|del|> 
 public void testRetrieveCollecton() throws Exception { 
 Assert.assertNotNull(snapshotRepoUnzipCache.repository.getRepositoryItemUidAttributeManager()); 
 boolean isActive = false; 
 if (Strings.isValid(footerMl)) { append(footerMl); } 
<|del|> 
 if (traceElements.isEmpty()) { 
 try { Long newVal = Long.parseLong(string); fOffsetMap.put((TmfTraceElement) element, newVal); } catch (NumberFormatException e) { /* Ignore and reload previous value */ 
<|del|> 
 return super.getText(fRefTimeMap.get(element)); 
 public void clearValidationMappings(Template template) { 
 public void assertUniqueTemplateVariable(FullVariable variable, Map<String, EList<String>> variableIdToArgMapping, Map<String, String> variableIdToKeywordMapping) { 
@RunWith(Parameterized.class) 
 private Map<URI, InputStream> prefetchedStreams = new ConcurrentHashMap<URI, InputStream>(); 
 InputStream stream = prefetchedStreams.remove(uri); if (stream != null) { return stream; 
 for (Object selectedObj : structured.toList()) { 
 PlanElement entry = (PlanElement) selectedObj; lastSelectedEntry = entry; 
<|del|> 
 return new LinkBlock((LinkAttributes) attributes); } else { return new ContentBlock("<", ">"); //$NON-NLS-1$ //$NON-NLS-2$ 
 currentBlock.write("\n"); //$NON-NLS-1$ 
 public void testBlockQuoteNestedList() { 
 assertMarkup("1. One\n2. Two\n3. Three\n\n"); 
 prefetchedStreams.put(uri, stream); 
 // update the toolbar m_visualizer.updateUI(); 
 public UUID get() { 
 return MessageFormat.format(Messages.ANONYMOUS_ID_FILE_ACCESS_ERROR_MESSAGE, type, anonymousIdFile); 
 anonymousId = new AnonymousId(); 
 heartbeatService = eclipseContext.get(IHeartbeatService.class); heartbeatDelay = getHeartbeatDelay(); 
<|del|> 
 permission.setConfigurationElement(configurationElement); 
 IModelElement[] elements = findMethods(identifier, fCurrentNamespace); if (elements == null || elements.length == 0) { elements = findMethods(identifier, null); } 
 * Red Hat Inc. - Added automatic enablement of options if they are not set 
 * Red Hat Inc. - Added automatic enablement of options if they are not set 
 edgeStyle.setCentered(CenteringStyle.BOTH); } else { edgeStyle.setCentered(CenteringStyle.SOURCE); 
 edgeStyle.setCentered(CenteringStyle.BOTH); } else { edgeStyle.setCentered(CenteringStyle.TARGET); 
 private String computeSourceForEnumerator(IASTTranslationUnit ast, IEnumerator binding) throws CoreException { 
 Long numValue = val.numericalValue(); if ( numValue != null) { return String.valueOf(numValue); 
 // Bug 285126 - add capability to show int value for enums fSource= computeSourceForEnumerator(ast, (IEnumerator)binding); 
 * Compute the source for a enumerator. If the value of the enumerator can be retrieved, the * method will return a string with the value, otherwise it will fall back showing the * enumerator constant. 
 * Compute the source for a enumerator. If the value of the enumerator can be retrieved, the * method will return a string with the value, otherwise it will fall back showing the * enumerator constant. 
 Long numValue = val.numericalValue(); if ( numValue != null) { return String.valueOf(numValue); 
 * Computes the source for a enumerator. If the value of the enumerator can be retrieved, * the method will return a string with the value, otherwise it will fall back showing * * the enumerator constant. 
 * @param binding the binding of the enumerator name 
 return numValue.toString(); 
<|del|> 
 private int count = 0; 
<|del|> 
 public void setExtensionReader(ExtensionReader extensionReader) { this.extensionReader = extensionReader; 
 if (n.getFeature() == ViewpointPackage.Literals.DVIEW__OWNED_REPRESENTATIONS) { 
 * A simple TableViewer to demonstrate usage of the {@link TableColumnLayout}. 
<|del|> 
 public void setConnector(AbstractRepositoryConnector connector) { 
 public static String ADVANCED_DIALOG_DESCRIPTION; 
<|del|> 
<|del|> 
 public boolean equals(Object obj) { boolean result; 
 public List<CDORevision> getLoadedRevisions(); 
 public List<CDORevision> getLoadedRevisions(); 
 } 
<|del|> 
 super(revisionManager); 
<|del|>
 else 
 } 
 String labelText; if (getMessage() != null && getMessage().length() > 0) { labelText = getMessage(); 
 IModelElement[] elements = findMethods(identifier, fCurrentNamespace); if (elements == null || elements.length == 0) { elements = findMethods(identifier, null); } 
 // Validate the new name to enable or not the OK button. textChanged(newName); // Select the new name 
 checkNotNull(item); count++; 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 setTitle("Enter new name"); 
 if (!StringUtil.isEmpty(getMessage())) { 
 // Validate the name to enable or not the OK button. textChanged(text.getText()); // Select the entered name 
 // Validate the name to enable or not the OK button. textChanged(text.getText()); // Select the entered name 
 singletons.add(new AtsUiResource(registry, orcsApi)); System.out.println("ATS - Application started - " + System.getProperty("OseeApplicationServer")); 
<|del|> 
 BranchConfig branchConfig = new BranchConfig( repository.getConfig(), branchName); String remoteName = branchConfig.getRemote(); 
 * @param stackSamples stack trace samples for the currently stalled event * @param numStacks the number of valid stack trace samples in the stackSamples array 
<|del|> 
 * Copyright (c) 2011, 2014 Benjamin Muskalla and others. 
<|del|> 
 private final IDataPersistenceService service; 
<|del|> 
<|del|> 
 getData(); 
<|del|> 
 if (needsPageBreak) { 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 if (monitor != null) { monitor.begin(size + infos); } 
<|del|> 
<|del|> 
 * the {@link ConnectionEditPart} that is under mouse during * reconnection 
 // The target is not the diagram itself nor a label (no reconnection on // a diagram or a label) 
<|del|> 
 * * 
 + "from the project's target platform nor by other projects in the reactor."); 
 getData().add(toAdd); 
 CompanyRatingCodeType ct1 = m_service.getCodeType(CompanyRatingCodeType.class); 
 public Object answer(InvocationOnMock invocation) throws ProcessingException { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public EditRepositoryWizard(TaskRepository repository) { this(repository, TasksUiPlugin.getConnectorUi(repository.getConnectorKind())); } 
 public AbstractRepositoryConnectorUi(AbstractRepositoryConnector connector) { 
 * Interface used to hook some behavior into the {@link ResourceSet} used by EMF Compare for the current 
 String version = getVersionString (); 
 if (getFileURLMethod != null){ URL result = (URL) getFileURLMethod.invoke(connection); return new File(result.toURI()); } 
 fBot.shell(MANAGE_CUSTOM_PARSERS_SHELL_TITLE).setFocus(); 
 fBot.shell(MANAGE_CUSTOM_PARSERS_SHELL_TITLE).setFocus(); 
 fBot.styledText().setText(XML_TRACE1); fBot.buttonWithTooltip("Feeling lucky").click(); 
 fBot.styledText().setText(XML_TRACE1); fBot.buttonWithTooltip("Feeling lucky").click(); 
 * @since 1.1 
 * @since 1.1 
 if (connectorStyle != null) { if (Routing.RECTILINEAR_LITERAL.getLiteral().equals(connectorStyle.getRouting().getLiteral())) { isEdgeRectilinearRoutingStyle = true; } 
 if (connectorStyle != null) { if (Routing.MANUAL_LITERAL.getLiteral().equals(connectorStyle.getRouting().getLiteral())) { isEdgeObliqueRoutingStyle = true; } 
 @Parameter(defaultValue = "true") private boolean copyResources; 
 * This command distributes shapes.<BR> * Performance information: This command is only time consumming on execution, * not creation. The "real" command, <code>wrappedCommand</code>, is created * during the execution. 
 * The distribution type must be one of: 
 * List of parts to distribute associated with their bounds (the * bounds of their figure). 
 * List of parts to distribute associated with their bounds (the * bounds of their figure). 
 * List of parts to distribute associated with their bounds. 
 * List of parts to distribute associated with their bounds. 
 * List of parts to distribute associated with their bounds. 
 * Defines the keystroke for this action. A keystroke is built from optional modifiers (alt, control, shift) 
 LOG.warn("Could not create keystroke '" + k + "' because it is invalid!"); 
 else if (SwtUtility.getScoutSwtKeyMap().containsKey(scoutKeystroke.getKey().toLowerCase())) { 
 return ""; 
 text += "\t" + SwtMenuUtility.formatKeystroke(getScoutMenu().getKeyStroke()); 
<|del|> 
 return Collections.emptyList(); 
 return new StandardEEResolutionHandler(new AllKnownEEsResolutionHints()); 
 private void logResolverException(ResolverException e) { logger.error("Cannot resolve target definition file:"); new MultiLineLogger(logger).error(e.getDetails(), " "); logger.error(""); } 
 public static final String POM_DEPENDENCIES_CONSIDER = "consider"; 
 private Option<Rectangle> getAbsoluteBounds(View gmfView, boolean isSource) { 
 * Export and Import wizard tests 
 private static final int PACKAGE_SIZE = 282349; 
 private static final int PACKAGE_SIZE = 282349; 
 public boolean compare(Object object, ComparisonOperator comparisonOperator) { 
 boolean compare(Object object, ComparisonOperator comparisonOperator); 
 * Copyright (c) 2007, 2014 Wind River Systems and others. 
 private final Map<IContainerDMContext,Set<IExecutionDMContext>> fFilteredThreadsByTarget = 
 public IContainerDMContext[] getTargetFilters() throws CoreException { Set<IContainerDMContext> set = fFilteredThreadsByTarget.keySet(); 
 * Copyright (c) 2011, 2014 Obeo. 
 * Copyright (c) 2011, 2014 Obeo. 
 * Copyright (c) 2011, 2014 Obeo. 
 * Copyright (c) 2011, 2014 Obeo. 
 * Copyright (c) 2011, 2014 Obeo. 
 * Copyright (c) 2011, 2014 Obeo. 
 * Copyright (c) 2011, 2014 Obeo. 
 assertFalse(differences.isEmpty()); 
 * Copyright (c) 2014 Obeo. 
<|del|> 
 final IComparisonScope scope = scopeBuilder.build(left, right, origin, monitor); 
 for (IStorage storage : traversals.getStorages()) { if (monitor.isCanceled()) { throw new OperationCanceledException(); } 
<|del|> 
 return semDec instanceof DRepresentation && new DRepresentationQuery((DRepresentation) semDec).isDanglingRepresentation(); 
 if (rep != null) { return !new DRepresentationQuery(rep).isDanglingRepresentation(); 
 if (object == null) { /* * We assume that every double state value is greater than any null * state value. */ return 1; 
 * @since 3.0 
 if (object == null) { /* * We assume that every integer state value is greater than any null * state value. */ return 1; 
 if (object == null) { /* * We assume that every long state value is greater than any null * state value. */ return 1; 
 if (object == null || object instanceof NullStateValue) { return 0; 
<|del|> 
 public static final String TOP_MARGIN_PROPERTY = "topMarginLabel"; // $NON-NLS$ 
 public static final String LEFT_MARGIN_PROPERTY = "leftMarginLabel"; // $NON-NLS$ 
<|del|> 
 * each DDiagramElement (border nodes) stores the absolute screen location 
 } catch (BuildFailureException e) { 
<|del|> 
 "Could not determine GDB version using command: " + StringUtil.join(args, " "), //$NON-NLS-1$ //$NON-NLS-2$ 
 "Error with command: " + StringUtil.join(args, " "), e));//$NON-NLS-1$ //$NON-NLS-2$ 
 // All configuration should be done in the final launch sequence 
 * Copyright (c) 2000, 2014 IBM Corporation and others. 
 * Copyright (c) 2000, 2014 IBM Corporation and others. 
 StateSystemPushPopTest.class, org.eclipse.linuxtools.statesystem.core.tests.backend.AllTests.class 
 throw new StateValueTypeException("A Double state value cannot be compared to null."); //$NON-NLS-1$ 
 return Double.compare(this.value, otherDoubleValue); 
public interface ITmfStateValue extends Comparable<ITmfStateValue> { 
 * Copyright (c) 2014 cole Polytechnique de Montral 
 * Naser Ezzati - Initial API and implementation 
 private static final ITmfStateValue baseIntValue = TmfStateValue.newValueInt(10); private static final ITmfStateValue biggerIntValue = TmfStateValue.newValueInt(20); private static final ITmfStateValue smallerIntValue = TmfStateValue.newValueInt(6); 
 public @Nullable String toString() { 
 * value. 
 public @Nullable String toString() { 
 public @Nullable String toString() { 
 * Copyright (c) 2014 cole Polytechnique de Montral 
 * Naser Ezzati - Initial API and implementation 
 * Unit tests for the {@link TmfStateValuesComparison} class 
 * Test that the {@link TmfStateValuesComparison#compare(ITmfStateValue, ITmfStateValue, ComparisonOperator)} * method compares correctly two state values based on the given comparison * operator. * 
 assertTrue(TmfStateValuesComparison.compare(nullValue, nullValue, ComparisonOperator.EQ)); 
 assertFalse(TmfStateValuesComparison.compare(baseStringValue, baseStringValue, ComparisonOperator.NE)); assertFalse(TmfStateValuesComparison.compare(nullValue, nullValue, ComparisonOperator.NE)); 
public class TmfStateValuesComparison { 
<|del|> 
 } return result; } 
 private static final String GAPS_HORIZONTALLY_LABEL = "Gaps Horizontally"; 
 BugzillaConnectorUi connectorUi = new BugzillaConnectorUi(); wizard = new EditRepositoryWizard(repository, connectorUi); 
<|del|> 
<|del|> 
 if (service.isLocalPage(content)) { result.add(content); } 
 * @since 3.2 
 fViewer.getViewer().update(traceElement, null); break; 
 if (offset != 0 && trace.getResource().exists()) { 
 return Strings.isNumeric(uuid) ? BranchManager.getBranchByUuid(Long.valueOf(uuid)) : null; 
 if (GUID.isValid(guid) && Strings.isNumeric(branchUuidStr)) { 
 public void testBrokenSymlinkAttributes() { 
 public void testSymlinkAttributes() { 
 public void testAttributeSymlink() { 
 public void testBug() { 
 public void testMultipleLinksToFolder() { 
import org.eclipse.papyrus.commands.Activator; 
<|del|> 
 Activator.getPluginId(), "/icons/ovr/symlink_ovr.png"); //$NON-NLS-1$ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 if (THU_FRY_WEEKEND_DAYS_COUNTRIES.contains(locale.getCountry())) { 
 private final Locale m_locale; 
 ISelection selection = HandlerUtil.getCurrentSelectionChecked(event); if (!(selection instanceof IStructuredSelection)) { return null; } TmfExperimentElement experiment = (TmfExperimentElement) ((IStructuredSelection) selection).getFirstElement(); 
 ISelection selection = HandlerUtil.getCurrentSelectionChecked(event); if (!(selection instanceof IStructuredSelection)) { return null; } TmfTraceElement trace = (TmfTraceElement) ((IStructuredSelection) selection).getFirstElement(); 
<|del|> 
<|del|> 
public class ResourceSelectionUtil { /* * Private constructor to block instantiation. */ 
 * Copyright (c) 2011, 2014 Obeo. 
 public Collection<IResourceSetHook> getResourceSetHooks() { 
 editor.clickContextMenu("Reset Origin"); SWTBotUtils.waitAllUiEvents(); 
 editor.clickContextMenu("Reset Origin"); SWTBotUtils.waitAllUiEvents(); 
 private static int[] getWeekendDays(Locale locale) { 
 private static final long serialVersionUID = 6232274446642339434L; 
 Status status = parentGit.status().setWorkingTreeIt(treeIt).call(); 
 * Copyright (c) 2011, 2014 THALES GLOBAL SERVICES. 
<|del|> 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Donald G. Dunne */ 
 String[] paths = classpath.split(":"); for (String path: paths){ File file = new File(path + SEPARATOR + resourceName); if (file.exists()){ return file; } 
 getSwtField().setWordWrap(booleanValue); getSwtContainer().layout(true); 
public abstract class ModelTestCase extends GitTestCase { 
 final Collection<URI> urisToLoad = ImmutableList.copyOf(transform(storages, TO_URI)); 
 * Retrieves the hooks that need to be hooked on this resource set. 
 private static Collection<IResourceSetHook> getMatchingHooks( 
 private final StorageTraversal storageTranversal; 
<|del|> 
 protected boolean isAttributeSupported(int attribute) { 
 protected boolean isReadOnlySupported() { 
 // merged by another diff (equivalence or implication). // requiresMerging must be executed before actually merging the dependencies because // findMasterEquivalence may return a different result after merging. 
 } return isSet; 
 // merged by another diff (equivalence or implication). // requiresMerging must be executed before actually merging the dependencies because // findMasterEquivalence may return a different result after merging. 
 } 
 BugzillaRestConfiguration result = new BugzillaRestConfiguration(repository.getUrl()); FieldResponse fields = getFields(monitor); 
 private Map<String, Field> fields; 
 for (StagingEntry entry : nodes) entry.setSubmodule(entry.getPath().equals(walk.getPath())); } catch (IOException e) { 
 if (headTree != null) { 
 if (headTree != null) { 
 * Test calling to {@link CDOTransaction#setBranch(CDOBranch)} twice. It causes "IllegalStateException : Already in cache". 
 * Test calling to {@link CDOTransaction#setBranch(CDOBranch)} twice. It cause "IllegalStateException : Already in cache". 
 if (__properties == null) { __properties = new EObjectContainmentEList<PropertyEntry>(PropertyEntry.class, this, UiPackage.PROPERTY_MAP__PROPERTIES); } return __properties; 
 /** Result we've found, if any. */ 
 return trackedProjects.keySet().toArray(new IProject[0]); 
 * executes {@link CenterEdgeEndModelChangeOperation} on each edges potentially 
 dialog.setInitialElementSelections(selectedResources); 
 * Test suite for time offset of traces. 
 } fResource.setPersistentProperty(TmfCommonConstants.TRACE_SUPPLEMENTARY_FOLDER, fResource.getParent().getLocationURI().getPath()); 
<|del|> 
<|del|> 
<|del|> 
 LOG.error("Error while reading permissions"); //$NON-NLS-1$ 
 public <R, E> Map<String, E> retrieveItems(IOperationMonitor monitor, String path, Function<R, E[]> attributeProvider, TypeToken typeToken) throws BugzillaRestException { 
 BugzillaRestConfiguration config = new BugzillaRestConfiguration(repository.getUrl()); config.setFields(getFields(monitor)); config.setProducts(getProducts(monitor)); return config; 
 public <R, E extends Named> Map<String, E> retrieveItems(IOperationMonitor monitor, String path, Function<R, E[]> attributeProvider, TypeToken typeToken) throws BugzillaRestException { 
<|del|> 
 public static IgnoreSubmoduleMode allModes[] = IgnoreSubmoduleMode.values(); 
 * Test that when another client creates a branch, and we call {@link CDOBranch#getBranches()} for the first time, it calls all existing branches. 
 ctfTmfEventType = new CtfTmfEventType(ied.getName(), contentTree); 
 { 
<|del|> 
 private List<String> methodList; 
 for (String methodName : methodList) { 
 for (MethodCall methodCall : previousCallHistory) { 
 for (IWorkbenchWindow testWindows : testWindows) { testWindows.close(); 
 public List<String> checkListTexts() { List<String> list = new ArrayList<String>(CHECKLIST_SIZE); 
 public List<String> checkListTexts() { List<String> list = new ArrayList<String>(CHECKLIST_SIZE); 
 for (Button checkButton : _checkList) { 
 if (insertionIndex < 0 || insertionIndex > targetList.size()) { 
 List<IFile> files = new ArrayList<IFile>(); 
 public List<String> checkListTexts() { List<String> list = new ArrayList<String>(CHECKLIST_SIZE); 
 CtfIterator iter = fMap.get(context); if (iter == null) { 
 * Assign an iterator to a context. 
 private Job heartbeatJob; private HeartbeatInterval heartbeatInterval; 
 heartbeatService = eclipseContext.get(IHeartbeatService.class); heartbeatInterval = getHeartbeatInterval(); 
 private HeartbeatInterval getHeartbeatInterval() { Preferences preferences = InstanceScope.INSTANCE.getNode(BUNDLE_ID); String delayName = preferences.get(PREF_DELAY, HOURLY.toString()); return HeartbeatInterval.valueOf(delayName); } 
 schedule(heartbeatInterval.getDelay()); 
<|del|> 
<|del|> 
<|del|> 
 HOURLY(TimeUnit.HOURS.toMillis(1)), DAILY(TimeUnit.DAYS.toMillis(1)); 
 try { PrivatePermission permission = null; if (isValidAttribute(datumId) && isValidAttribute(principalId) && isValidAttribute(purpose) && isValidAttribute(policy) && approvalType != null) { 
<|del|> 
<|del|> 
 public <R, E extends Named> Map<String, E> retrieveItems(IOperationMonitor monitor, String path, 
 throw new IllegalArgumentException("TmfXmlCondition: invalid comparison operator."); //$NON-NLS-1$ 
 if (source == null || dest == null) { 
 public List<LockState<Object, IView>> getLockStates(); 
 * Esteban Dugueperoux - initial API and implementation 
 * Bug 439337 about {@link CDOLockState lock state} prefetch following a {@link CDORevision revision} prefetch. 
 private static final int NB_CATEGORIES = 10; 
 view.getResourceSet().eAdapters().add(new EContentAdapterQueringCDOLockState()); NBRequestsCallsCounter nbRequestsCallsCounter = new NBRequestsCallsCounter(view); view.getResource(getResourcePath(RESOURCE_NAME + "?" + CDOResource.PREFETCH_PARAMETER + "=" + Boolean.TRUE)); 
 String assertMessage = "4 differents kinds of requests should have been sent, QueryRequest, QueryCancel, LoadRevisionsRequest and LockStateRequest"; 
 assertEquals("1 single query request should have been sent to cancel the single QueryRequest", Integer.valueOf(1), 
 assertEquals("1 single query request should have been sent to cancel the single QueryRequest", Integer.valueOf(1), 
 private static class NBRequestsCallsCounter implements IListener 
 private static class NBRequestsCallsCounter implements IListener 
 private static class EContentAdapterQueringCDOLockState extends EContentAdapter 
 * * Note that lock state will not be loaded automatically for CDOResource, {@link CDOResource#cdoLockState()} must be called explicitly to load it. * 
 this.scheduledJobs = new ArrayDeque<ValidateJob>(); this.delay = delay; 
 * @deprecated 
 * Copyright (c) 2014 vogella GmbH and others. 
 * Jeanderson Candido <http://jeandersonbc.github.io> - Bug 413611 * Simon Scholz <simon.scholz@vogella.com> - Bug 449022 
 * Copyright (c) 2014 Ron Peters and others. 
 * Copyright (c) 2014 vogella GmbH and others. 
 else 
 for (int i = 0; i < n; i++) 
 public List<LockState<Object, IView>> getLockStates(); 
 public synchronized List<LockState<OBJECT, CONTEXT>> getLockStates() 
 closeFile(raf); 
 * Retrieves the persistent anonymous ID. 
 private static final String ANONYMOUS_ID_FILE_NAME = "anonymousId"; //$NON-NLS-1$ 
 public void testGetAnonymousIdIsNotNull() throws IOException { AnonymousId sut = new AnonymousId(folder.newFile()); 
 AnonymousId sut = new AnonymousId(new File(writeProtectedFolder, ANONYMOUS_ID_FILE_NAME)); 
public class FieldResponse implements RestResponse<Field> { 
 return ImmutableList.copyOf(fMatchMap.get(trace)); 
 // now wait until we know that the configuration is no longer valid // Parameter of Constructor from BugzillaRestConnector // (Default see BugzillaRestConnector.CONFIGURATION_CACHE_REFRESH_AFTER_WRITE_DURATION) 
 mySync.wait(); 
<|del|> 
 private static class EContentAdapterQueringCDOLockState extends EContentAdapter 
 private synchronized void registerProxyResource2(CDOResourceImpl resource) 
 * @deprecated No longer supported. 
 * @deprecated No longer supported. 
 PackageFigure parent = getParentPackageFigure(); Rectangle headerBounds = parent == null ? null : parent.getHeader(); if (headerBounds != null && suggestedSide == PositionConstants.NORTH && !isOnHeader(suggestedLocation, headerBounds)) { 
 boolean synchronizeChildren(RefreshPlan refreshPlan); 
 private List<TimeGraphEntry> fEntryList; 
 assertThat(crvwAllowed.getMin(), is(-1)); assertThat(crvwAllowed.getMax(), is(1)); 
<|del|> 
<|del|> 
 private class PluginSearchItemsFilter extends ItemsFilter { 
 private class PluginSearchItemsFilter extends ItemsFilter { 
 private final List<TracePackageElement> fChildren; 
 private final List<TracePackageElement> fChildren; 
<|del|> 
<|del|> 
 if (connection != null) { connection.open(childMon, false); 
 subMon.setWorkRemaining(waitSteps); 
 subMon.setWorkRemaining(waitSteps); 
 if (connection != null) { 
 * dependency to Acceleo 3. This migration contribution goal is to replace each 
 * All Acceleo 3 references have been removed in Sirius Metamodels to avoid a * dependence to Acceleo 3. This migration contribution goal is to replace each * default value in VSMs by the old default value expression to avoid a change * of behavior. 
 private static final String OLD_SIZE_COMPUTATION_EXPRESSION_DEFAULT_VALUE = "[eContents()->size()/]"; 
<|del|> 
 ((EdgeStyleDescription) newObject).setSizeComputationExpression(OLD_SIZE_COMPUTATION_EXPRESSION_DEFAULT_VALUE); 
 * Allows to update the created object just after its creation (the * attribute values are not yet loaded from XML file). 
 * the new created object 
 * @return An EObject with updated values or the EObject itself if this * migration has nothing to do. 
 * @return An EObject with updated values or the EObject itself if this * migration has nothing to do. 
 // if the changeBoundsRequest is available, it is used to // retrieve the real figure size by taking in account the new // bounds (more reliable than computing the size from GMF) 
 * Copyright (c) 2014 IBM Corporation and others. 
 * org.eclipse.gmf.runtime.draw2d.ui.internal.routers.RectilinearRouter. * Warning: This Router doesn't handle all cases managed by the draw2D router, * this router is currently used by the edge centering operation. Some cases are * commented. 
 * Copyright (c) 2011, 2014 THALES GLOBAL SERVICES. 
 return newObject; 
<|del|> 
 boolean atomic = isCapabilityEnabled(CAPABILITY_ATOMIC); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Copyright (c) 2013, 2014 Ericsson 
 * Copyright (c) 2012, 2014 Ericsson 
 private volatile UUID anonymousId; 
 private UUID readOrCreateAnonymousId() { 
 return generateFreshAnonymousId(); 
<|del|> 
 return result; 
<|del|> 
<|del|> 
 createRadioButton(composite, Messages.LABEL_INFORMATION, getId(GROUP_BY_INFORMATION_BUTTON_ID), 
 public static SynchronizationAlgorithm synchronizeTraces(final File syncFile, final Collection<ITmfTrace> traces, boolean doSync) { 
 // now wait until we know that the configuration is no longer valid // Parameter of Constructor from BugzillaRestConnector // (Default see BugzillaRestConnector.CONFIGURATION_CACHE_REFRESH_AFTER_WRITE_DURATION) 
 /** @since 4.6 */ 
 /** @since 4.6 */ 
 * Copyright (c) 2008, 2014 Ericsson and others. 
 * Simon Marchi (Ericsson) - Parse thread name and store it in MIThread (Bug 378154) 
 } else if (var.equals("name")) { //$NON-NLS-1$ 
 CompositeCommand cc = new CompositeCommand(POST_CONTROL_COMMAND_LABEL); 
<|del|> 
 if (iconURI != null && !iconURI.isEmpty()) { 
 new Label(container, SWT.NONE); // Placeholder to push noteLabel to the second column. 
 String name = thread.getName(); 
 * Copyright (c) 2010, 2014 Ericsson and others. 
 * Copyright (c) 2014, Tobias Melcher <tobias.melcher@sap.com> 
 final RevWalk walk = new RevWalk(repo); 
 String workingTreeRootPath = repo.getWorkTree().toString(); 
 File projectFile = searchProjectFileUpwardsInRepo( changedFile.getParentFile(), workingTreeRootPath); if (projectFile != null) 
<|del|> 
 private File searchProjectFileUpwardsInRepo(File subFolder, String rootPath) { 
 while (currentPath.toString().startsWith(rootPath)) { 
 if (projectFile.isFile()) 
 if (monitor.isCanceled()) 
<|del|> 
 private static class BtfSourceInstanceAspect extends TmfEventFieldAspect { public BtfSourceInstanceAspect() { 
 interface BaseCriteria { 
 private static final class CustomEventFieldAspect implements ITmfEventAspect { 
 * implement an {@link ITmfEventAspect}. 
 ITmfEventAspect.BaseAspects.TIMESTAMP, new CtfChannelAspect(), new CtfCpuAspect(), ITmfEventAspect.BaseAspects.EVENT_TYPE, ITmfEventAspect.BaseAspects.CONTENTS 
 private String getAssertOutputMessageEnd(String expected, String actual) { 
 }); job.setSystem(true); job.runNow(new NullProgressMonitor()); 
 boolean containerCanBeCreatedInTarget = false; 
 if (mavenSession == null) { logger.warn("No maven session available, values in the build.properties will not be interpolated!"); 
 if (mavenProject == null) { logger.warn("No maven project found for baseDir '" + baseDir.getAbsolutePath() + "', values in the build.properties will not be interpolated!"); 
<|del|> 
 return String.format("artifact type[%s] guid[%s] on branch[%s]", getArtifactType(), getGuid(), getBranchUuid()); 
 boolean sameBranches = getBranchUuid() == node.getBranchUuid(); 
 /** * @author Roberto E. Escobar */ 
<|del|> 
 /** * @author Roberto E. Escobar */ 
 anonymousIdWidget.setCheckedPermissions(loadApproved(settingsService, datumCategorySet)); 
 * The {@link IClusterNotificationListener} provided by this interface is automatically added 
 public void testConflictingIncludeSourceLocations() throws Exception { TargetDefinition definition = definitionWith(new WithSourceLocationStub(null, TestRepositories.SOURCES, BUNDLE_WITH_SOURCES), new WithoutSourceLocationStub(null, TestRepositories.SOURCES)); 
 assertThat(content.getUnits().size(), is(3)); 
 List<TargetEnvironment> environments, ExecutionEnvironmentResolutionHints jreIUs, IProvisioningAgent agent) { ResolutionArguments arguments = new ResolutionArguments(definition, environments, jreIUs, agent); 
 try { result.setTargetDefinitionIncludeSourceMode(IncludeSourceMode.valueOf(value)); } catch (IllegalArgumentException e) { throw new BuildFailureException( "Illegal value of <targetDefinitionIncludeSource> target platform configuration parameter: " + value, e); } 
 /** * This class abstracts the communications with the identity repository, * and will be mainly used for ssh-agent. * @since 1.2 */ 
 private static final String BEGIN_TAG = "org.eclipse.tracecompass-BEGIN-TAG:"; //$NON-NLS-1$ private static final String END_TAG = "org.eclipse.tracecompass-END-TAG:"; //$NON-NLS-1$ 
 fCachedTextWidget.addControlListener(new ControlAdapter() { 
 private boolean isFullySetup; // including sftp channel and environment 
 * @return true if a valid session is available. 
 boolean hasOpenSession = fSessions.size() > 0; if (hasOpenSession) { 
 assert !connectCalled : "connect should only be called once"; //$NON-NLS-1$ 
 } catch (JSchException | RemoteConnectionException e) { 
<|del|> 
<|del|> 
 Collection<EObject> impactedEObjects = new LinkedHashSet<EObject>(); 
 Collection<EObject> impactedEObjects = new LinkedHashSet<EObject>(); 
 private ModelAccessor modelAccessor; 
<|del|> 
<|del|> 
 private boolean disabled; 
 } setForceRefresh(false); representationsToForceRefresh.clear(); 
 List<ITmfStateInterval> intervals = StateSystemUtils.queryHistoryRange(ss, quark, expectedStarts[0] * TO_NS, expectedStarts[expectedCount] * TO_NS); 
 final int[] expectedStarts = { 1, 5, 7 }; 
 final int[] expectedStarts = { 1, 3, 7, 7 }; 
 public void addSymref(String from, String to) { 
<|del|> 
 private abstract class AbstractTmfXmlStateValueTypeReadWrite extends TmfXmlStateValueTypeReadWrite { 
 if (traces.isEmpty()) { 
 if (coalescedRequest.isCompatible(request)) { // Send so it can be coalesced with the parent(s) 
<|del|> 
 /** * @throws Exception if an error occurred */ 
 /** * @throws Exception if an error occurred */ 
 /** * @throws Exception if an error occurred */ 
 /** * @throws Exception if an error occurred */ 
 private static final long DELAY = 1000; 
public class PatchSetDetailRemoteFactoryTest extends TestCase { 
<|del|> 
<|del|> 
public class PatchSetDetailRemoteFactoryTest extends GerritRemoteTest { 
public class PatchSetDetailRemoteFactoryTest extends GerritRemoteTest { 
<|del|> 
<|del|> 
 CommitResult result = commitAndPush(command, refSpec, privilegeLevel); 
 CommitResult result = commitAndPush(command, refSpec, privilegeLevel); 
<|del|> 
 private EventHeaderCompactDeclaration(ByteOrder byteOrder) { 
 private EventHeaderLargeDeclaration(ByteOrder byteOrder) { 
 throw new DiesOn(DeathType.ERROR).duedTo(ex).displaying("Error while processing of setup model") 
<|del|> 
 ITmfStateSystem ss = getStateSystem(); if (ss == null) { return NO_TID; 
 return NO_TID; 
 @SuppressWarnings("null") @NonNull Integer value = Integer.valueOf(ppidValue.unboxInt()); ppid = value; 
<|del|> 
 ITmfStateSystem ss = getStateSystem(); if (ss == null) { 
 /** * @author Megumi Telles */ 
 this.orcsApi = orcsApi; 
 * Imports the projects changed by a given commit. 
 private List<File> getFilesChangedInCommit(RevCommit commit, Repository repo) { 
 private List<File> getFilesChangedInCommit(RevCommit commit, Repository repo) { 
 private File searchEnclosingProjectInWorkDir(File subFolder, String rootPath) { 
 * Event aspects for LTTng kernel traces. * * @author Alexandre Montplaisir 
 * Return the pre-defined set of event aspects exposed by this trace. 
 return Messages.getMessage(Messages.AspectHelpText_Channel); 
 private static ByteOrder nullCheck(@Nullable ByteOrder bo) { if (bo == null) { 
 private static ByteOrder nullCheck(@Nullable ByteOrder bo) { if (bo == null) { 
 private static final EventHeaderCompactDeclaration EVENT_HEADER_BIG_ENDIAN = new EventHeaderCompactDeclaration(nullCheck(ByteOrder.BIG_ENDIAN)); 
 private static final EventHeaderCompactDeclaration EVENT_HEADER_LITTLE_ENDIAN = new EventHeaderCompactDeclaration(nullCheck(ByteOrder.LITTLE_ENDIAN)); 
 private static final EventHeaderLargeDeclaration EVENT_HEADER_BIG_ENDIAN = new EventHeaderLargeDeclaration(nullCheck(ByteOrder.BIG_ENDIAN)); 
 private static final EventHeaderLargeDeclaration EVENT_HEADER_LITTLE_ENDIAN = new EventHeaderLargeDeclaration(nullCheck(ByteOrder.LITTLE_ENDIAN)); 
<|del|> 
 if((action.getStyle() == IAction.AS_CHECK_BOX) || (action.getStyle() == IAction.AS_RADIO_BUTTON)) { action.setChecked(!action.isChecked()); } 
 return new MIThreadDMData_7_1(name == null ? "" : null, id, core == null ? null : new String[] { core }); 
 if (Iterables.isEmpty(aspects)) { 
 return Collections.EMPTY_LIST; 
 protected @Nullable List<ILinkEvent> getLinkList(long startTime, long endTime, 
 protected final ObjectId blobId; 
 public static void refreshFont(final IDiagramContainerEditPart self) { 
 if (StringUtil.isEmpty(newText)) { return getDefaultFeatureAsText(); 
<|del|> 
 /** The parent event provider */ 
 fParent = (TmfEventProvider) parent; 
 * Gets the parent event provider. 
 public SynchronizationAlgorithm synchronizeTraces() { 
 final SynchronizationAlgorithm syncAlgo = SynchronizationManager.synchronizeTraces(syncFile, Collections.<ITmfTrace> singleton(this), doSync); 
 public void testAspects() { 
 assertEquals("Cpu criterion of event 1", 1, cpuAspect.resolve(event)); assertEquals("Test criterion of event 1", "abc", testAspect.resolve(event)); 
 private static final String ASPECT_SPECIAL_EVENT = "set_aspects"; private static final String ASPECT_CPU = "cpu"; 
 private Collection<ITmfEventAspect> fAspects; 
 Collection<ITmfEventAspect> aspects = TmfTrace.BASE_ASPECTS; fAspects = aspects; 
 /* Generate the aspects for this trace if it is the aspects special event */ 
 Integer cpu = Ints.tryParse(fAspect.resolve(event)); if (cpu == null) { return TmfCpuAspect.CPU_UNAVAILABLE; } 
 /* Initialize the first default trace aspects */ builder.add(ITmfEventAspect.BaseAspects.TIMESTAMP); builder.add(ITmfEventAspect.BaseAspects.EVENT_TYPE); 
 return lifetime != -1 && ((issuedAt + lifetime) < (System.currentTimeMillis() / 1000)); 
 if (DEBUG_MONITORS && !isSuccess()) { 
 int type = chStmt.getColumnType(index); String name = chStmt.getColumnName(index); 
 protected class ImageResourceDeltaVisitor implements IResourceDeltaVisitor { 
<|del|> 
 if (events != null) { fTimeGraphWrapper.getTimeGraphViewer().setLinks(events); redraw(); } 
 * a child to add, cannot be null. 
 * @return a list of children event providers or an empty list if no * children (return value cannot be null). 
 * @param index * index of child to get. Prior calling this method the index has * to be verified so that it is within the bounds. * @return child event provider (cannot be null) 
 if (traces.isEmpty()) { 
 if (!expTraces.isEmpty()) { 
 return hf.newHasher() 
 properties.put(DebugOptions.LISTENER_SYMBOLICNAME, getPluginId()); 
 assertEquals("Cpu aspect of event 1", 1, cpuAspect.resolve(event)); assertEquals("Test aspect of event 1", "abc", testAspect.resolve(event)); 
 DBField.trackConstruction(false); 
 if (sel instanceof IStructuredSelection) { final IStructuredSelection ss = (IStructuredSelection) sel; Job job = new Job(CodanUIMessages.Job_TitleRunningAnalysis) { @Override protected IStatus run(final IProgressMonitor monitor) { 
 Assert.assertEquals("The deletion of a diagram has no effect", amountBeforeDeletion - 1, modelDiagrams.size()); // $NON-NLS-1$ 
 Assert.assertEquals("The deletion of a diagram has no effect", amountBeforeDeletion - 1, modelDiagrams.size()); // $NON-NLS-1$ 
 Assert.assertEquals("The deletion of a diagram has no effect", amountBeforeDeletion - 1, modelDiagrams.size()); // $NON-NLS-1$ 
 Assert.assertEquals("The deletion of a diagram has no effect", amountBeforeDeletion - 1, modelDiagrams.size()); // $NON-NLS-1$ 
 TransactionalEditingDomain domain = ServiceUtilsForEObject.getInstance().getTransactionalEditingDomain(getRootOfTheModel()); 
 TransactionalEditingDomain domain = ServiceUtilsForEObject.getInstance().getTransactionalEditingDomain(getRootOfTheModel()); 
 return "resources/openDiagramTest/"; //$NON-NLS-1$ 
 return "resources/openDiagramTest/"; //$NON-NLS-1$ 
<|del|> 
 protected IStatus run(IProgressMonitor monitor) { if (monitor.isCanceled() || stagingView.isDisposed()) return Status.CANCEL_STATUS; 
 * * @param indexDiff * the index diff 
 ITmfTimestamp timestamp = new TmfNanoTimestamp(event.getTimestamp().getValue() / SECONDS_TO_NS); 
 if (statement.length() == 0) { 
 public static final String FIELD_CONSTRUCTION_TRACKING = "fieldConstructionTracking"; //$NON-NLS-1$ 
<|del|> 
 int borderSize = 0; 
 if (borderedStyle.getBorderSize() != null && borderSize == 0) { 
 borderSize = style.getBorderSize().intValue(); 
 if (borderedStyle.getBorderSize() == null || borderSize == 0) { 
 if (StringUtil.isEmpty(newText)) { return getDefaultFeatureAsText(); 
 if (StringUtil.isEmpty(newText)) { return getDefaultFeatureAsText(); 
<|del|> 
 } else if (startIndex >= (fTable.getItemCount() - (eventFilter == null ? 1 : 3))) { // -1 for header row, -2 for top and bottom filter status rows 
<|del|> 
<|del|> 
 final SynchronizationAlgorithm syncAlgo = SynchronizationManager.synchronizeTraces(syncFile, Collections.<ITmfTrace> singleton(this), doSync); 
<|del|> 
 return checkNotNull(fSourceElement.getAttribute(TmfXmlStrings.ID)); 
<|del|> 
 public static <T> T checkForNull(@Nullable T obj) { 
 public static <T> T checkForNull(@Nullable T obj) { 
 * Copyright (c) 2000, 2014 IBM Corporation and others. 
 return result; 
 * Note that lock states will not be loaded automatically for CDOResource, {@link CDOResource#cdoLockState()} must be called explicitly to load it. 
 // Don't ask others CDOResourceNode either as it will create some load revisions request in addition to mode 
 // Don't ask others CDOResourceNode either as it will create some load revisions request in addition to mode 
 boolean isResourceNode = revision.isResourceNode(); InternalCDOObject object = getObject(id, !isResourceNode); 
 CDOLockState[] lockStates = getLockStates(ids); 
 private GerritClient adminClient; 
 UserCredentials credentials = GerritFixture.current().getCredentials(PrivilegeLevel.ADMIN); 
 * SWTBot test for testing callsite feature. 
 String id = this.getPluginId(); if (ACTIVATORS.containsKey(id)) { logError("Duplicate Activator ID : " + id); //$NON-NLS-1$ 
 protected Map connectionsToMoveEdgeDescriptor = new HashMap<ConnectionEditPart, MoveEdgeDescriptor>(); 
 this.viewsToChangeBoundsRequest = new HashMap<View, List<Request>>(); 
<|del|> 
<|del|> 
 * single-valued/multi-valued/settable/unsettable feature in CDO 
 performUnsetOnUnsettableSingleValued(getCDOResource()); 
 CDOTransaction transaction = openSession.openTransaction(); Resource resourceCDO = transaction.createResource(getResourcePath("resource")); 
 CDOTransaction transaction = openSession.openTransaction(); Resource resourceCDO = transaction.createResource(getResourcePath("resource")); 
 CDOTransaction transaction = openSession.openTransaction(); Resource resourceCDO = transaction.createResource(getResourcePath("resource")); 
 createClass1.eUnset(class2Ref); 
<|del|> 
 private void performUnsetOnUnsettableSingleValued(Resource resource) throws Exception 
 root.eUnset(attr); 
<|del|> 
 * test TransientStore/CDOStoreImpl.unset() with * single-valued/multi-valuated/settable/unsettable feature in CDO * and XMI mode. 
 if (differenceGroupProvider != null) { differenceGroupProvider.dispose(); } 
<|del|> 
 for (IAnalysisModule module : getAnalysisModules()) { if (module.isAutomatic()) { status.add(module.schedule()); 
 for (IAnalysisModule module : getAnalysisModules()) { if (module.isAutomatic()) { status.add(module.schedule()); 
 return getEncodedPathInfo(req.getContextPath(), req.getServletPath(), req.getRequestURI()); 
 pathInfo = pathInfo.substring(servletPath.length()); if (pathInfo.isEmpty() && !servletPath.isEmpty()) return null; 
 ServletUtils.getEncodedPathInfo("", "/s", "/s/foo/bar")); 
 ServletUtils.getEncodedPathInfo("/c", "/s", "/c/s/foo/bar///")); 
 if (pathInfo.startsWith(servletPath)) { int servletPathLength = servletPath.length(); 
 if (pathInfo.startsWith(servletPath)) { int servletPathLength = servletPath.length(); 
 return null; 
 TmfCoreTracer.traceAnalysis(getId(), trace, "setting trace for analysis"); //$NON-NLS-1$ 
 for (IAnalysisParameterProvider provider : fParameterProviders) { TmfCoreTracer.traceAnalysis(getId(), trace, "registered to parameter provider " + provider.getName()); //$NON-NLS-1$ 
 static final Set<String> REQUIRED_EVENTS = NonNullUtils.checkNotNull(ImmutableSet.<String> of( 
 final Multimap<Integer, ITmfStateInterval> map = createThreadMultimap(); 
 return new HostThread(hostId, currentTid); 
 final Adapter adapter = EcoreUtil.getExistingAdapter(rootNode, TreeNodeCrossReferencer.class); if (adapter instanceof TreeNodeCrossReferencer) { crossReferencer = (TreeNodeCrossReferencer)adapter; } else { 
 final List<TreeNode> nodes = new ArrayList<TreeNode>(settings.size()); 
 private static class TreeNodeCrossReferencer extends AbstractCompareECrossReferencerAdapter { 
 return (CompareInputAdapter)Iterators.tryFind(node.eAdapters().iterator(), instanceOf(CompareInputAdapter.class)).orNull(); 
 final Optional<Adapter> cia = Iterators.tryFind( ((TreeNode)parentNode).eAdapters().iterator(), instanceOf(CompareInputAdapter.class)); if (cia.isPresent()) { ret = cia.get(); 
 buf.append(";FILE_LOCK=NO"); 
 resolveLineTagLocations(SOURCE_NAME, MIRunControlTest.LINE_TAGS); 
 // Integer size 
<|del|> 
<|del|> 
 assertEquals(a.hashCode(), d.hashCode()); assertEquals(a.hashCode(), a.hashCode()); 
 * the {@link Encoding} can be Encoding.UTF8, Encoding.ASCII or * other 
 final ResourceSet resourceSet = new ResourceSetImpl(); 
<|del|> 
<|del|> 
 private static final Table<VirtualMachine, Long, VirtualCPU> VIRTUAL_CPU_TABLE = NonNullUtils.checkNotNull(HashBasedTable.<VirtualMachine, Long, VirtualCPU> create()); 
 } catch (InvocationTargetException e) { 
 checkNotNull(ImmutableList.of( 
 List<ITmfTreeViewerEntry> list = checkNotNull(Collections.singletonList(entry)); 
 return checkNotNull(String.valueOf(fPort)); 
 fFields = checkNotNull(builder.build()); 
 super(modelFactory, node, container, checkNotNull(Collections.EMPTY_LIST), eventField); 
 return checkNotNull(fModule.name()); 
 return checkNotNull(builder.build()); 
 fFields = checkNotNull(Collections.EMPTY_LIST); 
 return checkNotNull(protocol.getShortName().toUpperCase()); 
 return checkNotNull(builder.build()); 
 return checkNotNull(Arrays.asList(TmfTraceManager.getTraceSet(trace))); 
 sb.append(']'); 
 * structure contains more than {@code Integer.MAX_VALUE} elements, returns * {@code Integer.MAX_VALUE}. 
<|del|> 
 replayAction.setEnabled(false); 
 long liveDelay = Long.parseLong(rawInfo.getTextContent()); 
 return obj; 
<|del|> 
 private static final int BITS_PER_BYTE = Byte.SIZE; 
 private static final int BITS_PER_BYTE = Byte.SIZE; 
 StringDeclaration b = StringDeclaration.getStringDeclaration(); 
 return NonNullUtils.checkNotNull(sb.toString()); 
 throw new OseeStateException("StateManager can not be null for %s", artifact.toStringWithId()); 
 throw new OseeStateException("StateManager can not be null for %s", artifact.toStringWithId()); 
 final DebugConnection debugConnection) { 
 private class PortChangeListener implements IPreferenceChangeListener { @Override public void preferenceChange(PreferenceChangeEvent event) { if (event.getKey().equals( 
 "Cloning into '" + target.getPath() + "'...", "", "" }, result); 
 "Cloning into '" + target.getPath() + "'...", 
 command.getDirectory().getPath())); db = command.call().getRepository(); 
 private static final Pattern WILDCARD_PATTERN = checkNotNull(Pattern.compile("\\*")); //$NON-NLS-1$ 
 String jobName = checkNotNull(NLS.bind(Messages.TmfAbstractAnalysisModule_RunningAnalysis, getName())); 
 private static final IClientSession SESSION1 = Mockito.mock(IClientSession.class); private static final IClientSession SESSION2 = Mockito.mock(IClientSession.class); private static URI s_testuri1; private static URI s_testuri2; 
 // Simulate concurrency by changing the client session 
 assertCookieEquals(COOKIE1, CollectionUtility.firstElement(storedCookies)); 
 private void assertCookieEquals(HttpCookie expected, HttpCookie actual) { 
 * Copyright (c) 2012, 2013 Obeo. 
<|del|> 
<|del|> 
 final String dialogTitle = "Read-only File Encountered"; final String dialogMessage = "File ''{0}'' is read-only. Do you wish to make it writable?"; 
<|del|> 
<|del|> 
<|del|> 
 protected File createSimpleTextileMarkup() throws IOException { File markupFile = new File(tempFolder, "markup.textile"); 
 writer.println("\"INTERN-LABEL\":#intern_label"); 
 additional = additionalLoadedRevisions; 
<|del|> 
<|del|> 
 /* TODO: Use event layouts for this part also */ /* * The KVM_ENTRY event means we are entering a virtual CPU, so exiting * hypervisor mode */ 
 return getVirtualCpu(ht); 
 final String dialogTitle = "Read-only Resource Encountered"; 
 * Test that the invalid Meta-model is displayed in the error log. 
<|del|> 
 * The object to validate 
<|del|> 
 int VCPU_UNKNOWN = 0; 
 VirtualCPU getVCpuEnteringHypervisorMode(ITmfEvent event, HostThread ht); 
 VirtualCPU getVCpuExitingHypervisorMode(ITmfEvent event, HostThread ht); 
 void handleEvent(ITmfEvent event); 
 private final Long fCpuId; 
 /* Associate the machine to the hostID here, for cached access later */ fKnownMachines.put(hostId, machine); 
 /* Associate the machine to the hostID here, for cached access later */ fKnownMachines.put(hostId, machine); 
 ASTNode.resolveAnnotations(scope, annotations, currentBinding); 
 private void createMenuActions() { 
 ArrayList<Artifact> selectedArtifacts = getSelectedArtifacts(); if (selectedArtifacts.isEmpty()) { 
<|del|> 
<|del|> 
 * Get the TIDs of the threads from an analysis 
<|del|> 
 public String getName() { 
 * Copyright (c) 2013, 2014 Ericsson and others. 
 * It is only enabled for gdb > 7.3. gdb <= 7.3 generates a stopped event with two 
 * This test is just like atDoubleMethodStopAtBreakpointFunctionEntry, but avoids placing 
 * It is only enabled for gdb > 7.3. gdb <= 7.3 generates a stopped event with two 
 * Copyright (c) 2009, 2014 Ericsson and others. 
 assertEquals("main thread's name is wrong", expectedThreadName, threadData.getName()); 
<|del|> 
<|del|> 
 Method method = clazz.getMethod("run"); 
<|del|> 
 WriteAccessChecker writeAccessChecker = new WriteAccessChecker(getShell()); 
 Q7UIPlugin.log(e); 
 Shell shell = page.getActivePart().getSite().getShell(); WriteAccessChecker writeAccessChecker = new WriteAccessChecker(shell, false); 
 WriteAccessChecker writeAccessChecker = new WriteAccessChecker(dialog.getShell()); 
 Q7UIPlugin.log(e); 
 Q7UIPlugin.log(e); 
 WriteAccessChecker writeAccessChecker = new WriteAccessChecker(instance.getShell()); if (!writeAccessChecker.makeResourceWritable(references .toArray(new IQ7NamedElement[0]))) { 
 save(); 
 copy.commitWorkingCopy(true, new NullProgressMonitor()); 
 elementWc.commitWorkingCopy(true, pm); 
 suiteCopy.commitWorkingCopy(true, new NullProgressMonitor()); 
 WriteAccessChecker writeAccessChecker = new WriteAccessChecker(getShell()); 
 Shell shell = page.getWorkbenchWindow().getShell(); 
 operation.run(parent, wizard.getWindowTitle()); 
 operation.run(parent, wizard.getWindowTitle()); 
 RcpttCore.getInstance().copy(elements, map, newNames); 
 workingCopy.commitWorkingCopy(false, pm); 
 copy.commitWorkingCopy(true, new NullProgressMonitor()); 
 suiteCopy.commitWorkingCopy(true, new NullProgressMonitor()); 
 copy.commitWorkingCopy(true, new NullProgressMonitor()); 
 elementWc.commitWorkingCopy(true, pm); 
 WriteAccessChecker writeAccessChecker = new WriteAccessChecker(getShell()); 
 WriteAccessChecker writeAccessChecker = new WriteAccessChecker(getShell()); 
<|del|> 
 * Bug 429659 - check notifications when unsetting EStructuralFeature. 
 EReference refList = getModel6Package().getReferenceObject_ReferenceList(); Assert.assertFalse(refList.isUnsettable()); 
 private void performUnsetOnMultiValuedFeature(ITestModelProvider modelProvider) throws Exception 
 private void performUnsetOnUnsettableSingleValuedFeature(Resource resource) throws Exception 
 private void performUnsetOnNonUnsettableSingleValuedFeature(Resource resource) throws Exception 
<|del|> 
 if (layout.getTags().contains(tag)) { layout.getTags().remove(tag); } 
 return "PluginActionSet [desc=" + desc + ", " //$NON-NLS-1$ //$NON-NLS-2$ 
 (actionSetId != null ? ", actionSet=" + actionSetId : "") //$NON-NLS-1$ //$NON-NLS-2$ 
<|del|> 
 Collection<DialectEditor> editors = uiSession.getEditors(); if (editors.isEmpty()) { 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES. 
 if (traceElements.isEmpty()) { 
<|del|> 
<|del|> 
<|del|> 
 * 
 if (feature != null && feature.equals(ToolPackage.Literals.ABSTRACT_TOOL_DESCRIPTION__PRECONDITION)) { StringBuilder sb = new StringBuilder(); 
 toolTip = diagramTypeDescriptor.getDiagramDescriptionProvider().completeToolTipText(toolTip, eObject, feature); 
 return null; 
 return pcapEvent.getDestinationEndpoint(protocol); 
 return null; 
 return null; 
 return null; 
 ITmfStateSystem kernelSs = TmfStateSystemAnalysisModule.getStateSystemByModuleClass(trace, KernelAnalysis.class); 
 return !input.isTouch() && needLayout(input); 
 return new NotificationQuery(input).isNotationChange() && isSequenceElement(input) && needsLayout(input); 
 final int currentCPUNode = ss.getQuarkRelativeAndAdd(getNodeCPUs(ss), cpu.toString()); 
 private static final Pattern START_PATTERN = Pattern.compile(FTR_START_TAG); private static final Pattern END_PATTERN = Pattern.compile(FTR_END_TAG); 
 MHandledToolItem toolItem = MenuHelper.createToolItem(application, (CommandContributionItem) item); if (toolItem == null) { continue; 
 windowModel.setToBeRendered(false); windowModel.getContext().deactivate(); windowModel.getContext().dispose(); 
 * Runner for the unit tests of this plugin 
 * Linux kernel analyses in this plugin. 
 public static final String PLUGIN_ID = "org.eclipse.tracecompass.analysis.os.linux.ui"; //$NON-NLS-1$ 
 } // TODO Performance 
<|del|> 
 } border.layout(true, true); final Point point = detailPanel.computeSize(SWT.DEFAULT, SWT.DEFAULT); scrolledComposite.setMinHeight(point.y); 
<|del|> 
<|del|> 
 Setting setting; 
<|del|> 
<|del|> 
 for (final EObject newValue : notification.getNewEObjects()) { tableContextMapping.context.getChildContext(newValue, tableContextMapping.control, getView(tableContextMapping.control)); } 
 * it, false otherwise 
 * related GMF notation model or a workspace image set on viewpoint model * about a sequence element. 
 boolean isLayout = false; Object feature = input.getFeature(); 
 Object value = getValue(notification); 
 Object value = getValue(notification); 
<|del|> 
 * Contributors: * Obeo - initial API and implementation 
 * Test non sequence changes do not trigger sequence layout. 
<|del|> 
 protected final Multimap<String, IStatus> warnings = LinkedHashMultimap.create(); 
 private void checkLogs() { 
 protected Multimap<String, IStatus> warnings; 
<|del|> 
 private final ReentrantReadWriteLock fRWLock = new ReentrantReadWriteLock(false); 
 fBackend = backend; 
 private @Nullable ITmfStateSystemBuilder fSS = null; 
 public AbstractTmfStateProvider(ITmfTrace trace, String id) { fTrace = trace; 
 if (!fStateSystemAssigned) { 
 * {@code index < 0 || index >= size()}) 
 assertEquals(expected, actual); 
 assertEquals(expected, actual); 
 * Copyright (c) 2012, 2015 Obeo and others. 
 * Copyright (c) 2014, 2015 EclipseSource Muenchen GmbH and others. 
 * Copyright (c) 2012, 2015 Obeo and others. 
 WriteAccessChecker.setWritable(recource, true); return new ResourceAccessChange(recource, false); 
 public static final String PLUGIN_ID = "org.eclipse.e4.ui.importer.java"; //$NON-NLS-1$ 
 @Override 
 @Override 
 // set the background color setShadowBackgroudColor(graphics); 
 return Collections.emptyList(); 
 * Interlocked differences only occur in special cases: When both ends of a one-to-one feature have the * same type and are actually set to the container object in an instance model. 
 * Interlocked differences only occur in special cases: When both ends of a one-to-one feature have the * same type and are actually set to the container object in an instance model. 
 if (!info.exists() || EFS.getLocalFileSystem().isCaseSensitive() || lastName.toLowerCase().equals(lastName.toUpperCase())) { 
 private final IWorkbenchWindowConfigurer configurer; private final StatusLineManager statusLineManager; private final MApplication app; 
 eclipseContext.set(MWindow.class, windowModel); 
<|del|> 
 windowPage = (WorkbenchPage) window.getActivePage(); 
 for (IContributionItem item : items) { 
 } else { // Notice that file.getParentFile() is guaranteed to be not null since fileName == "/" // case is handled by the other branch of the 'if' statement. 
public class VSMElementNameValidConstraint extends AbstractCommonToolToAppliedOnConstraint { 
 if (content instanceof IdentifiedElement) { 
<|del|> 
<|del|> 
<|del|> 
 private static final String ERROR_NODE = "Errors (1 item)"; 
 private ImageComposer imageComposer = new ImageComposer(); 
<|del|> 
public class VSMElementNameValidConstraint extends AbstractCommonToolToAppliedOnConstraint { 
<|del|> 
 */ @Override 
 if (selectedValues.size() > 0) { 
 return Collections.unmodifiableList(currentlyResolving); 
 resolveRevisionsInBatch(triggers, true, logger, result); 
 graphics.setForegroundColor(ColorConstants.buttonLightest); 
 mock(MavenLogger.class)); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 SiriusEditor treeEditor = (CustomSiriusEditor) odesignEditor.getReference().getEditor(false); ImageComposer imageComposer = new ImageComposer(); 
 /** * Get the Label of a given object. * * @param eObject * the object to study * @return the label of the given object */ protected String getLabel(final EObject eObject) { 
 return element instanceof Resource && ((Resource) element).getURI() != null && SiriusUtil.ENVIRONMENT_URI_SCHEME.equals(((Resource) element).getURI().scheme()); 
 /** The "environment:/" uri scheme. */ 
 public static final String CHECKPOINT_ATTRIBUTE = "_checkpoint"; //$NON-NLS-1$ 
<|del|> 
 * Test representation visibility in Model Explorer view after session reload. 
 private static final String SEMANTIC_RESOURCE_NAME = "My.ecore"; 
 * Ensure that the representation still appears under its semantic resource 
 public void testRepresentationVisibilityAfterSessionReload() { 
 checkRepresentationVisibility(true); 
public class DefaultXmlStreamWriterTest { 
 public void contentEncodingNewlinesAndSpecialCharacters() { 
 * @since 2.3.1 
 * the <code>resourceURI</code>. Warning: this map is computed at each * call and can be costly. 
 public Map<URI, List<EObject>> getProxiesOf(URI resourceURI) { Map<URI, List<EObject>> result = Maps.newHashMap(); 
 List<EObject> correspondingEObjects = result.get(keyURI); if (correspondingEObjects == null) { correspondingEObjects = Lists.newArrayList(); } correspondingEObjects.add(eObject); result.put(keyURI, correspondingEObjects); 
 if (window != null && !PlatformUI.getWorkbench().isClosing()) { window.getPartService().removePartListener(fPartListener); fPartListener= null; 
 * Copyright (c) 2015 THALES GLOBAL SERVICES. 
 * Tell if the resolution of the proxy is enabled or not. 
 boolean resolveProxy = true; 
<|del|> 
<|del|> 
 Resource analysisResource = analysis.eResource(); if (analysisResource != null) { unregisterResourceInCrossReferencer(analysisResource); } 
 Resource analysisResource = analysis.eResource(); if (analysisResource != null) { unregisterResourceInCrossReferencer(analysisResource); } 
<|del|> 
 private DDiagram diagram; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 assertEquals("The diagram should be empty", 0, diagram.getOwnedDiagramElements().size()); 
 assertEquals("The diagram should be empty", 0, diagram.getOwnedDiagramElements().size()); 
 public static final String SHADOW_COLOR = "shadowColor"; //$NON-NLS-1$ 
 } // this section below should match what's in // org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.processHandledItem(ToolBarManager, // MHandledToolItem) 
public interface AirDCrossReferenceAdapter extends SiriusCrossReferenceAdapter { 
public class AirDCrossReferenceAdapterImpl extends CrossReferenceAdapter implements SiriusCrossReferenceAdapter, AirDCrossReferenceAdapter { 
 assertTrue(newInput != fileItemEditorInput); assertEquals(COMPARE_EDITOR_TITLE, newInput.getTitle()); 
 private static CompareEditorInput getComparisonEditor(CompareEditorInput editorInput, Predicate<CompareEditorInput> function) { 
 public boolean apply(CompareEditorInput existingEditorInput) { if (existingEditorInput instanceof FileItemCompareEditorInput) { return (((FileItemCompareEditorInput) existingEditorInput).getFileItemId().equals(item.getId())); 
 static Predicate<CompareEditorInput> getReviewItemSetComparePredicate(final IReviewItemSet itemSet, final String taskId) { return new Predicate<CompareEditorInput>() { 
 if (borderSize == 0) { 
 if (borderSize == 0) { 
 } // this section below should match what's in // org.eclipse.e4.ui.workbench.renderers.swt.ToolBarManagerRenderer.processHandledItem(ToolBarManager, // MHandledToolItem) 
<|del|> 
 this.display = PlatformUI.getWorkbench().getDisplay(); 
 * A rows checked or unchecked 
 * Copyright (c) 2015 Eike Stepper (Berlin, Germany) and others. 
 * Bug 458149 about {@link CDOResource#getURI()} call when the {@link CDOResource} is removed from its {@link ResourceSet}. 
 * Test {@link CDOResource#getURI()} when the resource is in a {@link ResourceSet} and also once removed from it. 
 * Test {@link XMIResource#getURI()} when the resource is in a {@link ResourceSet} and also once removed from it. 
 List<String> fBashed; List<String> fUnchanged; List<String> fSkipped; 
<|del|> 
<|del|> 
 // Read operations (returning an actual event) 
 * Copyright (c) 2015 Takari, Inc. 
 parameters = new HashMap<>(); 
 clazz = desc.getClassRealm().loadClass(mojo.getImplementation()); 
 protected void loadParameters(PluginDescriptor desc, Class<?> clazz, List<MojoParameter> parameters, IProgressMonitor monitor) throws CoreException { if(monitor.isCanceled()) return; 
/******************************************************************************* * Contributors: * This class was copied from org.apache.batik.css.engine.sac * Apache Batik project - initial API and implementation * Alain Le Guennec <Alain.LeGuennec@esterel-technologies.com> - Bug 458334 *******************************************************************************/ 
 for (StringTokenizer tok = new StringTokenizer(attr); tok.hasMoreElements();) { 
 * Lars Vogel <Lars.Vogel@gmail.com> - Bug 430468 * Alain Le Guennec <Alain.LeGuennec@esterel-technologies.com> - Bug 458334 
 @Test 
import org.eclipse.tracecompass.internal.tmf.ui.editors.ITmfEventsEditorConstants; 
 * non-null input string * @return the pre-processed input line 
 Activator.log.error("Failed to move element", e1); //$NON-NLS-1$ 
 if(path == null || path.length == 0) { 
 // only enable if tree is in focus 
 /** * @return whether the tree is in focus or not */ boolean isTreeInFocus() { 
<|del|> 
 PHPDebugCoreMessages.PHPDebugPlugin_PerformingPostStartupOperations, 
 return ArtifactQuery.getArtifactFromToken(CoreArtifactTokens.DefaultHierarchyRoot, branch); 
 return ArtifactQuery.getArtifactFromToken(CoreArtifactTokens.UniversalGroupRoot, branch); 
<|del|> 
 * @since 1.3 
 * role where the child element must be drop if eref is not null 
 * flag to know if the element have to put before the drop target 
 return getStereotypeApplication().eClass().getEStructuralFeature(property.getName().replaceAll("\\s", "")); //$NON-NLS-1$ 
 featureName = featureName.replaceAll("\\s", ""); //$NON-NLS-1$ 
/** * @param entry cast=(GtkEntry *) * @param iconPos cast=(gint) * @param stock cast=(const gchar *) */ 
import org.eclipse.sirius.tests.sample.component.Component; import org.eclipse.sirius.tests.sample.component.ComponentFactory; import org.eclipse.sirius.tests.sample.component.ComponentPackage; 
<|del|> 
<|del|> 
 // consequently we manage only the resource itself. 
 private boolean comparer(IDeclaration obj, IFieldCompareHelper comparer) { 
<|del|> 
 if (!comparer.compareField(otherDecs.get(i), localDecs.get(i)) || (!localFieldNames.get(i).equals(otherFieldNames.get(i)))) { 
 if (!comparer.compareField(otherDecs.get(i), localDecs.get(i)) || (!localFieldNames.get(i).equals(otherFieldNames.get(i)))) { 
 if (obj instanceof StructDeclaration) { 
<|del|> 
 * Check if the selected viewpoint contains * 1. the diagram model kind * 2. an ancestor of the diagram model kind * 3. a descendant of the diagram model kind * 
 default: if (ViewModelUtil.isDebugMode()) { final ReportService reportService = Activator.getDefault().getReportService(); reportService.report(new AbstractReport("Wrong number of controls!")); //$NON-NLS-1$ } 
 if (getControls().size() == 0 || getControls().values().iterator().next().isDisposed()) { 
 public static Image getCheckBoxImage(Control control, CheckBoxState state) { switch (state) { case checked: 
<|del|> 
 newValue = VSMMigrationService.getInstance().getValue(object, feature, value, version); } if (newValue != null) { super.setValue(object, feature, newValue, position); 
 protected IBreakpointDMContext insertBreakpoint( 
 private void removeBreakpoint(final IBreakpointDMContext breakpoint) throws InterruptedException, ExecutionException { Query<Void> query = new Query<Void>() { 
 private void updateBreakpoint(final IBreakpointDMContext breakpoint, final Map<String, Object> delta) throws InterruptedException, ExecutionException { Query<Void> query = new Query<Void>() { 
 OS.gtk_entry_set_icon_from_icon_name (handle, OS.GTK_ENTRY_ICON_SECONDARY, OS.GTK_NAMED_ICON_CLEAR); 
 protected final ConsoleOutputTestListener testListener = new ConsoleOutputTestListener(); 
 SiriusPlugin.getDefault().getLog().log(new Status(IStatus.WARNING, SiriusPlugin.ID, "Error while unloading an unaccessible resource:\n" + e.getMessage())); 
 final Iterator<Set<String>> viewModelPackageIterator = viewModelPackageGraph.getIerator(); 
 /** * Next candidates contains the roots and the children of the last returned set of nodes. They act as an easy lookup * for the next node to be returned by the iterator. */ private final Set<PackageTreeNode> nextCandidates; 
 cleanAndSaveJob.setJobGroup(jobGroupWorkbenchAutoSave); 
public interface ArtifactKey { 
<|del|> 
 //If no artifact has been referenced in the metadata, we publish a fake one because the code is not meant to handle this // and fails in many places. I tried to change the code where the failures were occurring but did not succeed. 
 public void setupProject(MavenSession session, MavenProject project) { //Load the XML here to fail as early as possible like it is done in EclipseFeatureProject 
 if (hasQualifier(currentVersion) && !(iu.getId().equals(capability.getAttributeValue(IU.NAME)) && IU.P2_IU_NAMESPACE .equals(capability.getAttributeValue(IU.NAMESPACE)))) 
 /** * Creates the zip for the artifact */ 
 @Parameter(property = "project.build.outputDirectory") private String artifactContentFolder; 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 throw new MojoExecutionException("Error updating " + IU.SOURCE_FILE_NAME, e); 
 return getPayloadDir().isDirectory(); 
 private File getPayloadDir() { return new File(artifactContentFolder); 
 PackageIUMojo mojo = (PackageIUMojo) lookupConfiguredMojo(project, "package-iu"); setVariableValueToObject(mojo, "artifactContentFolder", new File(basedir, "src/main/resources").getAbsolutePath()); 
 * Copyright (c) 2014, 2015 cole Polytechnique de Montral and others 
 * Genevive Bastien - Initial API and implementation * Bernd Hufmann - Ensure backwards compatibility to Linux Tools 
 File toFile = pathToFiles.append(fromFile.getName()).toFile(); if (!toFile.exists() && !fromFile.isDirectory()) { 
 File toFile = pathToFiles.append(fromFile.getName()).toFile(); if (!toFile.exists() && !fromFile.isDirectory()) { 
 * Copyright (c) 2010, 2015 Ericsson 
 Activator.getDefault().getStateLocation().removeLastSegments(1) 
 Activator.getDefault().getStateLocation().removeLastSegments(1) 
 protected static void assertConstantValue(long expected, IVariable constant) { 
 return result.toArray(new String[result.size()]); 
<|del|> 
 private static void updateRegistryAndLocalCache(boolean registeredByTooling, EPackage ePackage, Resource oldResource, ResourceSet newResourceSet) { 
 analysisMap.put(analysis.getAnalysisId(), analysis); 
 * Copyright (c) 2015 Red Hat Inc. 
 ASTParser parser = ASTParser.newParser( PHPVersion.getLatestVersion(), sourceModule); 
 subscriber.init(monitor); 
 // it does not make sense to keep "dirty" editors open - 
 public PapyrusWrappingLabel getStereotypesLabel() { 
<|del|> 
 * Returns the integer part of self. 
 * @return the integer part of self 
 * Returns self. 
 final int initialSize = list.size(); final List<Object> result = new ArrayList<Object>(initialSize + 1); 
public class ObservableMapLabelProvider extends LabelProvider implements ITableLabelProvider { 
public class DecoratingLabelProvider extends LabelProvider implements IViewerLabelProvider, IColorProvider, 
 * Eugen Neufeld - initial API and implementation * David Soto Setzke - migration to the renderer API 
 button.setImage(Activator.getImage(action)); 
 private Button[] createButtons(final Composite composite, Setting setting) { 
 private Object getLinkText(Object value) { final String linkName = adapterFactoryItemDelegator.getText(value); 
 private final Color getSystemColor(Composite parent, int color) { 
 return ctx.createFailureStatus(new Object[] { "The path '" + path + "' does not correspond to an image." }); 
 return ctx.createFailureStatus(new Object[] { "The image '" + path + "' does not exist." }); 
 * Copyright (c) 2003, 2015 IBM Corporation and others. 
<|del|>
 private final String orgVersion; 
 final public Version toOSGIVersion() { try { return new Version(toString()); } catch (IllegalArgumentException e) { return null; } 
 return this.orgVersion.compareTo(other.orgVersion); 
 return -1; } else if (this.qualifier == null && other.qualifier != null) { return 1; } else if (this.qualifier != null && other.qualifier != null) { return this.qualifier.compareTo(other.qualifier); 
 for (int x = 0; x < s.length(); ++x) { write(s.charAt(x)); 
 assertEquals("a test\n\n", markup); 
 assertEquals("a test\n\n", markup); 
 currentBlock.write(url); 
 prev = createSubGraph(prev, statement); 
 PageRef pageRef = null; boolean match = false; Iterator<Window> windowsIterator = sashWindowsManager.getSashModel().getWindows().iterator(); 
<|del|> 
 private User joeSmith; 
 joeSmith.persist(testInfo.getTestName()); 
 joeSmith.persist(testInfo.getTestName() + " - testFavoriteBranchCleanup"); assertEquals(2, joeSmith.getAttributeCount(CoreAttributeTypes.FavoriteBranch)); 
 continue; 
<|del|> 
<|del|> 
 private static final EAttribute[] attrs = {DescriptionPackage.eINSTANCE.getLayer_Icon(), 
 String extension = new Path(path).getFileExtension(); 
 private static final int VERSION = 6; 
 Integer nextPrio = ((Long) content.getField(fLayout.fieldNextPrio()).getValue()).intValue(); 
 Integer prio = ((Long) content.getField(fLayout.fieldNewPrio()).getValue()).intValue(); 
 final int prio = ((Long) event.getContent().getField(fLayout.fieldPrio()).getValue()).intValue(); 
 /* We know the prio must be an Integer */ execPrio = prioValue.unboxInt(); 
 private static final String SCHED_PI_SETPRIO = "sched_pi_setprio"; 
 new Statement(s, "set" + StringUtils.capitalize(p.getKey()), new Object[]{p.getValue()}).execute(); } catch (Exception e) { 
 * @since 3.15 
 private final String normalizedVersion; 
 public List<TmfEdge> getEdges() { 
 int execPrioQuark = ss.getQuarkAbsolute(Attributes.THREADS, threadId.toString(), Attributes.PRIO); 
 return adapterType.cast(file); 
 return adapterType.cast(iterable((ISelection) adaptableObject)); 
<|del|> 
 private static class Parser extends MetadataParser { public enum PARSER_MODE { REPO, IU 
 // TODO 353889 make ordering work - the deprecated LocalDependencyResolver doesn't order p2-installable-unit modules 
 private static final IFieldEgalityHelper BINARY_COMPARER = new IFieldEgalityHelper() { 
 private boolean testEgality(IDeclaration obj, IFieldEgalityHelper comparer) { 
 /** * This needs to be replaced with lambdas when they are available. */ private interface IFieldEgalityHelper { 
 public static TmfContentFieldAspect create(String aspectName, String helpText, String... fieldPath) { return new TmfContentFieldAspect(aspectName, helpText, fieldPath); 
 Iterator<?> iter = node.getChildren().iterator(); 
 Iterator<?> iter = node.getChildren().iterator(); 
 Iterator<?> iter = node.getChildren().iterator(); 
<|del|> 
 return getBundle().getSymbolicName(); 
 public abstract String getHookName(); 
 * Factory class for instantiating supported hooks. 
<|del|> 
 remoteConfig = rc; break; } 
 URIish pushURI) { 
 if (refSpec.matchSource(notesRef)) { 
 while (true) { int slash = 1; 
 } GerritUtil.configurePushURI(remoteConfig, new URIish(uri)); GerritUtil.configurePushRefSpec(remoteConfig, Constants.MASTER); GerritUtil.configureFetchNotes(remoteConfig); GerritUtil.setCreateChangeId(config); remoteConfig.update(config); config.save(); 
 } finally { if (httpConnection != null) { httpConnection.disconnect(); } 
 } GerritUtil.configurePushURI(remoteConfig, new URIish(uri)); GerritUtil.configurePushRefSpec(remoteConfig, Constants.MASTER); GerritUtil.configureFetchNotes(remoteConfig); GerritUtil.setCreateChangeId(config); remoteConfig.update(config); config.save(); 
 field = fFields.get(i); field.setValue(value); 
 public final static int SHOW_DEFAULT= SHOW_PARAMETERS | SHOW_OVERLAY_ICONS; 
 if (mode.equals(PARSER_MODE.REPO)) xmlReader.setContentHandler(new RepositoryDocHandler(INSTALLABLE_UNITS_ELEMENT, handler)); else xmlReader.setContentHandler(handler); 
 Parser parser = new Parser(Parser.PARSER_MODE.IU); 
 Parser parser = new Parser(Parser.PARSER_MODE.REPO); 
 assertThat(artifact.getAttributeValue("classifier"), is("binary")); assertThat(artifact.getAttributeValue("id"), is("iuWithPayloadButNoArtifactReference")); assertThat(artifact.getAttributeValue("version"), is("1.0.0")); 
 * Creates repository location. 
 public IRepositoryLocation createRepositoryLocation(final String rootUrl, @ScriptParameter(defaultValue = ScriptParameter.NULL) final String username, @ScriptParameter(defaultValue = ScriptParameter.NULL) final String password) { 
 if (username != null) location.setUsername(username); if (password != null) location.setPassword(password); 
<|del|> 
<|del|> 
 public VisualizerModel(String sessionId) { 
 protected TerminateCommandAction m_terminateAction = null; 
 public void linkLocalProject(final String directory) { 
 return checkNotNull(Collections.EMPTY_LIST); 
@SuppressWarnings("nls") @NonNullByDefault 
 public void replaceSelfQualifiers(IU iu, String version, String qualifier) { iu.setVersion(version); 
<|del|> 
<|del|> 
<|del|> 
 * the array of non-null field names * @throws IllegalArgumentException * if any one of the field names is null 
 * Alexander Kurtakov - Bug 460858 
 * Alexander Kurtakov - Bug 460858 
<|del|> 
<|del|> 
 ProcessResult result = FS.DETECTED.runHookIfPresent(getRepository(), 
 /** * @return the shell implementation */ public @NonNull LTTngToolsFileShell getShell() { 
 return null; 
 return checkNotNull(Collections.EMPTY_LIST); 
 return checkNotNull(Collections.EMPTY_LIST); 
 return checkNotNull(Collections.EMPTY_LIST); 
 public static final @NonNull LttngVersion NULL_VERSION = new LttngVersion(Version.emptyVersion.toString()); 
 public void addAll(List<String> segments) { for (String segment : segments) { add(segment); 
 for (String segment : getInput()) { 
 for (String segment : getInput()) { 
 monitorDialog.run(true, false, new ExpandDTreeItemRunnableWithProgress(session, dTreeItem, true)); 
 MessageDialog.openError(activeShell, "Error while expanding", e.getTargetException().getMessage()); 
 * Copyright (c) 2015 Obeo. 
 private final Session session; 
 private final Session session; 
 public DTreeItemUserInteraction(DTreeItem item, GlobalContext ctx) { 
 if (other == this) { return true; } if (other instanceof ITmfTimestamp) { ITmfTimestamp tmfTimestamp = (ITmfTimestamp) other; return (tmfTimestamp.getValue() == 0); } return false; 
public static final native long /*int*/ _gtk_image_new_from_icon_name (byte[] icon_name, int size); public static final long /*int*/ gtk_image_new_from_icon_name (byte[] icon_name, int size) { 
 item = new AgileItem(atsClient, (Artifact) artifact); 
 return getLineMessage(firstFail) + result.getMessage() + ": " + getFailMessage(firstFail); 
 monitor.beginTask("Tree item expanding", 1); 
 monitor.beginTask("Tree item expanding", tree.getOwnedTreeItems().size()); 
 new DTreeItemUserInteraction(child, ctx).expand(new SubProgressMonitor(monitor, 1)); } else { monitor.worked(1); 
 * Launch tree item expanding/collapsing. 
 refreshContent(false, monitor); 
 } } finally { monitor.done(); 
<|del|> 
 private ThreadPriorityAspect() { } 
 if (kernelAnalysis == null) { 
 if (ts == this) { return 0; } // throw npe if ts == null; return Long.compare(getValue(), ts.getValue()); 
abstract class GitHook<T> implements Callable<T> { 
abstract class GitHook<T> implements Callable<T> { 
 return input != null && element != null && element.equals(input.getElement()); 
 if (session instanceof DAnalysisSessionImpl) { 
 if (session instanceof DAnalysisSessionImpl) { 
 * Copyright (c) 2015 THALES GLOBAL SERVICES. 
<|del|> 
<|del|>
<|del|> 
 File fragFile = ResourcesPlugin.getWorkspace().getRoot().getProject(TEMPORARY_PROJECT_NAME).getFile(FRAGMENT_FILE_NAME).getLocation().toFile(); 
 private int choice = ISaveablePart2.DEFAULT; 
 public void detachEditor(final DialectEditor dialectEditor, boolean revertChanges) { // We need to compute the closeAllDetected() before to execute the // detachEditor since this editor will be removed from the list. 
 private int choice = ISaveablePart2.DEFAULT; 
<|del|> 
/** * Implementation of {@link EMFFormsLabelProvider}. It provides a label service that delivers the display name and * description for a domain model reference and optionally an EObject. * 
 private TransactionalEditingDomain getEditingDomain(Diagram diagram) { 
 protected int isApplicable(EStructuralFeature feature) { 
 if (VKeyattributedmrPackage.eINSTANCE.getKeyAttributeDomainModelReference_ValueDMR() == feature) { 
 public static final String PLUGIN_ID = "org.eclipse.emf.ecp.makeithappen.view.email.renderer"; //$NON-NLS-1$ 
 } monitor.worked(1); 
 * Default constructor. 
 * Default constructor. 
 * a {@link IProgressMonitor} to give progression 
 * a {@link IProgressMonitor} to give progression 
 * a {@link IProgressMonitor} to give progression 
 * a {@link IProgressMonitor} to give progression 
 * a {@link IProgressMonitor} to give progression 
 private final IResourceVariantTree sourceTree; 
<|del|> 
<|del|> 
 // try to give some useful results heuristically. 
 protected String execFormatValue(VALUE value) { return formatValueInternal(value); 
 // case where the detach triggers the reload of the modified resources // (if choice == ISaveablePart2.NO) 
 * Copyright (c) 2009, 2017 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2009, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2008, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2009, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2008 THALES GLOBAL SERVICES. 
 * Copyright (c) 2008 THALES GLOBAL SERVICES. 
 * Copyright (c) 2014 Obeo. 
 * Copyright (c) 2011 THALES GLOBAL SERVICES. 
 if (UMLPackage.Literals.VALUE_SPECIFICATION == ((EStructuralFeature) column) .getEType()) { 
 return XTEXT_VALUE_SPECIFICATION_CELL_EDITOR_IDENTIFIER; 
 if (UMLPackage.Literals.VALUE_SPECIFICATION == structuralFeature .getEType()) { 
 EObject parentSemanticElement = null; final Object contextElement = getContextElement(); if (null != contextElement && contextElement instanceof EObject) { parentSemanticElement = (EObject) contextElement; } 
 this.text.setText(labelProvider.getText(value)); 
 return NOT_A_VALUE_SPECIFICATION; 
 /** * Constructor. */ public UmlValueSpecificationJavaValidator() { super(); } 
 public static final String CONFIG_HTTP_SECTION = "http"; 
 if (enterNotifyEventFunc != null) enterNotifyEventId = OS.g_signal_add_emission_hook (enterNotifyEventSignalId, 0, enterNotifyEventFunc.getAddress (), enableWindow, 0); 
<|del|> 
 /** * @since 1.0 */ 
 * @author Christian Mansky * @since 1.0 
 private boolean longDesc; 
 private boolean longDesc; 
 } 
 * Copyright (c) 2012, 2015 THALES GLOBAL SERVICES. 
<|del|> 
 // update the map resource-EObject 
 // 1 - Check that uncontrol occurs on ConsumerProject 
<|del|> 
 // remove controlled resource if it is not in the resourceSet anymore 
 session.setSemanticResourcesNotUptodate(); 
 private Map<String, EObject> resourceToRootEObjectMap = Maps.newHashMap(); 
 * Copyright (c) 2015 EfficiOS Inc., Alexandre Montplaisir 
 private Map<String, Object> fVariables; 
public interface IIterable<T> { 
 fExpressions= new ArrayList<>(2); 
 List<Object> result= new ArrayList<>(); 
 @Override 
 entry = fEntryTable.get(key); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (fileExtensions.contains(uri.fileExtension())) { 
 * Specifies whether this IDependencySpecifier can determine dependencies of the given {@code uri}. 
 * determined an empty list is returned. 
 * determined an empty list is returned. 
 * Adds additional model dependencies for {@code start} that are specified by registered dependency * providers via the extension point {@code org.eclipse.emf.compare.ide.ui.modelDependencyProvider}. 
<|del|> 
 * 
 if (owner instanceof Component && eref == UMLPackage.eINSTANCE.getClass_NestedClassifier() && req.getElementType().getEClass() == UMLPackage.eINSTANCE.getComponent()) { 
<|del|> 
<|del|> 
<|del|> 
 // Disable the action if the selection is not valid 
 // Disable the action if the selection is not valid 
<|del|> 
 // Disable the action if the selection is not valid 
 // Disable the action if the selection is not valid 
 JFaceAspectsActivator.log(e); 
 MASTER, BRANCH); 
 String msg = BuildModelMessages.getFormattedString("BuildDescription.MissingArtifact", new String[] {fProject.getName(), fCfg.getName()}); //$NON-NLS-1$ 
<|del|> 
 public IPath getAbsolutePath() { if (db.isBare()) { return null; } 
 * @since 4.0 
 @Override 
 @Override 
 @Override 
 return new Path(db.getWorkTree().getAbsolutePath() + File.separatorChar + path); 
 * returns the enclosed expression. Otherwise, returns null. 
public abstract class CASTBaseDeclSpecifier extends ASTNode implements ICASTDeclSpecifier, IASTAmbiguityParent { 
public class CASTSimpleDeclSpecifier extends CASTBaseDeclSpecifier implements ICASTSimpleDeclSpecifier { 
public abstract class CPPASTBaseDeclSpecifier extends ASTAttributeOwner implements ICPPASTDeclSpecifier, IASTAmbiguityParent { 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 // Get corresponding table elements for (EObject notifier : notifiers) { Collection<Setting> inverseReferences = xref.getInverseReferences(notifier, false); tableElementsToRefresh.addAll(getDTableElementsFromInverseReferences(inverseReferences, table)); } return tableElementsToRefresh; 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2009, 2015 THALES GLOBAL SERVICES and others. 
 // Do nothing by default, not all dialects have incremental refresh // capability. 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 super(domain, "Refresh impacted representation elements"); 
<|del|> 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 monitor.beginTask("Refresh impacted representation elements", 1); 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES and others. 
 if (displayValue.contains(STEREOTYPE)) { 
 /** * A list of p2 repositories to be used as baseline. Those are typically the most recent * released versions of your project. */ 
 if (version.compareTo(baselineVersion) < 0) { 
 * Copyright (c) 2005, 2015 IBM Corporation and others. 
 View canonicalNotationElement = CSSDOMSemanticElementHelper.getInstance().findPrimaryView(notationElement); 
 protected EList<Stereotype> stereotypeList; 
 int eventType = notification.getEventType(); 
 if (!stereotypeList.isEmpty()) { 
 if (!stereotypeList.isEmpty()) { for (Stereotype stereotype : stereotypeList) { 
 public Image stereotypeIconToDisplay() { Image icon = null; 
 EObject appliedStereotypes = null; 
<|del|> 
 helper = CSSDOMUMLSemanticElementHelper.getInstance(); 
 extends GraphicalEditPart { 
 if (!stereotypeList.isEmpty()) { 
 if (!stereotypeList.isEmpty()) { 
 if (!stereotypeList.isEmpty()) { for (Stereotype stereotype : stereotypeList) { 
/** * This class manages one or more PersistentParameter, PersistentListParameter, * PersistentMapParameter objects, using a common name-space and optionally an * instance id so that multiple instances can each have their own version of * the parameter persisted */ 
 protected String getStoreKey() { 
 protected boolean isTypeSupported(Class<T> clazz) { 
 return (m_value == null)? m_defaultValue : m_value; 
<|del|> 
<|del|> 
 convertedList.add(convertToT(val)); 
 * Copyright (c) 2014, 2015 Ericsson AB and others. 
 m_integerParam = m_persistentSettingsManager1.getNewParameter(Integer.class, "Integer Parameter", false, DEFAULT_INTEGER); // List<T> 
 m_persistentSettingsManager1.getNewParameter(Float.class, "Float Parameter", false, 1.0f); 
 PersistentListParameter<Float> persistentFloatList = m_persistentSettingsManager1.getNewListParameter(Float.class, "List of Float Parameter", false, new ArrayList<Float>()); 
 return getRandomInt() % 2 == 0; 
<|del|> 
 resolvedResources = null; 
 if (target.getContext() != null && target.getContext().get(MPerspective.class) != null && target.getContext().get(MPerspective.class).getContext() == perspective.getContext()) { 
 public boolean isFloatingLabel(EObject notationElement) { 
 * Copyright (c) 2010 THALES GLOBAL SERVICES. 
 analysis.eAdapters().add(this); 
 Resource eResource = ((EObject) value).eResource(); if (eResource != null) { resourceToRootEObjectMap.put(eResource.getURI().toString(), (EObject) value); 
 remoteLaunchConfigService.setActiveConnection(activeConfig, activeLaunchTarget); 
<|del|> 
 private static final String ANY = ""; 
 IRemoteLaunchConfigService getRemoteLaunchConfigService() { return mock(IRemoteLaunchConfigService.class); 
 super(estimatedSize, limit); 
 protected TemporaryBuffer(final int estimatedSize, final int limit) { 
 public Heap(final int estimatedSize, final int limit) { 
 return input != null && input.getElement().equals(element); 
 * The element for which we need a graph Node. This element must not be null. 
 * reload it.</li> * </ul> * If the clazz has not been found, then the method "notFound" is called. 
<|del|> 
 return ImmutableList.copyOf(this.imports); 
 this.imports.clear(); this.couldNotBeLoaded.clear(); 
 public void updateScope(Collection<String> value) { 
 if (value != null) { for (final String odesignPath : value) { 
<|del|> 
<|del|> 
 found = queryEnvironment.getEPackageProvider().getType(targetTypeName.getClassifierName()); 
 @Deprecated Collection<String> getTargetTypes(); 
 VariableType getTargetType(); 
 private final String typeName; 
 * instances if needed. 
 * An interface for {@link IInterpreter} implementations which are able to 
 * An interface for {@link IInterpreter} implementations which are able to 
 * Performs a static analysis of an expression and return the result. 
 public static final VariableType ANY_EOBJECT = fromString(TypeName.EOBJECT_TYPENAME.getCompleteName()); 
 public TypeName getCommonType(Collection<EPackage> availableEPackages) { 
 EClassifier currentElementType = typeName.searchFirst(context.getAvailableEPackages()); 
 * @return A collection of all determined dependencies. At least includes the given {@code uri} itself, * consequently the collection is never {@code null}. Also the collection does not contain any * {@code null} entries. 
 addAll(uris, Iterables.filter(dependencies, notNull())); 
 lock.lock(); try { for (URI currentUri : uriCollection) { 
 lock.lock(); try { for (URI currentUri : uriCollection) { 
 assertNotNull("This test method is here since if I don't have it surefire complains there are no tests"); 
 assertNotNull("This test method is here since if I don't have it surefire complains there are no tests"); 
public abstract class AsciidocLanguageTestBase { 
 * Max Rydahl Andersen - copied from markdown to get base for asciidoc 
 * @author Max Rydahl Andersen - based/copied from markdown to adopt for asciidoc 
 * Max Rydahl Andersen - copied from markdown to get base for asciidoc 
 * @generated NOT 
 * @generated NOT 
 availableVariables.put(IInterpreterSiriusVariables.SOURCE_PRE, sourceTypes); availableVariables.put(IInterpreterSiriusVariables.SOURCE, sourceTypes); 
 public Collection<IInterpreterStatus> validateExpression(IInterpreterContext context, String expression) { 
 if (!equalsNullable(fFields, other.fFields)) { return false; 
 * Copyright (c) 2015 Boeing. 
 * Saves the given color settings to file. 
 * An array of color settings to save. 
<|del|> 
<|del|> 
 * * @author Stefan Seelman 
 public void placeholder() { 
 String value = BugzillaRestGsonUtil.convertString2GSonString(taskAttribute.getValue()); 
 * Test the TMF remote core plug-in activator 
 // Sets plug-in instance 
 installEditPolicy(AppliedStereotypeLabelDisplayEditPolicy.STEREOTYPE_LABEL_POLICY, new AppliedStereotypeNodeLabelDisplayEditPolicy()); 
 * Celine janssens (ALL4TEC) celine.janssens@all4tec.net - Initial API and implementation 
 if (!stereotypeList.isEmpty()) { for (Stereotype stereotype : stereotypeList) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private void log(int statusCode, String key, ResourceMapping[] emfMappings) { 
 private void log(int statusCode, String message, Collection<IResource> iResources) { 
 if (isValidShell(shell)) { shell.setAlpha(0); } 
<|del|> 
 wc.setAttribute(JSchConnection.IS_PASSWORD_ATTR, Boolean.TRUE.toString()); 
 * @see java.io.File#getAbsolutePath() 
<|del|> 
 EventHeaderScope(ILexicalScope parent, String name) { 
<|del|> 
 assertEquals(1, treeProvider.getRoots().size()); assertTrue(treeProvider.getRoots().contains(iProject)); 
 break; case DirCacheEntry.STAGE_0: // Skipped on purpose (no conflict) 
 * side of a delta 
 * copied from the private implementation in SyncInfoToDiffConverter 
 * copied from the private implementation in SyncInfoToDiffConverter 
 TreeWalk treeWalk) throws IOException { 
 if (resource != null && resource.getProject().isAccessible()) { 
<|del|> 
 boolean canDelete = appendSemanticElementsToDestroy(currentDiagramElement, elementsToDestroy); return canDelete ? elementsToDestroy : null; 
 * Get all semantic elements. 
 * and recursively from those of their contents. If the new container is already * set and also has the cross referencer, in this case cross referencer is not * removed. <BR> 
 * Get the bounds of a cell (SWT.Rectangle) for the specified row and column * index in a table 
 * @return the bounds in display relative coordinates 
 * SWTBot test for testing highlighting 
<|del|> 
 final Rectangle cellBounds = SWTBotUtils.getCellBounds(fTableBot.widget, ROW, MESSAGE_COLUMN); 
 final Rectangle cellBounds = SWTBotUtils.getCellBounds(fTableBot.widget, ROW, MESSAGE_COLUMN); 
 // enter regex in message column fTableBot.click(0, MESSAGE_COLUMN); 
 assertTrue(colorBefore.containsKey(fBackground)); assertTrue(colorBefore.containsKey(fForeground)); 
 assertTrue(colorBefore.containsKey(fBackground)); assertTrue(colorBefore.containsKey(fForeground)); 
<|del|> 
 final Rectangle cellBounds = SWTBotUtils.getCellBounds(fTableBot.widget, ROW, TIMESTAMP_COLUMN); 
 // toggle filter mode 
 fTableBot.click(0, 0); 
 * an {@link IllegalArgumentException} if the point is outside of * the image bounds 
 throw new IllegalArgumentException("Point outside of the image"); 
 * <code>pixel = rect.width * y + x;</code> 
 * the area to grab in display relative coordinates (top left is * the origin) 
 public static ImageHelper grabImage(final Rectangle rect) { 
 try { // note: awt is explicitly called until we can use SWT to // replace it. 
 * an {@link IllegalArgumentException} if the image does not match * the bounds 
 colors.add(pixelColor); 
 * @return an {@link ImageHelper} that is the per pixel difference between the two images * 
 * <br>Note that this is a <em>HINT</em>. It is currently ignored on all platforms. 
 if (!repo.getConfig().getBoolean("http", "sslVerify", true)) { //$NON-NLS-1$ //$NON-NLS-2$ 
 * dirk.fauth@googlemail.com - Bug 446095 * neufeld.eugen@googlemail.com - Bug 455747 
 if (partService.isPartOrPlaceholderInPerspective(part.getElementId(), modelService.getActivePerspective(window))) 
<|del|> 
 return getLockStates(viewID, ids, CDOLockState.DEPTH_NONE); 
 return getLockStates(viewID, ids, CDOLockState.DEPTH_NONE); 
 if (tb != null && !tb.isDisposed()) { 
 try (Git git = new Git(repo)) { git.commit().setAuthor("JUnit", "junit@jgit.org") 
 if (resource == null || resource.getProject() == null || !resource.getProject().isAccessible()) { 
 TreeWalk tw = new TreeWalk(repo); 
 TreeWalk tw = new TreeWalk(repo); 
 TreeWalk tw = new TreeWalk(repo); 
 TreeWalk tw = new TreeWalk(repo); 
 TreeWalk treeWalk = new NameConflictTreeWalk(repo); treeWalk.addTree(baseTree); treeWalk.addTree(sourceTree); treeWalk.addTree(remoteTree); 
<|del|> 
 * input from a {@link GitResourceVariantTreeProvider}. 
 * directory as well as it could be a branch. 
 * * @author Stefan Seelmann 
 //If there is no content, close the block: 
 * AsciiDoc setext underlined headings. 
<|del|> 
 return "(&[A-Za-z]{1,32}+;)"; //$NON-NLS-1$ 
<|del|> 
 void setHidden(boolean hidden); 
 private Boolean isHidden; 
 if (tool.isHidden != null) { isHidden = tool.isHidden; 
 isHidden = Boolean.valueOf(hidden); 
 public void setHidden(boolean hidden) { if (isHidden == null || !(hidden == isHidden.booleanValue())) { isHidden = hidden; 
 * A callback which is being notified if the classpath of some project did 
 if (!StringUtil.isEmpty(typeName)) { 
<|del|> 
 for (DDiagramElement dDiagramElement : new DDiagramQuery(dSemanticDiagram).getAllDiagramElements()) { 
 int y = 0; 
 // Create and return a new connection return connectionFactory.createConnection(hostUri, hostName); 
<|del|> 
 CTFClock clock = fTrace.getClock(); 
 // Set the label figure invisible by default // It will be visible when the NameEditPart will be added shapeFigure.getLabelFigure().setVisible(false); return shapeFigure; } 
 TreeWalk treeWalk, int baseIndex, int ourIndex, int theirIndex) throws IOException { 
 String hidden = element.getAttribute(ITool.IS_HIDDEN); 
 if (diagramElement != null) { shapeFigure.getLabelFigure().setVisible(!(new DDiagramElementQuery(diagramElement).isLabelHidden())); 
 // Compute label visibility if (eObj instanceof DDiagramElement && new DDiagramElementQuery((DDiagramElement) eObj).isLabelHidden()) { shapeFigure.getLabelFigure().setVisible(false); } else { shapeFigure.getLabelFigure().setVisible(true); } 
 } else if (element instanceof DDiagramElementContainer) { // DNodeContainer & DNodeList 
@RunWith(SWTBotJunit4ClassRunner.class) 
<|del|> 
 for (Table table : tableMap.values()) { if (!table.isDisposed()) { table.removeAll(); 
 for (Entry<TmfPcapProtocol, Table> protocolEntry : tables.entrySet()) { TmfPcapProtocol protocol = protocolEntry.getKey(); if (protocol == null) { 
 TmfPacketStreamBuilder builder = analysis.getBuilder(protocol); Table table = protocolEntry.getValue(); if (builder != null && !(table.isDisposed())) { 
 /** * Base class for all selection tests, using the indexer or not. */ 
 private static final String SHAPE_CONSTANT = "shape";//$NON-NLS-1$ 
 if (icon.getLocation() != null && !icon.getLocation().isEmpty()) { 
 icon = null; 
 super(domain, LABEL_COMMAND); 
 public static final String STEREOTYPE_PROPERTY_LOCATION = "stereotypePropertyLocation";//$NON-NLS-1$ 
<|del|> 
 return NotationUtils.getStringValue((View) diagramElement, StereotypeDisplayUtils.STEREOTYPE_PROPERTY_LOCATION, DEFAULT_LOCATION); 
<|del|> 
<|del|> 
<|del|> 
 ArtifactData artifactData = objectFactory.createArtifactData(version, (int) uuid, token, modType, guidToSet); 
 changeSiriusUIPreference(SiriusUIPreferencesKeys.PREF_SAVE_WHEN_NO_EDITOR.name(), false); changeSiriusUIPreference(SiriusUIPreferencesKeys.PREF_RELOAD_ON_LAST_EDITOR_CLOSE.name(), false); 
<|del|> 
 } else if (start) { 
 assertEquals("", html); 
 assertEquals("<p><strong>foo bar</strong></p>\n", html); 
 assertEquals("<p>_foo bar_</p>\n", html); 
 if (diagramElement == null) { return; 
 helper.setPersistency(getDomain(), nodeToDisplay); helper.setVisibility(getDomain(), nodeToDisplay, false); // Then update the Compartment Visibility Accordingly updateCompartmentVisibility(compartment); } 
 final IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot(); // FIXME if the storage is located outside of the workspace, getFileForLocation will return null, and // this call will thus result in NPE. How could we work around that limitation? 
 return fileExtensions.contains(uri.fileExtension()); 
 * @return The set of dependencies of {@code uri}. If {@code uri} has no dependency, the returned set is * empty. 
 final URI baseUri = createURIFor(file); final Set<IStorage> traversalSet = new LinkedHashSet<IStorage>(); for (URI uri : getUriAndDependentUrisFromDependencyProvider(baseUri)) { final IFile toResolve = getFileAt(uri); 
 * Copyright (c) 2004, 2015 IBM Corporation and others. 
 // try to apply runtime defaults in case the node is created programmatically inside initializer 
 * Copyright (c) 2004, 2015 IBM Corporation and others. 
 revertBackColor = XYGraphMediaFactory.getInstance().getColor(255 - backRGB.red, 255 - backRGB.green, 255 - backRGB.blue); 
 final LinkedHashSet<URI> dependencies = Sets.newLinkedHashSet(); dependencies.add(file1Uri); dependencies.add(file2Uri); return dependencies; 
 assertEquals("After a EPackage creation containing contents we should have 6 DLines selected", 6, selectionCount); 
 dynamicZoomMode = false; 
 start = me.getLocation(); 
 * Copyright (c) 2015 Obeo. 
 private final class CDOStoreEcoreEMap extends EcoreEMap<Object, Object> implements InternalCDOLoadable 
 private static final String RETRIEVE_EANNOTATION_ERROR = "Failed to retrieve Profile Defintion root annotation."; //$NON-NLS-1$ 
 /** * {@inheritDoc} * 
 public ReferenceValueFactory getValueFactory(final String propertyPath) { ReferenceValueFactory valueFactory = null; 
 } 
 public ProfileDefinitionObservableValue(final Profile profile, final List<?> wrappedList, final EditingDomain domain, final EObject source, final EStructuralFeature feature) { 
 /** * {@inheritDoc} * 
 return addCommand; 
 private final Profile profileToDefine; 
 public ProfileDefinitionValueFactory(final Profile profile, final EReference referenceIn) { 
 /** * {@inheritDoc} * 
 protected Object doCreateObject(final Control widget, final Object context) { 
 /** * {@inheritDoc} * 
 * the root profile 
<|del|> 
 private final boolean saveConstraintDefinition; 
 assertTrue("This baseline should appear to be from a target definition", ApiModelFactory.isDerivedFromTarget(baseline)); //$NON-NLS-1$ 
<|del|> 
 if (service != null) { resolvingError = false; 
 ApiPlugin.logErrorMessage("Signatures#matches: Unhandled signature kind: " + el1); //$NON-NLS-1$ 
<|del|> 
<|del|> 
 return Messages.SignalToReceptionDropStrategy_Label; 
 return Messages.SignalToReceptionDropStrategy_Description; 
 ((Collection<Object>)targetElement.eGet(esfOwned)).add(myTodo); 
<|del|> 
<|del|> 
<|del|>
 private static final IDirectEditorPreferencesManager INSTANCE = new DirectEditorPreferencesManager(); 
 private static final IDirectEditorPreferencesManager INSTANCE = new DirectEditorPreferencesManager(); 
 */ @Override 
 */ @Override 
<|del|> 
 for (final Entry<IAbstractDirectEditor, String> entry : modificationEntriesSet) { 
 for (final Entry<IDirectEditorExtensionPoint, Integer> modificationEntry : modificationEntriesSet) { 
 if (null != editor) { 
 if (null == editor) { 
 if (null == directEditor) { 
 if (null != extensionConstraint) { 
 IConstrainedEditor directEditorConstraint = getConstrainedDirectEditor(directEditor, extensionConstraint); 
 if (null != directEditor) { 
 IConstrainedEditor editorConstraint = getConstrainedDirectEditor(directEditor, constraint); 
 if (null != modificationValue) { 
 if (null == directEditor) { 
 if (null == editor) { 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
 public void controlResized(ControlEvent e) { // Dani: Do you really need a full redraw? If so, it should definitely be restricted to the case where word wrap is enabled. 
 if (null != extensionPoint.getAdditionalConstraint()) { IConstrainedEditor constraint = factory.createConstrainedEditor(); 
 private boolean fIsWordWrapActivated; 
 Iterator<DirectEditor> keySet = modifiedDefaultEditor.keySet().iterator(); 
 // temporarily deactivate word wrap (if activated) if (styledText.getWordWrap()) { styledText.setWordWrap(false); if (fVerticalRuler != null) { fVerticalRuler.update(); } 
 * Copyright (c) 2015 Holger Voormann and others. 
 boolean isWordWrapActivated(); 
 while (null == directEditor && directEditorsIterator.hasNext()) { 
<|del|> 
<|del|> 
 if (null == directEditor) { 
 if (null != directEditor && null != directEditor.getDefaultEditor()) { 
 if (null != language || !IDirectEditorsIds.SIMPLE_DIRECT_EDITOR.equals(language)) { 
 * Create Compartment View according to a specific Location. 
/** * This Class regroups the Commands and their execution for the Stereotype Display * 
 public static final String STEREOTYPE_LABEL_ALIGNMENT = "stereotypeAlignment";//$NON-NLS-1$ 
 * The Class AppliedStereotypeHelper. * Helper used in the User interaction to display Stereotypes from the Property View. * Note: this class is to be used instead of <i>AppliedStereotypeHelper</i> which is deprecated) 
/** * This class regroups all the constant required for the Migration of the Stereotype Display User Preferences. * 
 * Property location Key 
 return getOSRecommendedFolder(); 
 // shouldn't be called, but err on the side of caution return true; 
<|del|> 
 testProject.close(); 
 * Patrik Suzzi <psuzzi@gmail.com> - Bug 464464 
<|del|> 
public abstract class TraverseTabHandler extends AbstractHandler { private final boolean isPrevious; 
 throws CTFException { 
 ICTFPacketInformation packetIndex = parsePacketContext(dataOffsetbits, size, bitBuffer); 
 BitBuffer bitBuffer) throws CTFException { 
 void setCurrentPacket(ICTFPacketInformation currentPacket) throws CTFException { 
 throws CTFException { 
<|del|> 
<|del|> 
<|del|> 
 Activator.log.error(e); 
 ByteBuffer bb = ByteBuffer.allocate(PREVALIDATION_SIZE); bb.clear(); 
 } bb.position(0); 
 return new JSchProcessBuilder(getRemoteConnection()).start(flags); 
<|del|> 
 fStderrReader = new Thread(new ProcReader(fChannel.getExtInputStream(), pipedOutput)); 
 this(connection, "shell"); //$NON-NLS-1$ 
 try { if (cmdArgs.size() == 1 && cmdArgs.get(0).equals("shell")) { //$NON-NLS-1$ 
 try { if (cmdArgs.size() == 1 && cmdArgs.get(0).equals("shell")) { //$NON-NLS-1$ 
<|del|> 
 fPacketIndex = fStreamInput.getIndex().search(timestamp) - 1; 
 /** * This will read the entire trace and populate all the indexes. The reader * will then be reset to the first event in the trace. * * Do not call in the fast path. * 
 assertThat(comments.size(), is(2)); IComment lastComment = comments.get(1); 
 assertThat(comments.size(), is(2)); IComment lastComment = comments.get(1); 
 * @author Stefan Dirix <sdirix@eclipsesource.com> * @since 2.4 
 assertTrue(compareTextContent(originalFile, saveFile)); 
 assertEquals("The '" + regionContainerMapping.getName() + "' should displays its children in vertical stack", ContainerLayout.VERTICAL_STACK, regionContainerMapping.getChildrenPresentation()); 
 * button to set the font underlined. 
 * button to set the font struck through. 
 * button to set the font underlined. 
 * button to set the font struck trough. 
 if (index == -1) { newParent.getChildren().add(element); } else { newParent.getChildren().add(index, element); } 
 return list.get(list.size() - 1); 
 void setUnselectedHotTabsColorBackground(Color color); 
 private String removeCRCharacters(String text) { return text.replaceAll("\\r", ""); 
 * Copyright (c) 2015 THALES GLOBAL SERVICES. 
 private static final Version MIGRATION_VERSION = new Version("10.0.0.20150513"); 
 * Copyright (c) 2015 THALES GLOBAL SERVICES. 
 * Copyright (C) 2015, Richard Veach <rveach02@gmail.com> 
 // change fetch destination if standard final String oldFetchDestination = Constants.R_REMOTES + oldName 
 final List<RefSpec> refSpecs = newRemote.getFetchRefSpecs(); 
 for (RefSpec fetch : refSpecs) { if (fetch.matchDestination(oldFetchDestination)) { 
<|del|>
 private static boolean shouldReactToChildVisibilityChanges(MUIElement theElement) { 
 // Clamp the minimum initial size of the shell to be at least enough to click on the scroll // bars and see some initial content size= Geometry.max(size, new Point(128, 64)); 
 // If bash is in $PATH, git should also be in $PATH. 
 // If bash is in $PATH, git should also be in $PATH. 
<|del|> 
<|del|> 
<|del|> 
 private static final List<String> TEST_STRING = generateTestVector(40000, 6); 
 LinkedList<String> actual = new LinkedList<>(); Iterators.addAll(actual, fStringQueue.iterator()); containsSameElements(expected, actual); 
 Iterators.addAll(actual, fStringQueue.iterator()); containsSameElements(expected, actual); 
 Iterators.addAll(actual, fStringQueue.iterator()); containsSameElements(expected, actual); 
 private static <T> void containsSameElements(Collection<T> c1, Collection<T> c2) { assertEquals(HashMultiset.create(c1), HashMultiset.create(c2)); 
 private final static class SpellcheckableMessageAreaExtension 
 assertEquals("", html); 
 public void strongSourrounded() { String html = parseToHtml("before *foo bar* after"); assertEquals("<p>before <strong>foo bar</strong> after</p>\n", html); } 
 } 
 // closing the window during resize events. 
 size = fContextSelectorShell.computeSize(SWT.DEFAULT, SWT.DEFAULT, true); 
 handleRootAdded(resource, (EObject) next); 
 if (options.lockStatePrefetcher != null) { options.lockStatePrefetcher.dispose(); options.lockStatePrefetcher = null; } 
 if (!parent.isVisible()) 
 collectTargetElements(rootStatus, new HashSet(), allStatuses); 
 collectTargetElements(rootStatus, new HashSet(), allDiagnostics); 
<|del|> 
<|del|> 
 * Alexandre Montplaisir - Initial API and implementation * Sebastien Lorrain - Initial API and implementation 
 * traces, for versions of lttng-modules 2.7 and above. 
<|del|> 
 return SWTResourceManager.getColor(255,193,37); // Goldenrod 
 return OriginTracer.LTTNG27; 
 return OriginTracer.LTTNG27; 
 return OriginTracer.LTTNG27; 
 private volatile boolean writerIsPresent; 
 int headerHeight = tree.getHeaderHeight(); if (headerHeight > 0) { fTimeGraphViewer.setHeaderHeight(headerHeight); tree.removePaintListener(this); } 
 if (fHeight != height) { fHeight = height; 
<|del|> 
<|del|> 
 } else { 
 throw new RuntimeException("An adapter to have save fails."); 
 assertFalse(dirtyFiles.get(1).isDirty()); verify(listener).openTaskDeactivationDialog( Matchers.argThat(new CompareListOfReferencesWithoutOrder(makeDirtyReferencesFromParts(dirtyFiles)))); 
 IEditorPart dirtyFile = activateTaskAndOnlyEditOneFile(); List<IEditorPart> dirtyParts = new ArrayList<IEditorPart>(); dirtyParts.add(dirtyFile); 
 * Copyright (c) 2015 Obeo. 
 * Copyright (c) 2015 Obeo. 
 return !new Path(MISSINGPATH + ".java").equals(new Path(String.valueOf(unitResult.getFileName()))); 
 logListener= new ILogListener() { 
<|del|> 
 if (typeBinding.isPrimitive()) 
 public static final Version MIGRATION_VERSION = new Version("10.0.0.201504221300"); 
 this.isRootANewProject = projectAlreadyExistsInWorkspace(this.rootDirectory) == null; 
 private String DefaultDescription; 
 private String DefaultDescription; 
 + editors, MessageDialog.QUESTION, new String[] { "Deactivate Task and Save All", "Deactivate and Save Some...", IDialogConstants.CANCEL_LABEL }, 1).open(); 
 public static List<IConsole> findConsole(IRemoteConnection connection) { 
 public static List<IConsole> findConsole(IRemoteConnection connection) { 
<|del|> 
 if (statusCode != HttpURLConnection.HTTP_BAD_REQUEST && statusCode != HttpURLConnection.HTTP_OK) { 
 if (statusCode != HttpURLConnection.HTTP_BAD_REQUEST && statusCode != HttpURLConnection.HTTP_OK) { 
<|del|> 
 value = System.getProperty(key); 
 private void assertNextIterations(TestNavigatable navigatable, TestContext context, int startingElement) { TreeItem previousSelection = context.getItem(startingElement); 
 * Michael Borkowski - bug 462237, refactoring 
 TreeItem firstSelectedItem = firstOrNull(selection); 
 if (item != null) { return item; } return getFirstItemInTree(); 
 /** * Returns the previous sibling of the given TreeItem. * * @param item * the item to get the sibling for * @return the sibling */ 
 * Copyright (c) 2013, 2015 Obeo and others. 
<|del|> 
 builder.link(new LinkAttributes(), href, text); 
 if (group(7) != null) { // without ++ 
 builder.link(new LinkAttributes(), href, text); 
 builder.link(new LinkAttributes(), href, href); 
 // TODO Auto-generated method stub 
 return getLastDescendant(getPreviousSibling(start)); 
 return checkNotNull(b.toString()); 
<|del|> 
 assertTrue("Should have non-zero templates", templates.getTemplate().size() != 0); 
/** * Test unit for {@link WordUpdateData} * 
 * @author Jeff C. Phillips * @author David W. Miller 
 * @author Roberto E. Escobar * @author David W. Miller 
 /* * This code pulls out all of the stuff after the inserted listnum reordering stuff. This needs to * be here so that we remove unwanted template information from single editing */ 
 IAtsActionableItem.class); if (ai == null) { throw new OseeCoreException("Safety Actionable Item not configured"); } 
 IAtsTeamDefinition.class); if (teamDef == null) { throw new OseeCoreException("Safety Team Definition not configured"); } 
 IAtsTeamDefinition.class); if (teamDef == null) { throw new OseeCoreException("Safety Team Definition not configured"); } 
 logger.error(ex, "WordUpdateData Safety Action creation"); 
 try (RevWalk rw = new RevWalk(db); 
 try (ObjectInserter oi = db.newObjectInserter()) { 
 try (RevWalk rw = new RevWalk(db); BufferedReader br = new BufferedReader( 
 try (ObjectReader curs = clp.getRepository().newObjectReader()) { 
 try (ObjectReader or = db.newObjectReader()) { 
 try (PackWriter pw = new PackWriter(eden)) { 
 try (PackWriter pw = new PackWriter(src)) { 
 try (ObjectInserter inserter = repo.newObjectInserter()) { 
 inserter.flush(); } 
 modifiedDefaultEditor.put(defaultEditor, extensionPoint.getLanguage()); 
 public String getPreferenceLanguage(final String instanceClassName) { 
 String userAgentProvided = getProperty("p2.userAgent", null); //$NON-NLS-1$ 
 private static final String OTHER_PROJECT_IN_WS = "SiriusLibrary"; 
 protected int compareQualifier(RepositoryVersion other) { 
 * @since 3.11 
 protected int compareMajor(RepositoryVersion other) { 
 private static final String RSE_SSH_READY_PING = "RSE_SSH_READY_PING"; //$NON-NLS-1$ 
 final Object lock = new Object(); IHostShellOutputListener echoListener = new IHostShellOutputListener() { 
 synchronized (lock) { // we are done waiting; received_handshake[0] = true; lock.notifyAll(); break; 
<|del|> 
 * Teodor Madan (Freescale) - [467833] Wait shell initialization 
<|del|> 
 synchronized (lock) { 
 * Teodor Madan (Freescale) - [467833] Fix leaking shell writer thread 
 volatile boolean refreshJobScheduled; 
 * Copyright (c) 2012, 2015 Obeo and others. 
 XViewer xViewer = getXViewer(); if (obj instanceof Artifact && xViewer instanceof WorldXViewer) { WorldXViewer worldXViewer = (WorldXViewer) xViewer; 
<|del|> 
 if (eObject instanceof org.eclipse.uml2.uml.Class) { 
 if (slotCreationCommand != null && slotCreationCommand.canUndo()) { slotCreationCommand.undo(progressMonitor, info); } return CommandResult.newOKCommandResult(); 
 * Create a new GzipFile for the given file. 
 * the passed Gzip file. 
 * Get the name (relative path to the {@code remote}) of this sub repo. 
 public List<CopyFile> getCopyFiles() { 
 * Get for name (relative path to the {@code remote}) of this sub repo. 
 * Get the url of the sub repo. 
 public void addCopyFiles(Collection<CopyFile> copyfiles) { 
<|del|> 
 * the other index 
 /** Thrown by {@code create()} when file is too large. */ 
 reviewHarness.getClient().saveDraft(Patch.Key.parse(id), "base comment", 1, (short) 0, null, null, new NullProgressMonitor()); 
 * Copyright (c) 2005, 2015 SAP AG. 
 * fvelasco - Bug 396247 - ImageDescriptor changes * jsivadier - Bug 467502 - Improve DiagramComposite implementation without IWorkbenchPart 
<|del|> 
 } 
 // The Eclipse help system appends and extra "/" to the beginning of 
 return subTopics.toArray(new ITopic[0]); 
 return bytes; 
<|del|> 
 long getCountOfLoadedCommits() { 
 nextRepo = CommonUtils.getAdapter(((PlatformObject) o), Repository.class); 
 IHandlerService hsr = CommonUtils.getService(activeWorkbenchWindow, IHandlerService.class); 
<|del|> 
 private static final String RSE_SHELL_READY_PING = "RSE_SHELL_READY_PING"; //$NON-NLS-1$ 
 int ttywait = getReadyPingMsec(); 
 protected int getReadyPingMsec() { 
 final Object data = getItemData(items[0]); 
 final Object data = getItemData(items[0]); 
 return Integer.parseInt(rl.getString(id).trim()); 
 Integer.parseInt(SiriusEditorPlugin.INSTANCE.getString(key).trim()); 
<|del|> 
 boolean supports(ILaunchDescriptor descriptor, IRemoteConnection target) throws CoreException; 
 assertNull(service); 
 assertNotNull("Service not found.", service != null); 
 readMin = Math.min(readLeft, readRight); 
 public boolean doReadyPing(String pingCmd, final String expectedResponse, int msecPerPing, int maxPing) { 
<|del|> 
// RAP [if]: WeakHashMap need to be synchronized when it's accessed from different threads to avoid 
// [if] RAP: WeakHashMap need to be synchronized when it's accessed from different threads to avoid 
 fFile = "metadata"; //$NON-NLS-1$ // we're in CTF, the only thing using antlr is metadata 
 fFile = "metadata"; //$NON-NLS-1$ // we're in CTF, the only thing using antlr is metadata 
 fFile = "metadata"; //$NON-NLS-1$ // we're in CTF, the only thing using antlr is metadata 
 if (entry != fEntry) { throw new IllegalArgumentException(); 
 // refresh root to avoid shadow artifact if (AppearanceHelper.showShadow((View) getModel()) && getRoot() != null) { getRoot().refresh(); } 
 private void handleRapTargetInstallation() { 
<|del|> 
 if (fileEntry.isDirectory() && !fileEntry.getName().equals(".settings")) { 
<|del|> 
 public boolean accept(final Object element) { boolean result = false; 
 result = ((TreeFillingConfiguration) ((IAxis) object).getElement()).getLabelProvider(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private String getLabelProviderContextForTreeFillingConfiguration(final Table table, final Object listenObject) { String result = ""; //$NON-NLS-1$ 
 * @since 4.1 
 * @since 4.1 
 // This uri will be used later on to determine whether the storage has already been loaded or not. // Use the unmodified URI instead of the normalized one here. stream = super.createInputStream(uri, options); 
 // The user provided classes are not nested within a class so there is no 
<|del|> 
 public Statistics getStatistics() { 
 // Draws our own background to avoid overwriting the bar. 
<|del|> 
 * Akif Etkue - Initial API and implementation 
 WorkspaceFile fileObject1 = (WorkspaceFile) o1; WorkspaceFile fileObject2 = (WorkspaceFile) o2; Long size1 = Long.valueOf(fileObject1.getSize()); long size2 = fileObject2.getSize(); return size1.compareTo(size2); 
 String proxyHostConfigured = getProxyHost(proxyTestUri).isPresent() ? "proxyHost" : "noProxyHost"; //$NON-NLS-1$ //$NON-NLS-2$ 
 public int compare(WorkspaceContentType o1, WorkspaceContentType o2) { Integer count1 = Integer.valueOf(o1.getCount()); Integer count2 = Integer.valueOf(o2.getCount()); return Integer.compare(count2, count1); 
<|del|> 
<|del|> 
 Integer count1 = Integer.valueOf(o2.getCount()); Integer count2 = Integer.valueOf(o1.getCount()); return count1.compareTo(count2); 
 if (items.length > 0) { 
<|del|> 
 * {@link PackWriter.ObjectCountCallback}. 
 * That can be thrown inside * {@link PackWriter.ObjectCountCallback#setObjectCount(long)}. 
 * That can be thrown inside * {@link PackWriter.ObjectCountCallback#setObjectCount(long)}. 
 public WriteAbortedException(String s) { 
 public WriteAbortedException(String s, Throwable why) { 
 * Set the {@link ObjectCountCallback}. 
 * This callback will be passed on to * {@link PackWriter#setObjectCountCallback}. 
 * @param objectCount * the count of the objects. * @throws WriteAbortedException * to indicate that the write operation should be aborted. 
 void setObjectCount(long objectCount) throws WriteAbortedException; 
 // Otherwise, get percentage and draw bar and text if applicable. 
 * Copyright (c) 2015 Ericsson 
 * Copyright (c) 2015 Ericsson 
 * Copyright (c) 2015 Ericsson 
 public static final IRelationTypeSide ProgramToInsertion_Program = TokenFactory.createRelationTypeSide(RelationSide.SIDE_A, 0x7BD0963A0F884A2BL, "Program To Insertion"); 
 doRequestString("/ats/program/" + getSawTeam() + "/insertion", HttpMethod.GET, null, 
 "/ats/program/" + getSawProgram().getUuid() + "/insertion/" + Integer.toString(-5) + "/feature", 
 doRequestString("/ats/program/" + getSawProgram().getUuid() + "/insertion/" + getSawTeam() + "/feature", 
 private Long getSawTeam() { return org.eclipse.osee.ats.client.demo.DemoArtifactToken.SAW_Requirements.getUuid(); 
 String url = "/ats/program/" + getSawProgram().getUuid() + "/insertion"; 
 String url = "/ats/program/" + getSawProgram().getUuid() + "/insertion"; 
 String url = "/ats/program/" + getSawProgram().getUuid() + "/insertion"; 
 String urlInsertion = "/ats/program/" + getSawProgram().getUuid() + "/insertion"; String urlFeature = "/ats/program/" + getSawProgram().getUuid() + "/insertion/1234567800/feature"; 
 String url = "/ats/program/" + getSawProgram().getUuid() + "/insertion/1234567800/feature"; 
 String url = "/ats/program/" + getSawProgram().getUuid() + "/insertion/1234567800/feature"; 
<|del|> 
<|del|> 
 changes.setSoleAttributeValue(atsServer.getConfig().getSoleByUuid(updatedInsertion.getUuid()), CoreAttributeTypes.Name, updatedInsertion.getName()); 
 changes.setSoleAttributeValue(atsServer.getConfig().getSoleByUuid(updatedInsertion.getUuid()), CoreAttributeTypes.Name, updatedInsertion.getName()); 
 private void deleteConfigObject(long uuid, String comment, IArtifactType type) { 
 return "Insertion Feature"; 
 public Response getProgramInsertions(@PathParam("uuid") long uuid) throws Exception { ArtifactReadable programArt = atsServer.getArtifactByUuid(uuid); if (programArt == null) { throw new OseeCoreException("Given uuid not found"); } 
 public Response getProgramInsertions(@PathParam("uuid") long uuid) throws Exception { ArtifactReadable programArt = atsServer.getArtifactByUuid(uuid); if (programArt == null) { throw new OseeCoreException("Given uuid not found"); } 
 ArtifactReadable programArt = atsServer.getArtifactByUuid(programUuid); if (programArt == null) { throw new OseeCoreException("Given uuid not found"); } 
 ArtifactReadable insertionArt = atsServer.getArtifactByUuid(insertion.getUuid()); if (insertionArt == null) { throw new OseeCoreException("Given insertion uuid not found"); } 
 ArtifactReadable configArt = atsServer.getArtifactByUuid(uuid); if (configArt == null) { throw new OseeCoreException("Given uuid not found"); } return Response.ok().entity(atsServer.getConfigItemFactory().getInsertion(configArt)).build(); 
 ArtifactReadable insertion = atsServer.getArtifactByUuid(insertionUuid); if (insertion == null) { throw new OseeCoreException("Given insertion uuid not found"); } atsServer.getConfigItemFactory().deleteInsertion(insertion); return Response.ok().build(); 
 response = Response.ok().entity(updated).build(); 
 while (systemPrintableMessage.length() > 100) { 
 System.out.print(systemPrintableMessage); 
 private static final String DECORATION_MESSAGE = "The Profile Definition is outdated since last modifications"; //$NON-NLS-1$ 
 * elements of {@code nameQualifiers}. {@code nameQualifiers} cannot contain decltype specifiers * for creation of {@link ICPPASTDecltypeSpecifier}. 
<|del|> 
 newFunc = factory.newFunctionTryBlock(newDeclSpec, newFuncDecl, factory.newCompoundStatement()); 
<|del|> 
 * Akif Etkue - Initial API and implementation 
<|del|> 
 IPath rootLocation = job.getRootProject().getLocation(); IPath projectLocation = project.getLocation(); return projectLocation.makeRelativeTo(rootLocation).toString(); 
 * Test method for {@link org.eclipse.egerrit.core.command.ListCommentsCommand#ListCommentsCommand()} 
 * Test method for {@link org.eclipse.egerrit.core.command.ListCommentsCommand#formatRequest()} 
<|del|> 
 /** * @return String */ 
 /** * @param sl * @param sc * @param el * @param ec */ 
 /** * Constructor with some data already available * * @param FileInfo * fileInfo */ 
<|del|> 
<|del|> 
 public void testGetPreferredMergeStrategyWhenModelEnabledAndValidPreference() { 
 * Copyright (C) 2011, 2015 Mathias Kinzler <mathias.kinzler@sap.com> and others 
 * Detects inline images and single line block images: * * <pre> 
 Pattern keyValuePattern = Pattern.compile("(.*)=\"(.*)\""); //$NON-NLS-1$ 
 properties.put(positionalParameters.remove(0), pair.trim()); 
 attributes.setAlt(properties.get("alt")); //$NON-NLS-1$ 
 public void inlineImageNoTextWithSizes() { 
 public AsciiDocPreProcessor() { 
 static final private Pattern ATTRIBUTE_PATTERN = Pattern.compile("^:(.*?):(.*)"); //$NON-NLS-1$ 
 return "^(//.*)"; //$NON-NLS-1$ 
<|del|> 
 new DeveloperActivityDialog(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(), persistenceService).open(); 
 } return displayLabel + " Project"; 
 private static final Logger LOG = LoggerFactory.getLogger(WorkspaceProjectData.class); public static List<WorkspaceProjectType> readAllProjects() { 
 private static String getNatureId(IProject project) throws CoreException { 
 final Label projectNumberLabel = new Label(parent, SWT.NONE); final Label projectSizeLabel = new Label(parent, SWT.NONE); 
 if (null != commentNode) { 
 while (empty && childrenIterator.hasNext()) { 
 if (null != comment) { 
 return (view.getElement() instanceof Element && !((Element) view.getElement()).getAppliedStereotypes().isEmpty()); 
 * @since 1.1 
 job = new StatisticsUpdateJob(Messages.TmfStatisticsView_TmfStatisticsUpdateName, aTrace, isGlobal, statsMod, this); //$NON-NLS-1$ 
 * Alexis Cabana-Loriaux <alex021994@gmail.com> - Extracted the model out of StatisticsViewer 
 resource.load(str, Collections.emptyMap()); 
 // Test state of differences before command 
 private boolean received; 
<|del|> 
 /** 
 return this.isSystemLibrary; 
 hashCode = hashCode * 17 + this.entries[i].hashCode(); 
 for (String key : attributes.keySet()) { library.put(ATTRIBUTE_PREFIX + key, attributes.get(key)); } 
 canUndo = false; 
 private static CSSStyleDeclaration getStyleDeclaration(Object themeEngine, Display display) 
 shellStyle = getStyleDeclaration(themeEngine, input); if (shellStyle != null) { 
 final String message = String .format("The EditorInput (%s) is not compatible with the TreeEditor", //$NON-NLS-1$ input.getClass().getName()); throw new IllegalArgumentException(message); 
 final ResourceSetEditorInput editorInput = new ResourceSetEditorInput( resourceSet); return openEditor(editorInput); 
 IProject project = mockIProject(new String[] { JAVA_ID }); 
<|del|> 
RGB acquireCurrentColorSelectionGtk2(GdkColor color, long colorsel) { 
RGB acquireCurrentColorSelectionGtk3(long handle, GdkRGBA rgba) { 
long addEmissionHook(long handle, Display display, int signalId) { 
int lookupSignalId() { 
long /*int*/ setCurrentColorGtk2(GdkColor color, long handle) { 
 Set<ICElementHandle> result = new LinkedHashSet<>(); 
 /** * A specialization of BasicEList<EStructuralFeature.Setting> which speed up the * addition in the list by using a index to quickly determine if addUnique() can * be used. * * @author cedric * */ 
 * Copyright (c) 2012, 2015 THALES GLOBAL SERVICES 
 result = result && facetManager.getSuperValueOf(feature, source, 
 * Dispose the data structure and release any system resources associated * with it. 
 return new RGB (red, green, blue); 
 List<String> customDashForTestList = new ArrayList<String>(3); customDashForTestList.add(Integer.toString(customDashForTest[0])); customDashForTestList.add(Integer.toString(customDashForTest[1])); customDashForTestList.add(Integer.toString(customDashForTest[2])); 
 List<String> customDashForTestList = new ArrayList<String>(3); customDashForTestList.add(Integer.toString(customDashForTest[0])); customDashForTestList.add(Integer.toString(customDashForTest[1])); customDashForTestList.add(Integer.toString(customDashForTest[2])); 
 refreshCommand.executeWithChecks(new ExecutionEvent()); 
 protected void testRoundedCompartmentEditPart(final EditPart createdEditPart) { 
 @Ignore("Can't get the setted attribute on compartment figure to test it.") 
 refreshCommand.executeWithChecks(new ExecutionEvent()); 
 if (DocumentUtils.containsUseStatement(part, total)) { 
<|del|> 
 context.getFile().getName(), Messages.format(UNUSED_MESSAGE, part.getNamespace().getFullyQualifiedName()), OrganizeProblemIdentifier.USE_STATEMENTS, new String[0], 
 List<String> positional = new ArrayList<>(); 
 imageblockattr.setCssClass("image"); //$NON-NLS-1$ 
 Map<String, String> properties = new HashMap<>(); 
 String[] valpairs = rawFormat.split(","); //$NON-NLS-1$ 
 attributes.setAlt(properties.get("alt")); //$NON-NLS-1$ 
 Matcher attributesRef = ATTRIBUTE_TOKEN_PATTERN.matcher(line); 
 if (altText.startsWith("#")) { //$NON-NLS-1$ 
 String html = parser.parseToHtml("a [[#Some link?|link text]] reference to an internal anchor"); 
 * CEA LIST - Initial API and implementation * 
 while (value == null && iterator.hasNext()) { 
 while (allCompSameValue == true && iterator.hasNext()) { 
 View view = NotationHelper.findView(sourceElement); CustomStyleModelElementEx customStyleModelElement = null; 
<|del|> 
 * notice, this list of conditions and the following disclaimer. 
 throw raiseIllegalSignatureException(string, start); 
 result.addAll(getAllChildren(child, includedKind)); 
 private boolean isAssignable(Class<?> aClass, List<Class<?>> assignementTypes) { for (Class<?> class1 : assignementTypes) { 
 left = findTypedElement(localTraversal, accessor, actualMonitor, DiffSide.SOURCE); right = findTypedElement(localTraversal, accessor, actualMonitor, DiffSide.REMOTE); 
 * expected one (snap to another figure).<BR> 
 final List<Layer> deactivatedLayersAndAllLayersOfDeselectedViewpoints = Lists.newArrayList(Sets.symmetricDifference(layersInActivatedViewpoints, activatedLayers)); 
<|del|> 
 private Resource resource3; 
<|del|> 
 testOpenExistingTable(fileName, "RequirementTable"); //$NON-NLS-1$ 
 Assert.assertEquals(DERIVED_PROPERTY, thirdColumnRepresentedElement); 
 * This class allows to test the add and remove actions in the requirements NatTable 
 testOpenExistingTable(fileName, "RequirementTable"); //$NON-NLS-1$ 
 testOpenExistingTable(fileName, "ClassTreeTable"); //$NON-NLS-1$ 
 * This class allows to test the add/remove actions in the Generic NatTable 
<|del|> 
 private final static MappingJob INSTANCE = new MappingJob(); 
 static String headingTextToId(String headingText) { 
 final Matcher matcher = NUMBER_PATTERN.matcher(ret.string); if(matcher.find()){ String number = matcher.group(0); ret.number = Integer.parseInt(number); } 
 public final java.lang.Object getAdapter( @SuppressWarnings("rawtypes") // @SuppressWarnings("rawtypes"): tci> Because of the implementation final java.lang.Class parm0) { 
<|del|> 
 final EcoreExplorerAdapter adapter = new EcoreExplorerAdapter(this); ePackage.eAdapters().add(adapter); 
 content.add(new TmfEventField(checkNotNull(fieldName), null, null)); 
 String key = entry.getKey(); 
 fieldsArray[i] = new TmfEventField(checkNotNull(fields[i]), val, null); 
 if (outputColumn.name.equals(CustomTraceDefinition.TAG_TIMESTAMP) && timestamp != null) { 
 fields[i] = new TmfEventField(definition.outputs.get(i).name, null, null); 
/** * This abstract class provides the default implementation (type, representation * type, stereotype name to be applied) of the {@link ReversibleExtension} * adapter. */ public abstract class AbstractExtension extends AbstractReversible<InstanceSpecification>implements ReversibleExtension { 
/** * This class is a reversible adapter of a loaded extension. (Extensions * that are defined by loaded plug-ins) */ public class LoadedExtension extends AbstractExtension { 
 /** * This class is a reversible adapter of a workspace extension. (Extensions * that are defined by plug-ins in the workspace) */ 
/** * This abstract class provides the default implementation of the * {@link ReversibleExtensionPoint} adapter. */ public abstract class AbstractExtensionPoint extends AbstractReversible<Component>implements ReversibleExtensionPoint { 
 /** * This class is a reversible adapter of a loaded extension point. (Extension points * that are defined by loaded plug-ins) */ 
 * The interface representing a reversible extension point.<br /> * A reversed extension is a {@link org.eclipse.uml2.uml.Component * Component} inside it's reversible parent's representation. 
 /** * This abstract class provides the default implementation of the * {@link ReversiblePlugin} adapter. */ 
 /** * This class is a reversible adapter of a loaded plug-in. */ 
 /** * Sets the list of reversible extensions. * * @param extensions */ 
 /** * This class is a reversible adapter of a workspace plug-in. */ 
 new String(bytes, offset, length, US_ASCII)); } catch (StringIndexOutOfBoundsException e) { 
 if (matcher.matches()) { String number = matcher.group(1); 
<|del|>
 public void completeCss_property_Name(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) { 
 for (String property : allProperties) { StringBuilder stringBuilder = new StringBuilder(property); stringBuilder.append(": ");//$NON-NLS-1$ acceptor.accept(buildProposal(stringBuilder.toString(), context)); 
 for (String property : allProperties) { StringBuilder stringBuilder = new StringBuilder(property); stringBuilder.append(": ");//$NON-NLS-1$ acceptor.accept(buildProposal(stringBuilder.toString(), context)); 
 public void completeAttributeSelector_Value(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) { 
 public void completeAttributeSelector_Name(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) { 
 public void completeColorTok_Value(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) { 
 if (!prefix.isEmpty()) { 
 if (declaration.eContainer() instanceof css_declaration) { property = ((css_declaration) declaration.eContainer()).getProperty().getName(); } 
 if (autocomplete && null != property && (property.toLowerCase().contains("color") || property.toLowerCase().contains("gradient"))) {//$NON-NLS-1$ //$NON-NLS-2$ 
 public void complete_selector(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) { 
 public void complete_Identifier(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) { 
 if (owner instanceof Stereotype) { 
 ((OneTopLineResizableBorder) defaultBorder).setLengthRatio(new Float(NotationUtils.getStringValue(view, LINE_LENGTH_RATIO, LINE_LENGTH_RATIO_DEFAULT_VALUE).replace(',', '.')));// $NON-NLS-1$ //$NON-NLS-2$ 
 public void setLabelBackgroundColor(final String labelBackgroundColor) { // Do nothing 
 public void setLabelBackgroundColor(final String labelBackgroundColor) { // Do nothing 
 public static void refreshNameLabelColor(final IPapyrusEditPart editpart, final String defaultLabelColor) { 
 public void setLabelBackgroundColor(final String labelBackgroundColor) { // Do nothing 
 public void setLabelBackgroundColor(final String labelBackgroundColor) { // Do nothing 
 /** set to true to define the figure as a package. */ private boolean isPackage = false; /** The label color. */ private String labelColor = null; 
<|del|> 
 CreateElementRequest createElementRequest = new CreateElementRequest(domain, targetElementDiagram, typeToCreate); ICommand creationElementCommand; 
 throw new ExecutionException("not implemented"); 
 throw new ExecutionException("not implemented"); 
 * Class dedicated to the management of drag and drop of a Behavior (Functional etc..) into a Activity diagram to create automatically a callbehavor action 
<|del|> 
 resetAndSkipFully(in, n); 
 final Match diffMatch = ComparisonUtil.getComparison(diff).getMatch( 
/** * This Policy is to be used for Enumeration Literal Edit Part to manage the stereotype display * 
/** * * This Policy is to be used for Enumeration Literal Edit Part to manage the stereotype display * 
 Map<IServiceFactory, Attributes> java6factories; synchronized (cacheMutex) { factories = _project2Java5Factories.get(javaProj); java6factories = _project2Java6Factories.get(javaProj); 
<|del|> 
 } else { 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Copyright (c) 2015 Soft-Maint, and Mia-Software. 
 Session session = getSession(restore); if (session != null && session.isOpen() && getURI().hasFragment()) { input = session.getTransactionalEditingDomain().getResourceSet().getEObject(getURI(), false); 
 if (uiSession != null && uiSession.isOpen()) { uiSession.open(); } 
 EObject input = getInput(false); if (input != null) { return input.hashCode(); 
 if (uiSession != null && !uiSession.isOpen()) { 
<|del|> 
 * @since 1.1 
 if (editorReference.getEditorInput().equals(input)) { IEditorPart editor = editorReference.getEditor(false); if (editor == null || editor instanceof ITmfTraceEditor) { wbPage.closeEditors(new IEditorReference[] { editorReference }, false); } 
 Attributes imageBlockAttr = new Attributes(); imageBlockAttr.setCssClass("image"); //$NON-NLS-1$ 
 Map<String, String> properties = new HashMap<>(); 
 List<PDOMBinding> results = new ArrayList<>(); 
 return results.isEmpty() ? PDOMBinding.EMPTY_PDOMBINDING_ARRAY : results.toArray(new PDOMBinding[results.size()]); 
 return results.isEmpty() ? PDOMBinding.EMPTY_PDOMBINDING_ARRAY : results.toArray(new PDOMBinding[results.size()]); 
 cppOwners = getCPPBindingForC(compOwner); 
<|del|>
<|del|>
 // } 
 * Given a dependent type, heuristically tries to find a concrete scope (i.e. not an unknown scope) * for it. * 
 container.accept(visitor, 0); 
 private MouseAdapter createRemoveCommentEditorListener() { 
 Class<?> class2 = value2.getClass(); 
 monitor.done(); 
<|del|> 
 * Guy Perron - Initial API and implementation 
 private SubmitInput fSubmitInput; 
 * This structure is filled by GSON when parsing the corresponding JSON structure in an HTTP response. The SubmitInfo * entity contains information about the change status after submitting. 
 * href="https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#submit-input">SubmitInput</a> 
 * An interactive Command to speicify ownership and subject when dropping an usecase to a usecase diagram * A dialog will be opened for the user to select ownership swith yes/no and to confirm change of subject validate/cancel 
 usecaseSelectionCommand = cc.reduce(); 
 * UI composite element dedicated to manage the choice for ownership switch 
 * UI composite element dedicated to manage the choice for sibject 
/** * Class in charge to manage the messages 
 if (!commentPopupDialog.hasEdits()) { 
 public boolean hasEdits() { 
 int height = constrain(size.y, MIN_HEIGHT, getShell().getMonitor().getClientArea().height); getShell().setSize(size.x, height); scrolledComposite.setSize(size.x, height); 
<|del|> 
 discardOrDoneButton.setEnabled(currentComment == null || currentComment.isDraft()); 
<|del|> 
 private void addToEditTable(String value) { editTable.put(reviewitem.getId(), range.getStartLine(), value); 
 * As of 3.11 you can also use the other constructor which is based on 
 * @since 1.1 
<|del|> 
 * @since 1.1 
 if (o instanceof Set && !(o instanceof SortedSet<?>)) { /* Iteration order is undefined */ 
 private void validateFragmentContributions(IBuildEntry binIncludes) { 
 private void validateApplicationContributions(IBuildEntry binIncludes) { 
 protected boolean hasBraceLabel(final Node comment) { 
 public boolean isCommentEmpty(final Node comment) { 
 Assert.assertFalse("These is no applied profile on the model", model.getProfileApplications().isEmpty()); 
 protected void unapplyStereotype(final Collection<Stereotype> stereoList) { 
 Assert.assertNull(NLS.bind("Stereotype {0} is still applied on the element.", stereo.getQualifiedName()), appliedStereotype); 
 protected void applyStereotype(final Collection<Stereotype> stereoList) { 
 Assert.assertNotNull(NLS.bind("Stereotype {0} is not applied on the element", stereo.getQualifiedName()), appliedStereotype); 
 protected void testNodeLabelContent(final String expectedLabel) { 
 IPapyrusEditPart pep = (IPapyrusEditPart) editPart; Assert.assertTrue(pep.getPrimaryShape() instanceof NodeNamedElementFigure); PapyrusWrappingLabel label = ((NodeNamedElementFigure) pep.getPrimaryShape()).getStereotypesLabel(); 
 protected void testCompartmentLabelContent(final String expectedLabel) { 
<|del|> 
 protected void testOrphanComment(final int expectedNumberOfCommentView) { 
 protected void testStructure(final int expectedNumbersOfLabels, final int expectedNumbersOfCompartment, final int expectedNumbersOfBrace, final int expectedNumbersOfComment) { 
 List<View> labelList = testHelper.getAllLabel(elementView); Assert.assertNotNull("The label list is null", labelList); Assert.assertEquals("There should have as many Labels as applied Stereotypes", expectedNumbersOfLabels, labelList.size()); 
 List<View> compartmentsList = testHelper.getAllCompartment(elementView); Assert.assertNotNull("The compartments list is null", compartmentsList); Assert.assertEquals("There should have as many Comaprtment as applied Stereotypes", expectedNumbersOfCompartment, compartmentsList.size()); 
 public static boolean isX11 () { return GDK_WINDOWING_X11() && GDK_IS_X11_DISPLAY(gdk_display_get_default()); } 
 long /*int*/ imageHandle = OS.gtk_image_new(); if (imageHandle == 0) error (SWT.ERROR_NO_HANDLES); 
<|del|> 
} 
 List<View> comments = testHelper.getAllComment(elementView); Assert.assertNotNull("The comments list is null", comments); Assert.assertEquals("There should have only one Comment shape by View", expectedNumbersOfComment, comments.size()); 
<|del|> 
<|del|> 
 menuItemHasBoxAsChild = true; if (OS.SWT_PADDED_MENU_ITEMS) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 protected void setElementAndTest(final String objectName, final Class<? extends NamedElement> classType) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } else { // Gtk2 
 testCompartmentLabelContent(getStereotypeNameBetweenBrace(STEREO_A)); 
<|del|> 
 if (accelGroup != 0) addAccelerator (accelGroup); 
 if ((style & SWT.SEPARATOR) != 0) return; 
 if (image != null && boxHandle != 0) { 
 if (image != null && boxHandle != 0) { 
 if (image != null && boxHandle != 0) { 
 if (image != null && boxHandle != 0) { 
 } 
<|del|> 
 handleVersion1(localName, attributes); 
 handleVersion1(localName, attributes); 
 StatusHandler.log(new Status(IStatus.ERROR, ITasksCoreConstants.ID_PLUGIN, "Could not read repositories" //$NON-NLS-1$ , e)); 
<|del|> 
 cachedList = new ArrayList<>(getList()); 
 // because we have removed everything that is not an E 
 // cast is always safe as we get the array from a list of type M 
<|del|> 
<|del|> 
 // NOTE/TODO: This is unsafe and will cause ClassCastExceptions // if this map is queried with keys that are not of type S 
 assertTrue(deepEquals(STRING1, STRING2)); assertTrue(deepEquals(STRING2, STRING1)); 
public final class ObjectUtils { 
 if (o1 instanceof Set && !(o1 instanceof SortedSet<?>)) { /* Iteration order is undefined */ 
 if (o instanceof Set && !(o instanceof SortedSet<?>)) { /* Iteration order is undefined */ 
 private final long timeout; 
 private final long timeout; 
 public LargeObjectServlet(LargeFileRepository repository, long timeout) { 
 rsp.getOutputStream() 
 sendError(rsp, HttpStatus.SC_BAD_REQUEST, e.getMessage()); 
 response.addHeader(HttpSupport.HDR_CONTENT_LENGTH, String.valueOf(repository.getLength(id))); 
 if (in.read(buffer) != -1) { 
<|del|> 
 return new TaskRepository(kind, url); 
 assertEquals(Integer.valueOf(2), b.sample); 
 if (boxHandle != 0) { OS.gtk_container_add (boxHandle, imageHandle); OS.gtk_widget_show (imageHandle); } } if (labelHandle != 0 && boxHandle != 0) { 
 long /*int*/ groupHandle, labelHandle, imageHandle; 
 handle = OS.gtk_check_menu_item_new (); if (handle == 0) error (SWT.ERROR_NO_HANDLES); 
 handle = OS.gtk_menu_item_new (); if (handle == 0) error (SWT.ERROR_NO_HANDLES); 
 handle = OS.gtk_menu_item_new (); if (handle == 0) error (SWT.ERROR_NO_HANDLES); 
 OS.gtk_accel_label_set_accel_widget (labelHandle, 0); 
 if (boxHandle != 0) { OS.gtk_container_add (boxHandle, imageHandle); OS.gtk_box_reorder_child (boxHandle, imageHandle, 0); } 
 } 
} 
 public void addZoomedEvent(ITimeEvent event) { long start = event.getTime(); long end = start + event.getDuration(); 
 if (fEndTime == SWT.DEFAULT || end > fEndTime) { fEndTime = end; 
 return "(?:\\[((mailto\\:|[a-zA-Z]+\\://)[^\\[\\]\\|\\s]+)(?:(?:\\||\\s)([^\\]]*))?\\s*\\])"; //$NON-NLS-1$ 
<|del|> 
<|del|> 
 String getHostId(); 
 fTimestamp = ts; synchronized (TmfVertex.class) { fId = count++; } 
 fTimestamp = ts; synchronized (TmfVertex.class) { fId = count++; } 
 private static final String STATS_TOTAL = "total"; //$NON-NLS-1$ 
 long sum = 0L; synchronized (fWorkerStats) { for (long duration : fWorkerStats.get(worker)) { sum += duration; } 
 long sum = 0L; synchronized (fWorkerStats) { for (long duration : fWorkerStats.get(worker)) { sum += duration; } 
 private void recursivelyAddCommentEditorListener(Control c, MouseListener listener) { c.addMouseListener(listener); 
 sections = Lists.newArrayList(Iterables.filter(Arrays.asList(sectionContainer.getChildren()), Section.class)); 
 private void recursivelyAddCommentEditorListener(Control c, MouseAdapter adapter) { c.addMouseListener(adapter); 
 private Section findParentSection(Control c) { 
 return FluentIterable.from(commentList).filter(new Predicate<IComment>() { 
 * Constructor 
 // Even if the files were extracted to temporary folder, they 
 intermediateTempFolder.delete(true, SubMonitor.convert(monitor)); 
 fVertexFrom = from; fVertexTo = to; fType = EdgeType.DEFAULT; 
 fTimestamp = ts; synchronized (TmfVertex.class) { fId = count++; } 
<|del|> 
<|del|> 
<|del|> 
 for (Listener listener : listeners) { if (listener instanceof TypedListener) { TypedListener tl = (TypedListener) listener; 
<|del|> 
 if (labelHandle != 0 && OS.GTK_IS_LABEL (labelHandle)) { 
 buildStatusEvents(trace, parentTrace, ssq, fullStates, prevFullState, (ControlFlowEntry) entry, monitor, qStart, qEnd); 
 if (time == lastStartTime) { 
 // nothing to do 
<|del|> 
 private int findMaxDefinedLabelValue(String label) { 
 private int findMaxDefinedLabelValue(String label) { 
 private int findMaxPermitted(String label) { 
 submitButtonEnablement(); } 
 private void submitButtonEnablement() { fSubmit.setEnabled(true); int maxCRPermitted = findMaxPermitted(CODE_REVIEW); int maxVPermitted = findMaxPermitted(VERIFIED); if (findMaxDefinedLabelValue(CODE_REVIEW) != maxCRPermitted) { 
 /* */ /* Section to SET the data structure */ /* */ 
 // Manage the paste configuration newConf.setPasteConfiguration(copiedEObjectConfiguration); 
 if (!u.getProtocol().startsWith("http")) //$NON-NLS-1$ 
 if (!u.getProtocol().startsWith("http")) // $NON-NLS-1$ 
 if (logError) { Activator.log.error(ex); } 
<|del|> 
<|del|> 
 List<View> views = getViews((Element) source); 
 List<View> views = getViews((Element) source); 
 List<Object> newList = new ArrayList<>(Arrays.asList(array)); 
 return ""; //Can't happen //$NON-NLS-1$ 
<|del|> 
 assert fSelectionProvider != null; 
 unregisterActions(); 
 return (null != getVariableNode(context.getCoveringNode())); 
 final String tooltip = getToolTipText(false); 
 public final void addParents(RevCommit c, RevFlag queueControl) { 
 protected final boolean firstParent; 
 p.flags |= SEEN; if (firstParent && i > 0) { continue; } 
<|del|> 
 color.setColor("Gold Team", BLACK_HEX, "#CC9900"); color.setColor("Plaid Team", BLACK_HEX, "#33CCFF"); 
 XPath xpath = XPathFactory.newInstance().newXPath(); 
 XPath xpath = XPathFactory.newInstance().newXPath(); 
 } catch (IOException e1) { MessageDialog.openError(PlatformUI.getWorkbench().getDisplay().getActiveShell(), "Error", "Failed to obtain valid authentication response"); } 
 /** * Method to get access token from the request token * * @param requestToken : token to generate access token * @return access token */ public Token getAccessToken(final Token requestToken) { 
 TokenExtractorImpl tokenextractor = new TokenExtractorImpl(); accessToken = tokenextractor.extract(StreamUtils.getStreamContents(responseBodyAsStream)); 
 } catch (HttpException e) { OseeLog.log(getClass(), Level.SEVERE, e); } catch (IOException e) { OseeLog.log(getClass(), Level.SEVERE, e); 
 return signature; } 
 private void appendSignature(final HttpMethodBase request, final Map<String, String> oauth_params) { String oauthHeader = this.config.getHeaderExtractor().extract(request, oauth_params); request.addRequestHeader(OAuthConstants.HEADER, oauthHeader); } 
 OseeLog.log(DWAOAuthService.class, Level.SEVERE, "Error: " + e.getMessage()); 
 final Map<MDynamicMenuContribution, ArrayList<MMenuElement>> toBeHidden = new HashMap<>(); 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * */ public static DoorsArtifact doorsArtifact; private static DoorsModel instance; 
<|del|> 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Copyright (c) 2009, 2015 IBM Corporation and others. 
 * Zend Technologies * Yannick de Lange <yannickl88@gmail.com> 
<|del|> 
 if (LibraryFolderManager.getInstance().isInLibraryFolder( element.getResource())) { 
 * Zend Technologies * Yannick de Lange <yannickl88@gmail.com> 
 * Zend Technologies * Yannick de Lange <yannickl88@gmail.com> 
<|del|> 
 * @since 1.1 
<|del|> 
<|del|> 
<|del|> 
 * @since 1.1 
 * @author Alexandre Montplaisir * @since 1.1 
 * @author Alexandre Montplaisir 
<|del|> 
<|del|> 
 * Store the data from the latency analysis 
<|del|> 
 * Since the table is virtual, the content provider is a deferred content provider. 
 if (sorter instanceof ViewerCompoundComparator) { 
<|del|> 
 public void onComplete(LatencyAnalysis activeAnalysis, ISegmentStore<ISegment> syscalls) { // Only update the model if trace that was analyzed is active trace if (activeAnalysis.equals(LatencyViewerUtils.getAnalysisModule())) { updateModel(LatencyViewerUtils.storeAndGet(syscalls)); } 
 if (fTableViewer != null){ fTableViewer.updateModel(LatencyViewerUtils.storeAndGet(sysCalls)); 
 fTableViewer = new LatencyTableViewer(tableViewer); setInitialData(); 
<|del|> 
 results = analysis.getResults(); 
<|del|> 
 * Duration comparator for the table view of the latency analysis * * @author France Lapointe Nguyen * @since 2.0 */ 
<|del|> 
 * Janko Richter - initial API and implementation 
 PlatformUI.getWorkbench().getProgressService(), searchScope, 
 PlatformUI.getWorkbench().getProgressService(), searchScope, 
 * Copyright (c) 2015 Janko Richter and others. 
<|del|> 
<|del|> 
 StringBuilder varTypeHint = new StringBuilder(); // $NON-NLS-1$ 
<|del|> 
<|del|> 
 private ISegmentStore<ISegment> fWrappedStore; 
public class LatencyTableViewer extends LatencyAbstractTableViewer { 
 if (fTableViewer != null) { 
 public static LatencyDataStore storeAndGet(ISegmentStore<ISegment> data) { 
 value = "Returns a string that is the result of the concatenation of the current string and the string \"b\".", 
 value = "Returns a string that is the result of the concatenation of the current string and the string \"b\".", 
 @Param(name = "b", value = "The String that will be appended at the end of the current String.") 
 value = "Returns a string that is the result of the concatenation of the current string and the string \"b\".", 
 value = "Returns the current String prefixed with the given \"prefix\".", 
 @Param(name = "prefix", value = "The String that will be prepended before the current String") 
 result = "<code>true</code> if the current String is equal to the string \"b\", without considering case, <code>false</code> otherwise.", 
 @Throw(type = IndexOutOfBoundsException.class, value = "If \"n\" is not a valid index of self (i.e it is greater than the size of the current String).") 
 "the current String doesn't contain this particular substring. The index referential is 1 as in OCL and not 0.", 
 "in the current String. The index referential is 1 as in OCL and not 0.", 
 "in the current String. The index referential is 1 as in OCL and not 0.", 
 value = "Returns the current String with all characters transformed to lower case.", 
 value = "Returns the self string with the first characters transformed to lower case.", 
 value = "Returns the current String with all characters transformed to upper case.", 
 value = "Returns the current String with the first characters transformed to upper case.", 
 value = "Return the length of the current String.", 
 value = "Returns a string containing all characters from self starting from index lower up to index upper " + "included. Both lower and upper parameters should be contained between 1 and self.size() included. Lower " + 
 ISemanticObjectLabelProvider itemLabelProvider = (ISemanticObjectLabelProvider)adapterFactory 
<|del|> 
 /** * The AddTooltipManager instance. */ 
 * Copyright (c) 2013, 2015 Obeo. 
@SuiteClasses({ SortAxisGenericTableTest.class, InvertAxisGenericTableTest.class, EditAxisGenericTableTest.class, OpenAndDeleteTest.class, Bug458492_Edition_Enumeration.class, 
 if (notifiedElements.size() > 0) { // Select created elements 
 if (analysis == null) { updateModel(null); 
 ISegment[] segmentArray = Iterables.toArray(fWrappedStore, ISegment.class); 
 for (Entry<String, ArtifactReadable> entry : nameToCoverageUnit.entrySet()) { DispoItem dispoItem = nameToDispoItem.get(entry.getKey()); 
 report.addMessageForItem(newItem.getName(), "Could not determine Status"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public void addViewerContextMenu(StructuredViewer viewer, 
 private ViewerContextMenuHelper contextMenuHelper; 
<|del|> 
 DropTarget dropTarget = new DropTarget(viewer, DND.DROP_COPY | DND.DROP_DEFAULT); 
<|del|> 
 private final Set<LatencyAnalysisListener> fListeners = new HashSet<>(); 
 }, TreeMapStore.INTERVAL_START_COMPARATOR); 
 private final ISegmentStore<ISegment> fWrappedStore; 
public class CoverageUtil { private CoverageUtil() { } 
 fileName = fileName.replaceAll("\\.(ada|c)", ".LIS"); 
 if ((new File(f, Constants.DOT_GIT).exists()) && gitLinksEnabled(options)) { 
 public void onComplete(LatencyAnalysis activeAnalysis, ISegmentStore<ISegment> data) { // Check if the active trace was changed while the analysis was running if (activeAnalysis.equals(getAnalysisModule())) { updateModel(new LatencyDataStore(data)); 
 case START_TIME_COL_POS: 
 public void setData(@Nullable LatencyAnalysis analysis) { 
<|del|> 
 OrcsWriterEndpoint getOrcsWriterEndpoint(); 
 if (this.currentNamespace != null && this.currentNamespace.isBracketed()) { 
 @Nullable TmfGraph getAssignedGraph(); 
 * expected event type) that has to be processed. 
 /** * Handles an event * * @param event * The event to handle */ handleEvent(ITmfEvent event); 
 return new SWTBotMenu(ContextMenuHelper.contextMenu(swtBotTree, widget, text)); 
<|del|> 
 * @since 1.1 
 * @since 1.1 
 * The TmfSelectionRangeUpdatedSignal 
<|del|> 
<|del|> 
 private volatile boolean fHandlerCancelled = false; 
 @Override public void cancel() { fHandlerCancelled = true; } 
 @Param(name = "o1", value = "The object to compare"), 
 value = "Returns the concatenation of self (as a String) and the given string \"s\".", 
 value = "Returns the concatenation of the current string and the given object \"any\" (as a String).", 
 value = "Casts the current object to the given type.", 
 @Param(name = "type", value = "The type to cast the object to") 
 value = "Compares \"a\" to \"b\" and return <code>true</code> if \"a\" is less than or equal to \"b\".", 
 result = "<code>true</code> \"a\" is less than or equal to \"b\", <code>false</code> otherwise.", 
 value = "Compares \"a\" to \"b\" and return <code>true</code> if \"a\" is greater than or equal to \"b\".", 
 result = "<code>true</code> \"a\" is greater than or equal to \"b\", <code>false</code> otherwise.", 
 * Prior to 4.1 the preference was hosted in the UI plugin. So if this one * exists, we remove it from there and return. Otherwise null is returned. 
 private final static List<String> KNOWN_EXTENSIONS = Arrays.<String> asList(UmlModel.UML_FILE_EXTENSION, NotationModel.NOTATION_FILE_EXTENSION, DiModel.DI_FILE_EXTENSION); 
 // Known file dependencies by Papyrus return KNOWN_EXTENSIONS.contains(extension) && (null == preExtension || CreatedPapyrusProfileModel.PROFILE_FILE_EXTENSION.equals(preExtension)); 
 private Element containerSource = null; 
 protected void configureShell(final Shell newShell) { newShell.setText(DIALOG_TITLE); 
 label.setText(DESCRIPTION); 
 label.setText(DESCRIPTION); 
<|del|> 
 String label = null; 
 private static final String USER_INTERATION_LABEL = "Activate user interaction"; 
 return classType.isInstance(value) ? classType.cast(value) : null; 
 public EMFRefactorRequest(final EObject object) throws ServiceException { 
 void setRefactorResource(final URI resource); 
 boolean isCancelled(); 
 RENAME, MOVE, DELETE; 
<|del|> 
 public List<IRefactorParticipant> getRefactorParticipants() { return Collections.unmodifiableList(refactorParticipantsList); 
 return compoundCommand; } 
 handleStatus(e.getStatus()); 
 text = ((RefactorScope) element).getName(); 
 ServicesRegistry registry = new ServicesRegistry(); 
 // 64 objects fit in a single long word (64 bits). // On average a repository is 30% commits, 30% trees, 30% blobs. // Initialize bitmap capacity for worst case to minimize growing. 
 * Copyright (c) 2015 EfficiOS Inc., Alexandre Montplaisir 
 private @Nullable Repository getRepository(ExecutionEvent event) 
 if (receiver == null || !(receiver instanceof Repository)) { 
 init(entries(p.getOptions())); 
 * @since 4.1 
 OVR_GITFLOW = map("ovr/git-flow.gif"); //$NON-NLS-1$ 
 * Supplies decorations for displayed repositories 
 /** */ 
 private static @Nullable GitFlowRepository getRepository(Object element) { 
 private static class DecorationHelper { 
<|del|> 
 private ImageDescriptor descriptor; 
 private final static ImageDescriptor INITIALIZED_IMAGE; 
 TableItem tableItem = (TableItem) widget; parent = tableItem.getParent(); widgetBounds = getTableItemBounds(tableItem); 
 TreeItem treeItem = (TreeItem) widget; parent = treeItem.getParent(); widgetBounds = getTreeItemBounds(treeItem); 
 /** * Column position for the selected cell switch */ private static final int START_TIME_COL_POS = 0; private static final int END_TIME_COL_POS = 1; private static final int DURATION_COL_POS = 2; /** 
 if (data.getNbElements() <= Integer.MAX_VALUE) { getTableViewer().setItemCount((int) data.getNbElements()); } else { getTableViewer().setItemCount(Integer.MAX_VALUE); } 
/** * Content provider for the latency table viewers. * 
 /** * Array of all the segments in the segment store of the current trace */ private @Nullable ISegment[] fSegmentArray = null; 
 /** * Table viewer of the latency table viewer */ private @Nullable TableViewer fTableViewer = null; /** * Segment comparator */ private @Nullable Comparator<ISegment> fComparator = null; 
 fSegmentArray = null; fTableViewer = null; fComparator = null; 
 if (fComparator != null) { 
 } } else { fSegmentArray = null; 
 * Copyright (c) 2015 Obeo. 
 * Copyright (c) 2015 Obeo. 
 * @author <a href="mailto:stephane.begaudeau@obeo.fr">Stephane Begaudeau</a> 
 * @author <a href="mailto:stephane.begaudeau@obeo.fr">Stephane Begaudeau</a> 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES and others. 
 String message = this.getDefaultMessage(result); 
 * The diagnostic of the evaluation result 
 String type = "null"; //$NON-NLS-1$ 
 String type = "null"; //$NON-NLS-1$ 
 type = ePackage.getName() + "::" + eClass.getName(); //$NON-NLS-1$ 
 String message = "Result of type " + type; 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES and others. 
 DiagramElementEditPartOperation.refreshLabelAlignment(self.getContentPane(), ddec.getOwnedStyle()); 
 DiagramElementEditPartOperation.refreshLabelAlignment(self.getContentPane(), ddec.getOwnedStyle()); 
 assertEquals(SEGMENT_10_14, Iterables.getOnlyElement(intersectingElements)); 
<|del|> 
 public void updateModel(final @Nullable ISegmentStore<ISegment> dataInput) { final TableViewer tableViewer = getTableViewer(); 
 return COMPARATOR.compare(this, o); 
 @Nullable TmfGraph getAssignedGraph(); 
 * expected event type) that has to be processed. 
 * @return the label of the node. * @since 3.1 
 private final RegionContainerResizableEditPolicy regionContainerPolicy = new RegionContainerResizableEditPolicy(); 
 TmfPieChartStatisticsModel pieChartModel = getPieChartModel(); if (pieChartModel == null || pieChartModel.getPieChartGlobalModel() == null) { 
 TmfPieChartStatisticsModel pieChartModel = getPieChartModel(); if (pieChartModel == null || pieChartModel.getPieChartGlobalModel() == null) { 
 for (Entry<ITmfTrace, Map<String, Long>> entry : pieChartModel.getPieChartGlobalModel().entrySet()) { 
<|del|> 
<|del|> 
 private TmfTimeRange fTimeRange; 
 double points = getPointsFromAction(item); 
 private double getPointsFromAction(ArtifactReadable item) { double points = 0; 
 featureGroup.getSoleAttributeAsString(AtsAttributeTypes.Description, "")); 
 * Provider of labels for semantic objects. 
 * Provider of labels for semantic objects. 
 Diff leftSet = find(differences, and(changedAttribute("Root.SetString.A", "singleValuedAttribute", "value1", "value1bis"), ofKind(DifferenceKind.CHANGE))); 
 * This class defines usual methods for contextual tooltips. 
 return text; 
 * @return {@code true} when all {@code resources} map to a repository, * {@code false} otherwise. 
 int versionCompare = -(v1.compareTo(v2)); return versionCompare; 
 final IResource r = delta.getResource(); // don't consider resources contained in a project not // shared with Git team provider if ((r.getProject() != null) && (RepositoryMapping.getMapping(r) == null)) 
<|del|> 
<|del|> 
<|del|> 
 int tAT = 51101; 
<|del|> 
 try (ITmfContext context = (timeAnalysisEntry.getLastRank() != -1) ? 
 /** * Trace closed handler * 
 private TmfTimeRange fTimeRange; 
import java.util.LinkedHashMap; import java.util.LinkedHashSet; 
 * Jacques Bouthillier - Initial API and implementation 
 * Jacques Bouthillier - Initial API and implementation 
 return new SWTBotMenu(ContextMenuHelper.contextMenu(swtBotTree, widget, text)); 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES and others. 
 protected LatencyTableViewer createTableViewer(@Nullable Composite parent) { TableViewer innerViewer = new TableViewer(parent, SWT.FULL_SELECTION | SWT.VIRTUAL); return new LatencyTableViewer(innerViewer, true); 
 assertEquals("The node GMF width should not be impacted.", oldD2DSize.width, newD2DSize.width); assertEquals("The node figure should have the same ratio than the image.", newHeight, newD2DSize.height, 2); 
 if (slaveAnalysis != null && session instanceof DAnalysisSession) { 
 addField(useLogicalModelEditor); Label spacer = new Label(getFieldEditorParent(), SWT.NONE); spacer.setSize(0, 12); Composite modelStrategyParent = getFieldEditorParent(); 
 * @param texts 
 * @param texts 
 itemBounds.x = 0; return itemBounds; 
<|del|> 
 } feature.addToSum(points); 
 * See the requirement <b>{@req org.eclipse.papyrus.sysml14#Req014}</b>. 
 fail("The model is not created."); 
 * <p> See the requirement <b>{@req org.eclipse.papyrus.sysml14#Req015}</b>. 
 // 
<|del|> 
 // 
 // 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 DemoDbGroupsTest.class, DemoCountryConfigTest.class, PopulateDemoActionsTest.class, DemoDbPopulateValidateAtsDatabaseTest.class // 
 DemoDbGroupsTest.class, DemoCountryConfigTest.class, PopulateDemoActionsTest.class, DemoDbPopulateValidateAtsDatabaseTest.class // 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 } else if (contents.isEmpty()) { 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * replace it by a fresh new one to access the trace. We also * report that as an error as it should not happen. 
 try { final Set<IProject> projectCandidates = new LinkedHashSet<>(); 
 * @param mergeStrategyName * the strategy to use for merge. If not registered, the default * merge strategy according to preferences will be used. 
 testRepository.addAndCommit(project.getProject(), file3, 
 // With the MergeStrategy THEIRS, new files from branch 'master' should // be ignored and new files from branch 'side' should be present 
 return result; 
 Activator.getDefault().logError("Found closed iterator in iterator manager. " + victim.getTrace()); //$NON-NLS-1$ 
 Activator.getDefault().logError("Found closed iterator in iterator manager. " + victim.getTrace()); //$NON-NLS-1$ 
 comparison, null, originContainerMatch, MergeViewerSide.ANCESTOR, 
 public void setUp() { 
<|del|> 
 public void tearDown(){ 
<|del|>
 * See the requirement <b>{@papyrus.req org.eclipse.papyrus.sysml14#Req013}</b>. 
 * <p> See the requirement <b>{@papyrus.req org.eclipse.papyrus.sysml14#Req015}</b>. 
 *<p> See the requirement <b>{@papyrus.req org.eclipse.papyrus.sysml14#Req012}</b>. 
 * <p> See the requirement <b>{@papyrus.req org.eclipse.papyrus.sysml14#Req015}</b>. 
 *<p> See the requirement <b>{@papyrus.req org.eclipse.papyrus.sysml14#Req013}</b>. 
 // Control, TableItem, TreeItem, etc don't have a common interface for this 
 Rectangle grandParentWidgetBounds = toGrandParentBounds(parent, widgetBounds); return toDisplayBounds(parent.getParent(), grandParentWidgetBounds); 
 protected void createControl(Composite parent, FormToolkit toolkit, int style) { 
 * Copyright (c) 2007-2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2009, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES. 
 * Helper class to obtain translated strings. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES. 
 IContextService contextService = (IContextService) getSite().getService(IContextService.class); 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2009, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2009, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES. 
<|del|> 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES and others 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2011, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
<|del|> 
 // Open an editor on the provided server and changeInfo 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES. 
 throw new RuntimeException(MessageFormat.format(Messages.ExecutionOperations_invalidMessageSource, String.valueOf(source))); 
 private static final ProfilerTask COVERAGE = new ProfilerTask(Messages.AbstractFrame_coverageProfilerTaskCategory, Messages.AbstractFrame_coverageProfilerTaskName, SiriusTasks.IMAGES_VIEWPOINT); 
 super(Messages.ReparentExecutionOperation_operationName); 
 private static final ProfilerTask REFRESH_LAYOUT = new ProfilerTask( Messages.RefreshLayoutCommand_profilerTaskCategory, Messages.RefreshLayoutCommand_profilerTaskName, SiriusTasks.IMAGES_VIEWPOINT); 
<|del|> 
 @Override 
 // BEGIN SUPRESS CATCH EXCEPTION } catch (final RuntimeException e) { 
 protected void setRangeAndColor(@NonNull IDocument document, int offset, int length, @Nullable Color color) { 
 protected void setRangeAndColor(@NonNull IDocument document, int offset, int length, @Nullable Color color) { 
/** * Test class for conform creation 
 * @return Warning status for given message. 
 final List<IResource> resources = new ArrayList<IResource>(); 
 for (URI uri : dependencyUris) { // FIXME: this feature will fail with resources that are not in the workspace 
 promptUser(resources.toArray(new IResource[resources.size()])); 
 * Contributors: * Vincenzo Caselli - initial API and implementation * Francesco Guidieri - initial API and implementation 
 // By default created DLine is expand if default value of 
 return Collections.emptyList(); 
 final ToStringBuilder builder = new ToStringBuilder(this); builder.ref("partitionId", getPartitionId()); builder.attr("locale", getLocale()); builder.ref("codeTypeClass", getCodeTypeClass()); return builder.toString(); 
 * {@link #setNewPointList(PointList)} method. 
 * Copyright (c) 2012, 2015 THALES GLOBAL SERVICES. 
 * {@link #setNewPointList(PointList)} method. 
 if (connectionEditPart.getModel() instanceof Edge) { 
public abstract class AbstractLayoutProvider extends AbstractLayoutEditPartProvider { 
 * Copyright (c) 2005, 2015 IBM Corporation and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
/** * This Class redefines the PropertyPartEditPartCN for the Real Time Context * This editPart is used to control the CapsulePart. * * @see {@link RTEditPartProvider} * 
 installEditPolicy(CanonicalPortDisplayEditPolicy.CANONICAL_PORT_DISPLAY_ROLE, new CanonicalPortDisplayEditPolicy()); 
 * The CapsulePart as uml Property 
 eventBorker = DiagramEventBroker.getInstance(theEditingDomain); 
 while (null == portView && iterator.hasNext()) { 
/** * This Interface provides all the NamedStyle Properties for Real Time context * 
 /** * Constant indicating that all levels of the time graph should be expanded */ 
 /** * Constant indicating that all levels of the time graph should be expanded */ 
 implements IViewerUpdateListener, ILabelUpdateListener, IModelChangedListener, ITestModelUpdatesListenerConstants, IStateUpdateListener, IJobChangeListener 
 /** * Handles an event * * @param event * The event to handle */ handleEvent(ITmfEvent event); 
 synchronized (fWorkerStats) { 
<|del|>
 if (newWordWrapStatus == fIsWordWrapEnabled || !isWordWrapSupported()) 
 boolean isWordWrapEnabled(); 
 * selection mode will temporarily disable word wrapping.) 
 void setUiSortPossible(boolean uiSortPossible); 
 } subMonitor.worked(1); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, NLS.bind(Messages.copying, toString()), 3); IFileInfo myInfo = source.fetchInfo(EFS.NONE, subMonitor.newChild(1)); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, NLS.bind(Messages.moving, source.getAbsolutePath()), 1); 
 // the move was successful 
<|del|> 
 } return changed; 
 SubMonitor subMonitor = SubMonitor.convert(monitor, msg, 20); 
 } return traversals.toArray(new ResourceTraversal[traversals.size()]); 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html 
 resource.touch(iterationMonitor); 
 } catch (CoreException e) { PDECore.log(e); 
 validateProjectStructure(type, subMonitor.newChild(1)); 
 runner.run(subMonitor.newChild(1)); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 1); 
<|del|> 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 9); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 1); 
<|del|> 
 SubMonitor subMonitor = SubMonitor.convert(monitor, repoCount); 
 new Label(container, SWT.NONE).setText(""); 
 btnRapOption.setText("Prepare for Remote Application Platform (RAP)"); 
<|del|> 
 * @param CherryPickInput * the CherryPickInput that is to be created 
 setUiSortPossible(true); 
 final byte[] bytes = { // U+221E 0xe2889e INFINITY  (byte) 0xe2, (byte) 0x88, (byte) 0x9e, // .html 0x2e, 0x68, 0x74, 0x6d, 0x6c }; 
 final byte[] bytes = { // U+221E 0xe2889e INFINITY  (byte) 0xe2, (byte) 0x88, (byte) 0x9e, // .html 0x2e, 0x68, 0x74, 0x6d, 0x6c }; 
 return PropertySheetSorter.this.compareCategories(a.getCategoryName(), b.getCategoryName()); 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2008, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2015 IBM Corporation and others. 
 * Copyright (c) 2015 IBM Corporation and others. 
 selectionService = site.getService(ISelectionService.class); 
 runner.run(runnerConfig, launch, subMonitor.newChild(1)); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 4); 
 subMonitor.worked(1); 
 subMonitor.setCanceled(true); 
 runner.run(runnerConfig, launch, subMonitor.newChild(1)); 
 subMonitor.worked(1); 
 subMonitor.setCanceled(true); 
 * Test for the Call Stack view in trace compass 
 private static final long SEEK_TIME = 1378850463804898643l; 
 private List<String> fExpected = ImmutableList.of("40472b", "4045c8", "404412", "", ""); 
 * Initialization 
 SWTBotUtils.waitForJobs(); assertArrayEquals(STACK_FRAMES[currentEventOffset], getVisibleStackFrames(viewBot).toArray()); 
 }; return bcListener; } @Test public void testDefaultSelectionWithOnlyOneResult() throws Exception { IBlockingCondition bc = Jobs.getJobManager().createBlockingCondition("loadProposals", true); PropertyChangeListener bcListener = getUnblockOnSearchResultListener(bc); 
<|del|> 
 SubMonitor subMonitor = SubMonitor.convert(monitor, PDEUIMessages.GetNonExternalizedStringsOperation_taskMessage, fSelectedModels.size()); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, projects.length * 2); 
 SubMonitor subMonitor = SubMonitor.convert(pm, 2); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, bases.length); 
 SubMonitor subMonitor = SubMonitor.convert(pm, getTotalWork()); 
 boolean isJava8 = javaVersion() >= 1.8; 
 // TODO back port this change to JetS3t V2 
 // Strict legacy JetS3t V2 compatibility, with no IV support. 
 final CtfTmfTestTrace cygProfile = CtfTmfTestTrace.CYG_PROFILE; assumeTrue(cygProfile.exists()); 
 return; } 
 return; } 
 queryMatches = profile.query(QueryUtil.createIUQuery(id), subMonitor.newChild(1)); 
 toInstall.add(createInstallableUnitPatch(existingIU, newVersion, profile, subMonitor.newChild(1))); 
 return SubMonitor.convert(monitor); 
 return SubMonitor.convert(monitor); 
 getUnExternalizedStrings(project, subMonitor.newChild(1)); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, PDEUIMessages.GetNonExternalizedStringsOperation_taskMessage, pluginModels.length); 
 getUnExternalizedStrings(project, subMonitor.newChild(1)); 
 null, iterationMonitor.newChild(1)); } if (fBuilders.contains(PDE.SCHEMA_BUILDER_ID)) { 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 2); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 3); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, dependents.length); 
<|del|> 
 op.run(iterationMonitor); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, pkgs.length); 
 op.run(iterationMonitor); 
 compositeChange.addAll(PDEModelUtility.changesForModelModication(getExtensionModification(file), subMonitor.newChild(1))); } subMonitor.setWorkRemaining(bases.length - i); 
 iterationMonitor.beginTask( NLS.bind(PDEUIMessages.AddNewDependenciesOperation_searchForDependency, pluginId), exported.length); 
 } catch (CoreException e) { PDEPlugin.logException(e); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, frags.length * 2); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, roots.length); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, totalWork); 
<|del|> 
 SubMonitor subMonitor = SubMonitor.convert(monitor, packageFragments.length * 2); 
 } 
 } catch (CoreException e) { PDEPlugin.logException(e); 
 requestor, iterationbMonitor.newChild(1)); 
 } catch (CoreException e) { PDEPlugin.logException(e); 
 updateMonitor(iterationMonitor, fList.size()); 
 SubProgressMonitor subMonitor = new SubProgressMonitor(progressMonitor, length); 
 SubProgressMonitor subMonitor2 = new SubProgressMonitor(progressMonitor, epds.length); 
 progressMonitor.worked(1); 
 progressMonitor.worked(1); 
 } catch (MalformedURLException e) { PDEPlugin.log(e); 
 } subMonitor.worked(20); if (subMonitor.isCanceled()) { return; } 
 } subMonitor.worked(20); if (subMonitor.isCanceled()) { return; } 
<|del|> 
 setProjectNatures(project, model, subMonitor.newChild(1)); if (project.hasNature(JavaCore.NATURE_ID)) { setClasspath(project, model, subMonitor.newChild(4)); } 
 setProjectNatures(project, model, subMonitor.newChild(1)); if (project.hasNature(JavaCore.NATURE_ID)) { setClasspath(project, model, subMonitor.newChild(4)); } 
 throws JavaModelException { SubMonitor subMonitor = SubMonitor.convert(monitor); 
 jProject.setRawClasspath(new IClasspathEntry[] { jreCPEntry, handlerCPEntry }, subMonitor); 
 int ticks = (fImportType == IMPORT_FROM_REPOSITORY) ? fImportDescriptions.size() + 2 : fModels.length + 1; SubMonitor subMonitor = SubMonitor.convert(monitor, ticks); 
 IProject[] importedProjects = importer.performImport(descriptions, subMonitor.newChild(1)); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, fProjectClasspaths.size()); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 5); 
 return sourceMap; 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 4); 
 PluginImportHelper.importContent(provider.getRoot(), destination, provider, collected.get(currentDestination), iterationMonitor.newChild(1)); 
 PluginImportHelper.importContent(srcFile, destination, FileSystemStructureProvider.INSTANCE, collected.get(currentDestination), iterationMonitor.newChild(1)); 
 for (int i = 0; i < libraries.length; i++) { subMonitor.setWorkRemaining(libraries.length - i); 
 updateReferences(subMonitor.newChild(1), project); 
 updateReferences(subMonitor.newChild(1), project); 
 IPluginModelBase[] pluginstoUpdate = fData.getPluginsToUpdate(); SubMonitor subMonitor = SubMonitor.convert(monitor, pluginstoUpdate.length); 
 String[] paths = fData.getLibraryPaths(); SubMonitor subMonitor = SubMonitor.convert(monitor, paths.length + 2); 
 createContents(subMonitor.newChild(1), project); 
 SubMonitor subMonitor = SubMonitor.convert(monitor, 3); 
<|del|> 
<|del|> 
 ICoreRunnable op = new ICoreRunnable() { 
 SubMonitor subMonitor = SubMonitor.convert(monitor, name, 5); 
 project.open(subMonitor.newChild(1)); 
<|del|> 
<|del|> 
 * Find test properties from various sources in order of priority. 
 static boolean isTestConfigPresent() { 
 logger.warn("Long running tests are disabled."); 
 if (isTestConfigPresent()) { logger.info("Amazon S3 test configuration is present."); 
 if (isTestConfigPresent()) { logger.info("Amazon S3 test configuration is present."); 
 void cryptoTestIfAlgorithmIsPresent(String algorithm) throws Exception { 
 /* (non-Javadoc) 
 * A Git-specific {@link CompareEditorInput}. This class is a copy from * org.eclipse.egit.ui.internal.merge.GitMergeEditorInput. * * @author <a href="mailto:mathias.kinzler@sap.com">Mathias Kinzler</a> 
 RepoCommand command = new RepoCommand(remoteDb); 
 UstMemoryAnalysisModuleTest.class 
 prev = ch; } else { prev = 0; 
 public Object[] toArray() { 
 public Object[] toArray() { 
 return checkNotNull(fStartTimesIndex.values().toArray(a)); 
 return checkNotNull(fStartTimesIndex.values().toArray(a)); 
 if (this.add(elem)) { 
 // expected IAE, it doesn't contain semicolon and path part 
<|del|> 
 IBindingService bindingService = Adapters.getAdapter(window.getWorkbench(), IBindingService.class, true); 
 if (found[0]) { init (data); } else { 
<|del|> 
<|del|> 
<|del|> 
 public void testRandomPatterns() throws Exception { 
<|del|> 
<|del|> 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
<|del|> 
 Shell parent = getShell(); 
 * Ericsson - Initial API and implementation 
 private String getId() { 
 private String getId() { 
 private String getId() { 
 return Long.compare(other.getNbOccurence(), this.getNbOccurence()); 
 assertEquals("standard branches work", 
 assertEquals("long branches work", 
 String nsURI = ePackage.getNsURI(); if(nsURI != null && !nsURI.trim().isEmpty()){ URI uri = EcoreUtil.getURI(ePackage); 
 assertTrue("Source locator failed to find source", sourceElement instanceof IStorage); // Check file as resolved by ISourceLookup service sourceElement = SyncUtil.getSource(frameData.getFile()); assertTrue("Source Lookup service failed to find source", sourceElement instanceof IStorage); 
<|del|> 
 * @noreference This API will be deleted in a future release. See bug 475833 for details. * @noextend This API will be deleted in a future release. See bug 475833 for details. 
 consumedNodes = new HashSet<Node<E>>(); 
 for (EClass type : types) { if (type.isSuperTypeOf(((EObject)child).eClass())) { result.add((EObject)child); break; } else if (type.isInstance(child)){ result.add((EObject)child); } 
 for (EClass type : types) { if (type.isSuperTypeOf(((EObject)object).eClass())) { result.add((EObject)object); break; } else if (type.isInstance(object)) { result.add((EObject)object); } 
 for (EClass type : types) { if (type.isSuperTypeOf(((EObject)child).eClass())) { result.add((EObject)child); break; } else if (type.isInstance(child)) { result.add((EObject)child); } 
 for (EClass type : types) { if (type.isSuperTypeOf(((EObject)object).eClass())) { result.add((EObject)object); break; } else if (type.isInstance(child)) { result.add((EObject)child); } 
 (segmentArray.length > index)) { 
 return Adapters.getAdapter(contentProvider, SaveablesProvider.class, true); 
 return Adapters.getAdapter(contentProvider, SaveablesProvider.class, true); 
<|del|> 
 @Option(name = "--record-remote-branch", usage = "usage_branches") 
 @Option(name = "--record-remote-branch", usage = "usage_branches") 
<|del|> 
<|del|> 
 c.load(); 
 String appModelPathValue = appModelPath.filter(path -> !path.isEmpty()).orElseGet(() -> { 
 proxyTextBox.setText(service.getString(PHPDebugPlugin.ID, XDebugPreferenceMgr.XDEBUG_PREF_PROXY, "", null)); //$NON-NLS-1$ 
 attribute = Platform.getPreferencesService().getString(PHPDebugPlugin.ID, id, null, null); 
<|del|> 
<|del|> 
<|del|> 
 loadOptions.put(XMLResource.OPTION_RECORD_UNKNOWN_FEATURE, Boolean.TRUE); saveOptions.put(XMLResource.OPTION_RECORD_UNKNOWN_FEATURE, Boolean.TRUE); 
 assertNotNull("The " + variableName + " variable should be available to reference the created instance", interpreter.evaluateEObject(root, "aql:" + variableName)); 
<|del|>
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 public static void checkAndSetIgnoreCase(ChangeItem changeItem) { 
 ignoreType.isNone() || // 
 return (type.isNone() || type.isResurrected()); 
 String initialTrimVisibility = tc.getPersistedState().get(INITIAL_TRIM_VISIBILIY); if (initialTrimVisibility != null && initialTrimVisibility.length() > 0) { visible = Boolean.parseBoolean(initialTrimVisibility); 
 String initialTrimVisibility = tc.getPersistedState().get(INITIAL_TRIM_VISIBILIY); if (initialTrimVisibility != null && initialTrimVisibility.length() > 0) { visible = Boolean.parseBoolean(initialTrimVisibility); 
<|del|> 
<|del|>
<|del|> 
 for (EClass type : types) { if (type.isSuperTypeOf(((EObject)object).eClass())) { result.add((EObject)object); break; } else if (type.isInstance(object)) { result.add((EObject)object); } 
 for (EClass type : types) { if (type.isSuperTypeOf(((EObject)child).eClass())) { result.add((EObject)child); break; } else if (type.isInstance(child)) { result.add((EObject)child); } 
 for (EClass type : types) { if (type.isSuperTypeOf(((EObject)object).eClass())) { result.add((EObject)object); break; } else if (type.isInstance(child)) { result.add((EObject)child); } 
<|del|> 
 fail("Cannot verify the migration version: " + e.getMessage()); 
<|del|> 
<|del|> 
 private @Nullable TmfAbstractLatencyAnalysis fAnalysisModule = null; 
 public void setData(@Nullable TmfAbstractLatencyAnalysis analysis) { 
 public @Nullable TmfAbstractLatencyAnalysis getAnalysisModule() { 
 public abstract String getTextForSegment(ISegment input); 
 public String getTextForSegment(ISegment input) { 
 * Add bi-directional implications between the given UML change and the related changes (notation, di) * found in the map for the given change. 
 * BRANCH_3 checkouted. Comparison with BRANCH_2 (the move). * Comparison: No conflicts. Some differences, with just 1 {@link ResourceAttachmentChange} of kind MOVE. 
 if (resourceURI.endsWith(UML_EXTENSION)) { addEquivalences(resourceAttachmentChange, moveChangesByTrimmedURI); addEquivalences(resourceAttachmentChange, changesByTrimmedURI); 
 * Do add equivalence links between the relevant changes (requires, requiredBy). 
 private void addEquivalences(ResourceAttachmentChange umlAttachmentChange, Multimap<String, ResourceAttachmentChange> attachmentChangeByKey) { for (ResourceAttachmentChange relatedChange : attachmentChangeByKey .get(getIndexKey(umlAttachmentChange))) { 
 DiagramEventBroker eventBroker = null; TransactionalEditingDomain editingDomain = ((IGraphicalEditPart) getHost()).getEditingDomain(); if (null != editingDomain) { eventBroker = DiagramEventBroker.getInstance(editingDomain); 
 SubMonitor subMonitor= SubMonitor.convert(pm, 2); super.releaseDocument(document, subMonitor.newChild(1)); 
 BoundReference defaultBoundReference = UMLUtil.getStereotypeApplication(connectableElement, BoundReference.class); defaultBoundReference.setBoundEnd(modifiedEnd); 
 BoundReference defaultBoundReference = UMLUtil.getStereotypeApplication(connectableElement, BoundReference.class); defaultBoundReference.setBoundEnd(modifiedEnd); 
 * CEA LIST - Initial API and implementation * Bonnabesse Fanch (ALL4TEC) fanch.bonnabesse@alltec.net - Bug 476872 
 * Constant used to indicate that the action is done in the diagram. 
 * Constant used to indicate where the action is done. 
 * the editpart being reparented * @return The CompositeCommand that containing the modified MoveRequest. 
<|del|> 
 SubMonitor iterationMonitor = subMonitor.newChild(1).setWorkRemaining(types.length); 
 SubMonitor subMonitor = SubMonitor.convert(monitor); 
 SubMonitor iterationMonitor = subMonitor.setWorkRemaining(Math.max(plugins.size() + 1, 5)).newChild(1) .setWorkRemaining(imports.length); 
 try { SubMonitor subMonitor = SubMonitor.convert(monitor); 
 Change[] changes = PDEModelUtility.changesForModelModication(modification, subMonitor); 
 private void runCleanup(IProgressMonitor monitor, IBundlePluginModelBase modelBase, Change[] result) 
 null /* no progress monitor */); 
<|del|> 
 private void setupTestControlledPackagedWithDiagram() throws Exception { 
 private void setupTestControlledPackagedWithoutDiagram() throws Exception { 
 public void testControlledPackagedWithoutDiagram() throws Exception { setupTestControlledPackagedWithoutDiagram(); 
 public void testControlledPackagedWithoutDiagram() throws Exception { setupTestControlledPackagedWithoutDiagram(); 
 GridData data = new GridData(GridData.FILL_BOTH); data.heightHint = 300; fDialogComposite.setLayoutData(data); 
<|del|> 
 fDialogComposite.layout(); enableLocalButtons(); 
 fFileWidget.setConnection(fConnection); fFileWidget.addSelectionChangedListener(new ISelectionChangedListener() { @Override public void selectionChanged(SelectionChangedEvent event) { enableRemoteButtons(); } }); 
 } else { subMonitor.newChild(1); 
<|del|> 
 fFolderViewer.setInput(LTTngProfileViewer.getViewerInput()); 
 Path destPath = FileSystems.getDefault().getPath(LttngProfileManager.getProfilePath().toFile().toString()); copyProfileFile(source, destPath, Messages.TraceControl_ImportProfileTitle); fFolderViewer.setInput(LTTngProfileViewer.getViewerInput()); 
 } fFolderViewer.refresh(); 
 for (TraceSessionComponent session : sessions) { 
 /** * Returns the path to the profile directory. * @return the path to the profile directory */ 
 private ILoadDialog fLoadDialog; 
 if (nb != 0 && (data.isEmpty() || data.size() != nb)) { 
 if (nb != 0 && (data.isEmpty() || data.size() != nb)) { 
<|del|> 
 public static String LatencyScatterView_title; 
<|del|> 
 * synchronizer's queue * 
 * 
 if (numToAdd <= 0) { 
 * @deprecated this is not thread-safe and may contain invalid data at 
 * May be passed as a flag to {@link #split}. Indicates that isCanceled * should always return false. * @since 3.8 
 setWindowRange(currentStart, currentEnd); updateRange(currentRange); 
 // Provides for NodeEditParts with figures which can contain shapes if (isNodeEPWithSymbolCompartmentFigure(gep)) { 
 /** * @return true if figure contain container for shape elements and container edit part is a NodeEditPart */ private boolean isNodeEPWithSymbolCompartmentFigure(IGraphicalEditPart ep) { 
<|del|> 
<|del|> 
 * @since 4.2 
 return new Status(IStatus.INFO, PLUGIN_ID, "Analysis module does not have results"); //$NON-NLS-1$ 
 private boolean overlaps(ISegment last, ISegment next) { 
 if (swtChart.isDisposed()) { 
 ResourceUIUtil.RESOURCES_GRAPH_ID); 
<|del|>
 /** * @deprecated The URI resources Graph should not be accessed through the EMFCompareConfiguration since * this Graph is common to all comparison and the EMFCompareConfiguration is comparison * dependent. Get the URI resources ReadOnlyGraph through the EMFCompareRCPUIPlugin */ 
 * Set the graph to be used by this consumer. 
 * The graph to use 
 * Return the ID used to identify this specific consumer. 
 * Provide a read-only view of the graph used by this consumer. 
 * Copyright (c) 2014, 2015 Obeo. 
 public TransactionBuilder createTransaction(IOseeBranch branch, ArtifactReadable author, String comment) throws OseeCoreException { Conditions.checkNotNull(branch, "branch"); 
 TransactionBuilder createTransaction(Long branchId, ArtifactReadable userArtifact, String comment) throws OseeCoreException; 
 waitFork(graph, ts, target, current); 
 case IRQ_TIMER: 
 /** An instance of {@code StructureMergeViewerFilter}. */ 
 /** An instance of {@code StructureMergeViewerFilter}. */ 
 * the bundle/version-range map. Keys are the bundle symbolicnames to update and the * values are the new version range to apply. 
 * the bundle/version-range map. Keys are the bundle symbolicnames to update and the * values are the new version range to apply. 
 String bundleSymbolicName = mutableManifestElement.getValue(); if (versionsToUpdate.containsKey(bundleSymbolicName)) { 
 private enum ParameterType { 
 return handleNewlyOutOfScopeVersions(newVersionRange, originalReferencedVersion, newReferencedVersion); 
 Version newRight; if (versionRange.getRight() != null && versionRange.getRight().equals(originalReferencedVersion)) { newRight = newReferencedVersion; } else { newRight = versionRange.getRight(); 
 // change nothing: the specified versions are already the version presents in the manifest 
 public void rangesNowExcludingVersionShouldBeUpdatedWhenUpgradingVersion() { 
 public void rangesNowExcludingVersionShouldBeUpdatedWhenDowngradingVersion() { 
<|del|> 
 if (hasReferences(field, subMonitor.split(1))) 
<|del|> 
<|del|> 
 List<IJavaElement> allCus = new ArrayList<>(); 
<|del|> 
 fPublicMap = Collections.unmodifiableMap(fMap); 
 // if (!next.hasNeighbor(TmfVertex.OUTGOING_VERTICAL_EDGE) // && node.hasNeighbor(TmfVertex.OUTGOING_HORIZONTAL_EDGE)) // { // next = // NonNullUtils.checkNotNull(node.neighbor(TmfVertex.OUTGOING_HORIZONTAL_EDGE)); // } 
 public void handleEvent(ITmfEvent ev) { String eventName = ev.getName(); LttngEventLayout eventLayout = getProvider().getEventLayout(); 
 waitFork(graph, ts, target, current); 
 Object cpuObj = NonNullUtils.checkNotNull(TmfTraceUtils.resolveEventAspectOfClassForEvent(event.getTrace(), TmfCpuAspect.class, event)); 
 protected ICommand getReparentCommand(final IGraphicalEditPart gep) { // This overrides getReparentCommand in order to store on the MoveRequest a parameter which indicate where the move action is done. 
 createButton(parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false); Button button = createButton(parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, false); 
 createButton(parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false); Button button = createButton(parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, false); 
<|del|> 
<|del|> 
<|del|> 
 public void testRgbHex() { RGB rgb = E4ThemeColor.getRGBFromCssString("#00FF00"); //$NON-NLS-1$ assertEquals(new RGB(0, 255, 0), rgb); 
 return type.toString() + ' ' + id + ' ' + SoftIrqLabelProvider.getSoftIrq(id); 
<|del|> 
 String id = new Long(System.currentTimeMillis()).toString(); 
 customTimeStamps.put(fragments[i].getPath(), new Long( 
 Long delta = System.currentTimeMillis() - start; Long length = getContainersFile().length(); 
 timeStamps.put(Path.fromPortableString(key), timestamp); 
 int subClass = Integer.parseInt(new String(bytes)); 
 indexedDocuments.put(newDocNames[i], i); 
 static final Integer EXACT_MATCH = Integer.valueOf(SearchMatch.A_ACCURATE); static final Integer POTENTIAL_MATCH = Integer.valueOf(SearchMatch.A_INACCURATE); static final Integer ERASURE_MATCH = Integer.valueOf(SearchPattern.R_ERASURE_MATCH); 
 level); 
 report(NLS.bind( Messages.ScriptToggleBreakpointAdapter_breakpointAlreadySetAtLine, lineNumber), part); 
 /** @return current date. */ public Date getDate() { 
public class LatencyView extends AbstractSegmentStoreTableView { 
<|del|> 
 private ProcessStatus(int value) { fValue = value; 
 List<LttngWorker> kernelWorker = new ArrayList<>(); 
<|del|> 
 TmfEdge link = graph.append(target, new TmfVertex(ts)); if (link != null) { 
 case IRQ_TIMER: 
 fTcpMatching.matchEvent(event, event.getTrace(), DEFAULT_PROGRESS_MONITOR); 
 prev_state = (long) ((int) prev_state) & (LinuxValues.TASK_STATE_RUNNING | LinuxValues.TASK_INTERRUPTIBLE | LinuxValues.TASK_UNINTERRUPTIBLE); 
 ITmfEventField field = NonNullUtils.checkNotNull(event.getContent().getField(name)); return NonNullUtils.checkNotNull((Long) field.getValue()); 
<|del|> 
<|del|> 
<|del|> 
 fFolderViewer.setInput(LTTngProfileViewer.getViewerInput()); enableLocalButtons(); 
 fFolderViewer.setInput(LTTngProfileViewer.getViewerInput()); enableButtons(); 
 Object checkedElements[] = fFolderViewer.getCheckedElements(); 
 Object[] checkedElements = fFolderViewer.getCheckedElements(); for (Object element : checkedElements) { 
 superInterfaces[interfaceCount++] = types[Integer.parseInt( new String(b2))]; 
 Integer.parseInt(split[1])); 
 filters[i] = new Filter(split[0], true, Integer.parseInt(split[1])); 
 return Boolean.parseBoolean( this.getMarker().getAttribute(MODIFICATION, "true")); //$NON-NLS-1$ 
 int intValue = Integer.parseInt(totalWork); 
 elem.setAttribute(COMBINE_ACCESSRULES, curr.combineAccessRules()); 
 dialog.doCombineAccessRules()); 
 new Object[] { text, excluded }); 
 history.put(type, rank); 
 lineNumber = Integer.parseInt(lMatch.group()); 
 public static final String PREF_ENABLE_TARGETSELECTOR = "enableTargetSelector"; //$NON-NLS-1$ 
 if (targetSelector!=null){ targetSelector.refresh(); } 
 private final class AnalysisProgressListener implements IAnalysisProgressListener { 
 protected List<LinkEndsMapper> getExistingLinksBetweenSourceAndTarget(final CreateRelationshipRequest request, final IElementType wantedElementType) { List<LinkEndsMapper> existingElement = null; 
 if (UMLPackage.eINSTANCE.getConnector() == wantedEClass) { 
 int idx = rest.indexOf("rgb("); //$NON-NLS-1$ if (idx != -1) { rest = rest.substring(idx + 4, rest.length()); 
 Integer.parseInt(split[1])); 
 filters[i] = new Filter(split[0], true, Integer.parseInt(split[1])); 
 return Boolean.parseBoolean( this.getMarker().getAttribute(MODIFICATION, "true")); //$NON-NLS-1$ 
 int intValue = Integer.parseInt(totalWork); 
 node.setAttribute("type", Integer.toString(getType())); //$NON-NLS-1$ 
 String versionPluginId = element.getAttribute(ATTRIBUTE_VERSION_PLUGIN_ID); if (versionPluginId != null) { IBundleGroup bundleVersionPlugin = getBundleGroup(versionPluginId); if (bundleVersionPlugin != null) { 
 ((SupportProduct) item).setVersioningBundleGroup(bundleVersionPlugin); 
 public Generator(GenEditorGenerator genModel, CodegenEmitters emitters, BinaryEmitters binaryEmitters) { 
 public GeneratorBase(Map<String, String> formatter) { myFormatterOptions = formatter; 
<|del|> 
 GenEditorGenerator editorGen = GMFGeneratorUtil.loadEditorGen(runnerArguments.getGMFGENProjectLocation(), runnerArguments.getGMFGENResourceLocation()); 
 initPluginProject(runnerArguments.getGenerateProjectLocation(), editorGen.getPluginDirectory()); 
public interface GMFLauncherConstants { 
<|del|> 
 Repository repository, IWorkbenchPage workbenchPage) { 
 private static void openCompareToolExternal(Repository repository, CompareEditorInput input) { 
 if (uri != null) 
 private final String fFilePath; private final String fBuildId; private final String fToString; 
<|del|> 
 return branch.equals(CoreBranches.SYSTEM_ROOT) ? "none" : branch.getParentBranch().getName(); 
 final protected List<IDecoration> decorations = new ArrayList<IDecoration>(); 
 decorations.clear(); 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 IDiagramCommandFactory diagramCommandFactory = emfCommandFactoryProvider.getCommandFactory(getEditingDomain()); diagramCommandFactory.setUserInterfaceCallBack(new EMFCommandFactoryUI()); 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES. 
 if (part != null && part.getEditorInput() instanceof SessionEditorInput && ((SessionEditorInput) part.getEditorInput()).getStatus().getSeverity() < IStatus.ERROR) { 
 if (activeEditor != null && activeEditor.getEditorInput() instanceof SessionEditorInput && ((SessionEditorInput) activeEditor.getEditorInput()).getStatus().getSeverity() < IStatus.ERROR) { 
 HistoryTreeTest.class, InMemoryBackendTest.class 
 return NonNullUtils.checkNotNull(Iterables.getLast(latest)); 
<|del|> 
<|del|> 
 * Copyright (c) 2015 cole Polytechnique de Montral 
@org.eclipse.jdt.annotation.NonNullByDefault package org.eclipse.tracecompasss.statesystem.core.tests.stubs.backend; 
 if (endtime < Iterables.getLast(fIntervals).getEndTime()) { throw new IllegalArgumentException("Closing end time should be greater than or equal to the end time of the intervals of this node"); //$NON-NLS-1$ 
 * Copyright (c) 2007, 2015 IBM Corporation and others. 
 * Copyright (c) 2008, 2015 IBM Corporation and others. 
 * Copyright (c) 2008, 2015 IBM Corporation and others. 
 if (status.getSeverity() >= IStatus.ERROR) { 
 } 
 assertEquals(3, ht.getDepth()); 
 * A test class to test that {@link DialectEditor} are opened with a end-user 
 if (wakeupEventName.equals(eventLayout.eventSchedProcessTTWU())) { return eventName.equals(eventLayout.eventSchedProcessTTWU()); } return false; 
 styledString.append(MessageFormat.format(Messages.BundleContainerTable_10, bundleCountString), StyledString.COUNTER_STYLER); 
 IContextService contextService = (IContextService) getSite().getService(IContextService.class); 
 IContextService contextService = (IContextService) getSite().getService(IContextService.class); 
public class Lttng28EventLayout extends Lttng27EventLayout { 
 RoundedRectangleNodePlateFigure result = new RoundedRectangleNodePlateFigure(100, 250) { 
 } @Override public String fieldHRtimerFunction() { return HRTIMER_FUNCTION; } 
<|del|> 
 public <Match extends IPatternMatch, Matcher extends IncQueryMatcher<Match>> EventDrivenTransformationBuilder<Match, Matcher> createRule(String name) { return new EventDrivenTransformationBuilder<Match, Matcher>().name(name); 
 Map<RuleSpecification<?>, EventDrivenTransformationRule<?, ?>> rulesToAdd = Maps.newHashMap(); 
 private final CodeFormatterFactory myCodeFormatterFactory; 
 ImageData resizedData = DPIUtil.autoScaleImageData(data, currentDeviceZoom); 
 throw new UnsupportedOperationException(); 
<|del|> 
 int findOrInsert(AnyObjectId objectId, int type) { 
 BitmapBuilder addObject(AnyObjectId objectId, int type); 
<|del|> 
<|del|> 
 }; 
 } public long getCountOfLoadedCommits() { return countOfLoadedCommits; } 
 // test creation of ProtocolMessage in messageSet 
 // test not creation of ProtocolMessage in protocol0 
 public static final String PREFERENCE_WORD_WRAP_ENABLED= "wordwrap.enabled"; //$NON-NLS-1$ 
 * Andrey Loskutov <loskutov@gmx.de> - initial API and implementation 
 * This action toggles the word wrap in the editor. 
 int rulerHeight = clArea.height - topTrim; if(hScrolVisible) rulerHeight -= scrollbarHeight; 
<|del|> 
<|del|> 
 * this border locator does not take in account CSS, it is always internal. 
<|del|> 
public class Utils { /** * Creates a new UML model with a specific name * * @param name * The name of the model * @return the UML model */ 
 * Robin Stocker - Fix for Bug 193034 (tool tip also on text) * Alena Laskavaia - Bug 481604 
 * Copyright (c) 2007,2015 IBM Corporation and others. 
 * IBM Corporation - initial API and implementation * Alena Laskavaia - added ExpandableCompositeTest (Bug 481604) 
 @Override 
<|del|> 
<|del|> 
 // no client 
 if (widgetOffset == -1) 
<|del|> 
 * @return the receiver's word wrap state 
 this.valueCache.put(columnIndex, result); fireCacheUpdateEvent(buildUpdateEvent(columnIndex, null, result)); 
<|del|> 
 return "org.eclipse.papyrus.sysml14.diagram.parametric"; 
 return new ParameterPositionLocator(mainFigure, PositionConstants.NONE); 
 * bits, {@code new CompressedBitmap(bitmap, bitmapIndex)} represents the * objects at those positions in {@code bitmapIndex.packIndex}. 
 * For a EWAHCompressedBitmap {@code bitmap} representing a vector of bits, * {@code new CompressedBitmap(bitmap)} represents the objects at those * positions in {@code packIndex}. 
 reuse.or(new CompressedBitmap(bitmap, commitBitmapIndex)); 
 colState.setBackgroundEffect(((INumberColumn) c).getBackgroundEffect()); 
 } prefixName += "_" + i; //$NON-NLS-1$ 
 redraw(); 
<|del|> 
 getActiveWindowService().switchPerspective(perspectiveId); 
 wc.setAttribute(ILaunchManager.ATTR_ENVIRONMENT_VARIABLES, environment); 
<|del|> 
<|del|> 
<|del|> 
 /** * Example of Implementation of {@link IDecorationSpecificFunctions} from Papyrus decoration service to decoration nodeA. * */ 
 /** * Example of Implementation of {@link IPapyrusMarker} from Papyrus decoration service to decoration nodeA through marker * */ 
 /** * Example of Implementation of {@link IDecorationSpecificFunctions} from Papyrus decoration service to decoration nodeB. */ 
 /** * Example of Implementation of {@link IPapyrusMarker} from Papyrus decoration service to decoration nodeB through marker * */ 
<|del|> 
 /** * This utilize provide some methods and constants used on decorators examples. * */ 
 * @param behavoir * the behavior the test 
 if (null == view) { 
 if (null == decorationService) { 
 if (nodeBMarked) { // Decoration for B manage with marker 
 if (null == markerA) { 
 if (null == markerB) { 
 if (null != markerA && null != decorationService) { 
 if (null != markerB && null != decorationService) { 
 if ((null != diagramType) && (diagramType.equals(currentDiagramType))) { 
 if (null != view && ActivityDiagramEditPart.MODEL_ID.equals(UMLVisualIDRegistry.getModelID(view)) && view.getElement() instanceof CallBehaviorAction) { 
 if (null != manager) { 
 * pixel borders. 
 Optional<MCommand> optionalCommand = application.getCommands().stream() .filter(cmd -> SPY_COMMAND.equals(cmd.getElementId())).findFirst(); if (optionalCommand.isPresent()) { return optionalCommand.get(); } 
 return hasAssosciatedTask && !(hasContext || hasScheduledDate || hasDueDate); 
 import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; 
 } if (prune) { 
 // assert that the changed remote is available in the git configuration 
 // assert that the changed remote is available in the git configuration 
<|del|> 
 return "org.eclipse.papyrus.sysml14.diagram.parametric"; 
<|del|> 
<|del|> 
 resetSiriusSheetLabelProvider(propertiesView, oldLabelProvider); 
 private Object setSiriusSheetLabelProvider(SWTBotView propertiesView) { Object oldLabelProvider; 
 private Object setSiriusSheetLabelProvider(SWTBotView propertiesView) { Object oldLabelProvider; 
 private boolean serverUrlDisabled = false; 
 /** * Sets the URL control is enabled or disabled. * * @since 3.18 */ public void setUrlDisabled(boolean value) { serverUrlDisabled = value; 
 * <pre> 
 newname.append('_'); 
 public void setUrlReadOnlyNotCalled() throws Exception { 
 private boolean serverUrlReadOnly = false; 
 public void setUrlReadOnly(boolean value) { serverUrlReadOnly = value; 
 this.monitor = SubMonitor.convert(monitor); 
 * @author Alexandre Montplaisir 
<|del|> 
<|del|> 
 final IDockerConnection currentConnection = getCurrentConnection( activePart); final IDockerPortMapping selectedPort = portMappings 
 if ("tcp".equalsIgnoreCase(connectionURI.getScheme()) //$NON-NLS-1$ || "unix" //$NON-NLS-1$ .equalsIgnoreCase(connectionURI.getScheme()) 
<|del|> 
 throw new CmdLineException(CLIText.get().needSingleRevision); } 
 int begin = Math.max(Math.min(beginIndex, fTableItemCount - 1), 0); int end = Math.max(Math.min(endIndex, fTableItemCount - 1), 0); int selection = fSelectedBeginRank != begin ? begin : end; 
<|del|> 
 if ((selection < fTableTopEventRank + fFrozenRowCount && selection >= fFrozenRowCount) || (selection >= fTableTopEventRank + fFullyVisibleRows)) { 
 protected Command getCreateRelationshipCommand(final CreateRelationshipRequest req) { 
 * Edit policy provider for the editParts which used DefaultSemanticPolicy for Semantic Role. 
 public boolean provides(final IOperation operation) { 
 /** * * An utility class to use association. * */ 
<|del|> 
 assertNotNull(command); 
 assertThat(modelTarget, instanceOf(NodeImpl.class)); 
 private static final Collection<String> IPI_ENTRY_SET = ImmutableSet.of( 
 private static final Collection<String> IPI_EXIT_SET = ImmutableSet.of( 
 public Collection<String> getX86IrqVectorsEntry() { return IPI_ENTRY_SET; 
 public Collection<String> getX86IrqVectorsExit() { return IPI_EXIT_SET; 
/** * Interface for providing a {@link Runnable} which will get executed on the UI Thread. * 
 * - linux >= 4.3 and lttng >= 2.8: sched_waking + sched_wakeup_new * - linux < 3.8.0: sched_wakeup + sched_wakeup_new 
 /* Fall back to built-in sched_waking and sched_wakeup_new */ 
<|del|> 
 /* FIXME: downcast in the client should be avoided */ 
<|del|> 
 /* FIXME: downcast in the client should be avoided */ 
<|del|> 
 /* * No soft-break or line-feed found. Avoid breaking a run at * the first character (firstStart == 0) unless it's the * only run available (firstIndice == lineStart). See bug 408833. */ 
 private static final String INTERNAL_STRUCTURE_ID = "" + ClassCompositeCompartmentEditPart.VISUAL_ID; 
 * array containing the values * @param clazz * ID_TYPE of the Key 
 */ @NonNull 
 return ResourceStateFactory.getInstance().get(res) .staged() != Staged.NOT_STAGED; 
 fTrace = new CustomXmlTrace(definitions[0]); /* Deregister the custom XML trace */ TmfSignalManager.deregister(fTrace); Collection<ITmfEventAspect> aspects = TmfTrace.BASE_ASPECTS; fAspects = aspects; 
 /* Generate the aspects for this trace if it is the aspects special event */ String eventName = getStringValue(content, EVENT_NAME_FIELD); if (eventName.equals(ASPECT_SPECIAL_EVENT)) { 
 /** * @deprecated use {@link #ValgrindStackFrame(IValgrindMessage, String, ISourceLocator, String, int)} */ @Deprecated 
 String getText(); 
 * Ericsson - initial API and implementation 
 * The command: POST /changes/{change-id}/revert 
 * Construct a command to revert a review 
 * This class is used to execute a command on the EGerrit Dashboard 
 StagingState getStagingState(); 
 * <li>isContainer <code>true</code> if the resource is a project or a folder</li> 
<|del|>
 private static final String QUOTE = "\""; //$NON-NLS-1$ private static final String SPACE_QUOTE = " \""; //$NON-NLS-1$ 
 private static final String QUOTE = "\""; //$NON-NLS-1$ private static final String SPACE_QUOTE = " \""; //$NON-NLS-1$ 
 public abstract boolean matchesUsername(String username); 
 private final TaskRepository taskRepository; 
 /** Represents a resource that has been renamed. */ 
 protected void setStagingState(@NonNull StagingState staged) { 
 HAS_UNSTAGED_CHANGES, 
 public InputReader(InputStream inputStream, @Nullable final ICommandOutputListener listener, final boolean isStdOut) { 
 public InputReader(InputStream inputStream, @Nullable final ICommandOutputListener listener, final boolean isStdOut) { 
 * Call back with new output String. It will provide the delta String * in comparison the previous call of this method. 
 * Call back with new output String. It will provide the delta String * in comparison the previous call of this method. 
 * Call back with new error output String. It will provide the delta String * in comparison the previous call of this method. 
 * Call back with new error output String. It will provide the delta String * in comparison the previous call of this method. 
 bot.menu(WINDOW_MENU).menu(PREFERENCES_MENU_ITEM).click(); 
 Matcher matcher = MAC_OS_VERSION_PATTERN.matcher(osVersion); 
 return Integer.compare(fBugFixVersion, o.getBugFixVersion()); 
 final IPropertyChangeListener themeToPreferencesFontSynchronizer = new IPropertyChangeListener() { 
 if (fTextEditor != null && JavaUI.ID_MODULE_INFO_EDITOR.equals(fTextEditor.getEditorSite().getId())) { 
 if (fTextEditor != null && JavaUI.ID_MODULE_INFO_EDITOR.equals(fTextEditor.getEditorSite().getId())) { 
 if (fTextEditor != null && JavaUI.ID_MODULE_INFO_EDITOR.equals(fTextEditor.getEditorSite().getId())) { 
 private static CanonicalTreeParser createTreeParser(byte[] pathPrefix, 
 final T service = bundleContext.getService(serviceReference); 
<|del|> 
 attributes = fElementToEdit.getAttributes(); 
 String.format("Cell value of column %1$s in row %2$s on sheet %3$s is not a valud number.", //$NON-NLS-1$ 
 private final List<ITmfXmlStateValue> fStateValues; 
<|del|> 
 if (!fStateValues.isEmpty()) { 
 if (fStateValues.size() == 1) { ITmfXmlStateValue filter = fStateValues.get(0); 
<|del|> 
 throw new IllegalStateException("TmfXmlCondition : The state value does not exist in the state system"); //$NON-NLS-1$ 
 switch (comparisonOperator) { //TODO The comparison operator should have a compareHelper that calls compare 
 listener.outputUpdated(String.valueOf(buffer, 0, read)); 
 * in comparison to the previous call of this method. 
 * in comparison to the previous call of this method. 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Copyright (c) 2000, 2016 IBM Corporation and others. 
<|del|> 
 private Resource loadPackage(URI uri, URI normalized) { if (uriCache.containsKey(normalized)) { return uriCache.get(normalized); } 
<|del|> 
<|del|> 
 resources = new HashMap<Resource, Resource> (); 
 * 
 * One action can be associated with N keys. However, each key can only 
 textDirection = SWT.AUTO_TEXT_DIRECTION; 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
 return SWT.NONE; 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
 * Wraps Win32 API used to bidi enable widgets. Up to 3.104 was used by * StyledText widget exclusively. 3.105 release introduced the method 
 * Wraps Win32 API used to bidi enable widgets. Up to 3.104 was used by * StyledText widget exclusively. 3.105 release introduced the method 
 * @since 3.105 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
 * @since 3.105 
 ITask updatedReview = (ITask) delta.getElement(); 
 boolean anyIncomingReviews = (reviewTask.getSynchronizationState().isIncoming()); 
 private ITask getTasksAssosciatedWithReviewTask(ITask reviewTask) { 
 public void testIfMoveOfLabelIsDetectedAsCoordinatesChange() throws IOException { 
 private void testDragProvidedShape(boolean zoomAndScroll, boolean isSource) { 
 if (isSource) { originalPoint = newEReference1PointList.getFirstPoint(); } else { originalPoint = newEReference1PointList.getLastPoint(); } // reconnection bounds Rectangle newBounds = editor.getBounds(editor.getEditPart(ECLASS_PROVIDED, AbstractDiagramNodeEditPart.class)); 
 * Copyright (c) 2014, 2015 Ecole Polytechnique de Montreal and others 
 * Copyright (c) 2015 Ericsson 
 if (worker == null) { return; } 
 String[] args = commandLine.split("\\s+"); //$NON-NLS-1$ 
 return readNode; 
 analysisIds.add(oneAnalysis.getAttribute(TmfXmlStrings.ID)); 
 super(checkNotNull(definition.definitionName), getRootField(definition)); 
 ITmfStateSystemBuilder stateSystem = fStateSystem; if (stateSystem == null) { return Collections.EMPTY_SET; } return Collections.singleton(stateSystem); 
 return output.split("\\r?\\n"); //$NON-NLS-1$ 
 IRemoteConnectionType type = manager.getLocalConnectionType(); if (type != null) { CONNECTION_FACTORIES.put(checkNotNull(type.getId()), new LocalConnectionFactory()); } 
 String type = stream.readUTF(); 
 * Copyright (c) 2000, 2015 IBM Corporation and others. 
<|del|> 
 * Copyright (c) 2015 Luis Yanes. 
 throw new UnsupportedOperationException("Invoking this action from the editor is not supported"); 
<|del|> 
 private final RGBA fColor; private final RGBA fOddColor; 
 for (int i = 0; i < parameterTypes.size() && result; i++) { 
<|del|> 
 * Predicates that is <code>true</code> if and only if all first service's parameter types are the same as 
 * @throws TmfAnalysisException * If exception occurs * @throws IOException * If exception occurs * @throws TmfTraceException * If exception occurs 
 TmfTrace testTrace = new LttngKernelTrace(); 
 * Use {@link ValgrindStackFrame#getSourceLocator()} to resolve locations instead * @return launch object 
 return new Class[] { Repository.class }; 
 /** Cached attributes handler */ private AttributesHandler attributesHandler; 
 private static final Image CHECKED = org.eclipse.papyrus.infra.widgets.Activator.getDefault().getImage(Activator.PLUGIN_ID, "icons/checked.gif"); //$NON-NLS-1 
 private static final Image UNCHECKED = org.eclipse.papyrus.infra.widgets.Activator.getDefault().getImage(Activator.PLUGIN_ID, "icons/unchecked.gif"); //$NON-NLS-1$ 
<|del|> 
 public static final @NonNull Collection<@NonNull ITmfEventAspect<?>> BASE_ASPECTS = ImmutableList.of( TmfBaseAspects.getTimestampAspect(), TmfBaseAspects.getEventTypeAspect(), TmfBaseAspects.getContentsAspect() ); 
 private final Map<String, IAnalysisModule> fAnalysisModules = Collections.synchronizedMap(new LinkedHashMap<String, IAnalysisModule>()); 
 throws TmfTraceException { 
 * @param trace the original trace * @throws TmfTraceException Should not happen usually 
<|del|> 
<|del|> 
 HashMap<String, String> dsKeys = new HashMap<>(); HashSet<DSAnnotationProblem> problems = new HashSet<>(); 
 Bundle bundle = FrameworkUtil.getBundle(Activator.class); 
 final String str = "ssh://user.name@example.com:pass@word@example.com:33/some/p ath"; 
 public synchronized Set<GAV> getProjectGAVs() { 
 String text = (String) clipboard .getContents(TextTransfer.getInstance()); 
 text = stripGitCloneCommand(text); 
 final TreeWalk tw = new TreeWalk(repo)) { 
 private static boolean startsWith(byte[] a, byte[] b, int n) { if (b.length < n) { 
 public void testDisplayTextInitial() { 
 /** * use the label of the {@link AbstractRadioButton} contained in this field as display text instead of relying on * {@link Object#toString()} of validValue */ 
<|del|> 
 viewpoint = (Viewpoint) domain.getResourceSet().getEObject(EcoreUtil.getURI(viewpoint), true); 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2014,2015 Obeo. 
 // The following assert is valid for: "aql:" "[/]" "ocl:" "var:" // "service:" and "feature:" 
 // The following assert is valid for: "aql:" "[/]" "ocl:" "var:" // "service:" and "feature:" 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2015 THALES GLOBAL SERVICES and others. 
 assertNotNull("The variable" + ToolPackage.Literals.CREATE_VIEW__VARIABLE_NAME.getDefaultValueLiteral() + " should be available to reference the created view", 
 * Map (i.e. Map<?>), DisassemblyDocument treated sometimes as a Map<String, * List<Position>> and sometimes as Map<String, List 
<|del|> 
 String workDir = System.getProperty("git_work_tree"); if (workDir == null) { workDir = "."; 
 try (Repository db = new FileRepository(workDir + "/.git")) { 
 int lineLimit = Integer.valueOf(OseeInfo.getCachedValue(ATTR_FORM_PART_LINE_LIMIT)); 
 protected void doLaunch(String programName) throws Exception { 
 super(ActionCommands.MERGE_TOOL_ACTION, new ModelMergeToolActionHandler()); 
 SWTBotUtils.switchToTracingPerspective(); 
 * Use reflection to access the table viewer 
 * will be logged. 
 return Collections.emptyMap(); 
 IASTFunctionDefinition functionDefinition = findAncestorWithType(node, IASTFunctionDefinition.class); 
 this.titleImage = dialogTitleImage; this.message = dialogMessage; 
 return String.format("Core Node, %d children %s", //$NON-NLS-1$ 
 public static final IAttributeType ImageContent = TokenFactory.createAttributeType(0x100000000000037CL, "Image Content"); public static final IAttributeType IdValue = TokenFactory.createAttributeType(0x100004651100057L, "ID Value"); 
<|del|> 
 public IASTStatement[] labels = IASTLabelStatement.EMPTY_LABEL_STATEMENT_ARRAY; 
 IBinding[] result = ILabel.EMPTY_LABEL_ARRAY; 
 } else { Object result = vpInterpreter.evaluate(target, expression); final IStatus status = createResultStatus(result); 
 } else { Object result = vpInterpreter.evaluate(target, expression); final IStatus status = createResultStatus(result); 
 // Fallback to the original behavior if we are not using an // IEvaluationResult but a regular object 
 if (!SystemGroup.OseeAccessAdmin.isCurrentUserMember() && policyTableViewer.getAccessControlList().size() > 0) { 
 * Copyright (c) 2016 Ericsson 
<|del|> 
 ICommandService commandService = (ICommandService) PlatformUI.getWorkbench() .getService(ICommandService.class); 
 for (CommentAnnotation annotation : Iterables.filter(annotationInput.getAnnotations(), CommentAnnotation.class)) { 
 ICommandService commandService = (ICommandService) PlatformUI.getWorkbench() .getService(ICommandService.class); 
 /** * The backend tracks its end time separately from the tree, to take into * consideration intervals in the queue. */ 
 private final @NonNull Thread shtThread; /** The backend tracks its end time separately from the tree, to take into consideration intervals in the queue. */ 
 if (t <= getSHT().getTreeEnd()) { 
 if (t <= getSHT().getTreeEnd()) { 
 throw new TimeRangeException(String.format("%s Time:%d, Start:%d, End:%d", //$NON-NLS-1$ getSSID(), t, getStartTime(), fEndTime)); 
 throw new TimeRangeException(String.format("%s Time:%d, Start:%d, End:%d", //$NON-NLS-1$ getSSID(), t, getStartTime(), fEndTime)); 
 if (line.contains(XmlTags.CHANGE_PACKAGE_START)) { startOffset = raf.getFilePointer(); } else if (line.contains(XmlTags.OPERATIONS_START_TAG)) { 
 return startOffset; 
 boolean withinOperationsElement = false; 
 final AbstractValidateCommand validationCommand = new AsyncValidateSubtreeCommand(semanticObject); 
 // ValidateSubtreeCommand validationCommand = new ValidateSubtreeCommand(semanticObject); 
 total += getChecked(child); 
 this.annotationInput = (CommentAnnotationHoverInput) input; 
 if (annotation.getPosition().offset <= offset && (annotation.getPosition().length + annotation.getPosition().offset) >= offset) { return annotation; 
 m.put("sec", u); //$NON-NLS-1$ m.put("secs", u); //$NON-NLS-1$ 
 m.put("min", u); //$NON-NLS-1$ m.put("mins", u); //$NON-NLS-1$ 
 m.put("hr", u); //$NON-NLS-1$ m.put("hrs", u); //$NON-NLS-1$ 
 if (promptText.matches("(?i)(\\bpassword\\b|\\bpassphrase\\b)(\\s)?(for)?(\\s)?(.*)?(:?)")) { //$NON-NLS-1$ 
 /** * Rich Text Editor control that wraps CKEditor, a web-based WYSIWYG/Rich-Text editor. * * @see <a href="http://ckeditor.com/">http://ckeditor.com/</a> * * @since 3.1 */ 
<|del|> 
 final IValidationResult aqlValidationResult = validator.validate(trimmedExpression, variableTypes); 
/** * A {@link Round} for a leaderless repository. Inserts a new "term" commit * object that is used to guarantee election safety, preventing two replicas * from thinking that they are the leader at the same time. */ 
 msg.append(' ').append(tag); 
 /** End of the leader's log. */ private LogIndex head; 
 /** * A {@link Round} is in progress, attempting to push one or more * {@link Proposal}s to other replicas. */ 
 * @return opened repository for use by the leader thread. 
 * the proposed reference updates to queue for consideration. * Once execution is complete the individual reference result * fields will be populated with the outcome. 
 /** * @return state leader knows it has committed across a quorum of replicas. */ 
 /** * Send the commit immediately, even if it could be batched with the * next proposal. */ 
 /** * Send the commit immediately, even if it could be batched with the * next proposal. */ 
 /** * Send the commit immediately, even if it could be batched with the * next proposal. */ 
 /** * Batch the commit with next proposal, which generates less network * use, but may provide slower consistency on the replica. */ 
 /** Current state of a replica. */ 
 /** Replica can not be contacted. */ 
 * unique-ish name identifying this replica for debugging. 
 /** @return description of this replica for error/debug logging purposes. */ 
 this(defaultExecutor(), DEFAULT_TXN_NAMESPACE); 
 List<KetchReplica> replicas = new ArrayList<>(); 
 if (!hasParticipation(cfg, name)) { 
 /** * Initializes local replica by reading accepted and committed references. * <p> * Loads accepted and committed references from the reference database of * the local replica and stores their current ObjectIds in memory. * 
 boolean isBefore(LogId c) { return index <= c.index; } 
 * Proposal was validated and has entered the queue, but a round 
 * Proposal was validated and has entered the queue, but a round 
 commands = Collections.unmodifiableList(new ArrayList<>(cmds)); 
 /** @return optional author of the proposal. */ 
 /** @return optional message for the commit log of the RefTree. */ 
 * @return {@code true} if the proposal was attempted. A true value does not * mean consensus was reached, only that the proposal was considered * and will not be making any more progress beyond its current * state. 
 private static void format(StringBuilder s, @Nullable Ref r, String n) { 
/** A {@link Round} that aggregates and sends user {@link Proposal}s. */ 
 Matcher m = UnitMap.PATTERN.matcher(valStr); 
 return commands; 
/** Constructs a set of commands to stage content during a proposal. */ 
 private static final byte[] PEEL = { ' ', '^' }; 
 * source repository to read {@code oldTree} and {@code newTree} * from. 
 * {@code git} cannot be accessed to compare {@code oldTree} and * {@code newTree} to build the object set. 
 * Construct a set of commands to stage objects on a replica. 
 * objects to send to a replica. 
 String name = "Ketch Stage"; //$NON-NLS-1$ 
 * Copyright (C) 2016, Google Inc. 
<|del|> 
 String key = computeKey(repo); 
 return dfs.getDescription().getRepositoryName(); } 
 * Copyright (C) 2016, Google Inc. 
 * PreReceiveHook for handling push traffic in a Ketch system. 
 * Copyright (c) 2016 Nathan Ridge. 
 private static final int VERSION_5_0 = version(5, 0); 
 private final TaskAttribute taskAttribute; 
 context.set(IPresentationEngine.class, this); 
 factory = (IRendererFactory) contribFactory.create(factoryUrl, context); 
 * Wraps a JGit ProgressMonitor in an object conforming to IProgressMonitor. 
 if (SysMLResource.isSysMLProfileApplied(element)){ 
 * The initial {@link Round} for a leaderless repository, used to establish a * leader. 
<|del|> 
 * A leader managing consensus across remote followers. 
 * appended to the end of {@link #queued}. * <p> * Must be deep-copied with {@link RefTree#copy()} if * {@link #roundHoldsReferenceToRefTree} is {@code true}. 
 /** End of the leader's log. */ private LogIndex head; 
 /** End of the leader's log. */ private LogIndex head; 
 public void queueProposal(Proposal proposal) 
 * Replicas can be either a stock Git replica, or a Ketch-aware replica. 
 /** Participation of a replica in establishing consensus. */ 
 * If the next proposal is available, batch the commit with it, * otherwise just send the commit. This generates less network use, but * may provide slower consistency on the replica. 
 void pushTxnAcceptedAsync(Round round) { 
 LogIndex committed = leader.getCommitted(); if (equals(txnAccepted, committed) && !equals(txnCommitted, committed)) { prepareTxnCommitted(cmds, committed); 
 void pushCommitAsync(ObjectId committed, boolean leaderIsIdle) { 
 private void prepareTxnCommitted(List<ReceiveCommand> cmds, ObjectId committed) { 
 for (ReceiveCommand nextCmd : req.getCommands()) { ReceiveCommand priorCmd = waiting.get(nextCmd.getRefName()); if (priorCmd == null) { priorCmd = running.get(nextCmd.getRefName()); 
 protected abstract void startPush(ReplicaPushRequest req); 
 state = checkLagging(repo, acceptCmd, req); 
 protected Collection<ReceiveCommand> prepareCommit(Repository git, 
/** A snapshot of a leader and its view of the world. */ 
 // advertisement. If they failed, store the current values // back in the ReplicaPushRequest. 
 * run on the leader thread and should be completed quickly. 
 // Fast path: tree is passed in with only one proposal to run, // and it already has the proposal applied. 
 leader.roundHoldsReferenceToRefTree = false; 
 ObjectId lastIndex = acceptedOldIndex; ObjectId oldTreeId; 
 if (ObjectId.zeroId().equals(lastIndex)) { oldTreeId = ObjectId.zeroId(); 
 .append(": ") //$NON-NLS-1$ .append(leader.getTerm()); 
 // For each branch, collapse consecutive updates to only most recent, // avoiding sending multiple objects in a rapid fast-forward chain, or // rewritten content. 
 * {@link KetchLeader} will contact the replica using the Git wire protocol. * <p> * The remote replica may be fully Ketch-aware, or a standard Git server. 
 try (Transport transport = Transport.open(repo, uri)) { 
 private static boolean isExpectedValue(Map<String, Ref> adv, RemoteRefUpdate u) { 
 for (ReceiveCommand cmd : prepareCommit(git, adv, committed)) { 
 for (RemoteCommand cmd : cmds) { m.put(cmd.getRemoteName(), cmd); 
 * A snapshot of a replica. 
 final LogIndex acceptedOldIndex; LogIndex acceptedNewIndex; 
 * If references are being updated (such as in a {@link ProposalRound}) the * RefTree may be modified. * <p> * Invoked without {@link KetchLeader#lock} to build objects. 
 * If references are being updated (such as in a {@link ProposalRound}) the * RefTree may be modified. * <p> * Invoked without {@link KetchLeader#lock} to build objects. 
 * Invoked by the leader with {@link KetchLeader#lock} held by the caller. 
 * attempt to decrease the reference count by chaining commits.. 
 // 'commits' is sorted most recent to least recent commit. 
 int start = Math.max(0, end - TEMP_PARENTS); 
 * IEventDefinition, an interface for representing individual events. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 @NonNull Set<@NonNull String> getCustomAttributes(); 
<|del|> 
 String message = this.getDefaultMessage(result); 
 Bundle bundle = FrameworkUtil.getBundle(ElementTypesRegistryTests.class); 
 * copy to isolate it from any running rounds. 
 LogIndex committed = leader.getCommitted(); if (!equals(txnCommitted, committed) && shouldPushUnbatchedCommit(committed, leader.isIdle())) { pushCommitAsync(committed); 
/** * A helper to check if a {@link KetchReplica} is ahead or behind the leader. */ 
 * A proposal is done when it has entered either {@link State#EXECUTED} or * {@link State#ABORTED} state. If the proposal is already done * {@code callback.run()} is immediately invoked on the caller's thread. 
 private Map<String, Ref> push(Repository git, Transport transport, List<RemoteCommand> cmds) throws IOException { 
 * Creates a commit for {@code refs/txn/accepted} and calls 
 private static final int TEMP_PARENT_BATCH_SIZE = 128; 
 * id of the object to be verified * @return Action for verifying the object, or {@code null} if the server * doesn't support or require verification 
 public @Nullable Response.Action getVerifyAction(AnyLongObjectId id); 
<|del|> 
<|del|> 
 Upload(LargeFileRepository repository, 
 * @since 4.3 
 private final AnyLongObjectId contentHash; 
 * @return the id of the object, i.e. the expected hash of the object's * content 
 * @return the actual hash of the object's content which doesn't match the * object's id when this exception is thrown which signals that the * object has been corrupted 
 * Creates an instance of {@link IEventDefinition} corresponding to this * declaration. 
 * @return A new {@link IEventDefinition} 
<|del|> 
 IEventDefinition readNextEvent() throws CTFException; 
 lowestTimeAxisOffset = getClampedTimeAxisOffset(referenceView.getTimeViewAlignmentInfo()); 
 if (gtkVersion != null) { 
<|del|> 
 static final String BR = System.getProperty("line.separator"); 
 if (o1 == null || o2 == null || o1.getName() == null || o2.getName() == null) { 
 transactionIds.add(transId); 
<|del|> 
<|del|> 
 // TODO: This code is common between computeSize and layout int gapBetweenTcAndLabel = (textClient != null && textLabel != null) ? IGAP : 0; 
public class ExpandableCompositeTest { 
 GridLayoutFactory.fillDefaults().applyTo(shell); 
 GridLayoutFactory.fillDefaults().applyTo(comp); 
 checkSizeEquals(w, h); checkSizeEquals(w / 2, h * 2); checkSizeEquals(w * 2, h * 2); checkSizeEquals(1, SWT.DEFAULT); checkSizeEquals(0, SWT.DEFAULT); checkSizeEquals(SWT.DEFAULT, 1); 
 InputStream is; 
 conflictDetector = new MatchBasedConflictDetector(); 
<|del|> 
<|del|> 
 public Collection<ReferenceChange> getReferenceChangesByValueMatch(Match valueMatch) { 
 /** * {@inheritDoc} * * @see org.eclipse.eef.core.api.EEFPage#getLabel() */ 
 /** * {@inheritDoc} * * @see org.eclipse.eef.core.api.EEFPage#getGroups() */ 
 /** * {@inheritDoc} * * @see org.eclipse.eef.core.api.EEFPage#getDescription() */ 
 /** * {@inheritDoc} * * @see org.eclipse.eef.core.api.EEFPage#getVariableManager() */ 
 * Copyright (c) 2016 Obeo. 
 * Shared utility methods. * * @author Pierre-Charles David <pierre-charles.david@obeo.fr> 
 private static final int VERSION = 10; 
 * Copyright (c) 2010, 2016 THALES GLOBAL SERVICES and others. 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (remote != null) { 
 Assert .assertTrue(project.getLocation().toFile().getCanonicalPath().startsWith(outputDirectory.getCanonicalPath())); 
 * The column index of the cell to copy. 
 innerHeight -= marginHeight * 2; 
 int textHeight = textSize.y + 2 * marginHeight; if (wHint != SWT.DEFAULT) { textWidth = wHint; } if (hHint != SWT.DEFAULT) { textHeight = hHint; } 
 return new Point(widthHint, heightHint); 
 result.x = widthHint; 
 result.y = heightHint; 
 if (widthHint == preferredSize.x) { 
 if (widthHint >= preferred.x) { return new Point(widthHint, preferred.y); 
 if (widthHint >= preferred.x) { return new Point(widthHint, preferred.y); 
 if (heightHint == preferredSize.y) { 
 if(iter.next().getPath().equals(descriptor.getPath())) { 
 * Lars Vogel <Lars.Vogel@vogella.com> - Bug 486889 
 * Copyright (c) 2007, 2016 IBM Corporation and others. 
 * IBM Corporation - initial API and implementation * Lars Vogel <Lars.Vogel@vogella.com> - Bug 486889 
 * Lars Vogel <Lars.Vogel@vogella.com> - Bug 486889 
 * Lars Vogel <Lars.Vogel@vogella.com> - Bug 486889 
 * Copyright (c) 2010, 2016 IBM Corporation and others. 
 * Copyright (c) 2009, 2016 IBM Corporation and others. 
 if (!Util.isBlank(domainClassExpression) && !Util.isBlank(switchExpression)) { 
 switchExpressionVariables.put(EEFExpressionUtils.SELF, this.variableManager.getVariables().get(EEFExpressionUtils.SELF)); 
 * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2016 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2016 THALES GLOBAL SERVICES and others. 
 if (resource != null && domain.isReadOnly(resource)) { 
<|del|> 
<|del|> 
 public Variable[] getVariables(final TestSuite testSuite) { if (testSuite == null) throw new RuntimeException("TestSuite must not be null"); return testSuite.getModel().getVariables().toArray(new Variable[0]); 
 * opened TestSuite * @param identifier 
 public void setVariable(final TestSuite testSuite, final String identifier, final String content, 
 private final int fCore; private final String fHostId; 
 private final HostThread fHostThread; 
 * Mickael Istria (Red Hat Inc.) - [486901] Avoid blocking URL.equals 
 if (url != null && (productUrl == null || !url.toString().equals(productUrl.toString())) { 
 * IBM Corporation - initial API and implementation 
 /** * The main semantic element associated with the input, if it could be * determined unambiguously. */ private final EObject mainSemanticElement; 
 /** * Returns the {@link DSemanticDecorator} associated to the input, which is * only available if the input is itself a {@link DSemanticDecorator}. * * @return the {@link DSemanticDecorator} associated to the input. */ 
 * Mickael Istria (Red Hat Inc.) - [486901] Avoid blocking URL.equals 
 if (url != null && (productUrl == null || !url.toString().equals(productUrl.toString()))) { 
 if (prefix.isEmpty()) { 
 * </ol> * </ol> 
 * </ol> * </ol> 
 IUnknownEditorStrategy strategy = getUnknowEditorStrategy(allowInteractive); if (strategy == null) { 
<|del|> 
 * none is explicitly configured. Never returns {@code null}. 
 } IDEWorkbenchPlugin.log("No editor strategy found for " + strategyId); //$NON-NLS-1$ 
 if (oldTree != null && oldTreeish != null) { // The setter for each clears the other. throw new AssertionError(); } else if (oldTree != null) { 
 Assert.assertEquals(uuid, sprint.getUuid()); 
 return Long.valueOf(getArtId()); 
 return Long.valueOf(artifact.getArtId()); 
 return Long.valueOf(user.getArtId()); 
 return Long.valueOf(456); 
 return 999994L; 
 return 0L; 
 return Long.valueOf(artId); 
 return Long.valueOf(self.getArtId()); 
 return 0L; 
 default boolean matches(UuidIdentity... identities) { for (UuidIdentity identity : identities) { if (equals(identity)) { return true; } } return false; } 
 return String.format("artifact [type=[%s] guid=[%s] branch=[%s]]", getArtifactType(), getGuid(), getBranchId()); 
 return Long.valueOf(getLocalId()); 
 public static String SmartImportWizardPage_expandingArchive; public static String SmartImportWizardPage_deletingDirectory; 
 } return hasBeenRefreshed; 
 final int INVALID_ATTRIBUTE = -2; 
 * Copyright (c) 2016 cole Polytechnique de Montral 
 * @author Julien Daoust * @author Najib Arbaoui 
 String eventHRTimerExpireExit(); 
<|del|> 
<|del|> 
 } catch (StateSystemDisposedException | AttributeNotFoundException e) { Activator.getDefault().logError(e.getMessage(), e); 
@SuppressWarnings("javadoc") 
 private static final String BUNDLE_NAME ="org.eclipse.tracecompass.analysis.os.linux.ui.views.kernelmemoryusage.messages"; //$NON-NLS-1$ 
 return ArtifactQuery.getArtifactFromId(new Long(uuid).intValue(), CoreBranches.COMMON, 
 * 
 * 
 new WizardDialog(workbench.getActiveWorkbenchWindow().getShell(), wizard).open(); return null; 
 * 
<|del|> 
 workingSetsBlock = new WorkingSetConfigurationBlock(getDialogSettings(), "org.eclipse.ui.resourceWorkingSetPage"); //$NON-NLS-1$ 
 IContainer container = Adapters.adapt(root, IContainer.class); 
 IContainer container = Adapters.adapt(root, IContainer.class); 
<|del|> 
<|del|> 
<|del|> 
 if (resource != null && domain.isReadOnly(resource)) { 
 if (Arrays.asList(fFieldNames).contains(name)) { Activator.log(IStatus.WARNING, "Struct already contains a field named " + name); //$NON-NLS-1$ 
 @NonNull IDeclaration[] fields = Arrays.copyOf(fFields, fFields.length + 1); 
 @NonNull String[] names = Arrays.copyOf(fFieldNames, fFieldNames.length + 1); 
 List<IDeclaration> localDecs = Arrays.asList(fFields); List<IDeclaration> otherDecs = Arrays.asList(other.fFields); 
 List<IDeclaration> localDecs = Arrays.asList(fFields); List<IDeclaration> otherDecs = Arrays.asList(other.fFields); 
 Activator.log(IStatus.WARNING, "Number conversion issue with " + text + ". Assigning " + key + " = 0."); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ 
 AtsCoreClient_Suite.class, // 
 OseeLog.log(AbstractAtsConfigQueryImpl.class, Level.SEVERE, "Null found in results"); 
 getQuery().and(attrType, values); 
 * <code>==<code> operator. 
 // If the semantic doesn't belong to a session we don't check 
 // If the semantic doesn't belong to a session we don't check 
 // If the semantic doesn't belong to a session we don't check 
<|del|> 
<|del|> 
 * Copyright (c) 2016 CEA LIST 
 public static final String PLUGIN_ID = "org.eclipse.papyrus.designer.languages.cpp.reverse.ui"; //$NON-NLS-1$ 
 /** * Dialog to select a file in the workspace. The file can be filetered by extension. * */ 
 * Copyright (c) 2016 CEA LIST. 
 /** * Handler for the "Reverse to existing model (merge)" command * */ 
 /** * Handler for the "Reverse to existing model (overwrite)" command * */ 
 ResourceFileSelectionDialog fileSelector = new ResourceFileSelectionDialog("UML file selector", "Select a UML file", types); // $NON-NLS-1$ 
 Job job = new Job("Reversing project " + cProject.getElementName() + " to existing UML model (overwrite)") { // $NON-NLS-1$ 
 Job job = new Job("Reversing project " + cProject.getElementName() + " to existing UML model (overwrite)") { // $NON-NLS-1$ 
 /** * Handler for the "Reverse to new model" command * */ 
 /** * A listener that detects changes on a CDT project. * The events and processed and the listener feeds a map * that will be used for reverse in merge mode. * */ 
 e.printStackTrace(); 
 } 
 package org.eclipse.papyrus.designer.languages.cpp.reverse.reverse.change; 
 package org.eclipse.papyrus.designer.languages.cpp.reverse.utils; 
 resource = resourceSet.createResource(URI.createURI(uri)); 
 protected @NonNull TmfViewer createLeftChildViewer(Composite parent) { @NonNull KernelMemoryUsageComposite fTreeViewer = new KernelMemoryUsageComposite(parent); fTreeViewerReference = fTreeViewer; 
 fTmfViewer = createLeftChildViewer(fSashForm); 
 * @since 4.3 
 * @since 4.3 
 public static enum EolStreamType { 
 * This is the former AutoLFInputStream with a new name in order to have same * naming for all LF / CRLF streams 
<|del|> 
<|del|> 
 write(b, b.length - overflow, overflow); } 
 * 
 * @since 4.3 
 * @since 4.3 
 return display.COLOR_WIDGET_BACKGROUND; 
<|del|> 
 * 
 if (!Util.isBlank(diagnostic.getMessage())) { 
 if (!Util.isBlank(childDiagnostic.getMessage())) { 
 * Copyright (c) 2016 Obeo. 
 * The preferences of the bundle EEF Common. 
 * The EEF Common preference scope. 
 EEFIdeUiPlugin.getPlugin().debug("EEFSection#createControls(...)"); //$NON-NLS-1$ 
 * Copyright (c) 2015, 2016 Obeo. 
 * Copyright (c) 2015, 2016 Obeo. 
 * Copyright (c) 2015, 2016 Obeo. 
 assertEquals(0, value); 
 * Wassim Nasrallah - Initial implementation 
 * @return The currently active editor if it's an SiriusDiagramEditor, 
 * Get the variable defined by the given <i>identifier</i>. If the model does not contain the variable <code>null</code> is returned. 
<|del|> 
 * Check if the variable exists in the current model defined by its <i>identifier</i>. 
 Variable variable = getVariable(identifier); if (variable != null) { variable.setContent(content); fDirty = true; return; } // identifier not found create new variable this.addVariable(identifier, content, null); 
 * Set the content of a variable defined by the given <i>identifier</i>. If the variable with the given <i>identifier</i> already exists the content and * description is replaced. 
<|del|> 
 variable.setDescription(description); 
 variable.setDescription(description); 
 return; removeVariable(variable); 
 return; removeVariable(variable); 
 * Copyright (c) 2016 Bernhard Wedl and others. 
 * Copyright (c) 2016 Bernhard Wedl and others. 
 for (int index = 0; index < elements; index++) { testSuite.setVariable(variableIndentifier[index], variableContent[index], variableDescription[index]); } 
 public void addVariable() { 
<|del|> 
 double /*float*/ [] enabledLinkForeground, disabledLinkForeground; NSColor defaultEnabledLinkColor; 
 * Returns the link foreground color for the given enabled state. * @see Link#getEnabled() to get the current enabled state. 
 if (enabled) { if (equals (linkForeground, this.enabledLinkForeground)) return; this.enabledLinkForeground = linkForeground; } else { if (equals (linkForeground, this.disabledLinkForeground)) return; this.disabledLinkForeground = linkForeground; } updateLinkColor (enabled); 
 int INVALID_ATTRIBUTE = -2; 
<|del|> 
 * white 20% + WIDGET_BACKGROUND 60% end colour WIDGET_NORMAL_SHADOW * 100% + WIDGET_BACKGROUND 40% 
 if (e.x >= fTimeProvider.getNameSpace()) { 
 * Alexandra Buzila - bug 487119 
 int width = gc.textExtent(label).x + TEXT_MARGIN; 
 return label.substring(0, Math.min(label.indexOf(SWT.LF) != -1 ? label.indexOf(SWT.LF) : label.length(), MAX_LABEL_LENGTH)); 
 return Math.min(Math.max(x, -X_LIMIT), X_LIMIT); 
 * @author Mahdi Zolnouri * @author Wassim Nasrallah 
<|del|> 
 // farEndOwner cannot be null if( isRelayBorderPortInstance( farEndOwner ) ) 
 * <xmp>replaces &, ", ', <, > and all whitespace</xmp> 
<|del|> 
 buf.append("<tr><td>" + ScoutTexts.get("DetailedVersion") + ":</td><td>&nbsp;</td><td>" + HtmlHelper.escape(v.toString()) + "</td></tr>"); 
 text = HtmlTextUtility.escapeHtmlCapableText(m_env.getHtmlValidator(), cell, text); return StringUtility.convertPlainTextNewLinesToHtml(text, !isWrapText()); // !wrapText means that breakable chars should be replaced 
 if (!(obj instanceof IHtmlCapable)) { LOG.error("Passed object with text {} is not an instance of {}.", text, IHtmlCapable.class); 
 private final Set<IMarkerAxisListener> fListeners = new LinkedHashSet<>(); 
 private static final @NonNull String LOST_EVENTS = checkNotNull(Messages.MarkerEvent_LostEvents); 
<|del|>
 private static class SynchronizationModelDiagnosticProvider { 
 // node.js server throws error /* * String message = IOUtils.toString(in); if * (StringUtils.isEmpty(message)) { throw new * TernException(statusLine.toString()); } throw new * TernException(message); */ 
 * Select Git Flow feature branches. 
 List<Ref> refs, String title, String message, 
 viewer.addSelectionChangedListener(new ISelectionChangedListener() { 
 viewer.addDoubleClickListener(new IDoubleClickListener() { 
 return new ColumnLabelProvider() { 
 * Copyright (C) 2015, Max Hohenegger <eclipse@hohenegger.eu> 
 /** * Customization of {@link ConcernDescriptionImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
 /** * Customization of {@link FilterDescriptionImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
 /** * Customization of {@link EdgeMappingImportImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
 /** * Customization of {@link ToolGroupImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
 * @not-generated 
 * Copyright (c) 2015, 2016 Obeo. 
 * @not-generated 
 /** * Customization of {@link TreeDescriptionImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
 /** * Customization of {@link IdentifiedElementImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
 /** * Customization of {@link PaneBasedSelectionWizardDescriptionImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
 /** * Customization of {@link SelectModelElementVariableImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
 /** * Customization of {@link SelectionWizardDescriptionImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ 
<|del|> 
 for (Entry<String, ?> entry : map.entrySet()) { Object key = entry.getKey(); 
 * Mickael Istria (Red Hat Inc.) - Bug 485227 
 private static IRegistryChangeListener runtimeExtensionListener = new ContentTypeRegistryChangeListener(); private static IRegistryChangeListener contentExtensionListener = new ContentTypeRegistryChangeListener(); 
public class ContentTypeManager extends ContentTypeMatcher implements IContentTypeManager { 
 "Committed - baseline/commited branch \nUnmodified - Related artifact has not changed " + "\n<date> - Related artifact has been modified after task at the specified date \nEmpty - There is no related artifact"); 
 return DateUtil.getMMDDYYHHMM(refArt.getLastModified()); 
<|del|>
<|del|> 
 kernelState1 = ss.querySingleState(0L, 0); 
 private String getCurrentIntervalStateValue(String tid, ITmfStateSystem kernelSs, List<Integer> cpuNodes) { String execName = null; 
 execNameInterval.getStateValue().getType().equals(ITmfStateValue.Type.STRING)) { 
 * Copyright (c) 2008, 2016 Code 9 Corporation and others. 
 return parent.getSelectedElement() == element; 
 return element.isVisible(); 
 return getEditorDescriptor(file, true); 
<|del|> 
<|del|> 
 * Dirk Fauth <dirk.fauth@googlemail.com> - Bug 488234 
 * Dirk Fauth <dirk.fauth@googlemail.com> - Bug 488234 
 gridData.heightHint = scrollbarHeight; 
 * (and its whole sub-tree) that was previously used and is no longer required. * This class keeps a list of children attributes of a base quark and grows that * list as needed. 
 * otherwise a new quark will be created under the base quark. The name of * the attributes is a sequential integer. So the first quark to be added * will be named '0', the next one '1', etc. 
 // Fraction of a function duration to be added as spacing private static final double SPACING_RATIO = 0.01; 
<|del|>
 // Remove traces that were unchecked (thus left in fPreviousTraces) 
<|del|> 
 } else if (localName.equals(TaskRepositoriesExternalizer.ELEMENT_TASK_REPOSITORYV2) || currentV2Repository != null) { 
 if (currentV2Repository != null && localName.equals(TaskRepositoriesExternalizer.ELEMENT_TASK_REPOSITORYV2)) { taskRepositoriesV2.add(currentV2Repository); currentV2Repository = null; 
<|del|>
 public String getMessage(String value) { if (value != null && value.startsWith(PERCENT)) { // TODO find the corresponding message } return value; 
 public String getMessage(String value) { if (value != null && value.startsWith(PERCENT)) { // TODO find the corresponding message } return value; 
 public String getMessage(String value) { if (value != null && value.startsWith(PERCENT)) { // TODO find the corresponding message } return value; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (!element.isVisible()) { return false; } if (isMinimized(parent) || isMinimized(element)) { return false; } return true; 
<|del|>
 /** * The named style id for the slider composite width. */ 
 private final @Nullable TmfExperimentElement fExperimentElement; private final @NonNull List<TmfTraceElement> fTraceElements; private final @NonNull Map<String, TmfTraceElement> fPreviousTraces; private @NonNull IStatus fStatus = checkNotNull(Status.OK_STATUS); 
 private final @Nullable TmfExperimentElement fExperimentElement; private final @NonNull List<TmfTraceElement> fTraceElements; private final @NonNull Map<String, TmfTraceElement> fPreviousTraces; private @NonNull IStatus fStatus = checkNotNull(Status.OK_STATUS); 
 private final @Nullable TmfExperimentElement fExperimentElement; private final @NonNull List<TmfTraceElement> fTraceElements; private final @NonNull Map<String, TmfTraceElement> fPreviousTraces; private @NonNull IStatus fStatus = checkNotNull(Status.OK_STATUS); 
 private final @Nullable TmfExperimentElement fExperimentElement; private final @NonNull List<TmfTraceElement> fTraceElements; private final @NonNull Map<String, TmfTraceElement> fPreviousTraces; private @NonNull IStatus fStatus = checkNotNull(Status.OK_STATUS); 
 bot.waitUntil(waitForEditor(new BaseMatcher<IEditorReference>() { 
<|del|> 
 addResolver(new GlobalTemplateVariables.Selection(GlobalTemplateVariables.LineSelection.NAME, JavaTemplateMessages.CompilationUnitContextType_variable_description_line_selection)); 
<|del|> 
 addResolver(new GlobalTemplateVariables.Selection(GlobalTemplateVariables.LineSelection.NAME, JavaTemplateMessages.CompilationUnitContextType_variable_description_line_selection)); addResolver(new GlobalTemplateVariables.Selection(GlobalTemplateVariables.WordSelection.NAME, JavaTemplateMessages.JavaDocContextType_variable_description_word_selection)); 
 addResolver(new GlobalTemplateVariables.Selection(GlobalTemplateVariables.LineSelection.NAME, JavaTemplateMessages.CompilationUnitContextType_variable_description_line_selection)); addResolver(new GlobalTemplateVariables.Selection(GlobalTemplateVariables.WordSelection.NAME, JavaTemplateMessages.JavaDocContextType_variable_description_word_selection)); 
 * Copyright (c) 2000, 2016 IBM Corporation and others. 
 toolbarManager.appendToGroup("merge", new ReplyAction(gerritClient, 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (currentRepository != null && localName.equals(TaskRepositoriesExternalizer.ELEMENT_TASK_REPOSITORY)) { taskRepositories.add(currentRepository); currentRepository = null; 
 final AbstractTransactionalCommand transactionalCommand = new AbstractTransactionalCommand(domain, null, null) { 
 final boolean result = PapyrusFillHandlePasteCommandHandler.super.doCommand(targetLayer, command); return CommandResult.newOKCommandResult(Boolean.valueOf(result)); 
 final Object value = cell.getDataValue(); 
 final String number = stringValue.replace(templateString, ""); //$NON-NLS-1$ 
 if (MoveDirectionEnum.LEFT == command.direction || MoveDirectionEnum.RIGHT == command.direction) { 
 if (null != diff) { 
 if ((MoveDirectionEnum.UP == command.direction && !((PapyrusFillHandlePasteCommand) command).isIncrement()) || (MoveDirectionEnum.DOWN == command.direction && !((PapyrusFillHandlePasteCommand) command).isIncrement())) { 
 if ((MoveDirectionEnum.LEFT == command.direction && !((PapyrusFillHandlePasteCommand) command).isIncrement()) || (MoveDirectionEnum.RIGHT == command.direction && !((PapyrusFillHandlePasteCommand) command).isIncrement())) { 
 if ((MoveDirectionEnum.LEFT == command.direction && !((PapyrusFillHandlePasteCommand) command).isIncrement()) || (MoveDirectionEnum.RIGHT == command.direction && !((PapyrusFillHandlePasteCommand) command).isIncrement())) { 
 final Integer diff = calculateStringDiff(cells[rowArrayIndex][1], cells[rowArrayIndex][0], templateString); if (null == diff) { 
 final Integer diff = calculateStringDiff(cells[rowArrayIndex][1], cells[rowArrayIndex][0], templateString); if (null == diff) { 
 final Integer diff = calculateStringDiff(cells[rowArrayIndex][1], cells[rowArrayIndex][0], templateString); if (null == diff) { 
 if (null == temp || !temp.equals(diff)) { 
 diff = new Integer(Integer.parseInt(((String) c1.getDataValue()).replace(templateString, "")) - Integer.parseInt(((String) c2.getDataValue()).replace(templateString, ""))); //$NON-NLS-1$ //$NON-NLS-2$ 
 private static final String ICONS_REPLY = "icons/reply.png"; //$NON-NLS-1$ 
 TreeWalk tw = new TreeWalk(or); 
 TreeWalk tw = new TreeWalk(or)) { 
 * Copyright (C) 2015, Ivan Motsch <ivan.motsch@bsiag.com> * and other copyright owners as documented in the project's IP log. 
 TreeWalk walk = new TreeWalk(reader); 
 TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), 
 tw = new NameConflictTreeWalk(reader); 
 tw = new NameConflictTreeWalk(reader); 
 treeWalk = new TreeWalk(reader); 
 private Holder<String> cleanFilterCommandHolder; 
 * Copyright (C) 2010, 2013 Marc Strapetz <marc.strapetz@syntevo.com> * Copyright (C) 2015, Ivan Motsch <ivan.motsch@bsiag.com> 
 fail(e.getMessage()); 
/** * This analysis module retrieve a trace and * takes care of creating the state provider * 
 * In Linux, this typically means a user space application just got a page of 
 * In Linux, this typically means a page of ram was just freed 
 /** * This class represents an entry in the tree viewer of the kernel memory usage View. * * @author mahdi zolnouri * */ 
 /** * Constructor 
 * Copyright (c) 2010, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2016 Ericsson 
 private int fDragX = 0; private boolean fHasNamespaceFocus = false; 
 * @return the new instance * * @since 1.4 
 if ((address & (0xFFFFFFFF << 32)) == 0) { 
 private final Map<ITmfTrace, WeakReference<ISymbolProvider>> instances = new WeakHashMap<>(); 
 private static class SymbolProviderFactoryWrapper { 
 public final ISymbolProviderFactory factory; public final int priority; 
 // FIXME [SBE] I am commenting this code because while it's better it breaks the live edition in the workspace // if (this.eefPage.isUnique()) { // return this.eefPage.getDescription().getIdentifier(); // } 
 * Copyright (c) 2016 Boeing. 
 public Image getIcon() { 
 /* Let subclasses specify an icon */ return null; 
 return (getName() + " [" + nbTraces + ']'); //$NON-NLS-1$ 
 private File fileMixed; 
 private DirCache dc; 
 git.reset().setMode(ResetType.HARD).call(); fsTick(db.getIndexFile()); git.add().addFilepattern(".").call(); dc = db.readDirCache(); 
 DirCacheEntry dce = dc.getEntry(pathName); ObjectLoader open = walk.getObjectReader().open(dce.getObjectId()); e.index = new String(open.getBytes()); 
 class JobMonitor implements IProgressMonitorWithBlocking { 
<|del|> 
 private final @NonNull ITmfTrace fTrace; 
 public static enum SourceKind { 
<|del|> 
 */ @NonNullByDefault 
 private final ITmfTrace fTrace; 
<|del|> 
 * Mickael Istria (Red Hat Inc.) - Bug 488937 
 * Mickael Istria (Red Hat Inc.) - Bug 488938 
 if (null != resource.getContents() && 0 < resource.getContents().size() && resource.getContents().get(0) instanceof Folder) { 
 + "<TaskRepositories OutputVersion=\"2\">" // 
 assertEquals(serialized.lastIndexOf(labelPropertyValue), serialized.indexOf(labelPropertyValue)); 
<|del|> 
 checkEntryContent(entryCRLF, CONTENT_CRLF, CONTENT_LF); 
 * Lars Vogel <Lars.Vogel@vogella.com> - Bug 473427 
<|del|>
<|del|>
<|del|>
<|del|>
 * Lars Vogel <Lars.Vogel@vogella.com> - Bug 473427 
 if (!fCanvas.isVisible()) { 
 if (!fCanvas.isVisible()) { 
<|del|> 
<|del|> 
 @NonNull ITmfTrace getTrace(); 
<|del|> 
 * Copyright (c) 2016 Movidius Inc. and others 
 private @NonNull Map<String, String> fMapping = Collections.emptyMap(); 
 * Copyright (c) 2016 Movidius Inc. and others 
 * Copyright (c) 2016 Movidius Inc. and others 
 * Copyright (c) 2016 Movidius Inc. and others 
 * Copyright (c) 2016 Movidius Inc. and others 
 * Copyright (c) 2016 Movidius Inc. and others 
 * Copyright (c) 2016 Movidius Inc. and others 
 * Copyright (c) 2016 Movidius Inc. and others 
 if (!((eObject instanceof Property && ((ISpecializationType) SysMLElementTypes.BLOCK).getMatcher().matches(((Property) eObject).getType())))) { 
<|del|> 
<|del|> 
 ITmfContext context = fTrace.seekEvent(entry.getKey()); ITmfEvent event = fTrace.getNext(context); 
<|del|> 
 * This analysis module creates a stateprovider that keeps track of the memory * allocated and deallocated by the kernel 
<|del|> 
 return new KernelMemoryStateProvider(getTrace(), fLayout); 
 * We add an attribute to keep the lowest memory value for each thread. 
 long previousLowest = lowestMemoryValue.isNull() ? 0 : lowestMemoryValue.unboxLong(); 
 public String eventKmemPageAlloc() { 
 public String eventKmemPageFree() { 
 } 
 * Copyright (c) 2015, 2016 Obeo. 
 * The name of the extension point for the lifecycle manager provider. 
 * The {@link IItemRegistry} used to retrieve the lifecycle manager provider * {@link IEEFLifecycleManagerProvider}. 
 * The {@link IItemRegistry} used to retrieve the lifecycle manager provider * {@link IEEFLifecycleManagerProvider}. 
 * The extension registry listener used to populate the registry of lifecycle manager provider * {@link IEEFLifecycleManagerProvider}. 
 * The extension registry listener used to populate the registry of lifecycle manager provider * {@link IEEFLifecycleManagerProvider}. 
<|del|> 
 } else if (attributes.isDirectory()) { 
 } 
<|del|> 
 trace.setTimestampTransform(TimestampTransformFactory.createWithOffset(delta)); 
 } else if (container instanceof Interface) { // Approve the request if the container is an interface 
 } else if (RTMessageKind.IN == MessageSetUtils.getMessageKind(container)) { // Approve the request only if the Message matches the IN type 
 } else if (container instanceof Interface) { 
 } else if (RTMessageKind.IN_OUT == MessageSetUtils.getMessageKind(container)) { // Approve the request only if the Message matches the IN_OUT type 
 } else if ((container instanceof Interface)) { 
<|del|> 
 } else if ((container instanceof Interface)) { // Approve the request if the container is an interface 
 } else if ((container instanceof Interface)) { 
 * Celine JANSSENS (ALL4TEC) celine.janssens@all4tec.net - Initial API and implementation 
 private static final String DEFAULT_PARAMETER_NAME = "data";// $NON-NLS-1$ 
 /** * {@inheritDoc} * * @see org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditHelperAdvice#approveRequest(org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest) * */ 
 if (1 == elementsToEdit.size()) { 
<|del|> 
<|del|> 
 command = editCommand; 
 while (!defaultNameExist && iterator.hasNext()) { 
 private static final String DELETE_BUTTON_ICON = "/icons/Delete_12x12.gif"; //$NON-NLS-1$ 
 private static final String ADD_BUTTON_ICON = "/icons/Add_12x12.gif";//$NON-NLS-1$ 
 private static final String UP_BUTTON_ICON = "/icons/Up_12x12.gif";//$NON-NLS-1$ 
 public ParameterControlEditor(final Composite parent, final int style, final Operation operation, final INattableModelManager nattableManager) { 
 protected Button createButton(final Image image, final String toolTipText) { 
 ICommand setCommand = getProvider().getEditCommand(setRequest); 
 if (null != setCommand && setCommand.canExecute()) { 
 if (null != setCommand && setCommand.canExecute()) { 
 if (null != setCommand && setCommand.canExecute()) { 
 public ParameterCreationDialog(final Composite parent, final int style) { 
 public void setContentProvider(final IStaticContentProvider provider) { 
 if (null != getValue()) { 
 protected static final String UNDEFINED = "*";//$NON-NLS-1$ 
 public ParameterTypeContentProvider(final IStaticContentProvider provider) { 
 /** * Editor with the Control Buttons */ 
 public ParameterControlWidget(final Composite parent, final int style, final Operation operation, final INattableModelManager nattableManager) { 
 /** * Setter of parameter in the Editor * * @param selectedParameter * the parameter which the editor is editing */ public void setParameter(final Parameter selectedParameter) { 
 /** * Setter of a list of parameters in the Editor * * @param selectedParameterList * the list of parameters which the editor is editing */ public void setParameters(final List<Parameter> selectedParameterList) { 
 public ParameterCreationWidget(final Composite parent, final int style) { 
 // Log Helper 
<|del|>
<|del|>
<|del|> 
 * Returned Value from the Table 
 * Parameter of the selected Cell 
 /** * Create the Dialog containing the type Selection which is a tree 
 * 
 public boolean isAllowedContents(final Object object) { 
 private final java.nio.file.Path workspacePath; 
 if (dirs == null || dirs.isEmpty()) { 
 writeTrashFile("nested-repo", "README3.md", "content"); 
<|del|> 
<|del|> 
 if ((f.getEntryRawMode() == TYPE_TREE && f.getIndexFileMode(c) != FileMode.GITLINK) || (f.getEntryRawMode() == TYPE_GITLINK && f.getIndexFileMode(c) == FileMode.TREE)) { 
 /** * The "dirnogitlinks" key * @since 4.3 */ public static final String CONFIG_KEY_DIRNOGITLINKS = "dirNoGitLinks"; 
 * through the Work Tree * * @since 4.3 
 t.setColumnOrder(new int[] { 0, 1, 2, 3, 4}); 
<|del|> 
 init(entries()); 
 r[i] = new FileEntry(all[i], fs); 
 public FileEntry(File f, FS fs) { 
 DsfMemoryBlock block = new GdbMemoryBlock(this, memoryContext, getModelId(), label, blockAddress, getAddressableSize(memoryContext), 0, memorySpaceID); 
 SetMultimap<String, String> valuesByType = HashMultimap.create(); 
 Set<String> actual = StreamSupport.stream(fModule.getAnalysisRequirements().spliterator(), false) .flatMap(req -> req.getValues().stream()) .collect(Collectors.toSet()); 
 */ @FunctionalInterface 
 if (color != null) { if (color.isDisposed ()) error(SWT.ERROR_INVALID_ARGUMENT); if (color.equals(linkColor)) return; } else if (linkColor == null) return; 
 private String fMemorySpaceId; 
 private IMemorySpacePreferencesHelper fMemSpacePreferenceHelper; 
<|del|> 
 private final int fThreadId; private final @NonNull TmfView fView; private final @NonNull ITmfTrace fTrace; private final @Nullable String fThreadName; 
 builder.add(ControlFlowColumnComparators.PROCESS_NAME_COLUMN_COMPARATOR) .add(ControlFlowColumnComparators.TID_COLUMN_COMPARATOR) .add(ControlFlowColumnComparators.PTID_COLUMN_COMPARATOR) .add(ControlFlowColumnComparators.BIRTH_TIME_COLUMN_COMPARATOR) .add(ControlFlowColumnComparators.TRACE_COLUMN_COMPARATOR); 
 ControlFlowEntry entry = (ControlFlowEntry) item.getData(); fMenuMgr.add(new FollowThreadAction(ControlFlowView.this, entry.getName(), entry.getThreadId(), entry.getTrace())); 
 /** An invalid CPU */ public static final int INVALID_CPU = -1; /** An invalid thread id */ public static final int INVALID_THREAD_ID = -1; 
 /** An invalid CPU */ public static final int INVALID_CPU = -1; /** An invalid thread id */ public static final int INVALID_THREAD_ID = -1; 
 /** An invalid CPU */ public static final int INVALID_CPU = -1; /** An invalid thread id */ public static final int INVALID_THREAD_ID = -1; 
 } 
 * Copyright (c) 2007, 2018 THALES GLOBAL SERVICES. 
 * Copyright (c) 2015, 2018 Obeo. 
 * Copyright (c) 2015, 2018 Obeo. 
<|del|> 
<|del|> 
<|del|>
 registersService.findRegister(fTargetFrameContext, potentialRegisterName, new DataRequestMonitor<IRegisterDMContext>(executor, rm) { 
<|del|> 
public class XmlLatencyViewInfo extends AbstractXmlViewInfo { 
 LATENCY_TABLE(PatternLatencyTableView.ID, Messages.TmfXmlAnalysisOutputSource_LatencyTable); 
 loadLatencyView(); 
 SCATTER_GRAPH(PatternScatterGraphView.ID, Messages.TmfXmlAnalysisOutputSource_ScatterGraphTitle); 
 loadLatencyView(); 
 PatternScatterGraphViewer viewer = new PatternScatterGraphViewer(checkNotNull(parent), checkNotNull(Messages.PatternLatencyViews_ScatterGraphTitle), checkNotNull(Messages.PatternLatencyViews_ScatterGraphXLabel), checkNotNull(Messages.PatternLatencyViews_ScatterGraphYLabel)); 
 * Copyright (c) 2008, 2016 Ketan Padegaonkar and others. 
 includedReader, path, branch, uri, groups, repo); 
 proj.getCopyFiles()); 
<|del|> 
 * a consumer which will be notified about every * {@link ISideEffect} constructed by this factory. * @return a newly constructed {@link ISideEffectFactory} 
 static ISideEffectFactory createFactory(Consumer<ISideEffect> sideEffectConsumer) { 
 private List<ISideEffect> sideEffects; 
 private List<ISideEffect> sideEffects; 
 public void add(ISideEffect sideEffect) { 
 * It is safe to use it in any class, it will only apply to tests which have @Intermittent annotation <code> import org.eclipse.cdt.tests.dsf.gdb.framework.Intermittent import org.eclipse.cdt.tests.dsf.gdb.framework.IntermittentRule 
 @Intermittent(repetition = 3) public void someTest (){...} } </code> 
<|del|> 
 * Copyright (c) 2012, 2016 THALES GLOBAL SERVICES and others. 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 private final ITmfTrace fTrace; 
 @FunctionalInterface 
 try { fTempFile = File.createTempFile("tmpStateSystem", null); } catch (IOException e) { fail(e.getMessage()); } 
<|del|> 
 private void setCurrentHostThread(HostThread hostThread) { if (!hostThread.equals(fCurrentHostThread)) { fCurrentHostThread = hostThread; 
<|del|> 
 } else { /* over the vertical scroll bar or outside of the viewer */ 
<|del|> 
 throw new IllegalStateException("The persistent property section could not be added"); //$NON-NLS-1$ 
 private @Nullable String fAnalysisId = null; 
 /** This is the ID of the view described in the XML file */ 
<|del|> 
 public static final @NonNull String ID = "org.eclipse.tracecompass.internal.tmf.analysis.xml.ui.views.latencytable"; //$NON-NLS-1$ 
<|del|> 
<|del|> 
 /** The header bar */ private TmfEventsTableHeader fHeaderBar; 
 fLabelBackground = new Color(getDisplay(), LABEL_BACKGROUND); 
 text = ((TmfFilterNode) filter).getFilterName(); label.setData(TOOLTIP_KEY, filter.toString()); 
 if (fTempFile != null) { fTempFile.delete(); 
 assertEquals( 2, branch.get(1).getSequenceNumber()); assertEquals( 1, branch.get(1).getParentSequenceNumber()); 
 assertEquals( 4, branch.get(1).getSequenceNumber()); assertEquals( 3, branch.get(1).getParentSequenceNumber()); assertEquals( 5, branch.get(2).getSequenceNumber()); assertEquals( 4, branch.get(2).getParentSequenceNumber()); 
@org.eclipse.jdt.annotation.NonNullByDefault package org.eclipse.tracecompass.statesystem.core.tests.backend.historytree; 
<|del|> 
 if (containsSystemUser(users)) { 
 private static boolean containsCurrentUser(Collection<User> users) throws OseeCoreException { 
 private synchronized static void storeOnImageRegistry(String key, ImageDescriptor descriptor) { 
 protected ILaunchConfiguration getConfiguration() { 
 * {@link ISideEffect} constructed by this factory. The consumer * must guarantee that {@link ISideEffect#dispose()} will be * called on every {@link ISideEffect} it receives at some point * in the future. 
 * not run it immediately. The lifecycle of the returned {@link ISideEffect} * will be managed by the factory. Callers are not responsible for disposing * the resulting {@link ISideEffect}. So for example pausing, resuming and 
 cache.cache(renderedView); 
<|del|> 
 * @return true when the variable exists 
 * instance of the variable 
 * @return the variable or <code>null</code> 
 * Remove the variable with the given <i>identifier</i>. After the variable is removed it will not be available during the {@link TestSuite} execution. 
 * unique identifier of the variable 
 String[] fVariableIndentifier; String[] fVariableContent; String[] fVariableDescription; 
 public void getVariableCount() { 
 for (int index = 0; index < ELEMENTS; index++) { assertNotNull(testSuiteModel.getVariable(fVariableIndentifier[index])); testSuiteModel.removeVariable(testSuiteModel.getVariable(fVariableIndentifier[index])); assertFalse(testSuiteModel.hasVariable(fVariableIndentifier[index])); 
<|del|> 
 if ((depth != 0) && !isSameFile(root, resolved)) { 
 transferAddress.add(outputChunkSize.multiply(BigInteger.valueOf(i))), outputChunkSize.longValue()); 
 if ((depth != 0) && !(resolved != null && isSameFile(root, resolved))) { 
 if ((depth != 0) && !(resolved != null && isSameFile(root, resolved))) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 reflow(); 
 if (knwonEnvironment != queryEnvironment || returnTypes == null) { knwonEnvironment = queryEnvironment; 
 assertNotNull("fPkg", fPkg); 
 if (currentSupport != null) { currentSupport.gotoAnnotation(Direction.FORWARDS); } 
 private IMemorySpaces fMemorySpaceService; 
 default String getMemorySpaceID() { 
 synchronized (this.toProcess) { return this.toProcess.isEmpty(); } 
 final Set<T> rules = dmrsToRules.get(dmr); if (rules != null) { rules.remove(rule); } 
<|del|> 
 final IObservableValue upperBoundModelValue = EMFEditObservables.observeValue(getEditingDomain(domainObject), domainObject, EcorePackage.eINSTANCE.getETypedElement_UpperBound()); 
 if (getVElement().getLabel() != null) { group.setText(getVElement().getLabel()); 
 this.stackToSetting = stackToSetting; 
 Point location = sourceViewer.getSourceViewer().getControl().toDisplay( sourceViewer.getSourceViewer().getControl().getSize().x, sourceViewer.getViewportHeight() / 3); 
 if (classpathEntry.hasAnnotationFileFor(qualifiedTypeName)) { // in case of 'this.annotationsFromClasspath' we indeed search for .eea entries inside the main zipFile of the entry: 
<|del|> 
<|del|> 
 /** * A decorator for {@link IBinaryType} that allows external annotations to be attached. This can be used to change the * result of {@link #enrichWithExternalAnnotationsFor} or {@link #getExternalAnnotationStatus}. */ 
 try { return new ExternalAnnotationProvider(new FileInputStream(filePath), qualifiedBinaryTypeName); } catch (FileNotFoundException e) { // Expected, no need to report an error here return null; } 
 * Answer the resolved binary form for the type or null if the * receiver represents a compilation unit or source type. 
 } catch (IOException e) { 
 private List<Comment> commentList = new LinkedList<Comment>(); 
 * Copyright (c) 2010, 2016 THALES GLOBAL SERVICES. 
<|del|> 
 // has a memory-space-specific background color been set for the associated memory space? 
 private final Set<Integer> fQuarksInUse = new TreeSet<>(); 
<|del|> 
 public synchronized int getAvailable() { 
 * Copyright (c) 2000, 2016 IBM Corporation and others. 
 * Copyright (c) 2000, 2016 IBM Corporation and others. 
 * Copyright (c) 2015-2016 Red Hat, Inc. 
 final BigInteger dataCellSize = BigInteger.valueOf(4); 
 final BigInteger dataCellsPerLine = dataCellSize.multiply(numberOfColumns); 
<|del|> 
 private static final String KEY_PREFIX = EEFFont.class.getCanonicalName() + "."; //$NON-NLS-1$ 
 fontStyle = fontStyle | 2; // SWT.ITALIC 
 * on the org.eclipse.ui.texteditor.FindReplaceDialog of Eclipse. 
 // handle to the register we're looking-for final IRegisterDMContext theOne = getData(); 
 String returnValue = null; 
 } catch (TimeoutException exc) { } return returnValue; 
 tid = OTHER_TID; 
 ITmfStateSystem ss = module.getStateSystem(); 
<|del|> 
 * Copyright (c) 2012, 2016 Ericsson, cole Polytechnique de Montral 
 if (pattern.matcher(getName()).find()) { 
 if (pattern.matcher(getName()).find()) { 
 if (pattern.matcher(Integer.toString(fThreadId)).find()) { 
 if (pattern.matcher(Integer.toString(fParentThreadId)).find()) { 
 if (pattern.matcher(Integer.toString(fThreadQuark)).find()) { 
 if (pattern.matcher(fTrace.getName()).find()) { 
 return pattern.matcher(Utils.formatTime(getStartTime(), TimeFormat.CALENDAR, Resolution.NANOSEC)).find(); 
 * Copyright (c) 2014, 2016 cole Polytechnique de Montral and others. 
 return pattern.matcher(fParentId).find(); 
 * Copyright (c) 2010, 2016 Ericsson 
 public boolean matches(@NonNull Pattern pattern) { return getName() != null ? pattern.matcher(getName()).find() : false; 
 fTimeGraphCtrl.expand(entry.getParent()); 
 fTimeGraphCtrl.expand(entry.getParent()); 
 setText(Messages.ShowFindDialogAction_Search); setToolTipText(Messages.ShowFindDialogAction_Show_search_dialog); 
 fFilterDialog.getShell().setSize(SHELL_SIZE, SHELL_SIZE); 
 PlatformUI.getWorkbench().getHelpSystem().setHelp(shell, "org.eclipse.tracecompass.tmf.ui.widgets.timegraph.dialogs.find_dialog"); //$NON-NLS-1$ 
 group.setText(Messages.TimeGraphFindDialog_Direction); 
 boolean matches(@NonNull Pattern pattern); 
 boolean matches(@NonNull Pattern pattern); 
 private static final String KMEM_ALLOC = "mm_page_alloc"; private static final String KMEM_FREE = "mm_page_free"; 
 private static final String KMEM_ALLOC = "mm_page_alloc"; private static final String KMEM_FREE = "mm_page_free"; 
 if (pattern.matcher(Utils.formatTime(getStartTime(), TimeFormat.CALENDAR, Resolution.NANOSEC)).find()) { return true; } return pattern.matcher(fTrace.getName()).find(); 
 super(variableManager, interpreter, editingDomain); 
 super(variableManager, interpreter, editingDomain); 
 super(variableManager, interpreter, editingDomain); 
<|del|> 
 final ImageDescriptor desc = org.eclipse.papyrus.infra.widgets.Activator.getDefault().getImageDescriptor(Activator.PLUGIN_ID, NattableConfigurationConstants.ICON_WIZBAN_PATH); 
 final ImageDescriptor desc = org.eclipse.papyrus.infra.widgets.Activator.getDefault().getImageDescriptor(Activator.PLUGIN_ID, NattableConfigurationConstants.ICON_WIZBAN_PATH); 
 if (0 < workingSets.length) { 
 || !NattableConfigurationConstants.NATTABLE_CONFIGURATION_EXTENSION_FILE.equals(nattableConfigurationFileName.toString().substring(nattableConfigurationFileName.lastIndexOf(DOT) + 1))) { 
 initialResource = set.createResource(URI.createFileURI(nattableConfFileURI.toString())); 
 } catch (final InvocationTargetException e) { 
 } catch (final ServiceException e) { 
 } catch (final IOException e) { 
 } catch (final IOException e) { 
 if (null != inputStream) { 
 } catch (final IOException e) { 
 if (null != outputStream) { 
 } catch (final IOException e) { 
 listenFeatureLabel.setText(Messages.FeatureFillingConfigurationDialog_listenFeature); 
 setListenFeature((EStructuralFeature) newValue[0]); 
 if (Window.OK == result) { 
 setTitle(Messages.TreeFillingConfigurationDialog_treeFillingConfigurationDialogName); 
 setAxisElement(newValue[0]); 
 final CreateNattableConfigurationWizard wizard = new CreateNattableConfigurationWizard(configuration, resourceSelected); final WizardDialog dialog = new WizardDialog(Display.getDefault().getActiveShell(), wizard); 
 final CreateNattableConfigurationWizard wizard = new CreateNattableConfigurationWizard(configuration, resourceSelected); final WizardDialog dialog = new WizardDialog(Display.getDefault().getActiveShell(), wizard); 
 public void setEnabled(final Object evaluationContext) { 
 if (currentSelection instanceof StructuredSelection && 1 == ((StructuredSelection) currentSelection).size()) { 
 if (!resource.getContents().isEmpty() && resource.getContents().get(0) instanceof TableConfiguration) { 
 public void widgetSelected(final SelectionEvent e) { 
 public void widgetSelected(final SelectionEvent e) { 
 public void widgetSelected(final SelectionEvent e) { 
 public void widgetSelected(final SelectionEvent e) { 
 final AbstractAxisProvider axisProvider = rowAxisProvidersIterator.next(); 
 final AbstractAxisProvider axisProvider = columnAxisProvidersIterator.next(); 
 final String name = helper.getDefaultTableName(); final String type = helper.getTableType(); 
 public void handleEvent(final Event e) { setPageComplete(canFlipToNextPage()); 
 final Composite composite = (Composite) getControl(); 
 final Group group = createGroup(composite, Messages.NattableConfigurationProjectCreationPage_nattableConfigurationFileNameLabel); 
 final GridData data = new GridData(SWT.FILL, SWT.FILL, true, true); 
 if (null != nattableConfigurationFileName) { if ("".equals(nattableConfigurationFileName.getText())) { //$NON-NLS-1$ 
 final IProject[] projects = ResourcesPlugin.getWorkspace().getRoot().getProjects(); if (canFlip) { 
 final IProject[] projects = ResourcesPlugin.getWorkspace().getRoot().getProjects(); if (canFlip) { 
 public void widgetSelected(final SelectionEvent e) { 
 final EClass eClass = (EClass) event.widget.getData(E_CLASS); 
 final Display display = addAxisConfiguration.getDisplay(); 
 public void widgetSelected(final SelectionEvent e) { 
 headerAxisConfiguration.getOwnedAxisConfigurations().remove(selectedObjects.next()); 
 public void selectionChanged(final SelectionChangedEvent event) { 
 public void widgetSelected(final SelectionEvent e) { 
 final Iterator<?> selectedObjects = tableViewer.getStructuredSelection().iterator(); 
 final EStructuralFeatureAxis createdAxis = NattableaxisFactory.eINSTANCE.createEStructuralFeatureAxis(); 
 public void widgetSelected(final SelectionEvent e) { 
 public void widgetSelected(final SelectionEvent e) { 
 public void widgetSelected(final SelectionEvent e) { 
 final IAxis selectedAxis = (IAxis) selectedObjects.next(); 
 final Iterator<?> selectedObjects = ((StructuredSelection) selection).iterator(); 
 final TableDisplayStyle style = (TableDisplayStyle) tableConfiguration.getStyle(NattablestylePackage.eINSTANCE.getTableDisplayStyle()); if (null != style) { 
 final TableDisplayStyle style = (TableDisplayStyle) tableConfiguration.getStyle(NattablestylePackage.eINSTANCE.getTableDisplayStyle()); 
 protected Command getCreateActionCommand(final AbstractAdviceBindingFactory<?> adviceFactory) { 
<|del|> 
 * are made available under the terms of the Eclipse Public License v1.0 
<|del|> 
<|del|> 
 if (gc == null) device.internal_dispose_GC(hDC, null); 
 int baseline = Math.max(0, this.ascent); 
 return new Rectangle (0, 0, width, lineY[lineY.length - 1]); 
 int ascent = Math.max(lptm.tmAscent, this.ascent); int descent = Math.max(lptm.tmDescent, this.descent); int leading = lptm.tmInternalLeading; 
public void setAscent(int ascent) { 
public void setDescent(int descent) { 
 run.ascent += style.rise; run.descent -= style.rise; 
 } isRepresentationsResource = uri != null && new FileQuery(uri.fileExtension()).isSessionResourceFile(); 
 // bug 490908: only check the 1st root since sirius always puts // DAnalysis as 1st root of its resource EObject contentEObject = resource.getContents().get(0); if (contentEObject instanceof DAnalysis) { isRepresentationsResource = true; 
<|del|>
 * or not they contain a .git directory or file. 
 * @return whether or not we treat nested repos as directories. * If true, folders containing .git entries will not be * treated as gitlinks. 
 PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() { 
 @NonNull String[] names = Arrays.copyOf(fFieldNames, length + 1); @NonNull IDeclaration[] fields = Arrays.copyOf(fFields, length + 1); 
 @NonNull String[] names = Arrays.copyOf(fFieldNames, length + 1); @NonNull IDeclaration[] fields = Arrays.copyOf(fFields, length + 1); 
 /** Field names */ 
 return (int) Math.min(maxSize, Integer.MAX_VALUE); 
 if (hasField(name)) { 
 final @NonNull String[] fieldNames = fFieldNames; final @NonNull IDeclaration[] fields = fFields; for (int i = 0; i < fields.length; i++) { 
 if (structDeclaration.hasField(MetadataStrings.ID)) { IDeclaration idEnumDecl = structDeclaration.getField(MetadataStrings.ID); 
 getEMFFormsDomainExpander().prepareDomainObject(featurePathDMR, domainObject); 
 "Domain Expansion failed due to an invalid key attribute dmr: " + ex.getMessage()); //$NON-NLS-1$ 
<|del|>
<|del|>
 if (null != setCommand) { setCommand.setLabel(MOVE_UP); 
 if (null != setCommand) { setCommand.setLabel(REMOVE_ELEMENT); 
 ICommand createCommand = getParameterProvider().getEditCommand(request); 
<|del|> 
 throw new IllegalStateException("Worker parameter must be an IGraphWorker"); //$NON-NLS-1$ 
 * Copyright (c) 2010, 2016 THALES GLOBAL SERVICES, and others. 
 * Copyright (c) 2014 Obeo. 
 * An interface that offers the possibility to request information related to addresses for a given memory block 
 /** * An indication of the type of change which may render the current memory address information out of date */ 
 * Information item for a memory address or range 
 IMemoryBlockAddressInfoItem[] getAllAddressInfoItems(); 
 * Call-back interface used to receive notification of changes to address information items 
 * Register a listener so it can receive notifications of changes to address information items 
 void addAddressInfoUpdateListener(IAddressInfoUpdateListener listener); 
 * Removes a listener so it no longer receives notifications 
<|del|> 
 protected IGdbMemoryAddressInfoTypeRetrieval[] resolveMemoryAddressInfoProviders() { return new IGdbMemoryAddressInfoTypeRetrieval[] {new GdbMemoryAddressInfoVariablesRetrieval(fSession)}; } 
 if (memoryContainerCtx != null && memoryContainerCtx.equals(selectedContainerCtx)) { 
 IGdbMemoryAddressInfoTypeRetrieval[] infoTypeProviders = resolveMemoryAddressInfoProviders(); 
 IGdbMemoryAddressInfoTypeRetrieval[] infoTypeProviders = resolveMemoryAddressInfoProviders(); 
 }); } else { request.done(); 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 } } else { request.done(); 
 } protected IGdbMemoryAddressInfoTypeRetrieval[] resolveMemoryAddressInfoProviders() { return new IGdbMemoryAddressInfoTypeRetrieval[] {new GdbMemoryAddressInfoVariablesRetrieval(fSession)}; } 
<|del|> 
<|del|> 
<|del|> 
 private final static String UNICODE_NORTH_WEST_ARROW = "\u2196"; 
 for (BigInteger startAddress : sortedAddresses) { 
 List<BigInteger> collection = new ArrayList<>(keySet); 
public class Rendering extends Composite implements IDebugEventSetListener 
<|del|> 
 | SWT.V_SCROLL); 
 return (fBinaryPane.fPaneVisible && fMapAddressToInfoItems.size() > 0); 
 return Objects.hashCode(fFilePath, fOffset); 
 .maximumSize(1000) 
 /** * Signal handler for a cpu selected signal. 
 private final @NonNull ITmfTrace fTrace; 
 private static @Nullable DefaultEventLayout INSTANCE; 
 * Lucas Koehler - initial API and implementation 
@SuiteClasses({ EMFKeyAttributeValueProperty_Test.class, KeyAttributeDomainModelReferenceConverter_Test.class }) 
 } catch (StateValueTypeException e) { 
<|del|>
 * Copyright (c) 2015, 2016 vogella GmbH and others. 
<|del|> 
 * @since 4.3 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 String cpuAttributeName = NonNullUtils.nullToEmptyString(cpu); cpuQuark = ssb.getQuarkAbsoluteAndAdd(cpuAttributeName); fCpuNumToQuark.put(cpu, cpuQuark); 
 String cpuAttributeName = NonNullUtils.nullToEmptyString(cpu); cpuQuark = ssb.getQuarkAbsoluteAndAdd(cpuAttributeName); fCpuNumToQuark.put(cpu, cpuQuark); 
 protected abstract List<EEFConditionalStyle> getWidgetConditionalStyles(); 
<|del|> 
<|del|> 
 * event. If the new event starts before the zoomed event list's last event, * the new event is ignored and is assumed to be already part of the list. 
 protected EEFWidgetStyle getWidgetStyle(EEFConditionalStyle conditionalStyle) { return ((EEFCustomWidgetConditionalStyle) conditionalStyle).getStyle(); 
 List<Ref> refs, String title, String message, 
 public void setUp() { 
 /** * @author David W. Miller */ 
 // count number or previous picks 
<|del|> 
<|del|> 
 * Copyright (c) 2016 IBM Corporation and others. 
 * Copyright (c) 2000, 2016 IBM Corporation and others. 
 /** * This class hooks up the marker menu to the editor * * @since 1.0 */ 
 /** * This class manages the marker menu contribution * * @since 1.0 */ 
 /** * This class implements the marker delete a comment functionality * * @since 1.0 */ 
<|del|> 
 /** * This class implements the marker reply to comment functionality * * @since 1.0 */ 
 /** * This class is the entry point for the markers customization/generation * * @since 1.0 */ 
 /** * This class regroups common review functionality * * @since 1.0 */ 
 /** * Create a comment on the active review */ 
<|del|> 
 EGerritCorePlugin.logError(gerritClient.getRepository().formatGerritVersion() + e.getMessage()); 
 public static String ShowFindDialogAction_ShowSearchDialog; 
 public static String TimeGraphFindDialog_BackwardRadioButtonLabel; public static String TimeGraphFindDialog_CaseCheckBoxLabel; public static String TimeGraphFindDialog_CloseButtonLabel; 
 super.dispose(); ResourcesPlugin.getWorkspace().removeResourceChangeListener(this); getSite().getPage().removePartListener(fPartListener); 
 * Copyright (c) 2000, 2016 IBM Corporation and others. 
 * @param index the index of the button 
 * Control for adding an annotation with enum-based values to the generated source code. 
 * constants may depend on the project, e.g. its source level. 
 * may depend on the project, e.g. its source level. 
<|del|> 
<|del|> 
 if (conditionalStyle instanceof EEFButtonConditionalStyle) { return ((EEFButtonConditionalStyle) conditionalStyle).getStyle(); } return null; 
 if (conditionalStyle instanceof EEFLabelConditionalStyle) { return ((EEFLabelConditionalStyle) conditionalStyle).getStyle(); } return null; 
 copy.setVisible(!requiresVisibilityCheck(copy)); 
 if (conditionalStyle instanceof EEFRadioConditionalStyle) { return ((EEFRadioConditionalStyle) conditionalStyle).getStyle(); } return null; 
 private boolean requiresVisibilityCheck(MToolBarElement toolBarElement) { 
 if (conditionalStyle instanceof EEFSelectConditionalStyle) { return ((EEFSelectConditionalStyle) conditionalStyle).getStyle(); } return null; 
 if (conditionalStyle instanceof EEFTextConditionalStyle) { return ((EEFTextConditionalStyle) conditionalStyle).getStyle(); } return null; 
 if (conditionalStyle instanceof EEFCustomWidgetConditionalStyle) { return ((EEFCustomWidgetConditionalStyle) conditionalStyle).getStyle(); } return null; 
 return null; 
<|del|> 
 IStatus status= new Status(IStatus.INFO, JavaScriptUI.ID_PLUGIN, info); 
 if (data instanceof String && data.toString().length() > 0) { fAdditionalContentTypesIDs = StringUtils.unpack(data.toString()); 
 continue; 
<|del|> 
<|del|> 
 public static String TimeGraphFindDialog_BackwardRadioButtonLabel; public static String TimeGraphFindDialog_CaseCheckBoxLabel; public static String TimeGraphFindDialog_CloseButtonLabel; 
 public static String TimeGraphFindDialog_BackwardRadioButtonLabel; public static String TimeGraphFindDialog_CaseCheckBoxLabel; public static String TimeGraphFindDialog_CloseButtonLabel; 
 public static String TimeGraphFindDialog_BackwardRadioButtonLabel; public static String TimeGraphFindDialog_CaseCheckBoxLabel; public static String TimeGraphFindDialog_CloseButtonLabel; 
 private static final String PREV_PRIO = "prev_prio"; //$NON-NLS-1$ 
 else if (maxCount > -1) 
 * @since 4.4 
 applyResults(() -> { for (ITimeEvent event : eventList) { if (monitor.isCanceled()) { return; } entry.addZoomedEvent(event); } }); 
<|del|> 
 * Adds a listener that will be invoked when this {@link ISideEffect} 
 * Removes a dispose listener from this {@link ISideEffect} instance. Has no 
 .maximumSize(CACHE_SIZE) 
 IModelElement element = PHPSelectionUtil.getSelectionModelElement(selection.getOffset(), 
 * Copyright (c) 2000, 2016 IBM Corporation and others. 
<|del|> 
<|del|> 
 NLS.bind(RuntimeMessages.AbstractJSRuntimeType_DuplicateRuntimeInstall_Error, id)); 
 runtimeInstall = doCreateRuntimeInstall(id); 
<|del|> 
 * when the checked runtime in the table changes. 
 if (eventList != null) { /* Start a new event list on first iteration, then append to it */ 
 * Removes a dispose listener from this {@link ISideEffect} instance. Has no 
 * Adds the given {@link ISideEffect} instance from the composite. 
 * Adds the given {@link ISideEffect} instance from the composite. 
 * Removes the given {@link ISideEffect} instance from the composite. This * has no effect if the given side-effect is not part of the composite. 
<|del|> 
<|del|> 
 * result if they wish to dispose it early. Certain factory * instances may require all callers to do so. 
<|del|> 
 public boolean isDisposed() { // This side-effect never executes nor retains any references and // callers may rely upon this, so we should return true. 
 private int pauseDepth; 
 pauseDepth--; if (dirty && pauseDepth == 0) { 
 if (pauseDepth > 0) { 
 /** * Returns a singleton factory instance that creates unmanaged side-effects. */ public static SideEffectFactory FACTORY = new SideEffectFactory(sideEffect -> { }); 
 * Creates a new factory which will pass all created side-effects to the * given {@link Consumer}. 
<|del|> 
 CompositeSideEffect compositeSideEffect = (CompositeSideEffect) disposableWidget .getData(CompositeSideEffect.class.getName()); 
 CompositeSideEffect compositeSideEffect = (CompositeSideEffect) disposableWidget .getData(CompositeSideEffect.class.getName()); 
 "The resume() method was called more often than pause()."); //$NON-NLS-1$ 
 "The resume() method was called more often than pause()."); //$NON-NLS-1$ 
<|del|> 
@RunWith(SWTBotJunit4ClassRunner.class) public abstract class FindDialogTestBase extends KernelTestBase{ 
 */ @Test 
 public Integer run() { return timegraph.getSelectedIndex(); 
 * Copyright (c) 2004, 2016 IBM Corporation and others. 
 * Increments the count of the number of times the {@link ISideEffect} has * been resumed. If the side-effect has been resumed an equal or greater 
 * Increments the count of the number of times the {@link ISideEffect} has * been resumed. If the side-effect has been resumed an equal or greater 
 if (pauseDepth < 0) { throw new IllegalStateException( "Resume has unessesarily been called too often, so that the pauseDepth is below zero."); //$NON-NLS-1$ } else if (dirty && pauseDepth == 0) { 
 private final Realm realm; 
 if (pauseDepth < 0) { throw new IllegalStateException( "Resume has unessesarily been called too often, so that the pauseDepth is below zero."); //$NON-NLS-1$ } else if (pauseDepth == 0) { 
<|del|> 
 CompositeSideEffect compositeSideEffect = (CompositeSideEffect) disposableWidget .getData(CompositeSideEffect.class.getName()); 
 return new TmfAnalysisEventRequirement(events.build(), fLevel); 
 long ts = event.getTimestamp().toNanos(); 
 if (pathPrefix.isEmpty()) { 
 new Label(composite, SWT.NONE); new Label(composite, SWT.NONE); 
 ITmfStateInterval value = fullState.get(irqQuark); if (value.getStateValue().unboxInt() == cpu) { 
 ITmfStateInterval value = fullState.get(irqQuark); if (value.getStateValue().unboxInt() == cpu) { 
 @NonNull String irq = ss.getAttributeName(irqQuark); retMap.put(Messages.ResourcesView_attributeIrqName, irq); 
 ITmfStateInterval value = fullState.get(softIrqQuark); if (value.getStateValue().unboxInt() == cpu) { 
 ITmfStateInterval value = fullState.get(softIrqQuark); if (value.getStateValue().unboxInt() == cpu) { 
 isVariableCaseSensitive = Boolean.parseBoolean(isCS); 
 fBot.waitUntil(ConditionHelpers.timeGraphIsReadyCondition((AbstractTimeGraphView) viewBot.getViewReference().getPart(false), new TmfTimeRange(START_TIME, START_TIME), START_TIME)); 
 } 
 } else { if (!newLines.get(hh.getNewStartLine() - 1 + pos) .equals(hunkLine.substring(1))) { 
 sb.deleteCharAt(sb.length() - 1); } 
 if (Boolean.parseBoolean((String) props.get(KEY_INDEX_ALL_FILES))) { 
 if (Boolean.parseBoolean((String) props.get(KEY_INDEX_UNUSED_HEADERS_WITH_ALTERNATE_LANG)) && Boolean.parseBoolean((String) props.get(KEY_INDEX_ALL_FILES)) && !Boolean.parseBoolean((String) props.get(KEY_INDEX_UNUSED_HEADERS_WITH_DEFAULT_LANG))) { 
<|del|> 
 Version dRepresentationContainerRemovalVersion = DRepresentationContainerToDViewMigrationParticipant.MIGRATION_VERSION; 
 assertTrue("The DRepresentationContainer removal migration must be required on test data.", dRepresentationContainerRemovalVersion.compareTo(loadedVersion) > 0); 
 /** * this is placed here to remind developers that the osgi component this class implements needs a no argument * constructor */ 
 throw new OseeArgumentException("BranchID provided to safety workflow creation event incorrect type: %s", branchId.toString()); 
 testDirectionSearch(false, text, bot, findButton, viewBot); testOpenCloseDialog(viewBot); 
 return UIThreadRunnable.syncExec(() -> { return timegraph.getSelectedIndex(); 
<|del|> 
 if (!functionExitState.equals(poppedValue)) { 
 * @return The function name, for a function exit, or null if 
 public static class MyStatusBar extends WorkbenchWindowControlContribution { 
 public MenusTestSuite() { /* * TODO: MenusTestSuite was previously disabled in UiTestSuite and these * commented-out tests must be validated and fixed up */ 
 "The resume() method was called more times than pause()."); //$NON-NLS-1$ 
 "The resume() method was called more times than pause()."); //$NON-NLS-1$ 
 int width = ((Integer) ViewUtil.getStructuralFeatureValue(view, NotationPackage.eINSTANCE.getSize_Width())).intValue(); int height = ((Integer) ViewUtil.getStructuralFeatureValue(view, NotationPackage.eINSTANCE.getSize_Height())).intValue(); 
 if (null == diagramView) { 
 if (null == diagramView) { 
 if (null == diagramView) { 
 } shell.setText(Messages.TimeGraphFindDialog_FindTitle); 
 // typedef _Index_tuple<> __type; //$class,typedef 
 /** byteLen + MIN_SIZE > Short.MAX_VALUE, but that can overflow */ if (byteLen > Short.MAX_VALUE - MIN_SIZE) { 
 /** byteLen + MIN_SIZE > Short.MAX_VALUE, but that can overflow */ if (byteLen > Short.MAX_VALUE - MIN_SIZE) { 
 setToolTipText(Messages.SiriusCopyAppearancePropertiesAction_tooltipMessage); 
 return prefix + Path.SEPARATOR + path; 
 private JavaScriptCodeFactory fFactory; 
 Set<File> filesToAdd = new HashSet<>(); 
 final List<IEditorReference> editorRefsToClose = new ArrayList<>(); 
 Set<IFile> keySet = fileEditors.keySet(); for (IFile file : keySet) { if (file.getProject().equals(project)) { editorsToBeClosed.add(fileEditors.get(file)); 
 Activator.logError("Problems during auto-close of related editors", //$NON-NLS-1$ e); 
 Activator.logError("PartInitException - should not happen", e); //$NON-NLS-1$ 
 currentAdjustment = OS.gtk_adjustment_get_value (vAdjustment); 
 indexMark = OS.gtk_text_buffer_create_mark (bufferHandle, buffer, position, true); OS.gtk_text_view_scroll_to_mark (handle, indexMark, 0, true, 0, 0); 
 indexMark = OS.gtk_text_buffer_create_mark (bufferHandle, buffer, position, true); OS.gtk_text_view_scroll_to_mark (handle, indexMark, 0, true, 0, 0); 
 throw new IllegalArgumentException("Multiple template models found. Only one is supported."); //$NON-NLS-1$ 
import org.eclipse.cdt.core.dom.ast.cpp.ICPPVariable; import org.eclipse.cdt.core.parser.util.ObjectMap; 
 IValue value = getValue(); assertInstance(value, CStringValue.class); 
 protected ICPPASTInitializerClause getLastDeclarationInitializer() throws Exception { 
 public SinglePDOMTestStrategy(boolean cpp, boolean shouldRequireHeaderFile) { 
public interface IASTBreakStatement extends IASTStatement { 
 Number numberValue(); 
 IValue clone(); 
 * @noextend This interface is not intended to be extended by clients. 
public interface ICPPASTInitializerClause extends IASTInitializerClause { 
 if (fParsedValue == null) { fParsedValue = parseString(); } return fParsedValue; 
 private String parseString() { // TODO: Reuse code between this and CPPASTLiteralExpression.computeStringLiteralSize(). 
 /** * Gets the value of an evaluation, interpreted as a value of the given type. */ private static IValue getValue(IType type, ICPPEvaluation eval) { 
 }; 
 // since the setting is derived it should not be setted in anyway. return false; 
 /** * * @param project * @return */ private boolean hasPackageJson(IProject project){ 
 private boolean isValidFile(IFile file) { 
 Rectangle displaySize = parent.getDisplay().getBounds(); 
 Rectangle displaySize = parent.getDisplay().getBounds(); int locationX = ( displaySize.width - prefSize.x ) / 2 + displaySize.x; int locationY = ( displaySize.height - prefSize.y ) / 2 + displaySize.y; 
 Rectangle displaySize = parent.getDisplay().getBounds(); result.x = ( displaySize.width - preferredSize.x ) / 2 + displaySize.x; result.y = ( displaySize.height - preferredSize.y ) / 2 + displaySize.y; 
 boolean noSpaceForHeader= (arrowHeights[0] <= 0 && arrowHeights[1] <= 0 && !hScrollVisible); 
<|del|> 
 /* super.refreshChildren() above should have set this */ 
 * * For now it contains the list of the standard analyses, with their outputs * (views) under each. The plan is to eventually only show the views under this * node, since the user cannot really interact with the analyses themselves. * 
 * * For now it contains the list of the standard analyses, with their outputs * (views) under each. The plan is to eventually only show the views under this * node, since the user cannot really interact with the analyses themselves. * 
 public static final String PATH_ELEMENT = ".views"; //$NON-NLS-1$ 
 public static void addOverrideAnnotation(CodeGenerationSettings settings, IJavaProject project, ASTRewrite rewrite, ImportRewrite imports, MethodDeclaration decl, ITypeBinding overriddenMethodsDeclaringClassBinding, TextEditGroup group) { 
 if (findAnnotation("java.lang.Override", decl.modifiers()) != null) { 
 } AST ast= rewrite.getAST(); Annotation marker= ast.newMarkerAnnotation(); ImportRewriteContext context= null; 
 if (findAnnotation("java.lang.Override", decl.modifiers()) != null) { //$NON-NLS-1$ 
 finalResult.append(CRLF).append(CRLF).append(i + 1).append(PARENTHESES).append(childMessage); 
 if ((s.indexOf(',') < 0) && (s.indexOf('\\') < 0)) 
<|del|> 
 public static String replaceLineDelimers(String name) { 
 public static String replaceLineDelimiters(String name) { return name.replaceAll("\\r\\n", " ").replace('\n', ' ').replace('\r', ' '); //$NON-NLS-1$ //$NON-NLS-2$ 
 private void mergeRelatedContainmentRefChanges(Diff diff, EObject sourceValue, boolean rightToLeft) { EList<Diff> differences = diff.getMatch().getComparison().getDifferences(sourceValue); 
public abstract class FindDialogTestBase extends KernelTestBase { 
 @Before public void init() { 
 private static void verifySelection(String name, SearchOptions options, SWTBotView view, boolean isWrapped) { 
 @Override 
 if (sb.length() > 0) { sb.append("\n "); //$NON-NLS-1$ } 
 * @param signalSource 
 if ((xIsLog && xValue <= ZERO) || (yIsLog && yValue <= ZERO)) { /* Equal or less than 0 values can't be plotted on log scale */ continue; 
 validXDoubleSeries.add(xValue); validYDoubleSeries.add(yValue); indexSeriesCorrespondance.add(i); 
 .mapToInt(index -> getResultTable().getEntries().indexOf((getResultTable().getEntries().get(index)))) 
 * @author France Lapointe Nguyen * @author Alexandre Montplaisir 
 private static final Pattern pattern = Pattern.compile("'{3,}\\s*"); //$NON-NLS-1$ 
 //the created html should not contain "<hr/>" assertEquals("<p>x '''</p>\n", html); 
 int currentPS = fRevisionInContext.get_number(); 
<|del|> 
 CustomStateValue readCustomValue(SafeByteBufferWrapper buffer); 
 * The timerange on which to execute the analysis. * {@link TmfTimeRange#ETERNITY} can be used to indicate the 
 * @return The results of this analysis. Exact object type is * analysis-dependent, a more specific return type is encouraged. 
 * Exceptions resulting from the execution of on-demand analyses. 
 public @Nullable Integer resolve(@NonNull ITmfEvent event, boolean block, final IProgressMonitor monitor) throws InterruptedException { 
 while (block && !analysis.isQueryable(ts) && !monitor.isCanceled()) { Thread.sleep(100); 
 while (block && !analysis.isQueryable(ts) && !monitor.isCanceled()) { Thread.sleep(100); 
 public static final TupleFamilyId DefaultFamily = TokenFactory.createTupleFamilyType(1L); 
 final IScriptThread thread = frame.getScriptThread(); // TODO: Add a check for sync mode only if Async support will be // implemented. 
 public static final String AUTHOR_COMMENT = "icons/showAuthorComments.gif"; //$NON-NLS-1$ 
 /** * Helper class to handle images */ 
 /** * Helper class to handle images */ 
 /** * Base class for the quick fixes provided by egerrit */ 
 /** * Base class for the quick fixes provided by egerrit */ 
 public static String IS_DRAFT = "isDraft"; //$NON-NLS-1$ 
 public static String IS_DRAFT = "isDraft"; //$NON-NLS-1$ 
 return EGerritImages.get(EGerritImages.DELETE_QUICKFIX); 
 return EGerritImages.get(EGerritImages.DELETE_QUICKFIX); 
 Activator.logError("TmfMipmapFeature : Time stamp is out of range", e); //$NON-NLS-1$ 
 Activator.logError("MipMapProvider : Time stamp outside of time range of state system", e); //$NON-NLS-1$ 
 if (!functionExitState.isNull() || !functionExitState.equals(poppedValue)) { 
 return resolve(event, false, NULL_MONITOR); 
<|del|> 
 public static final String AUTHOR_COMMENT = "icons/showAuthorComments.gif"; //$NON-NLS-1$ 
 /** * Base class for the quick fixes provided by egerrit */ 
 IResource resource = event.getResource(); if (event.getType() == IResourceChangeEvent.PRE_DELETE && resource != null && resource.getType() == IResource.PROJECT) { IProject aboutToBeDeleted = (IProject) resource; 
<|del|>
 boolean associateEditor = false; 
 @Override public Number numberValue() { return null; } @Override 
 /** * Creates a value representing an instance of the given array type initialized with * the elements of the given initializer list. */ 
 }; 
<|del|> 
 /** * Get the initial value of the given variable, evaluated in the context of * the given activation record. */ public static ICPPEvaluation getVariableValue(ICPPVariable variable, ActivationRecord record) { 
 ICPPClassType classType = (ICPPClassType)type; // TODO(nathanridge): CompositeValue.create() only consider default member initializers, not // constructors. Should we be considering constructors here as well? 
 * Copyright (c) 2007, 2016 Wind River Systems and others. 
 private final ITreeModelViewer fViewer; 
 * @return The state value representing the function being entered 
 * @return The state value representing the function being exited, or * TmfStateValue#nullValue() if the exited function is undefined, * or null if not a function exit. 
 * @return The state value representing the function being entered, or null * if not a function entry 
 if (!functionExitState.isNull() && !functionExitState.equals(poppedValue)) { 
 SubMonitor archiveMonitor = SubMonitor.convert(subMonitor.newChild(ARCHIVE_OR_DIRECTORY_PROGRESS), 2); 
 request.fail(new IllformedLocaleException("Hi")); 
 request.fail(new IllegalArgumentException("Bad argument")); 
 // IntegralValue.THIS represents the this pointer inside a member function / constructor. 
 public static IntegralValue create(long value) { if (value >= 0 && value < TYPICAL.length) return TYPICAL[(int) value]; 
 return new ICPPEvaluation[] { getEvaluation() }; 
 public void marshal(ITypeMarshalBuffer buffer, boolean includeValue) throws CoreException { throw new UnsupportedOperationException(); 
 * * The full spec is documented at * https://github.com/lttng/lami-spec/blob/master/lami.md * 
 * Aspect for the IRQ handler names. 
 * Aspect for the IRQ numbers. * * This resolves the IRQ number for a given table, so 0|timer would return 0. 
 * Aspect for IRQ typel, indicating if it is a hardware IRQ or software IRQ. 
 * Aspect for LAMI mixed types. 
 * Aspect for LAMI table entries, which normally correspond to one "row" 
 /** * Pie chart * FIXME NYI */ 
 private static final String UNKNOWN_REPRESENTATION = "?"; //$NON-NLS-1$ 
 return new StringBuffer(UNKNOWN_REPRESENTATION); 
 return new StringBuffer(UNKNOWN_REPRESENTATION); 
<|del|> 
 private static final LamiBoolean TRUE = new LamiBoolean(true); private static final LamiBoolean FALSE = new LamiBoolean(false); public static LamiBoolean instance(boolean value) { return (value ? TRUE : FALSE); } 
 * Copyright (c) 2015, 2016 EfficiOS Inc. and others 
 * Base class for data types allowed in LAMI analysis scripts JSON output. 
 /** * Lami 'disk' value. * * A disk partition can be "sda2". It may always has a parent disk. * * @author Philippe Proulx */ 
 * * This is the representation of an operating system process. * 
 return fValue; 
 throw new IllegalStateException("Some X aspects are time based and some are not"); //$NON-NLS-1$ 
 throw new IllegalStateException("Some Y aspects are continuous and some are not"); //$NON-NLS-1$ 
 throw new IllegalStateException("Some Y aspects are time based and some are not"); //$NON-NLS-1$ 
<|del|> 
 PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() { 
 public void run() { if (viewer.getTree() == null || viewer.getTree().isDisposed()) { return; } 
<|del|> 
import org.junit.runner.RunWith; 
 assertEquals(":a: Image.getBoundsInPixels method doesn't return bounds in Pixel values.", boundsInPixels, DPIUtil.autoScaleUp(bounds)); 
 assertEquals(":b: Image.getBoundsInPixels method doesn't return bounds in Pixel values.", boundsInPixels, DPIUtil.autoScaleUp(bounds)); 
 assertEquals(":a: Size of ImageData returned from Image.getImageDataAtCurrentZoom method doesn't return matches with bounds in Pixel values.", boundsAtCurrentZoom, DPIUtil.autoScaleUp(bounds)); 
 assertEquals(":b: Size of ImageData returned from Image.getImageDataAtCurrentZoom method doesn't return matches with bounds in Pixel values.", boundsAtCurrentZoom, DPIUtil.autoScaleUp(bounds)); 
<|del|> 
<|del|> 
 public Set<IFolder> getFoldersToIgnore(IProject project, IProgressMonitor monitor) { return null; // JSDT doesn't create "rubbish" directories } 
<|del|> 
 return -1; 
 EvalBinding op = new EvalBinding(udlOpFunction, udlOpFunction.getType(), this); 
 if(retValue instanceof ICPPEvaluationOwner) { ICPPEvaluationOwner evalOwner = (ICPPEvaluationOwner)retValue; return new ExecReturn(evalOwner.getEvaluation()); 
 /** * Return an evaluation representing the variable's initialization. * * If the variable has no initializer, null is returned. */ 
 ResourcesPlugin.getWorkspace().addResourceChangeListener(this, IResourceChangeEvent.POST_CHANGE); 
 } if (url == null) { url = bundle.getEntry(path); } if (url != null) { URL localURL = FileLocator.toFileURL(url); return localURL.toString(); } 
 * Copyright (c) 2011, 2016 THALES GLOBAL SERVICES and others. 
 private static @Nullable LamiResultTable currentTable; private static int secondaryViewId = 1; 
 * * This is the implementation of https://github.com/lttng/lami-spec/blob/ * d6129206184988b3fd7cccb76deace4a69c1443e/lami.md * 
 return Messages.LamiIRQTypeAspect_HardwareIRQ; 
 return Messages.LamiIRQTypeAspect_SoftIRQ; 
 * * This is the representation of an operating system process. * 
 throw new UnsupportedOperationException("Unsupported chart type: " + chartModel.toString()); //$NON-NLS-1$ 
 * * This is the implementation of https://github.com/lttng/lami-spec/blob/ * d6129206184988b3fd7cccb76deace4a69c1443e/lami.md * 
 * 
 * Aspect for IRQ type, indicating if it is a hardware IRQ or software IRQ. 
 * Aspect for LAMI mixed types. 
 * Aspect for process TID 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Predicate to use to check whether or not this analysis applies * to a given trace 
 * @return If the X-axis is log scale 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc. and others 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 private static final LamiBoolean TRUE = new LamiBoolean(true); private static final LamiBoolean FALSE = new LamiBoolean(false); public static LamiBoolean instance(boolean value) { return (value ? TRUE : FALSE); } 
 nullToEmptyString(Messages.LamiBoolean_No)); 
 /** * Lami 'disk' value. * * A disk can be "sda". It may contain partitions. * * @author Philippe Proulx */ 
 /** * Lami 'disk' value. * * A disk partition can be "sda2". It may always has a parent disk. * * @author Philippe Proulx */ 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * * This is the representation of an operating system process. * 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Jonathan Rajotte-Julien 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 Ericsson, EfficiOS Inc. and others 
 IStructuredSelection selections = getTableViewer().getStructuredSelection(); 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Michael Jeanson 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc., Alexandre Montplaisir 
 * Copyright (c) 2015, 2016 EfficiOS Inc. and others 
 Set<String> mandatoryValues = getValueLevel().equals(PriorityLevel.MANDATORY) ? getValues() : Collections.EMPTY_SET; 
 * @author Mathieu Rail * @author Genevive Bastien 
 * The possible level for a requirement. 
 public PriorityLevel getValueLevel() { 
 req = new TmfCompositeAnalysisRequirement(ImmutableSet.of(FALSE_REQ1), PriorityLevel.ALL_OR_NOTHING); 
 req = new TmfCompositeAnalysisRequirement(ImmutableSet.of(FALSE_REQ1, FALSE_REQ2), PriorityLevel.ALL_OR_NOTHING); 
 if (port1.isConjugated() == port2.isConjugated()) { return ctx.createFailureStatus(arg, "Assembly connector must have different conjugation between connected ports."); 
 protected void runConnectorCreationTest(Property source, Property sourcePartWithPort, View sourceView, Property target, Property targetPartWithPort, View targetView, boolean canCreate) { 
 expectedValue = createCopy(sourceValue); match.setLeft(expectedValue); 
 * Map of pre-defined charts, for every table class names. 
 /** * Get the title of this analysis, as read from the script's metadata. 
 /** * Get the result table classes defined by this analysis, as read from the * script's metadata. 
 public String getFullCommandAsString(ITmfTrace trace, @Nullable TmfTimeRange range) { 
 * Call the currently defined LAMI script with the given arguments. 
 for (Object y : ySelections) { if(!(y instanceof LamiTableEntryAspect)) { continue; } 
 page.showView(LamiReportView.VIEW_ID, String.valueOf(secondaryViewId), mode); secondaryViewId++; 
 if (!(x instanceof LamiTableEntryAspect) || ySelections.length == 0) { 
 }); 
 int xMouseLocation = event.x; int yMouseLocation = event.y; 
<|del|> 
 * SWTChart workaround: SWTChart fiddles with tick mark visibility 
 getChart().getPlotArea().addMouseListener(new LamiScatterMouseDownListener()); 
 getChart().getPlotArea().addMouseListener(new LamiScatterMouseDownListener()); 
 * multiplier, so when a user hovers the mouse near the dot * the cursor cross snaps to it. 
 * multiplier, so when a user hovers the mouse near the dot * the cursor cross snaps to it. 
 * location, and compare it to the symbol size so when a * user clicks on a symbol it selects it. 
 * location, and compare it to the symbol size so when a * user clicks on a symbol it selects it. 
 // ------------------------------------------------------------------------ // Utility functions // ------------------------------------------------------------------------ 
 Iterator<Color> colorsIt = Iterators.cycle(COLORS); Iterator<Color> lightColorsIt = Iterators.cycle(LIGHT_COLORS); 
 * Fill with light colors to represent the deselected state. The * paint listener is then responsible for drawing the cross and * the dark colors for the selection. 
 * @author France Lapointe Nguyen * @author Alexandre Montplaisir 
<|del|> 
<|del|> 
 public Set<Diff> getDirectMergeDependencies(Diff diff, boolean mergeRightToLeft) { long start = System.currentTimeMillis(); 
 public Set<Diff> getDirectResultingMerges(Diff target, boolean mergeRightToLeft) { long start = System.currentTimeMillis(); 
 public Set<Diff> getDirectResultingRejections(Diff target, boolean mergeRightToLeft) { long start = System.currentTimeMillis(); 
 if (null == container) { 
<|del|> 
 * Martin Fleck - initial API and implementation 
 Set<Entry<Annotation, Position>> entrySet = annotationToPositionMap.entrySet(); for (Entry<Annotation, Position> entry : entrySet) { fModel.addAnnotation(entry.getKey(), entry.getValue()); 
 for (Entry<IAnnotationModel, HashMap<Annotation, Position>> entry : mapsByAnnotationModel.entrySet()) { addAnnotations(entry.getKey(), entry.getValue()); 
 for (Entry<Button, String> entry : fCheckBoxes.entrySet()) { 
public class CPPFieldSpecialization extends CPPVariableSpecialization implements ICPPField { 
 return ((ICPPFieldTemplate) getPrimaryTemplate()).getFieldPosition(); 
 public ICPPExecution getConstructorChainExecution() { if(!isConstexpr()) return null; 
 final List<Pair<IBinding, ICPPEvaluation>> resultPairs = new ArrayList<>(); 
 final Pair<IBinding, ICPPEvaluation> resultPair = new Pair<>(fieldMember, memberEval); 
 return CPPTemplates.instantiateFunctionBody(this, point); 
 return TypeTraits.isLiteralClass(getClassOwner(), fPoint); 
<|del|> 
 ICPPConstructor constructor = getImplicitlyCalledCtor(declarator); if(constructor != null) { 
 /** * ActivationRecord keeps track of the values of parameters and local variables * during the evaluation of a function call. * */ 
 // TODO(nathanridge): Handle this as a case in createSpecialization() public static ICPPVariable createVariableSpecialization(InstantiationContext context, ICPPVariable variable) { 
<|del|> 
 if(type == newType && value == newValue) { return variable; } ICPPVariable newVariable = new CPPVariableSpecialization(variable, context.getContextSpecialization(), context.getParameterMap(), newType, newValue); context.putInstantiatedLocal(variable, newVariable); 
 } else if (decl instanceof ICPPClassType && classOwner != null) { // TODO: Handle local classes 
 } else if (decl instanceof ICPPEnumeration && classOwner != null) { // TODO: Handle local enumerations 
 private static InstantiationContext createInstantiationContext(ICPPTemplateParameterMap tpMap, IBinding owner, IASTNode point) { 
 EvalBinding op = new EvalBinding(overload, overload.getType(), point); 
 newValue = new EvalFixed(fixed2.getType(context.getPoint()), fixed2.getValueCategory(context.getPoint()), fixed2.getValue(context.getPoint())); 
 private boolean hasIntType(ICPPEvaluation arg2, ConstexprEvaluationContext context) { IType type = arg2.getType(context.getPoint()); 
 private boolean isArray(ICPPEvaluation eval, ConstexprEvaluationContext context) { return eval.getType(context.getPoint()) instanceof IArrayType; 
 ICPPEvaluation pointerValue = evalPointer.dereference().getTargetEvaluation(); // TODO(nathanridge): What if the composite being accessed is not an array but a structure? 
 private final class LamiBarChartMouseDownListener extends MouseAdapter { 
<|del|> 
 public PriorityLevel getPriorityLevel() { 
 buffer.flip(); 
 * Get a string from the byte buffer. The first 4 bytes of the buffer * contain the integer value of the size of the strings. The 'size' bytes of * the string follow. 
 * @return get the cause of failure, or null if not applicable 
 @Nullable Throwable getFailureCause(); 
 /** * Represents an access to a sub-value of a composite value, identified by an index. * Composite values can include arrays, structures, and parameter packs (see {@code CompositeValue}). */ 
 private ICPPEvaluation getTargetEvaluation() { 
 return getTargetEvaluation().isValueDependent(); 
 return parent.getTemplateDefinition(); 
 private boolean checkedIsTypeDependent; private boolean isTypeDependent; static private final IASTName tempName = ASTNodeFactoryFactory.getDefaultCPPNodeFactory().newName(); 
 if (!checkedIsTypeDependent) { checkedIsTypeDependent = true; isTypeDependent = CPPTemplates.isDependentType(type) || containsDependentType(arguments); } return isTypeDependent; 
 public boolean isValueDependent() { if (CPPTemplates.isDependentType(type)) return true; for (ICPPEvaluation arg : arguments) { if (arg.isValueDependent()) return true; } 
 return type; 
 int r = CPPTemplates.determinePackSize(type, tpMap); for (ICPPEvaluation arg : arguments) { r = CPPTemplates.combinePackSize(r, arg.determinePackSize(tpMap)); } return r; 
 public boolean referencesTemplateParameter() { for (ICPPEvaluation arg : arguments) { if (arg.referencesTemplateParameter()) return true; } 
 EvalFunctionSet evalFunctionSet = new EvalFunctionSet(functionSet, false, false, newType, context.getPoint()); 
 private String fTitle; private String fMessage; private String fValue = "";//$NON-NLS-1$ private IInputValidator fValidator; private Button fOkButton; private Text fText; private Text fErrorMessageText; private String fErrorMessage; 
 fTitle = dialogTitle; fMessage = dialogMessage; fValue = "";//$NON-NLS-1$ fValidator = validator; fBaseCommand = baseCommand; 
<|del|> 
<|del|> 
 * Selection listener 
 * Table viewer to use in {@link LamiReportView}s. 
 * Since most of the external viewers deal only with continuous time * ranges and do not allow multi-time range selection, simply signal * only when one selection is present. 
 fail(e.getMessage()); 
 Map<String, LamiTableClass> tableModels = analysis.getTableClasses(); 
 * Copyright (c) 2015, 2016 Red Hat. 
 return gridCell.getPreferredSize() != null ? gridCell.getPreferredSize() : DEFAULT_PREFERRED_SIZE; 
 return new IHyperlink[0]; 
<|del|> 
 * Copyright (c) 2016 Zeligsoft (2009) Limited and others. * 
 * Contributors: * Young-Soo Roh - Initial API and implementation * 
 if (request.getContainmentFeature() != UMLPackage.Literals.STRUCTURED_CLASSIFIER__OWNED_CONNECTOR) { 
 public ICPPEvaluation computeForFunctionCall(ActivationRecord callSiteRecord, ConstexprEvaluationContext context) { 
<|del|> 
 ICPPField[] baseFields = (ICPPField[])ClassTypeHelper.getFields(baseClassType, context.getPoint()); 
 ICPPField[] baseFields = (ICPPField[])ClassTypeHelper.getFields(baseClassType, context.getPoint()); 
 for(Entry<IBinding, ICPPEvaluation> ccInitializer : memberInitList.getConstructorChainInitializers().entrySet()) { final IBinding member = ccInitializer.getKey(); 
 ExecReturn execReturn = (ExecReturn) bodyExec; 
 if (funcEval instanceof EvalFunctionSet) { 
 getTemplateDefinition()); 
 new EvalCompositeAccess(evaluatedOwner, fieldPos), getTemplateDefinition()); 
public class EvalPointer extends EvalReference { // The position will only be nonzero if the EvalReference has a referredSubValue, // not a referredBinding. 
 public EvalPointer(ActivationRecord record, EvalCompositeAccess referredSubValue, IBinding templateDefinition) { this(record, referredSubValue, templateDefinition, referredSubValue.getElementId()); 
 public EvalPointer(ActivationRecord record, EvalCompositeAccess referredSubValue, IBinding templateDefinition, int offset) { super(record, referredSubValue, templateDefinition); 
 referredSubValue = new EvalCompositeAccess(EvalFixed.INCOMPLETE, 0); referredBinding = null; 
 return referredSubValue != null && (position - referredSubValue.getParent().getValue(null).numberOfSubValues() > 0 || position < 0); 
 public IValue getValue(IASTNode point) { // TODO(nathanridge): Why does it make sense to consider a pointer's value to be its offset // into the underlying array? 
 EvalReference(ActivationRecord owningRecord, IBinding referredBinding, IBinding templateDefinition) { super(templateDefinition); 
 EvalReference(ActivationRecord owningRecord, EvalCompositeAccess referredSubValue, IBinding templateDefinition) { super(templateDefinition); 
 public ICPPEvaluation getTargetEvaluation() { 
 if (referredEval instanceof EvalReference) { // TODO(nathanridge): Why are we doing this for EvalReference only? 
 // TODO(nathanridge): Why are we losing the EvalReference wrapper here? return getTargetEvaluation().instantiate(context, maxDepth); 
 EvalBinding op = new EvalBinding(overload, overload.getType(), point); 
 EvalFixed newValue = new EvalFixed(evalUnary.getType(context.getPoint()), evalUnary.getValueCategory(context.getPoint()), evalUnary.getValue(context.getPoint())); 
 if (this.getValueCategory(context.getPoint()) == ValueCategory.LVALUE) { 
 public static IValue getConditionExprValue(ICPPEvaluation conditionExprEval, ActivationRecord record, ConstexprEvaluationContext context) { return conditionExprEval.computeForFunctionCall(record, context.recordStep()).getValue(context.getPoint()); 
 public static IValue getConditionExprValue(ICPPEvaluation conditionExprEval, ActivationRecord record, ConstexprEvaluationContext context) { return conditionExprEval.computeForFunctionCall(record, context.recordStep()).getValue(context.getPoint()); 
 computedInitializerEval = new EvalFixed(type, computedInitializerEval.getValueCategory(context.getPoint()), compVal); 
 initValue = initializerEval.getValue(context.getPoint()).get(0); 
 ICPPEvaluation initValue = initializerEval.getValue(context.getPoint()).get(0); if (isPointerToArray(initValue, context)) { 
<|del|> 
 ICPPEvaluation[] range = valueRange.getValue(context.getPoint()).getAll(); 
 private static ICPPEvaluation deref(ICPPEvaluation ptr, boolean isRef, ActivationRecord record, ConstexprEvaluationContext context) { 
 private static ICPPEvaluation inc(ICPPEvaluation ptr, IASTNode point) { 
 EvalBinding op = new EvalBinding(func, func.getType(), context.getPoint()); 
 boolean executionsDidChange = false; 
 * - all of its non-static data members and base classes are of non-volatile literal types * TODO: The last property isn't being checked. 
 protected static final int FIELD_POSITION_OFFSET = PDOMCPPVariable.RECORD_SIZE; // byte 
 return ((ICPPField)getSpecializedBinding()).getFieldPosition(); 
 return getByte(record + FIELD_POSITION_OFFSET); 
 return ((ICPPField)getPrimaryTemplate()).getFieldPosition(); 
<|del|> 
<|del|> 
 * The initialize() phase of the analysis will be used to check the * script's metadata. Actual runs of the script will use the execute() * method below. 
 * The initialize() phase of the analysis will be used to check the * script's metadata. Actual runs of the script will use the execute() * method below. 
 public IStructuredItemContentProvider getStructuredItemContentProvider(EObject self) { 
 public Collection<?> getStructuredItemContentProviderElements(EObject self) { IStructuredItemContentProvider scp = getStructuredItemContentProvider(self); 
 public Collection<?> getStructuredItemContentProviderElements(EObject self) { IStructuredItemContentProvider scp = getStructuredItemContentProvider(self); 
 * Copyright (c) 2015, 2016 EfficiOS Inc. and others 
 label.setFont(boldFont); label.addDisposeListener(event -> boldFont.dispose()); 
 Color color = new Color(parent.getDisplay(), 0xe7, 0x4c, 0x3c); label.setForeground(color); 
 Font font = fd.createFont(parent.getDisplay()); label.setFont(font); 
 @Override public void create() { super.create(); Shell shell = getShell(); shell.setMinimumSize(shell.getSize()); } 
<|del|> 
 public abstract Image getIcon(); 
<|del|> 
<|del|> 
<|del|> 
 public boolean cmakeGen = false; // TODO - provide config choice, or migrate to cmake - set true to gen cmake files 
 long us = Math.abs((value % 1000000) / 1000); // 0-999 microseconds 
 List<ITmfStateInterval> kernelState = ss.queryFullState(clampedEnd); 
 label.addDisposeListener(event -> boldDescriptor.destroyFont(boldFont)); 
 fd.destroyFont(font); 
 * Constructor. 
 } catch (TimeRangeException | AttributeNotFoundException e) { 
 public Properties getProviderSpecificProperties() { 
 protected IJavaProject getJavaProject(IStackFrame stackFrame) { 
 javaElement = getJavaElement(sourceElement); 
 && (gPath.getRoot() == lPath.getRoot() || gPath.getRoot() != null && gPath.getRoot().equals(lPath.getRoot())) 
 private static final String BUNDLE_NAME = "org.eclipse.tracecompass.internal.analysis.os.linux.core.latency.messages"; //$NON-NLS-1$ 
 return new Properties(); 
<|del|> 
<|del|> 
 throw new UnsupportedOperationException(JGitText.get().cannotBeCombined); 
 protected final HistoryTree getSHT() { 
 || parameter.getDirection() == ParameterDirectionKind.RETURN_LITERAL || parameter.getDirection() == ParameterDirectionKind.OUT_LITERAL) { 
 private static IQuerySpecificationRegistry createRegistry() { 
 IQuerySpecificationRegistry registry = QuerySpecificationRegistry.getInstance(); IQuerySpecification<?> querySpecification = registry.getDefaultView().getEntry(fqn).get(); c.patterns.add(querySpecification); 
 * the space in points from the origin of the text layout to the respective 
 Ref ref = repo.exactRef(notesRef); 
 Ref ref = repo.exactRef(notesRef); 
 for (int i = 0; i < array.length; i++) { if (array[i] instanceof ISegment) { fStore.add((E) array[i]); 
 boolean isFiltered = true; 
 if (persist) { SkynetTransaction transaction = TransactionManager.createTransaction(artifacts.iterator().next().getBranch(), "Prompt change boolean"); 
 ResourcesPlugin.getWorkspace().run(create, monitor); 
<|del|> 
 if (confirmationMode == ImportConfirmation.RENAME_ALL) { fBot.waitUntil(Conditions.shellIsActive("Confirmation")); SWTBotShell shell2 = fBot.activeShell(); 
 private void testImport(int options, boolean testViews, boolean fromArchive, boolean defaultExperiment, boolean clearTraces, ImportConfirmation confirmationMode) throws Exception { 
 // Delete resource existing in workspace existingResource.delete(true, monitor); 
 private void setExistingResource(IPath tracePath) { fExistingResource = null; 
 IPath folderPath = folder.getFullPath(); int commonLength = tracePath.matchingFirstSegments(folderPath); IPath relativePath = tracePath.removeFirstSegments(commonLength); 
<|del|> 
 doit(caretOffset, lineLength, "", false, true); //$NON-NLS-1$ document.replace(document.getLineOffset(lineNo), lineLength, ""); //$NON-NLS-1$ 
 * <code>true</code> if the script originated from a shell/interactive session 
<|del|> 
 public List<IContextInformation> computeContextInformation(final ContentAssistInvocationContext context, final IProgressMonitor monitor) { 
 CreationMenuRegistry.getInstance().loadCreationMenuModel(URI.createPlatformResourceURI(selectedFile.getFullPath().toString(), true)); 
 CreationMenuRegistry.getInstance().unloadCreationMenuModel(URI.createPlatformResourceURI(selectedFile.getFullPath().toString(), true)); 
 checkbox.setText(getName(folder)); checkbox.setToolTipText(getToolTipText(folder)); 
 fStore.sort(COMPARATOR); 
 private static final String DEFAULT_PAGE_LABEL = "General"; //$NON-NLS-1$ 
 synchingToTime(fTimeGraphViewer.getSelectionBegin()); 
 if (rLck != null) { 
<|del|> 
 return null; 
 Group colorsGroup; HashMap <Integer, String> hmap = new HashMap <> (); 
<|del|> 
<|del|> 
 colors.setHeaderVisible(true); 
<|del|>
<|del|> 
 HashMap <Integer, String> hmap = new HashMap <> (); static final int namedColorEnd = 8; 
 /*Adding elements to HashMap*/ 
 } 
 @Override public void widgetSelected (SelectionEvent event) { packColumns (); setExampleWidgetSize (); } 
 return project.getLocation().toString(); 
 return createdProject.getLocation().toString(); 
 /** * Iterates over the Spinner components to find the button with the * given name. * @param buttonName the button's name that should be found * @return the button or null if it could not be found */ 
 * IBM - Initial API and implementation * Eugen Neufeld - Left only Undo and Redo actions */ 
<|del|> 
 Assert.assertNotNull(versionToTarget); versionToTarget.setBaselineBranchUuid(viaTeamDefBranch.getUuid()); versionToTarget.setAllowCommitBranch(true); versionToTarget.setAllowCreateBranch(true); 
<|del|> 
 name = "invalid name"; 
 if (firstArtifact == null) { throw new OseeCoreException("Must make a selection"); 
 if (firstArtifact == null) { throw new OseeCoreException("Must make a selection"); 
<|del|> 
 if (verArt == null) { AWorkbench.popup("ERROR", "Select a version."); return; 
 Set<Long> uuids = new HashSet<>(); if (oseeDsl != null) { for (EObject object : oseeDsl.eContents()) { if (object instanceof OseeType) { addUuid(uuids, (OseeType) object); } 
 * IBM Corporation - initial API and implementation * Ian Pun <ipun@redhat.com> - addition of Color tab 
 * IBM Corporation - initial API and implementation * Ian Pun <ipun@redhat.com> - addition of Spinner test class 
 Spinner spinner; 
 public void test_computeSizeIIZ() { // super class test is sufficient 
 assertEquals(spinner.getIncrement(), cases[cases.length-1]); 
 assertEquals(spinner.getDigits(), cases[cases.length-1]); 
 assertEquals(spinner.getMaximum(), 1000); 
 assertEquals(spinner.getMinimum(), 2); 
 assertEquals(spinner.getMinimum(), 2); 
 assertEquals(spinner.getPageIncrement(), cases[cases.length-1]); 
 spinner.setValues(selection[i], minimum[i], maximum[i], digits[i], increment[i], pageIncrement[i]); 
 assertEquals(spinner.getText(), "5"); 
 * * This is the implementation of https://github.com/lttng/lami-spec/blob/ * d6129206184988b3fd7cccb76deace4a69c1443e/lami.md * 
 if (PHPCoreConstants.CODEASSIST_AUTOINSERT_COMMON_PREFIX.equals(event.getKey())) { 
 public static final String ATTRIBUTE_PRIORITY_LABEL = "task.common.priority.label"; //$NON-NLS-1$ 
 * @param alreadyProcessedContainedMatches * already processed matches that are contained in the match of the given * <code>match</code>. 
 if ("P5".equals(string)) { //$NON-NLS-1$ 
 try { PriorityLevel.valueOf(string); return true; } catch (IllegalArgumentException e) { return false; } 
 if (hasChanges(task.getAttribute(ITasksCoreConstants.ATTRIBUTE_PRIORITY_LABEL), priorityLabel, TaskAttribute.PRIORITY)) { 
 public PriorityLevel getPriorityLevel(TaskAttribute priorityAttribute, String priorityOption) { return PriorityLevel.fromString(priorityOption); 
 public PriorityLevel getPriorityLevel(TaskAttribute priorityAttribute, String priorityOption) { return PriorityLevel.fromString(priorityOption); 
 private final TaskAttribute attribute; 
 public static final String ATTRIBUTE_PRIORITY_LABEL = "task.common.priority.label"; //$NON-NLS-1$ 
 * Predicate to use to check whether or not this analysis applies * to a given trace 
 try { isServerInfoReady(); 
 } finally { monitor.done(); 
<|del|> 
 * already processed matches that are contained in the given <code>match</code>. 
 * already processed matches that are contained in the given <code>match</code>. 
 if (operation.equals(callEvent.getOperation())) { 
 Thread.sleep(t); t = t * 2; 
 * @since 4.4 
<|del|> 
 * directory will remain unchanged. Otherwise it will silently deal with the * problem. The default value is <code>false</code>. 
<|del|> 
 MessageDialog.openError(getShell(), "Error", e.getMessage()); //$NON-NLS-1$ monitor.done(); return; 
<|del|> 
 expireAfterMillis = TimeUnit.HOURS.toMillis(1); cleanupDelayMillis = AUTO_CLEANUP_DELAY; 
 private static final String CREATE_SESSION_KERNEL_SCENARIO_NAME = "CreateSessionAllKernelEvents"; 
 Set<String> typeNameSet = Sets .newHashSet(Iterables.transform(allPossibleTypes, TYPENAME)); 
 /** * Reduces the type descriptor set by providing the most specific set of type descriptors inferrable for a selected 
 * It is intended to run SWT JUnit tests on multiple GTK versions in batch. Ex GTK2.24, GTK3.14 GTK3.16 etc.. 
 if (cleanupDelayMillis < 0) { 
<|del|> 
 } finally { monitor.done(); 
<|del|> 
 private final Listener listener = new Listener() { 
 public void setTransactionId(int value) { this.transactionId = value; 
 List<Integer> processQuarks = ss.getQuarks(((AbstractCallStackAnalysis) module).getProcessesPattern()); 
 int callStackQuark = ss.getQuarkRelative(threadQuark, ((AbstractCallStackAnalysis) module).getCallStackPath()); actualQuarks = ss.getSubAttributes(callStackQuark, false); int quarkParent = actualQuarks.get(0); 
 int callStackQuark = ss.getQuarkRelative(threadQuark, ((AbstractCallStackAnalysis) module).getCallStackPath()); actualQuarks = ss.getSubAttributes(callStackQuark, false); int quarkParent = actualQuarks.get(0); 
 findChildren(segment, actualQuarks.get(callStackQuark + 1), ss, maxQuark); 
 fSegmentStatics.calculateStatistics(segment); 
 * Returns the excluded events. * @return excluded events 
 * Returns the excluded events. * @return excluded events 
 * Sets the excluded events. * @param events The excluded events to set 
 * Sets the excluded events. * @param events The excluded events to set 
 private List<String> fExcludedEvents; 
 public List<String> getExcludedEvents() { return fExcludedEvents; 
 public List<String> getExcludedEvents() { 
 List<String> getExcludedEvents(); 
 enableEvents(param, ILttngControlService.ALL_EVENTS, dialog.isKernel(), filter, dialog.getExcludedEvents(), monitor); 
 * @param excludedEvents 
 public void enableEvents(List<String> eventNames, String filterExpression, List<String> excludedEvents, IProgressMonitor monitor) throws ExecutionException { getControlService().enableEvents(getSessionName(), getName(), eventNames, isKernel(), filterExpression, excludedEvents, monitor); 
 * @param excludedEvents 
 public void enableEvents(List<String> eventNames, String filterExpression, List<String> excludedEvents, IProgressMonitor monitor) 
 * @param excludedEvents 
 String filterExpression, List<String> excludedEvents, IProgressMonitor monitor) throws ExecutionException { 
 * @param excludedEvents 
 List<String> eventNames, boolean isKernel, String filterExpression, List<String> excludedEvents, 
 public void enableEvents(String sessionName, String channelName, List<String> eventNames, boolean isKernel, String filterExpression, List<String> excludedEvents, IProgressMonitor monitor) throws ExecutionException { 
 * Command line option for configuring excluded event 
 eventInfo.setExcludedEvents(tmpString.toString()); 
 Iterables.removeAll(filteredChildren, hiddenChildren); 
 public static List<Pseudostate> getInitialPseudoStates(Region region) { 
 throw new ExecutionException("Element creation problem for Transition " + "."); 
<|del|> 
 public static List<Pseudostate> getInitialPsudoStates(Region region) { List<Pseudostate> pseudoStates = new ArrayList<>(); 
 public static List<Pseudostate> getInitialPsudoStates(Region region) { List<Pseudostate> pseudoStates = new ArrayList<>(); 
 for (int i = 0; i < cases.length; i++){ 
 if (setFlag){ 
 if (setFlag){ 
 if (setFlag){ 
 if (setFlag){ 
 if (setFlag){ 
 if (setFlag){ 
 if (newDuration == 0 || count == 0) { 
 newWindowStartTime = validateWindowStartTime(newWindowStartTime); xAxis.setRange(new Range(newWindowStartTime - viewer.getTimeOffset(), newWindowEndTime - viewer.getTimeOffset())); 
 final int targetStep = 100; 
 assertTrue("The VSM Group must contains a default viewpoint.", ownedViewpoints.size() == 1); 
<|del|> 
 public void ensureIndexed(IInputKey key, IndexingServices service); 
 * Bergmann Gabor - initial API and implementation * Balazs Grill - Added support for different indexing levels 
<|del|> 
 if (saveables != null) { saveables.addModelLifecycleListener(saveablesTracker); } 
 if (saveables != null) { saveables.removeModelLifecycleListener(saveablesTracker); } 
 List hiddenChildren = Lists.newArrayList(); 
<|del|> 
 profile = (Profile) createResource.getContents().get(0); } else { createResource.unload(); 
 List<Object> element = getRoot(); 
 public StereotypeQualifyNameValueEditor(final Composite parent, final int style) { 
 if (((e.stateMask & SWT.SHIFT) == 0) || (fEndTime == fBeginTime)) { 
 * Copyright (c) 2014, 2016 Obeo. 
 super(nullToEmptyString(definition.definitionName), getRootField(definition)); 
 /** Event type tag * @since 2.1*/ public static final String TAG_EVENT_TYPE = Messages.CustomTraceDefinition_eventTypeTag; 
 /** Event type tag * @since 2.1*/ public static final String TAG_EVENT_TYPE = Messages.CustomTraceDefinition_eventTypeTag; 
<|del|> 
 tagCombo.select(2); 
 case 1: // Event type 
 tagCombo.setItems(new String[] { CustomXmlTraceDefinition.TAG_IGNORE, CustomTraceDefinition.TAG_TIMESTAMP, CustomTraceDefinition.TAG_EVENT_TYPE, CustomTraceDefinition.TAG_MESSAGE, CustomTraceDefinition.TAG_OTHER }); 
 tagCombo.setItems(new String[] { CustomTraceDefinition.TAG_TIMESTAMP, CustomTraceDefinition.TAG_EVENT_TYPE, CustomTraceDefinition.TAG_MESSAGE, CustomTraceDefinition.TAG_OTHER }); tagCombo.select(3); // Other 
 actionCombo.setItems(new String[] { Messages.CustomXmlParserInputWizardPage_set, Messages.CustomXmlParserInputWizardPage_append, Messages.CustomXmlParserInputWizardPage_appendWith }); 
 } else if (inputAttribute.getInputName().equals(CustomTraceDefinition.TAG_EVENT_TYPE)) { 
 * Returns true if index is available for the given key providing all of the given services. 
 /** * @return true iff the given input key is already indexed, and contents are available without costly model traversal. * @deprecated use */ @Deprecated public boolean isIndexed(IInputKey key); /** 
 private static final String LOGGING_PROPERTY = "org.eclipse.tracecompass.logging"; //$NON-NLS-1$ private static final Logger TC_PARENT_LOGGER = Logger.getLogger("org.eclipse.tracecompass"); //$NON-NLS-1$ 
 * Copyright (c) 2016 cole Polytechnique de Montral and others 
 LOGGER.info(() -> "[ZoomThreadCanceled]"); //$NON-NLS-1$ 
 public void incorrectZombieGroupingWithoutProfileNamespaceURIPattern_bug496307() { 
 EClass packageBzombieClass = packageBzombie.eClass(); assertThat("PackageB zombie should be ViewPoint", packageBzombieClass.getName(), is("ViewPoint")); } finally { // ensure that the pattern is unregistered for further tests registry.unregister(pattern); } 
 System.arraycopy(availableTraceTypes,0,traceTypeList,1,availableTraceTypes.length); 
 private static void runOneBenchmark(@NonNull CtfTestTrace testTrace, String testName, RunMethod method, Dimension dimension) { 
 public static final ProfileNamespaceURIPatternRegistry INSTANCE = new ProfileNamespaceURIPatternRegistry(); 
 * <i>blockCommentStart</i><br/> * -----BEGIN SIGNATURE-----<br/> * Hash:SHA1 Provider:SUN <br/> * <br/> 
 * @param inputStream * provide {@link InputStream} to get signature from 
 public static SignatureInfo getSignatureInfo(final InputStream inputStream) throws ScriptSignatureException { 
 /** * Public constructor to store variables related to signature of script. It is preferable to provide the required values. 
<|del|> 
 setProperty(ComparePreferencePage.LAYOUT, fPreferenceStore.getString(ComparePreferencePage.LAYOUT)); 
 addLayoutCombo(composite); 
 Command moveCmd = new RecordingCommand(session.getTransactionalEditingDomain()) { 
 Command removeRepresentationCmd = new RecordingCommand(session.getTransactionalEditingDomain()) { 
 Command addDiagramCmd = new RecordingCommand(session.getTransactionalEditingDomain()) { 
 List<DRepresentation> cleanRepresentations(EList<DRepresentation> representations); 
 refreshRepresentation(obviousDiagram); refreshRepresentation(evoluateDiagram); 
 public void refreshRepresentation(final DRepresentation diagram) { 
 public Iterator<EObject> getAllContentInRepresentations(final Predicate<? super EObject> predicate) { 
 * @since 1.4 
 * @deprecated use {@link #isIndexed(IInputKey, IndexingService)} instead 
 * Check to see if the selected item is also the topItem. If it is, that means topItem is * in sync with the GTK view. If not, the real top item should be the last selected item, which is caused 
 * Check to see if the selected item is also the topItem. If it is, that means topItem is * in sync with the GTK view. If not, the real top item should be the last selected item, which is caused 
 // if topItem isn't set and there is nothing selected, topItem is the first item on the Tree 
 // Use GTK method to get topItem if there has been changes to the vAdjustment 
 topItem = item; 
 * </p> 
 needinfoProvider.setId(element.getAttribute("id")); needinfoProvider.setHumanReadableDescription(element.getAttribute("humanReadableDescription")); 
 if (needinfo.equals(needinfoProviderDescriptor.getId())) { 
 int informationStart = comment.indexOf(MessageFormat.format(INFORMATION_START, provider.getHumanReadableDescription())); 
 int informationEnd = comment.indexOf(MessageFormat.format(INFORMATION_END, provider.getHumanReadableDescription()), 
 /** * Gets the webkit version, within an <code>int[3]</code> array with * <code>{major, minor, micro}</code> version */ private static int[] internalGetWebkitVersion(){ 
 if (object != null){ Preconditions.checkArgument(object instanceof ICostFunction); 
<|del|> 
 if (attribute != null) { String attributeValue = attribute.get(); Assert.isNotNull(attributeValue); return attributeValue; } return ""; 
 * {@code null}. 
 * @return a supplier which will return the actual attribute value or * {@code null} if the attribute isn't set for the widget. 
 return () -> swtStyles != null ? swtStyles : ""; 
 return () -> attributeType != null ? attributeType : ""; 
 /** * Propagates state changes of the saveable part tracked by this properties * view, to properly update the dirty status. See bug 495567 comment 18. */ 
 for (Saveable saveable : saveables) { // check if the saveable is for the current part 
<|del|> 
import java.util.function.BiConsumer; 
 /** * @author Angel Avila */ 
 resources.add(new DatastoreEndpointImpl(orcsApi, activityLog)); resources.add(new KeyValueResource(orcsApi)); 
 dynamicMenu.setLabelProvider(labelProvider); dynamicMenu.addPulldownMenu(viewer, compareInput.gerritClient); 
 new GulpLaunch().launch(fileSelection, GULP_TASK_RUN); 
 return !CreatableEObjectAxisUtils.getCreatableElementIds(table, true).isEmpty(); 
 return !super.checkMoreConstraints(table) && !CreatableEObjectAxisUtils.getCreatableElementIds(table, false).isEmpty(); 
 return !super.checkMoreConstraints(table) && CreatableEObjectAxisUtils.getCreatableElementIds(table, false).isEmpty(); 
 Utils.drawText(gc, name, bounds.x, bounds.y, bounds.width, bounds.height, true, true); 
 * Appends given signature, messageSigestAlgorithm, provider, and certificate to given file.<br/> * Format for appending signature will be as follows: * <p> 
 AbstractRegistry.DOCKERHUB_REGISTRY, 
 AbstractRegistry.DOCKERHUB_REGISTRY, 
 GridDataFactory.fillDefaults().grab(true, false).hint(INTRO_TEXT_WIDTH_HINT, SWT.DEFAULT) .applyTo(introductionText); 
<|del|>
 IO.skipFully(in, n - 4); 
 default <T> @Nullable T getFieldValue(Class<T> type, @NonNull String @NonNull ... fieldName) { 
 fBot.waitUntil(new TraceDeletedCondition()); 
 return Optional.empty(); 
 configuredDirs, allowBare); 
 this(existingDirs, false, true); 
 private boolean allowBare; 
 util.getConfiguredRepositories(), true); 
 configuredDirs, !allowBare); 
 return Files.isSameFile(f1.toPath(), f2.toPath()); 
 System.arraycopy(files, 0, filesByLocation, 0, files.length); // Sorting files to search by location allows to more easily reuse // search results from one file to the other when they have same location 
<|del|> 
 default <T> @Nullable T getFieldValue(@NonNull Class<T> type, @NonNull String @NonNull ... fieldName) { 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Angel Avila */ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Angel Avila */ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Angel Avila */ 
 return updateLocation; 
 * Builtin filter commands are starting with this prefix 
 public static FilterCommandFactory registerCommand(String commandName, FilterCommandFactory fact) { 
 * Built-in LFS clean filter 
public class CleanFilter extends FilterCommand { 
 * The factory is responsible for creating instances of {@link CleanFilter} * . This factory can be registered using * {@link Repository#registerCommand(String, FilterCommandFactory)} 
 public final static FilterCommandFactory FACTORY = new FilterCommandFactory() { 
 * Registers this filter by calling * {@link Repository#registerCommand(String, FilterCommandFactory)} 
 // The outputstream into which the filtered content should be copied private OutputStream out; 
 public static final String HASH_FUNCTION_NAME = Constants.LONG_HASH_FUNCTION .toLowerCase().replace("-", ""); //$NON-NLS-1$ //$NON-NLS-2$ 
 * Encode this object into the LFS format defined by {@link #VERSION} 
 * the path to the LFS media directory. Will be "<repo>/.git/lfs" 
 public Path createTmpFile() throws IOException { 
 public final static FilterCommandFactory FACTORY = new FilterCommandFactory() { 
 private InputStream in; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 protected final String DOCKER_DAEMON_DEFAULT = AbstractRegistry.DOCKERHUB_REGISTRY; 
 public static final String SELECTED_IMAGE_NAME = "selectedImageName"; //$NON-NLS-1$ 
 public static final String FORCE_TAGGING = "forceTagging"; //$NON-NLS-1$ 
 config.getTimeUnit("core", null, "repositoryCacheExpireAfter", //$NON-NLS-1$//$NON-NLS-2$ getExpireAfter(), TimeUnit.MILLISECONDS)); 
 * @return The parent CTabFolder or <code>null</code>. * * @since 2.0 
 if (null != cTabFolder) { cTabFolder.removeSelectionListener(getCTabFolderSelectionListener()); 
 * @return the observables. * * @since 2.0 
<|del|> 
 Saveable[] saveables = event.getSaveables(); if (saveables == null) { return; } 
 ISaveablesLifecycleListener saveables = getSite().getService(ISaveablesLifecycleListener.class); if (saveables instanceof SaveablesList) { ((SaveablesList) saveables).addModelLifecycleListener(saveablesTracker); 
 ISaveablesLifecycleListener saveables = getSite().getService(ISaveablesLifecycleListener.class); if (saveables instanceof SaveablesList) { ((SaveablesList) saveables).removeModelLifecycleListener(saveablesTracker); 
 for (ITask task : toImport.getChildren()) { toImport.internalRemoveChild(task); 
 } catch (org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException | java.io.IOException | CoreException e) { if (TypeHierarchy.DEBUG) { 
 if (discoveredTypes.add(subType)) { 
 private final BitSet reserved = new BitSet(); 
<|del|> 
 leftToRight = ICompareUIConstants.PREF_VALUE_LEFT_TO_RIGHT .equals(cc.getProperty(ComparePreferencePage.LAYOUT)); 
 leftToRight = ICompareUIConstants.PREF_VALUE_LEFT_TO_RIGHT .equals(event.getNewValue()); 
 store.setDefault(LAYOUT, ICompareUIConstants.PREF_VALUE_LEFT_TO_RIGHT); 
 private void addLayoutCombo(Composite parent) { 
 private String[] getLayoutEntry(String value) { 
<|del|> 
 Job job = new Job(Messages.CallStackTableViewer_) { 
 long /*int */ window = paintWindow(); 
 if (null != text) { 
 if (null == timer) { 
 if (null != targetValidator) { 
 if (null != modelValidator) { 
 if (null == binding) { 
 if (null != modelProperty) { // Bug 433169: The widget may be used without an Observable Value (setValue + getValue) if (null != modelProperty.getValue()) { 
 if (null != timer) { 
 if (null != binding) { 
 if (null == rootMemento) { 
 if (null != resource) { 
 if (null == provider) { 
 if (activeEditorPart instanceof IViewerProvider) { Viewer viewer = ((IViewerProvider) activeEditorPart).getViewer(); if (viewer != null) { viewer.refresh(); } } 
 if (null != mostRecentCommand) { 
 if (null == propertySheetPage) { 
 if (null != displayEngine) { 
 if (null == eObject) { 
public interface ICostFunction{ 
 * 
 CoreText.DeleteBranchOperation_Canceled); 
<|del|> 
 public StyledString getStyledText(final Object element) { 
<|del|> 
 public String getText(final Object element) { 
<|del|> 
<|del|> 
 public ILabelProvider getLabelProvider(final String propertyPath) { 
<|del|> 
 public StyledString getStyledText(final Object element) { 
 public void testGetProxyForHostEmptyProxy() { Proxy defaultProxy = WebUtil.getProxy("localhost", IProxyData.HTTP_PROXY_TYPE); 
 public static @Nullable String TidAnalysisModule_Description; 
 * An interface that trace classes can implement if they have a known size, so * that reading progress can be shown. 
 SubMonitor subMonitor = SubMonitor.convert(monitor); 
 subMonitor.beginTask("", fTraceWithSize.size()); //$NON-NLS-1$ 
 final int done = fTraceWithSize.progress(); subMonitor.setWorkRemaining(fTraceWithSize.size() - done); subMonitor.worked(done); 
 final int done = fTraceWithSize.progress(); subMonitor.setWorkRemaining(fTraceWithSize.size() - done); subMonitor.worked(done); 
 * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html */ /** 
 fDebuggedProcessesAndNames.put(finalPId, name); break; 
 fDebuggedProcessesAndNames.put(finalPId, name); break; 
 // from GDB; but to be more future-proof, might as well 
 // from GDB; but to be more future-proof, might as well 
<|del|> 
 ISelection selection = queryTreeViewer.getSelection(); 
 Object value = null; 
 subMonitor.worked(done - alreadyDone); alreadyDone = done; 
<|del|> 
 /* * FIXME: change to !Iterables.isEmpty(getDependentAnalyses()) when * analysis dependencies work better */ return true; 
 } /* * TODO: parallelize if applicable, just make a loop to schedule all * the dependent analyses */ 
 if (artifactTypes != null || !artifactTypes.isEmpty()) { 
 allArtTypes = getArtifactTypesFromWorkItemTypes(); 
 for (ITask task : toImport.getChildren()) { toImport.internalRemoveChild(task); 
 * 
 if (container != null) { try { IFile file = WorkbenchResourceUtil.findFileRecursively(container, RunGulpTaskCommand.GULP_FILE_NAME); return file != null && file.exists(); } catch (CoreException ex) { 
public abstract class CallGraphAnalysis extends TmfAbstractAnalysisModule implements ISegmentStoreProvider { 
 Iterable<IAnalysisModule> dependentAnalyses = getDependentAnalyses(); for (IAnalysisModule module : dependentAnalyses) { if (!(module instanceof AbstractCallStackBaseAnalysis)) { 
 private boolean iterateOverStateSystem(@Nullable ITmfStateSystem ss, String[] threadsPattern, String[] processesPattern, String[] callStackPath, IProgressMonitor monitor) { 
<|del|> 
 .filter(listener -> listener instanceof IAnalysisProgressListener) 
 * A call Stack function represented as an {@link ISegment}. It's used to build * a segments tree based on the state system. The parent represents the caller * of the function, and the children list represents its callees. 
 private static final long serialVersionUID = -3257452887960883177L; 
 setContent(new CustomEventContent(customEventContent.getName(), customEventContent.getValue(), fColumnData)); 
<|del|> 
<|del|> 
<|del|> 
 private static final long serialVersionUID = -3257452887960883177L; 
 private void setParent(CalledFunction parent) { 
<|del|> 
 Job job = new Job(Messages.CallGraphAnalysis) { 
<|del|> 
 * Name of the job executing the callGraphAnalysis 
 getBackground().getRGB(), getForeground().getRGB(), 
 private static final long serialVersionUID = 7594768649825490010L; 
 if (null != stereotypeQualifiedName && stereotypeQualifiedName.contains(NamedElementUtil.QUALIFIED_NAME_SEPARATOR)) {// $NON-NLS-1$ oldProfile = stereotypeQualifiedName.split(NamedElementUtil.QUALIFIED_NAME_SEPARATOR)[0];// $NON-NLS-1$ 
 String profile = ((String) value).split(NamedElementUtil.QUALIFIED_NAME_SEPARATOR)[0];// $NON-NLS-1$ 
<|del|> 
 if (s.endsWith("/")) //$NON-NLS-1$ 
 String[] prevFullAttribute = null, curFullAttribute = null; 
 * Ericsson - Initial API and implementation 
 assertEquals("Number of segments found", LARGE_AMOUNT_OF_SEGMENTS, segments.length, ERROR); 
 * taken from the Fibonacci trace's callStack shows the structure of the segment 
 } // TODO:Look at updates while the state system's being built 
<|del|> 
 if (!findChildren(segment, depth, stateSystem, fCurrentQuarks.size() + fCurrentQuarks.get(depth), monitor)) { 
 * A Call stack function represented as an {@link ISegment}. It's used to build 
 @Nullable private CalledFunction fParent = null; 
 return TmfTraceUtils.getAnalysisModuleOfClass(trace, CallGraphAnalysis.class, CallGraphAnalysisUI.ID); 
 String symbolText = provider.getSymbolText(calledFunction.getAddr()); return symbolText == null ? "0x" + calledFunction.getAddr() : symbolText; //$NON-NLS-1$ 
 * Copyright (c) 2016 Cadence Design Systems, Inc. and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at 
 * http://www.eclipse.org/legal/epl-v10.html * 
import org.junit.runners.parameterized.TestWithParameters; 
 assertNotNull(new RefSpec("refs/heads/master:refs/heads/")); 
 * doesn't require matching wildcards. 
 * doesn't require matching wildcards. 
 * doesn't require matching wildcards. 
 * doesn't require matching wildcards. 
 enum WildcardMode { REQUIRE_MATCH, ALLOW_MISMATCH 
 if (isWildcard(s)) { wildcard = true; if (!allowMismatchedWildcards) { throw new IllegalArgumentException(MessageFormat .format(JGitText.get().invalidWildcards, spec)); } } 
 wildcard = true; if (!allowMismatchedWildcards) throw new IllegalArgumentException(MessageFormat .format(JGitText.get().invalidWildcards, spec)); 
 public RefSpec(String spec, wildcardmode mode) { this.allowMismatchedWildcards = mode; 
<|del|> 
 return list.toArray(new @NonNull String[list.size()]); 
 curFullAttribute = entry.getFullAttribute(); curEncodedAttribute = encodeFullAttribute(prevFullAttribute, entry.getFullAttribute()); list.add(curEncodedAttribute); 
 @Nullable private CalledFunction fParent = null; 
 public static final @NonNull String ID = "org.eclipse.tracecompass.internal.analysis.timing.ui.callgraph.callgraphanalysis"; //$NON-NLS-1$ 
 * Copyright (c) 2016 SWTBot Committers and others. 
 * Ericsson - Initial API and implementation 
 * Ericsson - Initial API and implementation 
 /* Check if this value is an update of the ongoing state */ 
 if (isUpdate()) { 
 private static final String BUNDLE_NAME = Messages.class.getPackage().getName() + ".messages"; //$NON-NLS-1$ 
 * @deprecated This analysis was moved to core as * {@link org.eclipse.tracecompass.internal.lttng2.ust.core.callstack.LttngUstCallStackAnalysis} * and is now internal 
<|del|>
<|del|> 
 fComposite = checkNotNull((Composite) super.createDialogArea(parent)); getShell().setText(Messages.ChartMakerDialog_Title); 
 LamiTimeRange expectedTimeRange = new LamiTimeRange(new LamiTimestamp(1000), new LamiTimestamp(2000)); assertEquals(expectedTimeRange, perProcessTable.getTimeRange()); 
class LamiCPU extends LamiData { 
 return (number == null ? null : Long.valueOf(number.longValue())); 
 return (number == null ? null : Double.valueOf(number.doubleValue())); 
class LamiFileDescriptor extends LamiData { 
 * @param lowLimit * Lower limit * @param value * Value * @param highLimit * Higher limit 
 Long startValue = fBegin.getValue(); Long endValue = fEnd.getValue(); 
<|del|> 
<|del|> 
 return number == null ? null : Long.valueOf(number.longValue()); 
 return number == null ? null : Double.valueOf(number.doubleValue()); 
 * {@code true} if this is a user-defined analysis 
 }; // we add a listener on the main object managed by the property view table.eAdapters().add(tableListener); initOtherFieldsAndAddOthersListeners(); } 
 * Test cascade state system. The call stack's structure used in this test * is shown below: * * <pre> * ________ * ______ * ____ * * </pre> 
 * Build a pyramid shaped call stack.This call stack contains three * functions ,Its structure is shown below : * * <pre> * __ * ____ * ______ * </pre> 
 // Create the first function 
 * Test mutliRoots state system.The call stack's structure used in this test * is shown below: * * <pre> * ___ ___ * _ _ * </pre> 
 fixture.pushAttribute(0, statev, quark); 
 CalledFunction segment = new CalledFunction(intervalStart, intervalEnd + 1, stateValue, node.getDepth() + 1); 
<|del|> 
 * Test mutliRoots state system. The call stack's structure used in this * test is shown below: 
 fixture.closeHistory(51); 
<|del|> 
 * Test state system with a Large amount of segments. All segments have the * same length. The call stack's structure used in this test is shown below: 
 fixture.closeHistory(11); 
 private static final @NonNull String CALLSTACK_PATH = "CallStack"; 
 private static final String @NonNull [] CSP = { CALLSTACK_PATH }; private static final String @NonNull [] PP = { PROCESS_PATH }; private static final String @NonNull [] TP = { THREAD_PATH }; 
 * Copyright (c) 2009, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2015, 2016 THALES GLOBAL SERVICES. 
 * @author <a href="mailto:pierre.guilet@obeo.fr">Pierre Guilet</a> 
<|del|> 
 OS.gtk_tree_view_column_cell_get_position (column, pixbufRenderer, x, w); 
 display.rendererGetPreferredWidthCallback.setEnabled(true); } else { OS.gtk_tree_view_column_cell_get_position (column, pixbufRenderer, x, w); 
 OS.gtk_tree_view_column_cell_get_position (column, textRenderer, xText, wText); 
 display.rendererGetPreferredWidthCallback.setEnabled(true); } else { OS.gtk_tree_view_column_cell_get_position (column, textRenderer, xText, wText); 
 void preDestroy() { if (mainMenu != null) { renderer.clearModelToManager(mainMenu, menuManager); mainMenu = null; } 
 ChangeInfo changeInfo = (ChangeInfo) element; //Note: Need to use the id instead of the changeInfo.getChange_id() for cases where //we can have the same changeId on two different branches //See review 78088 
 ChangeInfo changeInfo = (ChangeInfo) element; //Note: Need to use the id instead of the changeInfo.getChange_id() for cases where //we can have the same changeId on two different branches //See review 78088 
 * Bug 498165: gtk_tree_view_column_cell_get_position() sets off rendererGetPreferredWidthCallback in GTK3 which is an issue 
 Callback.setEnabled(false); 
 * Bug 498165: gtk_tree_view_column_cell_get_position() sets off rendererGetPreferredWidthCallback in GTK3 which is an issue 
 Callback.setEnabled(false); 
 //XXX Beware of Class.forName, it may cause surprises in Eclipse environments Class<?> aggregatorDomainClass = Void.class; if (aggregateParameterType != null) { aggregatorDomainClass = Class.forName(aggregateParameterType.getQualifiedName()); } 
 private static CalledFunction create(long start, long end, int depth, long value, @Nullable ICalledFunction parent) { 
 private static CalledStringFunction create(long start, long end, int depth, String value, @Nullable ICalledFunction parent) { 
 @Nullable ICalledFunction getParent(); 
 return new Comparator<ISegment>() { 
 Long longAddress = (Long) symbol; 
 ExceptionHandler<RuntimeException> exceptionHandler = DefaultExceptionHandler.getRuntimeExceptionHandler (); ExceptionHandler<Error> errorHandler = DefaultExceptionHandler.getErrorHandler (); 
 exceptionHandler.accept (exception); } catch (Error error) { errorHandler.accept (error); 
 throw new IllegalArgumentException ("exceptionHandler must not be null"); 
public final ExceptionHandler<RuntimeException> getRuntimeExceptionHandler () { return exceptionHandler; 
public final ExceptionHandler<RuntimeException> getRuntimeExceptionHandler () { return exceptionHandler; 
 exceptionHandler.accept (exception); } catch (Error error) { errorHandler.accept(error); 
<|del|> 
<|del|> 
<|del|> 
<|del|>
 private final TraceDomainType fDomain; 
 public static final String WORKSPACE = "WORKSPACE"; //$NON-NLS-1$ 
 @Override public void registerContextMenu(MenuManager menu, final ISelectionProvider selectionProvider) { super.registerContextMenu(menu, selectionProvider); registerOpenWorkspaceVersion(menu, selectionProvider); 
public final Consumer<RuntimeException> getRuntimeExceptionHandler () { 
<|del|> 
static final Consumer<RuntimeException> RUNTIME_EXCEPTION_HANDLER = exception -> { 
<|del|> 
<|del|> 
 if (runtimeExceptionHandler == null) { throw new IllegalArgumentException ("runtimeExceptionHandler must not be null"); 
 * Returns the current exception handler. It will receive all exceptions thrown by listeners 
 public void setOption(String key, Object value) { 
 * {@link #removeDefaultToolbarButton(String[])}</i> 
 public static final String[] DOCKERHUB_REGISTRY_ALIASES = new String[] { 
 private final @Nullable IConsumerAggregator fXAggregator; private final @Nullable IConsumerAggregator fYAggregator; 
<|del|> 
<|del|> 
 * overrided in order to allow two different objects that represent the same 
 return descriptors.distinct().count(); 
 if (countDistinctDescriptors(getXDescriptors()) > 1) { 
 fCategories = xconsumer.getList().stream().toArray(size -> new String[size]); 
 private static long countDistinctDescriptors(Stream<IDataChartDescriptor<?, ?>> descriptors) { 
 Collection<SearchPlanForBody> compiledPlans = createPlan(dependency, planProvider, searchContext); collectElementsToIndex(compiledPlans, classesToIndex, featuresToIndex, dataTypesToIndex); collectDependencies(compiledPlans, dependencies); 
 public QueryEvaluationHint overrideBy(QueryEvaluationHint overridingHint){ 
 levelNames = findLoglevelNames(TraceJulLogLevel.class); 
 * Copyright (c) 2011, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2011, 2016 THALES GLOBAL SERVICES. 
 fSeries = ImmutableList.copyOf(series); 
 fSeries.forEach(consumer -> consumer.accept(obj)); 
 IConsumerAggregator aggregatorX = fXAggregator; if (aggregatorX != null) { fSeries.forEach(s -> aggregatorX.accept(s.getXConsumer())); 
 return fSeries; 
 private final List<Object> fConsumedElements = new ArrayList<>(); 
 public List<Object> getConsumedElements() { return ImmutableList.copyOf(fConsumedElements); 
 public boolean areNumerical() { 
 public boolean areDuration() { 
 public boolean areTimestamp() { 
 return new SwtScatterChart(parent, data, model); 
 private final BiMap<String, Integer> fMap; private final List<String> fList = new ArrayList<>(); 
 public ScatterStringConsumer(IStringResolver<Object> resolver) { fResolver = resolver; 
 public ScatterStringConsumer(IStringResolver<Object> resolver, BiMap<String, Integer> map) { fResolver = resolver; 
 public BiMap<String, Integer> getMap() { return ImmutableBiMap.copyOf(fMap); 
 return new SwtScatterChart(parent, data, model); 
 public BarStringConsumer(IStringResolver<Object> resolver) { fResolver = resolver; 
 public BarStringConsumer(IStringResolver<Object> resolver) { fResolver = resolver; 
 return ImmutableList.copyOf(fList); 
 private static final String BAR_CHART_ICON = "icons/barchart.png"; //$NON-NLS-1$ 
 static boolean filterSameDescriptor(IDataChartDescriptor<?, ?> desc, @Nullable IDataChartDescriptor<?, ?> filter) { 
 static boolean checkIfNumerical(IDataChartDescriptor<?, ?> desc) { 
 private static final String SCATTER_CHART_ICON = "icons/scatterchart.png"; //$NON-NLS-1$ 
 *******************************************************************************/ 
 public NumericalConsumer(INumericalResolver<Object, Number> resolver) { fResolver = resolver; 
 /* Update the minimum value */ 
 /* Update the maximum value */ 
 return ImmutableList.copyOf(fData); 
 * @param selection 
 return visitor.isIndividualType(DescriptorType.NUMERICAL); 
 sideBand = isCapabilityEnabled(CAPABILITY_SIDE_BAND_64K); 
 * May be called repeatedly, likely in a background process. Can be used to do long-running status analysis that obtains the needed * information. If caching is required, the processor is responsible to do so himself, likely using the context. 
 public static String toPrettyString(IReport report, Map<String, String> processorNames) { 
 private void appendAuxiliaryInformation(EMap<String, String> auxiliaryInformation, StringBuilder builder) { for (Entry<String, String> entry : auxiliaryInformation.entrySet()) { 
 private void appendAuxiliaryInformation(EMap<String, String> auxiliaryInformation, StringBuilder builder) { for (Entry<String, String> entry : auxiliaryInformation.entrySet()) { 
public class CustomProcessorDescriptor extends ProcessorDescriptorImpl { 
 log(new LogMessages(IStatus.ERROR, "Processor \u2018{0}\u2019 failed to load image with exception {1}"), e, getClass(), e.getMessage()); 
 "Eclipse encountered {0,choice,1#an unexpected problem|1<{0,number,integer} unexpected problems}. Such problems may reveal severe issues in the code and thus we kindly ask you to send them to the affected projects. See below which projects request your assistance.", 
<|del|> 
 // special handling for the anonymization processors, they should always be the last elements 
 imageLabel = new Label(composite, SWT.NONE); 
 " {0,choice,1#One project|1<{0,number,integer} projects} requested additional processing for {1,choice,1#one problem|1<{1,number,integer} problems}. <a>Click here to execute all requested actions</a>.", 
 * {@link IEclipseContext} with the key '<i>acceptedPackagesPatterns</i>'. 
 public void advertiseRefs(BaseReceivePack receivePack) 
 public void advertiseRefs(BaseReceivePack receivePack) { 
 public void advertiseRefs(BaseReceivePack receivePack) 
 public void advertiseRefs(BaseReceivePack rp) 
 import org.eclipse.jgit.annotations.Nullable; import org.eclipse.jgit.errors.InvalidObjectIdException; 
 public void execute(final BaseReceivePack rp) { 
public abstract class UiResponseTest extends ViewsResponseTest { 
 protected Command getCommand(final IEvaluationContext context) { 
 final List<EObject> pagesToOpen = new LinkedList<EObject>(); List<EObject> pagesToSelect = new LinkedList<EObject>(); 
 private static String[] findLoglevelNames(Class<? extends ITraceLogLevel> enumType) { ITraceLogLevel[] levels = enumType.getEnumConstants(); if (levels == null) { return new String[0]; } 
 private static String[] findLoglevelNames(Class<? extends ITraceLogLevel> enumType) { ITraceLogLevel[] levels = enumType.getEnumConstants(); if (levels == null) { return new String[0]; } 
 if ((!levels[i].equals(TraceLog4jLogLevel.LEVEL_UNKNOWN)) && (!levels[i].equals(TracePythonLogLevel.LEVEL_UNKNOWN)) && (!levels[i].equals(TraceJulLogLevel.LEVEL_UNKNOWN))) { 
 /** * @since 1.5 */ 
 * Copyright (c) 2016 Obeo and others. 
 fIsAllLoggers = ((totalNbLoggers > 0) && (nbLoggers == totalNbLoggers)) || ((totalNbLoggers == 0) && fLoggersViewer.getCheckedElements().length == 1); 
 if (!fIsAllLoggers && !tmpSpecificLogger.trim().isEmpty()) { 
 private static class TaskTagBuildParticipantParticipant implements IBuildParticipant { 
 /** * Set the GcLog object used to store errors during background processing * @param gcLog * @since 4.7 */ 
 //Verify if a last value was set for this key by the current user and set it as default 
<|del|> 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Morgan E. Cook */ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
<|del|>
 List<IPresentationReconciler> res = new ArrayList<>(); 
 public static LocalSearchHints getDefaultFlatten(){ 
 * @deprecated use {@link #plan(PBody, Logger, Set, IQueryMetaContext, IQueryRuntimeContext, LocalSearchHints)} instead 
 assertEquals(1, completionProposalList.getItemCount()); 
 GenericEditorTestUtils.tearDownAfterClass(); 
 GenericEditorTestUtils.tearDownAfterClass(); 
 GenericEditorTestUtils.tearDownAfterClass(); 
 GenericEditorTestUtils.closeIntro(); 
 GenericEditorTestUtils.tearDownAfterClass(); 
 GenericEditorTestUtils.closeIntro(); 
<|del|> 
<|del|> 
 // supporting compound/aggregated hovers. 
<|del|> 
 task2.setCompletionDate(now); 
 task2.setDueDate(new Date(yesterday.getStartDate().getTimeInMillis())); 
<|del|> 
 assertFalse("The model must contain ProfileApplications references.", model.getProfileApplications().isEmpty()); //$NON-NLS-1$ 
<|del|> 
 assertEquals("Element is not the one expected", CLASS_1_NAME, class1.getName()); //$NON-NLS-1$ 
 assertEquals("Element is not the one expected", CLASS_2_NAME, class2.getName()); //$NON-NLS-1$ 
 assertEquals("Element is not the one expected", CLASS_3_NAME, class3.getName()); //$NON-NLS-1$ 
 assertEquals("Element is not the one expected", CLASS_4_NAME, class4.getName()); //$NON-NLS-1$ 
 assertEquals("The stereotypes applied on the class must be the same as the expected stereotypes.", appliedStereotypes, expectedStereotypes); //$NON-NLS-1$ 
 assertEquals("The stereotypes applied on the class must be the same as the expected stereotypes.", appliedStereotypes, expectedStereotypes); //$NON-NLS-1$ 
 assertEquals("The stereotypes applied on the class must be the same as the expected stereotypes.", appliedStereotypes, expectedStereotypes); //$NON-NLS-1$ 
 assertEquals("The stereotypes applied on the class must be the same as the expected stereotypes.", appliedStereotypes, expectedStereotypes); //$NON-NLS-1$ 
 assertNotNull("The Stereotype must contain an icon.", expectedImage); //$NON-NLS-1$ assertEquals("The icon of the Element must be the same as the expected icon.", expectedImage, image); //$NON-NLS-1$ 
 assertFalse("The String ID of the expected image must not be empty.", expectedImageId.isEmpty()); //$NON-NLS-1$ 
 public IMatcherCapability calculateRequiredCapability(PQuery query, QueryEvaluationHint hint); 
 public IMatcherCapability calculateRequiredCapability(PQuery query){ return queryBackendFactory.calculateRequiredCapability(query, this); 
 */ @Deprecated 
 if (isInLayoutingMode && graphicalEditPartToDrop instanceof IAbstractDiagramNodeEditPart) { 
 return TaskActivityUtil.getCurrentWeek().getToday().next(); case ITasksUiPreferenceConstants.SCHEDULE_NEW_TASKS_FOR_THIS_WEEK: return TaskActivityUtil.getCurrentWeek(); 
 * Copyright (c) 2016 Ericsson 
 * Copyright (c) 2016 Ericsson 
<|del|> 
<|del|> 
<|del|>
 if (isOnNamespace(event, timeGraphControl)) { 
 // Returns false for attributes and relations if artifact was deleted but the attribute or relation was not deleted 
 @Path("render") 
<|del|> 
<|del|> 
 List<ArtifactReadable> arts = Lists.newLinkedList(); 
 arts.addAll( queryFactory.fromBranch(branch).andGuids(guidsFromLinks).includeDeletedArtifacts().getResults().getList()); 
 fTimeProvider.setSelectionRangeNotify(time, time, false); 
 args.add("--tlsverify"); //$NON-NLS-1$ args.add("--tlscacert"); //$NON-NLS-1$ 
<|del|> 
 if (currentSelectedEngine != null && !currentSelectedEngine.containsAll(defaultConf)) { 
 if ("".equals(preferenceValue)) { //$NON-NLS-1$ preferenceValue = MessageDialogWithToggle.PROMPT; 
**************************************************************************** * Copyright (c) 2013, 2016 Obeo and others. 
 * Mathias Schaefer - preferences refactoring 
 * Copyright (c) 2014, 2016 Obeo and others. 
 preferences.clear(); 
 * Copyright (c) 2012, 2016 Obeo and others. 
 * Obeo - initial API and implementation * Mathias Schaefer - preferences refactoring 
 * @since 4.3 
 String enginePreferenceKey, Composite tabComposite, DataHolder<T> dataHolder) { IItemDescriptor<T> defaultEngine = ItemUtil.getDefaultItemDescriptor(registry, enginePreferenceKey); 
 if ("".equals(sync)) { //$NON-NLS-1$ sync = MessageDialogWithToggle.PROMPT; 
 if ("".equals(preferenceValue)) { //$NON-NLS-1$ preferenceValue = MessageDialogWithToggle.PROMPT; 
 /** {@link IEclipsePreferences} holding engines information. */ 
<|del|> 
 * Copyright (c) 2014 Obeo. 
 /** Preferences holding disabled match engines. */ 
 * Copyright (c) 2013, 2016 THALES GLOBAL SERVICES. 
 public static final Version MIGRATION_VERSION = new Version("11.1.0.201608250900"); //$NON-NLS-1$ 
 * Test class to test the DView.ownedRepresentations removal and that the 
 if (e.getMessage().equals(DREPRESENTATION_FOUND)) { 
 "After migration, the resource should not contain a DRepresentation in DView.ownedRepresentations."); 
<|del|> 
 public static final Version MIGRATION_VERSION = new Version("11.1.0.201608251200"); //$NON-NLS-1$ 
 * Copyright (c) 2010, 2016 THALES GLOBAL SERVICES. 
 * Complete the models references of the DAnalysis according to a semantic * object<BR> 
 * @param semanticObject * the semantic object 
 } else if (notifier instanceof DDiagramElement && ((EObject) notifier).eContainer() != null) { 
 public void refreshRepresentation(final DRepresentation diagram) { 
 saveFile(rootElements, path); 
 } 
<|del|>
 * Allow to retrieve the father {@link DAnalysis} from an element contained * in a {@link DRepresentation} or from a {@link DRepresentation} * itself.</br> 
 if (representation != null) { DRepresentationDescriptor representationDescriptor = new DRepresentationQuery(representation).getRepresentationDescriptor(); EObject rootContainer = EcoreUtil.getRootContainer(representationDescriptor, false); if (rootContainer instanceof DAnalysis) { dAnalysis = (DAnalysis) rootContainer; } 
 changeSiriusUIPreference(SiriusUIPreferencesKeys.PREF_REFRESH_ON_REPRESENTATION_OPENING.name(), true); 
 */ @Override 
 * the given page. If following markers do not belong to this view, they * would not be shown. This must be called from the UI thread. 
 if (null != marker && viewId.equals(getViewId(marker))) 
 Option<DRepresentation> representation = getRepresentation(); if (representation.some()) { DRepresentationDescriptor representationDescriptor = new DRepresentationQuery(representation.get()).getRepresentationDescriptor(); 
 Option<DRepresentation> representation = getRepresentation(); if (representation.some()) { DRepresentationDescriptor representationDescriptor = new DRepresentationQuery(representation.get()).getRepresentationDescriptor(); 
 Option<DRepresentation> representation = getRepresentation(); if (representation.some()) { DRepresentationDescriptor representationDescriptor = new DRepresentationQuery(representation.get()).getRepresentationDescriptor(); 
 Option<DRepresentation> representation = getRepresentation(); if (representation.some()) { DRepresentationDescriptor representationDescriptor = new DRepresentationQuery(representation.get()).getRepresentationDescriptor(); 
 final String myName = detachingSymbolicRef ? getRef().getName() : getRef().getLeaf().getName(); 
 // the cached index information for the path. // 
 * Copyright (c) 2012 THALES GLOBAL SERVICES. 
<|del|> 
 private ResourceManager resourceManager = null; 
 public boolean isTraceEnabled(String option) { 
 loadReview(); 
<|del|> 
 * Two references match if and only if they satisfy the following: 
 * <li>If both are object ID refs, the object IDs should be same. * </ul> 
 for (File file : files) { 
 for (File file : files) { 
 */ @Override 
 if (Window.OK == code) { 
 public CustomizableDelegatingItemLabelProvider(final List<Entry<String, Styler>> styleslist) { 
 if (null != umlResult) { 
 if (null == element) { 
 InputStream is = response.getResponseEntityAsStream(); 
 return ((loginToken == null && Strings.isNullOrEmpty(apiKey)) || super.needsAuthentication()); 
 try (BufferedInputStream is = new BufferedInputStream(response.getResponseEntityAsStream())) { InputStreamReader in = new InputStreamReader(is); throwExeptionIfRestError(is, in); return parseFromJson(in); } 
<|del|> 
<|del|> 
<|del|> 
 GridLayoutFactory.fillDefaults().margins(0, 0).numColumns(3).applyTo(apiKeyContainer); 
 Label apiKeyLabel = new Label(apiKeyContainer, SWT.NONE); apiKeyLabel.setText(Messages.BugzillaRestRepositorySettingsPage_use_api_key); 
 TestRepositorySettingsPage page = createPage(repository, true, Status.OK_STATUS); 
 if (checkBox.isEnabled()) { if ((optionFlags & ImportTraceWizardPage.OPTION_IMPORT_UNRECOGNIZED_TRACES) != 0) { checkBox.select(); } else { checkBox.deselect(); } 
<|del|> 
 * Test that the events editor gets activated and that the first event is * selectable. 
 @Override 
 @Override 
 if (receiver instanceof IAdaptable) { final IDockerConnection connection = ((IAdaptable) receiver) .getAdapter(IDockerConnection.class); if (connection != null) { return isConnectionEstablished(connection, property, args, expectedValue); } 
 if (ret == null) { ret = itemDelegator.getImage(match.getOrigin()); } 
<|del|> 
 * 4) Select trace type "Generic CTF Trace", unselect "Overwrite existing without warning", select "Create Links to workspace" and unselect "Preserve Folder Structure"and 
 * 4) Select trace type "LTTng Kernel Trace", unselect "Overwrite existing without warning", select "Create Links to workspace" and unselect "Preserve Folder Structure" 
 * 4) Select trace type "LTTng UST Trace", unselect "Overwrite existing without warning", select "Create Links to workspace" and unselect "Preserve Folder Structure" 
 * 4) Select trace type "Tmf Generic", unselect "Overwrite existing without warning", select "Create Links to workspace" and unselect "Preserve Folder Structure" 
 * @param key - key of key/value config pair. equals sign not accepted 
 public EMFComparePreferences getPreferenceProvider() { 
 if (diffEngineKey != null && !diffEngineKey.isEmpty()) { 
 if (diffEngineKey != null && !diffEngineKey.isEmpty()) { 
 public IEclipsePreferences getEMFComparePreferences() { 
 Display d = Display.getCurrent(); IProgressMonitorWithBlocking wrapper = ProgressMonitorUtil 
 Display d = Display.getCurrent(); IProgressMonitorWithBlocking wrapper = ProgressMonitorUtil 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public void fillDataStructure() { 
 public void fillDataStructure() { 
 public void fillDataStructure() { 
 GerritTableView.getActiveView(true).getSite().registerContextMenu(DASHBOARD_CONTEXT_MENU, menuManager, aViewer); 
 GerritTableView.getActiveView(true).getSite().registerContextMenu(DASHBOARD_CONTEXT_MENU, menuManager, aViewer); 
 String right = selectedRevision.getId(); 
 String right = selectedRevision.getId(); 
 String psSelectedID = revision.getId(); 
 String psSelectedID = revision.getId(); 
 .thenRun(() -> changeInfo.setUserSelectedRevision(selectedRevision));//keep the user working revision active 
 .thenRun(() -> changeInfo.setUserSelectedRevision(selectedRevision));//keep the user working revision active 
 * Builtin filter commands start with this prefix 
 * {@link FilterCommand}s for a certain command name. If the factory f1 is 
 * the factory responsible for creating {@link FilterCommand}s * for the specified name. <code>null</code> can be specified to 
 * Checks whether any {@link FilterCommandFactory} is registered for a 
 * Creates a new {@link FilterCommand} for the given name. A factory must be * registered for the name in advance. 
 * data from/to stdin/stdout these builtin commmands may be used. They are 
 * data from/to stdin/stdout these builtin commmands may be used. They are 
 * @param out * The {@link OutputStream} this command should write to 
 * thrown when the command constructor throws an IOException 
 * thrown when the command constructor throws an IOException 
 private static ConcurrentHashMap<String, FilterCommandFactory> filterCommandRegistry = new ConcurrentHashMap<>(); 
 public static FilterCommandFactory registerFilterCommand(String filterCommandName, FilterCommandFactory factory) { if (factory == null) return filterCommandRegistry.remove(filterCommandName); 
 public static FilterCommandFactory registerFilterCommand(String filterCommandName, FilterCommandFactory factory) { if (factory == null) return filterCommandRegistry.remove(filterCommandName); 
 public static boolean isRegistered(String filterCommandName) { return filterCommandRegistry.containsKey(filterCommandName); 
 public static FilterCommand getFilterCommand(String filterCommandName, Repository db, InputStream in, OutputStream out) throws IOException { FilterCommandFactory cf = filterCommandRegistry.get(filterCommandName); 
 private Set<String> filterCommands; 
 /** * Whether to use JGit's implementations of filters and hooks * * @since 4.5 */ public static final String ATTR_FILTER_USE_BUILTIN = "useJGitBuiltin"; /** 
 /** * Whether to use JGit's implementations of filters and hooks * * @since 4.5 */ public static final String ATTR_FILTER_USE_BUILTIN = "useJGitBuiltin"; /** 
 * writes the original content in a so-called 'media file' at '.git/lfs/objects/ 
 * writes the original content in a so-called 'media file' at '.git/lfs/objects/ 
 * writes the original content in a so-called 'media file' at '.git/lfs/objects/ 
 * The factory is responsible for creating instances of {@link CleanFilter}. * This factory can be registered using 
 * file should be written. That's the content which will be added 
 * Represents an LFS pointer file 
 * @throws IOException * when the temp file could not be created 
 * Thrown when an LFS mediafile is found which doesn't have the expected size 
 * The factory is responsible for creating instances of {@link CleanFilter} 
 private long size; 
 * Thrown when a LFS mediafile is found which doesn't have the expected size 
 public long getSize() { return size; 
 * The factory is responsible for creating instances of {@link SmudgeFilter} 
 * Registers this filter in JGit by calling 
 Repository.registerFilterCommand( 
<|del|> 
 lfs = new Lfs(db.getDirectory().toPath().resolve(Constants.LFS)); 
 * contact any LFS servers in order to get the missing content. 
 * The factory is responsible for creating instances of * {@link SmudgeFilter}. This factory can be registered using 
 out.write(b); } 
 private static final List<String> SYNC_VALUES = ImmutableList.of(ALWAYS, NEVER, PROMPT); 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|> 
 * Copyright (c) 2012, 2016 Original authors and others. 
 * Copyright (c) 2012, 2016 Original authors and others. 
 * {@link #drawLineVerticalBorderRight(GC, int, int, int)} is that the 
 * {@link #drawLineVerticalBorderLeft(GC, int, int, int)} is that the line 
 assertEquals(LineStyleEnum.DOTTED, borderStyle.getLineStyle()); assertEquals(BorderModeEnum.CENTERED, borderStyle.getBorderMode()); 
<|del|> 
 * mode state. 
 * Reset the CPU's status when it's coming out of an interruption. 
 * is a null value, we continue looking down the list. 
 String right = selectedRevision.getId(); 
 String psSelectedID = revision.getId(); 
 .thenRun(() -> changeInfo.setUserSelectedRevision(selectedRevision));//keep the user working revision active 
 modified = modifiedContent(linkType, source, content, matchMap, true, null); 
 * Copyright (c) 2000, 2016 IBM Corporation and others. 
<|del|> 
<|del|> 
/** * Contains static methods for constructing and manipulating progress monitors. * 
public final class ProgressMonitorUtil { 
<|del|> 
 } synchronized (mutex) { while (state[0] != 3) { try { mutex.wait(); } catch (InterruptedException e) { } } } 
<|del|> 
 public void testAccumulatingMonitorInUIThread() throws Exception { Semaphore uiSemaphore = new Semaphore(1); Semaphore backgroundSemaphore = new Semaphore(1); 
 uiSemaphore.release(); 
 uiSemaphore.acquire(); 
 uiSemaphore.acquire(); 
 assertEquals(1, size); String expected = "Task Name " + (numLoops[0] - 1); assertEquals(expected, tasks.get(0)); 
<|del|> 
 // Use the shortest qualified name for the control mode if needed 
 Predicate<Diff> isInConflict = new Predicate<Diff>() { public boolean apply(Diff input) { return input != null && input.getConflict() != null; 
 if (entryList != null) { 
 if (GitTraceLocation.REPOSITORYCHANGESCANNER.isActive()) { 
 "Trying to cancel " + refreshJob.getName() + " job"); //$NON-NLS-1$ //$NON-NLS-2$ } 
 if (GitTraceLocation.REPOSITORYCHANGESCANNER.isActive()) { 
 String nsURI = null; if (ePkg != null) { // examine the ePkg stereotype attribute first nsURI = (String) profile.getValue(ePkg, EPKG_NS_URI); 
 if (nsURI == null || nsURI.isEmpty()) { // still undefined or empty, get URI from UML attribute nsURI = profile.getURI(); 
 if (nsURI == null) { nsURI = ""; //$NON-NLS-1$ 
 // CHECKSTYLE:OFF JUnit createTest() method throws an Exception 
 /** The EGit preferences. */ 
 /** The default merge strategy to use is none is provided by user. */ 
 * EMFCompare configuration for this test 
 * Test if the given type is some kind of Collection. 
 * EMFCompare configuration for this test 
 * EMFCompare configuration for this test 
 * EMFCompare configuration for this test 
 * EMFCompare configuration for this test 
 * Constructor for the test where the user only wants to do a setup of the test (unzip archive, load 
 * EMFCompare configuration for this test 
 /** The default merge strategy to use if none is provided by user. */ 
 InputStream is = response.getResponseEntityAsStream(); 
<|del|> 
<|del|> 
 protected void createAdditionalControls(Composite parent) { FormToolkit toolkit = new FormToolkit(TasksUiPlugin.getDefault().getFormColors(parent.getDisplay())); 
 apiKey.setText(Strings.nullToEmpty(apiKeyValue)); 
 ui.loadArtifactRepository(destination, false, subMonitor.split(1)); 
 ui.loadArtifactRepository(destination, false, subMonitor.split(1)); 
 toInstall.add(createInstallableUnitPatch(existingIU, newVersion, profile, subMonitor.split(1))); 
 boolean reActivateWorkspaceRevision = true; 
 boolean reActivateWorkspaceRevision = true; 
 reActivateWorkspaceRevision = branchUiSelection(localRepo, potentialBranches); 
 reActivateWorkspaceRevision = branchUiSelection(localRepo, potentialBranches); 
 boolean notNull = (text != null || arrow != null || list != null || popup != null); if (notNull && (text.isFocusControl () || arrow.isFocusControl () || list.isFocusControl () || popup.isFocusControl ())) { 
 * Copyright (c) 2007, 2016 THALES GLOBAL SERVICES. 
<|del|> 
 * @since 4.6 
 * @since 4.6 
 * @since 4.6 
 /** * Whether to use JGit's implementations of filters and hooks * * @since 4.6 */ public static final String ATTR_FILTER_USE_BUILTIN = "useJGitBuiltin"; /** 
 * @since 4.6 
 * @since 4.6 
 * @since 4.6 
 * * @since 4.6 
 * @since 4.6 
 public void testInvalidPasswordValidate() throws BugzillaRestException { 
 if (location.getBooleanPropery(IBugzillaRestConstants.REPOSITORY_USE_API_KEY)) { 
 if (location.getBooleanPropery(IBugzillaRestConstants.REPOSITORY_USE_API_KEY)) { 
 if (statusCode != expected && statusCode != HttpStatus.SC_BAD_REQUEST) { 
 if (location.getBooleanPropery(IBugzillaRestConstants.REPOSITORY_USE_API_KEY)) { 
<|del|> 
 setErrorMessage(MessageFormat.format(getErrorMessage(), newValue.toString())); 
 setErrorMessage(MessageFormat.format(getErrorMessage(), value)); 
 /** * lfs folder * * @since 4.6 */ public static final String LFS = "lfs"; /** 
<|del|> 
 if (!Strings.isNullOrEmpty(apikeyPreferenceLink.getText())) { BrowserUtil.openUrl(apikeyPreferenceLink.getText(), IWorkbenchBrowserSupport.AS_EXTERNAL); 
 apiKey.setEnabled(!Strings.isNullOrEmpty(apiKeyValue)); 
 apiKey.setEnabled(!Strings.isNullOrEmpty(apiKeyValue)); 
<|del|> 
 @Override 
 @Override 
 MenusTestSuite.class 
 * Copyright (c) 2016 msg systems ag and others. 
 * msg systems ag - initial API and implementation 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 synchScheduleTime.setText(getMinutesString(ITasksUiPreferenceConstants.REPOSITORY_SYNCH_SCHEDULE_MILISECONDS)); 
 synchScheduleTimeRele .setText(getMinutesString(ITasksUiPreferenceConstants.RELEVANT_TASKS_SCHEDULE_MILISECONDS)); 
 assertTrue(client.validate(new NullOperationMonitor())); 
<|del|> 
 @Test @ConditionalIgnoreRule.ConditionalIgnore(condition = MustRunOnApikeyRule.class) 
<|del|> 
 validateResponse.getToken()); 
 String urlSuffix = getUrlSuffix(); if (urlSuffix.length() > 0 && authenticationRequired) { if (!urlSuffix.endsWith("?")) { //$NON-NLS-1$ urlSuffix += "&"; //$NON-NLS-1$ } 
 return baseUrl() + urlSuffix; 
 private final String userprefs = "/userprefs.cgi?tab=apikey"; //$NON-NLS-1$ 
 apikeyPreferenceLink = toolkit.createHyperlink(apiKeyContainer, "", SWT.NONE); //$NON-NLS-1$ 
 String url = serverUrlCombo.getText() + userprefs; 
 EMFStoreClientUtil.logProjectDetails(LOGGING_PREFIX, "Update not required", getProjectSpace(), //$NON-NLS-1$ 
 message != null ? message : "", //$NON-NLS-1$ 
 MessageFormat.format("Checksum computaion during version create: {0}", computedChecksum), //$NON-NLS-1$ 
 && mapping.getRepository() != repository) { 
<|del|> 
 } else if (eObject instanceof Feature || eObject instanceof Classifier) { 
<|del|> 
 if (serverType != null){ 
 MessageFormat.format("Checksum computation during version create: {0}", computedChecksum), //$NON-NLS-1$ 
<|del|> 
 return CharOperation.equals(this.name, mod.name()); 
 new InputStreamReader(contents, Charset.forName("UTF-8"))); 
 public void removeFiles() { 
 protected ITypeLookup typeLookupForModule(char[] modName) { return (typeName, qualifiedPackageName, qualifiedBinaryFileName, asBinaryOnly) -> { return typeLookup().findClass(typeName, qualifiedPackageName, qualifiedBinaryFileName, asBinaryOnly, modName); }; } 
<|del|> 
 if (!droppedProtocols.isEmpty()) { 
 private boolean canDrop(List<Collaboration> droppedObjects) { 
 if (!droppedProtocols.isEmpty()) { 
 private boolean canDrop(List<Collaboration> droppedObjects) { return !droppedObjects.stream().anyMatch(SystemElementsUtils::isBaseProtocol); 
 return new FilteredDropEditPolicy(delegate, baseFilter.or(invalidPortOnPart).or(invalidTypeOnCapsule).or(invalidPortOnCapsule)); 
 boolean isDone = false; while (!isDone) { 
 if (cherryPickCmdResult instanceof String) { 
 // Skip further iterating. root delta has at least one interesting 
 && (delta.getKind() == IResourceDelta.REMOVED)) { 
 private Button addCheckBox(Composite parent, String label, IPreferenceStore preferenceStore, String key) { if (preferenceStore == null) { preferenceStore = getPreferenceStore(); 
 IPreferenceStore buttonPreferenceStore = (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); button.setSelection(buttonPreferenceStore.getDefaultBoolean(key)); 
 IPreferenceStore buttonPreferenceStore = (IPreferenceStore) button.getData(PREFERENCE_STORE_KEY); buttonPreferenceStore.setValue(key, button.getSelection()); 
<|del|>
 IgnoreConditionCreator(Class<?> testClass, ConditionalIgnore annotation) { this.testClass = testClass; 
<|del|> 
 if (klass == ConditionalIgnoreRule.class) { 
<|del|> 
 if (annotation.annotationType() == RunOnlyWhenProperty.class) { 
 /* If node extensions were used, they would be printed here. */ 
<|del|> 
public final class CoreNode extends ParentNode { 
<|del|> 
 public HTNode createCoreNode(HTConfig config, int seqNumber, int parentSeqNumber, long start) { 
 // FIXME Change to abstract for 3.0 
 default void removeFiles() {} 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 spinner.addSelectionListener(widgetSelectedAdapter(e -> { 
<|del|> 
<|del|> 
 tree.addSelectionListener(widgetSelectedAdapter(e -> { 
<|del|> 
 table.addSelectionListener(widgetSelectedAdapter(e -> { 
<|del|> 
 for (int i = 0; i < 4; i++) { 
 private static final int GET_WORKSPACE_TIMEOUT_BEFORE_WARNING_MILLIS = 20000; 
 protected Command createActionCommand(final EditingDomain editingDomain, final Collection<?> selection) { 
 return Messages.ImportingDefaultPropertiesViewDescriptionCommand_text; 
 private boolean isTaskNewAndUnsaved() { return task != null && Boolean.valueOf(task.getAttribute(ITasksCoreConstants.PROPERTY_NEW_UNSAVED_TASK)); 
 try { return Long.parseLong(offset); } catch (NumberFormatException e) { return null; } }; 
 IStructuredSelection selection = list.getStructuredSelection(); 
 description = WorkbenchMessages.SelectPerspective_noDesc; } 
 Composite partComposite = localContext.getLocal(Composite.class); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 throw Throwables.propagate(re); 
 StatusHandler.log(new Status(IStatus.ERROR, "org.eclipse.mylyn.commons.sdk.util", //$NON-NLS-1$ 
 if (testRule instanceof ConditionalIgnoreRule) { 
 if (statement instanceof IgnoreStatement) { 
 } catch (Exception re) { 
 assertThat("Their is at least one System Protocol in the cpp library", !(language.getSystemProtocols(editor.getModel().eResource().getResourceSet()).isEmpty())); 
 List<RelationRow> relations = getRelationsFromArtifactAndTransaction(art, revertTransaction); if (!relations.isEmpty()) { throw new UnsupportedOperationException( "Revert of Relations Modified is not supported (but could be added as needed)"); } 
 weekStartCombo.add(CommonMessages.Sunday); weekStartCombo.add(CommonMessages.Monday); weekStartCombo.add(CommonMessages.Tuesday); weekStartCombo.add(CommonMessages.Wednesday); weekStartCombo.add(CommonMessages.Thursday); weekStartCombo.add(CommonMessages.Friday); weekStartCombo.add(CommonMessages.Saturday); 
 // Skip further iterating. Root delta has at least one interesting 
 // No interesting changes found. Continue iterating over delta 
 private boolean hasUuidPairAlreadyBeenEvaluated(Long uuidA, Long uuidB) { 
 // Add trailing / so that the entry knows it's a folder 
 // Extract archives in selected files (if any) to temporary folder 
 copyItem.addSelectionListener(widgetSelectedAdapter(e -> { 
 pasteItem.addSelectionListener(widgetSelectedAdapter(e -> { 
 coolItem.addSelectionListener(widgetSelectedAdapter(event -> { 
 tree.addSelectionListener(widgetSelectedAdapter(e -> { 
 table.addSelectionListener(widgetSelectedAdapter(e -> { 
 for (int i = 0; i < 4; i++) { 
 stringFieldLayoutData.widthHint = DEFAULT_GDB_COMMAND_LABEL_WIDTH_HINT; 
 toRefresh.add(resource.getProject()); 
 ImageDescriptor res = super.decorateImage(input, element); if (res == null) { return null; } 
 res = new DecorationOverlayIcon(res, overlay, IDecoration.BOTTOM_LEFT); 
 if (id.endsWith(ID_SUFFIX)) { 
 private static final String MATERIALIZED_MODELELEMENTID_GENERATOR_EXTENSIONPOINT = "org.eclipse.emf.emfstore.common.model.materializedModelElementIdGenerator"; //$NON-NLS-1$ 
 private Queue<JobTreeElement> children = new ConcurrentLinkedQueue<>(); 
 throttledRefresh.throttledExec(); 
 refreshGroups.throttledExec(); 
 private void doRefreshGroup(GroupInfo info) { for (IJobProgressManagerListener listener : listeners) { listener.refreshGroup(info); } 
 private void update() { 
 Display display = PlatformUI.getWorkbench().getDisplay(); display.asyncExec(() -> { 
 // because of bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=505732 
 /** * Close the tar file input stream. * * @throws IOException if the file cannot be successfully closed */ public void close() throws IOException { if (entryEnumerationStream != null) { 
 public ChangeDetail revert(String reviewId, int patchSetId, final String message, IProgressMonitor monitor) 
 @Test public void testAddTwoReviewersAndRemoveOne() throws Exception { 
 @Test public void testAddTwoReviewersAndRemoveOne() throws Exception { 
 // The size of the base image (that's also the size of this composite image) private Supplier<Point> size; 
 // The size of the base image (that's also the size of this composite image) private Supplier<Point> size; 
 this.referenceImageOrDescriptor = baseImage; 
 this.referenceImageOrDescriptor = baseImage; 
 return size.get(); 
 toRefresh.add(resource.getProject()); return; 
 ImageDescriptor descriptor = super.decorateImage(input, element); if (descriptor == null) { 
 if (eGeneric.eContainer() != null && eGeneric.eContainer() != collection 
 && collection.contains(eGeneric.eContainer())) { // generate artificial ID based on the container of the EGenericType 
 if (materializedElementIdGenerator != null) { isModelElementMaterialized = materializedElementIdGenerator.skip(getModelElementId().getId(), collection); } // if the element already has been materialized, we don't want to add it if (!isModelElementMaterialized) { 
<|del|> 
<|del|> 
<|del|> 
 // does the part already have a composite in its contexts? 
<|del|> 
 thrown.expect(BugzillaRestException.class); thrown.expectMessage("Unauthorized"); client.validate(new NullOperationMonitor()); 
<|del|> 
 return !Boolean.parseBoolean(fixture.getProperty(IBugzillaRestConstants.API_KEY_ENABLED_PROPERTY)); 
public class RepositoryKeyTest { 
 if (Boolean.parseBoolean(getProperty(IBugzillaRestConstants.API_KEY_ENABLED_PROPERTY))) { 
 BrowserUtil.openUrl(apikeyPreferenceLink.getText(), IWorkbenchBrowserSupport.AS_EXTERNAL); 
 apiKey.setEnabled(useApiKeyValue); 
 GerritException e = new GerritException("Unknown host: " + cause.getMessage()); //$NON-NLS-1$ 
 public void testAddTwoReviewersAndRemoveOne() throws Exception { List<String> reviewers = Arrays.asList(new String[] { "admin", "tests" }); List<Integer> userid = Arrays.asList(new Integer[] { 1000000, 1000001 }); //user id for tests 
<|del|> 
 * @return the estimated number of threads concurrently accessing the cache. 
 assertEquals("There should be only one group node under resource node", 1, treeItem.length); 
 assertEquals("The level 3 node should be expanded with 4 sub items", 4, viewpointItem2.getItems().length); 
 /** * Lock object for synchronizing updates of {@code pendingJobUpdates} and * {@code pendingGroupUpdates} */ private final Object pendingUpdatesMutex = new Object(); 
<|del|> 
 fCommandFactory.createMIEnvironmentCD(fCommandControl.getContext(), dir.toString()), 
 trace("Indexer: processed " + path.toOSString() + " [" + time + " ms]"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ 
 Display display = getWorkbenchConfigurer().getWorkbench().getDisplay(); IWorkspace workspace = IDEWorkbenchPlugin.getPluginWorkspace(); 
 // WARNING: this condition makes code that // relies on synchronous disconnect very hard to discover and test if (!display.isDisposed() && workspace != null && isWorkspaceLocked(workspace)) { display.asyncExec(disconnectFromWorkspace); } 
 @Test public void testShutdownWithLockedWorkspace() { 
 + ", returned by the AdapterManager for " + sourceObject.getClass().getName() //$NON-NLS-1$ 
<|del|> 
<|del|> 
 * @param overlayImageDescriptor * the overlay image descriptor 
 public DecorationOverlayIcon(ImageDescriptor baseImageDescriptor, ImageDescriptor overlayImageDescriptor, int quadrant) { 
<|del|> 
<|del|> 
 private void processDelta(IResourceDelta delta, Collection<Runnable> addAndRemoveRunnables, 
 // Mute error to prevent pop-up in case of concurrent modification // of markers. 
 private void checkBorderNodesSides(boolean expectConditionalStyle) { 
 if (expectConditionalStyle) { assertTrue("The tested node should be under a conditional style node. But it is not.", node.getOwnedStyle().getDescription().eContainer() instanceof ConditionalNodeStyleDescription); 
 } assertEquals("The tested node should be under a conditional style node. But is is not.", expectConditionalStyle, node.getOwnedStyle().getDescription().eContainer() instanceof ConditionalNodeStyleDescription); 
 TaskAttributeMapper mapper = taskData.getAttributeMapper(); 
 StatusHandler.log( new Status(IStatus.ERROR, BugzillaRestCore.ID_PLUGIN, "Eerror in updateNewAttachmentAttribute", e)); //$NON-NLS-1$ 
 project = resource.getProject(); 
 List<Double> xSeries = new ArrayList<>(dataSize); List<Double> ySeries = new ArrayList<>(dataSize); 
 while(modelIter.hasNext()) { ISegment segment = modelIter.next(); 
 private final String path; private final String name; private final boolean isFolder; 
 Activator.log(e); 
 private final IDockerConnection connection; private final String containerId; 
 return null; // we do not have the contents of container file 
<|del|> 
 private final ITreeContentProvider dynamicProvider; 
 if (useDynamic) { 
 private final FileSystemElement rootParent; 
 FileSystemElement element = (parent == null ? this.rootParent : parent); return super.createElement(element, fileSystemObject); 
 if (isContainer && depth > 0) { List children = provider.getChildren(fileSystemObject); if (children != null) { 
 if (isContainer && depth > 0) { List children = provider.getChildren(fileSystemObject); if (children != null) { 
<|del|> 
<|del|> 
 } catch (TarException | IOException e) { Activator.log(e); 
 ArrayList<ContainerFileProxy> copyList = new ArrayList<>(); 
 .mapToLong(Long::valueOf)); 
 synchronizeTraces(); 
 if (!fProgressIndicator.isDisposed()) { if (totalWork == IProgressMonitor.UNKNOWN || totalWork == 0) { fProgressIndicator.beginAnimatedTask(); } else { fProgressIndicator.beginTask(totalWork); } 
 assertEquals(errorMessage(2, 5), 6, groupItem.getItems().length); 
 assertEquals(errorMessage(3, 7), 7, viewpointItem.getItems().length); 
 assertEquals(errorMessage(4, 2), 2, expandedEntitiesDiagramItem2.getItems().length); 
 * Copyright (c) 2010, 2016 THALES GLOBAL SERVICES. 
 .collect(Collectors.toList()); 
 .collect(Collectors.toList()); 
 public void testSortedIterator() { 
 public Iterable<E> getIntersectingElements(long start, long end) { 
 } 
 List<E> list = Lists.newArrayList(getIntersectingElements(start, end)); 
 // Wait for any outstanding jobs to finish. Protect against deadlock by // terminating the wait after a timeout. waitForJobs(0, TimeUnit.MINUTES.toMillis(3)); 
 public IBreakpoint[] getTriggerPoints(); 
 public void removeTriggerPoint(IBreakpoint breakpoint) throws CoreException; 
 public boolean hasActiveTriggerPoints(); 
 public static final String TRIGGERPOINT = "org.eclipse.debug.core.triggerpoint"; //$NON-NLS-1$ 
 * Returns whether this breakpoint is defined as a trigger point in the 
<|del|> 
 * workspace. If it is a trigger point, then the * {@link org.eclipse.debug.core.model.ITriggerPoint} attribute on this * breakpoint's marker is set to <code>true</code>. 
 fTerminalConnector = new GdbTerminalConnector(process); 
 private final Process fProcess; private final Job fOutputStreamJob; private final Job fErrorStreamJob; 
 fOutputStreamJob = new OutputReadJob(process.getInputStream()); fOutputStreamJob.schedule(); fErrorStreamJob = new OutputReadJob(process.getErrorStream()); fErrorStreamJob.schedule(); 
 public IGdbTerminalControlConnector getTerminalControlConnector() { 
 private final IGdbTerminalControlConnector fGdbTerminalControlConnector; 
<|del|> 
<|del|> 
 PlatformUI.getWorkbench().getDisplay().asyncExec(r); 
 fTerminalConnector = new GdbTerminalConnector(process); 
 private final Process fProcess; private final Job fOutputStreamJob; private final Job fErrorStreamJob; 
 public IGdbTerminalControlConnector getTerminalControlConnector() { 
 private final IGdbTerminalControlConnector fGdbTerminalControlConnector; 
 * @param threshold * the new threshold * @since 4.6 
 * @since 4.6 
 assertTrue(in instanceof ObjectStream.SmallStream); 
 assertTrue(in instanceof ObjectStream.Filter); 
 Iterable<Diff> cascadingDifferences = concat(transform(selectedDifferences, org.eclipse.emf.compare.utils.DiffUtil.getSubDiffs(leftToRight))); 
 int radioOrCheckTextPadding = DPIUtil.autoScaleUp(16); 
<|del|> 
 shouldBeInCollection = (t >= child.getNodeStart() && t <= child.getNodeEnd()); 
 /** * A set of issue codes to ignore in this validator. 
 File file = new File(projectPath + "/pom.xml"); FileWriter pomFileWriter = new FileWriter(file); new MavenXpp3Writer().write(pomFileWriter, pomFileModel); pomFileWriter.close(); 
 void addEntryPoint(Plugin pluginJar) { 
 configDom.addChild(archiveDom); pluginJar.setConfiguration(configDom); 
 dialog.open(); 
 if ((project == null) || !project.exists()) { 
 Constants.HEAD, previous.getName(), 
 if (workspace != null) { if (!display.isDisposed() && isWorkspaceLocked(workspace)) { display.asyncExec(disconnectFromWorkspace); } else { disconnectFromWorkspace.run(); } 
 eventConsole.append("Double-clicked on Canvas: button=" + e.button + " x=" + e.x + " y=" + e.y + Text.DELIMITER); 
 @Test public void doubleClick() throws Exception { final SWTBotCanvas canvas = bot.canvasInGroup("Canvas"); canvas.doubleClick(); assertThat(listeners.getText(), containsString("Double-clicked on Canvas: button=1 ")); } @Test 
 /** * Double-clicks on this widget. * 
<|del|> 
 notify(SWT.MouseDown, createMouseEvent(x, y, 1, SWT.NONE, 2)); notify(SWT.MouseDoubleClick, createMouseEvent(x, y, 1, SWT.NONE, 2)); 
 notify(SWT.MouseDown, createMouseEvent(x, y, 1, SWT.NONE, 2)); notify(SWT.MouseDoubleClick, createMouseEvent(x, y, 1, SWT.NONE, 2)); 
 * 
 default void viewDataChanged(Iterable<? extends ISegment> newData) { 
 Comparator<ISegment> comparator = fComparator; Predicate<E> predicate = fPredicate; 
 * @return Collection of sequence numbers of the child nodes that intersect * t, non-null empty collection if this is a Leaf Node 
 if (currentNode.getNodeType() == HTNode.NodeType.CORE) { /* Here we add the relevant children nodes for BFS */ queue.addAll(((ParentNode) currentNode).selectNextChildren(t)); } 
 int potentialNextSeqNb = -1; 
 log.log(new Status(IStatus.ERROR, PLUGIN_ID, e.getMessage(), e)); 
 final HashMap<Class<? extends Rule>, Rule> rules = new HashMap<Class<? extends Rule>, Rule>(); 
 shell.setText(Messages.ManageAdditionalViewsDialog_Title); 
 label.setText(Messages.ManageAdditionalViewsDialog_LoadedView); 
 removeView.setText(Messages.ManageAdditionalViewsDialog_RemoveView); 
<|del|> 
 manageAdditionalViews.setText(Messages.PreviewView_AdditionalViews); 
 * @returns whether the inferior has been started, which means 
 String newUrl = StringUtils.replaceOnce(repo.getUrl(), urlToReplace, toMirror.getUrl()); mirror.setUrl(newUrl); mirror.setId(toMirror.getId()); 
 String newUrl = StringUtils.replaceOnce(repo.getUrl(), urlToReplace, toMirror.getUrl()); mirror.setUrl(newUrl); mirror.setId(toMirror.getId()); 
 protected @NonNull ISegment createSegment(long start, long end) { 
 * Create a segment 
 /* List containing all the objects contained in this node */ private final List<E> fObjects; 
 CORE((byte) 1), 
 public static NodeType fromByte(byte rep) { 
 return fByte; 
 return fuzz; 
 NLS.initializeMessages(CommandsMessages.class.getName(), CommandsMessages.class); 
 NLS.initializeMessages(CommandsMessages.class.getName(), CommandsMessages.class); 
 private final Job rebuildJob = Job.create(CommandsMessages.RebuildIndexHandler_jobName, monitor -> { 
 }); 
<|del|> 
 if (value != null) { return value.toString(); 
 private static String getUrl(Class<? extends ImageDescriptor> idc, ImageDescriptor imageDescriptor) { 
 if (url == null) { return null; } try { if (InternalPolicy.OSGI_AVAILABLE) { URL platformURL = FileLocator.find(url); if (platformURL != null) { url = platformURL; 
<|del|> 
 protected AbstractSegmentStoreTableView openTable() { 
 // FIXME: The first one should be leftpad, but because of preceding // sorts, it first sort descending in this case bot.waitUntil(ConditionHelpers.isTableCellFilled(tableBot, "rightpad", 0, 3)); 
 bot.waitUntil(ConditionHelpers.isTableCellFilled(tableBot, "98", 0, 2)); // Test that duration still works after having tested System Call 
 private Performance fPerf; 
 public void test5RandomInsertIterTwice() { 
 fuzz[i] = rng.nextInt(DEFAULT_SAMPLE); 
 populate(size, fuzz, fSegStore, getSegmentStoreSize() / 2 + 1, getSegmentStoreSize()); 
 private static void sortedIterate(ISegmentStore<@NonNull ISegment> store, Comparator<ISegment> order) { 
 private static Collection<Rule> getRules(VElement renderable) { final Map<Class<? extends Rule>, Rule> rules = new HashMap<Class<? extends Rule>, Rule>(); 
 return rules.values(); 
 protected void execInitClipboardForm(ClipboardForm form) { 
 protected void execInitClipboardForm(ClipboardForm form) { 
 protected WizardCheckboxTreePart treePart; 
<|del|> 
 if ((blockSize & (blockSize - 1)) != 0) { throw new IllegalArgumentException(JGitText.get().blockSizeNotPowerOf2); } 
 if (isModificationPreferredSize) { 
 String imagePath = NotationUtils.getStringValue(v, IMAGE_PATH_PROPERTY, null); return (svgFile != null || imagePath != null); 
 * Get the spacing between the Controls added by the {@link CTabFolder#addTabControl} methods. 
public void setSpacing(int spacing) { if(spacing < 0 || spacing > 3) SWT.error(SWT.ERROR_INVALID_ARGUMENT); 
 partActivated(part); // let the console know it's being activated fActiveConsole.consoleSelected(); 
<|del|> 
 * *chunks* that will go in the queue. The value must be larger * or equal to 0. 
 shell.forceActive(); shell.setFocus(); 
 pending = copier.submit(task); 
<|del|> 
 Object bar = composite.getData(AbstractPartRenderer.OWNING_ME); if (bar instanceof MTrimBar) { ((MTrimBar) bar).getChildren().forEach(this::hideManagedTB); 
 return this.logEntry.hashCode(); 
 // there is no thread for that inferior and therefore no =thread-selected event 
 /** @since 5.0 */ public ICommand<MIInfo> createCLIPasscount(IBreakpointsTargetDMContext ctx, String breakpoint, int passcount) { 
 public CLIInferior(ICommandControlDMContext ctx, String inferiorId) { super(ctx, INFERIOR + inferiorId); 
<|del|> 
 * * Databinding is set to SWT.Modify, because we cannot guarantee that the focus of the text field is lost after the * popup windows is closed. * 
 private static final String UNCONFIGURED = "Unnamed repository; edit this file to name it for gitweb."; 
 private static final String UNCONFIGURED = "Unnamed repository; edit this file to name it for gitweb."; 
 write("\n"); //$NON-NLS-1$ 
 assertOpenBlock(); try { currentBlock.write(text); currentBlock.write('('); currentBlock.write(definition); currentBlock.write(')'); } catch (IOException e) { throw new RuntimeException(e); } 
 * graph. It gets the traceability links and forms a graph with the connected * elements as nodes and the traceability links as edges 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 link = FileUtils.relativizeGitPath( 
 characters(text); characters("("); //$NON-NLS-1$ characters(definition); characters(")"); //$NON-NLS-1$ 
 boolean isReadOnly = getTaskAttribute().getMetaData().isReadOnly(); boolean textIsEmpty = getText().getText().isEmpty(); 
<|del|> 
 private final DisposeListener disposeDecorationListener = new DisposeListener() { 
 private final DisposeListener disposeDecorationListener = new DisposeListener() { 
 protected DisposeListener getDisposeDecorationListener() { return disposeDecorationListener; } 
 * An adornment provider is used to define the adornments the pattern matcher should prepare for. * A default implementation is available in {@link AllValidAdornments} that describes all * adornments fulfilling the parameter direction declarations. 
 public Iterable<Set<PParameter>> getAdornments(PQuery query); 
<|del|> 
 private final BiMap<String, Integer> fMap; /** The list of value for each object consumed */ 
 /* can't convert to fraction, use floating-point arithmetic */ fPeriodFraction = null; 
 break; default : direction = SWT.NONE; 
<|del|> 
 * Christian W. Damus (CEA) - bug 392301 * Fanch BONNABESSE (ALL4TEC) fanch.bonnabesse@all4tec.net - Bug 479314 
 * Christian W. Damus (CEA) - bug 392301 * Fanch BONNABESSE (ALL4TEC) fanch.bonnabesse@all4tec.net - Bug 479314 
 * Camille Letavernier (CEA LIST) camille.letavernier@cea.fr - Initial API and implementation * Fanch BONNABESSE (ALL4TEC) fanch.bonnabesse@all4tec.net - Bug 479314 * 
 throw new SAXException(RepoText.get().invalidManifest); } 
 * Defines if an {@link EStructuralFeature} should not be indexed by VIATRA Base. This filtering * method should only be used if the input metamodel has certain features, that the base indexer * cannot handle. 
 fCUnit.becomeWorkingCopy(subMonitor.split(1)); 
 remainingMonitor= subMonitor.split(8); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 SubMonitor subMonitor= SubMonitor.convert(monitor, NewWizardMessages.ClasspathModifier_Monitor_ResetFilters, 1); 
 entry.setAttribute(CPListElement.INCLUSION, new IPath[0]); entry.setAttribute(CPListElement.EXCLUSION, exclusions); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 for (int i= 0; i < types.length; i++) { String currName= types[i].getTypeQualifiedName('.'); 
 for (int j= 0; j < packageFragments.length; j++) addAllCus(collector, packageFragments[j]); 
 public BorderedScalableImageFigure(RenderedImage renderedImage, boolean useDefaultImageSize, boolean useOriginalColors, boolean antiAlias) { this(renderedImage, useDefaultImageSize, useOriginalColors, antiAlias, true); } 
 if((feature instanceof EReference && ((EReference)feature).isContainer())) { // container features are always represented through their opposite return true; } //If the feature is filtered by the feature filter specified in the BaseIndexOptions, return true 
 * Copyright (c) 2016 Red Hat inc. All rights reserved. 
 * - Bug 504483 
 * - Bug 504483 
<|del|> 
 if (value1 instanceof Comparable && value2 instanceof Comparable) { 
 } else if (value1 != null) { 
<|del|> 
 final ArrayList<List<ISearchOperation>> operations; 
 if (lightweightAutoRefreshEnabled) workspace.getRefreshManager().refresh(target); 
 int l = Integer.parseInt(contentLength.getValue()); return l < 0 ? -1 : l; 
 int l = Integer.parseInt(contentLength.getValue()); return l < 0 ? -1 : l; 
 } try { 
 subMonitor.newChild(1)); 
 fCUnit.makeConsistent(subMonitor.newChild(1)); 
 public NatTableDragSourceListener(final INattableModelManager tableManager, final NatTable nattable, final List<String> gridRegions) { 
 * Vincent Lorenzo (CEA LIST) vincent.lorenzo@cea.fr - Initial API and implementation * Mickael ADAM (ALL4TEC) mickael.adam@all4tec.net - Bug 502560: add drag to diagram support 
 * a visible position in the NatTable with an underlying viewport * @param scrollableRow * the row in the viewport's underlying scrollable layer 
 * Get the format data with the best corresponding to the key. 
 * Error message used when this format data manager is called by the * obsolete method * org.eclipse.sirius.diagram.ui.tools.internal.format.semantic. 
 private static final String ERROR_MESSAGE_UNSUPPORTED_METHOD_CALL = "The default SiriusFormatDataManager does not use this method anymore"; //$NON-NLS-1$ 
 throw new UnsupportedOperationException(ERROR_MESSAGE_UNSUPPORTED_METHOD_CALL); 
 clearFormatData(); throw new IllegalStateException(ERROR_MESSAGE_UNSUPPORTED_FORMAT_DATA_TYPE + formatData.getClass().getSimpleName()); 
 clearFormatData(); throw new IllegalStateException(ERROR_MESSAGE_UNSUPPORTED_FORMAT_DATA_TYPE + formatData.getClass().getSimpleName()); 
 throw new UnsupportedOperationException(ERROR_MESSAGE_UNSUPPORTED_METHOD_CALL); 
 * the {@link SWTBotTimeGraph} 
 * Enable the drag behavior regions from the natTable to an other widget/editor (diagram, table, ...) which can accept it. 
 for (long i = low; i < high; i++) { long start = i + fuzz[(int) (i % size)]; 
 for (long i = low; i < high; i++) { long start = i + fuzz[(int) (i % size)]; 
 return NLS.bind(Messages.BuildsView_BuildStatusSummary, 
 @Override 
 public static final String CAPRA_OFFICE_OBJECT = "org.eclipse.capra.ui.office.utils.capraOfficeObject"; 
 * Interface that third party {@link ModelProvider}s can adapt to indicate that * they don't want to participate in EGit synchronizations. 
 if (includeLocal) { 
 } else if (element instanceof IFile) { // This file is not in a ModelingProject (check in // <possibleChildren> and <triggerPoints> of // "org.eclipse.ui.navigator.navigatorContent" of plugin.xml) 
 "Bearer realm=\"(?<realm>.+)\",service=\"(?<service>.+)\",scope=\"(?<scope>.+)\""); //$NON-NLS-1$ 
 public static final String UNKNOWN_LAYER = "Unknown"; //$NON-NLS-1$ 
 tag.setLayer(UNKNOWN_LAYER); 
 * Image descriptor used to delay the actual {@link Image} creation until really needed. <code>null</code> if no * image specified if it was already created (in which case the 'image' field will be non-null). 
 /** * Initialize tests. */ 
<|del|> 
 * Specific implementation of the history tree to save a segment store. It adds * specific methods to get the elements intersecting a given time range. 
<|del|> 
 int count = Iterators.size(iterator); 
<|del|> 
 Spliterator<T> spliterator = Spliterators.spliteratorUnknownSize(iterator, 0); return StreamSupport.stream(spliterator, false); 
 // Edit file and wait a bit for the ResourceChangedListener to trigger testFile1.appendContents(new ByteArrayInputStream("\nhello again 1!".getBytes()), true, true, new NullProgressMonitor()); 
 * Copyright (c) 2016 Ericsson 
 * Ericsson - Initial API and implementation 
 * Return a command that allows to delete the topic of a review 
 * @return {@link DeleteTopicCommand} 
 * Copyright (c) 2016 Ericsson 
 protected abstract String getExtensionId(); 
 final Predicate<TraceTypeHelper> predicateTracetypeIdEquals = (t) -> t.getTraceTypeId().equals(getExtensionId()); 
 private static final String TRACE_PATH_NAME = "testfiles/txt/valid/001.txt"; 
 private static final String TRACE_PATH_NAME = "testfiles/xml/valid/001.xml"; 
<|del|> 
 text.append(Messages.AttachmentTableLabelProvider_Task_Context); 
<|del|> 
 TableColumnDescriptor[] columnDescriptorArray = createColumnDescriptors(); 
 for (int i = 0; i < columnDescriptorArray.length; i++) { 
 if (!maybeProjectId.isPresent()) { throw new ESException(Messages.XmlRpcClientManager_NoValidProjectId); } 
public class XmlRpcConnectionManager extends AbstractConnectionManager<XmlRpcClientManager> implements 
 // Nothing to do, operation has been cancelled 
 // Nothing to do, operation has been cancelled 
<|del|>
 for (IPluginModelBase model : models) { 
 return "HTML Renderer"; 
 public final HtIo<IHTObject, HTNode<IHTObject>> fHistoryTreeIo; 
public abstract class AbstractHistoryTree<E extends IHTObject, N extends HTNode<E>> implements IHistoryTree<E, N> { 
 private final void addSiblingNode(int depth, long newNodeStartTime) { 
<|del|> 
 protected class CoreNodeData { 
 return (fConfig.equals(other.fConfig) && fNodeStart == other.fNodeStart && fNodeEnd == other.fNodeEnd && fSequenceNumber == other.fSequenceNumber && fParentSequenceNumber == other.fParentSequenceNumber); 
 * Exceptions thrown when deleting or creating the file 
 protected long getNewBranchStart(int depth, E interval) { // The new branch starts at the end of the tree + 1, because the last // branch closed at tree end and they must be sequential 
 public void linkNewChild(@NonNull IHTNode<E> childNode) { if (!(childNode instanceof OverlappingNode<?>)) { throw new IllegalArgumentException("Adding a node that is not an overlapping node to an overlapping tree!"); //$NON-NLS-1$ } 
<|del|> 
 fListeners.forEach(l -> l.nodeClosed(this, endtime)); 
<|del|> 
<|del|> 
 * Copyright (c) 2012, 2016 Obeo and others. 
<|del|> 
 * @param annotation the Annotation that should be moved. 
 if (annotatableType.isSimpleType()) { 
 Name qualifier= (Name) astRewrite.createMoveTarget(qualifiedName.getQualifier()); SimpleName name= (SimpleName) astRewrite.createMoveTarget(qualifiedName.getName()); 
 return new DefaultInformationControl(parent, EditorsUI.getTooltipAffordanceString()); 
 * the listener to invoke when elements are locked or unlocked. 
<|del|> 
 protected IConsumer<List<Notification>> onModelChanged; 
 * The EEF-side listeners to notify when lock status change. 
 * UIs can be correctly rolled back to a consistent state 
 private Map<IExecutionDMContext, Integer> fRunCommands = new HashMap<>(); 
 pomFile = new File(basedir, PomFile.POLYGLOT_POM_XML); 
 final StringBuilder result = new StringBuilder(); 
 if (result.length() != 0) { result.insert(0, "(&").append(')'); //$NON-NLS-1$ return InstallableUnit.parseFilter(result.toString()); 
<|del|> 
 private boolean suppressed(File root, File resolved) { return !allowBare && !Constants.DOT_GIT.equals(resolved.getName()) && isSameFile(root, resolved); } private boolean isSameFile(File f1, File f2) { 
<|del|> 
 destination.refreshLocal(IResource.DEPTH_INFINITE, monitor); 
 if (open && !project.isOpen()) { SubMonitor progress = SubMonitor.convert(monitor, 2); 
 project.open(progress.newChild(1)); project.refreshLocal(IResource.DEPTH_INFINITE, progress.newChild(1)); 
 project.open(progress.newChild(1)); project.refreshLocal(IResource.DEPTH_INFINITE, progress.newChild(1)); 
 } SubMonitor progress = SubMonitor.convert(monitor, 8); progress.setTaskName( UIText.WizardProjectsImportPage_CreateProjectsTask); project.create(record.getProjectDescription(), progress.newChild(3)); project.open(IResource.BACKGROUND_REFRESH, progress.newChild(5)); return project; 
 SubscriberScopeManager manager = GitScopeUtil .createScopeManager(selectedResources); 
 SubMonitor progress = SubMonitor.convert(monitor, repoPaths.size()); 
 public final Collection<Integer> selectNextChildren(RangeCondition<Long> timeCondition) { 
<|del|> 
 if (progress.isCanceled()) { 
 SubMonitor progress = SubMonitor.convert(monitor, UIText.WizardProjectsImportPage_CreateProjectsTask, 8); 
 lookForNested, skipHidden); 
 private static final long MAX_ORDER = 62; // Larger than that would overflow 
 private Chart fChart; 
 final Chart chart = fChart; assertNotNull(chart); bot.waitUntil(ConditionHelpers.numberOfSeries(chart, 1)); 
 IPath getArtifactPath(EObject artifact); 
 TimeUnit.MILLISECONDS.sleep(300); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Activator.getDefault().logWarning("Order of alloc is outside of acceptable range : " + value); //$NON-NLS-1$ return; 
 String newVersion = "2.0.0"; verifier.addCliOption("-DnewVersion=" + newVersion); 
 PomFile rootPom = PomFile.read(new File(baseDir, "pom.xml"), false); Assert.assertEquals(newVersion, rootPom.getVersion()); 
 * Daniel Megert <daniel_megert@ch.ibm.com> - Show Git Staging view in Show In menu 
 addToFocusTracking(textWidget); 
 control.setData(FormToolkit.KEY_DRAW_BORDER, FormToolkit.TREE_BORDER); GridDataFactory.fillDefaults().grab(true, true).hint(SWT.DEFAULT, 50) .applyTo(control); addToFocusTracking(control); 
 control.setData(FormToolkit.KEY_DRAW_BORDER, FormToolkit.TREE_BORDER); GridDataFactory.fillDefaults().grab(true, true).applyTo(control); addToFocusTracking(control); 
 getManagedForm().getForm().setFocus(); 
 control.setData(FormToolkit.KEY_DRAW_BORDER, FormToolkit.TREE_BORDER); GridDataFactory.fillDefaults().grab(true, true).applyTo(control); addToFocusTracking(control); 
 protected List<String> data; 
 if (fetchResultImage != null) { 
 if (DEBUG_STATUS) { DebugUtils.debug("Create reference from Facet: " + name); //$NON-NLS-1$ 
 if (DEBUG_STATUS) { DebugUtils.debug("Create reference from Facet: " + name); //$NON-NLS-1$ 
 if (DEBUG_STATUS) { DebugUtils.debug("Create attribute from Facet: " + name); //$NON-NLS-1$ 
 if (DEBUG_STATUS) { DebugUtils.debug("Add additional ocl property: " + property); //$NON-NLS-1$ 
 || rc.max() > node.getNodeEnd()) { 
 text.append(" Continued\n"); 
 text.append(" Continued\n"); 
 defaultTarget = MAINBUILD.concat(COLON); 
<|del|> 
<|del|> 
<|del|> 
 * <code>true</code> to indicate that we should overwrite the 
 private static void writeSourceFile(Path outputFilePath, StringBuilder builder, boolean force) { 
 builder.append(" * @author ").append(System.getProperty("user.name")).append(System.lineSeparator()); //$NON-NLS-1$ //$NON-NLS-2$ 
 builder.append(" * @author ").append(System.getProperty("user.name")).append(System.lineSeparator()); //$NON-NLS-1$ //$NON-NLS-2$ 
 * 
<|del|> 
 initRawPackageInfo(rawPackageInfo, path, false, compliance); 
 * Copyright (C) 2017 Two Sigma Open Source 
 * Copyright (c) 2012, 2017 Original authors and others. 
 if (!containsMatcherEditor(matcherEditors, existingMatcherEditor)) { 
 if (node == null) return true; 
 IASTTranslationUnit ast = tu.getAST(index, ASTCache.PARSE_MODE); 
 private void assertWritable() { assertEnabled(); SWTBotAssert.assertVisible(this); 
 * Comparable type, for instance Long for timestamps 
 * Comparable type, for instance Long for timestamps 
 if (max < min || step < 0) { 
 for (long t = min; t < max; t += increment) { 
 times.add(max); 
 protected ICommand getBeforeDestroyDependentsCommand(DestroyDependentsRequest request) { 
<|del|> 
 throw new IOException(MessageFormat .format(JGitText.get().badShallowLine, line)); 
 * Philip Langer - adaptation for refactoring regarding SizeChange 
 if (!adapters.isEmpty()){ for (ILocalSearchAdapter adapter : adapters) { adapter.operationExecuted(this, frame); } 
 * Copyright (c) 2014, 2017 Obeo 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Copyright (c) 2017 Obeo 
<|del|> 
 private static <E extends Comparable<E>> E min(E n1, E n2) { 
 private static <E extends Comparable<E>> E max(E n1, E n2) { 
 return fSet.first(); 
<|del|>
 // 500: give the UI task a chance to update the active state rcs.schedule(500); 
 private volatile boolean doReschedule; 
 private void updateRefreshInterval() { 
 cancel(); schedule(interval); 
 private static int getRefreshIndexInterval() { 
 "Trying to cancel " + rcs.getName() + " job"); //$NON-NLS-1$ //$NON-NLS-2$ } 
 private volatile boolean doReschedule; 
 //XXX Wrapping with sneaky throw from Xtend (same behaviour as EclipseBasedShouldGenerate) 
 /** * The parent of this EObjectStructuredObservableValue. */ 
 public EObjectStructuredObservableValue(final EObject eObject, final EStructuralFeature eStructuralFeature, final EditingDomain domain, final boolean browseFeatures, final EObjectStructuredObservableValue parent) { 
<|del|> 
 /** * Returns the root parent of an EObjectStructuredObservableValue. * * @param observableValue * The child ObservableValue. * @return The root parent */ private EObjectStructuredObservableValue getRootObservableValue(final EObjectStructuredObservableValue observableValue) { 
<|del|> 
 /** * Verify if the CreateInstance button should be enabled or not. */ 
 public static final String TABLE_FILE_EXTENSION = "table"; //$NON-NLS-1$ 
 * Mickal ADAM (ALL4TEC) mickael.adam@all4tec.net - implementation of strike though, font and font color 
 * Font prefix into 'span' node. 
 * the parent block flow which will contain the created block * @param styles * stack of styles to be applied 
 Node namedItem = attributes.getNamedItem("style"); //$NON-NLS-1$ 
 String fontName = fontString.split(",")[0]; //$NON-NLS-1$ 
 * Overridden to refresh text after set of font and font color to be taken into account. 
 // Refresh text 
 * @return The current foreground color. 
 * Extract strike through value from styles. * * @param styles * the list of styles 
 * Extract strike through value from styles. * * @param styles * the list of styles 
 * Extract strike through value from styles. * * @param styles * the list of styles 
 * Generate code from a node representing a strike through styled text. 
 * Generate code from a node representing a strike through styled text. 
 * the parent block flow which will contain the created block * @param styles * the stack of styles 
 Node fontNameNode = node.getAttributes().getNamedItem("face"); //$NON-NLS-1$ Node fontSizeNode = node.getAttributes().getNamedItem("size"); //$NON-NLS-1$ String oldFont = ""; //$NON-NLS-1$ 
 oldFont = (Styles.font.getData().get(FONT_NAME) != null) ? (String) Styles.font.getData().get(FONT_NAME) : "Arial"; //$NON-NLS-1$ 
 s(""), // strike through //$NON-NLS-1$ u(""), // underline //$NON-NLS-1$ 
 * Mickal ADAM (ALL4TEC) mickael.adam@all4tec.net - Bug 502878 
<|del|> 
 if (facade != null) { UMLRTProtocol protocol = facade.getType(); if (protocol != null) { protocols.add(protocol); } 
 .map(UMLRTProtocolMessage::toReceiveEvent) 
 public synchronized void updateTraceContext(ITmfTrace trace, UnaryOperator<TmfTraceContext.Builder> updater) { TmfTraceContext ctx = getTraceContext(trace); 
 * @param headerName the header name 
 NavigableSet<@NonNull E> subSet = fSet.subSet(from, true, to, true); if (subSet.isEmpty()) { return null; } return new DiscreteRangeCondition<>(subSet); 
 String tid = entry.getTid(); if (tid == null) { 
 for (BigInteger candidateAddress=firstItemVisibleAddress; candidateAddress.compareTo(lastItemVisibleAddress) <=0; candidateAddress = candidateAddress.add(BigInteger.ONE)) { 
 * @param candidateAddress - An address higher than base address 
 return resource.getLocation() == null ? Path.EMPTY : resource.getLocation(); 
 * The new indexer 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 throw new OseeCoreException("Failed to parse expression: " + expression); 
 throw new OseeCoreException("Failed to parse expression: " + valueExpression); 
 value = value.equals("Default") ? getDefaultValue(feature, featureDefArt) : value; 
 * Copyright (c) 2016 Boeing. 
 throw new OseeCoreException( "Failed to parse expression: " + plExpression + " at start Index: " + startReplaceIndex); 
<|del|> 
 if (commandControl != null && gdbBackEnd != null) { 
<|del|> 
 if (unassignedProjects.contains(element)) { 
 size += pack.getPackDescription().getFileSize(PACK) - 32; 
 * estimated size of the .pack file in bytes. If 0 the pack file * size is unknown. 
 bot.checkBox("SWT.READ_ONLY").select(); final SWTBotText text = bot.textInGroup("Text"); 
 bot.checkBox("SWT.READ_ONLY").select(); final SWTBotText text = bot.textInGroup("Text"); 
 * Sets the selection to the given items. * If there is more than one item to select, the table must have the SWT.MULTI style. 
 int[] selectedIndices = widget.getSelectionIndices(); for (int i = 0; i < selectedIndices.length; i++) { unselect(selectedIndices[i]); 
<|del|> 
 private void unselect(final int row) { 
<|del|> 
 * Selects the given index items. * If there is more than one item to select, the table must have the SWT.MULTI style. 
<|del|> 
 notify(SWT.MouseDown, createMouseEvent(0, 0, 1, stateMask2, 1)); notify(SWT.Selection, selectionEvent(stateMask1)); notify(SWT.MouseUp, createMouseEvent(0, 0, 1, stateMask1, 1)); 
 final int[] indices = new int[items.length]; for (int i=0; i<items.length; i++) { indices[i] = indexOfChecked(items[i]); 
 private int indexOfChecked(final String item) { 
<|del|> 
 } else if (task != null) { 
 * Copyright (c) 2017 Obeo. 
 assertEquals("There should be only one viewpoint node under group node", 1, resourceItem.getItems().length); 
 * Returns true if the file at the given path is in sync with the index. Returns false if the file has already * been tested and might be out-of-sync. Returns null if its status is unknown and needs to be tested. 
 synchronized (this.cookies) { 
 synchronized (this.cookies) { result = (T) this.cookies.get(key); 
 synchronized (this.cookies) { T newResult = (T) this.cookies.get(key); 
 * Creates a new instance of {@link FileStateCache}. 
 /** * Schedules a rescan of the given project. */ 
 public void dragWithKey(int fromXPosition, int fromYPosition, int toXPosition, int toYPosition, int keyCode, final AtomicBoolean dragFinished) { 
 public void dragWithKey(final int fromXPosition, final int fromYPosition, final int toXPosition, final int toYPosition, final int keyCode, final AtomicBoolean dragFinished) { 
 public void mouseDragWithKey(final int fromXPosition, final int fromYPosition, final int toXPosition, final int toYPosition, final int keyCode, final AtomicBoolean dragFinished) { 
 final AtomicBoolean dragFinished = new AtomicBoolean(false); 
 final AtomicBoolean dragFinished = new AtomicBoolean(false); 
 return dragFinished.get(); 
<|del|> 
 } else if (task != null) { 
 if (teamWorkflowExtensionItems != null) { return teamWorkflowExtensionItems; } 
 * Handle "?unload" JSON requests from browsers that don't support the Beacon API. @see {@link UnloadRequestHandler} 
 LOG.info("Unloading UI session with ID {} (requested by UI)", jsonReq.getUiSessionId()); 
 * Handles "/unload/<uiSessionId>" requests from browsers that support the Beacon API. 
 handleUnloadRequest(req, resp, uiSessionId); return true; 
 LOG.info("Unloading UI session with ID {} (requested by UI)", uiSessionId); 
 layout.marginBottom = IDialogConstants.VERTICAL_SPACING; 
 // Fill layout with empty labels 
 repoManipulatorButton.addSelectionListener(SelectionListener.widgetSelectedAdapter(e -> { openRepoManipulatorUi(); })); 
 TmfTraceFolder tracesFolder = projectElement.getTracesFolder(); 
 if (experimentFolder == null) { throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.TmfProject_ExperimentFolderNotExists)); 
<|del|> 
<|del|> 
<|del|> 
 * optional aggregation of X and Y {@link IDataConsumer} that are called after * all the objects have been processed and allow to execute extra operations on * the whole dataset. 
 * Accessor that returns a collection of consumer, one for each series in * the chart. 
 *******************************************************************************/ 
 * A collection of descriptors to check 
 private static final String MILLISECONDS_FORMAT = "ss.SSS"; //$NON-NLS-1$ 
 protected final void populate() { 
 * multiple Y values on an X value. With this consumer, all object sharing a * same string value will also share the same value on the axis. 
 private final BiMap<String, Integer> fMap; /** The list of value for each object consumed */ 
 if (!(obj instanceof SwtChartPoint)) { 
 fConsumer = new ScatterStringConsumer(IStringResolver.class.cast(desc.getResolver()), fMap); 
 // Only allow descriptors of the same type, that will mean the same // thing. It is hard to compare durations to timestamps for instance 
 // It would not make sense to allow log scales for timestamps, so it // only applies to other numerical values 
 * Method used for checking if a descriptor for the X axis is valid given * previously selected descriptors. 
 queryData.addCriteria(new CriteriaAssociatedArtId(DefaultHierarchyRoot)); 
 setMinMaxRange(minimum, fMaximum); 
 setMinMaxRange(fMinimum, maximum); 
<|del|> 
<|del|> 
 * a Stale NFS File Handle 
 retVal = new ListenerList<IDebugContextListener>(); 
 ListenerList<IDebugContextListener> listenersForPart = fListenersByPartId.get(listenerPartId); if (listenersForPart != null) { for (IDebugContextListener iDebugContextListener : listenersForPart) { 
<|del|> 
 public @NonNull RangeCondition<E> subCondition(E from, E to) { 
 IDocumentPartitioner partitioner= entry.getValue(); 
 static class AlphaInfo { 
 static class AlphaInfo { 
<|del|> 
 public void answerToCommentThenInsertANewComment() { 
 return new ProblemBinding(null, ISemanticProblem.TYPE_NOT_PERSISTED); 
 long AnnotationForModule = ASTNode.Bit62L; 
<|del|> 
String getJavaCallDeclaration() { 
 assertEquals("The label should use the AQL syntax that is ::", "testPackage::Refuge", typeContentProposal.getLabel()); 
 assertEquals("The label should use the AQL syntax that is ::", "testPackage::Refuge", typeContentProposal.getLabel()); 
 * Overridden to disable code generation of old palette framework. 
 * Get the {@link TextEmitter} to generate palette configuration model for papyrus diagrams. 
 * Copyright (c) 2017 Atos Origin, CEA, ALL4TEC and others. 
 * Copyright (c) 2017 cole Polytechnique de Montral 
 /* * Minimum and maximum values are all the same, so add 1 to the * minimum */ 
<|del|> 
 default String getContainerId() { return null; }; 
 protected static DsfSession fSession = null; 
 fail(e.getMessage()); return; 
 DsfLaunch dsfLaunch = new DsfLaunch(lc, ILaunchManager.DEBUG_MODE, sourceLocator); fSession.registerModelAdapter(ILaunch.class, dsfLaunch); 
 * It optionally supports persistence of user-defined Register Groups per container/process, 
 private static int fGroupBookingCount = 1; 
<|del|> 
 buttonLabelToIdMap.put(IDialogConstants.CANCEL_LABEL, 
<|del|> 
 * @deprecated Always false. Don't use it. 
 public static String getArtifactLabel(EObject object) { 
 if (isAccepting(diff, mergeRightToLeft)) { 
<|del|> 
<|del|> 
<|del|> 
 if (element instanceof ICBreakpoint) { 
 for (IConfigurationElement configElement : children) { Expression child= perform(configElement); 
 for (Class<?> interfaze : interfaces) { if (uncachedIsSubtype(interfaze, type)) 
 for (String property : properties) { assertTrue("Property accessed", accessedPropertyNames.contains(property)); 
 for (Object element : newSnapshot.values()) { FileSummary newElement = (FileSummary) element; 
 for (Object element : oldSnapshot.values()) { FileSummary oldElement = (FileSummary) element; 
 for (Object element : snapshot.values()) { FileSummary fileSummary = (FileSummary) element; out.println(fileSummary.getPath()); out.println(fileSummary.getTimestamp()); out.println(fileSummary.getSize()); 
 if (files != null) { for (String child : files) { clear(new java.io.File(file, child)); } } 
 for (IStatus child : children) { log(child, newPrefix); 
 for (Method method : methods) { 
 for (IStatus status : statuses) { RuntimeLog.log(status); 
 for (Entry entry : entries) { queue.enqueue(entry); 
 for (Entry entry : entries) { queue.enqueue(entry); 
 static final String stashMessage = UIText.AutoRebaseProcess_UncommitedChanges; 
 } catch (CoreException e) { EGerritCorePlugin.logError(fGerritClient.getRepository().formatGerritVersion() + e.getMessage()); 
 EGerritCorePlugin.logError(fGerritClient.getRepository().formatGerritVersion() + e.getMessage()); 
 EGerritCorePlugin.logError(fGerritClient.getRepository().formatGerritVersion() + e.getMessage()); 
 /* Checkout the newly created local branch */ 
 EGerritCorePlugin.logError(fGerritClient.getRepository().formatGerritVersion() + e.getMessage()); 
 EGerritCorePlugin.logError(fGerritClient.getRepository().formatGerritVersion() + e.getMessage()); 
 MessageDialog.open(MessageDialog.INFORMATION, null, UIText.AutoRebaseProcess_AutoRebaseStarted, 
 EGerritCorePlugin.logError(fGerritClient.getRepository().formatGerritVersion() + e.getMessage()); 
 } 
 * Copyright (c) 2014, 2017 Obeo. 
<|del|> 
 IStructuredSelection selection = statusListViewer.getStructuredSelection(); if (selection != null && selection.size() == 1) { return (StatusAdapter) selection.getFirstElement(); 
 IUndoableOperation operation = (IUndoableOperation) selection.getFirstElement(); 
 IUndoableOperation operation = (IUndoableOperation) viewer.getStructuredSelection().getFirstElement(); 
 IStructuredSelection selection = fViewer.getStructuredSelection(); 
 assertEquals("selectionEquals - " + message, expectedList, selection.toList()); 
 public IFigure findMouseEventTargetAt(int x, int y) { 
 final SWTBotGefEditPart selectedEP; if(editPartClass != null) { selectedEP = getEditPart(label, editPartClass); } else { selectedEP = getEditPart(label); } 
<|del|> 
 // Move the clock forward by 1 minute and use the same as ttl. mockSystemReader.tick(60); 
 AbstractTransactionalCommand cmd = new RenameDiagramLabelCommand(editingDomain, "ChangeDiagramLabelCommand", diag, diagramLabel, Messages.RenameDiagramHandler_Label_DialogTitle); //$NON-NLS-1$ 
 AbstractTransactionalCommand cmd = new RenameTableLabelCommand(editingDomain, "ChangeTableLabelCommand", table, tableLabel, Messages.RenameTableHandler_Label_DialogTitle); //$NON-NLS-1$ 
 AbstractTransactionalCommand cmd = new RenameNamedElementLabelCommand(editingDomain, "ChangeLabelCommand", namedElement, label, Messages.RenameNamedElementHandler_Label_DialogTitle); //$NON-NLS-1$ 
 addProposal = addProposal && clazz instanceof EClass; 
 private final String expected; 
<|del|> 
 // see Bug 509577 - [Traditional Rendering] Local variable enclosing markings may be wrong in Little Endian presentation return (!isDisplayLittleEndian() && prefShowInfo); 
 // see Bug 509577 - [Traditional Rendering] Local variable enclosing markings may be wrong in Little Endian presentation return (!isDisplayLittleEndian() && prefShowInfo); 
 * Copyright (c) 2017 cole Polytechnique de Montral 
 * Get a segment from a comparator that correspond whose field wrt to 
 * the current node is empty, <code>null</code> is returned. 
 /** * Add to the collection the intervals that are within a range. * 
 * SegmentStore factory method that creates a segment store on disk 
 String message = MessageFormat.format(JGitText.get().gcTooManyUnpruned, unpruned); gcLog.write(message.getBytes(StandardCharsets.UTF_8)); 
 private static final String RECONNECTION_SOURCE_TYPE = "Reconnection source";// $NON-NLS-0$ 
 private static final String RECONNECTION_TARGET_TYPE = "Reconnection target"; // $NON-NLS-0$ 
<|del|>
 * @param req * The tested request * @return <code>true</code> if the container of each Message Event are the same 
 * @param req * The tested request * @return <code>true</code> if the container of each Message Event are the same 
 * @param req * The tested request * @return <code>true</code> if the container of each Message Event are the same 
<|del|> 
 Object element = null; 
<|del|> 
 * This Helper does not allowed to move Message Occurrence Specification into another Fragment. * In order to avoid inconsistencies between model and Diagram; 
 * This Helper does not allowed to move Message Occurrence Specification into another Fragment. * In order to avoid inconsistencies between model and Diagram; 
 * {@inheritDoc} 
 // If elements to move are Message Occurence Specification do not allowed the move to avoid inconsistencies 
 * * {@inheritDoc} * 
 if (null != req && req.getElementToEdit() instanceof Interaction && req.getValue() instanceof List<?>) { 
 * List of old Elements (before the request execution) * * @param newList * List of new elements * 
 // If the List doesn't contain the current Fragment that means it is the new one 
 // If the List doesn't contain the current Fragment that means it is the new one 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (skipGarbagePack(pack)) 
 public void computeHeadingId() { 
 public IGlobalActionHandler getGlobalActionHandler(final IGlobalActionHandlerContext context) { 
 public static void doRun(final IEditorPart editorPart, final SWTDiagramPrinter diagramPrinter) { 
 if (null != data) { boolean isPrintToFit = MessageDialog.openQuestion(null, DiagramUIPrintingMessages.Print_MessageDialogTitle, DiagramUIPrintingMessages.Print_MessageDialogMessage); 
 protected void doPrint(final IGlobalActionContext cntxt) { 
 protected PreferencesHint getPreferencesHint(final IEditorPart editorPart) { 
 protected Collection<Integer> selectNextIndices(TimeRangeCondition rc) { 
 continue OBJECT_SCAN; 
 private boolean checkoutCreatedBranch(SubMonitor subMonitor, String tempName) { /* Checkout the newly created local branch */ subMonitor.setTaskName(Messages.AutoRebaseProcess_CheckoutNewlyCreatedLocalBranch); 
 private boolean checkoutCreatedBranch(SubMonitor subMonitor, String tempName) { /* Checkout the newly created local branch */ subMonitor.setTaskName(Messages.AutoRebaseProcess_CheckoutNewlyCreatedLocalBranch); 
 bop.execute(subMonitor); } catch (CoreException e) { EGerritCorePlugin.logError(e.getMessage()); return false; 
 fetchRes = new FetchOperationUI(localRepo, uri, patchSpecs, 0, false).execute(subMonitor); 
 try (RevWalk rw = new RevWalk(localRepo)) { 
 public CustomRebaseStatusDialog(String message) { this.dialogMessage = message; 
<|del|> 
 * Grgoire Dup (Mia-Software) - Bug 356795 - [Unit Test Failure][0.2/4.2][0.2/3.8] org.eclipse.emf.facet.widgets.nattable.tests.Bug344413Test.testBug344413 
 * Grgoire Dup (Mia-Software) - Bug 365808 - [Unit Test Failure][0.2/4.2][0.2/3.8] org.eclipse.emf.facet.widgets.nattable.tests.NatTableAPITests 
 private Map<String, String> initialAttributes = Collections.emptyMap(); 
 protected static MarkupParser createParserWithConfiguration(MarkupLanguageConfiguration configuration) { MarkupLanguage markupLanguage = new AsciiDocLanguage(); if (configuration != null) { markupLanguage.configure(configuration); } MarkupParser parser = new MarkupParser(markupLanguage); return parser; } 
 public void createTableViewerLabelColumn(Object object) { 
<|del|> 
 public void run() { createReviewList(); 
<|del|> 
 UIUtils.displayInformation(Messages.UIFilesTable_3, Messages.UIFilesTable_2 + '\n' + failedFiles); 
 static final String MARKUP_FOR_DEFAULT = "Some default values\n\n" + // 
 return new MarkupParser(markupLanguage); 
 private static boolean isMruEnabled() { 
 private static boolean isMruEnabled() { 
 public void createTableViewerLabelColumn(Object object) { 
<|del|> 
 handleVisibleSelection(structuredSelection); handleNonVisibleSelection(structuredSelection); 
 event.data = viewer.getStructuredSelection().toArray(); 
 Object[] markers = viewer.getStructuredSelection().toArray(); 
 Object markers[] = viewer.getStructuredSelection().toArray(); 
 event.data = viewer.getStructuredSelection().toArray(); 
 Object[] data = viewer.getStructuredSelection().toArray(); 
 Object markers[] = viewer.getStructuredSelection().toArray(); 
 long time = System.currentTimeMillis(); 
 Version v = getDetailedVersion(version); if (v != null && Objects.equals(stability, v.getStability())) { 
 * Copyright (c) 2013, 2017 CEA LIST. 
 * Copyright (c) 2009, 2017 Atos Origin. 
 * Copyright (c) 2009, 2017 Atos Origin. 
 * Constant definitions for VIATRA Query Tooling Core plug-in preferences * * @noreference This experimental class is not intended to be referenced by clients. 
 this.automaticIndexing = preferenceStore.getBoolean(ToolingCorePreferenceConstants.P_DISABLE_TARGET_PLATFORM_METAMODEL_INDEX_UPDATE); 
 private ITmfTrace fTrace; 
 } return new DescriptorsInformation(false, false, false); 
 private static final char ELLIPSIS = ''; 
 fCloseButton.setSize(CLOSE_BUTTON_SIZE, CLOSE_BUTTON_SIZE); fCloseButton.setLocation(fChart.getSize().x - fCloseButton.getSize().x - CLOSE_BUTTON_MARGIN, CLOSE_BUTTON_MARGIN); 
 if (descriptors.isEmpty()) { 
<|del|> 
<|del|> 
 fCloseButton.setLocation(fChart.getSize().x - fCloseButton.getSize().x - CLOSE_BUTTON_MARGIN, CLOSE_BUTTON_MARGIN); 
 Chart chart = getChart(); IAxisSet axisSet = chart.getAxisSet(); IAxis xAxis = axisSet.getXAxis(0); 
 for (IAxis axis : axisSet.getXAxes()) { 
 protected static final char ELLIPSIS = ''; 
 swtSeries.setBarPadding(BAR_PADDING); 
 int lengthLimit = (int) (rect.height * LENGTH_LIMIT); 
 checkout(textForBranch, monitor); } catch (InterruptedException e) { 
<|del|> 
 return getMatchingPaths(objId, tf, true); 
 try (TreeWalk tw = new TreeWalk(db)) { tw.setFilter(tf); tw.setRecursive(recursive); tw.addTree(objId); 
 try (TreeWalk tw = new TreeWalk(db)) { tw.setFilter(tf); tw.setRecursive(recursive); tw.addTree(objId); 
 return objId; 
 result = checkout(textForBranch, progress.newChild(1)); 
 checkout(textForBranch, progress.newChild(1)); 
 for (final NamedElement member : scope.getMembers()) { 
 for (final NamedElement member : scope.getMembers()) { 
 private static final String XML_CONTENT = 
<|del|> 
 * This method extends the result returned by {@link #include(TreeWalk)} 
import static org.junit.Assert.fail; 
 * object whose contents are a hash collision. 
<|del|> 
 createBranch(textForBranch, doCheckoutNewBranch, commit, monitor); 
 bop.execute(progress.newChild(2)); 
 bop.execute(progress.newChild(2)); 
 long low = Math.max(from, fLongMin); long high = Math.min(fLongMax, to); if (high < low) { return null; } return new ContinuousTimeRangeCondition(low, high); 
 SortDataType.String, true, "Backlog that this item belongs to."); 
 * a visible position in the NatTable with the underlying * viewport linked to the row header 
 * a visible position in the NatTable with the underlying * viewport linked to the column header 
<|del|> 
 assertArrayEquals("menu items, 2 marker set", MENU_ITEMS_2_MARKERS_SET, menuItems.toArray()); assertTrue("None is checked", viewMenu.menu("Marker Set").menu(MENU_ITEMS_2_MARKERS_SET[0]).isChecked()); 
 assertArrayEquals("menu items, 2 marker set", MENU_ITEMS_2_MARKERS_SET, menuItems.toArray()); assertTrue("None is checked", viewMenu.menu("Marker Set").menu(MENU_ITEMS_2_MARKERS_SET[0]).isChecked()); 
<|del|> 
<|del|> 
 UIText.FetchGerritChangePage_CreatingBranchTaskName, doCheckout ? 10 : 2); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 protected abstract ApplicabilityId getApplicabilityId(); 
 * Combines sequential small writes into larger writes and that ensures that writes don't happen faster than a certain * maximum rate. 
<|del|> 
 toolTipHelper.setHideDelay(TOOLTIP_HIDE_DELAY); 
 if (mainView.isPresent()) { EObject main = mainView.get().getElement(); if (main instanceof State) { return UMLRTExtensionUtil.getRootDefinition((State) main).getRegions().get(0); } 
 PSEUDOSTATE_EXIT_NODE("org.eclipse.papyrusrt.umlrt.tooling.diagram.statemachine.RTPseudoState_ExitPointShape", PseudostateExitPointEditPart.VISUAL_ID), 
 public Font getDefaultFontWithWorkbenchDefaultSizeAndFromLabelFormat(final List<FontFormat> labelFormats) { return getFontFromNameAndLabelFormatAndWithDefaultSize(labelFormats, DEFAULT_FONT_NAME); 
 * Copyright (c) 2009, 2017 THALES GLOBAL SERVICES and others. 
 // If the diff is not a refined diff and is in a pseudo conflict // Or if the diff is a refined diff that is not in a direct pseudo conflict, but all its // refining diffs are in pseudo conflicts 
 assertNull("Module not present", findModule(modules, MY_MODULE)); 
<|del|> 
 assertTrue("Extended module class", newModule instanceof ExternalAnalysisModuleStub); assertEquals("Extended module ID", MY_MODULE, newModule.getId()); 
 assertTrue("Extended module class", newModule instanceof ExternalAnalysisModuleStub); assertEquals("Extended module ID", ABC_MODULE, newModule.getId()); 
 /* get the "abc" modules */ 
 /** * GTK specific DnD variables */ boolean blockSelected, movingSelection, isDragDetecting; 
 * send a mouse Up signal for >GTK3.14 as Wayland (support as of 3.14) * does not trigger a MouseUp/Mouse_release_event on DragEnd. * See Bug 510446. 
 public @NonNull LanguageServer getLanguageClient() { return this.server; 
 Preconditions.checkNotNull(serverContent, "Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"); this.serverContent = ImmutableMap.copyOf(serverContent); 
<|del|> 
 this.imageServerContent = ImmutableMap.copyOf(serverContent); 
 this.imageServerContent = ImmutableMap.copyOf(imageServerContent); 
 blockSelected = false; 
 return false; 
 menuManager = null; toolkit = null; 
 menuManager = null; toolkit = null; 
 * Copyright (c) 2017 THALES GLOBAL SERVICES. 
<|del|> 
 * Checks the first tooltip in the decoration group. */ /** * @param dDiagramElementDecorationFigures * decoration figures of the DDiagramElement 
 * position of the decoration group * @param expectedGroupBounds * the bounds to find the group * @param tooltipLabel * the expected tooltip label 
 * Checks the group decorations. Checks that the given group and its * decorations are correctly positioned 
 /** * Gets the group figure corresponding to the expectedGroupBounds bounds. */ 
 assertNotNull("Bad group decoration position at " + position.getName(), groupFigure); 
 /** * Gets the {@link DDiagramElement} with the given name among * ownedDiagramElements. */ 
 // EAST decorations should NOT be a list decorator because it is smaller // than the list decorator size. A group containing one decoration that // is smaller than the list decorator can be changed into a list // decorator. 
 List<Figure> children = tooltip.getChildren(); 
 /** * Check that decorator are correctly displayed when the image or the figure * is provided by a service */ 
 Label figureWithtext = new Label(semanticObject.getName()); // figureWithtext.setSize(8, 20); figureWithtext.setBackgroundColor(ColorConstants.blue); figureWithtext.setForegroundColor(ColorConstants.red); 
 // imageFigure.setSize(16, 16); 
 return Iterables.contains(iterable, seg); 
<|del|> 
 private IGraphicalEditPart findBestChildCandidate(IGraphicalEditPart graphicalEditPart, Point startLocation) { 
 private static final Pattern PLUGIN_LINE_PATTERN = Pattern.compile("\\s*<plugin id=\"(\\S*)\".*"); //$NON-NLS-1$ 
 * Copyright (c) 2009, 2017 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2009, 2017 THALES GLOBAL SERVICES. 
 * Copyright (c) 2009, 2017 THALES GLOBAL SERVICES. 
 return headerBackground != null ? headerBackground : display.getSystemColor(SWT.COLOR_LIST_BACKGROUND); 
 return headerForeground != null ? headerForeground : display.getSystemColor(SWT.COLOR_LIST_FOREGROUND); 
 configurationPreferences.put(TRACE_TYPE_PREFERENCE_KEY, configurationPreferences.get(TRACE_TYPE_PREFERENCE_KEY, getDefaultEncodedValue())); configurationPreferences.flush(); 
 configurationPreferences.put(TRACE_TYPE_PREFERENCE_KEY, configurationPreferences.get(TRACE_TYPE_PREFERENCE_KEY, getDefaultEncodedValue())); configurationPreferences.flush(); 
 Map<String, TraceTypeHelper> helpers = new HashMap<>(); fViewer.getCheckedElements().forEach(helper -> helpers.put(helper.getName(), helper)); TraceTypePreferences.setPreferenceValue(helpers); 
 ".capra-drive-credentials" + java.io.File.separator + "drive.googleapis.capra-drive"); 
 this.interpreter.unSetVariable(IInterpreterSiriusVariables.CONTAINER); this.interpreter.unSetVariable(IInterpreterSiriusTableVariables.LINE); this.interpreter.unSetVariable(IInterpreterSiriusTableVariables.TABLE); 
 this.interpreter.unSetVariable(IInterpreterSiriusVariables.ROOT); this.interpreter.unSetVariable(IInterpreterSiriusTableVariables.TABLE); 
 * Copyright (c) 2010, 2017 THALES GLOBAL SERVICES. 
 addField(Project.PROPERTY_LAST_MODIFIED_MILLIS, Long.toString(project.getLastModifiedMillis()), true, true); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Checks the first tooltip in the decoration group. Checks that the label * is correct 
<|del|> 
 assertTrue("Decoration tooltip figure should be an instance of org.eclipse.draw2d.Label in " + Position.SOUTH_EAST_LITERAL + " group", tooltip instanceof Figure); 
 // NORTH_WEST should be a list decorator because it overlaps the diagram 
<|del|> 
 protected ICommand getBeforeConfigureCommand(ConfigureRequest request) { ICommand result = null; 
 private static final String ERROR_TITLE = "Error"; 
 } String port = EnvironmentUtils.getArgValue(args, EnvConstants.CLIENTPORT_KEY); if (StringUtils.isNotEmpty(port)) { System.setProperty(EnvConstants.CLIENTPORT_KEY, port); } 
 int pos = ArrayUtils.indexOf(args, StringConstants.MINUS + key); 
 * @return True if the trace helper is enabled, false otherwise 
 public boolean isEnabled() { 
 public void setEnabled(boolean enable) { 
 TmfTraceType.getTraceTypeHelpers().forEach(helper -> { if (!helper.isExperimentType()) { helper.setEnabled(!Iterables.contains(unchecked, helper.getTraceTypeId())); } }); 
 public boolean performOk() { 
<|del|> 
 * updateTargetUnderMouse() is used to set the targetEditPart then used by handleButtonDown latter. This override has a 
 try (ScopeLog log = new ScopeLog(LOGGER, Level.FINE, "StateSystemAnalysis:executing", "aid", id)) { //$NON-NLS-1$ //$NON-NLS-2$ 
 long length = attachment.getLength(); 
 return ADAPTER_LIST; 
 helper.setEnabled(!preferences.contains(helper.getTraceTypeId())); 
 * Singleton class to access the trace type preferences of Trace Compass. The * trace type preferences is a blacklist preference of disabled trace types. 
 return getText(element); 
 List<TraceTypeHelper> unchecked = fViewer.getUncheckedElements(); TraceTypePreferences.setPreferenceValue(Iterables.transform(unchecked, new Function<TraceTypeHelper, @NonNull String>() { @Override public String apply(TraceTypeHelper helper) { return helper.getTraceTypeId(); } })); 
<|del|> 
 private static Button createButton(Composite parent, int id, String label) { 
 private static Button createButton(Composite parent, int id, String label) { 
<|del|> 
 fInput = (Iterable<@NonNull TraceTypeHelper>) newInput; 
 setTraceTypePreferences(CHECK_ALL); 
 private static void setTraceTypePreferences(@NonNull String button, @NonNull String... pathToCheck) { 
 * Copyright (c) 2007, 2017 THALES GLOBAL SERVICES and others. 
 /** * Create the decoration group for the boolean property in this preference page. * 
 * Abstract implementation used for sub classes that implements SiriusDecorationDescriptorProvider. 
 * @return true if the editPart respect conditions to be decorated, false otherwise 
 /* * exclude AbstractDiagramNameEditPart but not DNodeListElementEditPart that can be decorated for * compartment */ 
 * Copyright (c) 2017 THALES GLOBAL SERVICES. 
 * Normal priority. Used for decorations provided with the VSM. 
 * Decoration type. 
 * Decoration tooltip if defined as figure. 
 * listeners should be unhooked in {@link #deactivate(GraphicalEditPart, IDecorator)}. </br> 
 * @see #deactivate(GraphicalEditPart, IDecorator) 
 void deactivate(IDecorator decorator, GraphicalEditPart editPart); 
 void deactivate(IDecorator decorator, GraphicalEditPart editPart); 
 * Copyright (c) 2017 THALES GLOBAL SERVICES. 
 * Copyright (c) 2017 THALES GLOBAL SERVICES. 
 IInterpreter interpreter = session.getInterpreter(); 
 private class DecorationDescriptorWithLazyTooltip extends DecorationDescriptor { 
<|del|> 
 if (session == null) { session = new EObjectQuery(element).getSession(); } IInterpreter interpreter = session.getInterpreter(); 
public class EditModeDecorationDescriptorProvider extends AbstractSiriusDecorationDescriptorProvider { 
 /** * Indicates if decorations are globally activated for Sirius diagram element. * * @return value */ 
 * This IDecorator handles core Sirius decorations and decorations provided in the VSM. 
 private static final Integer DEFAULT_MARGIN = 2; 
 DRepresentationElement model = (DRepresentationElement) view.getElement(); this.session = SessionManager.INSTANCE.getSession(model.getTarget()); 
 Map<Position, IFigure> figureAtPosition = computeGroupDecorationsFigure(positionToDecorators, margin); if (figureAtPosition != null) { addDecoration(getDecoratorTarget().addConnectionDecoration(figureAtPosition.get(Position.CENTER_LITERAL), 50, false)); } 
 private Map<Position, IFigure> computeGroupDecorationsFigure(Map<Position, List<DecorationDescriptor>> decosDescAtPosition, int margin) { 
<|del|> 
 * @return the figure dimension 
<|del|> 
 return Optional.empty(); 
<|del|> 
<|del|> 
<|del|> 
 registerCoreDecorationProviders(); 
 private void unregisterDecorationProviders() { 
 * Copyright (c) 2015, 2017 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2015, 2017 THALES GLOBAL SERVICES. 
 throw new UnsupportedPackVersionException(vers); 
 throw new UnsupportedPackIndexVersionException(v); 
 String procName = field == null ? StringUtils.EMPTY : (String) field.getValue() + '-'; 
 * disabled trace types. 
 * @param disabled * The list of disabled trace type ids in the preference page 
 List<String> disabled = new ArrayList<>(); 
 Iterable<String> splitted = Splitter.on(SEPARATOR).split(joined); for (String id : splitted) { disabled.add(id); 
 Iterable<String> splitted = Splitter.on(SEPARATOR).split(joined); for (String id : splitted) { disabled.add(id); 
 TraceTypePreferences.setPreferenceValue(Lists.newArrayList(Iterables.transform(unchecked, helper -> helper.getTraceTypeId()))); 
 } fTree.getViewer().collapseAll(); 
 GridData data = new GridData(SWT.RIGHT, SWT.TOP, false, false); 
 fTree.setChecked(parent, true); parent = fContentProvider.getParent(parent); 
 for (Object child : children) { 
<|del|> 
 List<RefSpec> branchSpecs = new ArrayList<>(1); RefSpec refSpecBranch; 
 refSpecBranch = new RefSpec().setSource("refs/heads/" + revisionInfo.getChangeInfo().getBranch()) //$NON-NLS-1$ .setDestination(Constants.FETCH_HEAD); 
 IStructuredSelection structuredSelection = treeViewer.getStructuredSelection(); 
 if (structuredSelection.isEmpty() == false) { 
 if (structuredSelection.isEmpty() == false) { 
 List<Spec> list = fileAssociationViewer.getStructuredSelection().toList(); return list.toArray(new Spec[list.size()]); 
 List<Spec> list = fileAssociationViewer.getStructuredSelection().toList(); return list.toArray(new Spec[list.size()]); 
 ITreeSelection treeSelection = getTreeViewer().getStructuredSelection(); 
 ITreeSelection treeSelection = getTreeViewer().getStructuredSelection(); 
 IStructuredSelection structuredSelection = fViewer.getStructuredSelection(); IStructuredSelection expectedSelection = new StructuredSelection(expected); assertEquals("selectionEquals - " + message, structuredSelection, expectedSelection); 
 public ZoomThread(long startTime, long endTime, long resolution, int scopeId) { 
 rebaseButton.addSelectionListener(rebaseButtonListener(rebaseButton.getShell())); 
 String value = Joiner.on(SEPARATOR).join(disabled); 
 Iterable<String> disabled = Splitter.on(SEPARATOR).split(joined); return Lists.newArrayList(disabled); 
 int checked = SWTBotUtils.getTreeCheckedItemCount(treeBot); assertEquals("default", 0, checked); 
 int checked = SWTBotUtils.getTreeCheckedItemCount(treeBot); assertEquals("default", 226, checked); 
 int checked = SWTBotUtils.getTreeCheckedItemCount(treeBot); assertEquals("default", 26, checked); 
import static org.junit.Assert.assertArrayEquals; 
 int defaultCount = SWTBotUtils.getTreeCheckedItemCount(treeBot); 
 selectAllButton.addSelectionListener(widgetSelectedAdapter(e -> { projectNames.setAllChecked(true); selection = projectNames.getCheckedElements(); updateEnablement(); })); 
 public static void afterClass() { setTraceTypePreferences(CHECK_ALL); 
 // Change node to refresh the tree 
 WaitUtils.waitUntil(tree -> tree.rowCount() > 0, viewBot.bot().tree(0), "Failed to import test filter"); 
 if (!helper.isExperimentType() && (helper.isEnabled() || (helper.getTraceTypeId().equals(selected)))) { 
import org.eclipse.swt.internal.cocoa.OS; 
 IWorkbench workbench = HandlerUtil.getActiveWorkbenchWindow(event).getService(IWorkbench.class); 
 * Copyright (C) 2016, Google Inc. 
 tabFolder = getPageFolder(currentSelectedEObject); if (!tab.controlCreated()) { // create tab control if not already created. tab.createControl(tabFolder); 
 if (guard != null && defaultLanguage != null) { // if default language is not null and there exist a guard // for this transition 
 // no need to keep this element in the map if adapter is removed // for whatever reason. e.g., model is closed 
 String transitionIdentifier = " --> "; 
 State containingState = ((Pseudostate) target).getState(); 
 if (searcher != null) { manager.release(searcher); searcher = null; } 
 meta.add(new StoredField(F_VERSION, VERSION)); 
 fields.add(new StoredField(REQUEST_DATE_FIELD_NAME, Long.toString(entry.getRequestDate().getTime()))); 
import java.util.Set; import java.util.regex.Pattern; 
<|del|> 
 tickLabels = new LinearScaleTickLabels(this); 
 * * @param obj * object * @return span in pixel 
 pixelsToStart = (int) ((value - min) / (max - min) * (length - 2 * margin)) + margin; 
<|del|> 
 this((LinearScale)linearScale); 
<|del|> 
 * Copyright (c) 2010, 2017 Oak Ridge National Laboratory and others. 
 public LinearScaleTicks2(DAxis scale) { 
<|del|> 
 Iterable<ITmfXmlSchemaParser> extraSchemaParsers = XmlUtils.getExtraSchemaParsers(); 
 * Specific implementation of the history tree to save a segment store. It adds * specific methods to get the elements intersecting a given time range. 
 * Get an iterator for the elements of this tree. It uses * {@link #getIntersectingElements(long, long)} for the full duration of the * tree. 
 return new BasicSegment2(getChildStart(index), Math.max(getChildStart(index) + fMaxLength[index], getChildStart(index))); 
<|del|> 
 public int getMajorTickMarkStepHint() { if (isDateEnabled()) { return Math.max(majorTickMarkStepHint, formatPatternSize); } 
 if (isDateEnabled()) formatPatternSize = TextUtilities.INSTANCE.getTextExtents(formatPattern, getFont()).width; 
 * This is used to declare the LinearScaleTickLabels object as an IScaleTickLabels * field in AbstractScale instead of declaring it in LinearScale 
 if (max - min < 1000) // <1 sec, step = 10 ms timeStep = 10l; else if (max - min < 60000) // < 1 min, step = 1 sec 
 double temp = gridStepHint + (timeStep - gridStepHint % timeStep); if (minBigger) temp = -temp; 
<|del|> 
<|del|> 
 public Map<String, String> createImageServerContent(String scheme) throws IOException { HashMap<String, String> map = new HashMap<>(); 
 public Map<String, String> createImageServerContent(String scheme) throws IOException { HashMap<String, String> map = new HashMap<>(); 
 checkNotNull(serverContent, 
 fMaxLength[childIndex] = child.getLongest(); // The child node's extra data applies to the child and its subtree, // so also update with the child's children 
 Map<String, String> map = new HashMap<>(); 
 * Segment history tree node data constructor 
 * @since 4.8 
 * @since 4.8 
public class HintAdjustmentTest { 
 @Before 
 @After 
 @Test 
public class SizeCacheTest { 
 if (notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (!dragDetect (x, y, false, true, null)) { 
 buffer.putString(fName); 
<|del|> 
 private final Action VIEW_BY_THREAD = new Action(Messages.FlameGraph_ShowPerThreads, IAction.AS_RADIO_BUTTON) { 
 if (!fViewByThread) { buildFlameGraph(fFlamegraphModule); fViewByThread = true; saveAggregateOption(fViewByThread); } 
 private volatile boolean fViewByThread = false; 
 * Christian W. Damus - bug 462958 * Mickal ADAM - mickael.adam@all4tec.net - Bug 459678 
 * Christian W. Damus - bug 468175 * Mickal ADAM - mickael.adam@all4tec.net - Bug 459678 
/** * Get the command to destroy {@link CombinedFragment}. */ 
 /** * Command to move Operand fragments. */ 
 /** * Select and delete pops up menu command. */ 
 /** * {@link EditElementCommand} to set {@link MessageSort}. */ 
 /** * {@link ElementEditHelper} for {@link CombinedFragment}. */ 
 /** * {@link ElementEditHelper} for {@link ConsiderIgnoreFragment}. */ 
 /** * {@link ElementEditHelper} for {@link ExecutionSpecification}. */ 
 * CEA LIST - Initial API and implementation 
 /** * {@link ElementEditHelper} for {@link Lifeline}. */ 
 protected ICommand getCreateRelationshipCommand(final CreateRelationshipRequest request) { 
 protected boolean isReadOnly(final EObject eObject) { 
/** * * Move Operand Fragment Edit Request. * */ public class MoveOperandFragmentEditRequest extends AbstractEditCommandRequest { 
 /** * @return true element is type of type to match */ 
 /** * @return true element is type of type to match */ 
 * Copyright (c) 2017 Obeo. 
 public static final Version MIGRATION_VERSION = new Version("12.0.0.2017041100"); //$NON-NLS-1$ 
 // provided when opened from a no modeling project. 
 } else { // we show as editor name the aird name and as description // the aird full path relatively to the project. 
 if (global) { 
 private static class ImportContainersFinder implements IModelElementVisitor { 
 return true; 
<|del|> 
 private Map<IMarker, Fixit> fixitMap = new HashMap<>(); 
 private Map<IMarker, Fixit> fixitMap = new HashMap<>(); 
 /** Same constructor as {@link LazyArrayListStore} */ 
<|del|> 
 StringBuilder methodName = new StringBuilder(method.getParent().getElementName()).append("::"); //$NON-NLS-1$ 
 protected LinearScaleTickLabels createLinearScaleTickLabels() { return new LinearScaleTickLabels2(this); 
 protected LinearScaleTickLabels createLinearScaleTickLabels() { return new LinearScaleTickLabels(this); 
 createLinearScaleTicks(); 
 if (scale instanceof AbstractScale) { AbstractScale aScale = (AbstractScale) scale; 
<|del|> 
 createLinearScaleTicks(scale); 
<|del|>
 * The Marker events are events with a duration that define a region of * interest. These regions can be displayed in views as Markers or other * indicators. 
<|del|> 
<|del|> 
 Activator.getDefault().logError("Unable to delete: " + dir.toString(), e); //$NON-NLS-1$ 
 fSourceUrl = Collections.singletonList(sourceUrl); 
 Assert.isTrue(index < totalCount && index >= 0, java.text.MessageFormat.format( 
 deleteMarker(marker); 
 fUniqueId = TraceCompassLogUtils.traceObjectCreation(LOGGER, Level.FINE, this); 
<|del|> 
 fUniqueId = TraceCompassLogUtils.traceObjectCreation(LOGGER, Level.FINE, this); 
 fUniqueId = TraceCompassLogUtils.traceObjectCreation(LOGGER, Level.FINE, this); 
 // .gitmodules referencing ../plugins/hooks, which is // on http://gerrit.googlesource.com/plugins/hooks, 
 * @since 8.5 
 IModelElement[] types = PHPModelUtils.getTypes(name, sourceModule, type.start(), null); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // stateMask should reflect CTRL key 
 // stateMask should reflect CTRL key 
 if (indices.length > 1) { 
<|del|>
 int stateMask1 = (ctrl) ? (SWT.NONE | SWT.CTRL) : SWT.NONE; int stateMask2 = (ctrl) ? (SWT.BUTTON1 | SWT.CTRL) : SWT.BUTTON1; 
 notify(SWT.MouseDown, createMouseEvent(0, 0, 1, stateMask1, 1)); notify(SWT.Selection, selectionEvent(stateMask2)); notify(SWT.MouseUp, createMouseEvent(0, 0, 1, stateMask2, 1)); 
 CCorePlugin.log(e); // should not happen 
<|del|> 
 public LinearScaleTicks2(DAxis scale) { 
 if (IAtsTeamWorkflow.isOfType(artifact)) { 
 private static final String CONTENT_PRESENTATION_OPTION_KEY = "presentation.option"; //$NON-NLS-1$ 
 private volatile ContentPresentation fContentPresentation = ContentPresentation.AGGREGATE_THREADS; 
 ContentPresentation contentPresentation = fContentPresentation; if (section != null) { String contentPresentationOption = section.get(CONTENT_PRESENTATION_OPTION_KEY); if (contentPresentationOption != null) { contentPresentation = ContentPresentation.fromName(contentPresentationOption); } 
 * Copyright (c) 2012, 2017 THALES GLOBAL SERVICES and others. 
 Set<EObject> result = new LinkedHashSet<EObject>(); 
 * {@link IAxesFactory} that produces Diamond Light Source alternative {@link DAxis} * 
 * {@link IAxesFactory} that produces Diamond Light Source alternative {@link DAxis} * 
 * 
 * 
<|del|> 
<|del|> 
 * 
 * 
<|del|> 
<|del|> 
 * Use correctly spelled {@link #updateMarkerElements()} instead. 
 private int numberOfIntervals; 
 * * @param numerator * @param denominator * @return rounded down value 
 protected static double roundDown(BigDecimal numerator, BigDecimal denominator) { final int ns = numerator.signum(); 
 * * @param numerator * @param denominator * @return rounded up value 
<|del|> 
 /** * Get the downloaded file if the operation was successful. Can be null if * something went wrong during the download. * 
 private @Nullable ISegment fLast = null; private @Nullable ISegment fNext = null; private Iterator<@NonNull ISegment> fIterator = iterableToCompact.iterator(); 
 private @Nullable ISegment fLast = null; private @Nullable ISegment fNext = null; private Iterator<@NonNull ISegment> fIterator = iterableToCompact.iterator(); 
 private Iterable<@NonNull ISegment> fDisplayData = Collections.emptyList(); 
 meForFeatureObservable = null; 
 if (meForFeatureObservable == null) { meForFeatureObservable = rtModelFactory.createFromSource(input, null); } 
 * Get observable for specification. 
 protected IObservable getSpecificationObservable(EObject element) { 
 ModelElement modelElement = rtModelFactory.createFromSource(element, null); result = modelElement.getObservable("specification"); 
 ModelElement modelElement = rtModelFactory.createFromSource(transition, null); IObservable observable = modelElement.getObservable("ownedRule"); 
 fText = new Text(parent, SWT.READ_ONLY | SWT.WRAP); data = new GridData(GridData.FILL_HORIZONTAL); data.grabExcessHorizontalSpace = true; fText.setLayoutData(data); fText.setForeground(parent.getDisplay().getSystemColor(SWT.COLOR_BLACK)); 
 fText = new Text(parent, SWT.READ_ONLY | SWT.WRAP); data = new GridData(GridData.FILL_HORIZONTAL); data.grabExcessHorizontalSpace = true; fText.setLayoutData(data); fText.setForeground(parent.getDisplay().getSystemColor(SWT.COLOR_BLACK)); 
<|del|> 
 * Selects the current tree item. Replaces the current selection. 
 * Selects the item matching the given name. Replaces the current selection. 
 @Test public void setEmptySelection() throws Exception { bot.radio("SWT.MULTI").click(); table = bot.tableInGroup("Table"); 
 @Test public void setEmptySelection() throws Exception { bot.radio("SWT.MULTI").click(); tree = bot.treeInGroup("Tree"); 
 tree.select(new String[] {}); 
 } try { tree.select("Node 2", "Node 4"); fail("Expecting an exception"); } catch (Exception e) { assertEquals("Tree does not support SWT.MULTI, cannot make multiple selections.", e.getMessage()); } 
 * Selects the items matching the array list. Replaces the current * selection. If there is more than one item to select, the tree must have * the SWT.MULTI style. 
 * Selects the indices provided. Replaces the current selection. If there is * more than one item to select, the tree must have the SWT.MULTI style. * * @param indices * the indices to select. 
 * Test the {@link DownloadTraceHttpHelper} class * * @author Simon Delisle 
 Point size = control.computeSize(widthHint, SWT.DEFAULT); if (widthHint!=SWT.DEFAULT && fill) size.x = Math.max(size.x, widthHint); if (width != SWT.DEFAULT) 
/** * Factory for creating test controls which try to maintain a constant area when * their width changes. */ public final class ControlFactory { 
 if (wHint != SWT.DEFAULT) { wHint -= adjusted.x; 
 /* * Since we don't know the size of an iterable, pass * size = 128, an aligned and reasonable size for a * segment store. */ updateData(startTime, endTime, 128, statusMonitor); 
<|del|> 
 List<Double> xSeries = nb != UNKNOWN_SIZE ? new ArrayList<>(nb) : new ArrayList<>(); List<Double> ySeries = nb != UNKNOWN_SIZE ? new ArrayList<>(nb) : new ArrayList<>(); 
 TraceCompassLogUtils.traceObjectDestruction(LOGGER, Level.FINE, this, fUniqueId); 
<|del|> 
 if (request.getValue() instanceof ArrayList && request.getElementToEdit() instanceof AttributeOwner && request.getFeature().equals(UMLPackage.eINSTANCE.getStructuredClassifier_OwnedAttribute())) { 
 List<IBean<T>> beans = CollectionUtility.arrayList(m_beans); Collections.sort(beans, ORDER_COMPARATOR); return getExactBean(beans, beanClazz); 
 //remove duplicate registered classes, keep only bean with lowest order Set<Class<?>> seenBeans = new HashSet<>(); 
 BeanHierarchy h = m_beanHierarchies.get(beanClazz); if (h != null) { return h.getExactBean(beanClazz); 
 BeanHierarchy h = m_beanHierarchies.get(clazz); return h != null && !h.getBeans().isEmpty(); 
 EObject root = roots.get(0); if (root instanceof Group) { return Optional.of((Group) root); } 
<|del|> 
 zoomThread = createZoomThread(clampedStartTime, clampedEndTime, resolution, restart); fZoomThread = zoomThread; if (zoomThread != null) { zoomThread.setScopeId(log.getId()); 
 zoomThread = createZoomThread(clampedStartTime, clampedEndTime, resolution, restart); fZoomThread = zoomThread; if (zoomThread != null) { zoomThread.setScopeId(log.getId()); 
 * Copyright (c) 2011, 2017 SAP AG. 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 String message = String.format(Messages.PHPServer_incompatible_version, module.getName(), moduleVersion, runtimeVersion); 
 String message = String.format(Messages.PHPServer_incompatible_version, module.getName(), moduleVersion, runtimeVersion); 
 String message = String.format(Messages.PHPServer_incompatible_version, module.getName(), moduleVersion, runtimeVersion); 
 private static final TmfTimestampFormat TIMESTAMP_FORMAT = new TmfTimestampFormat("yyyy-MM-dd " + TmfTimestampFormat.getDefaulTimeFormat().toPattern()); //$NON-NLS-1$ 
<|del|> 
 data.setComparator(SegmentComparators.INTERVAL_LENGTH_COMPARATOR); ISegment maxSegment = data.getElement(-1); 
 styledString.append(MessageFormat.format(" ({0})", getString("AdditionalLayerItemProvider_transientLayer")), TRANSIENT_LAYER_STYLE); //$NON-NLS-1$ //$NON-NLS-2$ 
<|del|> 
 public void export(final DRepresentation representation, final Session session, final IPath path, final ExportFormat format, final IProgressMonitor monitor) { 
<|del|> 
 * Remove layers from DDiagram.activatedLayers that are now considered as transient and remove * DDiagramElement.decorations if there descriptions come from a layer that is now considered as transient. 
 * Was related to the dangling edges issue http://bugs.eclipse.org/512752, but is now entirely ignored. 
 if (stack != null) { c = stack.c; carry = stack.carry; stack = stack.prev; 
<|del|> 
 if (artifact instanceof ArtifactToken) { IAtsWorkItem workItem = services.getWorkItemFactory().getWorkItem((ArtifactToken) artifact); if (workItem != null) { workItems.add((T) workItem); } 
 setAtsId(action, topTeamDefinition, changes); 
<|del|> 
<|del|> 
 * Copyright (c) 2007-2017 Cisco Systems, Inc. 
 System.out.println("Editor updating in response to a resource change event"); 
 if (isIncluded(feature) && (!useIsSet() || eObject.eIsSet(feature))) { // The superclass has eGet(feature, false) hard-coded for // efficiency because proxies are irrelevant to emptiness 
<|del|> 
 return this.editingContextAdapter.performModelChange(() -> { String actionExpression = action.getActionExpression(); EAttribute eAttribute = EefPackage.Literals.EEF_TOOLBAR_ACTION__ACTION_EXPRESSION; 
 private ToolBarManager createSectionToolBar(Section groupSection, EList<EEFToolbarAction> actions) { ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT | SWT.HORIZONTAL); ToolBar toolBar = toolBarManager.createControl(groupSection); 
 private ToolBarManager createSectionToolBar(Section groupSection, EList<EEFToolbarAction> actions) { ToolBarManager toolBarManager = new ToolBarManager(SWT.FLAT | SWT.HORIZONTAL); ToolBar toolBar = toolBarManager.createControl(groupSection); 
 td.maxHeight, td.align == TableWrapData.FILL); 
 int clientWidthHint = width; if (clientWidthHint != SWT.DEFAULT && clientWidthHint != MIN_WIDTH) { clientWidthHint -= HMARGIN * 2; 
<|del|> 
 if (shouldCopy(featureType)) { 
 processValidationSet(processedDescription, currentDescription, cache, interpreter, variableManager, overridesProvider); 
 private Hyperlink text; 
 String onClickExpression = Optional.ofNullable(this.description.getOnClickExpression()).orElse(""); //$NON-NLS-1$ if (!onClickExpression.isEmpty()) { 
<|del|> 
 * Set the contributions. 
 public void setContributions(final ArchitectureExtendedProviderDescriptor descriptor) { Assert.isNotNull(descriptor); 
 if (null == provider) { 
 return getDiagram().getName() + ARCHITECTURE_PALETTE_NAME_SUFFIX; 
 return getDiagram().getName() + ARCHITECTURE_PALETTE_NAME_SUFFIX; 
 return getDiagram().getName() + ARCHITECTURE_PALETTE_ID_SUFFIX; 
 public static final String PALETTE_PROVIDERS = "paletteProviders"; //$NON-NLS-1$ 
 * Add providers for palettes based on model declared in architecture. 
 public static final String USE_HTML_RENDERER = "useHtmlRenderer"; //$NON-NLS-1$ public static final String USE_CK_EDITOR = "useCkEditor"; //$NON-NLS-1$ 
 * @deprecated since 3.1. Use {@link org.eclipse.papyrus.infra.ui.preferences.RichtextPreferenceInitializer} instead. * 
 * @deprecated since 3.1. Use {@link org.eclipse.papyrus.infra.ui.preferences.RichtextPreferencePage} instead. 
 if (Platform.getPreferencesService().getBoolean(Activator.PLUGIN_ID, RichtextPreferencePage.USE_CK_EDITOR, false, null)) { 
 * Copyright (c) 2007, 2017 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2007, 2017 THALES GLOBAL SERVICES and others. 
 /** The tool from which this operation is defined. */ protected AbstractToolDescription sourceTool; 
<|del|> 
<|del|> 
 fStartTimeRange = new Text(timeRangeSelectionComposite, SWT.BORDER); 
 fEndTimeRange = new Text(timeRangeSelectionComposite, SWT.BORDER); 
 SelectTracesOperation selectTracesOperation = new SelectTracesOperation(NonNullUtils.checkNotNull(fExperiment), fTraces, new HashMap<String, TmfTraceElement>(), fStartTimeRange, fEndTimeRange); 
 * Checks whether the analysis can be executed or not. * * @return <code>true</code> if analysis can be executed else * <code>false</code> 
 /** * Gets the analysis helper for this analysis. 
 public static final String PLUGIN_ID = "org.eclipse.emf.ecp.workspace.ui.rap"; //$NON-NLS-1$ 
<|del|> 
 SelectTracesOperation selectTracesOperation = new SelectTracesOperation(Objects.requireNonNull(fExperiment), fTraces, new HashMap<String, TmfTraceElement>()); 
 iterator.next(); 
 * Aparna Argade - Bug 508710 * Kunal Tayal - Bug 516098 
 * Gets the index of the item matching the given item.Only the first column is searched. 
 public int indexOf(final String text, final int column) { 
 if (tableItem.getText(column).equals(text)) 
 }); for (TableItem item : selection) { unselect(item); notifySelect(true); } 
 private void unselect(final TableItem item) { syncExec(new VoidResult() { 
 * Selects the given index items. Replaces the current selection. If there * is more than one item to select, the table must have the SWT.MULTI style. 
 if (indices.length > 1) { 
 protected CreateConnectionViewAndElementRequest request; protected EditPart graphicalContainer; 
 if ("CHOICE_BEHAVIOR".equals(preference)) { 
 ISegment maxSegment = data.getElement(SegmentStoreWithRange.LAST); 
 public long getSegmentCount() { 
 span = SpanType.MARK; 
 EMPHASIS, STRONG, ITALIC, BOLD, CITATION, DELETED, INSERTED, SUPERSCRIPT, SUBSCRIPT, SPAN, CODE, MONOSPACE, UNDERLINED, MARK, 
 private final @NonNull List<TmfAnalysisElement> fContainedAnalyses = new ArrayList<>(); 
 for (ITmfTrace t : TmfTraceManager.getTraceSetWithExperiment(trace)) { 
<|del|> 
 @Test 
 // If this is a struct with a typedef then the annotation should go on the typedef instead 
<|del|>
 Object provider; String contributorName = "<unknown"; //$NON-NLS-1$ 
 Object provider; String contributorName = "<unknown"; //$NON-NLS-1$ 
 MessageFormat.format( 
 if (selectedNode instanceof StagingFolderEntry) { viewer.setExpandedState(selectedNode, !viewer.getExpandedState(selectedNode)); } 
 * 209.0 - Alias templates and their instances take up more space than required, bug 516385. 
 } // No comparator, so impossible the easily get last element, // just return the first as it is random anyway 
 } Iterator<? extends @NonNull ISegment> iterator = fIterator; 
 public static final IHTIntervalReader<ISegment> READER = buffer -> new SystemCall(buffer.getLong(), buffer.getLong(), buffer.getString()); 
 private final long fStartTime; private final long fEndTime; private final String fName; 
<|del|> 
<|del|> 
<|del|> 
 return fMinEnd != null ? fMinEnd : getNodeStart(); 
 return "ust_dl:dlopen"; 
 return "ust_dl:dlclose"; 
 * Copyright (c) 2017 cole Polytechnique de Montral 
 // Event names used for memory events 
 // Event names used for function entry/exit 
 // Event names used to track dynamic linking loader 
 // Field names // Note: 'Context' word only kept for implementing the ILttngUstEventLayout // interface 
<|del|> 
 /* Fallback to the Default layout and hope for the best */ 
 if (me.button == PlotArea.BUTTON2 && previousZoomType != ZoomType.PANNING) { 
 if ((me.button != BUTTON1 || zoomType == ZoomType.NONE) && me.button != BUTTON2) 
<|del|>
 String contributorName = "<unknown>"; //$NON-NLS-1$ 
 tableViewer.setItemCount((int) Math.min(Integer.MAX_VALUE, contentProvider.getSegmentCount())); 
<|del|> 
 * analysis element to remove 
 aggregateAnalysisElement = (TmfAggregateAnalysisElement) analysis; 
 public static final int BUTTON2 = 2; 
 List<ICommitMessageProvider> getCommitMessageProviders() { 
 String contributorName = "<unknown>"; //$NON-NLS-1$ 
 public static String OpCopy_DownloadingFile; 
 private @Nullable Long fMinEnd = null; 
 // TODO add "published as" back-trace to IQuerySpecification // TODO rewritten as / rewritten from traceability to PDisjunction? 
 protected AdvancedViatraQueryEngine getOrCreateEngine(EMFScope scope) throws ViatraQueryException{ if (engine == null) { engine = AdvancedViatraQueryEngine.createUnmanagedEngine(scope, getEngineOptions()); } return engine; 
 EMFScope scope, 
<|del|> 
<|del|> 
 if (onClickExpression.isEmpty()) { this.text.setText(labelProvider.getText(value)); } else { this.hyperlink.setText(labelProvider.getText(value)); 
 this.hyperlinkListener = new EEFHyperlinkListener(this, this.hyperlink, this.container, this.controller); hyperlink.addMouseListener(hyperlinkListener); 
 this.hyperlinkListener = new EEFHyperlinkListener(this, this.hyperlink, this.container, this.controller); hyperlink.addMouseListener(hyperlinkListener); 
 if (this.hyperlink != null && !this.hyperlink.isDisposed() && this.hyperlinkListener != null) { this.hyperlink.removeMouseListener(this.hyperlinkListener); 
 if (selectHyperLinkLabel != null && !selectHyperLinkLabel.isDisposed()) { 
 returnStatus = ctx.createFailureStatus(expression, variableType); 
 * Create the filtered list widget used to display the {@link EPackage}s contained in the given 
 * Create the filtered list widget used to display the root elements contained in the given 
 if (item instanceof IDynamicWidgetLayoutListener) { dynamicWidgetLayoutListener = (IDynamicWidgetLayoutListener) item; 
 private static BinaryOperator<Viewpoint> usePluginVersionOverWorkspaceFunction = (vp1, vp2) -> { URI uri = vp1.eResource().getURI(); 
 /** Whether this listener should process proxies. */ 
 /** Whether this listener should process proxies. */ 
 spanTypeToElementNameBuilder.put(SpanType.MARK, "mark"); //$NON-NLS-1$ 
 spanTypeToCssStyles.put(SpanType.MARK, "font-style: italic;"); //$NON-NLS-1$ 
<|del|> 
<|del|> 
 } catch (IOException e) { try { Files.deleteIfExists(file); } catch (IOException e1) { // Ignore } 
 private static final TmfTimestampFormat TIMESTAMP_FORMAT = new TmfTimestampFormat("yyyy-MM-dd HH:mm:ss.SSS SSS SSS"); //$NON-NLS-1$ 
 @NonNull Set<? extends ObjectId> have, @NonNull Set<ObjectId> tags, Set<ObjectId> tagTargets, List<ObjectIdSet> excludeObjects) 
 @NonNull Set<ObjectId> tagTargets, List<ObjectIdSet> excludeObjects) 
<|del|> 
<|del|> 
<|del|> 
 * Neil Mackenzie - initial API and implementation 
 * Neil Mackenzie - initial API and implementation 
 * @author Neil Mackenzie 
 * Neil Mackenzie - initial API and implementation 
 * Neil Mackenzie - initial API and implementation 
 * @author Neil Mackenzie 
 * Neil Mackenzie - initial API and implementation 
 * @author Neil Mackenzie 
 * Neil Mackenzie - initial API and implementation 
 * @author Neil Mackenzie 
 final Iterator<Thread> iter = collection.iterator(); 
 final CommunicationGroup group = this.groupMap.get(receiver); 
 * The helperadvice class used for (Non-Directed) Association. 
 * Dnes Harmath - initial API and implementation 
 final AbstractAxisProvider rowAxisProvider = table.getCurrentRowAxisProvider(); if (rowAxisProvider instanceof IMasterAxisProvider) { addListenerOnTableConfigurationObjects(rowAxisProvider); 
 /** * This method clear the map {@link #map} and {@link #featureVSConfiguration}, then fill them a new time with the new values */ 
 /** * This method clear the map {@link #map} and {@link #featureVSConfiguration}, then fill them a new time with the new values */ 
<|del|> 
<|del|> 
 /** * * @param listenObject * @return */ protected List<Object> getListenFeatureValueFor(final EObject listenObject) { 
 final List<Object> toAdd = new ArrayList<Object>(); final List<Object> toRemove = new ArrayList<Object>(); 
 /** * * @return * the list of the objects used as sources to provide the columns */ 
<|del|> 
 /** * This method allows to update the displayed column after changes in the table configuration */ 
 if (null != conf && null != conf.getFilterRule() && conf.getFilterRule() instanceof IBooleanEObjectExpression) { return ((IBooleanEObjectExpression) conf.getFilterRule()).evaluate((EObject) objectToTest).booleanValue(); 
 String metamodelName = ""; //$NON-NLS-1$ 
 if (null != this.configurationByMetamodelMap) { 
 /** * * Constructor. * */ 
 /** * * Constructor. * */ 
 queue.add(tmfTraceElement); 
 } return false; 
 * @since 3.0 
 SelectTracesOperation operation; 
 setPageComplete(validTimeRange); return validTimeRange; 
<|del|> 
 Logger.error(Activator.PLUGIN_ID, "Cannot instantiate completion provider in Python world.", e); 
 // Double check that everything worked if (fPythonProvider != null) { return fPythonProvider.getProposals(context); } 
 private final Map<Object, WeakReference<IValue>> fVariableResultCache= new HashMap<>(); 
 } container.getOwnedBehaviors().add(ob); op.getMethods().add(ob); 
 private final Map<Long, WeakReference<IValue>> fVariableResultCache= new HashMap<>(); 
<|del|> 
 } else if (prev != 0) { /* update the process name if changed at runtime */ 
 } else if (prev != 0) { /* update the process name if changed at runtime */ 
 * @param mementoSupplier * A supplier that creates a new XYGraphMemento on each call to * the supplier's get method. 
 * <b>Warning:</b> This method is called in the constructor to create a plot * area 
 * @return previousXYGraphMem * previous graph memento 
 public XYGraphMemento getPreviousXYGraphMemento() { 
 public XYGraphMemento getAfterXYGraphMemento() { 
 /** * Returns the previous graph memento * 
 branch = BranchId.valueOf(services.getAttributeResolver().getSoleAttributeValue(configObject, AtsAttributeTypes.BaselineBranchUuid, BranchId.SENTINEL.getId())); 
 "startTime", startTime, //$NON-NLS-1$ "endTime", endTime, //$NON-NLS-1$ 
 if (!(tid instanceof Integer)) { 
 if (eo instanceof Element) { 
 double value = array.get(i); if (value < 0) { return value + offset; 
 * the number of bits in the unsigned data, or zero and has to be * <= 1023 (limit for IEEE doubles). If bits <= 0, the data is * treated as having signed values. 
 * * @since 3.14 
 * * @since 3.14 
 * Workbench toolbar id for edit toolbar group. * * @since 3.111 */ 
 * @since 3.111 
 okButton.setText(MarkerMessages.filtersDialog_applyAndCloseButton); 
 okButton.setText(MarkerMessages.filtersDialog_applyAndCloseButton); 
 } } 
 if (traceModel != null) { 
 ArtifactWrapper toRemove = awc.getArtifacts().get(index); 
 public AttributeTypeId getAttributeType(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * @author Mikael Ferland 
 for (MappingFile mf : TmfTraceManager.getInstance().getTraceContext(fTrace).getMappingFiles()) { 
<|del|> 
<|del|> 
 /** The plugin ID */ public static final String PLUGIN_ID = "org.eclipse.tracecompass.incubator.traceevent.ui"; //$NON-NLS-1$ 
 public void setValue(EObject eObject, EStructuralFeature feature, Object value, int position) { if (feature instanceof EReference) { boolean isContainment = feature instanceof EReference && ((EReference)feature).isContainment(); 
 sendSelectionEvent (SWT.Selection, event, true); 
 * Index of the first mapping file to swap 
<|del|> 
<|del|> 
 * Copyright (c) 2014, 2017 cole Polytechnique de Montral and others. 
 fMappingTable.setInput(fSymbolProvider.getMappingFiles()); 
 if (!fMappingFiles.contains(mf)) { fMappingFiles.add(mf); } 
 private final @NonNull List<@NonNull MappingFile> fMappingFiles = new ArrayList<>(); 
<|del|> 
 * Check if the time range overlap or is completely included in this * SelectTracesOperation's time range. 
 * Check if the time range overlap or is completely included in this * SelectTracesOperation's time range. 
 return traceStartTime.compareTo(fEndTimeRange) <= 0 && traceEndTime.compareTo(fStartTimeRange) >= 0; 
 * Queue of TmfTraceElement to update 
 } /* * Try to get the element bounds from the supplementary files. */ 
 fRemoveFile.setEnabled(selectionCount >= 1); 
<|del|> 
 private ITmfTimestamp fStartTimeRange; private ITmfTimestamp fEndTimeRange; 
 * @param nbPoints * The number of points to display, cannot be negative. 0 means * use native resolution. any positive integer means that number * of points 
 public synchronized void setNbPoints(int nbPoints) { if (nbPoints < 0) { throw new IllegalArgumentException("Number of points cannot be negative"); //$NON-NLS-1$ 
<|del|> 
 final List<LogEntry> events = new CopyOnWriteArrayList<LogEntry>(); 
 events.add(entry); 
<|del|> 
<|del|> 
 * 
@SuppressWarnings("squid:S2160") // 'Subclasses that add fields should override "equals"' not necessary. implementation of AbstractSet is sufficient. 
 return cookie; 
 return cookie; 
 setXsrfCookie(nonNullOrThrow(cookie, () -> new GerritLoginException(), httpClient).get()); 
 return Arrays.stream(httpClient.getState().getCookies()) 
 jdbcService.getClient().runQuery(stmt -> ids.add(ArtifactId.valueOf(stmt.getLong("art_id"))), query, data); 
 public Collection<Artifact> getRelationOrderArtifacts(RelationTypeId relationType, ArtifactTypeId artifactType) { 
 private static Collection<Field> collectNonStaticFieldsWithAnnotation(Class<?> clazz, Class<? extends Annotation> annotation, boolean throwOnError) { 
 } else if (RECTILINEAR.equals(routingStyle)) { 
 * source or target node side from which the edge is connected. 
 * Copyright (c) 2017 THALES GLOBAL SERVICES and others. 
 * @param intersection 
 * source or target node side from which the edge is connected. 
 method.invoke(instance, getInjectionArguments(method.getParameterTypes())); 
 throw translateException("Exception while invoking @InjectBean method {}", method, e); 
 throw translateException("Exception while invoking @PostConstruct method {}", method, e); 
 return collectNonStaticFieldsWithAnnotation(clazz, InjectBean.class, false); 
 @SuppressWarnings("unchecked") Constructor<T> injectCons = (Constructor<T>) BeanInstanceUtil.getInjectionConstructor(beanClass); if (injectCons != null) { 
 if (Routing.RECTILINEAR_LITERAL.equals(getRoutingStyle())) { 
 if (Routing.MANUAL_LITERAL.equals(getRoutingStyle())) { 
 public Routing getRoutingStyle() { 
 if (Routing.RECTILINEAR_LITERAL.equals(routingStyle)) { 
 barSeries.setBarColor(color); barSeries.setBarPadding(0); 
 * A trace on which we are interested to fetch a model * @return A CpuUsageDataProvider instance. If analysis module is not found, it * returns null 
 ICommonXAxisResponse res = verifyParameters(fModule, filter, xvalues, monitor); if (res != null) { return res; 
 /** * Constructor * 
 * Gets a list of selected CPUs * * @return A collection of cpu id 
<|del|> 
 final ITmfStatistics stats = Objects.requireNonNull(statsMod.getStatistics()); 
 if (cookie.isPresent()) { setXsrfCookie(cookie.get()); return; } if (CoreUtil.TEST_MODE) { System.err.println(" Authentication failed: " + httpClient.getState()); //$NON-NLS-1$ } throw new GerritLoginException(); 
 final double[] y = new double[nb]; final long[] yLong = new long[nb]; 
 y[i] = yLong[i]; /* casting from long to double */ 
 * Tells if the current platform corresponds to Oxygen or later. 
 while (currentClass != null) { fields.addAll(Arrays.asList(currentClass.getDeclaredFields())); currentClass = currentClass.getSuperclass(); 
 protected BaseXYQueryFilter createQueryFilterFromInterval(long start, long end, int nb) { return new AnalysisSelectedCpuQueryFilter(start, end, nb, fSelectedThread, fCpus); 
 BranchId branch = BranchId.SENTINEL; 
 public long keycode; 
 public static final byte[] keys_changed = ascii("keys-changed"); 
<|del|> 
 if (keysChangedProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS); OS.g_signal_connect (OS.gdk_keymap_get_default (), OS.keys_changed, keysChangedProc, 0); 
 if (keysChangedProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS); OS.g_signal_connect (OS.gdk_keymap_get_default (), OS.keys_changed, keysChangedProc, 0); 
 * Determine key group of Latin layout. * * @return the most Latin keyboard layout group */ 
 if (keysChangedProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS); OS.g_signal_connect (OS.gdk_keymap_get_default (), OS.keys_changed, keysChangedProc, 0); 
 * Determine key group of Latin layout. * * @return the most Latin keyboard layout group */ 
 /** * Return the most Latin keyboard layout group. * * @noreference This method is not intended to be referenced by clients. */ 
 public ITmfCommonXAxisResponse fetchXY(BaseXYQueryFilter filter, @Nullable IProgressMonitor monitor) { 
 * Copyright (c) 2015, 2017 Obeo and THALES GLOBAL SERVICES. 
 long prevTime = start; 
@Override void drawInteriorWithFrame_inView(long /*int*/ id, long /*int*/ sel, NSRect cellFrame, long /*int*/ viewid) { 
 @Override 
 * Description of a provides info as described in JVMS9 4.7.25. 
 * Description of a provides info as described in JVMS9 4.7.25. 
 if (eventID < 0 || eventID >= fDeclarations.size()) { 
 @NonNull public final String id; @NonNull public final IContentType contentType; @Nullable public final String languageId; 
 * @deprecated Use {@link TmfCommonXLineChartViewer#clearContent()} 
<|del|> 
 if ((style & SWT.SINGLE) != 0) { 
 if ((style & SWT.SINGLE) != 0) { 
 openDiagram(name, ZoomLevel.ZOOM_100); 
 * for snapToGrid (see bugzilla 519305). 
 * Copyright (c) 2017 Obeo. 
 * [516578] tool variables are not displayed in autocompletion. 
 return null; } 
 * Copyright (c) 2010, 2017 THALES GLOBAL SERVICES. 
 /** * Cancels this event handler */ void cancel(); 
 if (HANDLER.equals(elementName)) { 
<|del|> 
 fRoot = new TmfTreeViewerEntry(null); Iterable<@NonNull CounterAnalysis> modules = TmfTraceUtils.getAnalysisModulesOfClass(trace, CounterAnalysis.class); 
 */ @SuppressWarnings("restriction") 
<|del|> 
 return TmfCommonXAxisResponseFactory.createFailedResponse(CommonStatusMessage.UNEXPECTED_QUERY_FILTER); 
 long end = Math.min(filter.getEnd(), ss.getCurrentEndTime()); 
<|del|> 
 private final Set<Integer> fCpus; 
 * The set of CPU 
 * Gets a set of selected CPUs 
<|del|> 
<|del|> 
<|del|> 
 /* Change Zoom and number of points */ 
 /* Change Zoom and number of points */ 
 /* Change Zoom and number of points */ 
<|del|> 
<|del|> 
<|del|> 
 assertTrue("Series should have the same x axis values", Arrays.equals(xRead, xWrite)); 
 assertTrue("Series should have the same x axis values", Arrays.equals(xRead, xWrite)); 
 private static TmfCommonXLineChartViewer getChartViewer(IViewPart viewSite) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { 
 private static TmfCommonXLineChartViewer getChartViewer(IViewPart viewSite) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { 
 SWTBotUtils.delay(1000); 
 map.add(start); 
 /* delete above may have reset the value */ 
 } } PlatformUI.getWorkbench().getDisplay().syncExec(() -> { 
 private static final RGB RED = new RGB(255, 0, 0); private static final RGB BLUE = new RGB(0, 0, 255); 
 private static final RGB RED = new RGB(255, 0, 0); private static final RGB BLUE = new RGB(0, 0, 255); 
 assertEquals(readSeries.getLineColor().getRGB(), BLUE); 
 assertEquals(writeSeries.getLineColor().getRGB(), RED); 
 private final List<String> fLibraries = new ArrayList<>(); 
 * Copyright (c) 2016, 2017 CEA LIST, ALL4TEC and others. 
 * Copyright (c) 2010, 2016, 2017 CEA LIST,ALL4TEC, and others. 
 * Copyright (c) 2017 Obeo. 
<|del|> 
 Optional<Diagram> optionalDiagram = getGMFDiagramFromDRepresentationDescriptor(markedDiagramDescriptor); if (optionalDiagram.isPresent()) { Diagram markerDiagram = optionalDiagram.get(); 
<|del|> 
 private static final Set<@NonNull Integer> ALL_CPUS = Collections.emptySet(); 
 public static String CpuUsageDataProvider_title; /** * CPU usage total series name */ 
 rules[0]= new SingleLineRule("'", "'", new Token(new TextAttribute(new Color(Display.getCurrent(), new RGB(0, 255, 0))))); //$NON-NLS-1$ //$NON-NLS-2$ 
 Map<String, Long> cpuUsageMap = Maps.filterKeys(fModule.getCpuUsageInRange(cpus, prevTime, time), key -> key.startsWith(KernelCpuUsageAnalysis.TOTAL) ); 
 Map<String, Long> cpuUsageMap = Maps.filterKeys(fModule.getCpuUsageInRange(cpus, prevTime, time), key -> key.startsWith(KernelCpuUsageAnalysis.TOTAL) ); 
 long cpuTime = entry.getValue(); totalCpu += cpuTime; 
 private final DateFormat dateInstance; 
 * Method to get the global scope of this engine. 
 public ScriptableObject getScope() { return fScope; 
 private Collection<CounterTreeViewerEntry> fEntries = Collections.emptyList(); 
 MenuItem selectedWidget = (MenuItem) e.widget; Menu menu = selectedWidget.getParent(); MenuItem[] menuItems = menu.getItems(); for (MenuItem menuItem : menuItems) { menuItem.setSelection(false); 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 /** * @author Angel Avila */ 
 * The implementation should update the {@link Sampling} in the {@link TimeGraphEntry} 
 final List<TimeGraphEntry> entryList = fEntryList; if (entryList == null) { return null; } return new ZoomThreadByEntry(entryList, startTime, endTime, resolution); 
 * Class to describe on which time range and resolution the zoomed entry list is * sampled. 
 * * @param zoomStart * the start time of the zoom * @param zoomEnd * the end time of the zoom * @param resolution * the resolution of the zoom 
 * Getter for the zoom sampling of this entry 
 * the sampling parameters used to compute the current zoomed event * list. 
<|del|> 
 if (selectionIsKeyword(expression) && !expression.equals(Keywords.AUTO)) 
 continue; 
 fRoot.addChild(rootBranch); 
/** * Entry of a TMF tree viewer which is associated to a counter. * 
<|del|> 
<|del|> 
 IClassFile cf= ((IClassFileEditorInput)ei).getClassFile(); 
 IClassFile classFile= ((IClassFileEditorInput)input).getClassFile(); 
import org.eclipse.jdt.core.IClassFile; import org.eclipse.jdt.core.IJavaElement; 
 item.setText(Messages.codeActions_emptyMenu); 
 FileOutputStream propStream = new FileOutputStream(release); try { props.store(propStream, null); } finally { propStream.close(); } 
 * Contributors: * Boeing - initial API and implementation *******************************************************************************/ 
 if (xAxis.length <= 1 || monitor.isCanceled()) { 
<|del|> 
 } setXAxis(xAxis); 
 Activator.logError(e.getMessage(), e); 
 // submodules.*.update values from .gitmodules to the config, and // does so using the path defined in .gitmodules as the subsection 
 // submodules.*.update values from .gitmodules to the config, and // does so using the path defined in .gitmodules as the subsection 
 checkLocationAlignOnGrid(firstNewNode, "BorderNode 'new Enum2'"); 
 checkLocationAlignOnGrid(firstNewNode, "BorderNode 'new Enum2'"); 
 checkLocationAlignOnGrid(secondNewNode, "BorderNode 'new Enum3'"); 
<|del|> 
 * Copyright (c) 2010, 2017 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2002, 2017 IBM Corporation and others. 
 * A specific class to override the arrangeCommand to handles edge centering, snapping, ...<BR> 
 assertEquals("Waldo", ((IASTName) target).toString()); 
 clearContent(); updateContent(); 
 * @param node * The decl-specifier or decltype-specifier in which the 'auto' * or 'decltype' occurs. 
 target = testF3(file, offset); assertInstance(target, IASTName.class); 
 // Fast path: try to leverage the SessionLazyCrossReferencer first if present 
 * @since 5.0 
<|del|> 
 try (final FileReader in = new FileReader(shallowFile)) { 
 * Copyright (c) 2007, 2017 THALES GLOBAL SERVICES. 
 public static class SaveRunnable extends RunnableWithResult.Impl<Exception> { 
 /** * Create a callstack symbol for a given element * 
 final List<DocumentEvent> fDocumentEvents= new ArrayList<>(); 
 boolean hasPath = !StringUtils.isEmptyOrNull(uPath); 
 if (StringUtils.isEmptyOrNull(cPath)) { 
 fPoolAttributes.entrySet().forEach(e -> { 
 * Copyright (c) 2015, 2017 Obeo. 
 * Copyright (c) 2016, 2017 Obeo. 
 * Copyright (c) 2008, 2017 THALES GLOBAL SERVICES. 
 * Copyright (c) 2017 Obeo. 
 * Copyright (c) 2016, 2017 Red Hat Inc. and others 
 * Copyright (c) 2017 Red Hat Inc. and others 
 * Copyright (c) 2016, 2017 Red Hat Inc. and others 
 * Copyright (c) 2016, 2017 Red Hat Inc. and others 
 // We retrieve the potential type list of the feature specified in the reference name field. 
 private final List<DocumentEvent> fDocumentEvents= new ArrayList<>(); 
 private boolean fIsFilteredSubset; 
 private boolean fIsFilterPending= false; 
 void handleRepeatedInvocation() { 
<|del|> 
 return fComputedProposals; 
 private static final long serialVersionUID = 1223772305074418261L; 
 syncStatusDecorator = getDiagramSynchronizeStatusFigure(editor); assertEquals("Wrong color for decorator icon.", SynchronizeStatusFigure.BORDER_COLOR_UNSYNC_DIAG, syncStatusDecorator.get().getForegroundColor().getRGB()); 
 * @since 2.4 
 * Copyright (c) 2000, 2017 IBM Corporation and others. 
 * 
/** 
<|del|> 
 @Deprecated 
 long sessionId = Long.parseUnsignedLong(stuff.group(1), 16); 
 return fExecAspect.resolve(event); 
 public final class TidAspect extends LinuxTidAspect { 
 /** * Get the aspect to retrieve the executable name from a uftrace event * * @return The executable name aspect */ 
 IRegion lineInformation = getDocument().getLineInformation(line - 1); int offset = lineInformation.getOffset() + lineInformation.getLength(); 
 private static final List<IMarkerResolution> universalResolutions = new ArrayList<>(); 
 .forEach(resolutions::add); 
 .forEach(resolutions::add); 
 assertEquals(fFooImplRet, aspect.resolve(DUMMY_EVENT)); long orig = fFooImplRet; fFooImplRet = 25; assertEquals(fFooImplRet, aspect.resolve(DUMMY_EVENT)); fFooImplRet = orig; assertEquals(fFooImplRet, aspect.resolve(DUMMY_EVENT)); 
<|del|> 
 this.nameText.setText("newName"); //$NON-NLS-1$ 
 this.setControl(composite); validatePage(); 
 RefactoringProcessor processor = new LSPRenameProcessor(info, offset); 
<|del|> 
 private final IMarkerResolution resolutionInstance; 
 private static final String CONTRIBUTE_URL = "https://www.eclipse.org/contribute/"; 
<|del|> 
 * @since 3.14 
<|del|> 
 return new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Most assuredly NOT a traceevent trace"); //$NON-NLS-1$ 
 if (matches == 0) { return new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Most assuredly NOT a traceevent trace"); //$NON-NLS-1$ 
 if (matches == 0) { return new Status(IStatus.ERROR, Activator.PLUGIN_ID, "Most assuredly NOT a traceevent trace"); //$NON-NLS-1$ 
 * This method return the extension point ID of this provider 
 /** * Create a {@link ITmfTreeDataProvider} for the given trace. If this factory * does not know how to handle the given trace it will return null 
 @Nullable ITmfTreeDataProvider<@NonNull ITmfTreeDataModel> createProvider(@NonNull ITmfTrace trace); 
 this.messageTraceOutput = new MessageTraceOutput(); this.messageTraceLogger = messageTraceLogger; 
 * The {@code MessageTraceDbLogger} interface is a logger interface. 
 * The {@code MessageTraceDbLogger} interface is a logger interface. 
 * are being measured and calculated for the different Message Trace classes. 
 * are being measured and calculated for the different Message Trace classes. 
<|del|> 
 * Sets the line spacing provider of the widget. The line spacing applies for some lines with customized spacing. 
 * Sets the line spacing provider of the widget. The line spacing applies for some lines which customized spacing. 
 * </ul> * @exception IllegalArgumentException <ul> * <li>ERROR_NULL_ARGUMENT when line spacing provider is null</li> * </ul> * @see #setLineSpacingProvider(StyledTextLineSpacingProvider) 
 * Copyright (c) 2017 Angelo ZERR. 
 /* * The StyledText line spacing is different from the new line spacing * 1) update line spacing */ 
 public TimeTrace(String name){ this.name = String.format(this.getClass().getName() + "[%s]", name); 
 referenceService = viewModelContext.getService(ReferenceService.class); 
 * Copyright (c) 2005, 2017 IBM Corporation and others. All rights reserved. This 
 public static String WizardPreferencesImportRestartDialog_restart; 
 public static String WizardPreferencesImportRestartDialog_restart; 
 * Copyright (c) 2000, 2017 IBM Corporation and others. 
 private static final Logger LOG = LoggerFactory.getLogger(FS.class); 
 if (spacing != null && spacing.intValue() >= 0) { 
 // appropriate entries. At this point we simply empty the stats store for elements where // instance indexing is introduced only have to consider the target indexing level. See bug 
 public static Button getWizardDialogButton(WizardDialog dialog, int buttonId) { 
 File downloadedTrace = downloadedTraceList.get(0); Pair<IFileSystemObject, FileSystemObjectImportStructureProvider> rootObjectAndProvider = ArchiveUtil.getRootObjectAndProvider(downloadedTrace, null); 
 archiveFolderName = downloadedTrace.getName(); 
<|del|> 
<|del|> 
 descriptor.setClasspathAttribute(IClasspathManager.TEST_ATTRIBUTE, isTest ? "true" : null); 
 descriptor.setClasspathAttribute(IClasspathManager.TEST_ATTRIBUTE, isTest ? "true" : null); 
<|del|> 
 log.error("unexpected entryKind " + entry.getEntryKind() + " for entry " + entry.getPath()); //$NON-NLS-1$ //$NON-NLS-2$ 
 private static void waitForShadowProjectUpdated(String parentProjectName) { 
 * Copyright (c) 2017, 2017 Conrad Groth and others. 
<|del|> 
 assertTrue(e.getMessage().contains("14")); // delta size 
 Activator.getDefault().logError("Error adding tracing nature to project " + project.getName(), e); //$NON-NLS-1$ 
<|del|> 
 * Image saving interface. It is to be implemented by view classes that want to * allow their content to be exported as an image. The default implementation * exports the canvas as a PNG image. 
 * Save the image, This default implementation save the canvas as a PNG image. 
 * Returns the primary control associated with this view. 
 protected IAction createSaveAction() { // FIXME export tree viewer or legend. 
 Map<IMarker, MarkerEntry> entryMap = markerToEntryMap; if (entryMap == null) { entryMap = new HashMap<>(); 
<|del|> 
 * @param fsRef cast=(struct FSRef*) 
 * @param object The domain object previously injected with the context * @param context The context previously injected into the object * @throws InjectionException if an exception occurred while performing this operation 
 * @param object The domain object previously injected with the context * @param context The context previously injected into the object * @throws InjectionException if an exception occurred while performing this operation 
 parent.requestLayout(); 
 // Add external editors from OS for (IEditorDescriptor desc : getSortedEditorsFromOS()) { mapIDtoEditor.put(desc.getId(), desc); } 
 private static String pathToString(File file) { final String path = file.getPath(); return SystemReader.getInstance().isWindows() ? path.replace('\\', '/') : path; 
 bos.write(ConfigTest.pathToString(includedFile).getBytes()); 
 return null; } 
 } catch (ModelException x) { 
 * 
 * @since 3.3 
 * @since 3.3 
 * Copyright (c) 2007, 2017 THALES GLOBAL SERVICES. 
<|del|> 
 * A class aggregating all the queries (read-only!) having a * DiagramElementMapping as a starting point. 
 return UNKNOWN_TID; 
 DRepresentation representation = getRepresentation("new diagExportAsImage"); 
 DRepresentation representation = getRepresentation("NoScaleIfLarger"); 
 * Tests the export of diagrams as image with SVGZ format and auto-scale activated when an up scale is done. 
 StyleUtils.initBooleanNamedStyle(editingDomain, table, NamedStyleConstants.AUTO_RESIZE_CELL_HEIGHT, NamedStyleConstants.ENABLE_AUTO_RESIZE_CELL_HEIGHT); 
 // If wrap text is currently enabled if (wrapTextValue.isBooleanValue()) { 
 StyleUtils.initBooleanNamedStyle(editingDomain, table, NamedStyleConstants.WRAP_TEXT, NamedStyleConstants.ENABLE_WRAP_TEXT); 
 case IMarker.SEVERITY_ERROR: return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJS_ERROR_TSK); case IMarker.SEVERITY_WARNING: return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJS_WARN_TSK); 
 while (!complete && !monitor.isCanceled()) { 
 if (monitor.isCanceled()) { return; } 
 private boolean syncStateSystem(long time, StateSystemEntry stateSystemEntry) { ITmfStateSystem ss = stateSystemEntry.fSs; if (time < ss.getStartTime() || ss.getCurrentEndTime() < time) { return false; } 
 * Aparna Argade - Bug 527571 
 !((Text)event.widget).getText().equals(((Text)event.widget).getMessage()); 
 /** Number of colors used for State system time events */ public static final int NUM_COLORS = 18; 
 /** Number of colors used for State system time events */ public static final int NUM_COLORS = 18; 
 private static final StateItem[] STATE_TABLE = new StateItem[NUM_COLORS]; 
 return new ContentBlock(type, ":: ", "", 0, 1); //$NON-NLS-1$//$NON-NLS-2$ 
 } } else { stateSystemEntry.setFullStates(null); 
 * Currently used: {@link #INHERIT_ACCESSIBILITY}, {@link #TOGGLE_ACTION}, {@link #SEPARATOR} 
 * Currently used: {@link #TOUCHED}, {@link #MASTER_REQUIRED} 
 IEclipseContext trackedContext = EclipseContextFactory.create(); trackedContext.set("a", "abc"); trackedContext.set("aConstructor", "abcConstructor"); trackedContext.set("b", "bbc"); 
 * Indicate if the resulting document builder should support HTML img tags or strip them out. The default is true. 
 public void emitImageWithoutImageSupport() { 
<|del|> 
 protected Optional<Integer> getPixelGridSize() { 
 /* package */ int computePreferredWidthBasedOnPixelGridSize(final double prefWidth, int pixelGridSize) { return Double.class.cast(Math.ceil(prefWidth / pixelGridSize)).intValue() * pixelGridSize; 
 final int prefWidth = entry.getValue(); 
 /** * Compute all name with all authorized namespace computation in UML */ 
 /** The color used to draw the range indicator during the last paint action. */ private Color fLastRangeIndicatorColor; 
 */ private Image createImage(Display display, Point size, Color rangeIndicatorColor) { 
<|del|> 
 return PHPModelUtils.getFullName(localClassName, sourceModule, argument.sourceStart()); 
 public void testCategorizationElementTreeRendererReadOnlyBehavior_ViewIsReadOnly() throws ECPRendererException { 
<|del|> 
<|del|> 
 Logger.logException(e); 
 * Copyright (c) 2015, 2017 Obeo. 
<|del|> 
<|del|> 
 * Initialize the context by copying new resources and waiting all build process. 
 private IClasspathAttribute[] cleanupClasspathAttributes(IClasspathAttribute[] extras) { if(Arrays.stream(extras).allMatch(Objects::nonNull)) { 
<|del|> 
<|del|> 
 // Expected exception, do nothing. 
<|del|> 
 markerToEntryMap.put(nextMarker, markerEntry); 
 private static final Set<TmfCommonProjectElement> fOpening = Collections.synchronizedSet(new HashSet<>()); 
 if (!fOpening.add(traceElement)) { /* element is already opening */ return; 
 deleteTrace(traceElement, childrenSubMonitor); 
 PlatformUI.getWorkbench().getProgressService().run(true, true, new TmfWorkspaceModifyOperation() { @Override protected void execute(IProgressMonitor monitor) throws CoreException, InvocationTargetException, InterruptedException { for (TmfTraceElement dir : directories) { 
<|del|> 
<|del|> 
 final Set<T> elementsToChooseFrom, boolean allowMultiple, T... initialSelection) { 
 void onCreate(EObject eObject, EReference eReference, EObject newInstance); 
 final Set<EObject> selectedInstances = SelectModelElementWizardFactory .showSelectInstanceDialog(candidates, eReference.isMany()); 
 final DefaultNavigationService dns = new DefaultNavigationService(); dns.instantiate(ViewModelContext.class.cast(emfFormsViewContext)); return dns; 
 final DefaultNavigationService dns = new DefaultNavigationService(); dns.instantiate(ViewModelContext.class.cast(emfFormsViewContext)); return dns; 
 reportService.report(new AbstractReport(message, args)); 
 * @since 1.8 
 setupSorting(comparator, regularColumnsStartIndex, tableViewerComposite); 
<|del|> 
 protected Set<Template> collectAvailableTemplates(EObject eObject, EReference eReference) { 
@Component(service = { TemplateProvider.class, TemplateCreator.class, TransientRuntimeTemplateProvider.class }) 
 private final CreateCallback creationCallback = mock(CreateCallback.class); 
 contentService = (INavigatorContentService) ref.get(); if (contentService == null) { 
 return new Status(IStatus.ERROR, PlatformUI.PLUGIN_ID, "Content from directory '" + srcFolder.getAbsolutePath() + "' can not be listed."); //$NON-NLS-1$ //$NON-NLS-2$ 
 throw new IOException("Content from directory '" + src.getAbsolutePath() + "' can not be listed."); //$NON-NLS-1$ //$NON-NLS-2$ 
 if (part == AbstractTimeGraphView.this) { 
 private String fRegex; private Point fLocation; 
 private Predicate<String> fPredicate; 
<|del|> 
<|del|> 
 * Copyright (c) 2000, 2018 IBM Corporation and others. 
 // The calculated rectangle is a little bit too small. Italic fonts would show some small part in the default color. 
 if (iterableType == null) return null; 
 boolean variableTypeInferenceError = false; boolean isTypeNameVar = isTypeNameVar(scope); 
 this.binding = new LocalVariableBinding(this, variableType != null ? variableType : scope.getJavaLangObject(), this.modifiers, false) { 
 variableType = patchType(this.initialization.resolvedType); 
 /* * Checks the initializer for simple errors, and reports an error as needed. If error is found, * returns a reasonable match for further type checking. */ private TypeBinding checkInferredLocalVariableInitializer(BlockScope scope) { 
 throw new IOException( "Content from directory '" + oldModDir.getAbsolutePath() + "' can not be listed."); //$NON-NLS-1$ //$NON-NLS-2$ 
 } catch (IOException e1) { /* ignore */ 
 protected void update(IAction action, ISelection s) { super.update(action, s); 
 SWTBotUtils.delay(1000); fBot.viewByTitle(PROJECT_EXPLORER_VIEW_NAME).setFocus(); 
 private static void createCopy(SWTBotTreeItem traceItem, boolean copyAsLink) { SWTBotView viewBot = fBot.viewByTitle("Project Explorer"); viewBot.setFocus(); 
 viewBot.show(); 
<|del|> 
 boolean allCommon = Iterables.all(providers, p -> p instanceof ITmfCommonXAxisModel); 
 if (!(model instanceof ITmfCommonXAxisModel)) { 
 SWTBotUtils.delay(1000); fBot.viewByTitle(PROJECT_EXPLORER_VIEW_NAME).setFocus(); 
 return false; 
 * Copyright (c) 2018 Obeo 
 * Copyright (c) 2018 Obeo 
<|del|> 
 private static final String BASIC_SERVICE_JAVA2 = "BasicService2.java"; 
<|del|> 
 * Forgets all stored plans in this result provider. If no plans are stored, nothing happens. 
 matches = Iterables.any(values, predicate::test); 
 matches = Iterables.any(values, predicate::test); 
 //LinkedHashSet is used to maintain a deterministic ordering of transitions private final Set<Transition> transitions = new LinkedHashSet<>(); 
 return String.format("%s{transitions=%s}", getClass().getName(), 
 if (sourceNameFieldText.equals(currentSourceName)) { 
 setSourceName(sourceNameFieldText); 
 void addVendor(Vendor<? extends T> vendor); 
 * Marks a method within a {@link BazaarContextFunction}. This method can request arbitrary parameters from the 
 * 
 private final List<Vendor<? extends T>> vendors = new ArrayList<Vendor<? extends T>>(); 
 private final List<Vendor<? extends T>> vendors = new ArrayList<Vendor<? extends T>>(); 
 private final List<Vendor<? extends T>> vendors = new ArrayList<Vendor<? extends T>>(); 
 public T createProduct(Vendor<? extends T> vendor) { 
 @SuppressWarnings("unchecked") public T createProduct(Vendor<? extends T> vendor, IEclipseContext context) { return (T) ContextInjectionFactory.invoke(vendor, Create.class, context); 
 return result; 
 return result; 
 * @see org.eclipse.emfforms.bazaar.Bazaar#createProduct(org.eclipse.emfforms.bazaar.BazaarContext) 
 public List<T> createProducts(BazaarContext bazaarContext) { 
 } 
<|del|> 
 status = XmlUtils.addXmlFile(file); } else { XmlUtils.updateXmlFile(file); 
 * The absolute xml file path 
 private static final @NonNull Multimap<String, XmlOutputElement> XML_OUTPUT_ELEMENTS = HashMultimap.create(); private static Multimap<String, XmlOutputElement> fCachedOutputElement; 
<|del|> 
 private static void preloadXmlAnalysesOutput(File xmlFile) { 
 public static Multimap<String, XmlOutputElement> getXmlOutputElements() { return fCachedOutputElement; 
<|del|> 
 int callStackQuark = ss.optQuarkRelative(threadQuark, callStackPath); if (callStackQuark == ITmfStateSystem.INVALID_ATTRIBUTE) { continue; } 
 } catch (StateSystemDisposedException e) { 
 ITimeGraphEntryModel model = entry.getModel(); ITimeGraphState function = fFunctions.get(model.getId()); 
 Set<String> structurallyChangedTypes = null; 
 Set<@NonNull Integer> cpus = cpuFilter.getCpu(); Map<String, Long> cpuUsageMap = fModule.getCpuUsageInRange(cpus, start, end); 
<|del|>
 // we have to replace old reconciler 
 fReconciler = phpConfiguration.replaceReconciler(fTextEditor, this); 
 boolean allCommon = Iterables.all(providers, ITmfCommonXAxisModel.class::isInstance); 
 URL url = FileLocator.find(FrameworkUtil.getBundle(ImageResourceManager.class), new Path(path), null); 
 * Don't inspect files that are larger than this threshold to avoid * excessive reading. No pointer file should be larger than this. 
 private static final String EMPTY = ""; //$NON-NLS-1$ 
 break; } 
 break; } 
 // if no objects to be pushed have been identified, return early 
 // received an object we didn't request 
 // This could be done better (more precise logic), but according // to https://github.com/git-lfs/git-lfs/issues/1759 git-lfs // generally only supports 'origin' in an integrated workflow. 
<|del|> 
 try { address = Long.parseLong(name, 16); } catch (NumberFormatException e) { // leave name as null } 
 appearance = YAppearance.Type.SCATTER.equals(seriesType) ? createScatter(serieName, seriesType, width) : createAppearance(serieName, seriesType, width); 
<|del|> 
 public void build(String projectName, @ScriptParameter(defaultValue = "6") int buildKind) throws CoreException { 
 return Boolean.getBoolean("eclipse.pde.launch"); //$NON-NLS-1$ 
<|del|>
<|del|> 
 public ArchiveContentEncodingDetector(String extension) { Assert.isNotNull(extension, "Extension can not be null"); 
 /** * check if file extension matches the one(s) set for this detector */ 
 String charset = new ArchiveContentEncodingDetector(".java").getCharset(file); if(charset != null) { Charset defaultCharset = Charset.defaultCharset(); if(!charset.equals(defaultCharset.name())) { desc.setClasspathAttribute(IClasspathAttribute.SOURCE_ATTACHMENT_ENCODING, charset); } 
 private void configureSourceEncoding(IClasspathEntryDescriptor desc, IPath srcPath) { 
 if (writeBitmaps != null) { return writeBitmaps.getObjectSet(); } ObjectIdOwnerMap<ObjectIdOwnerMap.Entry> r = new ObjectIdOwnerMap<>(); 
 * @since 4.11 
 * @since 4.11 
 ObjectReader reader = up.getRevWalk().getObjectReader(); try (RevWalk walk = new RevWalk(reader)) { AsyncRevObjectQueue q = walk.parseAny(notAdvertisedWants, true); 
 * Copyright (c) 2013, 2018 Ericsson 
 * Tooltip for the expand button 
 * Tooltip for the collapse button 
 Assert.isLegal(extension != null && !extension.isEmpty() && !extension.endsWith("/"), "extension can't be empty or /"); 
 * Detects the encoding of a jar/zip archive's content 
 /** * Creates a new encoding detector * * @see CharsetDetector * @param extension file extension */ 
 * Detects the encoding of the content of the given archive. The archive must be a jar or a zip file. The first file * matching this detector's extension is analyzed. * * @param file jar or a zip file */ 
 * @author Guillaume Champagne * @author Alexis-Maurer Fortin * @author Hugo Genesse * @author Pierre-Yves Lajoie * @author Eva Terriault 
 IStatus status = ftraceTrace.validate(null, "res/trace-android-sched"); 
 * Activator * * @author Guillaume Champagne * @author Alexis-Maurer Fortin * @author Hugo Genesse * @author Pierre-Yves Lajoie * @author Eva Terriault 
 private static Iterable<@NonNull ITmfEventAspect<?>> sfAspects; 
 private static class FtraceEventNameAspect implements ITmfEventAspect<String> { 
<|del|> 
 private static final Map<String, TmfEventType> TYPES = new HashMap<>(); 
 * Ftrace field class 
import java.util.function.Predicate; import java.util.stream.Collectors; import org.eclipse.core.internal.resources.ComputeProjectOrder.Digraph.Edge; 
 public static class Digraph<T> { 
 public static <T> VertexOrder<T> computeVertexOrder(final Digraph<T> g1, Class<T> clazz) { Assert.isNotNull(g1); 
 if ((c == '#' && getLastChar() == '&') || (c == '{' || c == '\\' || c == '[' || c == ']')) { 
 assertParagraphWithEntityReference("&#unknown;\n\n", "#unknown"); 
 if (elementToRename instanceof NamedElement && null != ((NamedElement) elementToRename).getName() && false == ((NamedElement) elementToRename).getName().isEmpty()) { 
 final StringBuilder builder = new StringBuilder(base); builder.append(separator); builder.append(contents.size()); //builder.append(1);// most of the time, the element to initialized is already in a list, so the +1 is not required return builder.toString(); 
 public final static String COPY_CLASS1_NAME = "CopyOf_Class1_1"; //$NON-NLS-1$; 
 for (Map.Entry<Long, Integer> entry : entries.entrySet()) { 
 * Copyright (c) 2008, 2018 THALES GLOBAL SERVICES. 
 result = result && this.parent.equals(rdiObj.parent); 
 result = result && this.parent.equals(rdiObj.parent); 
 * Copyright (c) 2009, 2018 THALES GLOBAL SERVICES and others. 
 result = result && this.parent.equals(objItem.parent); 
 result = result && this.parent.equals(objItem.parent); 
<|del|> 
 * Copyright (c) 2016, 2018 THALES GLOBAL SERVICES. 
 if (distanceBetweenPartAndDecoratorOnXaxis < MAX_DISTANCE_X && distanceBetweenPartAndDecoratorOnYaxis < MAX_DISTANCE_Y) { 
 * Copyright (c) 2010, 2018 THALES GLOBAL SERVICES. 
 * If the tick is {@link SymbolStyle#NONE}, no tick shall be displayed. 
 } else if (fs.isDirectory(f)) { 
 new LegendEntry(running, stateItems[0]); /* * Create a blocked group */ 
 * Copyright (c) 2015, 2018 cole Polytechnique de Montral and others 
 * Copyright (c) 2015, 2018 cole Polytechnique de Montral 
 private static final String LEGEND_NAME = "States Transition Visualizer"; 
 public void disconnectContentType(@NonNull IContentType contentType) { 
 public boolean enable(IContentType contentType); 
 new FtraceCpuAspect(), TmfBaseAspects.getEventTypeAspect(), TmfBaseAspects.getContentsAspect(), new FtracePidAspect()); 
 bw.write(" <metadata_license>" + license + "</metadata_license>\n"); bw.write(" <project_license>" + license + "</project_license>\n"); 
<|del|> 
 StringBuilder typeBuffer = new StringBuilder(); 
 //If an exception occured while trying to create the file, it means that it is not writable 
<|del|> 
 return x; 
 .toJson(LfsConnectionFactory 
 if (responseCode != HttpConnection.HTTP_OK) { throw new IOException(MessageFormat.format( LfsText.get().serverFailure, lfsServerConn.getURL(), Integer.valueOf(responseCode))); 
<|del|> 
 problem.getSourceEnd() - problem.getSourceStart() + 1).getCoveringNode(); 
 * Tries to cancel the future. See {@link CancelMode} for semantics. 
<|del|> 
 discardChanges(repository, paths, progress.newChild(1)); 
<|del|> 
 IProgressMonitor progress) 
 new EclipseGitProgressTransformer(progress)); 
 * Checks the system configuration. 
 UIText.ConfigurationChecker_installLfsDontAsk }, 0); 
 * A {@link WorkspaceModifyOperation} that will execute the Export as images action. 
 * selects the first occurrence of the given field 
 * Selects the given field at the given start/end coordinates 
 * example snippet: DateTime with localization support. 
 */ @FunctionalInterface 
 * Time in ms spent in the negotiation phase. For non-bidirectional * transports (e.g., HTTP), this is only for the final request that * sends back the pack file. 
 walk.getFilterCommand( Constants.ATTR_FILTER_TYPE_SMUDGE)); 
 /* 
 if (isValidRefExpression(contents)) { 
 if (id != null) { result.add(new RefContentProposal(localDb, contents, id, false)); } 
 if (id != null) { result.add(new RefContentProposal(localDb, contents, id, false)); } 
import static org.eclipse.jgit.util.HttpSupport.HDR_CONTENT_ENCODING; import static org.eclipse.jgit.util.HttpSupport.HDR_CONTENT_LENGTH; import static org.eclipse.jgit.util.HttpSupport.HDR_CONTENT_TYPE; import static org.eclipse.jgit.util.HttpSupport.HDR_WWW_AUTHENTICATE; 
 assertStartsWithIgnoreCase(info.getResponseHeader(HDR_WWW_AUTHENTICATE), "basic realm="); 
 IDocumentPartitioner partitioner= entry.getValue(); 
 private long fLastQueriedTime = 0; 
 this (ss, quark, initialTime, Long.MAX_VALUE, 1); 
 return (fResolution == 1 ? endTime + 1 : ((endTime - fLastQueriedTime) / fResolution + 1) * fResolution); 
 * Consults TipManager to determine the Tip's read status. 
 * Instructs the TipManager to mark this tip as read. 
<|del|> 
 * Return an URL with the primary goal to be rendered by the tip manager. 
 binder = binder.through(new WWWAuthenticateFilter(authMethod, realmName)); 
 * Copyright (C) 2018, Hossein Pursultani. 
 private final String realmName; 
 currentBlock = nestedBlocks.pop(); 
<|del|> 
 // To understand why we reparent, see implementation note about bug 454936 at the start of TabFolder. 
<|del|>
 * @return the list of interfaces provided by a port or sub-port. Takes conjugation of the parent port into account 
 * @return the list of interfaces required by a port or sub-port. Takes conjugation of the parent port into account 
 // return all provided interfaces 
 // return all required interfaces 
 public static void disableLanguageServerContentType( @NonNull ContentTypeToLanguageServerDefinition contentTypeToLSDefinition) { 
 public static void enableLanguageServerContentType( @NonNull ContentTypeToLanguageServerDefinition contentTypeToLSDefinition, 
 firePropertyChanged(aEnd, IArtifactComponentChangeListener.Prop.NAVIGABLE); 
 private static @NonNull String computeEntryName(Type type, int id) { 
@RunWith(JUnit4.class) public class ComputeProjectOrderTest { 
 excludeRemoteRefs(walk); 
 while (walk.next() != null) { 
<|del|> 
 findLfsPointers(toPush, walk); 
 private static void findLfsPointers(Set<LfsPointer> toPush, ObjectWalk walk) 
 private String remote() { String remoteName = getRemoteName() == null ? Constants.DEFAULT_REMOTE_NAME : getRemoteName(); return Constants.R_REMOTES + remoteName; } 
 if (contentUrl.getProtocol().equals(SCHEME_HTTPS) 
 StringBuilder msg = new StringBuilder("No event fired:").append(unfiredIds); 
 * This test checks that nobody adds an unexpected dependency on the plugin org.eclipse.papyrus.emf 
 Assert.assertTrue(NLS.bind("The dependency {0} is not registered with compatible version range", current.getKey()), bundleToCheck.getRegisteredDependencyVersion(current.getKey()).inIncludedIn(current.getValue())); //$NON-NLS-1$ 
 while (fProject.getPathVariableManager().isDefined(buf.toString())) { 
 * helper function for tests that are compatible with earlier Javadoc formatting rules 
 ITimeGraphDataProvider<? extends TimeGraphEntryModel> dataProvider = BaseDataProviderTimeGraphView.getProvider(entry); 
 * Copyright (c) 2007, 2018 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2002, 2006, 2008 IBM Corporation and others. 
<|del|> 
 protected void disposeChildren(List<? extends IWidget> widgetsToDispose) { widgetsToDispose.remove(getForm()); // form is closed in disposeActionInternal super.disposeChildren(widgetsToDispose); } 
 protected void disposeChildren(List<? extends IWidget> widgetsToDispose) { widgetsToDispose.remove(getForm()); // form is closed in disposeActionInternal super.disposeChildren(widgetsToDispose); } 
 protected class P_ChildNodesVisitor extends DepthFirstTreeVisitor<ITreeNode> { 
<|del|> 
 container.getEClassifiers().add(firstEClass); // Behind is code to simulate a service throwing an // OperationCanceledException. So the pseudo dead code is expected. 
 * Obeo - initial API and implementation *******************************************************************************/ 
<|del|> 
 private ITimeGraphState createTimeGraphState(ITmfStateInterval interval, ITmfStateSystem ss) throws StateSystemDisposedException { 
 return new TimeGraphState(startTime, duration, s); 
<|del|> 
 /** Entries for Current Thread */ 
 if ((!parent.equals(Attributes.CPUS) || cpuNumber == null) && !attributeName.equals(Attributes.CURRENT_THREAD)) { 
 if ((!parent.equals(Attributes.CPUS) || cpuNumber == null) && !attributeName.equals(Attributes.CURRENT_THREAD)) { 
 if ((!parent.equals(Attributes.CPUS) || cpuNumber == null) && !attributeName.equals(Attributes.CURRENT_THREAD)) { 
 StateItem state = getEventState((TimeEvent) event); 
 /** Reset the log back to its original empty state. */ void clear() { try { for (;;) { try { active.acquire(MAX); break; } catch (InterruptedException e) { continue; } } 
<|del|> 
 // if we have a key for the given template we surely have at least one template 
 // otherwise we have to analyze all keys and see if our type is a super type (of at least one) 
 continue; 
 for (Map.Entry<Long, Integer> entry : entries.entrySet()) { 
 Session openedSession = localSession.getOpenedSession(); assertNotNull("The session should be opened", openedSession); assertTrue("The session should be opened", openedSession.isOpen()); 
 Session openedSession = localSession.getOpenedSession(); assertNotNull("The session should be opened", openedSession); assertTrue("The session should be opened", openedSession.isOpen()); 
 private void addViewModels(Set<String> packages) { packages.add("http://org/eclipse/emf/ecp/view/model/170"); //$NON-NLS-1$ 
 private final List<String> registeredEcores = new LinkedList<String>(); 
 } } catch (final ViewModelMigrationException ex) { throw new InvocationTargetException(ex); 
 public static VView loadView(IFile file, Collection<String> registeredEcores) throws IOException { 
 final URI fileURI = URI.createFileURI(path); final Resource resource = resourceSet.getResource(fileURI, true); if (resource != null) { return (VView) resource.getContents().get(0); 
 public void register(String ecorePath, VView viewModel) { 
 final List<String> ecorePaths = viewModel.getEcorePaths(); for (final String ecorePath : ecorePaths) { EcoreHelper.unregisterEcore(ecorePath); 
 void register(String ecorePath, VView viewModel); 
 * 
 editingDomain = AdapterFactoryEditingDomain.getEditingDomainFor(object); new ExtendedLoadResourceDialog(Display.getDefault().getActiveShell(), editingDomain).open(); 
 * * @generated NOT 
 final InternalEObject oldDomainModelEFeature = (InternalEObject) domainModelEFeature; 
 if (coreType) { 
 final Registry packageRegistry = EPackage.Registry.INSTANCE; // final Registry packageRegistry = resourceSet.getPackageRegistry(); 
 static final private Comparator<ITmfStateInterval> CACHE_COMPARATOR = (a, b) -> { 
 final private TreeMultimap<Integer, ITmfStateInterval> fExecNamesCache = TreeMultimap.create(Integer::compare, CACHE_COMPARATOR); 
 String threadEntryName = NLS.bind(Messages.ThreadEntry, id); if (threadEntryName != null) { return threadEntryName; } 
 private Repository remoteDb; 
 private static final Comparator<ITmfStateInterval> CACHE_COMPARATOR = (a, b) -> { 
 private final HashMap<Integer, Type> fEntryModelTypes = new HashMap<>(); 
<|del|> 
 //Optional#get is correct here as long as trace and notation models are only modified by Viewers transformation 
<|del|> 
 * Copyright (c) 2011-2018 EclipseSource Muenchen GmbH and others. 
 Position[] withDigits = { new Position(0, 4) }; // " - " 
 compareStyleRanges(withDigits, getStyleRanges(".3*3", "test.3xx3"), "test.3xx3", ""); 
 compareStyleRanges(withDigits, getStyleRanges(".3*3", "test.3xx3"), "test.3xx3", ""); 
 patternMatcher.setPattern("*" + pattern); //$NON-NLS-1$ 
<|del|> 
 * @since 1.16 * * <!-- end-user-doc --> * * @generated 
<|del|> 
 * @since 1.16 * <!-- end-user-doc --> * * @generated 
<|del|> 
 IResource resource = createAndVerifyResource(TEST_FILE_NAME, true); 
 IResource resource = createAndVerifyResource(TEST_FILE_NAME, true); 
 private static final boolean IS_WINDOWS = System.getProperty("os.name").contains("Windows"); //$NON-NLS-1$ //$NON-NLS-2$ 
 try { String targetPathString = targetLocation.toOSString(); Path linkPath = Paths.get(link.getProject().getLocation().append(link.getProjectRelativePath()).toOSString()); Path targetPath = Paths.get(targetPathString); 
<|del|> 
 public static void deleteResource(@Nullable IResource resource, @Nullable IProgressMonitor monitor) throws CoreException { SubMonitor subMon = SubMonitor.convert(monitor, 1); 
 if (isFileSystemSymbolicLink(resource) && !resource.exists() && ((resource instanceof IFile) || (resource instanceof IFolder))) { 
 * the resource in the workspace 
 * symbolic link) regardless of link is broken or not. 
 * Returns the location path of the given resource. If the resource is file * system symbolic link then it will return the link target location. 
 * Returns the location URI of the given resource. If the resource is file * system symbolic link then it will return the link target location. 
 Path newLinkedFile = Paths.get(resource.getWorkspace().getRoot().getLocation().append(destinationPath).toOSString()); 
 for (Map.Entry<QualifiedName, String> entry : persistentProperties.entrySet()) { 
 private static boolean isHandleDeleted(IResource resource, IProject parentProject) { 
 URI uri = ResourceUtil.getLocationURI(getElementUnderTraceFolder().getResource()); 
 * 
 * 
 * * @since 1.16 * <!-- end-user-doc --> 
 final List<Command> ecorePathCommands = new ArrayList<Command>(); ecorePathCommands.add(command); 
 putCurrentThreadTooltip(ss, retMap, full, status); 
 if (isType(entry, Type.CPU)) { return (int) (itemHeight * 0.65); 
<|del|>
 if (paths == null || paths.isEmpty()) { 
 static String itemTypeProperty() { return ".type"; //$NON-NLS-1$ 
 * Copyright (c) 2007, 2018 THALES GLOBAL SERVICES and others. 
<|del|> 
 @NonNull private IResource createAndVerifyLink(IPath path, String name, boolean isFile, boolean isSymLink) throws IOException, CoreException { 
 private static final boolean IS_WINDOWS = System.getProperty("os.name").contains("Windows"); //$NON-NLS-1$ //$NON-NLS-2$ 
 * the progress monitor or null. 
<|del|> 
 || resource.getWorkspace().getRoot().getLocation().isPrefixOf(path)) && // link within the workspace !path.toFile().exists(); 
 || resource.getWorkspace().getRoot().getLocation().isPrefixOf(path)) && // link within the workspace !path.toFile().exists(); 
 private final HashMap<Integer, Type> fEntryModelTypes = new HashMap<>(); 
 if (currentThreadQuark != ITmfStateSystem.INVALID_ATTRIBUTE) { ITmfStateInterval result = ss.querySingleState(interval.getEndTime(), currentThreadQuark); eventList.add(new TimeGraphState(startTime, duration, s, String.valueOf(result.getValue()))); } 
 if (currentThreadQuark != ITmfStateSystem.INVALID_ATTRIBUTE) { ITmfStateInterval result = ss.querySingleState(interval.getEndTime(), currentThreadQuark); eventList.add(new TimeGraphState(startTime, duration, s, String.valueOf(result.getValue()))); } 
 Map<String, String> retMap, List<ITmfStateInterval> full, int tid) { String currentThread = String.valueOf(tid); 
 Map<String, String> retMap, List<ITmfStateInterval> full, int tid) { String currentThread = String.valueOf(tid); 
 private static final int NUM_COLORS = 25; private static final float BRIGHTNESS = 0.8f; private static final float SATURATION = 0.8f; 
 fColors.add(new RGB((int) (360.0 / NUM_COLORS * i), SATURATION, BRIGHTNESS)); 
 if (isType(event.getEntry(), Type.CURRENT_THREAD) && event instanceof TimeEvent) { 
 trimmableTrace.trim(tr, tracePath, mon.split(1)); SubMonitor ssMon = SubMonitor.convert(mon, statesystemModules.size()); 
<|del|> 
 Path path = trimmableTrace.trim(tr, tracePath, mon.split(1)); if(path == null) { Activator.getDefault().logWarning("Could not trim trace " + tracePath); //$NON-NLS-1$ return; } 
 IResource resource; try { resource = getResource(path); } catch (CoreException e) { Activator.getInstance().logError(e.getMessage(), e); return null; } 
 if (!wantCapability(line, OPTION_FILTER)) { throw new PackProtocolException(uri, JGitText.get().filterRequiresCapability); } 
 return URIUtil.toUnencodedString(new File(uri).toURI()); 
 public static String ThreadStatusUsermode; 
 currentThreadQuark = ss.optQuarkAbsolute(Attributes.THREADS, Integer.toString(s), Attributes.EXEC_NAME); String execName = null; 
 execName = String.valueOf(result.getValue()); 
 list.add(new TimeGraphState(start, duration, StateValues.CPU_STATUS_RUN_USERMODE, Messages.ThreadStatusUsermode)); 
 MergeConflictingRunnableTest.class, MergeNonConflictingRunnableTest.class }) 
<|del|>
 if (filterBlobLimit >= 0 && !wantCapability(line, OPTION_FILTER)) { throw new PackProtocolException(uri, JGitText.get().filterRequiresCapability); 
 return Arrays.asList(new Object[][] { {fSomeProject}, {fSomeOtherProject} }); 
 * 
 * the destination path 
 public static final String testFontName; // isWindows refers to windows platform, i.e. win32 windowing system; see also isWindowsOS 
 public final static boolean isWindowsOS = System.getProperty("os.name").startsWith("Windows"); 
 Assert.isLegal(fgPreferenceNodeId == null || id == null, "Preference node already set"); //$NON-NLS-1$ fgPreferenceNodeId= id; 
<|del|> 
 * @return the default color to use for displaying hyperlinks, or * <code>null</code> if the color definition does not exists. 
 * @return the default color to use for displaying active hyperlinks, or * <code>null</code> if the color definition does not exists. 
 * Default strategy that creates a new model element based on the sub classes of the reference type. If 
 * This implementation utilizes the {@link EClassSelectionStrategy} to filter the EClass to offer. 
 * A <em>customization strategy</em> for accumulating {@link EClass}es for instantiation to create a new * object in a reference. Used by the {@link DefaultCreateNewModelElementStrategyProvider}. 
 StyledText widget = fSourceViewer.getTextWidget(); if (fSourceViewer != null && widget != null && !widget.isDisposed()) { widget.setFocus(); 
 if (fSourceViewer != null) { StyledText widget = fSourceViewer.getTextWidget(); if (widget != null && !widget.isDisposed()) { widget.setFocus(); } 
 // Do Nothing, no listeners instanciated 
 ITmfTimestamp startTime = fRequestedTraceCutStart; 
<|del|> 
 && Objects.equals(event1.getCPU(), event2.getCPU()) && Objects.equals(event1.getChannel(), event2.getChannel()); 
 * Copyright (c) 2016, 2018 EfficiOS Inc., Alexandre Montplaisir 
 // If the connection start has no yet been determined (the user did not select the start location yet, we // need to recompute the extended data. if (start) { CreateConnectionRequestHelper.computeConnectionStartExtendedData(current, (INodeEditPart) editPart); } 
 URI root = initParams.getRootUri() != null ? URI.create(initParams.getRootUri()) : null; this.lspStreamProvider.handleMessage(message, this.languageServer, root); 
<|del|> 
 (Objects.equal(expectedVal, actualVal)); 
 * Link style, the general line style 
 * Handler to allow tracing to and from IMarker instances as used by Eclipse to associate notes with resources. 
 inputStream = provider.getInputStream(); if (inputStream != null) { inputStream = new FilterInputStream(inputStream) { 
 errorStream = provider.getErrorStream(); if (errorStream != null) { errorStream = new FilterInputStream(errorStream) { 
 outputStream = provider.getOutputStream(); if (outputStream != null) { outputStream = new FilterOutputStream(outputStream) { 
 new String[] { IDialogConstants.NO_LABEL, 
 return inputStream; } if (provider.getInputStream() != null) { inputStream = new FilterInputStream(provider.getInputStream()) { 
 return errorStream; } if (provider.getErrorStream() != null) { errorStream = new FilterInputStream(provider.getErrorStream()) { 
 return outputStream; } if (provider.getOutputStream() != null) { outputStream = new FilterOutputStream(provider.getOutputStream()) { 
 /** * @param display cast=(GdkDisplay *) */ 
 * Copyright (c) 2017, 2018 Ericsson 
 public static final double TAU = Math.PI * 2; 
 double r, g, b; 
 if (red > 255 || red < 0) { 
<|del|> 
 * Link style, the general line style 
 // figure size. In some cases, the GMF Bounds may have been updated but the figure has not been refreshed yet. 
 public static final int NOTIFYICONDATA_V2_SIZE = NOTIFYICONDATA_V2_SIZE (); 
public static final native int NOTIFYICONDATA_V2_SIZE (); 
 .normalizeBranchName(name.replaceAll("[#$!]", " ")); //$NON-NLS-1$ //$NON-NLS-2$ if (normalized.length() > 30) { 
<|del|> 
 * Copyright (c) 2016, 2018 THALES GLOBAL SERVICES. 
 * DRepInDViewToRootObjectsAndWithDRepDescRepPathMigrationParticipant. 
 * Copyright (c) 2017, 2018 THALES GLOBAL SERVICES. 
 IFolder supplRootFolder = project.getFolder(TmfCommonConstants.TRACE_SUPPLEMENTARY_FOLDER_NAME); IFolder supplFolder = supplRootFolder.getFolder(path); createFolder(supplFolder, null); resource.setPersistentProperty(TmfCommonConstants.TRACE_SUPPLEMENTARY_FOLDER, supplFolder.getLocation().toOSString()); 
 * Copyright (c) 2015, 2018 Obeo. 
<|del|> 
 sb.append(MessageFormat.format(Messages.NoteAttachmentWithoutSourceOrTargetMigrationParticipant_edgesRemoved, gmfDiagram.getName(), noteAttachmentsToRemove.length)); 
 * Default sorter for artifacts. Sorts on descriptive name 
 Logger log = this.logger; if (log != null) { log.error(message, e); 
 void setLogger(LoggerFactory factory) { 
 LoggerFactory factory = context.getService(reference); 
 public void removedService(ServiceReference<LoggerFactory> reference, Logger service) { context.ungetService(reference); 
 void unsetLogger(LoggerFactory loggerFactory) { if (this.factory == loggerFactory) { this.factory = null; this.logger = null; } 
 void unsetLogService(LogService logService) { if (this.logService == logService) { this.logService = null; } 
 * Copyright (c) 2015, 2018 Obeo. 
 if (fRoot != null && arch != null && !arch.isEmpty()) { 
 if (fRoot != null && nl != null && !nl.isEmpty()) { 
 if (name != null && !name.isEmpty()) { 
 if (fRoot != null && ws != null && !ws.isEmpty()) { 
 } catch (IOException e) { 
 } catch (IOException e) { 
 if (OS.CAIRO_CONTEXT_REUSE) { if (cairoTransformationMatrix == null) cairoTransformationMatrix = new double[6]; Cairo.cairo_get_matrix(data.cairo, cairoTransformationMatrix); clipping = getClipping(); } 
 IEclipsePreferences prefs= new ProjectScope(javaProject.getProject()).getNode(JavaUI.ID_PLUGIN); if (prefs == null) return options; int profileVersion= prefs.getInt(FORMATTER_SETTINGS_VERSION, versioner.getCurrentVersion()); 
 * Copyright (c) 2010, 2018 THALES GLOBAL SERVICES and others. 
 * Copyright (c) 2010, 2018 THALES GLOBAL SERVICES and others. 
 if (element == null) { return; } 
 * Copyright (c) 2007, 2018 THALES GLOBAL SERVICES and others. 
 fAverageCharWidth = getAverageCharWidth(gc); 
 void addColorListener(ITimeGraphColorListener listener); 
 getTimeGraphControl().setFilterActive(isFilterApplied); 
 } 
 ResourceUtil.deleteResource(resource, subMon.split(1)); 
 @NonNull Map<@NonNull String, @NonNull BiPredicate<org.eclipse.tracecompass.internal.tmf.core.model.timegraph.IPropertyCollection, @NonNull Function<org.eclipse.tracecompass.internal.tmf.core.model.timegraph.IPropertyCollection, @NonNull Map<@NonNull String, @NonNull String>>>> predicates = computeRegexPredicate(); 
 protected void doFilterEvents(TimeGraphEntry entry, List<ITimeEvent> eventList, Map<String, BiPredicate<IPropertyCollection, Function<IPropertyCollection, Map<String, String>>>> predicates) { 
 if (!predicates.isEmpty()) { // For each event in the events list, test each predicates and set the // status of the property associated to the predicate 
 && getTimeEventFilterDialog() != null && getTimeEventFilterDialog().hasActiveSavedFilters()) { 
public interface ITimeEvent extends IPropertyCollection, IElementResolver { 
 @NonNullByDefault protected void doFilterEvents(TimeGraphEntry entry, List<ITimeEvent> eventList, Map<String, BiPredicate<IItem, Function<IItem, Map<String, String>>>> predicates) { if (!predicates.isEmpty()) { 
<|del|> 
 public Response cancelAction(@PathParam("id") String id) { 
 int cellGap = TEXT_GAP; if (event.index == 0) { cellGap = 0; } 
 for (int i = 0; i < limit; ++i) { 
 setLayoutData(compositeBuilder.getViewerComposite()); 
 return Collections.emptyList(); 
 * Iterate and return the first failling rule. null if no rule is * failling. 
 return target.getConflict() != null && target.getConflict().getKind() == ConflictKind.PSEUDO; 
<|del|> 
 @NonNull Map<@NonNull String, @NonNull BiPredicate<@NonNull IPropertyCollection, @NonNull Function<@NonNull IPropertyCollection, @NonNull Map<@NonNull String, @NonNull String>>>> predicates = computeRegexPredicate(); 
 protected Map<String, BiPredicate<IPropertyCollection, @NonNull Function<@NonNull IPropertyCollection, @NonNull Map<@NonNull String, @NonNull String>>>> computeRegexPredicate() { 
<|del|> 
<|del|> 
 public static final String PREF_COMPILER_COMPLIANCE_DOES_NOT_MATCH_JRE = LaunchingPlugin.getUniqueIdentifier() + ".PREF_COMPILER_COMPLIANCE_DOES_NOT_MATCH_JRE"; //$NON-NLS-1$ 
 finalEnvironment = environment; break; 
 public static final String PREF_STRICT_COMPLIANCE_COMPATIBLE_JRE_NOT_AVAILABLE = LaunchingPlugin.getUniqueIdentifier() + ".PREF_STRICT_COMPLIANCE_COMPATIBLE_JRE_NOT_AVAILABLE"; //$NON-NLS-1$ 
<|del|> 
 ss.modifyAttribute(ts, (Object) null, buildIdQuark); 
 fSs.modifyAttribute(ts, (Object) null, mergedInQuark); 
 fSs.modifyAttribute(ts, (Object) null, mergedInQuark); 
 issuedFromValue = Integer.parseInt(fSs.getAttributeName(fromQuark)); 
 fSs.modifyAttribute(ts, Integer.parseInt(fSs.getAttributeName(baseQuark)), issuedFromQuark); 
 GtkRequisition naturalSize = new GtkRequisition(); GtkRequisition minimumSize = new GtkRequisition(); GTK.gtk_widget_get_preferred_size(handle, minimumSize, naturalSize); size.y = Math.max(size.y, minimumSize.height); 
 if (widget == handle && GTK.GTK_VERSION >= OS.VERSION(3, 20, 0)) { 
 Map<String, BiPredicate<IElementResolver, Function<IElementResolver, Map<String, String>>>> predicates = computeRegexPredicate(); 
 GtkRequisition naturalSize = new GtkRequisition(); GtkRequisition minimumSize = new GtkRequisition(); GTK.gtk_widget_get_preferred_size(handle, minimumSize, naturalSize); size.y = Math.max(size.y, minimumSize.height); 
 JsonElement jsonElement = entry.getValue(); 
 for (Entry<String, JsonElement> entry : object.entrySet()) { String key = entry.getKey(); JsonElement jsonElement = object.get(key); 
 for (Entry<String, JsonElement> entry : object.entrySet()) { String key = entry.getKey(); JsonElement jsonElement = object.get(key); 
 * Red Hat - initial API and implementation 
 * @since 4.0 
 if (e.character == SWT.CR) { 
<|del|> 
 shell.setLocation(getFilterBounds()); 
<|del|> 
<|del|> 
 List<TmfCommonProjectElement> toReopen = new ArrayList<>(); 
 String key = new StringBuilder(IModelElement.TYPE).append(":").append(type.getTypeName()).toString(); //$NON-NLS-1$ 
<|del|> 
 private class ControlMovedListener implements ControlListener { 
 // Keep only the events that do not have the 'exclude' property activated 
 * The event is annotated. When this is enable, * {@link ITimeGraphPresentationProvider#postDrawEvent} will not be call 
<|del|> 
<|del|> 
 adv.send(db.getRefDatabase().getRefsByPrefix(Constants.R_REFS)); 
 * The event is annotated. When this is set, * {@link ITimeGraphPresentationProvider#postDrawEvent} will not be called 
 * The event is annotated. When this is set, * {@link ITimeGraphPresentationProvider#postDrawEvent} will not be called 
 Integer previousFillColor = (Integer) styleMap.get(ITimeEventStyleStrings.fillColor()); if (previousFillColor != null) { 
 Integer previousFillColor = (Integer) styleMap.get(ITimeEventStyleStrings.fillColor()); if (previousFillColor != null) { 
 data.put(IElementResolver.label(), getLabel()); 
 * Copyright (c) 2018 Ericsson 
 * @author Jean-Christian Kouame * @author Christophe Bourque Bedard 
<|del|> 
 GridLayoutFactory.fillDefaults().applyTo(tableContainer); 
<|del|> 
 fExportButton.addSelectionListener(new SelectionAdapter() { 
 fEditButton.addSelectionListener(new SelectionAdapter() { 
 fDeleteButton.addSelectionListener(new SelectionAdapter() { 
 FileDialog dialog = TmfFileDialogFactory.create(Display.getCurrent().getActiveShell(), SWT.OPEN); 
 if (path != null && !XmlUtils.exportXmlFile(selectionXml, path).isOK()) { Activator.logError(NLS.bind(Messages.ManageXMLAnalysisDialog_FailedToExport, selectionXml)); 
 if (ISaveablePart.PROP_DIRTY == propId && !editorPart.isDirty()) { // Editor is not dirty anymore, i.e. it was saved loadXmlFile(file, false); 
<|del|> 
 * * <p> * This is used as an input to {@link ProtocolV2Hook}. * 
public final class LsRefsV2Request { private final List<String> refPrefixes = new ArrayList<>(); 
 assertNotNull(git.getRepository().exactRef("refs/tags/test")); 
 assertNull(git.getRepository().exactRef("refs/tags/test")); 
 * Copyright (C) 2018, Google LLC. 
 private final boolean peel; 
 private LsRefsV2Request(List<String> refPrefixes, boolean symrefs, boolean peel) { this.refPrefixes = refPrefixes; this.symrefs = symrefs; this.peel = peel; 
 * Copyright (C) 2018, Google LLC. 
 default void onCapabilities(CapabilitiesV2Request req) throws ServiceMayNotContinueException { 
<|del|> 
 logErrorOpeningAsWorkspaceFile(e); 
<|del|> 
 addField(new RegExStringFieldEditor(Preferences.KEY_OPEN_AS_PREVIEW_NAME_PATTERN, 
 setNeedsDisplay(); 
void redraw(boolean children) { 
 setNeedsDisplay(); 
 setNeedsDisplayInRect(x, y, width, height); } private void setNeedsDisplay() { view.setNeedsDisplay(true); } private void setNeedsDisplayInRect(int x, int y, int width, int height) { 
 * Copyright (c) 2010, 2018 THALES GLOBAL SERVICES. 
 final Vector<IBreakpointDMContext> newTargetBPs = new Vector<>(); 
 public void testLambdaCaptures_535196_1() throws Exception { 
 * <p>Bug 489640, 438992. Drop-down appearance.</p> 
 // Resolver should be triggered. commitAndSync(transaction1, transaction2); commitAndSync(transaction2, transaction1); 
<|del|>
 ResourcesPlugin.getWorkspace().run( runnable, new MultiRule(Arrays.stream(projects).map(IJavaProject::getResource).toArray(ISchedulingRule[]::new)), IWorkspace.AVOID_UPDATE, mainMonitor.split(1)); 
 * Copyright (c) 2018, Markus Duft <markus.duft@ssi-schaefer.com> 
 public DescribeCommand setTags(boolean tags) { this.useTags = tags; 
 DebugUIPlugin.log(new Status(IStatus.WARNING, DebugUIPlugin.getUniqueIdentifier(), "Interrupted while waiting on ElementContentProvider jobs", e)); //$NON-NLS-1$ 
 public byte[] loadSectionData() throws IOException { makeSureNotCompressed(); 
 assertTrue("Wrong Binding", "Integer".equals(simpleName.resolveBinding().getName())); 
 try { loadResourceSetWithProxies(resourceURI, commandStack, null); } catch (final IOException ex) { Activator.getDefault().getReportService().report( new StatusReport(new Status(IStatus.ERROR, Activator.PLUGIN_ID, ex.getMessage(), ex))); } return null; 
 if (addResourceToSet(resourceSet, resourceURI, null)) { 
 * (value is 1 &lt;&lt 15). * * @since 3.108 
 private PackWriterBitmapPreparer newPreparer(Set<RevCommit> wants, 
 ((IBrowserFunctionProvider) tip).getBrowserFunctions() .forEach((name, function) -> fBrowserFunctions.add(createBrowserFunction(name, function))); 
 * Provides names and functions, which can be invoked by the JavaScript code, 
 fContentComposite.requestLayout(); } private void applyBrowserFunctions(Tip tip) { 
 info.setLastModified((st_mtime * 1_000) + st_mtime_msec); 
 } 
public class ClasspathShortenerTests extends AbstractDebugTest { 
 return String.join(";", classpathElements); 
<|del|> 
 protected ClasspathShortener(String os, String javaVersion, ILaunch launch, String[] cmdLine, int lastJavaArgumentIndex, File workingDir, String[] envp) { 
 protected ClasspathShortener(String os, String javaVersion, ILaunch launch, String[] cmdLine, int lastJavaArgumentIndex, File workingDir, String[] envp) { 
 this.processTempFilesDir = workingDir != null ? workingDir : Paths.get(".").toAbsolutePath().normalize().toFile(); //$NON-NLS-1$ 
 * {@link IJavaLaunchConfigurationConstants#ATTR_USE_CLASSPATH_ONLY_JAR} is set, a classpath-only jar is used (without asking confirmation). 
 public boolean shortenCommandLineIfNecessary() { // '|' used on purpose (not short-circuiting) 
 return JavaCore.compareJavaVersions(javaVersion, JavaCore.VERSION_9) >= 0; 
 private int getEnvironmentLength() { 
 // POSIX suggests to subtract 2048 additionally so that the process may safely modify its environment. // see https://www.in-ulm.de/~mascheck/various/argmax/ 
 private void removeCmdLineArgs(int index, int length) { 
 if (env[i].regionMatches(true, 0, CLASSPATH_ENV_VAR_PREFIX, 0, 10)) { 
 String tempFiles = process.getAttribute(ATTR_LAUNCH_TEMP_FILES); if (tempFiles == null) { 
 Arrays.stream(tempFiles.split(File.pathSeparator)).map(path -> new File(path)).forEach(file -> file.delete()); 
 String tempFiles = classpathShortener.getProcessTempFiles().stream().map(file -> file.getAbsolutePath()).collect(Collectors.joining(File.pathSeparator)); process.setAttribute(LaunchingPlugin.ATTR_LAUNCH_TEMP_FILES, tempFiles); 
 String tempFiles = classpathShortener.getProcessTempFiles().stream().map(file -> file.getAbsolutePath()).collect(Collectors.joining(File.pathSeparator)); process.setAttribute(LaunchingPlugin.ATTR_LAUNCH_TEMP_FILES, tempFiles); 
 String tempFiles = classpathShortener.getProcessTempFiles().stream().map(file -> file.getAbsolutePath()).collect(Collectors.joining(File.pathSeparator)); process.setAttribute(LaunchingPlugin.ATTR_LAUNCH_TEMP_FILES, tempFiles); 
 * @since 3.11 
 * @since 3.11 
 * Copyright (c) 2005, 2018 IBM Corporation and others. 
 * @return a representation that will not be applied the auto scale when in mode * {@link ExportFormat.ScalingPolicy#AUTO_SCALING_IF_LARGER}. 
 if(event.getSource() == serverChoice && event.getProperty() == FieldEditor.VALUE) { String changedLSLocation = CPPStreamConnectionProvider.getDefaultLSLocation((String) event.getNewValue()).getAbsolutePath(); if(changedLSLocation != null) { serverPath.setStringValue(changedLSLocation); } 
 if(event.getSource() == serverChoice && event.getProperty() == FieldEditor.VALUE) { String changedLSLocation = CPPStreamConnectionProvider.getDefaultLSLocation((String) event.getNewValue()).getAbsolutePath(); if(changedLSLocation != null) { serverPath.setStringValue(changedLSLocation); } 
 serverPath.setStringValue(changedLSLocation.getAbsolutePath()); 
 ((IPostSelectionProvider) sourceViewer.getSelectionProvider()) .addPostSelectionChangedListener(editorSelectionChangedListener); 
 ((IPostSelectionProvider) sourceViewer.getSelectionProvider()) .removePostSelectionChangedListener(editorSelectionChangedListener); 
 Enumeration<URL> entries = Activator.findEntries("/", libName, true); //$NON-NLS-1$ 
 * @param writer The Writer to which the xml should be written to, e.g. * {@link BufferedWriter} * 
 * Class inspired from {@link java.net.URI} but simpler. It is used to define the location of an element. 
 * Class inspired from {@link java.net.URI} but simpler. It is used to define the location of an element. 
 * Id used to represent the global contextual menu. 
 * Constructs an URI by parsing the given string. 
 * @return an optional tabbar id 
 if (menuURI.substring(MENU_SCHEME.length()).trim().startsWith(SEPARATOR)) { String id = menuURI.substring(MENU_SCHEME.length()).trim().substring(SEPARATOR.length()).trim(); 
 if (menuURI.substring(MENU_SCHEME.length()).trim().startsWith(SEPARATOR)) { String id = menuURI.substring(MENU_SCHEME.length()).trim().substring(SEPARATOR.length()).trim(); 
 if (tabbarURI.substring(TABBAR_SCHEME.length()).trim().startsWith(SEPARATOR)) { String id = tabbarURI.substring(TABBAR_SCHEME.length()).trim().substring(SEPARATOR.length()).trim(); 
 if (tabbarURI.substring(TABBAR_SCHEME.length()).trim().startsWith(SEPARATOR)) { String id = tabbarURI.substring(TABBAR_SCHEME.length()).trim().substring(SEPARATOR.length()).trim(); 
 DiagramUIPlugin.getPlugin().log(new Status(IStatus.WARNING, DiagramUIPlugin.ID, IStatus.OK, MessageFormat.format(Messages.Group_Not_Displayed, group.getName(), MessageFormat.format(Messages.Group_No_Menu_ID, menuId)), null)); 
<|del|> 
<|del|> 
 // Use the path as the default. 
<|del|> 
 private ILaunchManager lm = DebugPlugin.getDefault().getLaunchManager(); 
 DDiagramElement found = list.stream().filter(input -> input.getTarget() instanceof ENamedElement && targetName.equals(((ENamedElement) input.getTarget()).getName())).findFirst().orElse(null); 
 DDiagramElement found = list.stream().filter(input->input.getTarget() instanceof ENamedElement && targetName.equals(((ENamedElement) input.getTarget()).getName())).findFirst().orElse(null); 
 Collection<String> dependencies = new ArrayList<String>(Arrays.asList(IMPORT, SERVICE)); 
 evaluateCollection(interpreter, eAttribute, expression, new ArrayList<EObject>(Arrays.asList(eobjectArrayValue))); 
 .filter(n -> isElementEqualsToComponent(n, componentName)).findFirst().orElse(null); 
<|del|> 
 * Copyright (c) 2018 Felix Morgner 
 * Get the type of the template-template parameter (either {@link #tt_class} or {@link #tt_typename}). 
 } catch (InterruptedException e) { LaunchingPlugin.log(e); 
 checkProcessResult(process); 
 String output = "IProcess.getStreamsProxy() returned null"; //$NON-NLS-1$ 
 public EventJob(String name) { super(MessageFormat.format(UIText.GitDecorator_jobTitle, name)); 
<|del|> 
 String message = SiriusGraphQLMessages.SiriusGraphQLContext_requestTooExpensive; String formattedMessage = MessageFormat.format(message, this.cost, maxCost); throw new IllegalArgumentException(formattedMessage); 
 /** * System call lookup helper, reads a map of system call names and their file * locations. System calls are ABIs and should remain static in location when * they are created. * * @author Matthew Khouzam */ 
 Activator.getDefault().logError("Syscall names not available!"); //$NON-NLS-1$ 
 BeanTestingHelper.get().unregisterBeans(m_replacedBeans); 
 // we don't want this util class to be instantiable 
 public Tuple keepSelectedIndices(ITuple original) { Object[] signature = new Object[sourceWidth]; for (int i = 0; i < indices.length; ++i) signature[indices[i]] = original.get(indices[i]); return Tuples.flatTupleOf(signature); 
 public TmfRegexFilterAppliedSignal(Object source, String regex) { 
<|del|> 
<|del|> 
 for (Repository repository : repositories) { Map<String, Ref> localBranches = repository.getRefDatabase() .getRefs(Constants.R_HEADS); localBranchMapping.add(localBranches); } 
 * Capabilities protocol v2 request. 
 public void run() { if (aMode == getCurrentMode()) { // the currently checked menu item can be // hit again return; } 
 return findLocalResourceImpl(resource, hookEntries, m, classPathIndex, curIndex); 
 private URL findLocalResourceImpl(String resource, ClasspathEntry[] cpEntries, Module m, int classPathIndex, int[] curIndex) { 
 for (ClasspathEntry cpEntry : cpEntries) { 
 return findLocalResources(resource, hookEntries, m, classPathIndex, resources); 
 return findLocalEntry(path, hookEntries, classPathIndex, curIndex); 
 return findLocalClassImpl(classname, hookEntries, hooks); 
 * @since 5.1 
 return (Notification.REMOVE == notificationType || Notification.REMOVE_MANY == notificationType) && !children.containsAll(childrenFromTreeContextEntry); 
 private static final int DEFAULT_MAX_COST = 100; 
 * and is available at * https://www.eclipse.org/legal/epl-2.0/ * * SPDX-License-Identifier: EPL-2.0 
<|del|> 
 * and is available at * https://www.eclipse.org/legal/epl-2.0/ * * SPDX-License-Identifier: EPL-2.0 
 if (visible) GTK.gtk_widget_show(control.topHandle ()); 
 } 
 public static void main(String[] args) { 
<|del|> 
<|del|> 
 if (inactivePositions == null) { 
 // A set containing all active objects of PresentationReconcilerCPP. 
 if (returnedPositions == null) { 
 // Adding Semantic Highlighting Position Category and a DefaultPositionUpdater to the document. newDocument.addPositionCategory(SEMANTIC_HIGHLIGHTING_POSITION_CATEGORY); semanticHighlightingPositionUpdater = new DefaultPositionUpdater(SEMANTIC_HIGHLIGHTING_POSITION_CATEGORY); newDocument.addPositionUpdater(semanticHighlightingPositionUpdater); 
 if (doc == null) { 
 // TODO: Use IColorManager to cache Color objects so that only one object per color is created. 
<|del|> 
 private static boolean isNameUsed(String name, List<NamedElement> list) { return list.stream().anyMatch(el -> Objects.equals(el.getName(), name)); 
 private static boolean isNameUsed(String name, List<NamedElement> list) { return list.stream().anyMatch(el -> Objects.equals(el.getName(), name)); 
 Layer editorFigure = new FreeformLayer(); editorFigure.setBorder(new MarginBorder(10)); editorFigure.setLayoutManager(new FreeformLayout()); editorFigure.setOpaque(false); editorFigure.add(leftInterfaceContainer); editorFigure.add(rightInterfaceContainer); updateRouter(editorFigure); return editorFigure; 
 IFigure newFigure = new FreeformLayer(); newFigure.setBorder(new MarginBorder(10)); newFigure.setLayoutManager(new FreeformLayout()); newFigure.setOpaque(false); 
 List<Event> inputEvents = new ArrayList<>(temp.getInterfaceList().getEventOutputs()); 
 List<Event> outputEvents = new ArrayList<>(temp.getInterfaceList().getEventInputs()); 
 List<VarDeclaration> inputVars = new ArrayList<>(temp.getInterfaceList().getOutputVars()); 
 List<VarDeclaration> outputVars = new ArrayList<>(temp.getInterfaceList().getInputVars()); 
 return getResource(((SubApp)container)); 
<|del|> 
 public static final EMFQueryMetaContext DEFAULT_SURROGATE = new EMFQueryMetaContext(false, true, UnscopedTypeSupport.EMIT_EXCEPT_AS_WEAKENED_REPLACEMENT); 
 int offset = event.fOffset - lastPartition.getOffset(); lastPartition.insert(event.fText, offset >= 0 ? offset : event.fOffset); 
<|del|> 
 Assert.assertTrue(idsOfCoveredDiscrepancies.size() == idsSize); 
 if (type.equals(ANALYZE_CODE) || type.equals(ANALYZE_TEST) || type.equals(ANALYZE_REQT)) { 
 addSemanticHighlightPositionCategory(newDocument); 
 HighlightingStyle highlightingStyle = new HighlightingStyle(textAttribute, isEnabled); 
 * are made available under the terms of the Eclipse Public License v2.0 
<|del|> 
<|del|> 
 private final Multimap<URI, Pattern> dependencyCache; 
 Set<URI> referredUris = PatternLanguageHelper.getReferencedPatternsTransitive(pattern).stream() .map(p -> p.eResource().getURI()).collect(Collectors.toSet()); referredUris.forEach(u -> dependencyCache.remove(u, pattern)); 
 private IQuerySpecification<?> getOrCreateQuerySpecification(Pattern pattern, AdvancedPatternParserSnapshot results) { 
<|del|> 
<|del|> 
 selectedDevParams = Collections.unmodifiableList(new ArrayList<>(selParams)); 
 public static final String WRITE_PARAMETER = "<Request ID=\"{0}\" Action=\"WRITE\"><Connection Source=\"{1}\" Destination=\"{2}\" /></Request>"; //$NON-NLS-1$ 
 public static final String FORCE_VALUE = "<Request ID=\"{0}\" Action=\"WRITE\"><Connection Source=\"{1}\" Destination=\"{2}\" force=\"{3}\" /></Request>"; //$NON-NLS-1$ 
 String request = MessageFormat.format(FORCE_VALUE, 
 String request = MessageFormat.format(FORCE_VALUE, 
 private static final String WRITE_PARAMETER_FBDK2 = "<Request ID=\"{0}\" Action=\"WRITE\"><Parameter Value=\"{1}\" Reference=\"{2}\" /></Request>"; //$NON-NLS-1$ 
 return MessageFormat.format(DeploymentExecutor.WRITE_PARAMETER, this.reqID++, value, Dst); 
 if (OS.GTK_VERSION >= OS.VERSION (3, 2, 0)) { 
 virtSpecifier.setPropertyInParent(VIRT_SPECIFIER); 
 out.print("<div id=\""+id+"\"><input id=\"run-action-" + id + "\" type=\"checkbox\" "+ //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$ 
 out.println("/><label for=\"run-action-" + id + "\">"+getText()+"</label></div>"); //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$ 
 * Copyright (c) 2007, 2018 THALES GLOBAL SERVICES and others. 
 * Whether or not to fetch from upstream before feature branch is * created. 
 return config.getBoolean(GITFLOW_SECTION, FEATURE_START_SUBSECTION, FEATURE_START_FETCH_KEY, false); 
 } progress.setWorkRemaining(1); 
 start(progress.newChild(1), branchName, head); 
 throws URISyntaxException, InvocationTargetException { 
<|del|> 
<|del|> 
 getCachedSegments().add(segment); 
 // TODO(ms) should check for submodule path, but can't set name // before 5.1.0 assertEquals("Invalid submodule name '-invalid-path'", e.getMessage()); 
<|del|> 
 private final List<GitmoduleEntry> gitsubmodules = new ArrayList<>(); 
 assertTrue(errorLine.startsWith( "unpack error Invalid submodule URL '-upayload.sh'")); 
 throw new UncheckedIOException(e); 
 // Ignored. Client cannot use this repository. 
 this.clientShallowCommits = requireNonNull(clientShallowCommits); 
 this.clientShallowCommits = Objects .requireNonNull(clientShallowCommits); 
 FetchV0Request(@NonNull Set<ObjectId> wantIds, int depth, 
 FetchV2Request(@NonNull List<ObjectId> peerHas, 
 String viewName = "Not Set"; 
 static boolean commonIntersect(Multimap<String, String> data1, Multimap<String, String> data2) { 
 public static final String ID_MODULE= "module"; //$NON-NLS-1$ 
 * Copyright (c) 2009, 2018 THALES GLOBAL SERVICES and others. 
 if (!visibilityModeActive && !layoutingModeActive) { 
 * Copyright (c) 2009, 2018 THALES GLOBAL SERVICES. 
 * Return command parameters representing mapping types specific to this * diagram type which should be integrated in the Layers menus. 
 return (E) (Comparable<E>) o -> 0; 
 .filter(bundle -> symbolicName.equals(bundle.adapt(BundleRevision.class).getSymbolicName())) 
 // Equinox regions could hide bundle ID 0 bundleContext.getBundle(SYSTEM_BUNDLE_LOCATION).adapt(FrameworkWiring.class).refreshBundles(bundles); 
 listeners = new ArrayList<IContentChangedListener>(); 
 } 
 bestMatch = getBestMatch(tags.get(c)); if (bestMatch.isPresent()) { Candidate cd = new Candidate(c, bestMatch.get()); 
 bestMatch = getBestMatch(tags.get(c)); if (bestMatch.isPresent()) { Candidate cd = new Candidate(c, bestMatch.get()); 
 if (e != null && (e instanceof CancellationException || (e.getCause() != null && e.getCause() instanceof CancellationException))) { 
 addEventHandler(getLayout().eventSyscallExitPrefix() + OPEN, this::handleOpenExit); addEventHandler(LTTNG_STATEDUMP_FILE_DESCRIPTOR, this::handleStateDump); 
 * In releases prior to 5.2 this method was called setForce() but this name 
 * @since 5.2 
 * JGit releases before 5.2 had a method <code>setForce()</code> offering 
 * @since 5.2 
 * @since 5.2 
 /** * DISABLE_PRINT_FOR_PERMISSION_AUTHORITY_DECORATION. */ protected static final String DISABLE_PRINT_FOR_PERMISSION_AUTHORITY_DECORATION = "org.eclipse.sirius.diagam.ui.hidePrintingOfPermissionAuthorityDecoration"; //$NON-NLS-1$ 
<|del|> 
 bestMatch = getBestMatch(tags.get(c)); if (bestMatch.isPresent()) { Candidate cd = new Candidate(c, bestMatch.get()); 
 for (String segment : relPath.segments()) for (Object child : cp.getChildren(currentNode)) { 
 List<ICodeMiningProvider> providers, IProgressMonitor monitor) { 
 * File access by file view 
<|del|> 
 // unassigned is not useful in the selection choice dialog oseeUsers.remove(unassigned); if (teamMembers != null) { teamMembers.remove(unassigned); 
 new UserCheckTreeDialog("Select Assignees", "Select to assign.\nDeSelect to un-assign.", oseeUsers); 
 new UserCheckTreeDialog("Select Assignees", "Select to assign.\nDeSelect to un-assign.", oseeUsers); 
<|del|> 
<|del|> 
 } subMon.checkCanceled(); 
 monitor.beginTask(name, repositories.length * 3); 
 // Do nothing 
<|del|>
 // Do nothing 
 super.setLabel(MessageFormat.format(JavaCodeMiningMessages.JavaImplementationCodeMining_label, implCount)); 
 super.setLabel(MessageFormat.format(JavaCodeMiningMessages.JavaReferenceCodeMining_label, refCount)); 
 return action; 
 to = from.getCopy().setX(editor.getBounds(eClass2EditPartBot).x); 
 IJavaElement element = super.getElement(); long refCount= countReferences(element, monitor); 
 IJavaElement element = super.getElement(); long refCount= countReferences(element, monitor); 
 action= refCount > 0 ? e -> new FindReferencesAction(editor).run(element) : null; 
 protected int getStackFrameIndex(IStackFrame stackFrame) { 
 protected int getStackFrameIndex(IStackFrame stackFrame) { 
 stackFrameIndex++; 
 if (compile == null) { Activator.logInfo("buildFilterFromRegex: Invalid regex"); //$NON-NLS-1$ 
 * Indicator of the relative order between updates of a specific reference 
 private final Multimap<NodeId, InstanceIdentifier<?>> nodesToVpps = ArrayListMultimap.create(); 
 //FIXME: according contract in YANG model this should be URI to data on mount point (accroding to RESTCONF) 
 public final int linkMtu; 
 byte subInnerVlanIdAny, int vtrOp, int vtrPushDot1q, int vtrTag1, int vtrTag2, int linkMtu) 
public final class ReadOnlyTransaction implements DOMDataReadOnlyTransaction { 
 private final VppReadProxy operationalReader; private final VppReadProxy configReader; 
 return config.read(path); // TODO using ReadWriteTransaction.read for operational should be allowed 
 } @Override public Object getIdentifier() { return this; } 
<|del|> 
 static Map<InstanceIdentifier<?>, DataObject> childrenFromNormalized(@Nonnull final DataContainerNode parent, 
public final class VppConfigDataTree implements VppDataTree { 
<|del|> 
 final ChangesProcessor processor = new ChangesProcessor(writer, nodesBefore, nodesAfter); try { processor.applyChanges(); } catch (VppApiInvocationException e) { LOG.warn("Failed to apply changes", e); LOG.info("Trying to revert successful changes for current transaction"); 
 } // rethrow as we can't do anything more about it throw e; 
 final DataContainerNode parent = (DataContainerNode)parentOptional.get(); return DataTreeUtils.childrenFromNormalized(parent, serializer); 
public final class VppOperationalDataTree implements ReadableVppDataTree { 
 final DataObject dataObject = reader.read(path); // FIXME we need to expect a list of dataObjects here 
 LOG.trace("VppOperationalDataProxy.toNormalizedNode(), path={}, path={}", path, dataObject); 
 configSnapshot = null; operationalData = null; 
 private static void checkConfigurationWrite(final LogicalDatastoreType store) { Preconditions.checkArgument(LogicalDatastoreType.CONFIGURATION == store, "Write is not supported for operational data store"); 
 private void checkIsNew() { Preconditions.checkState(status == NEW, "Transaction was submitted or canceled"); Preconditions.checkState(modification != null, "VPPDataTree modification should not be null"); 
 private void checkIsNew() { Preconditions.checkState(status == NEW, "Transaction was submitted or canceled"); Preconditions.checkState(modification != null, "VPPDataTree modification should not be null"); 
 throw new UnsupportedOperationException("deprecated"); 
<|del|> 
 * @param <D> Specific DataObject derived type, that is handled by this reader 
 LOG.debug("Reading from all delegates"); 
 final List<DataObject> objects = new ArrayList<>(rootReaders.size()); 
 // we need to provide extensible way to register initializer that would // translate between models 
 private NormalizedNode<?, ?> wrapDataObjects(final YangInstanceIdentifier yangInstanceIdentifier, 
 LOG.trace("VppOperationalDataProxy.toNormalizedNode(), normalizedNodeEntry={}", entry); return entry.getValue(); 
 Sets.difference(nodesBefore.keySet(), rootWriters.keySet())); 
 // TODO move to translate-utils 
 // TODO move to translate-utils 
 // TODO move to translate-utils 
public interface JVppDump extends JVppRequest { 
 void checkActive(); 
 LOG.severe("Can't find vpp jni library: " + LIBNAME); 
 throw new IOException("Failed to open library resource " + LIBNAME); 
<|del|> 
 this.clientName = clientName; } 
public interface JVppDump extends JVppRequest { 
public interface JVppReply<REQ extends JVppRequest> { 
<|del|> 
<|del|> 
 this.clientName = Objects.requireNonNull(clientName,"Null clientName"); 
 this.requests = Objects.requireNonNull(requestMap, "Null requestMap"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Objects.requireNonNull(replyFuture,"replyFuture is null"); 
 Objects.requireNonNull(reply,"reply is null"); 
 Objects.requireNonNull(reply,"reply is null"); 
 Objects.requireNonNull(reply,"reply is null"); 
 } } catch(NullPointerException e) { throw new IllegalStateException(e.getMessage()); 
 * Open VppConnection for communication to VPP * * @param callback instance handling responses * * @throws IOException if connection is not established 
 * Open VppConnection for communication to VPP * * @param callback instance handling responses * * @throws IOException if connection is not established 
 * Initiate VPP connection for current instance 
 } catch (VppApiInvocationException e) { 
final class InterfaceTypeTestUtils { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * Test whether file at persistPath exists and is readable or create it along with its parent structure 
 * Test whether file at persistPath exists and is readable or create it along with its parent structure 
 Files.newOutputStream(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)); 
<|del|> 
 ReadTimeoutException.class, 30, () -> reinitializeJVpp(reinitializationCounter)); 
<|del|>
<|del|> 
 final byte isIpv6 = (byte) (isIpv6(VxlanGpe) ? 1 : 0); 
 Remote.getAddress(), vni, protocol, encapVrfId, decapVrfId, isIpv6)); 
<|del|>
 remote.getAddress(), vni, protocol, encapVrfId, decapVrfId, isIpv6)); 
 final int vni, final byte protocol, final int encapVrfId, final int decapVrfId, final byte isIpv6) { 
<|del|>
<|del|>
 * Callback Exception representing failed operation of JVpp request call 
 void onError(org.openvpp.jvpp.VppCallbackException ex); 
<|del|> 
 } catch (VppBaseCallException e) { 
 public VppBaseCallException(final String methodName, final int errorCode) { super(String.format("vppApi.%s failed with error code: %d", methodName, errorCode)); 
 super(methodName, 0, errorCode); 
<|del|> 
 if (e instanceof ExecutionException && ( e.getCause() instanceof VppBaseCallException)) throw (VppBaseCallException)(e.getCause()); 
 if (e instanceof ExecutionException && ( e.getCause() instanceof VppBaseCallException)) throw (VppBaseCallException)(e.getCause()); 
 if (e instanceof ExecutionException && ( e.getCause() instanceof VppBaseCallException)) throw (VppBaseCallException)(e.getCause()); 
 private final String methodName; private final int errorCode; 
 super(methodName, errorCode); 
 <REQ extends JVppRequest, REPLY extends JVppReply<REQ>> CompletionStage<REPLY> send(REQ req); 
<|del|> 
 final CompletableFuture<REPLY> replyCompletableFuture = new CompletableFuture<>(); 
 void onError(VppCallbackException ex); 
 if (e instanceof ExecutionException && ( e.getCause() instanceof VppBaseCallException)) { throw (VppBaseCallException) (e.getCause()); } 
 if (e instanceof ExecutionException && ( e.getCause() instanceof VppBaseCallException)) { throw (VppBaseCallException) (e.getCause()); } 
 public void onWantInterfaceEventsReply(final WantInterfaceEventsReply wantInterfaceEventsReply) { System.out.println("Interface notification stream updated"); } 
 LOG.warn("Failed to write interface {}(id=): {}", subifName, writeContext, dataAfter); 
 /** * Start notification stream managed by this producer. * * @param collector Notification collector expected to collect produced notifications */ void start(@Nonnull NotificationCollector collector); /** * Stop notification stream managed by this producer. */ 
 void onNotification(@Nonnull Notification notification); 
 */ @Nonnull 
/** * Notification collector based on MD-SAL's {@link NotificationPublishService}. */ public final class HoneycombNotificationCollector implements NotificationCollector, AutoCloseable { 
 @Nonnull final NotificationPublishService bindingDOMNotificationPublishServiceAdapter, @Nonnull final NotificationProducerRegistry notificationProducerRegistry) { 
 * Customizer for reading sub interfaces form the VPP. 
<|del|> 
<|del|> 
<|del|>
 FutureJVpp fakeJvpp = mock(FutureJVpp.class); 
 verify(fakeJvpp,times(1)).lispEnableDisable(lispCaptor.capture()); 
<|del|> 
 LOG.debug("No interfaces for :{} found in VPP", id); 
 LOG.debug("No interfaces for :{} found in VPP", id); 
<|del|> 
<|del|> 
 checkArgument(maskParts.length == DOTTED_QUAD_MASK_LENGHT, "Network mask %s is not in Quad Dotted Decimal notation!", mask); 
 checkArgument(value < NETMASK_PART_LIMIT, "Network mask %s contains invalid number(s) over 255!", mask); checkArgument(value >= 0, "Network mask %s contains invalid negative number(s)!", mask); 
 "Non-contiguous network mask %s is not allowed!", mask); 
 if (!optionalReply.isPresent()) { return; } 
 builder.setEnable(TranslateUtils.byteToBoolean(lispStateOptional.get().featureStatus)); 
 try { dumpOptional = dumpManager.getDump(ctx.getModificationCache()); } catch (VppBaseCallException e) { throw new ReadFailedException(id, e); 
 .filter(n -> key.equals(new LocatorSetKey(TranslateUtils.toString(n.locatorSetName)))) 
 builder.setName(TranslateUtils.toString(data.locatorSetName)); } else { 
 if (mapResolverOptional.isPresent()) { LispMapResolverDetails details = mapResolverOptional.get(); 
 if (mapResolverOptional.isPresent()) { LispMapResolverDetails details = mapResolverOptional.get(); 
 dumpOptional = dumpManager.getDump(context.getModificationCache()); 
 /** * Extract bytes from string * * @throws NullPointerException in case of null rawString */ public static byte[] extractBytes(String rawString) { Preconditions.checkNotNull(rawString); return rawString.getBytes(); } 
 TranslateUtils.getReply(getFutureJVpp().lispAddDelLocalEid(request).toCompletableFuture()); } 
 TranslateUtils.getReply(getFutureJVpp().lispAddDelLocator(request).toCompletableFuture()); } 
 lispEnableDisable.isEn = TranslateUtils.booleanToByte(enable); 
 TranslateUtils.getReply(getFutureJVpp().lispPitrSetLocatorSet(request).toCompletableFuture()); } 
 public void readCurrentAttributes(@Nonnull InstanceIdentifier<Address> id, @Nonnull AddressBuilder builder, @Nonnull ReadContext ctx) 
 builder.setIp(TranslateUtils.arrayToIpv4AddressNoZone(detail.ip)) .setSubnet(new PrefixLengthBuilder() .setPrefixLength(new Byte(detail.prefixLength).shortValue()).build()); LOG.info("Address read successfull"); 
 //TODO add reading of isForwarding flag when there is dump for it LOG.warn("Operation not supported"); 
 .setPrefixLength(Short.valueOf(detail.prefixLength)).build()); 
 throw new ReadFailedException(id, e); 
 return new InterfaceKey(interfaceContext.getName(elt.swIfIndex, context.getMappingContext())); }) .collect(Collectors.toList()); 
 checkState(interfaceContext.containsIndex(interfaceName, mappingContext), "Mapping does not contains mapping for provider interface name ".concat(interfaceName)); 
 private void addDelNeighbourAndReply(boolean add, int parentInterfaceIndex, Neighbor data) 
 * Operational data read operation customizer for {@link Neighbor}<br> * Currently not supported in jvpp, so this is only dummy implementation<br> 
 checkArgument(id.firstKeyOf(Interface.class) != null, "No parent interface key found"); 
 checkArgument(id.firstKeyOf(Interface.class) != null, "No parent interface key found"); 
 * Operational data read operation customizer for {@link Neighbor}<br> * Currently not supported in jvpp, so this is only dummy implementation<br> 
 "Mapping does not contains mapping for provider interface name %s", interfaceName); 
<|del|> 
 private WriterRegistry.DataObjectUpdates toBindingAware( final Map<YangInstanceIdentifier, ModificationDiff.NormalizedNodeUpdate> biNodes) { 
 ModificationDiff.NormalizedNodeUpdate normalizedNodeUpdate = biEntry.getValue(); 
 return dataObject; 
 final Map<YangInstanceIdentifier, NormalizedNodeUpdate> merged = new HashMap<>(); 
 .isPresent(); 
 private static boolean isBeforeAndAfterDifferent(@Nonnull final DataTreeCandidateNode candidateNode) { 
/** * Special writer handling updates for nodes of type list. */ public final class GenericListWriter<D extends DataObject & Identifiable<K>, K extends Identifier<D>> extends 
/** * Special writer handling updates for any complex nodes. */ public final class GenericWriter<D extends DataObject> extends AbstractCompositeWriter<D> { 
 private void singleUpdate(@Nonnull final Multimap<InstanceIdentifier<?>, ? extends DataObjectUpdate> updates, @Nonnull final WriteContext ctx) throws WriteFailedException { 
 private static final class WriterRelation {} 
 // unregister is not supported in ModifiableWriterRegistry (not really needed though) 
 @Nullable private Writer<?> getWriter(@Nonnull final InstanceIdentifier<?> singleType) { 
 // TODO split configuration and translation code into 2 or more bundles 
 void init(@Nonnull ModifiableReaderRegistryBuilder registry); 
 public List<K> getAllIds(@Nonnull final InstanceIdentifier<C> id, @Nonnull final ReadContext ctx) 
/** * Generic list node writer with customizable behavior thanks to injected customizer. */ public final class GenericListWriter<D extends DataObject & Identifiable<K>, K extends Identifier<D>> extends 
/** * Generic writer with customizable behavior thanks to injected customizer. */ public final class GenericWriter<D extends DataObject> extends AbstractGenericWriter<D> { 
final class ReflexiveReaderCustomizer<C extends DataObject, B extends Builder<C>> extends NoopReaderCustomizer<C, B> { 
 // unregister not supported 
 private boolean shouldReadCurrent(@Nonnull final InstanceIdentifier<? extends DataObject> id) { 
 protected Reader<? extends DataObject, ? extends Builder<?>> getSubtreeHandler(@Nonnull final Set<InstanceIdentifier<?>> handledChildren, @Nonnull final Reader<? extends DataObject, ? extends Builder<?>> reader) { 
<|del|> 
<|del|> 
interface Ids { 
 public final InstanceIdentifier<D> getManagedDataObjectType() { 
 public interface DataObject1 extends DataObject { InstanceIdentifier<DataObject1> IID = InstanceIdentifier.create(DataObject1.class); 
<|del|> 
 LOG.warn("Failed to set gre tunnel for interface: {}, gre: {}", swIfName, dataAfter, e); 
 LOG.warn("Failed to readCurrentAttributes for: {}", id, e); 
<|del|> 
<|del|> 
 /** * Base interface for plugin's Java API. */ 
 if (pluginRegistry.putIfAbsent(name, callback) != null) { 
 final ControlPingCallback callback = (ControlPingCallback) pluginRegistry.get(clazz.getName()); 
 return jvpp.controlPing(this); 
public class EidMappingContext { 
<|del|> 
 * Retrieve name for mapping stored provided mappingContext instance. 
<|del|> 
<|del|> 
<|del|> 
 checkState(id.firstKeyOf(LocatorSet.class) != null, "Cannot find reference to parent locator set"); 
 //TODO currently ,creating locator-set does not return index of created locator-set,so therefore //there can be done loading of interfaces under specific customizer //can be done after https://jira.fd.io/browse/VPP-323 
 ShowLispStatusReply reply; 
 final Eid eid = localMappingContext.getEid(mappingId, ctx.getMappingContext()); 
<|del|> 
 private static String bindKey(String prefix) { 
 LOG.debug("Reading attributes for Locator Set {}", id); 
 LOG.warn("No dump present for Locator Set {}", id); 
 .filter(n -> keyName.equals(TranslateUtils.toString(n.locatorSetName))) 
 .build(); 
<|del|> 
<|del|> 
abstract class AbstractLispReaderFactoryBase { 
final class EidTableReaderFactory extends AbstractLispReaderFactoryBase implements ReaderFactory { 
 public static EidTableReaderFactory newInstance(@Nonnull final InstanceIdentifier<LispState> lispStateId, 
 public static String getArrayAsEidString( 
 public static boolean compareAddresses(Address firstAddress, Address secondAddress) { 
 request.locatorSetName = data.getLocatorSet().getBytes(UTF_8); 
<|del|>
 request.lsName = data.getLocatorSet().getBytes(UTF_8); 
abstract class AbstractLispWriterFactoryBase { 
<|del|> 
final class LocatorSetsWriterFactory extends AbstractLispWriterFactoryBase implements WriterFactory { 
 public static LocatorSetsWriterFactory newInstance( 
 public static MapResolversWriterFactory newInstance( 
 public static MapResolversWriterFactory newInstance( 
final class VniTableWriterFactory extends AbstractLispWriterFactoryBase implements WriterFactory { 
 sampleModules.add(new LispModule()); 
 map = new ConcurrentHashMap<>(); 
 public Optional<T> getDump(@Nonnull String entityKey, @Nonnull ModificationCache cache, final U dumpParams) 
 // binds and execute dump to be thread-save 
 final String interfaceRef = interfaceContext.getName(details.swIfIndex, ctx.getMappingContext()); 
 //TODO - to be totally reliable, resolve HONEYCOMB-201 
 //TODO - to be totally reliable, resolve HONEYCOMB-201 
<|del|> 
 //no need to check isPresent() - we are inside of address customizer, therefore there must be Address data //that is being processed by infrastructure subnetValidator.checkNotAddingToSameSubnet(ipv4Optional.get().getAddress()); 
<|del|> 
 this(futureJVppCore, interfaceContext, new SubnetValidator()); 
 //finds conflicting prefix final Short conflictingPrefix = prefixLengthRegister.keySet() .stream() .filter(a -> prefixLengthRegister.get(a).size() > 1) .findFirst() .get(); 
 //and reports it with affected addresses throw SubnetValidationException .forConflictingData(conflictingPrefix, prefixLengthRegister.get(conflictingPrefix)); } 
<|del|> 
<|del|> 
 private final JsonReader jsonReader; 
 * Must be implemented in Thread-safe fashion and return non-null data 
<|del|> 
<|del|> 
public class ContextsReaderFactory implements ReaderFactory { 
 * Utility class allowing {@link MappingId} to {@link Eid} mapping 
 return read.isPresent() && read.get().getMapping() .stream() .anyMatch(mapping -> compareEids(mapping.getEid(), eid)); 
 return read.isPresent() && read.get().getMapping() .stream() .anyMatch(mapping -> compareEids(mapping.getEid(), eid)); 
 LOG.debug("Read attributes for id {}", id); 
 .filter(detail -> compareAddresses(eid.getAddress(), getAddressFromDumpDetail(detail))) .collect(RWUtils.singleItemCollector()); 
 .map(detail -> getArrayAsEidLocal(valueOf(detail.eidType), detail.eid, detail.vni)) .map(localEid -> localMappingContext.getId(localEid, context.getMappingContext())) .map(MappingId::new) .map(LocalMappingKey::new) 
 resolverMappings(id, builder, details, ctx.getModificationCache()); 
 if (localEidsMappingContext.containsId(toLocalEid(localEid), writeContext.getMappingContext())) { 
 LOG.debug("Writing Id {} ", id); 
 * @returns If present in cache ,returns cached instance, if not, tries to dump data using provided executor, otherwise 
 throw new ReadTimeoutException(replyType, e); } catch (VppBaseCallException e) { throw new ReadFailedException(replyType, e); 
 final JVppSnatImpl jvppSnat = new JVppSnatImpl(); 
 // FIXME HONEYCOMB-248 VPP-459 Implement when read is available in VPP/Snat 
 * Get index for a stored mapping entry. 
 public static Set<Module> loadActiveModules(@Nonnull final List<String> moduleNames) { final ClassLoader classLoader = ActiveModuleProvider.class.getClassLoader(); 
 LOG.warn("Class {} is provided in modules configuration, but is not a Module and will be ignored", clazz); 
<|del|> 
 if (!handledTypes.containsAll(keylessIdentifiers(updates.keySet()))){ 
 System.out.printf("Received TraceProfileAddReply reply: context=%d%n", 
<|del|> 
 // Using finally instead of try-with-resources in order to leave ctx open for BulkUpdateException catch // block. The context is needed there, but try-with-resources closes the resource before handling ex. LOG.debug("Closing write context {}", ctx); 
 LOG.debug("Submit failed", e); 
 throw new WriterRegistry.Reverter.RevertSuccessException(e.getFailedIds()); 
 /** * Allows method parameters injection * */ 
 void init(@Nonnull DataBroker broker, @Nonnull InstanceIdentifier<O> id, @Nonnull ReadContext ctx) throws InitFailedException; 
 if (delegate instanceof Initializer) { LOG.trace("{}: Initializing current: {}", this, id); 
 abstract void setBuilderPresence(@Nonnull final B builder); 
 private static final class SnatInterfaceExecutor implements 
 ? super.build() 
 return Inbound.class; 
 return obj == NOT_PRESENT_INBOUND; 
 return Outbound.class; 
 return obj == NOT_PRESENT_OUTBOUND; 
public final class LoopbackCustomizer extends AbstractInterfaceTypeCustomizer<Loopback> implements MacTranslator, JvppReplyConsumer { 
 if (loopback.getMac() != null) { createLoopback.macAddress = parseMac(loopback.getMac().getValue()); } 
<|del|> 
 boolean isPresent(@Nonnull InstanceIdentifier<D> id, @Nonnull D built, @Nonnull ReadContext ctx) throws ReadFailedException; 
 assertEquals(DataObjects.DataObject1.IID, typesInList.get(0)); assertEquals(DataObjects.DataObject2.IID, typesInList.get(1)); 
 private static final class AdjacencyDumpParams { 
 assertThat(e.getUnrevertedSubtrees(), hasSize(2)); assertThat(e.getUnrevertedSubtrees(), hasItem(InstanceIdentifier.create(DataObject2.class))); assertThat(e.getUnrevertedSubtrees(), hasItem(InstanceIdentifier.create(DataObject1.class))); 
 assertThat(e.getUnrevertedSubtrees(), hasSize(2)); assertThat(e.getUnrevertedSubtrees(), hasItem(InstanceIdentifier.create(DataObject2.class))); assertThat(e.getUnrevertedSubtrees(), hasItem(InstanceIdentifier.create(DataObject1.class))); 
 // No need for any detailed message here, LeafRefDataValidationFailedException has // pretty detailed message, just wrapping it to be thrown as ancestor of TranslationException 
 * Utility class providing Ipv4/6 CUD support. 
 LOG.debug("Neighbour {} successfully written", id); 
 LOG.debug("Neighbour {} successfully deleted", id); 
 LOG.debug("Neighbour {} successfully written", id); 
<|del|> 
<|del|> 
 if (routingAttributes!= null && classifyTablePresent(routingAttributes.getClassifyTable(), getVppClassifierContextManager(), 
 if (routingAttributes != null && classifyTablePresent(routingAttributes.getClassifyTable(), getVppClassifierContextManager(), mappingContext)) { 
 final Collection<T> references) { 
 .map(iface -> Optional.ofNullable(iface.getAugmentation(VppInterfaceAugmentation.class)) .map(VppInterfaceAugmentation::getL2) .map(L2BaseAttributes::getInterconnection) .orElse(null)) 
 throws WriteFailedException { 
 return getReplyForDelete(getFutureJVppIoamexport() 
 request.srcAddress = ipv4AddressNoZoneToArray(ioamExport.getCollectorAddress().getValue()); request.collectorAddress = ipv4AddressNoZoneToArray(ioamExport.getSourceAddress().getValue()); 
public interface ReferenceCheck { 
 assertEquals(2, allIds.size()); assertEquals(ACL_IID.getKey(), allIds.get(0)); assertEquals(MACIP_ACL_IID.getKey(), allIds.get(1)); 
 return Integer.parseInt(Optional.ofNullable(jmxPort).orElse("1099")); 
<|del|> 
<|del|> 
 protected IpAddressReader(@Nonnull final NamingContext interfaceContext, final boolean isIpv6, @Nonnull final DumpCacheManager<IpAddressDetailsReplyDump, IfaceDumpFilter> dumpCacheManager) { super(interfaceContext, isIpv6); this.dumpCacheManager = dumpCacheManager; } 
 protected Optional<IpAddressDetailsReplyDump> addressDumpSupplier(@Nonnull final InstanceIdentifier<?> id, @Nonnull final ReadContext context) throws ReadFailedException { return dumpCacheManager.getDump(id, context.getModificationCache(), new IfaceDumpFilter(getInterfaceContext() 
 return getAllIpv4AddressIds(subInterfaceAddressDumpSupplier(id, ctx), AddressKey::new); 
 return getReplyForDelete(getFutureJVppIoamexport() 
final class ContainerNodeDataProcessor extends AbstractYangContextHolder implements YangDataProcessor { 
final class ListNodeDataProcessor extends AbstractYangContextHolder implements YangDataProcessor { 
final class YangDataProcessorRegistry { 
 static YangDataProcessorRegistry create(@Nonnull final SchemaContext context, 
 DataObject getNodeData(@Nonnull final YangInstanceIdentifier yangInstanceIdentifier, 
final class InjectionTestData { 
interface InitializationTest<D extends DataObject> { 
 LOG.debug("Proxy ARP was successfully enabled on interface {} (id={})", swIfName, swIfIndex); 
 LOG.debug("Proxy ARP was successfully disabled on interface {} (id={})", swIfName, swIfIndex); 
 int MPLS_LABEL_INVALID = 0x100000; 
 int MPLS_LABEL_INVALID = 0x100000; 
<|del|> 
 Lists.newArrayList(new ListInContainerKey(1L), new ListInContainerKey(2L))) { 
 // List<TargetType>, not Target type. If node is static list, addStructuralListReader should be used 
 this.staticKeys = checkNotNull(staticKeys, "Static keys cannot be null"); checkState(!this.staticKeys.isEmpty(), "No static keys provided"); 
 assertThat(allIds, contains(keyOne, keyTwo)); 
 .flatMap(content -> Arrays.stream(content.split("\n"))) 
 // TODO - HC2VPP-92 - Add more descriptive exception handling after https://jira.fd.io/browse/VPP-649 
<|del|> 
 package org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.vpp.classifier.rev161214; 
<|del|> 
<|del|> 
 // Acl(Structural) 
 // Ingress (execute after classify table and session writers) 
 * Copyright (c) 2016 Cisco and/or its affiliates. 
 checkArgument(dataAfter.getServer() != null && !dataAfter.getServer().isEmpty(), "At least one DHCP server needs to be configured"); 
 checkArgument(serversBefore != null && !serversBefore.isEmpty(), 
 checkArgument(dataBefore.getServer() != null && !dataBefore.getServer().isEmpty(), "At least one DHCP server needs to be configured"); 
 private void verifyComplexKey(final String key, final String params) { 
 checkState(references.isEmpty(), "%s cannot be removed, it is referenced in following interfaces %s", dataBefore, references); 
<|del|> 
 verify(aclApi, never()).aclDel(any(AclDel.class)); 
 } else { 
 synchronized (locatorSetContext) { if (!locatorSetContext.containsIndex(locatorSetName, ctx.getMappingContext())) { locatorSetContext.addName(set.lsIndex, locatorSetName, ctx.getMappingContext()); } 
<|del|> 
 // No need for any detailed message here, LeafRefDataValidationFailedException has // pretty detailed message, just wrapping it to be thrown as ancestor of TranslationException 
 private final DataTree dataTree; 
final class NormalizedNodeRewriteDeleteRegistry implements RewriteDeleteProducer { 
 registry.add(new GenericWriter<>(routingId, new SubInterfaceRoutingCustomizer(jvpp, ifcContext))); 
 protected RoutingCustomizer(@Nonnull final FutureJVppCore futureJVppCore, @Nonnull final NamingContext interfaceContext) { 
 protected void setRouting(@Nonnull final InstanceIdentifier<? extends RoutingBaseAttributes> id, @Nonnull final String name, 
 final WriteContext writeContext) throws WriteFailedException { 
abstract class RoutingCustomizer extends FutureJVppCustomizer implements JvppReplyConsumer { 
 protected RoutingCustomizer(@Nonnull final FutureJVppCore futureJVppCore, @Nonnull final NamingContext interfaceContext) { 
 protected void readInterfaceRouting(@Nonnull final InstanceIdentifier<? extends RoutingBaseAttributes> id, @Nonnull final Consumer<Long> v4VrfConsumer, @Nonnull final Consumer<Long> v6VrfConsumer, @Nonnull final ReadContext ctx, final String interfaceName) 
public final class MirroredInterfaceCustomizer extends SpanFutureJVppCustomizer 
 private boolean isAddressNotPresentForInterface(@Nonnull final InstanceIdentifier<Routing> id, @Nonnull final WriteContext ctx, boolean checkBefore) { 
 return true; 
 * Returns true if interface does not have v4/v6 addresses configured 
 augData.map(Interface1::getIpv4).map(Ipv4::getAddress).map(List::isEmpty).orElse(true); 
 * Returns true if interface does not have v4/v6 addresses configured 
 IPAddress normalizedForm = IPAddress.from(getAddress(prefix)).toSubnet(parseInt(suffix)); 
 @Nonnull Logger logger) { 
 IPAddress.from(getAddress(secondPrefixParts[0])).toSubnet(parseInt(secondPrefixParts[1])); 
 return Arrays.stream(vnis).boxed(); 
 default boolean isRegularInterface(@Nonnull final SwInterfaceDetails elt) { return !isSubInterface(elt); 
 builder.setTapName(toString(swInterfaceTapDetails.devName)); 
 result = 31 * result + Objects.hashCode(localEid); result = 31 * result + Objects.hashCode(remoteEid); 
 result = 31 * result + Objects.hashCode(localEid); result = 31 * result + Objects.hashCode(remoteEid); 
 .toInstance(new NamingContext("gpe-entry-", GPE_ENTRY_MAPPING_CTX)); 
 return addr == null || Arrays.equals(addr, new byte[addr.length]); 
 // TODO - HC2VPP-169 - use equals after resolving this issue 
 registry.add(new GenericListWriter<>(nativeEntryTableId, new NativeForwardPathsTableCustomizer(api))); registry.add(new GenericListWriter<>(nativeEntryTableId.child(NativeForwardPath.class), new NativeForwardPathCustomizer(api, interfaceContext))); 
 .filter(gpeNativeFwdRpath -> isFromFib(tableId, gpeNativeFwdRpath)) 
 .mapToLong(UnsignedInts::toLong) 
 .mapToLong(UnsignedInts::toLong) 
 int applicationModulesCount(){ return index.keySet().size(); } 
 LOG.debug("VPP FIB updated successfully with (added id={}).", id); 
 private static Set<String> readFromFolder(final URL folderUrl) { 
 final YangModuleMappingIndex index = new YangModuleMappingIndex("static-yang-index"); 
 * Copyright (c) 2017 Cisco and/or its affiliates. 
interface ResourceLoader { 
 } static URL fileToUrl(final File file) { try { return file.toURI().toURL(); } catch (MalformedURLException e) { throw new IllegalStateException(e); } } 
 return ImmutableSet.copyOf(index.get(moduleName)); 
 return new YangModules(activeModules.getActiveModulesClasses().stream() 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 return httpsConnector; 
 // connectors injected to make sure that server is started after they are added 
<|del|> 
 * Copyright (c) 2017 Cisco and/or its affiliates. 
 // if HTTP is disabled, null will be injected 
 // if HTTPS is disabled, null will be injected 
 } install(getConfigurationModule()); 
<|del|> 
 LOG.info("RESTCONF Jetty server successfully started"); 
 LOG.info("RESTCONF Jetty server successfully started"); 
 Main.init(new ActivationModule()); 
 Main.init(new ActivationModule()); 
 @Test(expected = IllegalStateException.class) 
 protected AclModule(@Nonnull final Class<? extends Provider<FutureJVppAclFacade>> jvppAclProviderClass) { 
 protected VppIoamModule(Class<? extends Provider<FutureJVppIoamtraceFacade>> jvppIoamTraceProvider, 
 protected NatModule(Class<? extends Provider<FutureJVppSnatFacade>> jvppSnatProvider) { 
 protected VppNshModule(Class<? extends Provider<FutureJVppNshFacade>> jvppNshProvider) { 
 * Index of java classes to relative absolute paths within repository. Used to generate Git links for binding classes of * VPP apis 
 return raw.substring(raw.indexOf(JAVA_SOURCE_FOLDER) + JAVA_SOURCE_FOLDER_NAME_LENGTH) 
 * Implementations of builder that collects handlers as they are bind 
<|del|> 
 public CoverageScanner(final Class<?> classToScan, final Operation.CrudOperation crudOperation, final Class<?> referenceClass) { this.classToScan = classToScan; this.crudOperation = crudOperation; this.referenceClass = referenceClass; 
 * Represents coverage data for single supported VPP binary api and its binding 
 private final VppApiMessage vppApi; 
 private final JavaApiMessage javaApi; 
 private CoverageUnit(final VppApiMessage vppApi, final JavaApiMessage javaApi, final List<YangType> yangTypes, final List<Operation> supportedOperations) { 
 private VppApiMessage vppApi; private JavaApiMessage javaApi; private List<YangType> yangTypes; private List<Operation> supportedOperations; 
 public CoverageUnit build() { 
 entrySubtreeId.child(LocatorPair.class)), 
<|del|> 
<|del|> 
 mapRegisterBuilder.setTtl(UnsignedInts.toLong(ttlRead.ttl)); 
 if (mapRegister.getTtl()!= null) { ttlRequest.ttl = mapRegister.getTtl().intValue(); } 
 final SwInterfaceDetails ifcDetails = dumpManager.getInterfaceDetail(id, ctx, key.getName()); if (!isInterfaceOfType( org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.v3po.rev170607.Tap.class, ifcDetails)) { 
 final SwInterfaceDetails ifcDetails = dumpManager.getInterfaceDetail(id, ctx, key.getName()); if (!isInterfaceOfType( org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.v3po.rev170607.VhostUser.class, ifcDetails)) { 
 LOG.debug("Interface {} not present in cached data, performing specific dump[{}]", interfaceName, 
<|del|> 
 @Nonnull final InterfaceCacheDumpManager dumpManager) { 
 request.isAdd = booleanToByte(isAdd); 
 request.isAdd = booleanToByte(isAdd); 
 final SwInterfaceDetails detail = reply.swInterfaceDetails.get(0); return detail; 
 final Map<String, SwInterfaceDetails> interfaceIndex = getMap(ctx); 
<|del|> 
 /** * Tells whether writer in this registry for provided type directly implements update method * * @param type data object type */ boolean writerSupportsUpdate(@Nonnull InstanceIdentifier<?> type); 
 /** * Tells whether writer in this registry for provided type directly implements update method * * @param type data object type */ boolean writerSupportsUpdate(@Nonnull InstanceIdentifier<?> type); 
<|del|> 
 final boolean supportsUpdate = !WriterCustomizer.class.equals(updateDeclaringClass); LOG.debug("Customizer {} update support : {}|Update declaring class {}", customizerClass, supportsUpdate, 
 if(writer == null){ writer = getSubtreeWriterResponsible(type); } return checkNotNull(writer, "Unable to find writer for %s", type).supportsDirectUpdate(); 
 if(writer == null){ writer = getSubtreeWriterResponsible(type); } return checkNotNull(writer, "Unable to find writer for %s", type).supportsDirectUpdate(); 
<|del|> 
 void processModifications(@Nonnull final InstanceIdentifier<? extends DataObject> id, @Nullable final DataObject dataBefore, @Nullable final DataObject dataAfter, @Nonnull final WriteContext ctx) throws WriteFailedException; 
 * Indicates whether nodes handled by this writer can be updated directly by using processModifications method , or 
 void processModifications(@Nonnull DataObjectUpdates updates, @Nonnull WriteContext ctx) throws TranslationException; 
<|del|> 
 * Process modifications and translate them as create/update/delete operations to lower level 
 // returns true to make higher level performance better(does not have to break updates to delete+create pairs) return true; 
 public void onShowVersionReply(final ShowVersionReply msg) { 
 Main.init(new ActivationModule()); 
 registry.subtreeAdd(Collections.emptySet(), new BindingBrokerWriter<>(InstanceIdentifier.create(ApplicationRib.class), dataBroker)); 
 return path.isDrop == 1 && isArrayZeroed(path.nextHop); 
 registry.subtreeAdd(ImmutableSet.of(TABLES_IID), new BindingBrokerWriter<>(InstanceIdentifier.create(ApplicationRib.class), dataBroker) ); 
 public Logger getLogger() { 
 protected abstract Logger getLogger(); 
 protected abstract Logger getLogger(); 
 getApplicationRibWriters().stream() .peek(aClass -> getLogger().debug("Binding writer factory {}", aClass)) .forEach(aClass -> applicationRibWritersBinder.addBinding().to(aClass)); 
 static final class TableTypeRegistration { 
 Set<Class<? extends WriterFactory>> getApplicationRibWriters(); 
public final class EidTableWriterFactory extends AbstractLispInfraFactoryBase implements WriterFactory { 
@State(Scope.Thread) /* * Control code runs on one jvm, benchmark runs on different one to have isolation * */ @Fork(1) /* * Measuring Maximum throughput of operations * */ 
<|del|> 
 flatWriterRegistry.processModifications(new WriterRegistry.DataObjectUpdates(updates, ImmutableMultimap.of()), ctx); 
 DataObject2.IID, ((DataObjectUpdate.DataObjectDelete) DataObjectUpdate.create(iid2, dataObject2, null))); flatWriterRegistry.processModifications(new WriterRegistry.DataObjectUpdates(ImmutableMultimap.of(), deletes), ctx); 
 } LOG.info("Received show version reply"); 
 testInvokeCounter(false, Integer.parseUnsignedInt(args[0])); 
 CompletableFuture<ShowVersionReply> replyFuture = jvpp.showVersion(request).toCompletableFuture(); 
 CompletableFuture<ShowVersionReply> replyFuture = jvpp.showVersion(request).toCompletableFuture(); 
@Timeout(time = 2) 
@Timeout(time = 2) 
 this.toBeReverted = toBeReverted; 
 } catch (IllegalArgumentException e) { return; 
 * Reverts changes that were successfully applied during update before failure occurred. Changes are reverted 
 * @throws UpdateFailedException in case update fails * @throws IllegalArgumentException if registry is unable to process provided update 
 } alreadyProcessed.add(singleUpdate); LOG.trace("Update successful for type: {}", writerType); LOG.debug("Update successful for: {}", singleUpdate); 
 @Test(expected = IllegalArgumentException.class) 
 @Test(expected = IllegalArgumentException.class) 
 final WriterRegistry.DataObjectUpdates revert = allUpdates.get(2); assertContainsOnlySingleUpdate(revert); 
 * @throws TranslationException in case update fails or there was some other problem while processing 
 * @throws TranslationException in case update fails or there was some other problem while processing 
<|del|> 
<|del|> 
 requests.put(pingId, replyCompletableFuture); 
 // reply received early, because we don't know callback to call // we wrap the reply and let the sender to call it 
 throw new IllegalStateException("Calling onControlPingReply in EarlyControlPingReply"); 
<|del|> 
 final CompletableDumpFuture<DUMP> replyDumpFuture; 
 if (requests.remove(pingId) == null) { 
<|del|> 
 Set<YangModelBindingProvider> getYangBindings() { 
 * Add a handler responsible for writing all complex nodes within a subtree its responsible for. 
 * Add a handler responsible for writing all complex nodes within a subtree its responsible for. 
 default boolean canProcess(@Nonnull final InstanceIdentifier<? extends DataObject> instanceIdentifier) { return getManagedDataObjectType().equals(instanceIdentifier); } 
 checkArgument(writer != null, "Unable to process update. Missing writers for: %s", 
<|del|> 
<|del|> 
 if (pathArgument.getType().equals(parent)) { return true; } 
<|del|> 
<|del|> 
 * @param count number of requests with which test should be run 
 private AfPacketDelete getDeleteAfPacketIfRequest(final int swIfIndex) { AfPacketDelete request = new AfPacketDelete(); // TODO // request.hostIfName = ; 
<|del|> 
 * Construct unique name from provided parentProtocolName and {@code Ipv4Prefix} 
 * Construct unique name from provided parentProtocolName and {@code Ipv6Prefix} 
<|del|> 
 * Checks whether FIB table with provided index exist in VPP 
 // TODO - remove isDrop condition https://jira.fd.io/browse/VPP-995 return path.isDrop == 1 && isArrayZeroed(path.nextHop); 
 return resolveFlags(getSpecialHopRequest(add, route.getDestinationPrefix(), (byte) parentProtocolTableId, DEFAULT_VNI), flagsVariant); 
<|del|> 
<|del|> 
 public static final InstanceIdentifier<Routing> ROUTING = InstanceIdentifier.create(Routing.class); public static final InstanceIdentifier<ControlPlaneProtocols> RT_CPS = ROUTING.child(ControlPlaneProtocols.class); public static final InstanceIdentifier<ControlPlaneProtocol> RT_CPS_CP = RT_CPS.child(ControlPlaneProtocol.class); 
 return classifierContextManager.getTableIndex(classifyTableName, mappingContext); 
 throw new IllegalStateException(format("Unable to load classname: %s", classname), e); 
 class FibTableDoesNotExistException extends Exception { public FibTableDoesNotExistException(final int index) { super(format("Fib table with index %s does not exist", index)); } } 
 fibTableService.write(instanceIdentifier, tableId, "Vrf-IPv4-" + tableId, false); fibTableService.write(instanceIdentifier, tableId, "Vrf-IPv6-" + tableId, true); 
 fibTableService.write(instanceIdentifier, tableId, "Vrf-IPv4-" + tableId, false); fibTableService.write(instanceIdentifier, tableId, "Vrf-IPv6-" + tableId, true); 
 // TODO(HC2VPP-334): We are using only one default FIB table for LocalSids defined in srv6.json configuration // file. When Fib Table management is implemented we need to use FIB table on per Sid basis. 
 registry.add(new GenericWriter<>(Srv6IIds.RT_SRV6, new Srv6Customizer())); 
 * Provides Endpoint function type class. 
 * Provides Endpoint function type class. 
 * Provide behavior function type integer value. 
 * Provide behavior function type integer value. 
 binders = new ArrayList<>(); 
 .filter(toLocalSidFunctionBinder -> toLocalSidFunctionBinder.canHandle(localSid)) .map(binder -> binder.createWriteRequestAndBind(localSid, ctx)) .collect(RWUtils.singleItemCollector()); 
<|del|> 
<|del|> 
<|del|>
 .ifPresent(detail -> bindLocalSid(detail, ctx, locatorKey.getName(), sidAddress, builder)); 
 Srv6FuncOpcodeUnreserved opcode = extractOpCode(sidAddress, readContext.getMappingContext(), locName); 
 * Manages metadata for SRv6 plugin 
 .setPathIndex(DEFAULT_PATH_INDEX) .setWeight(DEFAULT_WEIGHT) 
<|del|> 
<|del|> 
<|del|> 
 LOG.info("Starting FibManagementModule initialization"); 
 LOG.debug("Injecting FibManagementModule reader factories"); 
 LOG.debug("Injecting FibManagementModule reader factories"); 
 LOG.debug("Injecting FibManagementModule writers factories"); 
 LOG.info("FibManagementModule started successfully"); 
 public void delete(InstanceIdentifier<?> identifier) throws WriteFailedException { sendRequest(identifier, ByteDataTranslator.BYTE_FALSE); } private void sendRequest(final InstanceIdentifier<?> identifier, final byte isAdd) throws WriteFailedException { 
<|del|> 
 return values.length == 2 ? Long.parseLong(values[1]) : 0; 
 request.readAllIpPrefixes(RWUtils.cutId(instanceIdentifier, Prefixes.class), readContext); // checks whether L3 steering contains default routes to steer all traffic to SRv6 policy. If found sets // allPrefixes flag to true in autoroute-include/prefixes/state 
<|del|> 
 private AtomicLong distinguisher; 
<|del|> 
public final class Srv6Util { 
public final class Srv6Util { 
 public static <T extends DataObject> Ipv6Address extractBsid( final @Nonnull InstanceIdentifier<T> instanceIdentifier, final @Nonnull WriteContext writeContext, boolean isWrite) { 
<|del|> 
 } catch (ReadFailedException e) { 
 public void setSegments(final List<SidList> segments) { 
 return request; 
 return VPP_UNRESOLVED_TYPE; 
 final Set<InstanceIdentifier<?>> specificIfcTypes = Sets.newHashSet(vhostId, afpacketId, vxlanId, vxlanGpeId, tapId, loopbackId); 
 .filter(childIiD -> instanceIdentifier.getTargetType().equals(childIiD.getTargetType())) .anyMatch(instanceIdentifier1 -> isPathEqual(instanceIdentifier, instanceIdentifier1)); 
<|del|> 
 // TODO consider refactor based on implemented contract. 
 tapConnect.hostIfName = tapv2.getHostInterfaceName().getBytes(); 
 tapConnect.hostIfName = tapv2.getHostInterfaceName().getBytes(); 
 builder.setHostInterfaceName(toString(swInterfaceTapV2Details.devName)); 
 .setHostInterfaceName(readValue.getHostInterfaceName()) 
public class TapV2CustomizerTest extends WriterCustomizerTest implements Ipv4Translator, Ipv6Translator, MacTranslator { 
 final String mac = "ff:ff:ff:ff:ff:ff"; tapCustomizer.writeCurrentAttributes(getTapId("tap"), getTapData("tap", mac), writeContext); tapCustomizer.writeCurrentAttributes(getTapId("tap2"), getTapData("tap2", mac), writeContext); 
<|del|> 
 if (rxRingSz != null) { tapConnect.rxRingSz = rxRingSz.shortValue(); } 
 if (txRingSz != null) { tapConnect.txRingSz = txRingSz.shortValue(); } 
 setHostProperties(tapConnect, tapv2); 
 tapConnect.hostIp4Addr = ipv4AddressPrefixToArray(hostIpv4address); 
 tapConnect.hostIp4Gw = ipv4AddressNoZoneToArray(new Ipv4AddressNoZone(hostIpv4GW)); 
 tapConnect.hostIp6Addr = ipv6AddressPrefixToArray(hostIpv6address); 
 tapConnect.hostIp6Gw = ipv6AddressNoZoneToArray(new Ipv6AddressNoZone(hostIpv6GW)); 
 * @throws NullPointerException if vppPhysAddress.length < 6 or is null 
 } else { builder.setHostBridge(null); } 
 toString((swInterfaceTapV2Details.hostIp4Addr)), swInterfaceTapV2Details.hostIp4PrefixLen))); } else { builder.setHostIpv4Address(null); } 
 toString((swInterfaceTapV2Details.hostIp6Addr)), toJavaByte(swInterfaceTapV2Details.hostIp6PrefixLen)))); } else { builder.setHostIpv6Address(null); } 
<|del|> 
<|del|> 
 * @throws NullPointerException if vppPhysAddress is null * @throws IllegalArgumentException if vppPhysAddress.length < 6 
<|del|> 
<|del|> 
 InterfaceKey key = id.firstKeyOf(Interface.class); final int index = ifcNamingContext.getIndex(key.getName(), writeContext.getMappingContext()); enableDisableStatisticsNotifications(index, false); this.ifcStatisticsManager.disableInterface(index); 
 final String ifaceName = id.firstKeyOf(id.getTargetType()).getName(); 
<|del|> 
<|del|> 
<|del|> 
 public InterfaceStatisticsCollectionCustomizer(final NamingContext ifcNamingCtx, 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 .getDefaultInstance(currentTime.format(DateTimeFormatter.ofPattern(DATE_AND_TIME_PATTERN)))); 
 LOG.warn("Statistics notification error received.", e); 
<|del|> 
 TableKey key = new TableKey(Ipv4.class, new VniReference(0L)); Table data = tables.getTable().stream().filter(table -> table.key().equals(key)).findAny().get(); 
 TableKey key = new TableKey(Ipv6.class, new VniReference(0L)); Table data = tables.getTable().stream().filter(table -> table.key().equals(key)).findAny().get(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private Connection openConnection() { 
 private Connection openConnection() { 
 private Connection openConnection() { 
 private Connection openConnection() { 
 // TODO deal with the exception 
 statement.close(); connection.close(); } catch (SQLException e) { // TODO deal with the exception 
<|del|> 
<|del|>
 protected void unregSwitch(boolean synch) { 
 //the -1 is for beacon... 
 psw.register(); OVXSwitch vsw = new OVXSingleSwitch(vswId, tid); try { 
 //Test: before unregister before=psw.map.hasVirtualSwitch(psw, tid); 
 vlink.register(); vlink2.register(); vp.boot(); pp.setOVXPort(vp); vp2.boot(); pp2.setOVXPort(vp2); try { 
import android.view.Menu; import android.view.MenuInflater; import android.view.MenuItem; import android.view.View; import android.view.Gravity; 
 private final Integer hashSize; 
<|del|> 
 public synchronized void removeSwitch(final long ovxDpid) { 
 if (this.mFilter.isEmpty()) { 
<|del|>
 private OnMapReadyListener mOnMapReadyListener; 
 if (mOnMapReadyListener != null){ mOnMapReadyListener.onMapReady(); } 
 } obtainCoordinates(providerName); 
 public final double getLatitude() { 
 throw new IllegalStateException("SQL Error: " + e); 
 throw new IllegalStateException("SQL Error: " + e); 
 if (persistenceType == SSL_ID && 
 Assert.assertEquals(SessionPersistence.SSL_ID.name(), 
 Assert.assertEquals(SessionPersistence.SSL_ID.name(), 
 } else if (!loadBalancer.getProtocol().equals(HTTP) && !loadBalancer.getProtocol().equals(HTTPS)) { dbLoadBalancer.setContentCaching(false); if ((dbLoadBalancer.getSessionPersistence() == SessionPersistence.SOURCE_IP)) { 
<|del|> 
 * 
 * 
 entry.setContent("Details: " + event.getDetailedMessage() + "\nCallback Host: " + event.getCallbackHost()); 
 Pattern addressRegex = Pattern.compile("^(https?://)?(www.)?(\\S+)(:\\d+)$"); 
 String message = "Unable to find an valid IP address or domain name."; LOG.warn(message); throw new BadRequestException(message); 
 mLatitude = latitude; 
 mLongitude = longitude; 
 double latitude = 0.d; double longitude = 0.d; 
 // try to grab address using domain parsing 
import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.EditText; import android.widget.ListView; 
 if(!mSelectedItems.contains(item)) { mSelectedItems.add(item); }else{ mSelectedItems.remove(item); } 
import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.EditText; import android.widget.ListView; 
<|del|> 
 public final Cursor getAddress(String rowId, String[] columns) { 
 public final Cursor getWordMatches(String query, String[] columns) { 
 private ListMode mATMListFragment = null; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 mCurrentValue = getPersistedInt(mDefaultValue); 
 mNumberPickerMain.setMaxValue(values.length - 1); 
 mNumberPickerMain.setValue(mCurrentValue / 1000); 
 public static void mainn(String[] args) { // Cos tu zrobic //cos znowu dopisuje } 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 mDatabaseAdapter = new DataBaseAdapter(getContext()); 
<|del|> 
 if(command.hasSelectedFileKeyword() && selectedFiles.size() == 0) 
import com.google.common.util.concurrent.Service; import com.google.inject.AbstractModule; 
 * Configure the maven setup needed for setting persistence in HCP 
<|del|> 
<|del|> 
 * @return true/false, depending on whether or not setup for remote persistence is available 
 * @return true/false, depending on whether or not setup for remote persistence is available 
 * Configure the maven setup needed for local persistence * * TODO Expand the API to fully support addon's options 
<|del|> 
// TODO - Move string to constants 
// TODO - see if needed and if so generalize Validate.notNull(fileManager, "FileManager is required"); 
<|del|> 
<|del|> 
 TaskPresenter taskPresenter = new TaskPresenter(0, MainView.getInstance().getWorkflowPresenter().getBucketPresenterById(1), ViewMode.CREATING); 
<|del|> 
 log.info("Starting Topology API client for {}:{}", host, port); 
 log.warn("Topology API client start interrupted"); 
 log.warn("Topology API client stop interrupted"); 
 out.add(new BinaryWebSocketFrame(data.copy())); // TODO: check if data reference counter can be decreased safely 
 out.add(new BinaryWebSocketFrame(data.copy())); // TODO: check if data reference counter can be decreased safely 
 out.add(new BinaryWebSocketFrame(data.copy())); // TODO: check if data reference counter can be decreased safely 
 * Extract a binary byte buffer from a binary websocket frame. * Note: this is intended for extracting a binary encoded protocol buffer * message from a binary websocket frame, but it should work for any other * binary frame content. 
<|del|> 
 pipe.addLast(new HttpObjectAggregator(65536)); 
 log.warn("Topology API server stop interrupted"); 
 * ID of the existing task. * @param taskPresenter * taskPresenter associated with the task 
 * The miniView associated with the task being added 
 createInDatabase(); saveView(); updateView(); //bucket.addMiniTaskView(miniView); 
 view.setStatus(model.getStatus()); System.out.println("view index" + model.getStatus()); 
<|del|> 
<|del|> 
 Double suma, roznica, sumaKwadratow; 
 int szerokoscDzialki = IOHelper.readInt(); 
 double cenaMetraSiatki = IOHelper.readDouble(); 
 double cenaSlupka = IOHelper.readDouble(); 
 System.out.println("rozliczenie za metr kwardatowy (z) = " + kosztGrzaniaZa1Metr); 
 public void removeUserFromAssignedTo(User user) { 
<|del|> 
<|del|> 
 public static void removeDependency(ProjectOperations projectOperations, String moduleName, String groupId, String artifactId) { 
 AwaitableObserver<PojoChain> sub = subscribe(PojoChain.class, chain.id, 1); sub.await(ONE_SECOND, 0); 
 Collection<UUID> unlinkedPortIDs; 
 * @param presenter * Taskpresenter * @param req * The requirement 
 /** * @return returns the panel that requirements are on */ 
import java.util.List; import java.util.Map; 
 List<Long> hourKeysList = new ArrayList<Long>(); 
 } catch (NumberFormatException ex) { // This non number directory will not contain an LZO so skip it. 
 Long daysAgoLimit = StaticDateTimeUtils.dateTimeToHourLong( 
 long blockSize = (long) HadoopLogsConfigs.getHdfsBlockSize() * 1024L*1024L; 
 * @author thefloorisjava 
 @ConfigInt(key = "control_packets_tso", defaultValue = 46 << 2 /* Expedited Forwarding*/) public int getControlPacketsTso(); 
 HttpMethod.GET); 
 ViewEventController.getInstance().editRequirement(reqMap.get(view.getRequirementIndex()-1)); 
 * This calls something to add requirement to the related requirement field * @param listener The listener to be added to the ComboBox 
 * This calls something to open the requirement tab * @param listener The listener to open the requirement tab 
 * @return Index of requirements in the requirementComboBox 
 * @param requirementIndex the Index of the requirement in the requirementComboBox 
 * add a requirement to the reuqirementComboBox * @param req * the requirement item 
 HttpMethod.GET); 
 * This calls something to add requirement to the related requirement field * @param listener The listener to be added to the ComboBox 
 * @return Index of requirements in the requirementComboBox 
 * @param requirementIndex the Index of the requirement in the requirementComboBox 
 * add a requirement to the reuqirementComboBox * @param req * the requirement item 
<|del|> 
 /** * Removes miniTaskView from BucketView * @param miniTaskView miniTaskView to be removed */ public void removeTaskView(MiniTaskView miniTaskView){ 
/** * Removes miniTaskView from BucketView 
<|del|> 
 * representation of the color object. * @return string * the English string of the color object 
 /** * updates this miniTaskView's color label with the color from this MiniTaskView's Model. * paints null if the user selected no label. */ 
 bb.position(start + 16); // IP's length field offset (14 + 2) 
 final ElasticData elasticData = getCore(); 
 public ElasticData getCore() { 
<|del|> 
 * @author thefloorisjava 
 * makes a call to add requirement to the related requirement field 
 case GET: presenter.writeModelToView(); break; case POST: presenter.responsePost(model); break; case PUT: presenter.responsePut(model); break; case DELETE: presenter.responseDelete(model); break; } 
 } /** * @return the color of the current label. */ public Color getLabelColor() { return (Color) colorComboBox.getSelectedItem(); } 
<|del|> 
 @ConfigBool(key = "cluster_enabled", defaultValue = false) public Boolean getClusterEnabled(); 
 public int serialize(ByteBuffer bb) { int length = getLength(); bb.put(data, 0, length); return length; 
 private static byte[] cachedFlowStateEthernetHeader = null; 
 if (cachedFlowStateEthernetHeader == null) { 
<|del|>
 /**indicates if archived tasks are shown 
 /**set if archived tasks are shown * @param showArchived indicates if archived tasks are shown 
 } }); 
 * @return return the help view 
 } 
 * serialVersionUID */ 
<|del|> 
<|del|> 
 /** * Adds a help Tab into the MainView */ 
 zaliczka = (5 * cenaCieplejWody + 8 * cenaZimnejWody) * liczbaOsob; 
 zaplata = zaplata * (-1); System.out.println("Nadpata wynosi: " + zaplata); 
 /** * this function sets the color to be allowed on the view * * @param filterColor * to change to 
 * @return return the help view 
<|del|> 
 import java.awt.event.ActionEvent; 
 * @param subject The new subject of the message 
 * @param content The text of the message itself 
 * @param recipients The list email addresses to notify 
 MockData db; Session defaultSession; Project testProject; User testUser; 
 assertEquals("test 3", manager.getEntity(defaultSession, "3")[0].getTitle()); 
 FlowTagger.FlowTag tag = traversedDeviceTag(); return tag == null || traversedDeviceInv ^ pktCtx.flowTags().contains(tag); 
 /** * Constructs a BucketPresenter for the given model. * * @param model * @param workflow */ public BucketPresenter(BucketModel model, WorkflowPresenter workflow) { this.model = model; this.workflow = workflow; } /** 
 public BucketPresenter getBucket(int id) { return bucketPresenters.get(id); } /** 
 }); /* 
 * Create the panel. * @param model The workflow model this panel will take information from. 
<|del|> 
<|del|> 
 public BucketPresenter getBucket(int id) { return bucketPresenters.get(id); } /** 
 * Add a task to the model at the index. * @param index the position where the task will be added 
 public void responseGet(BucketModel[] models) { if (models[0].getId() == 0) return; this.model = models[0]; 
 @Override public void removeUpdate(DocumentEvent e) { validateField(); } @Override public void insertUpdate(DocumentEvent e) { validateField(); } @Override public void changedUpdate(DocumentEvent arg0) { validateField(); } }; 
 private static final long serialVersionUID = 8216327558633962233L; private JLabel filterLabel = new JLabel(Icons.FILTER); 
 /** * Constructs view contain all filters */ 
 titleHolderPanel.setBorder(new LineBorder(Color.BLACK)); 
 /** * set Filter View to collapsed view, hides filters */ 
 /** * Expands filter view showing all filters */ 
 /** * Gives filters operations */ 
 /** * revalidates and repaints the history Panel */ 
 host.getName(), new ArrayList<ExtraDhcpOpt>()); 
 this(mac, ip, name); Preconditions.checkNotNull(extraDhcpOpts, "Extra DHCP options should not null. Use empty list " + "instead to express absense of it."); 
 "application/vnd.org.midonet.collection.DhcpHost-v2+json"; 
 "application/vnd.org.midonet.collection.DhcpHost-v2+json"; 
 @Nonnull protected List<ExtraDhcpOpt> extraDhcpOpts = new ArrayList<>(); 
 public LinkedHashMap<FlowMatch, ManagedWildcardFlow> dpFlowTable = 
 FlowMatch match = flow.getMatch(); 
 FlowMatch flowMatch = new FlowMatch().addKey(FlowKeys.tunnel(10L, 100, 200)); 
 System.out.print("Podaj warto zmiennej x: "); float x = IOHelper.readInt(); System.out.print("Podaj warto zmiennej y: "); float y = IOHelper.readInt(); 
 float a, b, c, z; 
 zk.add(paths.getHostPath(hostIdentifier), null /*data*/, CreateMode.PERSISTENT); 
 host.getName(), host.getExtraDhcpOpts()); 
 "application/vnd.org.midonet.collection.DhcpHost-v2+json"; 
 "application/vnd.org.midonet.collection.DhcpHost-v2+json"; 
 @ConfigInt(key = "control_packets_tos", defaultValue = 46 << 2 /* Expedited Forwarding*/) public int getControlPacketsTos(); 
 public final static short FLOW_STATE_IP_FRAGMENT_OFFSET = (short) 0; // TODO(tfukushima): Get the accurate TTL and use it if possible. public final static byte FLOW_STATE_IP_TTL = (byte) 64; 
 public final static short FLOW_STATE_IP_FRAGMENT_OFFSET = (short) 0; // TODO(tfukushima): Get the accurate TTL and use it if possible. public final static byte FLOW_STATE_IP_TTL = (byte) 64; 
 deserializedFlowStateEthenet)); 
<|del|> 
<|del|> 
 if (ctx.embed()) { log.info("Stopping embedded Cluster service for node {}", ctx.nodeId()); 
<|del|> 
 * Copyright 2015 Midokura SARL 
 VxLanGatewayService s = new VxLanGatewayService(nodeCtx, dataClient, vtepDataClientFactory, zkConnWatcher); 
 log.debug("Lazy update of Bridge schema: existing VTEP" + "binding migrated to new schema in {}", bridgeId); 
<|del|> 
<|del|> 
 log.debug("VTEP bindings on bridge {} changed, ports to VTEP were " + " {}, now: {}", id, oldConfig.vxLanPortIds, newConfig.vxLanPortIds); 
 log.debug("Bridge {} does not any port towards VTEP, ignoring", id); 
<|del|> 
 } 
 ", vxLanPortIds=" + vxLanPortIds + 
 if (vxlanPortIds.isEmpty()) { 
 public int getDhcpMtu(); 
 * Copyright 2015 Midokura SARL 
 throw TraceRequiredException.instance(); 
 private void updateLogicalPorts( 
 * Copyright 2014 Midokura SARL 
 public int getDhcpMtu(); 
 public LinkedHashMap<FlowMatch, ManagedFlow> dpFlowTable = new LinkedHashMap<>((int)maxDpFlows); 
<|del|> 
 if (port.getHostId() != null && port.getHostId().equals(hostIdentifier)) { 
 public ZookeeperConnectionModule(Class<? extends ZkConnectionAwareWatcher> connWatcherImpl) { 
 private final int id; 
 bind(VxlanGatewayService.class).asEagerSingleton(); 
 doReturn(true).when(lock).acquire(anyLong(), any(TimeUnit.class)); 
 pktCtx.enableTracing(requestId); 
 public Rule(Condition condition, Action action, UUID chainId, int position) { 
 bind(InterfaceDataUpdater.class).to(DefaultInterfaceDataUpdater.class); 
 } for (McastMac mc : mcasts) { if (mc.mac.equals(ml.mac().toString())) { log.debug("MCAST remote MAC already in vtep"); return; } } 
 super(condition, null); 
<|del|> 
 super(condition, null); 
 // Create an outer message builder with nested builder. 
 public Class<? extends Rule> getType(Topology.Rule proto) { 
<|del|> 
<|del|> 
 @ZoomClass(clazz = Topology.Rule.class, factory = NatRule.NatRuleFactory.class) 
 "class: " + getClass() + " to a protocol buffer is not " + 
<|del|> 
 timer.scheduleAtFixedRate(tick, 0, intervalMillis); 
 return Response.status(Response.Status.OK).entity(rLbDetails).build(); 
 rProtocol.setProtocol(LoadBalancerProtocolType.TCP.name()); 
<|del|> 
 assertEquals(pojo, convertedPojo); 
<|del|> 
<|del|> 
public class Chain implements VirtualDevice { 
 public void setLoadBalancer(UUID lbID) { loadBalancerId = lbID; 
 public static class NatRuleFactory implements ZoomConvert.Factory<NatRule, Topology.Rule> { 
 // Ignored by ZoomConvert. 
 " must have its boolean dnat set"); 
 UUID newId = modify(client, plTable, op).result(Duration.Inf()); 
 query(client, plSetTable, cond).result(Duration.Inf()); 
 UUID newId = modify(client, plSetTable, op).result(Duration.Inf()); 
 new Observable.OnSubscribe<MacUpdate>() { 
 UcastMacUpdate.apply( null, (UcastMac)mac)); 
 McastMacUpdate.apply( null, (McastMac)mac)); 
 PhysicalLocator loc = PhysicalLocator.apply(ip); PhysicalLocator pl = backend.createPhysicalLocator(loc); 
 UcastMacUpdate update) { 
 * Common schema sections for the {Ucast|Mcast}Mac{Local|Remote} tables 
<|del|> 
 * Returns all destination IP addresses that share the same prefix to the * given invalidation trie node. 
 * destination IP addresses that share the same prefix represented by this * node, and should be invalidated when the route has changed. 
 return new IPv4Subnet(value.getAddress(), value.getPrefixLength()) .getIntAddress(); 
 UUID traceRequestCreate(@Nonnull TraceRequest traceRequest) 
import org.midonet.midolman.state.zkManagers.RouterZkManager.RouterConfig; import org.midonet.midolman.state.zkManagers.TraceRequestZkManager.TraceRequestConfig; 
 List<Op> ops = new ArrayList<>(); 
 List<Op> ops = new ArrayList<>(); 
 * Returns all destination IP addresses that share the same prefix to the * given invalidation trie node. 
 gameManager = new GameManager(); gameManager.setEndGameListenner(this); if (onePersonMod) { 
 List<Player> players = new ArrayList<Player>(2); int level = 0; 
 private Button btn_go, btn_game_2, btn_nsd; 
 } catch (NoSuchAlgorithmException e) { } 
 * Returns all destination IP addresses that share the same prefix of the 
 return IPv4Addr.apply(value.getAddress()).toInt(); 
 @Produces({ VendorMediaType.APPLICATION_TRACE_REQUEST_COLLECTION_JSON, 
 @Produces({ VendorMediaType.APPLICATION_TRACE_REQUEST_JSON, 
 @Consumes({ VendorMediaType.APPLICATION_TRACE_REQUEST_JSON, 
 * Copyright 2014 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * rtnetlink Address resource representation. 
 * rtnetlink Neighbour resource representation. 
<|del|> 
 private void drawLine(Canvas canvas, Point startingPoint, Point endingPoint) { 
 private void drawMultiPolygon(Canvas canvas, Multipolygon multipolygon) { 
<|del|> 
<|del|>
 return ((this.vertex1.equals(((Edge) o).vertex1) && this.vertex2.equals(((Edge) o).vertex2)) || (this.vertex1.equals (((Edge) o).vertex2) && this.vertex2.equals(((Edge) o).vertex1))); 
<|del|> 
 private double distance, edgeMultiplier; 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 public Level getLevel(float floor){ for(Level lev : levels) { if(lev.getCurrentLevel() == floor){ return lev; 
 public Level getLevel(float floor){ for(Level lev : levels) { if(lev.getCurrentLevel() == floor){ return lev; 
 private ArrayList<Road> roads; 
 public Crossing(long id, ArrayList<Road> roadsList, Point crossPoint) { super(id, crossPoint); roads = new ArrayList<>(roadsList); 
 private float currentLevel; 
 case MAP_SET_TERRAIN: 
 case MAP_SET_TERRAIN: 
 case MAP_SET_SATATELITE: 
 case CATEGORIES_FILTER: showFilterCategoriesDialog(); 
 case OPTIONS: break; case HELP: break; default: break; 
 public void addMarkerFromFormData() { if(areFormFieldsNull()) { throw new NullPointerException("Marker form fields are null"); } 
 FragmentTransaction _f_transaction = getFragmentManager().beginTransaction(); DialogFragment _f_dialog = (DialogFragment)getFragmentManager().findFragmentByTag("FormDialog"); if(_f_dialog != null) { _f_transaction.remove(_f_dialog); 
 private void showFilterCategoriesDialog() { FragmentTransaction _f_transaction = getFragmentManager().beginTransaction(); DialogFragment _f_dialog = (DialogFragment)getFragmentManager().findFragmentByTag("FilterDialog"); if(_f_dialog != null) { _f_transaction.remove(_f_dialog); 
<|del|> 
<|del|> 
 NetlinkMessage.scanAttributes(buf, addr); return addr; } catch (BufferOverflowException ex) { return null; } 
 } catch (BufferOverflowException ex) { return null; 
 } catch (BufferOverflowException ex) { return null; 
 if (rtm.family == Addr.Family.AF_INET) { if (buf.remaining() == 4) { buf.order(ByteOrder.BIG_ENDIAN); this.dst = IPv4Addr.fromInt(buf.getInt()); } 
 NetlinkMessage.writeRawAttribute(buf, Attr.RTA_DST, dst.toBytes()); 
 private void prepareToNewMarker() { 
 void setLongClickListener(); void showToastMarkerInfo(); 
<|del|> 
 public void enableLongClickListener() { 
<|del|> 
 mapper = new GeometryStyleMapper(objects, this, context); 
<|del|> 
<|del|> 
<|del|> 
public class RendererTestActivity extends Activity implements View.OnClickListener{ private MapView mapView; private GeometryRenderer renderer; private ImageButton butPlus; private ImageButton butMinus; private ImageButton butUp; private ImageButton butDown; private int mapLevel = 0; 
 System.out.println("Dann was anderes.. "); 
 nextHop, nextHopPort, nextHopGateway, weight, attributes, routerId, false /* learned */); 
 ArrayList<Polygon> polygons = new ArrayList<>(); polygons.add(new Polygon(points)); MapObject obj = new Building(1234, new Multipolygon(polygons)); 
<|del|> 
 System.out.println("Dann was anderes.. "); 
@Resource(name = ResourceUris.BRIDGES) 
 private int readLittleEndianIntFromStdin() throws Exception { 
<|del|> 
 private HashMap<Long, Node> nodesMap = new HashMap<>(); private HashMap<Long, Way> waysMap = new HashMap<>(); private HashMap<Long, Relation> relationsMap = new HashMap<>(); 
 public Way getWay(Long id) { return waysMap.get(id); } public Relation getRelation(Long id) { return relationsMap.get(id); } 
 static private Map<String, String> buildMap(JSONObject jObj, String name) { 
 public OSMData fetchDataWithinRadius(double latitude, double longitude, double radius) { 
 } Map<String, String> tagMap = buildMap(tempJSONOBject, TAGS); osmData.addRelation(relationsId, new Relation("relation", relationsId, tagMap, relationsMembers)); break; default: break; 
<|del|> 
public class Relation extends OSMElement { 
<|del|> 
<|del|> 
 if (this.checkTag(key, value)) { 
 if (tempWay.checkTagFromArray("highway", HIGHWAY_TAGS)) { 
 @Override 
 protected java.util.UUID parseLocatorSet(Row<GenericTableSchema> row) { 
 private ColumnSchema<GenericTableSchema, String> getEncapsulationSchema() { 
 static public Condition getDstIpMatcher(IPv4Addr value) { 
 * Extract the physical locator information from the table entry 
<|del|> 
 private String parseName(Row<GenericTableSchema> row) { 
 protected java.util.UUID parseUuid(Row<GenericTableSchema> row) { 
<|del|> 
 //sprawdzanie czy w danym miejscu wystpuje przejcie dla pieszych 
 static public Condition getIpaddrMatcher(IPv4Addr ip) { 
 static public Condition getLocatorMatcher(java.util.UUID locId) { 
 static public Condition getDstIpMatcher(IPv4Addr value) { 
<|del|> 
 static public Condition getManagementIpsMatcher(IPv4Addr value) { 
<|del|> 
 static public Condition getUuidMatcher(java.util.UUID value) { 
 String input; 
<|del|>
<|del|> 
<|del|> 
 return Response.status(200).entity("Operacja dodania uzytkownika nie powiodla sie").build(); 
 } 
 System.out.println("Wystapil problem z zamknieciem bazy danych"); 
 if (tempWay.checkTagFromArray("highway", HIGHWAY_TAGS)) { 
 @ZoomField(name = "network_id", converter = UUIDUtil.Converter.class) 
 @ZoomField(name = "floating_ip_address", converter = IPAddressUtil.Converter.class) 
 @ZoomField(name = "fixed_ip_address", converter = IPAddressUtil.Converter.class) 
 @ZoomField(name = "ip_address", converter = IPAddressUtil.Converter.class) 
 @ZoomField(name = "gateway_ip", converter = IPAddressUtil.Converter.class) 
 @ZoomField(name = "address", converter = IPAddressUtil.Converter.class) 
 @ZoomField(name = "address", converter = IPAddressUtil.Converter.class) 
 for (Road road : roads) { LineString geometry = (LineString) road.getObjectGeometry(); 
 another file for demo. % 
 /** * Stock is a class for creation of stock objects in CA05 * @author Matt M. Kara B. * @version 1.0 * @since 4/24/15 23:00 */ 
<|del|> 
<|del|>
 /** * SellOrder does stuff */ 
ted market.java content.... void main(){ } 
Pasted market.java content.... 
 void main(){ 
<|del|> 
 ArrayList<Order> buyOrderList = new ArrayList<Order>(); buyOrderList.add(order); buyOrders.put(order.getStockSymbol(), buyOrderList); 
<|del|> 
 //Performs trade on the buy and sell orders and finds the matching price 
 //Performs trade on the buy and sell orders and finds the matching price 
 int priceIndex = 0; 
 int flagForDuplicatePrice = 0; 
 for(Order traderPosition: position){ if(traderPosition.getStockSymbol().equals(o.getStockSymbol())){ if(o.getSize() < traderPosition.getSize()){ traderPosition.setSize(traderPosition.getSize() - o.getSize()); 
<|del|> 
 ArrayList<Order> tempOrders = sellOrders.get(order.getStockSymbol()); tempOrders.add(order); sellOrders.put(order.getStockSymbol(), tempOrders); 
 Set<String> stockKeys = stockList.keySet(); String[] stocks = stk.toArray(new String[stockKeys.size()]); 
ted market.java content.... void main(){ } 
ted market.java content.... void main(){ } 
<|del|> 
 Order order = buySorted.get(i); if (buyOrder.getSize() <= sellVolume) { buyOrders.get(order.getStockSymbol()).remove(order); sellVolume -= order.getSize(); 
 Order order = sellSorted.get(i); sellOrders.get(order.getStockSymbol()).remove(order); 
 ArrayList<Double> marketTradeInformation = new ArrayList<Double>(); 
<|del|>
 //This goes through every order and calculates an ideal trade balance. It then executes that trade. 
 try { //access this order's trader and call the tradePerformed method to indicate that a trade has been performed. 
 /** * Adds orders to the appropriate buyOrders or sellOrders lists. * * @param order The order to be added to the OrderBook. */ 
 /** * Goes through every order and calculates an ideal trade balance. It then executes that trade. * */ 
<|del|> 
<|del|> 
<|del|> 
 int priceIndex = 0; 
 ArrayList<Order> ownedStocks; 
 private ISubject stockMarketSubject; Market market; 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 int priceIndex = 0; 
 for ( int x = 0 ; x <= priceIndex-1 ; x++){ 
 private ISubject stockMarketSubject; Market market; 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
<|del|>
 Market market; 
<|del|> 
 flagForDuplicatePrice = 1; 
 // Create 14 traders 
/** * An abstract class needed so that buy and sell orders can be stored in the same data structure. * * @author Kyle Doud and Garrett McCaffrey */ 
<|del|> 
 public final static byte FLOW_STATE_IP_FLAGS = (byte) 0x02; 
 return Response.serverError().entity("Brakuje odpowiedniej funkcji w bazie danych").build(); 
 return Response.serverError().entity("Wystapil nieznany blad").build(); 
 return Response.status(httpCode).entity("Operacja dodania zgloszenia nie powiodla sie").build(); 
 for(Order traderPosition: position){ if(traderPosition.getStockSymbol().equals(o.getStockSymbol())){ if(o.getSize() < traderPosition.getSize()){ traderPosition.setSize(traderPosition.getSize() - o.getSize()); 
<|del|> 
<|del|>
 Order order1 = buySorted.get(i); if (order1.getSize() <= sellVolume) { buyOrders.get(order1.getStockSymbol()).remove(order1); sellVolume -= order1.getSize(); 
 Order order2 = sellSorted.get(i); sellOrders.get(order2.getStockSymbol()).remove(order2); 
<|del|> 
<|del|> 
<|del|> 
<|del|>
 for(Order traderPosition: position){ if(traderPosition.getStockSymbol().equals(o.getStockSymbol())){ if(o.getSize() < traderPosition.getSize()){ traderPosition.setSize(traderPosition.getSize() - o.getSize()); 
 String name; 
 Stock removedStock = removeStockFromStockList(symbol); removedStock.setPrice(newPrice); addStock(removedStock); 
 public void printStockHistory(String symbol) { 
 Market market; 
<|del|> 
 int supplyCount = 0; int demandCount = 0; while (supplyCount < supply.size()) 
 Order tempOrder = orders.get(j); 
 for (Order o : ownedStocks) { 
 Stock stockToBeUpdated = removeStockFromStockList(symbol); stockToBeUpdated.setPrice(newPrice); addStock(stockToBeUpdated); 
 private ISubject stockMarketSubject; Market market; 
 this.market = m; 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
public class Trader { // Name of the trader 
<|del|> 
 for (int y=0; y<priceIndex-1;y++){ for (int x = 0; x < priceIndex-1-y; x++){ 
 int flagForMatchPrice = 0; for ( int x = priceIndex-1 ; x >=0 ; x--){ 
<|del|>
 if(flagForMatchPrice == 0){ 
 Stock updatedStock = (Stock) stockMarketSubject.getUpdate(); if (market.getStockForSymbol(updatedStock.getSymbol()) == null) { 
 // Create 14 traders 
 /** * Adds orders to the appropriate buyOrders or sellOrders lists. * * @param order The order to be added to the OrderBook. */ 
 public boolean equals(Object obj) { return ((Order) obj).getOrderNumber() == this.getOrderNumber(); 
<|del|> 
<|del|>
 m.getMarketHistory().setSubject(pS);//let observer be associated with subject pS.registerObserver(m.getMarketHistory());//register observer 
 private ISubject stockMarketSubject; Market market; 
 this.market = m; 
 } //this is deal with sell order. 
 private Market currentMArket; private HashMap<String, ArrayList<Order>> buyOrders; private HashMap<String, ArrayList<Order>> sellOrders; 
 private Market currentMArket; private HashMap<String, ArrayList<Order>> buyOrders; private HashMap<String, ArrayList<Order>> sellOrders; 
<|del|> 
 private ISubject stockMarketSubject; Market market; 
<|del|>
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 for ( int x = priceIndex-1 ; x >=0 ; x--){ 
 for ( int x = 0 ; x <= priceIndex-1 ; x++){ 
 private ISubject stockMarketSubject; Market market; 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 this.market = m; 
<|del|>
 tempRoom.setOptions(getOptions(tempWay, "buildingpart")); 
 //super(); 
 //super(); 
<|del|> 
<|del|> 
* SellOrder: java class for the creation of SellOrder objects to be used in CA05. 
<|del|> 
<|del|> 
 } else { throw new StockMarketExpection("Invalid Stock: " + symbol); } 
 private Market m; private Map<String, List<Double>> history; 
 private Market m; private Map<String, List<Double>> history; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 // Create 14 traders 
<|del|>
 private ISubject stockMarketSubject; Market market; 
 private ISubject stockMarketSubject; Market market; 
 private ISubject stockMarketSubject; Market market; 
 Market market; 
 for (Order buyOrder: allBuyOrders){ if(buyOrder.isMarketOrder == true){ marketBuyOrder = buyOrder.getSize(); 
 int marketSellOrder = 0; double dupPrice=0; int flagForDuplicatePrice = 0; for (Order sellOrder : allSellOrders){ if(sellOrder.isMarketOrder == true){ marketSellOrder = sellOrder.getSize(); 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 // Create 14 traders 
 // Create 15 traders 
 // Create 15 traders 
<|del|> 
 int flagForDuplicatePrice = 0; 
 private ISubject stockMarketSubject; Market market; 
 String name; // Cash left in the trader's hand 
 Market market; 
 // Populate the buyOrders and sellOrders data structures 
<|del|> 
 public void buyFromBank(Market market, String symbol, int volume) 
 public void placeNewOrder(Market market, String symbol, int volume, 
 market.addOrder(theOrder); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public void placeNewMarketOrder(Market market, String symbol, int volume, 
 double totalPrice = market.getStockForSymbol(symbol).getPrice() * volume; 
 market.addOrder(theOrder); 
 public void tradePerformed(Order order, double matchPrice) 
<|del|> 
<|del|> 
 // get stock from list and update price 
 Stock stockToBeUpdated = removeStockFromStockList(symbol); stockToBeUpdated.setPrice(newPrice); addStock(stockToBeUpdated); 
 + stock.getSymbol() + ")"); 
 marketHistory.startHistoryWithPrice(stock.getSymbol(), stock.getPrice()); 
 + ", " + getStockForSymbol(symbol).getPrice() + ") -> " + newPrice + " X Not Allowed "); 
<|del|> 
<|del|> 
<|del|> 
 trader8.buyFromBank(nasdaq, "SBUX", 5000); // should throw exception 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // TODO Auto-generated catch block 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 long ownedQuantity = 0; 
 // Create 14 traders 
<|del|> 
<|del|> 
<|del|> 
 // Create 14 traders 
<|del|>
<|del|>
 e.printStackTrace(); 
<|del|>
 private ISubject stockMarketSubject; Market market; 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 Market market; 
<|del|> 
<|del|> 
 public void buyFromBank(Market mMarket, String symbol, int volume) 
 // Create 14 traders 
 private ISubject stockMarketSubject; Market market; 
 private ISubject stockMarketSubject; Market market; 
<|del|> 
 int priceIndex = 0; 
 for(int x=0; x< priceIndex ; x++){ 
 for(int x=0; x< priceIndex ; x++){ 
 for ( int x = priceIndex-1 ; x >=0 ; x--){ 
 for ( int x = 0 ; x <= priceIndex-1 ; x++){ 
 // Create 14 traders 
<|del|>
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
<|del|> 
 public void buyFromBank(Market currentMarket, String symbol, int volume) 
 public void tradePerformed(Order currentOrder, double matchPrice) 
<|del|> 
import java.util.*; 
 Market currentMarket; 
 public MarketHistory(Market currentMarket) { this.currentMarket = currentMarket; 
<|del|> 
 for (Order currentOrder : ordersPlaced) { if (((currentOrder instanceof BuyOrder) && (newOrder instanceof BuyOrder)) || ((currentOrder instanceof SellOrder) && (newOrder instanceof SellOrder))) { if (currentOrder.getStockSymbol().equals( 
 public static boolean owns(ArrayList<Order> stockList, String symbol) { for (Order stock : stockList) { 
 private ISubject stockMarketSubject; Market market; 
 this.market = m; 
 for ( int x = priceIndex-1 ; x >=0 ; x--){ 
 double price, OrderType orderType) throws StockMarketExpection { // Similar to the other method, except the order is a market order 
 return nwStart.equals(nt.nwStart) && nwEnd.equals(nt.nwEnd) && tpStart == nt.tpStart && tpEnd == nt.tpEnd; 
 Market market2 = new Market("Nikkei"); IPO.enterNewStock(market2, "BABA", "Alibaba", 84.88); IPO.enterNewStock(market2, "BDU", "Baidu", 253.66); 
 trader8.buyFromBank(market, "SBUX", 5000); 
<|del|> 
<|del|> 
<|del|> 
 Market market; 
 ArrayList<Order> stocksOwnedByTrader; ArrayList<Order> ordersPlacedByTrader; 
 for (int i = 0; i < stocksOwnedByTrader.size(); i++) { if (stocksOwnedByTrader.get(i).getStockSymbol() == symbol){ tmpOrder = stocksOwnedByTrader.get(i); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 //If there are no stocks in the market. 
<|del|> 
 throws StockMarketExpection { 
 this.position.remove(O); 
 Market market; 
<|del|> 
<|del|> 
 } else { 
 for (Order marketOrder : marketOrders) { 
 if (((orderPlaced instanceof BuyOrder) && (newOrder instanceof BuyOrder))) { 
 for (Order order : ordersPlaced) { order.printOrder(); 
 trader15.buyFromBank(m, "SBUX", 1500); // Exception 
 //super(); 
 //super(); 
<|del|> 
public class OrderBook { Market market; 
 listOrders.add(buyOrder); 
 private Market market; private HashMap<String, ArrayList<Order>> buyOrders; private HashMap<String, ArrayList<Order>> sellOrders; 
 for (Order order : this.sellOrders.get(symbol)) 
 public OrderBook(Market market) { this.market = market; 
<|del|> 
 Market market; 
 ArrayList<Order> position; // Orders placed by the trader 
 throws StockMarketExpection { 
 private ISubject subject; 
 //Trader 8's buy will throw exception 
 //Calculating cumulative prices 
 //Calculating bigger demand 
 market1.printStocks(); 
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 if (isBuyOrder(newOrder, orderPlaced) || isSellOrder(newOrder, orderPlaced)) { 
 } } 
 try { //access this order's trader and call the tradePerformed method to indicate that a trade has been performed. 
 // TODO Auto-generated catch block 
 trader15.placeNewMarketOrder(m, "SBUX", 1500, 0, OrderType.SELL); 
 // TODO Auto-generated catch block e.printStackTrace(); 
 } } 
<|del|> 
<|del|> 
 public boolean equals(Object currentOrder) { return ((Order) currentOrder).getOrderNumber() == this.getOrderNumber(); 
<|del|> 
 // for every buyOrder and sellOrder that match, save them into their corresponding market order 
<|del|> 
<|del|> 
 private Market getM() { 
 private void setM(Market currentMarket) { 
 private HashMap<String, ArrayList<Order>> getBuyOrders() { 
 private void setBuyOrders(HashMap<String, ArrayList<Order>> buyOrders) { 
 private HashMap<String, ArrayList<Order>> getSellOrders() { 
 private void setSellOrders(HashMap<String, ArrayList<Order>> sellOrders) { 
 private class OrderPrices implements Comparator<Order> { 
<|del|> 
<|del|> 
<|del|> 
 public MarketHistory(Market market) { 
 this.market = market; 
 Stock updatedStock = (Stock) subject.getUpdate(); 
 market1.printStocks(); 
 int flagForDuplicatePrice = 0; 
 throws StockMarketExpection { 
 return null != byteField && null != byteSet && byteField.equals(o.byteField) && 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Market market; Map<String, List<Double>> history; 
 //TODO tablica tagw POI zostanie uzupeniona w trakcie mapowania budynku, //TODO trzeba ustali jakie poi bd nas interesowa 
 rootDir.ensureHas(path, null); 
 ensureOutputClass(clazz); 
 assertTrue(exists(hostId)); 
 }else if(butMinus == v){ 
 if (mDrawerToggle.onOptionsItemSelected(item)) { return true; } 
 int id = v.getId(); if(id == R.id.butPlus){ 
 private WifiScanReciever wifiScanReciever; //private LocalizationData localizationData; 
 // This only tests the legacy storage. Cluster storage is automatically // cleaned-up when stopping the service. startAndStopService(); 
<|del|> 
 return false; 
 @JsonIgnore public void update(Bridge from) { this.id = from.id; 
 @JsonIgnore public void update(Bridge from) { this.id = from.id; 
 return RouterDataConverter.fromData(routerData, getBaseUri()); 
 @JsonIgnore 
 if(datagram) { boss = null; } else { boss = new NioEventLoopGroup(); } 
 } else { 
 }else if(butUp == v){ 
 private Path getPath(Polygon polygon) { 
<|del|> 
 // BridgeBuilderStateFeeder, ZookeeperStateStorage and HostService 
 // BridgeBuilderStateFeeder, ZookeeperStateStorage and HostService 
<|del|> 
 if(!datagram) { wrkr.shutdownGracefully(); } 
 } else { 
 * Copyright 2015 Midokura SARL 
 SimpleChan simpleadapter = new SimpleChan(sub); 
 public SimpleChan(Observer<Object> obs) { this.obs = obs; } 
 boss.shutdownGracefully(); 
<|del|> 
 if (exc == null && opResultHasError(r)) { exc = new OvsdbOpException(client, ops, idx, r); 
 if (exc == null && opResultHasError(r)) { exc = new OvsdbOpException(client, ops, idx, r); 
<|del|> 
 public final UUID id; public final String name; public final List<String> portIds; 
 if( (mapObject instanceof Road ) || (mapObject instanceof Building) || (mapObject instanceof Crossing)){ 
<|del|> 
 for (int i = 0; i < 1000; ++i) { String key; do { key = "SomeString" + random.nextInt(); } while (testMap.containsKey(key)); testMap.put(key, random.nextInt()); 
 for (Map.Entry<String, Integer> entry : testMap.entrySet()) { Assert.assertNotNull(entry.getValue()); 
<|del|> 
 int PREFFERED_SUGGESTION_SIZE = 10; void analyse(Long uuid, int suggestionSize); 
 List<Long> getSuggestionList(Long UUID); 
 private AnalyseService analyseService; 
 <<<<<<< HEAD import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; ======= 
 List<Long> getSuggestionList(Long UUID); 
 private Neo4jTemplate neo4jTemplate; 
 import android.support.v4.util.Pair; 
 exc = new OvsdbOpException(client, ops, idx, r); break; 
 Server srv = Server.getInstance(); srv.startup(f); 
 /** * Shuts down the server. * * @throws IOException Thrown if server fails to shutdown. */ 
 dir.asyncDelete(encodePath(entry.key, entry.value, version), thisCb); 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 public Network getNetwork(@Nonnull UUID id) throws WebApplicationException { 
 * Copyright 2015 Midokura SARL 
<|del|> 
 final URL fname = BaseXTestSuite.class.getClassLoader().getResource("sampleHarvest.xml"); File file = new File(fname.toURI()); Server srv = Server.getInstance(); srv.startup( file ); 
 assertTrue( c.runQueryNtcirWrap( ">invalid<" ).startsWith( "Query" ) ); 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
<|del|> 
 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); break; } try { 
<|del|> 
<|del|> 
 void updateSslTermination(LoadBalancer loadBalancer, ZeusSslTermination sslTermination) throws Exception; 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 @JsonProperty("start") @ZoomField(name = "start", converter = IPAddressUtil.Converter.class) 
 boolean withVlad = Boolean.parseBoolean(System.getenv("withVladimir")); if (withVlad) { 
 boolean withVlad = Boolean.parseBoolean(System.getenv("withVladimir")); if (withVlad) { 
 @JsonProperty("binding:host_id") 
 private static final String SCROLLINGCACHE_DEFAULT = "3"; 
 @JsonProperty("binding:host_id") 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
<|del|> 
 } else if (cmd.equals("cdjar")) { 
 * Copyright 2015 Midokura SARL 
 public void updateCluster(VirtualIp vip, Cluster cluster) { vip.setCluster(cluster); virtualIpRepository.merge(vip); 
 public URI vxLanPort; 
<|del|> 
 mMemBar.setProgress(used); 
 String path = pb.getPoolHealthMonitorMappingsPath(pool.id, healthMonitor.id); Assert.assertTrue(this.zk.exists(path)); 
 // make sure the path exists Assert.assertTrue(zk.exists(path)); 
<|del|> 
 dto = new MirrorRule(mirrorData.getDstPortId()); 
 typedRule.getCondition(), typedRule.getDstPortId()); 
 public UUID getDstPortId() { 
 public MirrorRule setDstPortId(UUID portId) { 
 * Copyright 2015 Midokura SARL 
<|del|> 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 @Pattern(regexp = IPv6.regex, message = "is an invalid IPv6 format") 
 * Copyright 2015 Midokura SARL 
 * @return A list of DhcpSubnet objects. 
 // Make sure that the DhcpSubnet6 has the same IP address as the URI. 
 * Copyright 2015 Midokura SARL 
<|del|> 
 * Demo game screen * @author Bubul/Funky 
 private class SimpleChan extends SimpleChannelInboundHandler<io.netty.channel.socket.DatagramPacket> { 
 if (isCompatApiEnabled()) { 
 // @ValidPortId 
 @ZoomField(name = "router_id", converter = UUIDUtil.Converter.class) public UUID routerId; 
 .setId(UUIDUtil.toProto(randId)) .setType(Topology.Rule.Type.LITERAL_RULE) 
 .setId(UUIDUtil.toProto(randId)) .setType(Topology.Rule.Type.LITERAL_RULE) 
 ml.mac()); 
 /** *The width of the game window. */ 
 * Test class for service discovery details in java. 
 if (clock.time() - stat.getMtime() < ONE_DAY) { log.debug("Skipping NAT block recycling: too soon after last operation"); 
 byte[] serializedHostId = new UUIDUtil.RichJavaUuid(hostId).toBytes(); zk.setData(paths.getNatPath(), serializedHostId, stat.getVersion(), 
 p.completeWith(recycleDevices(children)); } else if (rc == KeeperException.Code.BADVERSION.intValue()) { log.info("Aborting: recycle already being performed by another host"); p.success(0); 
 } else { log.info("Failed to recycle blocks for device {} and ip {} (ZK error: {})", devId, ipv4, KeeperException.Code.get(rc)); 
 deleteOps[blockIdx] = Op.delete(path, stat.getVersion()); 
 zk.multi(Arrays.asList(deleteOps)); 
 + "must be one of: ACCEPT, DROP, REJECT or RETURN."); 
 if (!action.equals(Action.ACCEPT) && !action.equals(Action.CONTINUE) && !action.equals(Action.RETURN)) 
 this(null); 
 && action != Action.REJECT && action != Action.RETURN) { 
<|del|> 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
<|del|> 
 * Copyright 2015 Midokura SARL 
<|del|> 
 @ZoomField(name = "network_inbound_ids", converter = UUIDUtil.Converter.class) public List<UUID> networkInboundIds; 
<|del|> 
 public GuiceRequestFactoryServlet(ExceptionHandler exceptionHandler, 
<|del|>
 throwable == null ? null : throwable.getClass().getName(), 
 assertThat("Create should not have succeeded", 
 * Implement your own stack data structure (LIFO) of strings. * It has to contain the following methods: 
<|del|> 
 public Response create(Route route) 
<|del|> 
<|del|> 
 * Generate an insert operation corresponding to the given VTEP table entry. 
 log.handle(Priority.ERROR, "Expected OMS Events JSON dictionary list as input to process event: " + event); 
 log.handle(Priority.INFO, requestType + " was successfull"); 
 log.error("Error in converting requested Lock info to JSON ", e); asyncResponse.resume(Response.ok("Error in converting requested Lock info to JSON ", MediaType.APPLICATION_JSON).build()); 
 log.error("Invalid requested lock information: " + lockInfo, e); asyncResponse.resume(Response.ok(" INvalid requested lock information " + lockInfo, MediaType.APPLICATION_JSON).build()); 
 assertTrue(vni >= SequenceDispenser.VxgwVni.seed()); 
 assertTrue(exists(hostId)); assertEquals(get(hostId).getName(), hostName); assertTrue(isAlive(hostId)); } 
 private static final double secsPerDay = 24.0*60.0*60.0; 
<|del|> 
 if (IPUtils.isValidIpv6String(n.getIpAddress())) { 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 * Copyright 2015 Midokura SARL 
 int len = MIN_HEADER_LEN + vlanIDs.size() * 4 + childLength(); return pad ? Math.max(len, 60) : len; 
 public final static String KEYSTONE_TOKEN_EXPIRED_FORMAT_WITH_MILLIS = 
 assertEquals(204, response.getStatus()); 
<|del|>
 typedDto.vtepId = vtepIds.apply(typedPort.getMgmtIpAddr()); 
 @Max(0xFFFF) 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 @JsonIgnore public void update(ServiceContainerGroup that) { if (that != null) { this.serviceContainerIds = that.serviceContainerIds; } } 
 @ZoomField(name = "name") 
<|del|> 
 if (data == null) {//message to commiter 
<|del|> 
<|del|> 
<|del|> 
 @ZoomField(name = "ipsec_site_conns") 
<|del|> 
<|del|> 
 public static final String IPSEC_SITE_CONNS = "/ipsec_site_connections"; 
 return valueOf(IPSecSiteConnection.normalizeIpSecEnumString(v)); 
 return valueOf(IPSecSiteConnection.normalizeIpSecEnumString(v)); 
 "Condition matched on device {} chain {} with action {}", ownerId, chainId, action); 
 private ResponseListener mListener; private Map<String, String> mResponseHeaders; 
<|del|> 
 @ZoomField(name = "id") public UUID id; 
 return Objects.equals(id, that.id) && Objects.equals(type, that.type) && 
 .add("id", id) .add("type", type) 
 @JsonProperty("segmentation_id") 
 @ZoomField(name = "id") public UUID id; 
<|del|> 
 public Host getDefaultActiveHostAndActiveCluster(Integer accountId, boolean hasPublicVip) throws EntityNotFoundException, ClusterStatusException, NoAvailableClusterException; 
<|del|> 
<|del|> 
<|del|> 
 return TILE_IMAGES_PATH + PATH_SEPARATOR 
 return Objects.hash(chainId, condInvert, matchForwardFlow, matchReturnFlow, 
 continue; } 
 } 
 fieldArray[i][j] = 0; } 
 public void setGameField(int xPos, int yPos, int color) { if (field[xPos][yPos] == EMPTY) { 
 GameFieldButton(CurrentGameState gameState, int xPos, int yPos) { 
<|del|> 
<|del|> 
 field[a][a] = BLACK_PLAYER; // that are already set before beginning field[b][b] = BLACK_PLAYER; field[b][a] = WHITE_PLAYER; field[a][b] = WHITE_PLAYER; whichPlayerSets = BLACK_PLAYER; 
 if (yPos != 0 && field[xPos][yPos - 1] == enemy) { for (int i = yPos - 1; i >= 0; i--) { if (field[xPos][i] == enemy) { 
 int i = xPos - 1; int j = yPos - 1; 
 xPos = SIZE_OF_FIELD - 1; yPos = SIZE_OF_FIELD - 1; 
<|del|> 
 root.setPrefSize(X_RESOLUTION, Y_RESOLUTION); 
 MenuRadioButton(String nameOfButton) { super(nameOfButton); 
 tiles.add(new Tile(String.valueOf(tileText))); tiles.add(new Tile(String.valueOf(tileText))); tileText++; 
 tile = tiles.get(variableOfList); 
<|del|> 
<|del|> 
 char tileText = 'A'; 
<|del|> 
 if (massiveTiles[n][m].isSelected() || event.getClickCount() > 1 || !event.isStillSincePress()) { 
 if (BotMode.getBotMode() == 0) { if (massiveTiles[n][m].isSelected() || event.getClickCount() > 1 || !event.isStillSincePress()) { 
<|del|> 
<|del|> 
 if (BotMode.getBotMode() == PLAYER_VS_BOT) { 
 if (BotMode.getBotMode() == BOT_IS_A_PLAYER) { 
 if (BotMode.getBotMode() == PLAYER_VS_BOT) { 
 if (BotMode.getBotMode() == BOT_IS_A_PLAYER) { 
 // 0 - player // 1 - bot vs player // 2 - bot 
 paneMain.setPrefSize(width, height); 
 imageView.setFitHeight(height); imageView.setFitWidth(width); 
 /** * @param args */ 
<|del|> 
 CreateButtons(); 
 public void CreateButtons() { 
<|del|> 
 final KeyFrame FrameOpacity1 = new KeyFrame(animationDuration, opacity1); final KeyFrame FrameLayout1 = new KeyFrame(animationDuration, KeyValueY1); animateAddedPoints.getKeyFrames().addAll(FrameOpacity0, FrameLayout0, FrameOpacity1, FrameLayout1); 
 private Rectangle createCell(int PositionX, int PositionY) { 
 if (Game2048.STEP >= Step25) { GridOperator.sortGrid(direction); board.setPoints(0); 
 final Location newLocation = findFarthestLocation(t1.getLocation(), direction); Location nextLocation = newLocation.offset(direction); // calculates to a possible merge 
 if (Game2048.STEP >= Step30) { 
 int row, column; 
 if (turn == FIRST_TURN && difficultyLevel > EASY) { 
 if (turn >= THIRD_TURN) { // check, if A.I. can win right on this turn 
<|del|> 
 private byte[][] currentGeneration = null; 
 } } 
 if (x == -1) { 
 if (x == -1) { 
 if (y == -1) { 
 int neighbourCount = 8; for (int i = 0; i < neighbourCount; i++) { 
 return (byte) 0; } 
 info.getArea()[x][y] = 0; } 
 if ((this.delay > 999 && this.delay < delay) || (this.delay < 6 && this.delay > delay)) { 
 } 
 } catch (IOException e) { System.err.println("Caught IOException: " + e.getMessage());} 
 status.setFont(Font.font(Font.getDefault().getName(),FontWeight.BOLD, 40)); 
 return conjunctionInv; 
<|del|> 
 if (BotActive == false) { GameBot.AnimationTimer.start(); BotActive = true; } else { GameBot.AnimationTimer.stop(); BotActive = false; } 
<|del|>
 private static int botMode; 
 * This class changes the level of difficulty, when player chooses another mode in 
 * This class changes the level of difficulty, when player chooses another mode in 
 GameState.setBotMode(BOT_ON); BotTurn(); 
 GameState.setBotMode(BOT_ON); BotTurn(); 
 if (GameState.getBotMode() == BOT_ON) { 
 * 
 * 
 Board.Winner = false; 
 int action = RandomNumber(); Direction direction = Direction.valueForBOT(action); Game2048.gameManager.move(direction); 
 tilesWereMoved = GridOperator.traverseGrid((xPosition, yPosition) -> { 
 Board.Winner = true; 
 parallelTransition.getChildren() .add(animateExistingTile(fitstTileToCheck, nextLocation)); parallelTransition.getChildren().add(animateMergedTile(secondTileToCheck)); mergedToBeRemoved.add(fitstTileToCheck); 
 private int xPosition; private int yPosition; 
 /** * Add to tile's value the value of the tile to be merged to, set the text with the new value and * replace the old style game-title--value with the new one */ public void merge(Tile anotherTile) { 
<|del|> 
 private int numberOfTurns = 0; public int currentReplayableTurn; public LinkedList<int[][]> gameStates = new LinkedList<>(); 
<|del|> 
 Tile arrayOfTiles[][]; 
 private final int HEIGHT = 400; private final int WIDTH = 600; 
 () -> (gameMovePoints.get() > 0) ? "+".concat(Integer.toString (gameMovePoints.get())) : "", 
 lblPoints.setLayoutX(lblPoints.sceneToLocal( midScoreX, 0).getX() - lblPoints.getWidth() / 2d); 
 Scene scene = new Scene(root, WIDTH, HEIGHT); 
 board.resetGameProperty().addListener((OValue, booleanFirst, booleanSecond) -> { if (booleanSecond) { 
 newLocation.getLayoutX(Board.CELL_SIZE) - (tile.getMinHeight() / 2), Interpolator.EASE_OUT); 
 * Animation that creates a pop effect when two tiles merge by increasing the tile * scale to 120% at the middle, and then going back to 100% 
 * Sort TraversalX, traversalY, so for Right or Down directions they are taken * in reverse order 
 // Board.CELL_SIZE - 13 -> this is the tile that was a bit less than the field 
 this.dx = this.initVelocity; // change the ball position coordinate X this.dy = -this.initVelocity; // change the ball position coordinate Y 
 public void draw(GraphicsContext graphicsContent) { graphicsContent.setFill(this.color); graphicsContent.fillOval(this.leftBoundary, this.upperBoundary, this.width, this.height); 
 private static Color[] BRICK_COLORS = {Color.TRANSPARENT, 
 private static Color[] BRICK_COLORS = {Color.TRANSPARENT, 
public final class Constants { 
public final class Constants { 
 int brickLifes; 
 GraphicsContext graphicsContent = canvas.getGraphicsContext2D(); 
 ArrayList<String> inputKeyCode = new ArrayList<>(); 
 Mechanics mechanics = new Mechanics(playerLifes, ball, paddle, bricks); 
 private int playerLifes; private float duration; 
 root.setPrefSize(WINDOW_WIDTH, WINDOW_HEIGTH); 
<|del|> 
 public Mechanics(int playerLifes, Ball ball, Paddle paddle, 
 this.playerScore++; if (brick.getLifes() == 0) { this.leftBricks--; 
 this.playerScore++; if (brick.getLifes() == 0) { this.leftBricks--; 
 setPreferredSize(new Dimension(WIDTH, HEIGHT)); 
 private MenuButton startButton; private MenuButton exitButton; private MenuButton rulesButton; private MenuButton recordsButton; 
 setPreferredSize(new Dimension(WIDTH, HEIGHT)); 
 Image imageBackground = null; 
 this.dx = this.initVelocity; // change the ball position coordinate X this.dy = -this.initVelocity; // change the ball position coordinate Y 
 FileReader fileReader = new FileReader(file); BufferedReader bufferedReader = new BufferedReader(fileReader); 
 KeyFrame keyFrame; keyFrame = new KeyFrame(Duration.seconds(duration), new EventHandler<ActionEvent>() { 
public class Replay { 
 numberLines += 2; 
 * Bot makes random move. 
 owner = NO_OWNER; 
 private GameLogic field; private int posX; private int posY; private int result; private int serverMode = PLAY_MODE; 
 this.positionX += this.dx; 
 public void sort(int sortMode) { 
 Board.Winner = false; 
 Button buttons = new Button(); buttons.setPrefSize(30, 30); buttons.setId(symbol); buttons.setOnAction(t); buttons.setTooltip(new Tooltip(text)); return buttons; 
 Tile tile = gameGrid.get(new Location(x, y)); PROPERTIES.setProperty("Location_" + x + "_" + y, tile != null ? tile.getValue().toString() : "0"); 
 Tile tile = Tile.newTile(new Integer(value)); Location locaton = new Location(x, y); tile.setLocation(locaton); gameGrid.put(locaton, tile); 
 int hash = 7; hash = 61 * hash + this.x; hash = 61 * hash + this.y; return hash; 
 int hash = 7; hash = 61 * hash + this.x; hash = 61 * hash + this.y; return hash; 
 private Rectangle createCell(int PositionX, int PositionY) { 
<|del|> 
 int HASH = 7; int HASHNUMBER = 97; HASH = HASHNUMBER * HASH + this.x; HASH = HASHNUMBER * HASH + this.y; return HASH; 
 private final Properties PROPS = new Properties(); 
 public static int numberSave = 0; public static int numberRead = 1; public static boolean endFile = false; 
 private double replayInfo[]; public static final int FILE_END = -1; 
 while (buffer != FILE_END) { 
<|del|> 
 } else if (mv.version < p.version) { 
 int basePort = Integer.valueOf( System.getProperty("test.api.port", "50000")); int port = portSeed.getAndIncrement() % (0xffff - basePort) + basePort; 
 fileChooser.setInitialDirectory( new java.io.File("C:\\Users\\Thandor-Laptop\\workspace\\Cat's life\\Saves")); fileChooser.getExtensionFilters().add( new FileChooser.ExtensionFilter(" catsv", "*.catsv")); fileChooser.setTitle("   "); 
 scala.Option.apply(reflections), metricRegistry), 
 double[] array = new double[populations.size()]; 
 long[] arrayScalaSorted = arrayJavaSorted.clone(); 
<|del|> 
<|del|> 
<|del|> 
 if (mouse == -1) { break; } 
 array = new int[replayArray.size()]; int temp = replayArray.size(); for (int i = 0; i < temp; i++) { 
 array = new int[replayArray.size()]; int temp = replayArray.size(); for (int i = 0; i < temp; i++) { 
 log.info("MidoNet Agent main start... ---------"); 
 log.info("MidoNet Agent exiting. Bye!"); 
 void enableDisableTLS_10(LoadBalancerEndpointConfiguration conf, LoadBalancer loadBalancer, boolean isEnabled) 
<|del|> 
 public static void convertApiSslTermToDbTlsProtocols(org.openstack.atlas.docs.loadbalancers.api.v1.SslTermination apiSslTerm, org.openstack.atlas.service.domain.entities.SslTermination dbSslTerm, boolean newDbSslTerm) { 
 && Objects.equal(description, other.description) 
 && Objects.equal(description, other.description) 
<|del|> 
 } 
 return (this.x.getValueFor(x) + this.y.getValueFor(x)); 
<|del|> 
<|del|> 
 log.error("Put {} => {} failed: {}", key, value, ex); synchronized (ReplicatedMap.this) { writingMap.remove(new Entry(key, value)); } 
 log.debug("Already writing entry {} -> {}", key, value); 
 log.debug("Waiting on reading entry {} -> {}", key, value); 
 private Set<Entry> writingSet; 
 if (writingSet.contains(entry)) { 
 return "{ regEx=\"" + regExString + "\", className=\"" + someClass.getCanonicalName() + "}"; 
<|del|> 
 } while (start < length); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 synchronized (startEvents) { long startWindow = clock.time() - period; while (startEvents.size() > 0 && startEvents.peek() < startWindow) { startEvents.poll(); } 
 log.info("Process ``{}`` stopped", cmd); 
 log.info("Process ``{}`` starting with pid {} at time {}", cmd, ProcessHelper.getProcessPid(process), clock.time()); 
<|del|> 
<|del|> 
public class MonitoredDaemonProcess extends AbstractService { 
 * Copyright 2016 Midokura SARL 
 * Copyright 2016 Midokura SARL 
 int retriesPerPeriod, long period, Consumer<Exception> exitAction) { 
 * Copyright 2016 Midokura SARL 
 return name + "(" + 
 type + " ifindex " + ifindex + 
 ArrayList<Service> services = new ArrayList<>(7); 
 return toString() + "=" + (wcmatch.tunnelTTL & 0xff); 
 return toString() + "=" + String.format("%04X", wcmatch.etherType); 
 return toString() + "=" + (wcmatch.networkTTL & 0xff); 
<|del|> 
<|del|> 
 String statusDescription) { 
 return MoreObjects.toStringHelper(this) .omitNullValues() .add("type", type) .add("cookieName", cookieName) .toString(); 
public class LoadBalancerV2 extends ZoomObject { 
 public String vipAddress; 
 public UUID vipSubnetId; 
public class PoolHealthMonitorV2 extends ZoomObject { 
import java.util.UUID; import org.midonet.cluster.data.*; 
 @ZoomField(name = "id") 
 @JsonProperty("id") @ZoomField(name = "id") 
 public Boolean adminStateUp; 
 public List<UUID> loadBalancers; 
 String statusDescription) { 
 return MoreObjects.toStringHelper(this) .omitNullValues() .add("poolId", poolId) .add("status", status) .add("statusDescription", statusDescription) .toString(); 
 } members.remove(memberId); 
 public String toString() { return String.valueOf(matches); } 
 public static final String LBS_V2 = "/lbs_v2"; public static final String LISTENERS_V2 = "/listeners_v2"; 
 public static final String LBS_V2 = "/lbs_v2"; public static final String LISTENERS_V2 = "/listeners_v2"; 
 } catch (PatternSyntaxException e) { logger.error("Failed to set commit path for {}, invalid pattern: {}", this.jobName, commitPath); 
 public transient JenkinsRule jenkinsRule = new JenkinsRule(); 
 jenkinsRule.assertBuildStatus(Result.SUCCESS, multi.scheduleBuild2(0, new UserCause()).get()); mockChangeSet("beer/mikkeller/AmericanDream"); jenkinsRule.assertBuildStatus(Result.SUCCESS, multi.scheduleBuild2(0, new UserCause()).get()); 
 jenkinsRule.assertBuildStatus(Result.SUCCESS, multi.scheduleBuild2(0, new UserCause()).get()); mockChangeSet("beer/mikkeller/AmericanDream", "whisky/bruichladdich/Octomore"); jenkinsRule.assertBuildStatus(Result.SUCCESS, multi.scheduleBuild2(0, new UserCause()).get()); 
 PhaseJobsConfig secondPhase = new PhaseJobsConfig("free2", null, true, null, KillPhaseOnJobResultCondition.NEVER, false, false, "", 0, false, false, "",false, false); 
 getPools(baseUri)).path(id.toString()).build(); 
 @JsonProperty("health_monitors_v2") public String healthMonitorV2Template; 
 @JsonProperty("pools_v2") 
 @JsonProperty("pool_v2_template") 
 @JsonProperty("pool_members_v2") 
 @JsonProperty("pool_member_v2_template") 
 @JsonProperty("listeners_v2") 
 @JsonProperty("listener_v2_template") 
 public void delete(@PathParam("id") UUID id) { 
 LoadBalancerV2 lb = new LoadBalancerV2(); 
 ListenerV2 l = new ListenerV2(); 
<|del|>
 // By the way, this is a comment. // (Edit following a bad review) We'll just pretend that I removed the above comment... 
<|del|> 
 @ZoomField(name = "max_burst_kb") 
<|del|> 
 // expect to use 'max_burst_kb' in ZK, the API, the PMC, and in internal 
<|del|> 
 public static final String USELESS_STRING = "goodbye"; 
 * @return A file descriptor for the new socket. On error, it throws a * {@code LastErrorException}. 
 } for (; i < ifruName.length; i++) { ifruName[i] = 0; } 
 public NativeLong memStart; public NativeLong memEnd; 
 // The API sets a V2 pool member's status to NO_MONITOR when its actual // status cannot be obtained from a health monitor. It has no protobuf // equivalent. 
 throw new Exception("Fip64Del successed for non-existing fip6"); 
 throw new Exception("Fip64SyncDisable successed but Sync had not been enabled"); 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
 throw new PKIException("Error deleting signing cert record:" + e, e); 
 @ManyToOne(fetch = FetchType.EAGER) 
 // TODO: walidacja hasla i id // TODO: zrobic sprawdzanie czy zalogowany == ten co moze zrobic update 
 int retries, long period, int exitErrorCode) { 
 public ResponseEntity<String> getUnreadAndMarkAsRead() throws JsonProcessingException { 
 private List<AttendingCourseDTO> attendingCourses; private List<TeacherPrivilegeDTO> teacherPrivileges; 
<|del|> 
<|del|> 
 if ((portSubnet == null || portSubnet.size()==0) && StringUtils.isNotEmpty(portAddress)) { 
 if (StringUtils.isNotEmpty(networkAddress)) { 
 if (StringUtils.isNotEmpty(networkAddress)) { 
 portSubnet.add(IPSubnet.fromString(networkAddress, networkLength) 
 public void createRegion() throws Exception { 
 public void createRegion() throws Exception { 
 if (!portSubnet.isEmpty()) { 
 * Starts the database migration. 
 encryptAlgorithm = EncryptionAlgorithm.AES_128_CBC_PAD; wrapAlgorithm = KeyWrapAlgorithm.AES_KEY_WRAP_PAD; wrapIVLength = 0; 
 } catch (Exception e) { // TODO(alee) - narrow the exception here. We should only // return Version(0.0.0) in the case where get a 404 response. 
 SymmetricKey sessionKey = crypto.generateSessionKey(encryptAlgorithm); 
 major = Integer.valueOf(parts[0]); 
 major = Integer.valueOf(parts[0]); 
 minor = Integer.valueOf(parts[1]); 
 throw new EBaseException("Failed to generate IV when wrapping secret", e1); 
 SecureRandom rnd = new SecureRandom(); return rnd.generateSeed(numBytes); 
 SecureRandom rnd = new SecureRandom(); return rnd.generateSeed(numBytes); 
 "// Class auto-generated. Do not edit manually!\n" + 
<|del|> 
 public static byte[] encodePKIArchiveOptions(PKIArchiveOptions opts) throws Exception { 
 byte[] iv = CryptoUtil.getNonceData(encryptAlg.getIVLength()); AlgorithmIdentifier aid = getAlgorithmId(algorithm, encryptAlg, iv); WrappingParams params = getWrappingParams(encryptAlg, iv); 
<|del|> 
 private String publicKey; 
 encryptAlgorithm, data.getNonceData())); 
 encryptAlgorithm, data.getNonceData())); 
 public static final String SECURITY_DATA_PL_WRAPPED = "payloadWrapped"; 
@XmlRootElement(name="KRAInfo") 
 logger.debug("KRAInfoService.getInfo(): session: " + session.getId()); 
 boolean encrypt_archival = cs.getBoolean("kra.allowEncDecrypt.recovery", false); 
 public KRAInfoResource resource; 
 boolean encrypt_recovery = cs.getBoolean("kra.allowEncDecrypt.recovery", false); return encrypt_recovery ? KRAInfoResource.ENCRYPT_MECHANISM : KRAInfoResource.KEYWRAP_MECHANISM; 
@XmlRootElement(name="CAInfo") 
 logger.debug("CAInfoService.getInfo(): session: " + session.getId()); 
 IConfigStore cs = CMS.getConfigStore(); boolean kra_present = cs.getBoolean("ca.connector.KRA.enable", false); if (!kra_present) return null; 
 public CAInfoResource resource; 
 resource = createProxy(CAInfoResource.class); 
 SecureRandom rnd = new SecureRandom(); return rnd.generateSeed(numBytes); 
 encrypted = allowEncDecrypt_recovery; 
 encrypted = allowEncDecrypt_recovery; 
 else if ("ecc".equals(algorithm)) { 
 IConfigStore cs = CMS.getConfigStore(); boolean kra_present = cs.getBoolean("ca.connector.KRA.enable", false); if (!kra_present) return null; 
<|del|> 
<|del|> 
<|del|>
{ 
 null, // PQG not yet supported 
 RequestId requestID, 
 requestId, 
 RequestId recoveryID, KeyId keyID, 
 RequestId recoveryID, KeyId keyID, 
 requestId, keyId, 
 requestId, keyId, 
 "LOGGING_SIGNED_AUDIT_SECURITY_DATA_INFO"; 
 KeyId keyID, 
 CMS.debug("NetkeyKeygenService: setting extractablePairs to true"); 
<|del|> 
<|del|> 
 public RestTemplate getRest() { 
<|del|> 
 // find CA that issued the cert List<AuthorityData> authorities = authorityClient.findCAs(null, null, issuerDN, null); 
 } else if (kwAlg == KeyWrapAlgorithm.DES_CBC_PAD) { 
public final class Sum2Numbers { 
 * This program computes sum of 2 numbers. 
 * This program computes division of 2 numbers. 
ort java.util.Scanner; 
ort java.util.Scanner; 
 return first + second; 
 System.out.println(math.sum(first, second)); 
/** * Class created to solve problem 1000 - Timus. Can be tested with console. * Class includes: sum - return result of summation between 2 numbers * main - console program used to test the sum function */ 
 public static void main(String[] arg) { 
 public static void main(String[] arg) { 
 * This method instantiates a new Vertx and deploys the verticle. Then, it waits to see if the verticle has * successfully completed its start sequence (thanks to `context.asyncAssertSuccess`). 
 * This method instantiates a new Vertx and deploys the verticle. Then, it waits to see if the verticle has * successfully completed its start sequence (thanks to `context.asyncAssertSuccess`). 
 * This method, called after our test, just cleans up everything by closing the vert.x instance 
 // We create an HTTP client and query our application. When we get the response we check it contains 
 * This program finds the minimum value of an array of numbers. 
 int min = numbers[0]; 
 String array2 [] = {"ab","abc","bcd","acd"}; 
 return weekday == false || vacation == true; 
 return (talking == true && (hour < 7 || hour > 20)); 
 if (negative){ 
 * CodingBat WarmUp 1 Solutions * http://codingbat.com/java/Warmup-1 
 boolean alsTeen = a >= 13 && a <= 19; boolean blsTeen = b >= 13 && b <= 19; return (alsTeen || blsTeen) && !(alsTeen && blsTeen); 
 return b; } else if (Math.abs(10 - a) == Math.abs(10 - b)) { return 0; 
 public void lineDraw(int length, int width) { 
 public static double arrayAvg(double[] array){ 
 public static double arrayAvg(double[] array){ 
 } 
 } 
 * Calculate the average value of {@code values}. {@code values} must be valid and populated. * @param values: given values in array form 
 public static double arrayAvg(double[] values){ double average = 0; if ((values.length != 0) || (values != null)) { for (double value : values) { average += value; 
 public static double arrayAvg(double[] values){ double average = 0; if ((values.length != 0) || (values != null)) { for (double value : values) { average += value; 
 public void arrayAvg_multipleValues() { double[] values = {1, 2, 3, 4}; double average = ArrayPractice.arrayAvg(values); 
 public void arrayAvg_multipleValues() { double[] values = {1, 2, 3, 4}; double average = ArrayPractice.arrayAvg(values); 
 public void arrayAvg_oneValue() { double[] values = {4}; double average = ArrayPractice.arrayAvg(values); 
 * Calculate the average value of {@code values}. {@code values} must not be empty. 
 public static double avgArray(double[] values){ 
<|del|> 
 String sub = str.substring(0 , 3); return sub + sub + sub; 
 return Math.max(a , b); 
<|del|> 
<|del|> 
 String array2 [] = {"ab","abc","bcd","acd"}; 
 public String everyNth(String str , int n) { StringBuilder every = new StringBuilder(); 
 * CodingBat Warm Up 2 Solutions * http://codingbat.com/java/Warmup-2 
 if (str.length() <= 3) { String repeat = str; 
 int a = Math.min(nums.length , 4); for (int i = 0; i < a; i = i + 1) { 
 String array2 [] = {"ab","abc","bcd","acd"}; 
<|del|> 
 @GET 
<|del|> 
 String hellomessage = "Hello World for review!"; System.out.println( hellomessage ); 
 StringBuilder times = new StringBuilder(); 
 String repeat = str; 
 for (int i = 0; i < a; i = i + 1) { if (nums[i] == 9) { c++; 
 } sslCipherProfileService.setCipherProfileOnSslTermination(dbTermination, cipherProfileName); 
 * This method instantiates a new Vertx and deploys the verticle. Then, it waits to see if the verticle has * successfully completed its start sequence (thanks to `context.asyncAssertSuccess`). 
 * This method instantiates a new Vertx and deploys the verticle. Then, it waits to see if the verticle has * successfully completed its start sequence (thanks to `context.asyncAssertSuccess`). 
 * This method, called after our test, just cleans up everything by closing the vert.x instance 
 // We create an HTTP client and query our application. When we get the response we check it contains 
 int prefixBytes = 1024 * 3; // 3 kibibyte 
<|del|>
 public void tearUp(TestContext testContext) throws IOException { 
 public static final String PARSED_TYPE_KEY = "parsedType"; 
<|del|>
<|del|>
 X509Certificate importedCert = manager.importCertPackage(cert.getEncoded(), preferredNickname); 
 String issuedBy = null; if (cert == null) { CMS.debug(method + "input param cert null"); return null; } 
 } catch (TPSException e) { CMS.debug(method + e.toString()); 
 CMS.debug(method + "found original cert record"); 
 Iterator<TPSCertRecord> records; if (cert == null) { CMS.debug(method + "input param cert null"); return false; } if (cuid == null) { CMS.debug(method + "input param cuid null"); return false; } 
 if (certRecord.getSerialNumber().equalsIgnoreCase(cert.getSerialNumber())) { 
 System.out.println("------Gerrit Hub Test-1-------on------9-SEP-2017"); 
 System.out.println("------Gerrit Hub Test-1-------on------9-SEP-2017"); 
 snapshot.putIfAbsent(this.clazz, new HashMap<>()); HashMap<Object, Object> entry = snapshot.get(this.clazz); 
 final class MappedSnapshot extends HashMap<Class<?>, HashMap<Object, Object>> 
 if (j < 0) { 
 audit(OCSPGenerationEvent.createFailureEvent(auditSubjectID(), "Missing OCSP response")); 
 throw new RuntimeException(e); 
 SecureRandom random = null; 
 JssSubsystem jssSubsystem = (JssSubsystem) CMS.getSubsystem(JssSubsystem.ID); rnd = jssSubsystem.getRandomNumberGenerator(); 
<|del|> 
<|del|> 
 String pwd = hashPassword(challengePassword); 
<|del|> 
<|del|> 
 SecureRandom rnd = CryptoUtil.getRandomNumberGenerator(); 
 SecureRandom rnd = SecureRandom.getInstance("pkcs11prng","Mozilla-JSS"); 
<|del|> 
 } catch (NoSuchAlgorithmException | NoSuchProviderException e) { throw new RuntimeException(e); 
 throw new RuntimeException(e); 
 throw new RuntimeException(e); 
<|del|> 
<|del|> 
 SecureRandom rnd = SecureRandom.getInstance("pkcs11prng","Mozilla-JSS"); 
 SecureRandom rnd = SecureRandom.getInstance("pkcs11prng","Mozilla-JSS"); 
 CMS.getUserMessage("CMS_KRA_INVALID_PRIVATE_KEY") + ": " + e, e); 
 CMS.getUserMessage("CMS_KRA_INVALID_PUBLIC_KEY") + ": " + message); 
 throw new EKRAException( CMS.getUserMessage("CMS_KRA_INVALID_PRIVATE_KEY") + ": " + e, e); 
 throw new EKRAException( CMS.getUserMessage("CMS_KRA_INVALID_PRIVATE_KEY") + ": " + e, e); 
 throw new EKRAException( CMS.getUserMessage("CMS_KRA_INVALID_KEYRECORD") + ": " + e, e); 
 throw new EKRAException( CMS.getUserMessage("CMS_KRA_INVALID_STATE") + ": " + message); 
 throw new EKRAException( CMS.getUserMessage("CMS_KRA_INVALID_STATE") + ": " + e, e); 
 throw new EKRAException( CMS.getUserMessage("CMS_KRA_INVALID_STATE") + ": " + message); 
<|del|> 
<|del|>
<|del|>
<|del|>
 private Text mConsoleTxt; 
 lpr.addCommand(GlobalData.Get().GetSdbPath() + "sdb" + " install " + 
 //Check ident_string because, verifyBytes will be = sharedSecret otherwise. //Let caller clear sharedSecret when the time comes. 
<|del|> 
<|del|> 
 public String getTxtProjectName() { return mTxtProjectName.getText(); 
<|del|> 
 public ApprovalTable() { 
 public void onSignIn() { addReviewer.setVisible(true); 
 addReviewer.setVisible(false); 
 if (Gerrit.isSignedIn() && change.getStatus().isOpen()) { addReviewer.setVisible(true); } else { addReviewer.setVisible(false); 
 if (Gerrit.isSignedIn() && change.getStatus().isOpen()) { addReviewer.setVisible(true); } else { addReviewer.setVisible(false); 
 if (Gerrit.isSignedIn() && change.getStatus().isOpen()) { addReviewer.setVisible(true); } else { addReviewer.setVisible(false); 
 if (nameEmail.length() == 0) { 
 PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, 
 PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, 
<|del|> 
 approvals = new ApprovalTable(); 
 body.append(a.getFullName()); 
 addReviewer.setVisible(Gerrit.isSignedIn() && change.getStatus().isOpen()); 
<|del|> 
<|del|> 
 log.error("Cannot send review request to new reviewer for change " + id, e); 
 if (!db.changeApprovals().byChangeUser(id, reviewer).iterator().hasNext()) { 
Copyright (C) 2008 The Android Open Source Project 
<|del|> 
 super(/* auto hide */true, /* modal */true); 
 final FlowPanel mwrap = new FlowPanel(); 
<|del|> 
 String headingAbandonMessage(); 
<|del|> 
<|del|> 
 void abandonChange(PatchSet.Id patchSetId, String message, 
Copyright (C) 2008 The Android Open Source Project 
Copyright (C) 2009 The Android Open Source Project 
 boolean canAbandon = false; if (me == null) { 
 final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey()); if (patch == null || projEnt == null) { 
 final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey()); if (me == null || patch == null || projEnt == null) { 
<|del|> 
 private static Map<String, File> hooks; 
 } catch (Throwable e) { 
<|del|> 
 final File hook = getHooks().get(ON_NEW_CHANGE_HOOK); if (hook != null) { 
<|del|> 
<|del|> 
<|del|> 
 final Widget l = new SafeHtmlBuilder().append(msg.getMessage().trim()).wikify() .replaceAll(Gerrit.getConfig().getCommentLinks()).toBlockWidget(); 
 String link = "<a href=\"" + cfg.getString("CommentLink", commentLinkName, "link") + "\">$&</a>"; 
<|del|> 
<|del|> 
<|del|> 
 cm.setFrom(getSubmitter(c)); 
 cm.setChangeMessage(msg); cm.sendMergeFailed(); 
 log.error("Cannot submit patch set for Change " + c.getId() + " due to a path conflict.", e); } 
 schema.changeMessages().insert(Collections.singleton(msg)); 
 schema.changeMessages().insert(Collections.singleton(msg)); 
<|del|>
 public static final ResultDeserializer<Boolean> BOOLEAN_INSTANCE = 
 public static final ResultDeserializer<Byte> BYTE_INSTANCE = 
 public static final ResultDeserializer<Character> CHARACTER_INSTANCE = 
 public static final ResultDeserializer<Float> FLOAT_INSTANCE = 
 public static final ResultDeserializer<Integer> INTEGER_INSTANCE = 
 public static final ResultDeserializer<Short> SHORT_INSTANCE = 
 * 
 * 
<|del|> 
 if (deserializerFor(targetType) != null) { return; } 
 if (srcWriter == null) { return; } 
 final int end = compSerializer.lastIndexOf('.'); return end >= 0 ? compSerializer.substring(0, end) : ""; 
 if (pw == null) { return null; } 
<|del|>
 if (!new RefControl(user, change.getDest().get()).canUpload()) { 
 final ReceiveCommits receive = factory.create(projectControl, repo); final PrintWriter msg = toPrintWriter(err); 
 0 /* patchIndex */, 
 return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), 0 /* patchIndex */, 
// PatchSetKeys psk = new PatchSetKeys(patchesToKeys(patches), row - 1, // PatchTable.this.psid.getParentKey()); 
 // Parent table can be null here since we are not showing any next/previous links panel.add(new PatchLink.SideBySide(fn, patchKey, 0, null /* parent table */)); 
 protected PatchScreen.Type getPatchScreenType() { return PatchScreen.Type.SIDE_BY_SIDE; 
<|del|>
<|del|>
 String fileName = patch.getFileName(); int s = fileName.indexOf(File.pathSeparator); if (s >= 0) { fileName.substring(s + 1); } 
 return new ChangeLink(PatchUtil.C.upToChange(), psid.getParentKey()); 
 return new ChangeLink(PatchUtil.C.upToChange(), psid.getParentKey()); 
<|del|>
<|del|>
 void initializeRow(int row) { Patch patch = PatchTable.this.patchList.get(row - 1); 
 void initializeRow(int row) { Patch patch = PatchTable.this.patchList.get(row - 1); 
<|del|> 
 protected PatchScreen.Type getPatchScreenType() { return PatchScreen.Type.SIDE_BY_SIDE; 
 linkTable = new FlexTable(); linkTable.setStyleName("gerrit-SideBySideScreen-LinkTable"); linkTable.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT); linkTable.getFlexCellFormatter().setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_RIGHT); 
 protected PatchTable parentPatchTable; 
 String fileName = patch.getFileName(); int s = fileName.indexOf(File.pathSeparator); if (s >= 0) { fileName.substring(s + 1); } 
 /** The table that contains the next/previous links */ 
<|del|> 
 * @param text The text of this link * @param patchKey The key for this patch 
 // Note: use '/' here and not File.pathSeparator since git paths are always separated by / int s = fileName.lastIndexOf('/'); 
 nc.setAttribute("align", "center"); 
<|del|> 
<|del|> 
 /** Key local to Gerrit to identify a safe file. */ 
<|del|> 
 table.setText(0, C_BRANCH, Util.C.changeTableColumnBranch()); 
 @Option(name = "--slave", usage = "support fetch only") boolean slave; 
<|del|> 
<|del|> 
 /** protected for serialization over JSON-RPC */ protected boolean isSafeInline; 
 protected Map<String, String> directUrlsLeft = new HashMap<String, String>(); protected Map<String, String> directUrlsRight = new HashMap<String, String>(); 
 nc.nbsp(); 
<|del|> 
<|del|> 
 want.addAll(changesCreatedBy(db, parsedQuery[1])); 
 want.addAll(changesReviewedBy(db, parsedQuery[1])); 
 private abstract static class UserNameProcessor implements Callable<Set<Change.Id>> { 
 private static Set<Account.Id> getAccountSources(final ReviewDb db, final String userName) throws OrmException { AccountAccess dbAccounts = db.accounts(); ResultSet<Account>[] allAccounts = new ResultSet[] { 
 throw new RuntimeException(ex); 
 private List<Change.Id> changesCreatedBy(final ReviewDb db, final String userName) { 
 private List<Change.Id> changesReviewedBy(final ReviewDb db, final String userName) { 
 // This might return null if the change does't have any reviewer 
 // This might return null if the change does't have any reviewer 
 String base = GWT.getHostPageBaseURL(); base += "cat/" + KeyUtil.encode(patchKey.toString()); String left = base + "^1"; String right = base + "^0"; 
 nc.nbsp(); 
 nc.openTd(); maybeAppendImgTag(nc, left); 
 public static final int VERSION = 13; 
<|del|> 
<|del|> 
 filterBySortKey(result, changesCreatedBy(db, parsedQuery[1]), cmp, key); 
 * A Callable that returns a set of changes parameterized by a user. Subclasses should implement 
 * @return a set of all the account ID's matching the given user name in either of the following 
 for (Account account : rs) { result.add(account.getId()); 
 private Set<Change.Id> changesCreatedBy(final ReviewDb db, final String userName) throws OrmException { 
 return processor.call(); 
 private Set<Change.Id> changesReviewedBy(final ReviewDb db, final String userName) throws OrmException { 
 return processor.call(); 
<|del|> 
 @Query("WHERE changeOpen = false AND key.accountId = ? ORDER BY changeSortKey") ResultSet<ChangeApproval> closedByUserAll(Account.Id account) 
 usage = "displays the sha of each project in the specified branch") 
 createCommentEditor(suggestRow, column, line, file, null /* no parent */); 
 @Column(length = 40, notNull = false) 
 addChildren(parentMap, parentMap.get(c.getKey().get()), outResult); 
 * @return a link to the next file in this patch set, or a link to the main patch view * if we are at the last file. 
 protected Map<String, String> directUrlsLeft = new HashMap<String, String>(); protected Map<String, String> directUrlsRight = new HashMap<String, String>(); 
<|del|> 
<|del|> 
 public static final int VERSION = 13; 
<|del|> 
<|del|> 
 if (reviewedPatches.contains(p.getKey())) p.setReviewedByCurrentUser(true); 
 void setReviewedByCurrentUser(Key patchKey, boolean reviewed, AsyncCallback<VoidResult> callback); 
 // Mark this file reviewed as soon we display the diff screen if (Gerrit.isSignedIn() && isFirst) { setReviewedByCurrentUser(true /* reviewed */); } 
Copyright (C) 2009 The Android Open Source Project 
Copyright (C) 2009 The Android Open Source Project 
 private boolean reviewedByCurrentUser; 
 public boolean isReviewedByCurrentUser() { return reviewedByCurrentUser; 
 public void setReviewedByCurrentUser(boolean r) { reviewedByCurrentUser = r; 
<|del|>
 return new com.google.gwtorm.client.Key<?>[] {patchKey}; 
 @Query("WHERE key.accountId = ? AND key.patchKey.patchSetId = ?") ResultSet<AccountPatchReview> byReviewer(Account.Id who, PatchSet.Id ps) throws OrmException; 
 } else if (apr != null && !reviewed) { 
<|del|>
<|del|>
public final class PatchSetPublishDetailFactory 
<|del|>
 if (change.getStatus().isOpen() && 
 private final GerritServer gs; @Inject public PatchSetInfoFactory(GerritServer gs) { this.gs = gs; } public PatchSetInfo patchSetInfoFromRevCommit(RevCommit src, PatchSet 
<|del|>
 public static PatchSetInfo patchSetInfoFromPatchSetId(PatchSet.Id patchSetId) throws PatchSetInfoNotAvailableException { 
 final RevCommit src = 
 throw new PatchSetInfoNotAvailableException(e); 
<|del|>
<|del|>
public final class PatchSetInfoNotAvailableException extends Exception { 
 final PatchSetInfoFactory infoFactory; @Inject ChangeDetailServiceImpl(final SchemaFactory<ReviewDb> sf, PatchSetInfoFactory infoFactory) { super(sf); this.infoFactory = infoFactory; 
<|del|> 
 public PatchSetInfo get(RevCommit src, PatchSet.Id psi) throws OrmException { PatchSetInfo info = new PatchSetInfo(psi); 
 public PatchSetInfo get(PatchSet.Id patchSetId) 
 private final PatchSetInfoFactory infoFactory; 
 repo = gs.openRepository(projectName); 
 patchSetInfo = patchSetInfoFactory.get(patchSet.getId()); 
 private final RegisterNewEmailSender.Factory registerNewEmailFactory; 
 registerNewEmailFactory = esf; 
 sender = registerNewEmailFactory.create(address); 
 bind(PatchSetInfoFactory.class); 
 public AbandonedSender(@Assisted Change c) { super(c, "abandon"); 
 + "method is not SSH: " + replicateURI.toString()); 
<|del|> 
Copyright (C) 2009 The Android Open Source Project 
 for (CmdOption c : optionList) { parser.addOption(c, c); 
<|del|> 
<|del|> 
 throw new Failure(CMD_ERR, "Error accessing the database\n", e); 
 private PatchSet.Id patchSetId; 
 final Change.Id cid = ps.getId().getParentKey(); final ChangeControl control = changeControlFactory.validateFor(cid); final Change c = control.getChange(); 
 usage = "Score for " + category.getName() + "\n"; 
class CmdOption implements Option, Setter { private String metaVar; private boolean multiValued; private String name; private boolean required; private String usage; 
public class PatchSetIdHandler extends OptionHandler<PatchSet.Id> { public PatchSetIdHandler(final CmdLineParser parser, final OptionDef option, final Setter<? super PatchSet.Id> setter) { super(parser, option, setter); } 
 setter.addValue(id); return 1; 
 throw new UnloggedFailure(CMD_ERR, "Invalid patchset id"); 
 throw new UnloggedFailure(CMD_ERR, "Change is closed."); 
 sb.append("Patch Set "); sb.append(patchSetId.get()); sb.append(": "); 
 sb.append("Patch Set "); sb.append(patchSetId.get()); sb.append(": "); 
 boolean insert = false; 
 byOwner = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null); forReview = new ChangeTable.Section("", ApprovalViewType.USER, ownerId); closed = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null); 
 byOwner = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null); forReview = new ChangeTable.Section("", ApprovalViewType.USER, ownerId); closed = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null); 
<|del|> 
 aicFactory.want(aid); 
 approvals.put(id, new ApprovalSummary(psas.values())); 
<|del|> 
<|del|> 
<|del|> 
public class GerritPersonIdentProvider implements Provider<PersonIdent> { private final String name; private final String email; 
<|del|> 
 public static final String MESSAGE = "Invalid SSH user name."; 
 /** Regular expression that {@link #sshUserName} must match (not enforced in this class). */ public static final String SSH_USER_NAME_PATTERN = "^[a-zA-Z]([a-zA-Z0-9]|[!\"#$%&*+-.=?^_{|}~])+$"; 
 /** Regular expression that {@link #sshUserName} must match (not enforced in this class). */ public static final String SSH_USER_NAME_PATTERN = "^[a-zA-Z]([a-zA-Z0-9]|[!\"#$%&*+-.=?^_{|}~])+$"; 
 private static final Pattern SSH_USER_NAME_PATTERN = Pattern.compile(Account.SSH_USER_NAME_PATTERN); 
 Injector sshInjector; if (slave) { sshInjector = sysInjector.createChildInjector(new SshModule(), new SlaveCommandModule()); } else { sshInjector = sysInjector.createChildInjector(new SshModule(), new MasterCommandModule()); } 
<|del|> 
 Injector sshInjector = createSshInjector(sysInjector); 
 "^[a-zA-Z][a-zA-Z0-9._-]+$"; 
 /** Account id which is a unique (world-wide) SHA-1 value */ String accountId; 
 if (InvalidSshUserNameException.MESSAGE.equals(caught.getMessage())) { 
<|del|> 
 String getDN() throws NamingException { return get("dn"); } String get(final String attName) throws NamingException { 
 Map<String, String> map() { return Collections.unmodifiableMap(attsSingle); 
<|del|>
 return new ByProjectMergedChangesScreen(project, "n,z"); case NEW: case SUBMITTED: 
<|del|> 
<|del|> 
 String cn = (String) groupAtts.get(groupName).get(); 
 String cn = (String) groupAtts.get(groupName).get(); 
 } catch (NamingException e) { log.warn("Could not find dn", e); 
<|del|> 
 read.setMaxValue((short) 2); 
<|del|> 
<|del|>
 final Widget l = new SafeHtmlBuilder().append(msg.getMessage().trim()).wikify() .replaceAll(Gerrit.getConfig().getCommentLinks()).toBlockWidget(); 
 String link = "<a href=\"" + cfg.getString("CommentLink", commentLinkName, "link") + "\">$&</a>"; 
 return Collections.emptySet(); 
 effectiveGroups = new HashSet<AccountGroup.Id>(authGroups); 
Copyright 2009 Gert Scholten 
 static native JavaScriptObject objectResult(JavaScriptObject responseObject) /*-{ return responseObject.result; }-*/; 
 private static final native boolean getBoolean(JavaScriptObject jso, int pos) /*-{ return jso[pos]; }-*/; 
<|del|> 
 public static final ResultDeserializer<Boolean> BOOLEAN_INSTANCE = 
 public static final ResultDeserializer<Byte> BYTE_INSTANCE = 
 public static final ResultDeserializer<Character> CHARACTER_INSTANCE = 
 public static final ResultDeserializer<Double> DOUBLE_INSTANCE = 
 public static final ResultDeserializer<Float> FLOAT_INSTANCE = 
 public static final ResultDeserializer<Integer> INTEGER_INSTANCE = 
 public static final ResultDeserializer<Short> SHORT_INSTANCE = 
 * 
 final ReceiveCommits receive = factory.create(projectControl, repo); final PrintWriter msg = toPrintWriter(err); 
<|del|> 
 public ProjectControl validateFor(final Project.NameKey nameKey, final int need) throws NoSuchProjectException { 
<|del|> 
 private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException { if (!c.isVisible()) { 
<|del|> 
 this.queryProvider = queryProvider; 
<|del|> 
 private final Map<ChangeListener, ChangeListenerHolder> listeners = 
 public static class RefPattern extends StringKey<com.google.gwtorm.client.Key<?>> { 
 @Column(id = 2) 
<|del|> 
<|del|> 
<|del|> 
 import java.io.IOException; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; 
 RefControl(ProjectControl projectControl, String ref, PermissionCollection relevant) { 
 RefControl(ProjectControl projectControl, String ref, PermissionCollection relevant) { 
<|del|> 
 if (RefNames.REFS_CONFIG.equals(refName) && !projectControl.isOwner()) { 
 if (!(projectControl.getProjectState().isAllProjects() && getCurrentUser().getCapabilities().canAdministrateServer())) { 
 private static final Class<? extends SchemaVersion> C = Schema_24.class; 
 public Collection<ProjectRight> getAllProjectRights(final ApprovalCategory.Id id) { 
 // Same for the ref for this change. short refMinAllowed = 0, refMaxAllowed = 0; String destRef = change.getDest().get(); 
 return val >= level; 
 return val >= level; 
<|del|> 
<|del|> 
 public static final Class<Schema_161> C = Schema_161.class; 
 return val >= level; 
 return val >= level; 
 if (state.getRefRights(at).isEmpty()) { return isProjectStateValid(user, at, state); } else { return isRefStateValid(user, at, state); } 
 int bLength = b.getRefPattern().length(); if ((bLength - aLength) == 0) { return a.getApprovalCategoryId().get() .compareTo(b.getApprovalCategoryId().get()); } 
 final Collection<RefRight> rights = Collections.unmodifiableCollection(db.refRights().byProject( 
 ProjectState create(Project project, Collection<RefRight> localRights); 
<|del|> 
<|del|> 
 ReviewDb db = schemaFactory.open(); 
 db.close(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 final String username = who.getLocalUser(); 
<|del|> 
Copyright (C) 2010 The Android Open Source Project 
<|del|> 
 final Object output = queue.take(); if (output != null) { stdout.println(gson.toJson(output)); stdout.flush(); 
<|del|> 
 private static class ChangeListenerHolder { final ChangeListener listener; final IdentifiedUser user; 
 ChangeListenerHolder(ChangeListener l, IdentifiedUser u) { listener = l; user = u; } 
<|del|> 
 private final Map<ChangeListener, ChangeListenerHolder> listeners = 
 poolSize = config.getInt("sshd", "streamThreads", cores + 1); 
 /** Queue of events to stream to the connected user. */ private final LinkedBlockingQueue<Object> queue = new LinkedBlockingQueue<Object>(MAX_EVENTS); 
 private volatile boolean dropped = false; 
 dropped = true; } 
 stdout.println(gson.toJson(queue.take())); stdout.flush(); 
 event.kind = kind; 
 addArg(args, "--is-draft", String.valueOf(patchSet.isDraft())); addArg(args, "--trivial-rebase", String.valueOf(isTrivialRebase)); addArg(args, "--message-updated-only", String.valueOf(noCodeChange)); 
 boolean inDblQuote = false; 
 username = username.trim(); 
 rp.setAllowNonFastForwards(true); rp.setRefLogIdent(user.newRefLogIdent()); rp.setTimeout(transferConfig.getTimeout()); rp.setMaxObjectSizeLimit( transferConfig.getEffectiveMaxObjectSizeLimit(projectControl.getProjectState())); 
 ui.message("warning: could not delete function nextval_project_id"); 
 stdout.println(); } } else { stdout.print(p.getName()); stdout.println(); 
 usage = "displays the sha of each project in the specified branch") 
<|del|> 
 ObjectId id = getObjectIdForBranch(p.getNameKey(), showBranch); if (id != null) { stdout.print(ObjectId.toString(id) + " "); 
 stdout.print(id.name() + " "); stdout.print(p.getName()); stdout.println(); 
 stdout.print(id.name() + " "); stdout.print(p.getName()); stdout.println(); 
 IdentifiedUser u = user.get().asIdentifiedUser(); userId = u.getAccountId(); userEditPrefix = RefNames.refsEditPrefix(userId); } else { userId = null; viewMetadata = false; 
import org.eclipse.jgit.transport.RefFilter; 
<|del|> 
<|del|> 
 if (!project.isAllRefsVisible()) { // Pretend the project doesn't exist 
 public boolean isAllRefsVisible() { 
<|del|> 
 @Column(id = 1, name = Column.NONE) protected Key key; 
 try { db.patchSetApprovals().delete(toDelete); } catch(OrmException ex) { result.addError(new ReviewerResult.Error( ReviewerResult.Error.Type.COULD_NOT_REMOVE, "Could not remove reviewer " + reviewerId)); } } else { 
 protected InheritedRefRight(){ 
 * @return the cached data; null if no such project exists, projectName is null or an error 
<|del|> 
 private ProjectControl projectControl; 
 @Argument(index = 0, required = true, multiValued = true, usage = "projects to set the parent") private List<ProjectControl> children = new ArrayList<ProjectControl>(); 
 PrintWriter p = toPrintWriter(err); 
 if (e != null && e.controlFor(currentUser).isVisible()) { final ProjectControl pctl = e.controlFor(currentUser); 
 void populate(final int row, final Branch k) { 
 private final String queueName; private final int threadPoolSize; 
 private WorkQueue workQueue; 
 stdout.print("----------------------------------------------" 
Copyright (C) 2010 The Android Open Source Project 
<|del|> 
 private final Change.Id changeId; 
 toDelete.add(psa); } else { permitted = false; break; 
 return new ChangeControl(getRefControl().forUser(who), getChange()); 
 throw notTimeUnit(section, subsection, setting, valueString); 
public class ProjectCreatorGroupsProvider implements Provider<Set<AccountGroup.Id>> { private static final Logger log = LoggerFactory.getLogger(ProjectCreatorGroupsProvider.class); 
 } else { 
 if (!isAnyIncludedIn(currentUser.getEffectiveGroups(), projectCreatorGroups)) { throw new Failure(1, "fatal: Not permitted to create " + projectName); 
 if (ownerIds != null && !ownerIds.isEmpty()) { ownerIds = new ArrayList<AccountGroup.Id>(new HashSet<AccountGroup.Id>(ownerIds)); } else { 
<|del|> 
 protected boolean canAdd; 
<|del|> 
 } 
 rights.display(result.groups, result.rights); addPanel.setVisible(result.canModifyAccess); delRight.setVisible(rights.getCanDelete()); 
 usage = "displays the sha of each project in the specified branch") 
<|del|> 
 allowGoogleAccountUpgrade = false; 
 CurrentUser user) { 
 WorkQueue.Executor executor; 
<|del|> 
<|del|> 
<|del|> 
 final ProjectControl pc = projectControlFactory.validateFor(projectName, ProjectControl.OWNER | ProjectControl.VISIBLE); final ProjectState projectState = pc.getProjectState(); 
 @Override public void onComplete(Continuation self) {} @Override public void onTimeout(Continuation self) { executor.remove(this); } @Override 
<|del|> 
 private Set<Change.Id> changesCreatedBy(final ReviewDb db, final String userName) throws OrmException { 
 return processor.call(); 
 private Set<Change.Id> changesReviewedBy(final ReviewDb db, final String userName) throws OrmException { 
<|del|> 
 usage = "displays the sha of each project in the specified branch") 
<|del|> 
 final ChangeControl changeControl = changeControlFactory.validateFor(changeId); Change change = changeControl.getChange(); 
 throw new IllegalArgumentException(myAction.getCategoryId() + " not an action"); 
<|del|> 
 @Query("WHERE open = true AND sortKeyDesc > ? ORDER BY sortKeyDesc LIMIT ?") 
<|del|> 
 "SELECT change_id, sort_key FROM changes" + " WHERE sort_key_desc IS NULL OR sort_key_desc=''"); 
 if (changes.isEmpty()) { break; } 
 .invertSortKey("fffffffffffffffe")); 
 .invertSortKey("fffe9fffffffffff")); 
 assertEquals("0001600000000000", ChangeUtil .invertSortKey("FFFE9FFFFFFFFFFF")); 
 assertEquals("z", ChangeUtil.invertSortKey("/")); 
<|del|> 
 NB.encodeInt32(raw, 0, uuidPrefix); NB.encodeInt32(raw, 4, uuidSeq--); 
 assertEquals("ffffffffffffffff", ChangeUtil .invertSortKey("0000000000000000")); 
 boolean showedBanner = false; 
 boolean showedProject = false; 
 db.refRights().insert(toUpdate); db.refRights().delete(toDelete); 
 return def; 
 public static void bumpRowVersionNotLastUpdatedOn(Change.Id id, ReviewDb db) 
 import org.apache.sshd.server.Environment; 
 private RevisionApi revisionApi(PatchSet patchSet) throws RestApiException { return changeApi(patchSet).revision(patchSet.getRevision().get()); 
 try { webSession.get().login(arsp, remember); } catch (OrmException e) { log.error("Unable to log in",e); } 
Copyright (C) 2008 The Android Open Source Project 
 KeyGenerator prng) throws OrmException { 
 return now.after(expireAt); 
 } webSession.get().login(arsp, true /* persistent cookie */); 
 try { webSession.get().login(res, false); } catch (OrmException e) { log.error("Unable to log in", e); result.success = false; callback.onSuccess(result); return; } 
 this.cache = cache; this.prng = prng; 
 protected Timestamp refreshCookieAt; 
 public void updateLastSeen() { lastSeen = now(); 
 public boolean needsCookieRefresh() { return refreshCookieAt.before(now()); 
 ResultSet<TrackingId> byChange(Change.Id change) throws OrmException; 
 ResultSet<TrackingId> byTrackingId(TrackingId.Id trackingId) throws OrmException; 
 MagicBranchInput(ReceiveCommand cmd, LabelTypes labelTypes, NotesMigration notesMigration) { 
<|del|> 
 || getCurrentUser().isAdministrator() // site administers are god 
 private ChangeApi changeApi(PatchSet patchSet) throws RestApiException { return gApi.get().changes().id(patchSet.getId().getParentKey().get()); } 
 private RevisionApi revisionApi(PatchSet patchSet) throws RestApiException { return changeApi(patchSet).revision(patchSet.getRevision().get()); 
<|del|> 
public class Hyperlink extends com.google.gwt.user.client.ui.Hyperlink { 
import com.google.inject.servlet.RequestScoped; import com.google.inject.servlet.ServletModule; 
 @Query 
 @Named(WebSession.CACHE_NAME) final Cache<ActiveSession.Key, ActiveSession> cache) { this.reviewDbFactory = reviewDbFactory; 
<|del|> 
 c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged)); } catch (PatchSetInfoNotAvailableException e1) { logError("Cannot read merged patch set " + merged, e1); 
<|del|> 
<|del|> 
import com.google.gerrit.reviewdb.AccountDiffPreference.Whitespace; 
<|del|> 
 AccountDiffPreference diffPref = new AccountDiffPreference(Gerrit.getUserAccount().getId()); diffPref.setIgnoreWhitespace(getIgnoreWhitespace()); 
 public AccountDiffPreference run(ReviewDb db) throws OrmException { return currentUser.get().getAccountDiffPreference(); 
 public AccountDiffPreference run(ReviewDb db) throws OrmException { return currentUser.get().getAccountDiffPreference(); 
 public Whitespace getIgnoreWhitespace() { return Whitespace.forCode(ignoreWhitespace); 
 public void setIgnoreWhitespace(Whitespace ignoreWhitespace) { this.ignoreWhitespace = ignoreWhitespace.getCode(); 
Copyright (C) 2010 The Android Open Source Project 
 DiffSummaryKey.fromPatchListKey(PatchListKey.againstParentNum(1, b, ws)), project); 
 private class LargeObjectTombstone extends PatchList { 
<|del|> 
<|del|> 
<|del|>
public class MineWatchedOpenChangesScreen extends PagedSingleListScreen { 
<|del|> 
 diffPref.setShowTabs(showTabs.getValue()); diffPref.setContext(getContext()); 
 throw new IllegalArgumentException("diffPref.getAccountId() " + diffPref.getAccountId() + " doesn't match" + " the accountId of the signed in user " + getAccountId()); 
<|del|> 
 // TODO(cranger): maybe get the state through the accountCache instead. 
 if (idSideB != null) { if (idSideB.equals(cachedPatchSetId)) { commitMessageBlock.display(cachedCommitMessage); } else { fetchCommitMessage(idSideB); } } 
 final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide()); 
 final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified()); 
 @Column(id = 2) 
 cancelButton = new Button(); 
 patchSetPanel.setActive(false); 
<|del|> 
<|del|> 
 } 
 private CollectionsUtil() { } 
<|del|> 
 public static final AccessCategory.Id CODE_REVIEW = new AccessCategory.Id("CodeReview"); 
 protected Key key; 
 throw new ProvisionException("Cannot query approval access categories", e); 
 return Collections.unmodifiableMap(accessCategories); 
 private final Collection<AccountGroup> groups; 
 private final Iterable<SshKeyCacheEntry> sshKeyIter; 
 isVisible = (getUser().isInternalUser() || canPerform(Permission.READ)) && canRead(); 
 new ApprovalCategory.Id("CPRJ"); 
<|del|> 
 new SshKeyCacheEntryIterable(); 
 this.groups = Collections.unmodifiableCollection(groups); 
<|del|> 
 new SshKeyCacheEntryIterable(); private final Iterable<SshKeyCacheEntry> sshKeyIter; 
<|del|> 
 public void setComments(List<Comment> comments) throws OrmException { 
class SshKeyCacheEntryIterable { static final SshKeyCacheEntryIterable EMPTY = new SshKeyCacheEntryIterable(); 
class SshKeyCacheEntryIterable { static final SshKeyCacheEntryIterable EMPTY = new SshKeyCacheEntryIterable(); 
 SshKeyCacheEntryIterable(Iterable<SshKeyCacheEntry> sshKeyIter) { 
 Iterable<SshKeyCacheEntry> getSshKeyCacheEntries() { 
 protected boolean regex; 
 protected Username() { } public Username(String name) { 
<|del|> 
<|del|> 
 private final Account account; private final Set<AccountGroup.UUID> internalGroups; private final Collection<AccountExternalId> externalIds; private Cache<IdentifiedUser.PropertyKey<Object>, Object> properties; 
Copyright (C) 2009 The Android Open Source Project 
 mail_dir = new File(etc_dir, "mail"); 
<|del|> 
 + " in protobuf format", err); 
 againstParent = readVarInt32(in) != 0; 
 newName = hdr.getNewName(); 
 return new SshKeyCacheEntryCollection( SshKeyCacheEntryCollection.Type.NO_KEYS); 
 private void extractMailExample(String orig) throws Exception { File ex = new File(site.mail_dir, orig + ".example"); 
 private void extractMailExample(String orig) throws Exception { File ex = new File(site.mail_dir, orig + ".example"); 
 private static BaseEdit readEdit(final InputStream in) throws IOException { 
 return new BaseEdit(beginA, endA, beginB, endB); 
 BaseEdit[] inner = new BaseEdit[innerCount]; 
 protected List<LineEdit> edits; 
 g.registerTypeAdapter(com.google.gerrit.prettify.common.LineEdit.class, 
public class EditDeserializer implements JsonDeserializer<LineEdit>, JsonSerializer<LineEdit> { public LineEdit deserialize(final JsonElement json, final Type typeOfT, 
 if (src.getEdits() != null) { for (BaseEdit e : src.getEdits()) { 
 if (curEdit.getEdits() != null) { 
 newName = hdr.getOldName(); 
Copyright (C) 2010 The Android Open Source Project 
 for (Account.Id accountId : initialMembers) { 
 Object d = data; if (d instanceof byte[]) { 
 byte[] d = new byte[len]; IO.readFully(in, d, 0, len); data = d; 
 private static final long serialVersionUID = 1L; private transient volatile Object data; 
<|del|> 
 Object d = data; if (d instanceof byte[]) { byte[] buf = (byte[]) d; 
 m = new PopulatingCache(eh, c); 
class SerializableProtobuf<T> implements Serializable { private transient volatile T object; 
class SerializableProtobuf<T> implements Serializable { private transient volatile T object; 
 SerializableProtobuf(T object, ProtobufCodec<T> codec) { 
 T toObject(ProtobufCodec<T> codec, Provider<T> provider) { 
 codec.mergeFrom(buf, object); 
 d = codec.decode((byte[]) d); 
 codec.mergeFrom((byte[]) d, tmp); 
 return (T) d; 
 AuthConfig authConfig, 
<|del|> 
<|del|> 
 private static final Logger log = LoggerFactory.getLogger(IdentifiedUser.class); 
 private final Set<DownloadScheme> downloadSchemes; 
<|del|> 
 public final String type = "change-restored"; 
 ArrayList<AccountExternalId> out = new ArrayList<AccountExternalId>(accIds.size()); for (AccountExternalId extId : accIds) { String accEmail = extId.getEmailAddress(); if (accEmail != null && accEmail.equals(email)) { 
 if (id.getEmailAddress() != null) { byEmail.remove(new EmailWrapper(id.getEmailAddress())); } 
 public int getRelationID() { 
 @Option(name = "--output", aliases = {"-o"}, required = true, metaVar = "FILE", usage = "File to write .proto into") private File file; 
 if (!lf.commit()) { throw new IOException("Could not write to " + file); } 
 public Map<K, V> getAll(Iterable<K> keys); 
 if (dst == null) { dst = src; } 
 public ProjectState get(Project.NameKey projectName); 
 for (ChangeData cd : prefetchData(p.restart(lastBeforeRestart))) { 
 private Collection<ChangeData> prefetchData(ResultSet<ChangeData> resultSet) throws OrmException { final List<ChangeData> data = resultSet.toList(); 
 if (needed.contains(NeededData.PROJECT_STATE)) { needed.add(NeededData.CHANGE); 
 if (needed.contains(NeededData.PROJECT_STATE)) { needed.add(NeededData.CHANGE); 
 HashSet<Project.NameKey> projectNames = new HashSet<Project.NameKey>(); 
class PrefetchableAndPredicate extends AndPredicate<ChangeData> 
 PrefetchableAndPredicate( 
 PrefetchableAndPredicate(Predicate<ChangeData>... that) { 
class PrefetchableOrPredicate extends OrPredicate<ChangeData> implements 
 PrefetchableOrPredicate( 
 ProjectState checkedGet(Project.NameKey projectName) throws IOException; 
 Map<NameKey, List<Predicate<ChangeData>>> rules = getRules(); if (rules.isEmpty()) { return EnumSet.noneOf(NeededData.class); } EnumSet<NeededData> needed = EnumSet.of(NeededData.CHANGE); 
 if (active == null || active == account.isActive()) { map.put(account.getId(), info); 
 if (!a.isActive()) { 
 IdentifiedUser cu = SshUtil.createUser(sd, userFactory, key.getAccount()); if (!cu.getAccount().isActive()) { 
 IdentifiedUser cu = SshUtil.createUser(sd, userFactory, key.getAccount()); if (!cu.getAccount().isActive()) { 
<|del|> 
 ProjectControl pc = getProjectControl(req); if (!pc.canRunUploadPack()) { 
<|del|> 
 HashSet<AccountGroup.Id> all = new HashSet<AccountGroup.Id>(); all.addAll(authConfig.getRegisteredGroups()); all.removeAll(authConfig.getAnonymousGroups()); groupIds = Collections.unmodifiableSet(all); 
 public Set<AccountGroup.Id> get() { 
 this.internalChangeQuery = internalChangeQuery; 
 return changeControlFactory .create(controlForRef(notes.getChange().getDest()), notes); 
 } watchesTab.display(result); updateUnwatchedProjects(); 
<|del|> 
<|del|> 
 final MySuggestionDisplay suggestionDisplay = new MySuggestionDisplay(); 
 /* top table */ grid = new Grid(2, 2); 
 pageSize = AccountGeneralPreferences.DEFAULT_PAGESIZE; 
<|del|> 
 private String hintStyleName = Gerrit.RESOURCES.css().inputFieldTypeHint(); 
 InlineHyperlink link = createLink(index, patchType, SafeHtml.asis(Util.C .prevPatchLinkIcon()), null); 
 public List<InheritedRefRight> rights; public boolean canModifyDescription; public boolean canModifyAgreements; public boolean canModifyAccess; 
 populate(row, r); 
 table.setWidget(row, 3, new Hyperlink(group.getName(), Dispatcher .toAccountGroup(group.getId()))); 
 public static final String REF_MERGE_STRATEGY_TAB = "merge_strategies"; 
 @Column(id = 5) protected char submitType; @Column(id = 6, notNull = false, name = "parent_name") 
 final RefMergeStrategy.RefPattern rp = new RefMergeStrategy.RefPattern(RefRight.ALL); 
<|del|> 
 listener().to(LocalDiskRepositoryManager.Lifecycle.class); bind(CachePool.class); install(ProjectCacheImpl.module()); 
 public Project.Id getId() { 
 Factory(final ProjectControl.Factory p, final Provider<ReviewDb> d) { 
<|del|> 
 CommentsUtil commentsUtil, 
 CommentsUtil commentsUtil, 
 return projectId; 
 + "; run first gerrit version 2.1.5 or 2.1.4 to upgrade the" + " schema at least to version 34" + "; then restart this new gerrit version."); 
 return group.equals(grant.group) && pattern.equals(grant.pattern); 
 grant(local, OWN, admin, "refs/*", 1); 
 public Collection<RefRight> getAllRights(ApprovalCategory.Id action, boolean dropOverridden) { 
 Grant grant = new Grant(right.getAccountGroupId(), right.getRefPattern()); if (grants.contains(grant)) { 
 assertTrue("can read", u.controlForRef("refs/tags/foobar").isVisible()); assertTrue("no master", u.controlForRef("refs/heads/master").isVisible()); 
 grant(false, SUBMIT, registered, "refs/*", 1); grant(true, SUBMIT, registered, "refs/*", 0); grant(true, SUBMIT, registered, "refs/heads/*", -1, 1); 
 grant(false, SUBMIT, registered, "refs/*", 1); grant(true, SUBMIT, registered, "refs/*", 0); grant(true, SUBMIT, registered, "refs/heads/*", -1, 1); 
 grant(false, SUBMIT, registered, "refs/*", 1); grant(true, SUBMIT, registered, "refs/*", 0); grant(true, SUBMIT, registered, "refs/heads/*", -1, 1); 
 }); try { bu.execute(); } catch (UpdateException | RestApiException e) { logWarn("Cannot abandon changes for deleted project " + destProject, e); 
<|del|> 
 static class ListKey { static final ListKey ALL = new ListKey(); 
 Util.ACCOUNT_SVC.myProjectWatch( new ScreenLoadCallback<List<AccountProjectWatchInfo>>(this) { 
 if (request == req) { callback.onSuggestionsReady(req, response); request = null; callback = null; 
<|del|> 
 request = req; callback = cb; 
<|del|> 
<|del|> 
<|del|> 
 void createProject() throws OrmException, RepositoryNotFoundException, IOException, CreateProjectParamsException; 
 projectCache.evict(projectControl.getProject()); 
 public abstract void deleteRepository(String repoName) throws SecurityException, IOException; 
 * @param projectName of the project to be created. 
 * @param projectName of the project to be deleted. 
class HttpsClientSslCertAuthFilter implements Filter { 
 String userName; 
 * into the <review-site>/etc/keystore. 
 if (link != null) { 
 if (link != null) { 
 retryDelay = Math.max(0, getInt(rc, cfg, "replicationretry", 1)); 
 public void onValueChange(CheckBoxSelectionEvent checkBoxSelectionEvent) { final boolean value = checkBoxSelectionEvent.isChecked(); final String selectedProject = checkBoxSelectionEvent.getProjectName(); hideOnSuccessPanel(); setSelectedProjectsTable(value, selectedProject); 
 try { hookResult = runSyncHook(project.getNameKey(), refUpdateHook, args); } catch (TimeoutException e) { hookResult = new HookResult(-1, "Synchronous hook timed out"); } 
 return hookResult; 
 private final AccountCache accountCache; private final ChangesCollection changes; 
 final OnEditEnabler sbl = new OnEditEnabler(save); sbl.listenTo(addressTxt); 
 saveProject = new Button(Util.C.buttonSaveChanges()); saveProject.addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { doSave(); } }); 
 if (orig == null) { orig = ""; } 
 retryDelay = Math.max(0, getInt(rc, cfg, "replicationretry", 1)); 
 } setParentButton.setEnabled(false); } 
 private final PerformCreateProjectImpl.Factory performCreateProjectFactory; 
 RetrieveParentCandidatesImpl( final ProjectControl.Factory projectControlFactory, final ReviewDb db, @WildProjectName final Project.NameKey wildProject) { 
 if (c.isVisible() || c.isOwner()) { if (!r.contains(p.getParent()) && !p.getParent().equals(wildProject)) { 
 } 
<|del|> 
 if (refs.isEmpty()) { // Remove Git Repository. repoManager.deleteRepository(p.get()); 
 if (refs.isEmpty()) { // Remove Git Repository. repoManager.deleteRepository(p.get()); 
 // Update parent relationship. for (final Project c : db.projects().getChildren(p.get())) { c.setParent(projectControl.getProject().getParent()); db.projects().update(Collections.singleton(c)); projectCache.evict(c); } 
 // Remove all added RefRights. db.refRights().delete(db.refRights().byProject(p)); 
<|del|> 
<|del|> 
<|del|> 
 final AdminOp operation) { 
<|del|> 
 public void setParent() throws OrmException, NoSuchProjectException, OperationNotExecutedException; 
 // If no parent was selected (parent == null), use the default. if (parentNameKey != null) { final ProjectState state = projectCache.get(parentNameKey); 
 if (grandParents.contains(pc) || pc.equals(parentNameKey)) { 
public class SearchProjects { final private HandlerManager handlerManager = new HandlerManager(this); 
 List<ProjectData> filterProjectsList = new ArrayList<ProjectData>(); 
 public void addSearchHandler(SearchHandler handler) { handlerManager.addHandler(SearchEvent.getType(), handler); handlerManager.addHandler(ClickSearchEvent.getType(), handler); 
 if (insertedRows.size() > 1) { Collections.sort(insertedRows, new Comparator<String>() { public int compare(final String a, final String b) { return a.compareTo(b); } }); } 
 case Event.ONCLICK: { 
<|del|> 
 final String newProjectName = projectNameTxtBox.getText().trim(); final String currentProjectName = getProjectKey().toString(); renameButton.setEnabled(!newProjectName.isEmpty() && !currentProjectName.equals(newProjectName)); 
 mergedParents = null; 
<|del|> 
 null, null, null, null, null, null, null, null, null, null), null)); 
 if (!createTxt.getText().trim().isEmpty() && event.getCharCode() == KeyCodes.KEY_ENTER) { 
 private final ChangeHookRunner hooks; 
 private Account.Id createAccountIfUserCanBeAuthenticated(final String username) throws CmdLineException { 
 throw new Failure(1, "fatal: '" + project.getName() + "': not a git archive", e); 
 logDebug("Finding new and replaced changes"); newChanges = new ArrayList<>(); 
 void appendChangeId(Change.Id changeId) { 
 long ttl = getSeconds(name, "maxage", p.maxAge()); c.setEternal(ttl == 0); if (ttl != 0) { c.setTimeToIdleSeconds(0); c.setTimeToLiveSeconds(ttl); } 
 c.setEternal(true); 
 @Inject CreateCodeReviewNotes(final ReviewDb reviewDb, @GerritPersonIdent final PersonIdent gerritIdent, final AccountCache accountCache, final ApprovalTypes approvalTypes, @Assisted final Repository db) { 
 throw new CodeReviewNoteCreationException(e); } finally { reader.release(); inserter.release(); revWalk.release(); 
 new StringBuilder("Update notes for submitted changes\n\n"); 
 ours.set(c, noteContent); 
 ours.set(c, noteContent); 
 approvalTypes.getApprovalType(a.getCategoryId()).getCategory(), a.getValue(), accountCache.get(a.getAccountId()).getAccount()); 
 approvalTypes.getApprovalType(a.getCategoryId()).getCategory(), a.getValue(), accountCache.get(a.getAccountId()).getAccount()); 
 formatter.appendBranch(commit.change.getProject().get(), 
 throw new CodeReviewNoteCreationException(commit, e); 
<|del|> 
 ObjectId commitId = inserter.insert(b); inserter.flush(); return revWalk.parseCommit(commitId); 
 new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US); 
 void appendChangeId(Change.Key changeKey) { sb.append("Change-Id: ").append(changeKey.get()).append("\n"); 
 // TODO: use category.getLabel() when available sb.append(category.getName().replace(' ', '-')); sb.append(value < 0 ? "-" : "+").append(Math.abs(value)).append(": "); 
 // TODO: use category.getLabel() when available sb.append(category.getName().replace(' ', '-')); sb.append(value < 0 ? "-" : "+").append(Math.abs(value)).append(": "); 
 // there is not really a common ancestry for these two note revisions 
 ListMultimap<ObjectId, Ref> existing = changeRefsById(); GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey()); 
<|del|> 
<|del|> 
<|del|> 
 void appendBranch(Branch.NameKey branch) { sb.append("Branch: ").append(branch.get()).append("\n"); } 
 void appendSubmittedAt(Date date) { sb.append("Submitted-at: ").append(rfc2822DateFormatter.format(date)) 
 public AccountGroup.Id getIncludedGroupId() { 
<|del|> 
<|del|> 
 displayPersonNameInReviewCategory = false; 
Copyright (C) 2011 The Android Open Source Project 
Copyright (C) 2011 The Android Open Source Project 
Copyright (C) 2011 The Android Open Source Project 
 return performCreateGroup.createGroup(groupName, null, false, null, Collections.singleton(me), null); 
 throw new Failure(new NoSuchGroupException(name)); 
Copyright (C) 2011 The Android Open Source Project 
Copyright (C) 2011 The Android Open Source Project 
Copyright (C) 2011 The Android Open Source Project 
Copyright (C) 2011 The Android Open Source Project 
 this.remotePeerProvider = remotePeerProvider; this.dbProvider = dbProvider; 
 /** The account identity for the user. */ 
Copyright (C) 2011 The Android Open Source Project 
Copyright (C) 2011 The Android Open Source Project 
Copyright (C) 2011 The Android Open Source Project 
 private static final String BYINCLUDEDGROUP_NAME = "groups_includes"; 
<|del|> 
 return Collections.unmodifiableCollection(groupArray); 
 return Collections.emptyList(); 
 * @param initialMembers initial members to be added to the new group * @param initialIncludedGroups initial groups to include in the new group 
 final String groupDescription, final boolean visibleToAll, final AccountGroup.Id ownerGroupId, final Collection<? extends Account.Id> initialMembers, final Collection<? extends AccountGroup.Id> initialIncludedGroups) throws OrmException, NameAlreadyUsedException { 
 if (initialIncludedGroups != null) { 
 } else if (isRuleNotAllowed(caught)) { 
 void changeGroupOptions(AccountGroup.Id groupId, GroupOptions groupOptions, 
<|del|> 
 private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) { 
 import java.sql.SQLException; import java.sql.Statement; 
 newChanges = Collections.emptyList(); logDebug("Aborting early due to invalid commit"); 
<|del|>
 if (action == null) { throw new NullPointerException("action"); 
 patches = list.toPatchList(psIdNew, getCurrentFileList()); 
<|del|> 
 /** * The change id for which the old version history is valid. */ private static Change.Id currentChangeId; 
 /** * The change id for which the old version history is valid. */ private static Change.Id currentChangeId; 
 if (index == 0) { 
Copyright (C) 2011 The Android Open Source Project 
<|del|> 
 projectCache.evictAll(); 
 } else { 
 } else { 
 diffPrefs = new ListenableAccountDiffPreference().get(); 
 private int patchIndex; private ListenableAccountDiffPreference prefs; 
 } catch (RestApiException err) { 
 try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs()); ObjectInserter ins = repo.newObjectInserter()) { bu.setRepository(repo, rp.getRevWalk(), ins) .updateChangesInParallel(); 
 try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs()); ObjectInserter ins = repo.newObjectInserter()) { bu.setRepository(repo, rp.getRevWalk(), ins) .updateChangesInParallel(); 
 try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs()); ObjectInserter ins = repo.newObjectInserter()) { bu.setRepository(repo, rp.getRevWalk(), ins) .updateChangesInParallel(); 
 infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit())); 
 List<PatchSetInfo.ParentInfo> pInfos = new ArrayList<PatchSetInfo.ParentInfo>(); 
 List<PatchSetInfo.ParentInfo> pInfos = new ArrayList<PatchSetInfo.ParentInfo>(); 
<|del|> 
 Grant grant = new Grant(right.getAccountGroupId(), right.getRefPattern()); if (grants.contains(grant)) { 
 grants.add(grant); 
 RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get())); 
 public CurrentUser getCurrentUser() { return getRefControl().getCurrentUser(); 
 public boolean canRebase() { return isOwner() || getRefControl().canSubmit() || getRefControl().canRebase(); 
 public boolean canRestore() { return canAbandon() // Anyone who can abandon the change can restore it back 
<|del|> 
 @Option(name = "--remove", aliases = {"-r"}, metaVar = "EMAIL", usage = "reviewer to remove") void optionRemove(Account.Id who) { toRemove.add(who); } 
Copyright (C) 2011 The Android Open Source Project 
<|del|> 
 * Get the sections that pertain only to this project. Expand the roles from RoleSections defined * in this or parent projects. 
 return group.equals(grant.group) && pattern.equals(grant.pattern); 
Copyright (C) 2011 The Android Open Source Project 
 @Option(name = "--remove", aliases = {"-r"}, metaVar = "EMAIL", usage = "reviewer to remove") void optionRemove(Account.Id who) { toRemove.add(who); } 
 log.error("Error updating reviewers on change " + changeId, err); writeError("fatal", "internal error while updating " + changeId); 
Copyright (C) 2009 The Android Open Source Project 
 final CellFormatter fmt = table.getCellFormatter(); final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap(); final StringBuilder hint = new StringBuilder(); 
<|del|> 
<|del|> 
class CherryPick extends MergeOp { 
 final ProjectState pe = mergeArguments.projectCache.get(branch.getParentKey()); 
 final ProjectState pe = mergeArguments.projectCache.get(branch.getParentKey()); 
<|del|> 
<|del|>
<|del|>
 super(_message.toString()); 
@Singleton public class ChangeTestMergeQueue { 
@Singleton public class ChangeTestMergeQueue { 
 case ACCOUNT_NOT_FOUND: 
 @Option(name = "--name", required = true, metaVar = "PROJECT", usage = "project to compile rules for") private String projectName; 
 @Option(name = "--name", required = true, metaVar = "PROJECT", usage = "project to compile rules for") private String projectName; 
 @GerritServerConfig private Config config; 
 Project.NameKey project = new Project.NameKey(projectName); 
 rulesId = git.resolve(GitRepositoryManager.REF_CONFIG + ":rules.pl"); 
 if (cacheDir == null) { 
 File tempDir = File.createTempFile("GerritCodeReview_", ".rulec"); if (!tempDir.delete() || !tempDir.mkdir()) throw new IOException("Cannot create temporary directory " + tempDir); 
 compileProlog(rulesId, tempDir); 
<|del|> 
 private void createJarArchive(File archiveFile, List<String> toBeJared, File tempDir) 
<|del|> 
 private List<File> getAllFiles(File dir, String prefix) { 
 for (File f : dir.listFiles()) { if (f.getName().endsWith(prefix)) { 
<|del|> 
 } catch (PartialResultException e) { } 
 if (cfgUrl == null && type_str == null) { // default to pathinfo format for internally managed gitweb. type_str = "gitweb-pathinfo"; } 
 logError( String.format( "Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err); 
 logError(String.format("Replacement for project %s was not attempted", project.getName())); 
<|del|> 
 File jarFile = new File(rulesDir, "rules-" + rulesId.getName() + ".jar"); if (!jarFile.isFile()) { return null; 
 } URL[] urls = new URL[]{url}; ClassLoader urlLoader = new URLClassLoader(urls, defaultLoader); LoaderRef lRef = new LoaderRef(rulesId, urlLoader); synchronized(lock) { referMap.put(rulesId, lRef); } return urlLoader; 
 cacheDir = site.resolve(config.getString("cache", null, "directory")); 
<|del|> 
 ObjectId key = ((LoaderRef) ref).key; if (classLoaderCache.get(key) == ref) { classLoaderCache.remove(key); } 
 private static final Logger log = LoggerFactory.getLogger(RulesCache.class); private final Map<ObjectId, LoaderRef> classLoaderCache = 
 protected RulesCache (@GerritServerConfig Config config, SitePaths site) { cacheDir = site.resolve( 
 protected RulesCache (@GerritServerConfig Config config, SitePaths site) { cacheDir = site.resolve( 
 public synchronized ClassLoader getClassLoader(ObjectId rulesId) { if (rulesId == null || rulesDir == null) { return null; } Reference<? extends ClassLoader> ref = classLoaderCache.get(rulesId); 
<|del|> 
 } 
 } catch (MalformedURLException e) { log.error("Path to rules jar is broken", e); 
 URL[] urls = new URL[]{url}; 
 @Option(name = "--all", usage = "recompile all rules") private boolean all; 
<|del|> 
 public void run() throws IOException, CompileException { 
 throw new CompileException("error: no rules.pl in " + git.getDirectory()); 
 File jarFile = new File(ruleDir, "rules-" + rulesId.getName() + ".jar"); 
<|del|> 
<|del|> 
<|del|> 
 private List<File> getAllFiles(File dir, String extension) { 
 getAllFiles(f, extension, fileList); 
 getRelativePaths(f, extension, path + f.getName() + "/", pathList); 
 System.err.println("(type Ctrl-D or \"halt.\" to exit," + " \"['path/to/file.pl'].\" to load a file)"); 
<|del|> 
<|del|> 
 if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) { 
 if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) { 
 topicTerm = SymbolTerm.create(topic); 
class PRED_commit_author_3 extends AbstractCommitUserIdentityPredicate { 
 protected Operation exec(Prolog engine, UserIdentity userId) throws PrologException { 
 public PRED_change_branch_1(Term a1, Operation n) { 
public class PRED_change_owner_1 extends Predicate.P1 { 
 public PRED_change_owner_1(Term a1, Operation n) { 
public class PRED_change_project_1 extends Predicate.P1 { 
 public PRED_change_project_1(Term a1, Operation n) { 
public class PRED_change_topic_1 extends Predicate.P1 { 
 public PRED_change_topic_1(Term a1, Operation n) { 
public class PRED_commit_author_3 extends AbstractCommitUserIdentityPredicate { 
 public PRED_commit_author_3(Term a1, Term a2, Term a3, Operation n) { 
 PatchSetInfo psInfo; try { psInfo = getPatchSetInfo(engine); } catch (PatchSetInfoNotAvailableException err) { throw new JavaException(this, 1, err); } 
public class PRED_commit_committer_3 extends AbstractCommitUserIdentityPredicate { 
 public PRED_commit_committer_3(Term a1, Term a2, Term a3, Operation n) { 
 PatchSetInfo psInfo; try { psInfo = getPatchSetInfo(engine); } catch (PatchSetInfoNotAvailableException err) { throw new JavaException(this, 1, err); } 
public class PRED_current_user_1 extends Predicate.P1 { 
 public PRED_current_user_1(Term a1, Operation n) { 
 throws PatchSetInfoNotAvailableException { 
 resultTerm = replication; 
 protected PatchSet.Id patchSetId; 
<|del|> 
<|del|> 
<|del|> 
 if (regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) { SymbolTerm changeSym = getTypeSymbol(changeType); 
 Term a5 = engine.areg5; 
 return engine.jtry5(commit_delta_check, commit_delta_next); } } 
public class PRED_commit_delta_4 extends Predicate.P4 { 
 public PRED_commit_delta_4(Term a1, Term a2, Term a3, Term a4, Operation n) { 
<|del|> 
 /** Name supplied does not match to a registered account or account group. */ REVIEWER_NOT_FOUND, 
 if (members.isEmpty()) { return false; } 
 } } 
 GroupMembersFactory create(Project.NameKey project, AccountGroup.UUID groupUUID); 
 case REVIEWER_NOT_FOUND: 
 final String reviewer = addMemberBox.getText(); if (reviewer.length() == 0) { 
 if (!AddReviewer.isLegalReviewerGroup(group.getUUID())) { 
 String msg = String.format( "Cannot verify permissions to commit object %s in repository %s", commit.name(), projectControl.getProject().getNameKey()); 
 AddReviewerHandler create(Change.Id changeId, Collection<String> reviewers, boolean confirmed); 
 return !(AccountGroup.ANONYMOUS_USERS.equals(groupUUID) || AccountGroup.REGISTERED_USERS.equals(groupUUID)); 
 type.setProject("${project}.git/summary"); type.setRevision("${project}.git/commit/${commit}"); type.setBranch("${project}.git/shortlog/${branch}"); type.setPathInfo(true); 
 private final Map<StoredValue<Object>, Object> storedValues; 
 storedValues.put((StoredValue<Object>) sv, obj); 
 storedValues.putAll(child.storedValues); 
 public boolean canRebase() { return isOwner() || getRefControl().canSubmit() || getRefControl().canRebase(); 
 public boolean canRestore() { return canAbandon() // Anyone who can abandon the change can restore it back 
<|del|> 
 type = new GitWebType(); type.setLinkName("cgit"); 
<|del|> 
 if (tB != Text.EMPTY) { 
 if (revision == Revision.Old || revision == Revision.Both) { 
 for (String action : actions) { Function function = FUNCTIONS.get(action); if (function == null) { function = NOOP; } functions.add(function); 
 /** * Initializes a stored value key with a new unique key. */ 
import com.googlecode.prolog_cafe.lang.SystemException; import org.eclipse.jgit.errors.RepositoryNotFoundException; 
<|del|> 
 if (tA != Text.EMPTY) { 
 if (tB != Text.EMPTY) { 
 public static final StoredValue<AccountCache> ACCOUNT_CACHE = create(AccountCache.class); 
 public static final StoredValue<AccountCache> ACCOUNT_CACHE = create(AccountCache.class); 
<|del|> 
 if (isOwner() && 0 <= approval.getValue()) { 
 showError(OpenIdUtil.C.noProvider() + ": " + result.statusMessage); 
 cancelWithError(req, rsp, "OpenID authentication failure: " + e.getMessage() + ". If this says nothing to you, contact the site administrator."); 
 // Intercept exception so the admin gets to see issues, too. 
 throw new DiscoveryException(""); 
<|del|> 
<|del|> 
 cancelWithError(req, rsp, "Contact site administrator"); 
 final ObjectId newCommitId; 
 if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) { 
 topicTerm = SymbolTerm.create(topic); 
 public void setCanModifyState(final boolean cms) { canModifyState = cms; 
 default: throw new IllegalStateException(String.format( "Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get())); 
 reject(cmd); 
import java.io.UnsupportedEncodingException; import java.util.ArrayList; 
<|del|> 
 Collection<ChangeNotes> allNotes = notesFactory.create( db, replaceByChange.values().stream().map(r -> r.ontoChange).collect(toList())); for (ChangeNotes notes : allNotes) { replaceByChange.get(notes.getChangeId()).notes = notes; 
 a.author = asAccountAttribute(message.getAuthor()); 
 public AccountAttribute reviewer; 
 public AccountAttribute reviewer; 
 * the uploader publishes the change, it becomes a NEW change. 
 String sideBySide(); String unifiedDiff(); 
 errorlabel.setVisible(!r.getChange().isMergeable()); 
 return message; 
<|del|> 
 if (k.isEmailOnlyAuthors()) { 
 if (k.isVisibleToAll()) { 
 return groupDetails; 
import java.io.UnsupportedEncodingException; import java.util.ArrayList; 
<|del|> 
<|del|> 
 List<String> lastCreateChangeErrors = new ArrayList<>(); 
 String.format( "%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())) .trim(); 
 logDebug( "Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size()); 
<|del|> 
 protected BranchEmail(EmailArguments ea, SshInfo sshInfo, @Assisted Project p, @Assisted String bn, @Assisted ReceiveCommand.Type type) { super(ea, getMessageClass(type)); 
 this.branchName = bn; 
 case UPDATE: mc = "modifyBranch"; break; case DELETE: mc = "deleteBranch"; break; 
 protected void formatBranch() throws EmailException { 
 /** Setup the message headers and envelope (TO, CC, BCC). */ @Override 
 owners = getOwners(); watchers = getWatchers(); add(RecipientType.TO, owners); if (!watchers.isEmpty()) { add(RecipientType.BCC, watchers); } setBranchSubjectHeader(); 
<|del|> 
<|del|> 
 if (ps.isDraft() && !isDraftVisible(db, null)) { 
 } localOwners = Collections.unmodifiableSet(groups); 
 public ProjectConfig getConfig() { return config; } 
 public long getMaxObjectSizeLimit() { return config.getMaxObjectSizeLimit(); 
 "fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName()); throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg); 
 private final Set<ChangeLabel.LabelKey> labelsToExclude; 
 public void setCanModifyState(final boolean cms) { canModifyState = cms; 
 return canPerform(Permission.REBASE) && canWrite(); 
 config = cfg; 
import com.google.gerrit.server.PatchSetUtil; import com.google.gerrit.server.ReviewerByEmailSet; 
 public void gerritConfig(final AsyncCallback<GerritConfig> callback); 
 config = cfg; 
Copyright (C) 2011 The Android Open Source Project 
 public static boolean isValid(String value) { return value.matches("([a-z,A-Z,0-9]+\\-)*[a-z,A-Z,0-9]+"); 
 if (key == null) { if (b.key == null) { return true; } else { return false; } } else { return key.equals(b.key); } 
 } @Override public int hashCode() { return key.hashCode(); } 
Copyright (C) 2011 The Android Open Source Project 
<|del|> 
 doLabelsSuggestion(new Change.Id(1), allExcludingOneChange, expected); 
<|del|> 
Copyright (C) 2011 The Android Open Source Project 
 if (!isLabelAdded(labelText)) { 
 if (!isLabelAdded(labelText)) { 
import java.io.IOException; import java.nio.file.Path; import java.nio.file.Paths; 
 @Test public void testUpdate() throws OrmException, FileNotFoundException, IOException { 
 Util.MANAGE_SVC.deleteLabel(new ChangeLabel(changeId, labelKey), 
 log.error("Cannot query database to locate prior changes", e); 
 if (MagicBranch.isMagicBranch(refname)) { throw new BranchCreationNotAllowedException(refname); 
 protected boolean draft; 
 if (newId != null) { cm.setPatchSetId(newId); updates.add(cm); 
 void deleteDraft(PatchLineComment.Key key, AsyncCallback<VoidResult> callback); 
Copyright (C) 2011 The Android Open Source Project 
 if (!control.isOwner()) { 
 public Id getAtomicId() { return atomicId; 
<|del|> 
 continue; 
 Change change = StoredValues.CHANGE.get(engine); Branch.NameKey name = change.getDest(); 
 Change change = StoredValues.CHANGE.get(engine); Account.Id ownerId = change.getOwner(); 
 Change change = StoredValues.CHANGE.get(engine); Project.NameKey name = change.getProject(); 
 Term topicTerm = Prolog.Nil; 
 PatchSetInfo psInfo = StoredValues.PATCH_SET_INFO.get(engine); UserIdentity author = psInfo.getAuthor(); 
 PatchSetInfo psInfo = StoredValues.PATCH_SET_INFO.get(engine); UserIdentity committer = psInfo.getCommitter(); 
 PatchListKey plKey = new PatchListKey(projectKey, a, b, ws); 
 return value.matches("(\\-?[a-z,A-Z,0-9]+)+\\-?"); 
 @Test public void testAddLabelWithoutPermission() throws Exception { final ChangeLabel changeLabel = new ChangeLabel(new Change.Id(0), "test"); final AddLabel addLabel = new AddLabel(changeControlFactory, db, changeLabel); 
 public void testAddLabelCompoundByHyphen() throws Exception { doValidValueAddLabelTest("A-Special-label"); } 
 private FlowPanel changeLabelsPanel; private List<ChangeLabel.LabelKey> changeLables; 
<|del|> 
 private boolean contains(final String newLabel) { return changeLables.contains(new ChangeLabel.LabelKey(newLabel)); 
/** Suggestion Oracle for change labels. */ 
 result.removeAll(labelsToExclude); final Set<StringSuggestion> r = new HashSet<StringSuggestion>(result.size()); for (ChangeLabel.LabelKey l : result) { r.add(new StringSuggestion(l.get())); 
 result.removeAll(labelsToExclude); final Set<StringSuggestion> r = new HashSet<StringSuggestion>(result.size()); for (ChangeLabel.LabelKey l : result) { r.add(new StringSuggestion(l.get())); 
 public void removeFromExclude(final ChangeLabel.LabelKey label) { 
 changeLables.remove(labelKey); 
 changeLabelsPanel.add(g); 
 Account a = db.accounts().get(to); if (a.getPreferredEmail() == null) { a.setPreferredEmail(who.getEmailAddress()); db.accounts().update(Collections.singleton(a)); byIdCache.evict(to); } 
 detail.setCanEdit(control.getRefControl().canWrite()); 
<|del|> 
 public void setName(String name) { 
 protected Set<String> refsOwnedBy; 
 public void setLocal(List<MergeStrategySection> mss) { local = mss; 
 public static final String MERGE_STRATEGY = "merge_strategies"; 
 private Set<Account.Id> watchers; private Set<Account.Id> owners; 
 return "newBranch"; 
 public List<String> getProjectOwnerNames() { 
 public List<String> getProjectOwnerNames() { 
 return subscribers; 
<|del|> 
 velocityContext.put("projectName", projectState != null ? projectState .getProject().getName() : null); 
 velocityContext.put("projectName", projectState != null ? projectState .getProject().getName() : null); 
<|del|> 
 // Abort non fast-forwards. 
 private final BatchUpdate.Factory batchUpdateFactory; private final InternalUser.Factory internalUserFactory; 
 UrlModule(GerritOptions options, AuthConfig authConfig) { this.options = options; this.authConfig = authConfig; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public ArrayList<Project.NameKey> call() throws NoSuchProjectException { LinkedHashSet ancestors = new LinkedHashSet(); 
 public List<String> getProjectOwnerNames() { 
Copyright (C) 2011 The Android Open Source Project 
Copyright (C) 2011 The Android Open Source Project 
<|del|> 
 File b = gerrit.path("Location of archive directory", "archivePath", "git"); 
<|del|> 
<|del|> 
 if (account1.getPreferredEmail() != null && !account1.getPreferredEmail().isEmpty() && account2.getPreferredEmail() != null && !account2.getPreferredEmail().isEmpty()) { 
<|del|> 
 private boolean ran; 
 private NpTextBox projectNameTextBox; 
 result.setProjects(getProjects()); 
<|del|> 
 public static final String MESSAGE = "No Reference Pattern matches: "; 
<|del|> 
 public void evict(Project project) { projectCache.evict(project); controls.remove(project.getNameKey()); 
 switch (result.getErrors().get(0).getType()) { 
 final @Assisted Collection<Account.Id> accountIds) { 
<|del|> 
 if (isSet(account1.getPreferredEmail()) && isSet(account2.getPreferredEmail())) { 
 final TreeFormatter treeFormatter = new TreeFormatter(stdout); treeFormatter.printTree(accountGroupNodeFactory.create(groupMembers)); 
 p.put("project", encode(branch.getParentKey().get())); p.put("branch", encode(branch.get())); 
 log.warn("Value specified for gitweb.pathSeparator is not a single character:" + pathSeparator); 
 public SubmoduleSubscription(final Branch.NameKey superProject, final Branch.NameKey subscription, final String path) { key = new Key(superProject, subscription); this.path = path; 
 @Override 
 final StringBuilder msgbuf = new StringBuilder(); msgbuf.append("Updated ") .append(subscriber.getParentKey().get()) .append('\n'); Repository pdb = null; RevWalk recRw = null; 
 final StringBuilder msgbuf = new StringBuilder(); msgbuf.append("Updated ") .append(subscriber.getParentKey().get()) .append('\n'); Repository pdb = null; RevWalk recRw = null; 
 p.put("file", encode(file)); 
<|del|> 
 @Option(name = "--remove-group", metaVar = "GROUP", 
 private Project.NameKey getParentName(final Project project) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 while (p != null && parents.add(p)) { 
 public InvalidNameException(String invalidName) { super(MESSAGE + ": " + invalidName); 
 Comparator<RefConfigSection> { 
 } else if (approvals.isEmpty() || forceMessage) { 
 } else if (approvals.isEmpty() || forceMessage) { 
<|del|> 
<|del|> 
 protected List<MergeStrategySection> mergeStrategies; 
 public void setRevision(String rev) { revision = rev; 
<|del|> 
 if (!projectControl.isVisible() || !projectControl.controlForRef(name).isOwner()) { continue; 
 public GroupList get(final Collection<ProjectControl> projects) throws OrmException, NoSuchGroupException { final Set<AccountGroup> groups = 
 final ProjectMergeStrategies strategies = new ProjectMergeStrategies(); strategies.setRevision(config.getRevision().name()); strategies.setMergeStrategies(local); strategies.setOwnerOf(ownerOf); 
public class ProjectConfig extends VersionedMetaData implements ValidationError.Sink { 
 final Project project = config.getProject(); project.setDescription(rs.getString("description")); project.setUseContributorAgreements("Y".equals(rs .getString("use_contributor_agreements"))); 
 if (!(!name.equals("-- All Projects --") && submitType == 'M')) { 
 if (!errors.isEmpty()) { logDebug("Handling error conditions: {}", errors.keySet()); 
 Collections.sort(mergeStrategies); 
 setUndoDeleteAvailable(row); MergeStrategySection r = getRowItem(row); r.setDeleted(true); 
<|del|> 
 public Collection<CommentLinkInfoImpl> getCommentLinkSections() { 
<|del|> 
<|del|> 
 final String errorMsg = "No such project: " + branch.getParentKey(); log.error(errorMsg); throw new MergeException(errorMsg); 
<|del|> 
 public CapabilityControl getProjectCapabilities( 
 : null; this.globalMaxObjectSizeLimit = transferConfig.getMaxObjectSizeLimit(); 
 List<String> names = new ArrayList<String>(watchers.size()); 
<|del|> 
 projectState = args.projectCache.get(project.getNameKey()); 
import java.util.HashMap; import java.util.Map; 
 } } else if (f.isDirectory()) { scanProjects(f, prefix + f.getName() + "/", names); 
 protected Branch.NameKey superProject; 
<|del|> 
<|del|> 
import java.util.HashSet; import java.util.LinkedHashMap; 
import java.util.HashSet; import java.util.LinkedHashMap; 
 private void stubExecuteBatchException(String command, BatchUpdateException exception) 
 public void testInsertNothing() throws OrmException { 
 // expected assertSame(e.getCause(), exception); 
 public void testUpdateNothing() throws OrmException { 
 // expected assertSame(e.getCause(), exception); 
 public void testUpdateOneConcurrentlyModifiedException() throws SQLException, OrmException { 
 public void testUpsertTwoNotExisting() throws SQLException, OrmException { 
 public void testUpsertTwoBothExisting() throws SQLException, OrmException { 
 public void testUpsertTwoFirstExisting() throws SQLException, OrmException { 
 public void testUpsertTwoSecondExisting() throws SQLException, OrmException { 
 private static final String NO_MEMBERS = "<no-group-members/>"; private static final String UNRESOLVED_GROUP = "<unresolved-group/>"; 
 private static final String NO_MEMBERS = "<no-group-members/>"; private static final String UNRESOLVED_GROUP = "<unresolved-group/>"; 
 private static final String RECURSIVE_NODE_SEPARATOR = "..."; 
 public String getDescription(); 
 ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes); 
<|del|> 
<|del|> 
 public static final String MESSAGE = "No Reference Pattern matches: "; 
<|del|> 
 db.patchSetApprovals().byPatchSet(patchSetId).toList(); 
<|del|> 
 suggestBox.setText(projectName != null ? projectName.get() : ""); 
<|del|> 
 public SubmoduleSubscription(final Branch.NameKey superProject, final Branch.NameKey subscription, final String path) { key = new Key(superProject, subscription); this.path = path; 
 @Override 
 final StringBuilder msgbuf = new StringBuilder(); msgbuf.append("Updated ") .append(subscriber.getParentKey().get()) .append('\n'); Repository pdb = null; RevWalk recRw = null; 
 final Branch.NameKey submodule, final String path) { key = new Key(superProject, submodule); 
 return null; 
 * Sends an email to the subscribers of a project. 
<|del|> 
 if (branchMatchWithFilter(branchName, filter)) { 
<|del|> 
 protected void ccAllApprovals() { if (!NotifyHandling.ALL.equals(notify) && !NotifyHandling.OWNER_REVIEWERS.equals(notify)) { return; } 
 protected UseContentMerge useContentMerge; 
 public void setUseContentMerge(final UseContentMerge cm) { 
<|del|> 
 public CreateProjectScreen() { super(); setRequiresSignIn(true); } 
 if (!r.contains(parent)) { r.add(parent); 
 if (!r.contains(parent)) { r.add(parent); 
 if (!r.contains(allProject)) { r.add(allProject); } Collections.sort(r); 
 + "if this option is used all other options and arguments are ignored") 
 } catch (ProjectCreationFailedException err) { throw new UnloggedFailure(1, "Fatal: " + err.getMessage(), err); } finally { 
 public Project.NameKey getProject() { 
 public Project.NameKey getProject() { 
 concurrencyViolationDetected = true; 
 inserts = allInstances; 
 stdout.print("\n"); 
 stdout.print("\n"); 
 p.setProperty(RuntimeConstants.VM_PERM_INLINE_LOCAL, "true"); 
<|del|> 
 projectName = n != null ? new Project.NameKey(n) : null; 
 public void setProjectName(Project.NameKey n) { 
 throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err); 
 void visibleProjectDetails(AsyncCallback<List<ProjectDetail>> callback); 
<|del|> 
 throw new UnloggedFailure(1, "fatal: Project name is required."); 
 * West and East decorations will surround the text on the 
 throws BadRequestException, UnprocessableEntityException, 
<|del|> 
<|del|> 
 West, Title, East, FarEast; 
 header.getCellFormatter().setWidth(0, Cols.FarEast.ordinal(), "100%"); 
 @Option(name = "--start", aliases = {"-S"}, usage = "Number of changes to skip") 
 @Option(name = "--start", aliases = {"-S"}, usage = "Number of changes to skip") 
 throw new IllegalArgumentException( 
 stdout.print("\n"); 
 stdout.print("Warning: The group '" 
import com.google.gerrit.common.EventBroker; import com.google.gerrit.elasticsearch.ElasticIndexModule; import com.google.gerrit.extensions.client.AuthType; import com.google.gerrit.gpg.GpgModule; import com.google.gerrit.httpd.auth.oauth.OAuthModule; 
 /** Scheme used for INTERNAL authentication */ 
<|del|> 
 } } catch (OrmException err) { throw new AccountException("Cannot connect to database", err); 
Copyright (C) 2012 The Android Open Source Project 
<|del|> 
 submitResult.get(0).errorMessage)); break; 
 "Unsupported SubmitRecord.status + (" + submitRecord.status + ")"); 
 approval = candidateApproval; break; 
 // Create messaages to accompany the restored change 
<|del|> 
<|del|> 
 throws BadRequestException, UnprocessableEntityException, 
<|del|> 
 // Create a message to accompany the restored change 
<|del|> 
<|del|> 
<|del|> 
 throw new IllegalStateException( "Cannot submit " + result.getErrors().get(0).getMessageOrType()); 
<|del|> 
<|del|> 
<|del|> 
 throw new IllegalStateException( 
 throw new IllegalArgumentException( 
 URI thisServerURI = new URI(canonicalWebUrl); 
 if (projectNameCandidate.endsWith(".git")) { 
 /** Filename of the change merged hook. */ private final File changeMergedHook; 
 public void doChangeAbandonedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) 
 final ChangeRestoredEvent event = new ChangeRestoredEvent(); final AccountState owner = accountCache.get(change.getOwner()); 
 final List<String> args = new ArrayList<>(); 
 this.sendEmailExecutor = sendEmailExecutor; this.changeUpdateExector = changeUpdateExector; 
<|del|> 
 if (!control.isOwner() || !control.isVisible(db)) { 
 stdout.print("Warning: Some groups are not visible to you and " 
import com.google.gerrit.common.EventBroker; import com.google.gerrit.elasticsearch.ElasticIndexModule; import com.google.gerrit.extensions.client.AuthType; import com.google.gerrit.gpg.GpgModule; import com.google.gerrit.httpd.auth.oauth.OAuthModule; 
<|del|> 
 projectNameTextBox.setEnabled(enabled); 
 parentNameTextBox.setEnabled(enabled); emptyCommitCheckBox.setEnabled(enabled); 
<|del|> 
 void rebaseChange(PatchSet.Id patchSetId, AsyncCallback<ChangeDetail> callback); 
 private void runGC() { 
 for (Map.Entry<String, Ref> e : rp.getAdvertisedRefs().entrySet()) { 
 final ChangeMovedSender.Factory senderFactory, 
/** Send notice about a change being moved to a different destination branch. */ 
 @Override 
 this.replaceOpFactory = replaceOpFactory; this.patchSetUtil = patchSetUtil; 
 change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId())); ChangeUtil.updated(change); 
Copyright (C) 2012 The Android Open Source Project 
<|del|> 
 String err = "Change is closed, submitted, or patchset is not latest"; 
<|del|> 
 // This block of code will be removed when integrating Submit Actions UI change. final SubmitActionSection mss = new SubmitActionSection(RefConfigSection.ALL); 
<|del|> 
 if (!repoManager.branchExists(destBranch)) { 
 if (!repoManager.branchExists(destBranch)) { 
 public boolean branchExists(final Branch.NameKey branch) throws RepositoryNotFoundException, IOException { final Repository repo = openRepository(branch.getParentKey()); 
 if (repo.getRef(destBranch.get()) == null) { 
import com.google.gerrit.client.ui.ListenableAccountDiffPreference; 
<|del|> 
<|del|> 
 private Set<String> getFileListBy(final PatchSet.Id id) throws NoSuchChangeException, NoSuchEntityException, OrmException { final Set<String> fileList = new HashSet<String>(); 
 public List<Patch> toPatchList(final PatchSet.Id setId, 
 return Joiner.on("; ").join(labelResults); 
 throws ResourceConflictException { checkArgument(!cs.furtherHiddenChanges(), "checkSubmitRulesAndState called for topic with hidden change"); for (ChangeData cd : cs.changes()) { 
 final AccountVisibility accountVisibility) { 
 logDebug("Executing batch with {} commands", batch.getCommands().size()); 
 public boolean merge(MergeOp.Factory mof, Change change) throws MergeException { boolean started = start(change.getDest()); if (started) { 
 return "send-email comments"; 
 public void postEvent(final Change change, final ChangeEvent event, 
<|del|> 
 void deleteDraftChange(PatchSet.Id patchSetId, AsyncCallback<VoidResult> callback); @SignInRequired void rebaseChange(PatchSet.Id patchSetId, AsyncCallback<ChangeDetail> callback); 
 throw new InvalidChangeOperationException("Permission denied moving" + " destination branch to " + branch + " for change " + changeId); 
 public String id; public String number; public String revision; public String ref; public Boolean isCurrentPatchSet; 
 @Assisted final PatchSet.Id patchSetId, @Assisted("branch") final String branch, @Assisted("message") final @Nullable String changeComment) { 
 final IdentifiedUser currentUser, @Assisted final PatchSet.Id patchSetId, @Assisted("branch") final String branch, @Assisted("message") @Nullable final String changeComment) { 
 int count = t.count; s.append(count * 100 / t.total).append("% (").append(count) 
public abstract class CommentedActionDialog<T> extends AutoCenterDialogBox implements CloseHandler<PopupPanel> { 
 @Assisted("message") @Nullable final String changeComment) { 
 approvalsUtil.clearCurrentPatchSetNonVetos(updatedChange); 
 final AccountVisibility accountVisibility) { 
<|del|> 
<|del|> 
<|del|> 
 private final List<Task> tasks = new CopyOnWriteArrayList<Task>(); private int spinnerIndex; private char spinnerState = NO_SPINNER; 
 public void waitFor(Future<?> workerFuture) throws ExecutionException { 
 Task task = new Task(subTask, subTaskWork); tasks.add(task); 
 s.append(String.format("%d%% (%d/%d)", count * 100 / t.total, count, t.total)); 
 public boolean merge(MergeOp.Factory mof, Change change) throws MergeException { boolean started = start(change.getDest()); if (started) { 
<|del|> 
 return "send-email comments"; 
<|del|> 
<|del|> 
 @Named(TIMEOUT) 
 AsyncReceiveCommits(final ReceiveCommits.Factory factory, 
 progress = new MultiProgressMonitor( new MessageSenderOutputStream(), "Updating changes"); 
 progress = new MultiProgressMonitor( new MessageSenderOutputStream(), "Updating changes"); 
 String[] files; if (subobject == null) { files = object.currentFilePaths(db, cache); } else { files = object.filePaths(db, cache, subobject); } 
 * @type <C> child type of T (Example: PatchSet is a child of Change) 
<|del|> 
 HasDraftByPredicate(Arguments args, Account.Id accountId) { 
import com.google.gwtorm.server.ResultSet; import com.google.inject.Provider; 
 LegacyChangeIdPredicate(Provider<ReviewDb> db, Change.Id id) { super(ChangeQueryBuilder.FIELD_CHANGE, id.toString()); this.db = db; 
class OrSource extends OrPredicate<ChangeData, PatchSet> implements ChangeDataSource { 
class TrackingIdPredicate extends OperatorPredicate<ChangeData, PatchSet> implements ChangeDataSource { 
 private static List<Predicate<String, String>> list( final Predicate<String, String>... predicates) { 
Copyright (C) 2012 The Android Open Source Project 
Copyright (C) 2012 The Android Open Source Project 
<|del|> 
<|del|> 
 Util.LIST_SVC.toggleStars(req, new GerritCallback<VoidResult>() { 
<|del|> 
 out.print("}\n"); out.print("\n"); 
<|del|> 
 new ChangeDetailCache.GerritWidgetCallback(b)); 
 * Get all reviewers for a change. 
 * @param db database connection to use for updates. * @param dest PatchSet to copy to 
 } if (patchSetAncestors.size() == 1) { 
 } if (depChange.getStatus().isOpen()) { 
 return ImmutableSet.copyOf(groups); 
 // Ensure consistent behavior regardless of the default line separator // for the platform where Gerrit is run. out.print('\n'); 
 "string\twith\ttabs", "string\\twith\\ttabs" }; 
 static String[] NON_PRINTABLE_CHARS = 
 * characters in the column text are ever escaped, the column * separator must be a sequence of non-printable characters if 
<|del|> 
 protected static String[] NON_PRINTABLE_CHARS = 
 public void addColumn(final String content) { if (!firstColumn) { out.print(columnSeparator); } out.print(escapeString(content)); firstColumn = false; 
 /** 
 /** * Finishes the output by flushing the current line and takes care of any * other cleanup action. 
 * to this method without intervening calls to {@link #addColumn} will 
 formatter.addColumn( "\tan indented multi-line\ntext with a null character: \u0000"); 
 if (db.changes().byBranchOpenAll(k).iterator().hasNext()) { 
Copyright (C) 2012 The Android Open Source Project 
 //private void parseReview(final JsonObject obj) //throws ValidationException { //final Review review = new Review(); 
<|del|> 
 private ListProjects impl; 
import org.kohsuke.args4j.spi.BooleanOptionHandler; import org.kohsuke.args4j.spi.EnumOptionHandler; import org.kohsuke.args4j.spi.FieldSetter; import org.kohsuke.args4j.spi.MethodSetter; 
import org.kohsuke.args4j.spi.Setter; import org.kohsuke.args4j.spi.Setters; 
Copyright (C) 2012 The Android Open Source Project 
 GsonBuilder gb = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES) .registerTypeAdapter(Timestamp.class, new SqlTimestampDeserializer()); 
<|del|> 
 List<ChangeData> changes = imp.queryChanges(query); 
 out.labels = labelsFor(cd); 
 boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount() .getGeneralPreferences() .isDisplayPersonNameInReviewCategory(); 
<|del|> 
 private Object shell; 
 env.setProperty("python.security.respectJavaAccessibility", "false"); 
 env.setProperty("python.cachedir", new File(home, "jythoncache").getPath()); 
<|del|> 
 } catch (SecurityException e) { 
 } catch (InvocationTargetException e) { 
 nameBox = new RemoteSuggestBox(new ProjectNameSuggestOracle()); 
<|del|> 
<|del|> 
 public String number; public String revision; public List<String> parents; public String ref; public AccountAttribute uploader; public Long createdOn; 
 // For package introspection and "import com.google" to work, // Jython needs to inspect actual .jar files (not just classloader) 
 protected Object runMethod(Class klazz, Object instance, String name, Class[] sig, Object[] args) { 
 log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable"); 
Copyright (C) 2012 The Android Open Source Project 
 } Response<String> resp = putHttpPassword.apply(rsrc, in); if (generateHttpPassword) { stdout.print("New password: " + resp.value() + "\n"); } 
<|del|> 
<|del|> 
 commit.setMessage("Add the ContributorAgreements for upgrade to Gerrit Code Review schema 65\n"); 
 .get(0) .getId()); 
 if (!adminGroupIds.contains(ag.getOwnerGroupId())) { throw new IllegalStateException( "individual group exists with non admin owner group: " + name); 
 .get(0) .getId(); 
<|del|> 
 keysNavigation.add(new OpenKeyCommand(0, KeyCodes.KEY_ENTER, Util.C .changeTableOpen())); 
 if (! c.isLatest()) { 
 AccountGeneralPreferences prefs = Gerrit.getUserAccount().getGeneralPreferences(); 
 fmt.getElement(row, col).setTitle( acv.getName() + " \nby " + FormatUtil.nameEmail(ai)); 
 UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed); 
 GerritCallback<ApprovalSummarySet> approvalFormatter(final int dataBegin, final int rows, final boolean highlightUnreviewed) { 
 PatchUtil.DETAIL_SVC.userApprovals(cids, ownerId, parent .approvalFormatter(dataBegin, rows, true)); 
 PatchUtil.DETAIL_SVC.strongestApprovals(cids, parent .approvalFormatter(dataBegin, rows, false)); 
Copyright (C) 2011 The Android Open Source Project 
public class AbandonCommand extends SshCommand { 
 if (!id.equals(userProvider.get().getAccountId())) { 
 return (Integer) o; 
 Watchers matching = getWatches(type); 
 DynamicItem<ProjectNameLockManager> lockManager, 
 // Loop over the comments and collect them into groups based on the file // location of the comment. FileCommentGroup currentGroup = null; 
<|del|> 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
<|del|>
 protected void init() throws EmailException { 
 public static GroupReference forGroup(GroupDescription.Basic group) { 
 GroupMembership membershipsOf(IdentifiedUser user); 
 return Iterables.getOnlyElement(refs); 
 AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group); if (accountGroup == null) { 
 return uuid.get().startsWith("global:") || uuid.get().matches("[0-9a-f]{40}"); 
<|del|> 
<|del|> 
import com.google.gerrit.server.git.ChangeMergeQueue; 
 private static final String KEY_ACCEPTED = "accepted"; private static final String KEY_REQUIRE_CONTACT_INFORMATION = "requireContactInformation"; 
 public boolean isValid(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException; 
 import org.apache.sshd.server.Environment; import org.kohsuke.args4j.Argument; import org.kohsuke.args4j.Option; 
 throw new UnloggedFailure(1, "Only one option may use the stdin"); 
 private final Provider<AnonymousUser> anonymousUserProvider; private final CurrentUser currentUser; 
 Matcher patternMatcher = regexPatterns.get(findReplace.find()).matcher(line); 
 private Config config; private PlugInClassLoader plugInClassLoader; 
 return pluginCache.values(); 
 public Set<String> toFileList() { 
 static final long serialVersionUID = 17L; 
 public boolean isRebaseTransparent() { 
 h = h * 31 + (isRebaseTransparent ? 1 : 0); 
 .getWhitespace()), repo).toFileList()); return pList.copyBy(patchfileList); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public Plugin get(String pluginName) { 
 log.error("Cannot list " + pluginsDir.getAbsolutePath()); 
 public final String name; 
 @Singleton 
 loadPlugins(); 
 Collection<File> plugInJars; 
 ClassLoader parentLoader = PluginLoader.class.getClassLoader(); ClassLoader jarClassLoader = URLClassLoader.newInstance(getPluginURLs(jarFile), parentLoader); 
 Class<?> moduleClass = Class.forName(moduleName, false, jarClassLoader); 
<|del|> 
 if (pluginsDir == null || !pluginsDir.exists()) { 
 new URLClassLoader(getPluginURLs(jarFile), parentLoader); 
 public final Class<? extends AbstractModule> moduleClass; 
 File[] plugins = pluginsDir.listFiles(new FileFilter() { 
 return pathname.isFile() && pathname.getName().endsWith(".jar"); 
<|del|> 
<|del|> 
 String pluginName = getMandatoryAttribute(jarManifest, "Gerrit-Plugin"); String moduleName = getMandatoryAttribute(jarManifest, "Gerrit-SshModule"); 
 String pluginName = getMandatoryAttribute(jarManifest, "Gerrit-Plugin"); String moduleName = getMandatoryAttribute(jarManifest, "Gerrit-SshModule"); 
 if (!Module.class.isAssignableFrom(moduleClass)) { throw new ClassNotFoundException("Class " + moduleClass.getName() + " is not a Guice Module"); 
 log.error("Cannot access plugin jar " + jarFile, e); 
 String pluginName = getMandatoryAttribute(jarManifest, "Gerrit-Plugin"); String moduleName = getMandatoryAttribute(jarManifest, "Gerrit-SshModule"); 
 if (!Module.class.isAssignableFrom(moduleClass)) { throw new ClassNotFoundException("Class " + moduleClass.getName() + " is not a Guice Module"); 
 public void initSshModule(String pluginName) { this.pluginName = pluginName; 
Copyright (C) 2011 The Android Open Source Project 
import com.google.gerrit.sshd.SshCommand; 
public class AbandonCommand extends SshCommand { 
<|del|> 
 final Change.Key key = Change.Key.parse(tokens[2]); for (final Change change : db.changes().byKey(key)) { 
<|del|> 
import static org.pegdown.Extensions.ALL; 
<|del|> 
 return new PegDownProcessor(ALL).markdownToHtml(markdownSource); 
<|del|> 
 void setStatus(Status newStatus) { 
<|del|> 
 } else if (auto != null && auto.sysModule != null) { 
<|del|> 
 public static String toProjectBranches(Project.NameKey p) { return "/admin/projects/" + p.get() + ",branches"; 
 * 
 * 
import com.google.gerrit.client.ui.AccountDashboardLink; 
<|del|> 
<|del|> 
 @Inject ChangeCache(@Named(ID_CACHE) Cache<Project.NameKey, List<Change>> cache) { this.cache = cache; } 
 log.warn(String.format("Plugin '%s' file '%s' too large to format", pluginName, entryName)); 
<|del|> 
 res.setContentType(contentType); if (charEnc != null) { res.setCharacterEncoding(charEnc); } 
 install(new DefaultCacheFactory.Module()); 
<|del|> 
 revWalk = new RevWalk(db); inserter = db.newObjectInserter(); 
 revWalk = new RevWalk(db); inserter = db.newObjectInserter(); 
 return apiType; 
 Injector root = newRootInjector(env); 
 if (input instanceof IOException) { return new InsertException("IO error", input); } return new InsertException("Error inserting change/patchset", input); 
 public final boolean validated; public final String why; 
 new CommitValidationResult(false, "Prohibited by server, contact admin"); 
 public String getValidationReason() { return why; 
<|del|> 
 public CommitValidationResult onCommitReceived(CommitReceivedEvent receiveEvent); 
 public CommitValidationResult onCommitReceived(CommitReceivedEvent receiveEvent); 
 @Override 
 @Override 
 /** * Audit annotation for JSON/RPC interfaces. * * Flag with @Audit all the JSON/RPC methods to * be traced in audit-trail and submitted to the * AuditService. */ 
 String action() default ""; /** List of positions of parameters to be obfuscated in audit-trail (i.e. passwords) */ 
 public static final String UNKNOWN_USER = "N/A"; public static final String UNKNOWN_SESSION_ID = "000000000000000000000000000"; private static final Object UNKNOWN_RESULT = "N/A"; 
 return uuid.hashCode(); 
 @Override public String toString() { 
 void onAuditableAction(AuditEvent action); 
 private final DynamicSet<AuditListener> auditListeners; 
 public void dispatch(AuditEvent action) { 
<|del|> 
 String parm = arg.substring(0, eqPos); parms.put( parm, secure && dcmd.isSensitiveParameter(parm) ? MASK : arg.substring(eqPos + 1)); 
import com.google.gerrit.client.ui.AccountDashboardLink; 
 bind(RequestContext.class).annotatedWith(Names.named(FALLBACK)) 
 } 
<|del|> 
 private final IdentifiedUser.RequestFactory userFactory; 
 AccountGroup.UUID ownerUUID = group.getOwnerGroupUUID(); 
 stdout.print( "-------------------------------------------------------------------------------\n"); 
 format .newGson() .toJson(output, new TypeToken<Map<String, PluginInfo>>() {}.getType(), stdout); 
<|del|> 
 super.service(req, res); } catch (RequireCapabilityException err) { res.setStatus(HttpServletResponse.SC_FORBIDDEN); noCache(res); sendText(req, res, err.getMessage()); 
 throw new RequireCapabilityException(msg); 
Copyright (C) 2012 The Android Open Source Project 
 + " COUNT(*)" + ",SUM(OCTET_LENGTH(k) + OCTET_LENGTH(v))" + " FROM data"); 
 throw new PatchListNotAvailableException(e.getCause()); 
<|del|> 
<|del|> 
 while (1 < table.getRowCount()) { 
 for (final PluginInfo p : plugins.values().asList()) { 
 table.setText(row, 1, plugin.name()); table.setText(row, 2, plugin.version()); 
 return sensitiveParameters == null ? false : sensitiveParameters.contains(param); 
 return name.equals(((RefConfigSection) obj).name); 
 && projectControl != null 
 && projectControl != null 
 private transient boolean isRebaseTransparent; 
 final AnyObjectId b, final Whitespace ws, final boolean rebaseTransparent) { 
 final AnyObjectId b, final Whitespace ws, final boolean rebaseTransparent) { 
 public String getDiffTypeForRebasedPatchSets() { return diffTypeForRebasedPatchSets; 
 final ObjectId newId = plkey.getNewId(); final ObjectId oldId = plkey.getOldId(); final Whitespace ws = plkey.getWhitespace(); 
<|del|> 
 md.setMessage("Switch LDAP group UUIDs to DNs\n"); 
 groupNameSpan.setTitle(ref.getUUID() != null ? ref.getUUID().get() : ""); 
 if (state != null) { final String name = nameOf(uuid, state); 
 uuid.get().startsWith(UUID_PREFIX), "SingleUserGroup does not handle %s", uuid.get()); 
import java.io.UnsupportedEncodingException; 
 @Option(name = "--limit", aliases = {"-n"}, metaVar = "CNT", usage = "maximum number of projects to list") 
 final Branch.NameKey branch = new Branch.NameKey(project, tokens[1]); 
 String fileName = getDisplayFileName(patch); 
 private final AuditService audit; 
 try { doLogout(req, rsp); } finally { audit.dispatch(new AuditEvent(sid, webSession.get().getCurrentUser(), what, when, null, "{\"Success\":true}")); 
 try { doLogout(req, rsp); } finally { audit.dispatch(new AuditEvent(sid, webSession.get().getCurrentUser(), what, when, null, "{\"Success\":true}")); 
import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
final class GerritJsonServlet extends JsonServlet<GerritJsonServlet.GerritCall> { private static final Logger log = LoggerFactory.getLogger(GerritJsonServlet.class); 
 } catch (Throwable ignoreExceptionWhileLogging) { log.warn("Error occurred during audit event dispatch", ignoreExceptionWhileLogging); 
<|del|> 
<|del|> 
 private static final Field resultField; 
 log.error("Unable to expose RPS/JSON result field"); 
 changeId = null; message = null; 
 InvalidChangeOperationException, NoSuchChangeException, OrmException { 
<|del|> 
 published = true; 
 } 
<|del|> 
Copyright (C) 2012 The Android Open Source Project 
<|del|> 
 List<String> versionParts = new ArrayList<>(); 
 DOM.setInnerHTML(span, new SafeHtmlBuilder().append(messageText.getText()) .asString()); 
 } catch (IOException e) { log.error("Could not commit rename of group " + oldName + " to " + newName + " in " + md.getProjectName().get(), e); 
 CheckBox checkBox = new CheckBox(); table.setWidget(row, 1, checkBox); table.setText(row, 2, plugin.name()); table.setText(row, 3, plugin.version()); 
 .changeInfoBlockCanMergeYes() : Util.C.changeInfoBlockCanMergeNo()); } else { table.getRowFormatter().setVisible(R_MERGE_TEST, false); 
 private final Provider<AbandonChange> abandonChangeProvider; 
<|del|> 
<|del|> 
 InvalidChangeOperationException, NoSuchChangeException, OrmException { if (changeId == null) { throw new InvalidChangeOperationException("changeId is required"); } 
 @Option(name = "--delete", usage = "delete a draft patch set") 
 public static void refreshMenuBar() { refreshMenuBar(true); } private static void refreshMenuBar(boolean populateMyMenu) { 
 private ObjectId createNoteContent(CodeReviewCommit commit) throws CodeReviewNoteCreationException, IOException { 
 public final NoteMap commitNewNotes(NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws IOException, ConcurrentRefUpdateException { 
 if (! ours.contains(n)) { 
 ProjectBasicAuthFilter(DynamicItem<WebSession> session, AccountCache accountCache, AccountManager accountManager, AuthConfig authConfig) { 
 String usernamePassword = new String(decoded, encoding(req)); int splitPos = usernamePassword.indexOf(':'); if (splitPos < 1) { 
 private void setUserIdentified(Account.Id id) { WebSession ws = session.get(); ws.setUserAccountId(id); ws.setAccessPathOk(AccessPath.GIT, true); ws.setAccessPathOk(AccessPath.REST_API, true); } 
 return MoreObjects.firstNonNull(req.getCharacterEncoding(), UTF_8.name()); 
<|del|> 
 v.append(LIT_BASIC); v.append("realm=\"").append(REALM_NAME).append("\""); 
<|del|> 
 BanCommit(final Provider<IdentifiedUser> currentUser, final GitRepositoryManager repoManager, @GerritPersonIdent final PersonIdent gerritIdent, final NotesBranchUtil.Factory notesBranchUtilFactory) { 
 ours = NoteMap.read(revWalk.getObjectReader(), baseCommit); 
 try { JiraClientSession session = newSession(); session.close(); } catch (XmlRpcException e) { log.error("Cannot validate Jira configuration and connectivity", e); throw new RuntimeException(e); } 
<|del|> 
<|del|> 
<|del|> 
 private String getStringConfigWithDefault(String section, String key, 
 String.format("%s\n%s?p=%s;a=commit;h=%s", comment, gitwebUrl, projectName, commitId); 
 "(\\[[a-zA-Z0-9]*-[0-9]*\\])"); 
 if (webUrl == null) { if (gerritConfig.getString("gitweb", null, "cgi") != null) { String canonicalUrl = gerritConfig.getString("gerrit", null, "canonicalWebUrl"); 
 if (changeDetail.canRebase()) { final Button b = new Button(Util.C.buttonRebaseChange()); 
<|del|> 
 } else { 
 return currentUser.getCapabilities().canAdministrateServer(); 
 popingUp = false; 
 private void doLogout(final HttpServletRequest req, 
 try { doLogout(req, rsp); } finally { audit.dispatch(new AuditEvent(sid, currentUser, what, when, null, null)); 
 try { doLogout(req, rsp); } finally { audit.dispatch(new AuditEvent(sid, currentUser, what, when, null, null)); 
import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
<|del|> 
<|del|> 
<|del|> 
 try { for (Update u : event.getUpdates()) { String newObjId = u.getNewObjectId(); if (newObjId == null) { continue; } 
/** Reload the specified plugins, or rescan if none specified. */ 
<|del|> 
<|del|> 
 String sideMarker(); 
<|del|> 
<|del|> 
 p.setShowLineEndings(true); 
 private boolean all; private int limit; private int start; 
 p.getSrcFile().getFileName()); 
 public static PluginInfo toPluginInfo(Plugin p) { 
 private Button delSel; private boolean submitOnSelection; 
<|del|> 
 protected PopupPanel.PositionCallback getPositionCallback() { 
 protected void onMovePointerTo(String projectName) { 
 public boolean isPopingUp() { 
 public void setPreferredCoordinates(final int top, final int left) { this.preferredTop = top; this.preferredLeft = left; 
<|del|> 
Copyright (C) 2012 The Android Open Source Project 
Copyright (C) 2012 The Android Open Source Project 
Copyright (C) 2012 The Android Open Source Project 
 if (sshdAdvertisedAddress != null && ! sshdAdvertisedAddress.isEmpty()) { 
 @Inject protected ListPlugins(PluginLoader pluginLoader) { this.pluginLoader = pluginLoader; 
 dataDir = sitePaths.data_dir; tempDir = sitePaths.tmp_dir; 
 public void reload(List<String> names) throws InvalidPluginException, PluginInstallException { 
 public void reload(List<String> names) throws InvalidPluginException, PluginInstallException { 
 public final native boolean isDisabled() /*-{ return this.disabled ? true : false; }-*/; 
 @Argument(index = 0, metaVar = "NAME", required = true, usage = "plugin(s) to enable") 
 throw die("plugin failed to enable"); 
 if (newName.trim().isEmpty()) { 
 private ForwardingRemovalListener.Factory forwardingRemovalListenerFactory; 
 @Override public String[] depends() { return new String[] {}; } @Override public boolean hidden() { return false; } @Override 
 if (! c.isLatest()) { 
<|del|> 
import com.google.gerrit.sshd.PluginCommandModule; 
 protected void doPost(HttpServletRequest req, HttpServletResponse res) 
<|del|> 
 suggestions.add("commentby:"); suggestions.add("from:"); 
 final SuggestBox suggestBox = new SuggestBox(new SearchSuggestOracle(), searchBox, suggestionDisplay); 
<|del|> 
<|del|> 
 String leCR(); 
 String srcType = fileName; 
<|del|> 
 public void onResponseReceived(Request req, final Response res) { 
<|del|> 
<|del|> 
 * @return textual validation reason. 
 if (!project.isOwner()) { throw new UnloggedFailure(1, "Permission denied: you do not have ownership rights to " + project.getProject().getName()); 
 if (!project.isOwner()) { throw new UnloggedFailure(1, "Permission denied: you do not have ownership rights to " + project.getProject().getName()); 
<|del|>
 final RefUpdate u = repo.updateRef(Constants.HEAD, true); 
 @SignInRequired 
<|del|> 
 audit(); currentCall.set(null); 
 if (resultField == null) { return null; 
 if (resultField == null) { return null; 
<|del|> 
<|del|> 
<|del|> 
 private final ForwardingRemovalListener.Factory forwardingRemovalListenerFactory; 
 * attached via the DynamicSet API. 
 if (!Strings.isNullOrEmpty(name)) { 
 public Account.Id getAccountId() { 
 protected abstract void doRequest(HttpServletRequest req, HttpServletResponse res) throws IOException; 
 private static String getReqUrl(HttpServletRequest req) { StringBuffer url = req.getRequestURL(); 
 private void addLink(String label, final PatchSet.Id id) { 
 "fatal: %s does not have \"%s\" capability.", Objects.firstNonNull( user.getUserName(), user instanceof IdentifiedUser ? ((IdentifiedUser) user).getNameEmail() : user.toString()), rc.value()); 
 "fatal: %s does not have \"%s\" capability.", Objects.firstNonNull( user.getUserName(), user instanceof IdentifiedUser ? ((IdentifiedUser) user).getNameEmail() : user.toString()), rc.value()); 
 public String sign(Account.Id user, String url); 
 public void verify(Account.Id user, String url, String token) throws InvalidTokenException; 
<|del|> 
 String tokenString = json.get("_authKey").getAsString(); 
 res.sendError(HttpServletResponse.SC_UNAUTHORIZED); return; 
import com.google.gwt.user.client.ui.HTMLPanel; import com.google.gwt.user.client.ui.Image; 
 pcl.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("stdin"), new JavaObjectTerm(inReader)); 
 ParsedBody body; if (JSON_TYPE.equals(req.getContentType())) { body = parseJson(req, res); } else if (FORM_ENCODED.equals(req.getContentType())) { body = parseForm(req, res); 
Copyright (C) 2012 The Android Open Source Project 
 public ScriptRunner getIndexScript() throws IOException { return getScriptRunner("index_generic.sql"); 
 protected static final ScriptRunner getScriptRunner(String path) throws IOException { if (path == null) { return new ScriptRunner(); 
 protected static final ScriptRunner getScriptRunner(String path) throws IOException { if (path == null) { return new ScriptRunner(); 
 * Return a ScriptRunner that runs the index script. Must not return * <code>null</code>, but may return a ScriptRunner that does nothing. * * @throws IOException 
 * Return a ScriptRunner that runs the nextVal script. Must not return * <code>null</code>, but may return a ScriptRunner that does nothing. * * @throws IOException 
 Collections.singleton(new AccountGroupName(batch))); 
 ScriptRunner(final String scriptName, final InputStream script) { this.name = scriptName; 
<|del|> 
} 
 private String subname; 
<|del|> 
 styleLastCommentCell(row, col, line.getLine() == FILE_COMMENT_ROW); 
<|del|> 
 private void openLine(final SafeHtmlBuilder m) { 
<|del|> 
 private final boolean replicatePermissions; private final String remoteNameStyle; private volatile WorkQueue.Executor pool; 
<|del|> 
 private IdentifiedUser user; private AccountResource rsrc; 
 stderr.println("preferred email not found: " + email); 
 public boolean canRebase() { return isOwner() || getRefControl().canSubmit() || getRefControl().canRebase(); 
Copyright (C) 2012 The Android Open Source Project 
Copyright (C) 2012 The Android Open Source Project 
Copyright (C) 2012 The Android Open Source Project 
 @Option(name = "-s", usage = "Read prolog script from stdin. (Otherwise uses rules.pl from refs/meta/config)") 
 public void runSubmitFilters(ProjectState projectState, List<Term> results, PrologEnvironment pcl) throws UnloggedFailure { 
 throw new UnloggedFailure("Cannot consult rules.pl for " + parentState.getProject().getName() + err); 
 throw new UnloggedFailure("Exception calling " + filterRule + " of " + parentState.getProject().getName() + err); 
 return (n.endsWith(".jar") && pathname.isFile()); 
/** Command that allows testing of prolog submit-rules in a live instance. 
 @Inject private AccountCache accountCache; final @AnonymousCowardName String anonymousCowardName; @Option(name = "-c", required = true, usage = "ChangeId to load in prolog environment") 
 usage = "Read prolog script from stdin instead of reading rules.pl from the refs/meta/config branch") 
 private static final String[] PACKAGE_LIST = {Prolog.BUILTIN, "gerrit"}; 
 // thus will leak information that a change-id is valid even though the // user are not allowed to see the change. // See http://code.google.com/p/gerrit/issues/detail?id=1586 
<|del|> 
 private void runSubmitFilters(ProjectState projectState, List<Term> results, 
 if (!shouldReplicate(project, state)) { 
 private static GroupReference groupReference(ParameterizedString p, LdapQuery.Result res) throws NamingException { 
 /** @return base directory under which the specified project is stored. */ public File getBasePath(Project.NameKey name) { String alternateBasePath = repositoryCfg.getBasePath(name); return alternateBasePath != null ? new File(alternateBasePath) : basePath; 
 p.approvals.add(asApprovalAttribute(a, labelTypes)); 
 public Repository openRepository(Project.NameKey name) throws RepositoryNotFoundException { 
 /** * Convert the results from Prolog Cafe's format to Gerrit's common format. 
/** Command that allows testing of prolog submit-rules in a live instance. */ 
 @Argument(index = 0, required = true, usage = "ChangeId to load in prolog environment") 
<|del|> 
 final @GerritServerConfig Config cfg, final ChangeHooks hooks, @Assisted final Change.Id changeId, 
 final ResultSet<Account> accounts = db.accounts().get(added); for (final Account account : accounts) { 
 ru.refName = refName.getShortName(); 
 for (final Account.Id id : added) { final Account account = accountCache.get(id).getAccount(); 
 List<SubmitRecord> submitRecords) { ca.submitRecords = new ArrayList<>(); 
 List<SubmitRecord> submitRecords) { ca.submitRecords = new ArrayList<>(); 
 sa.status = submitRecord.status.name(); if (submitRecord.status != SubmitRecord.Status.RULE_ERROR) { 
 SubmitRecordAttribute sa) { 
 private final Multimap<String, ClassLoader> packageClassLoaderMap = LinkedHashMultimap.create(); 
 /** Return set of packages that contain Prolog predicates */ public ImmutableSet<String> getPackages(); 
 private static final List<String> PACKAGE_LIST = ImmutableList.of( Prolog.BUILTIN, "gerrit"); 
 List<String> packages = Lists.newArrayList(); packages.addAll(PACKAGE_LIST); 
 private final IdentifiedUser.GenericFactory identifiedUserFactory; 
 } 
<|del|> 
 @Option(name = "--no-filters", aliases = {"-n"}, usage = "Don't run the submit_filter/2 from the parent projects") 
 @Option(name = "--no-filters", aliases = {"-n"}, usage = "Don't run the submit_filter/2 from the parent projects") 
 InputStreamReader inReader = new InputStreamReader(in); 
 InputStreamReader inReader = new InputStreamReader(in); 
<|del|> 
 submitRecord.status = r.status.name(); 
 label.status= l.status.name(); 
 label.by = new AccountAttribute(); label.by.email = a.getPreferredEmail(); label.by.name = a.getFullName(); label.by.username = a.getUserName(); 
<|del|> 
<|del|> 
 + name); 
 Project.NameKey getProject() { return projectKey; 
 ignoreWhitespace = in.readBoolean(); 
 public String resumeSortKey; 
 Integer limitFromPredicate = LimitPredicate.getLimit(FIELD_LIMIT, p); 
 Integer limitFromPredicate = LimitPredicate.getLimit(FIELD_LIMIT, p); 
 Integer limitFromPredicate = LimitPredicate.getLimit(FIELD_LIMIT, p); 
 private final long delay; private volatile ScheduledFuture<?> handle; 
 handle = submit.create().start(INITIAL_DELAY_S, SECONDS); 
 public void stop() { ScheduledFuture<?> f = handle; if (f != null) { handle = null; f.cancel(true); } 
 public String[] plugnisUrls; 
 public String[] plugnisUrls; 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not 
 * Writing a plugin: 
 private final StaticServlet staticServlet; private final boolean isNoteDbEnabled; private final Integer pluginsLoadTimeout; 
public class Plugin { public static enum ApiType { EXTENSION, PLUGIN; } 
 public Injector getSysInjector() { return sysInjector; } 
 private final Path pluginsDir; private final Path dataDir; private final Path tempDir; 
 install(new WebUiPluginModule()); 
 public List<String> plugins; public List<Message> messages; public Integer pluginsLoadTimeout; public boolean isNoteDbEnabled; 
 * Base class for writing Gerrit Web UI plugins 
<|del|> 
import static com.google.inject.Scopes.SINGLETON; 
 @Nullable Class<? extends Module> httpModule) { this.cacheKey = new CacheKey(name); 
 assertEquals(ms(0, SECONDS), parse("0s")); 
 addMessage( String.format( "(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name())); 
 return ScriptRunner.NOOP; 
 ds.setValidationQuery(dst.getValidationQuery()); ds.setValidationQueryTimeout(5); 
 final StringBuilder b = new StringBuilder(); final ConfigSection dbs = new ConfigSection(cfg, "database"); 
 final StringBuilder b = new StringBuilder(); final ConfigSection dbc = new ConfigSection(cfg, "database"); 
<|del|> 
 // not used throw new UnsupportedOperationException(); 
<|del|> 
 ui.message( "WARN: InitStep from plugin %s does not implement %s (Exception: %s)", jar.getName(), InitStep.class.getName(), e.getMessage()); 
 ui.message( "WARN: Cannot load and get plugin init step for %s (Exception: %s)", jar, e.getMessage()); 
 ui.message("WARN: Cannot list %s", pluginsDir.getAbsolutePath()); 
 } Arrays.sort(matches, new Comparator<File>() { @Override public int compare(File o1, File o2) { return o1.getName().compareTo(o2.getName()); } }); 
<|del|> 
<|del|> 
 public List<Change> load(Project.NameKey key) throws Exception { 
 public static final String PREFIX = "/gerrit_ui/rpc/"; 
<|del|> 
 expect(sshProvider.get()).andReturn("*:29418"); 
 public GitBlitInitStep(final ConsoleUI ui, final Section.Factory sections, @PluginName final String pluginName) { 
 log.info("Configuring servlet and filters"); 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 final GitRepositoryManager repoManager) 
 projectControl.validateFor(nameKey); 
 return gsonBuilder.create(); 
<|del|> 
 for (Update update : event.getUpdates()) { if (update.getRefName().startsWith("refs/heads")) { networkGraphDataCache.refresh(event.getProjectName()); return; } } 
 final PlotWalk walk = new PlotWalk(repo); try { 
 try { List<Head> heads = getHeadsForRepository(repo); for (Head head : heads) { ObjectId headId = repo.resolve(head.getId()); walk.markStart(walk.parseCommit(headId)); } 
 repoManager.openRepository(NameKey.parse(repoName)); 
<|del|> 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 if (!depPatchSetList.isEmpty()) { PatchSet depPatchSet = depPatchSetList.get(0); 
<|del|> 
 public static final String ADMIN_GROUPS = "/admin/groups/"; public static final String ADMIN_CREATE_GROUP = "/admin/create-group/"; 
 patch(token, base, id, patchIndex, patchSetDetail, patchTable, topView, null); 
//limitations under the License. package com.googlesource.gerrit.plugins.gitblit.app; import org.apache.wicket.Request; import org.apache.wicket.RequestCycle; import org.apache.wicket.protocol.http.request.WebRequestCodingStrategy; import org.apache.wicket.protocol.http.servlet.ServletWebRequest; 
<|del|> 
import static com.google.gerrit.common.PageLinks.PROJECTS; import static com.google.gerrit.common.PageLinks.QUERY; 
Copyright (C) 2012 The Android Open Source Project 
 in = PGPUtil.getDecoderStream(in); return new PGPPublicKeyRingCollection(in); 
 public OrmException convertError(final String op, final String entity, final SQLException err) { 
 String getDomain(); 
 public final static class Builder { 
 } public String toString() { return String.format("AuthUser[uuid=%s, userName=%s]", getUUID(), getUserName()); } 
 public String get() { 
 * present. This indicates that the AuthBackend has none of the needed * information in the request to perform authentication. If parts of the * authentication information is available to the backend, then a different * AuthException should be used. 
<|del|> 
 private final String username; 
 /** * Returns the user's SSH PublicKey credentials. * * @return SSH PublicKey or null if was not provided during SSH negotiation. */ @Nullable 
 final String soyTemplatesRoot, String siteTitle) { 
 ImmutableMap.<String, String> of(), staticPrefix, toFileURL(customTemplatesFilename), siteTitle); 
 private static final String BASIC_AUTH_PREFIX = "Basic "; 
 if (hdr == null) { // We are anonymous at this stage 
 if (hdr == null) { // We are anonymous at this stage 
 if (splitPos < 0) { 
public interface CommitValidationListener { 
public interface CommitValidationListener { 
 return getReviewers(db.patchSetApprovals().byChange(notes.getChangeId())); 
 return ImmutableSetMultimap.copyOf(reviewers); 
 } super.onBrowserEvent(event); 
 public void display(DashboardMap dashes) { while (1 < table.getRowCount()) { table.removeRow(table.getRowCount() - 1); } 
 } }); 
 authUsers.add(checkNotNull(backend.authenticate(request))); 
 "UniversalAuthBackend doesn't support domain."); 
 } else if (authExs.size() == 1) { 
 if (authUsers.size() == 1) { 
 @Argument(index = 0, required = true, multiValued = false, usage = "change with topic to change") 
 public final String message; 
 return message; 
 * Listener to provide validation on received commits. 
 * Result of a commit validation from a CommitValidationListener. 
 new CommitValidationResult(false, "Prohibited by Gerrit, invalid commit"); 
 * Gets additional textual description for the validation failure. 
 public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException { final String commitMessage = receiveEvent.commit.getFullMessage(); final List<CommitValidationMessage> messages = new ArrayList<CommitValidationMessage>(); 
 throw new CommitValidationException("Only 'hello world' commit messages are allowed ;-)"); 
public class DashboardInfo extends JavaScriptObject { 
 dashboards.putAll(loadDashboards(projectName, repo, revWalk, ref)); 
 log.warn("Failed to load dashboards of project " + projectName.get(), e); 
 info = loadProjectDefaultDashboard(projectState, considerLocal); if (info != null) { replaceTokens(info, projectName.get()); return info; 
<|del|> 
<|del|> 
<|del|> 
 return a.id().compareTo(b.id()); 
 table.setWidget(row, 1, new Anchor(k.name(), "#" + link(k))); 
 private static final Logger log = LoggerFactory.getLogger(CherryPick.class); 
<|del|> 
<|del|> 
 this.links = new HashMap<Integer, Anchor>(); 
 String fileCommentBorder(); 
 if (isFileCommentCell) { 
 /** Disable gzip compression for already compressed responses. */ 
 return String.format( "BinaryResult[Content-Type: %s, Content-Length: %d]", getContentType(), getContentLength()); 
 replaceTokens(dashboards.get(id), projectName.get()); 
 private Map<String, DashboardInfo> projectDashboards(final Project.NameKey projectName) { final Map<String, DashboardInfo> output = Maps.newTreeMap(); 
 parent = projectState.getProject().getParent(allProjects); 
 if (defaultDashboardId == null) { return null; } return loadDashboard(projectControl, defaultDashboardId, defaultDashboardId); 
 cb.onSuccess(HttpResponse.wrap(res, data)); 
<|del|> 
 @Override protected void destroyCommentRow(final int row) { super.destroyCommentRow(row); 
<|del|> 
 throw new InvalidChangeOperationException( "Not allowed to add new Patch Sets to: " + changeId.toString()); 
 void revertChange(PatchSet.Id patchSetId, String message, AsyncCallback<ChangeDetail> callback); 
Copyright (C) 2012 The Android Open Source Project 
 detail.setCanCherryPick(control.getProjectControl().canPushToAtLeastOneRef() == Capable.OK); 
<|del|> 
 if (!control.getProjectControl().controlForRef(destinationBranch).canUpload()) { throw new InvalidChangeOperationException( "Not allowed to cherry pick " + changeId.toString() + " to " + destinationBranch); 
import com.google.gerrit.reviewdb.client.Branch; 
<|del|> 
 final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), commitToCherryPick, authorIdent, myIdent, message); 
 change.nextPatchSetId(); 
 case MysqlErrorNumbers.ER_DUP_ENTRY: 
 String fileCommentHeader(); 
 new SshAuthRequest(username, key, sd.getRemoteAddress()); 
 this(username, null, null, clientAddress); 
 public void checkCredentials(Object credentials) throws AuthException { if (credentials instanceof String) { super.checkCredentials(credentials); } else if (credentials instanceof PublicKey && Objects.equal(getPubKey(), credentials)) { return; } throw new InvalidCredentialsException(); 
 public void checkCredentials(Object credentials) throws AuthException { if (credentials instanceof String) { super.checkCredentials(credentials); } else if (credentials instanceof PublicKey && Objects.equal(getPubKey(), credentials)) { return; } throw new InvalidCredentialsException(); 
 void createNewPatchSet(final PatchSet.Id patchSetId, final String newCommitMessage, final AsyncCallback<ChangeDetail> callback); 
class CodeReviewCommit extends RevCommit { 
 String foreach = null; 
 } else if ("foreach".equals(kv[0])) { foreach = URL.decodeQueryString(kv[1]); 
 it.set(it.next() + " " + all_queries); 
<|del|> 
 public RestView<ChangeResource> list() throws ResourceNotFoundException { throw new ResourceNotFoundException(); 
 public RestView<ChangeResource> list() throws ResourceNotFoundException { throw new ResourceNotFoundException(); 
<|del|> 
 if (fetchAccountIds(changeResource).contains(accountId)) { Account account = accountCache.get(accountId).getAccount(); return new ReviewerResource(changeResource, account); 
 Set<Account.Id> accountIds = new HashSet<Account.Id>(); 
Copyright (C) 2012 The Android Open Source Project 
 ValueRadioButton b = new ValueRadioButton(ct.getCategory(), buttonValue); SafeHtml buf = new SafeHtmlBuilder().append(buttonValue.format()); buf = CommentLinkProcessor.apply(buf); SafeHtml.set(b, buf); 
<|del|> 
 Account.Id accountId = patchSetApproval.getAccountId(); if (!reviewers.containsKey(accountId)) { Account account = accountCache.get(accountId).getAccount(); reviewers.put(accountId, json.format(new ReviewerResource(rsrc, account))); } 
 .append(ChangeUtil.cropSubject(subject)); 
 List<String> lastCreateChangeErrors = new ArrayList<>(); 
 String projectFilterPanel(); String projectFilterLabel(); 
 String projectFilter(); 
<|del|> 
<|del|> 
<|del|> 
 return "[Octopus merge; cannot be formatted as a diff.]\n"; 
<|del|> 
<|del|> 
 private final Provider<MergeOp> mergeOpProvider; private final Provider<MergeOpRepoManager> ormProvider; 
 public ListeningExecutorService createChangeUpdateExecutor(@GerritServerConfig Config config) { 
 @Override public String toString() { return callable.toString(); } }; } 
 * 
 * @throws InvalidCredentialsException when the credentials are present and 
<|del|> 
 log.error("Cannot query LDAP to authenticate user", e); 
 Collection<GroupReference> suggest( String name, @Nullable ProjectControl project); 
 this.projectCache = projectCache; 
 boolean projectExists = false; 
 if (!projectExists) { 
import com.google.gerrit.server.account.DefaultRealm; 
<|del|> 
public final class Change extends Reviewable { public static class Id extends Reviewable.Id { 
 public void add(final Project.NameKey project) { 
 b.append(URL.encode(p.get())); 
 api.addParameter("project", n.get()); 
 stmt.executeUpdate("UPDATE accounts SET max_recent_entries = " + AccountGeneralPreferences.DEFAULT_MAX_RECENT_ENTRIES); 
<|del|> 
 super(text, token); this.toHighlight = toHighlight; 
 public MetaDataUpdate(GitReferenceUpdated gitRefUpdated, 
 public void checkCredentials(Object credentials) throws AuthException { if (!Objects.equal(getPassword(), credentials)) { 
<|del|> 
<|del|> 
 PhoneBookDb p = phoneBook.open(); try { p.updateSchema(executor); 
 CommitValidators(@GerritPersonIdent final PersonIdent gerritIdent, final SshInfo sshInfo, 
<|del|> 
<|del|> 
<|del|> 
import com.google.gwt.user.client.ui.Label; 
<|del|> 
<|del|> 
 Section s = new Section(); 
 if (Project.DashboardType.fromId(id) != null) { 
<|del|> 
<|del|> 
 messages.addAll(e.getMessages()); 
 public List<CommitValidationMessage> validate(CommitReceivedEvent receiveEvent) throws CommitValidationException { List<CommitValidationMessage> messages = new ArrayList<>(); 
 + FooterConstants.CHANGE_ID.getName() + " must be in commit message footer"; 
 + FooterConstants.CHANGE_ID.getName() + " line format in commit message footer"; 
 List<CommitValidationMessage> messages = new ArrayList<>(); 
 return String.format( " gitdir=$(git rev-parse --git-dir); scp -p -P %d %s@%s:hooks/commit-msg ${gitdir}/hooks/", 
 ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey()); 
 if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) { 
 logError( "User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName()); 
<|del|> 
 String projectName = params.getParameter(0); 
<|del|> 
 "Project %s has invalid notify %s filter \"%s\": %s", state.getProject().getName(), nc.getName(), 
<|del|> 
 return serverIdentProvider.get(); 
<|del|> 
 * Uses the time as stored in annotated tags if available, or else the commit * time of the tagged commit. Non-commits are given {@link Long#MIN_VALUE}, 
 * Uses the time as stored in annotated tags if available, or else the commit * time of the tagged commit. Non-commits are given {@link Long#MIN_VALUE}, 
<|del|> 
 log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err); 
 ItemAndPluginName myItem = item.get(); return myItem != null ? myItem.provider.get() : null; 
 ItemAndPluginName myItem = item.get(); return myItem != null ? myItem.provider.get() : null; 
Copyright (C) 2013 The Android Open Source Project 
 } catch (OrmException e1) { log.error("Exception while looking up avatar for user: " + user, e1); 
Copyright (C) 2013 The Android Open Source Project 
 renderJson( req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes), TreeJsonData.Tree.class); 
 return " DEFAULT '" + (column.getDefaultValue(Boolean.class) ? getTrueLiteralValue() : getFalseLiteralValue()) + "'"; 
<|del|> 
Copyright (C) 2012 The Android Open Source Project 
<|del|> 
 int l = isHead(left) ? 1 : 0; int r = isHead(right) ? 1 : 0; return r - l; 
 final AbbreviatedObjectId id = commit.abbreviate(7); 
 static class MemberInfo { final String kind = "gerritcodereview#member"; 
<|del|>
 switch (authConfig.getAuthType()) { case OPENID: config.setAllowedOpenIDs(authConfig.getAllowedOpenIDs()); break; case OPENID_SSO: config.setOpenIdSsoUrl(authConfig.getOpenIdSsoUrl()); break; 
 ObjectId o = oldObjectId != null ? oldObjectId : ObjectId.zeroId(); ObjectId n = newObjectId != null ? newObjectId : ObjectId.zeroId(); Event event = new Event(project, ref, o.name(), n.name()); 
 final native void init() /*-{ this.members = []; }-*/; 
<|del|> 
 * Bind one implementation as the item. 
 static class Input { List<String> members; 
 public List<MemberInfo> apply(GroupResource resource, Input input) 
 return newMembers; 
 this.messages = Collections.emptyList(); 
 Set<Account.Id> projectWatchers = new HashSet<Account.Id>(); 
import java.util.HashMap; import java.util.Map; 
 put(GROUP_KIND, "members").to(PutMembers.class); put(MEMBER_KIND).to(PutMembers.PutMember.class); 
import java.util.List; import java.util.regex.Pattern; 
<|del|> 
 return contextPath + servletPath + path; 
 outputStream = new ServletOutputStream() { @Override public void write(int c) throws IOException { osWriter.write(c); osWriter.flush(); } }; 
 return new PutMember(put, Url.decode(id)); 
 public enum Policy { /** Use {@link #validateForGerritCommits}. */ GERRIT, 
<|del|> 
 /** * Iterates from a project up through its parents to All-Projects. * <p> * If a cycle is detected the cycle is broken and All-Projects is visited. */ 
 return null; 
 seen.add(firstResult.getProject().getNameKey()); 
 public PutMember create(final GroupResource group, final String id) { 
 private final String id; 
 throws AuthException, MethodNotAllowedException, BadRequestException, OrmException { PutMembers.Input in = new PutMembers.Input(); in._oneMember = id; return put.get().apply(resource, in); 
 auditUpdates.add(audit); 
 public GroupResource getGroup() { return group; 
 final Map<Account.Id, MemberInfo> members = getMembers(resource.getGroupUUID(), new HashSet<AccountGroup.UUID>()); return Lists.newArrayList(members.values()); 
 final AccountGroup.UUID groupUUID, 
 final AccountGroup group = groupCache.get(groupUUID); if (group == null) { // the included group is an external group and can't be resolved return Collections.emptyMap(); } 
 final AccountGroup.UUID groupUUID, 
 final AccountGroup group = groupCache.get(groupUUID); if (group == null) { // the included group is an external group and can't be resolved return Collections.emptyMap(); } 
<|del|> 
 StringBuilder url = new StringBuilder(); url.append("http://www.gravatar.com/avatar/"); url.append(hex(emailMd5)); url.append(".jpg"); 
<|del|> 
 } settings.setHref(Gerrit.selfRedirect(PageLinks.SETTINGS)); 
 new Callable<Void>() { @Override public Void call() { runPushOperation(); return null; } 
 this.userGenericFactory = userGenericFactory; this.groupCache = groupCache; this.groupDetailFactory = groupDetailFactory; 
 return user.getEffectiveGroups().containsAnyOf(ids); 
<|del|> 
 /** * @return optional email address to send to the group's members. If * provided, Gerrit will use this email address to send * change notifications to the group. */ 
<|del|> 
 formatter.addColumn(Objects.firstNonNull(info.name, "n/a")); 
 Dispatcher.toProjectAdmin(parents.get(0), ProjectScreen.ACCESS)); 
<|del|> 
 parents = new ArrayList<NameKey>(names.length); for (String n : names) { 
 return Collections.emptyList(); 
 return Collections.emptyList(); 
 allProjectsName = all; order = new ArrayList<Project.NameKey>(); index = 0; 
 List<Project.NameKey> parents = pr.getParents(); if (parents == null || parents.size() < 1) { order.add(allProjectsName); return; 
 public Object apply(MemberResource resource, PutMember.Input input) { // Do nothing, the user is already a member. return get.get().apply(resource); 
<|del|> 
 * An ITS facade doing nothing, it's configured when no ITS are referenced in * config 
 if (log.isDebugEnabled()) { log.debug("addComment({},{})", issueId, comment); } 
 String message = commit.getFullMessage(); log.debug("Searching comment " + message.trim() + " for patterns " 
 for (Entry<Pattern, ItsAssociationPolicy> entry : regexes.entrySet()) { 
 + "Hint: insert one or more issue-id anywhere in the commit message.\n" 
<|del|> 
<|del|> 
 if (filterMatch(null, nc.getFilter())) { 
 @Inject 
 return who.name; 
 String name = formatAccountAttribute(who); 
 throw new AuthException(String.format("Cannot add group: %s", includedGroupResource.getName())); 
 throw new AuthException(String.format("Cannot add group: %s", includedGroupResource.getName())); 
 in.groups = ImmutableList.of(id); 
 public PermissionRule getRule(GroupReference group) { return getRule(group, false); 
 if (who != null && !Strings.isNullOrEmpty(who.name)) { 
 return getCommentPrefix(change) + "change " + what + " [by " + who + "]"; 
 for (String issue : issues) { log.debug("Adding GitWeb URL " + gitUrl + " to issue " + issue); 
 this.key = GerritHookFilterChangeState.this.translateConditionKey(key); 
 this.key = GerritHookFilterChangeState.this.translateConditionKey(key); 
 super(id.get()); 
 String ref = URL.encodeQueryString(id.substring(0, c)); String path = URL.encodeQueryString(id.substring(c + 1)); 
 Account.Id getAccountId() { return rev.getAccountId(); 
 public AccountGroup.UUID getMember() { return getMemberDescription().getGroupUUID(); 
 table.setWidget(row, C_PROJECT, new ProjectLink(c.getProject().getKey(), c .getStatus())); 
<|del|> 
 if (caught == null) { 
 private void onFailure(Throwable caught) { if (failed) { return; } failed = true; Throwable caughtDuringOnFailure = null; 
 AccountGroup.UUID g = ids.iterator().next(); groups(group).id(g.get()).delete(cb); 
 if (input == null || Strings.isNullOrEmpty(input.owner)) { throw new BadRequestException("owner is required"); 
 if (input == null || Strings.isNullOrEmpty(input.owner)) { throw new BadRequestException("owner is required"); 
 group = db.accountGroups().get(group.getId()); if (group == null) { throw new ResourceNotFoundException(); 
<|del|> 
 } catch (OrmException | NoSuchChangeException e) { 
 } catch (OrmException | NoSuchChangeException e) { 
 return format(cd, Optional.<PatchSet.Id> absent(), true); 
 private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) 
 table.insertRow(insertPosition); applyDataRowStyle(insertPosition); populate(insertPosition, info); 
 protected MessageInfo() { } } 
 public static class IncludedInInfo extends JavaScriptObject { public final native JsArrayString branches() /*-{ return this.branches; }-*/; public final native JsArrayString tags() /*-{ return this.tags; }-*/; 
 for (ChangeNotes notes : first.notesFactory.create( first.db, missing.keySet())) { 
 public static void ensureReviewedByLoadedForOpenChanges( Iterable<ChangeData> changes) throws OrmException { 
<|del|> 
 AccountInfo info = created.get(id); if (info == null) { info = new AccountInfo(id); created.put(id, info); } 
 private transient Account.Id _id; 
<|del|> 
 Loader create(boolean detailed); 
 post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class); 
 public void onSuccess(final VoidResult result) { for (int row = 1; row < table.getRowCount();) { 
<|del|> 
 public static RestApi actions(@Nullable String project, int id, String revision) { 
 for (ApprovalInfo app : Natives.asList(label.all())) { 
public class ReviewNotesModule extends AbstractModule { 
<|del|> 
<|del|> 
 if (pr.getMin() != 0 || pr.getMax() != 0) { // TODO: Support arbitrary labels. 
 public IdentifiedUser getUser() { return user; 
<|del|> 
 Set<String> expectedGroups = Sets.newHashSet(); 
 if (!currentUser.getCapabilities().canAdministrateServer()) { throw new PermissionDeniedException(String.format( 
<|del|> 
 throw new NoSuchProjectException(sourceProjectNameKey); 
 if (projectCache.get(destinationProjectNameKey) != null) { throw new NameAlreadyUsedException(destinationProjectNameKey.toString()); 
<|del|> 
/** Rename a project. **/ @RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER) 
 public List<ReviewerInfo> format(ReviewerResource rsrc) throws OrmException { 
 public Object apply(ReviewerResource rsrc) throws OrmException { 
 OrmException { 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
 public void testCreateGroupWithoutCapability_Forbidden() throws OrmException, JSchException, IOException { 
 public void testCreateGroupWhenGroupAlreadyExists_PreconditionFailed() throws OrmException, JSchException, IOException { 
import com.google.gwt.user.client.ui.FlowPanel; import com.google.gwt.user.client.ui.SuggestBox; import com.google.gwt.user.client.ui.SuggestOracle.Suggestion; 
import com.google.gwt.user.client.ui.FlowPanel; import com.google.gwt.user.client.ui.SuggestBox; import com.google.gwt.user.client.ui.SuggestOracle.Suggestion; 
@RequiresCapability(GlobalCapability.RAW_QUERY) @CommandMetaData(name = "gsql", descr = "Administrative interface to active database") 
 @Override public OrmException convertError(String op, String entity, SQLException err) { return fallbackConvertError(op, entity, err); } 
Copyright (C) 2013 The Android Open Source Project 
<|del|> 
final class CommandProvider { 
 CommandProvider(final Provider<Command> p, final String d) { 
 ((Commands.NestedCommandNameImpl) annotation); 
 @Option( name = "--exclude", metaVar = "NAME", usage = "child project of old parent project which should not be reparented" ) private List<ProjectControl> excludedChildren = new ArrayList<>(); 
@CommandMetaData(name = "ban-commit", descr = "Ban a commit from a project's repository") 
@CommandMetaData(name = "show-queue", description = "Display the background work queues", runsAt = MASTER_OR_SLAVE) 
@CommandMetaData(name = "type", descr = "Test prolog submit type") 
 super(MESSAGE + ": " + name); 
 final native void setCreateEmptyCommit(boolean cc) /*-{ if(cc)this.create_empty_commit=cc; }-*/; 
 result.error = MessageFormat.format( ChangeMessages.get().groupIsNotAllowed, group.getName()); 
<|del|> 
<|del|> 
@RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER) @CommandMetaData(name = "rename-project", descr = "Rename a project") 
<|del|> 
 return info; } 
<|del|> 
<|del|> 
 if (input.name == null) { throw new BadRequestException("name is not provided"); } else if (!name.equals(input.name)) { 
 return m; 
 } else if (args.group != null) { 
 log.warn("Omitting corrupt change " + cd.getId() + " from results", e); 
Copyright (C) 2013 The Android Open Source Project 
 ApprovalCategory.Id catId = Iterables.getLast(allTypes).getApprovalCategoryId(); 
 this.addReviewerCategoryId = Iterables.getLast(approvalTypes.getApprovalTypes()) .getApprovalCategoryId(); 
 } else if (args.group != null) { 
 final Change c = object.change(dbProvider); 
<|del|> 
 public static Git cloneProject(String url) throws GitAPIException { final File gitDir = TempFileUtil.createTempDirectory(); 
 public static String createCommit(Git git, PersonIdent i, String msg, 
 private static ObjectId computeChangeId(Git git, PersonIdent i, String msg) 
@CommandMetaData(name="start", descr="Start replication for specific project or all projects") 
 String name; 
 + "\" does not exist or is not visible'."); 
 args.setProjectName(input.name); 
 throws ResourceConflictException { throw new ResourceConflictException("Project \"" + input.name + "\" already exists"); 
 labelTypes = projectControl.getLabelTypes(); 
 final native void setName(String n) /*-{ if(n)this.name=n; }-*/; 
 SubmitType submitType; List<String> branches; 
 SubmitType submitType; List<String> branches; 
 if (!name.equals(input.name)) { 
 labelTypes = projectControl.getLabelTypes(); 
<|del|> 
 for (String username : usernames) { if (sm.match(ref, username)) { sectionToProject.put(sm.section, sm.project); break; } 
 return RunwayStatus.canceled(); 
 Project project = projectCache.get(new Project.NameKey(newProjectName)).getProject(); assertProjectInfo(project, p); 
<|del|> 
<|del|> 
 tw.addTree(commit.getTree()); assertFalse("ref " + ref + " has non empty commit", tw.next()); tw.reset(); 
 RestResponse r = session.get(endpoint); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); 
 out.mergeable = cd.isMergeable(); if (includeSubmittable) { out.submittable = submittable(cd); } 
 } catch (OrmException | NoSuchChangeException e) { 
 if (lp == null) { return rp != null ? 1 : left.compareTo(right); 
<|del|> 
<|del|> 
 lt.setCanOverride(true); 
 rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true)); 
 if (old == null || old.canOverride()) { 
 public boolean canOverride() { return canOverride; 
 public void setCanOverride(boolean canOverride) { this.canOverride = canOverride; 
 final Change c = object.change(dbProvider); if (c == null) { // The change has disappeared. // return false; } 
import com.google.gerrit.reviewdb.client.AccountGroup; 
<|del|> 
<|del|> 
<|del|> 
 expect(capabilityControl.canAdministrateServer()).andReturn(false).anyTimes(); 
 expect(capabilityControl.canAdministrateServer()).andReturn(true).anyTimes(); 
 type.setAbbreviatedName("CR"); 
 assertEquals("CR", codeReview.getAbbreviatedName()); 
 "SELECT value, name" 
 type.setCopyMinScore("Y".equals(catRs.getString("copy_min_score"))); 
 Change.Id changeId = psa.getKey().getParentKey().getParentKey(); checkArgument(changeId.equals(ctl.getChange().getId()), 
 child(PROJECT_KIND, "children").to(ChildProjectsCollection.class); get(CHILD_PROJECT_KIND).to(GetChildProject.class); 
 u.setRefLogIdent(identifiedUser.newRefLogIdent()); 
 /** Can rename projects on the server. */ 
/** Error indicating generic failure to rename an existing project. */ 
 * in open state by the caller. 
 if (fileName.equals(Constants.DOT_GIT)) { projectName = prefix.substring(0, prefix.length() - 1); } else if (fileName.endsWith(Constants.DOT_GIT_EXT)) { 
// hierarchy anyways, we directly integration test with the filesystem instead 
 * Task stub that logs the invocation sequence to a list and allows to 
<|del|> 
 || canAdministrateServer(); 
 Set<Project.NameKey> projectsToGc = gcQueue.addAll(projectNames); for (Project.NameKey projectName : Sets.difference( Sets.newHashSet(projectNames), projectsToGc)) { 
 b.append(".").append(subsection); 
@RequiresCapability(GlobalCapability.RUN_GC) @CommandMetaData(name = "gc", descr = "Run Git garbage collection") 
 @Inject private GarbageCollection.Factory garbageCollectionFactory; 
 final List<Project.NameKey> projectNames = Lists.newArrayList(); 
<|del|> 
 PUT("/groups/non-existing/members/admin").getStatusCode()); 
 private final String fileName; 
 gcLogger.addAppender(dst); gcLogger.setAdditivity(false); 
 for (AccountProjectWatch accountProjectWatch : accountProjectWatches) { 
 throw new Exception("Project has subscribed submodules."); 
 }.setContentType("text/plain") .setCharacterEncoding(UTF_8.name()) .disableGzip(); 
 log.info(String.format( "Defaulting core.streamFileThreshold to %s", desc)); 
 log.warn( "Omitting corrupt change " + cd.getId() + " from results", e); 
 boolean visible = threadScoper.scope(new Callable<Boolean>(){ @Override public Boolean call() throws NoSuchProjectException { return controlFor(project).isVisible(); } }).call(); if (!visible) { return; } 
 log.error( "Could not obtain available labels for project {}." 
 public Object apply(CommentResource rsrc) throws OrmException { 
 protected boolean includeAuthorInfo() { 
 Short context; Boolean expandAllComments; 
<|del|> 
 public static boolean success(final String username, final ServerSession session, final SshScope sshScope, final SshLog sshLog, final SshSession sd, final CurrentUser user) { 
 public static boolean success(final String username, final ServerSession session, final SshScope sshScope, final SshLog sshLog, final SshSession sd, final CurrentUser user) { 
 if (projectState.getProject().getState().permitsRead() == false) { 
 this.urls = factory.urls; this.site = factory.site; 
 } catch (BadRequestException | PermissionBackendException e) { throw new IOException(e); 
 @Nullable @CanonicalWebUrl String gerritUrl, 
 return repoFactory.create(nameKey); } catch (NoSuchProjectException e) { throw new RepositoryNotFoundException(name, e); 
 gitweb.set("url", "plugins/gitiles/"); 
 gitweb.set("url", "plugins/gitiles/"); 
 // is "connected" to the branch. logDebug("Branch is unborn"); 
 // is "connected" to the branch. logDebug("Branch is unborn"); 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
 if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences() .isRelativeDateInChangeTable()) { 
 relativeDateInChangeTable = false; 
 .setAttribute("href", href) .append(SafeHtml.asis(input)) 
 Iterator<RegexFindReplace> it = findReplaceList.iterator(); while (it.hasNext()) { RegexFindReplace fr = it.next(); 
 if (it.hasNext()) { 
 public static class ConfigInfo { public Boolean useContributorAgreements; public Boolean useContentMerge; public Boolean useSignedOffBy; public Boolean requireChangeId; 
 public static class ConfigInfo { public Boolean useContributorAgreements; public Boolean useContentMerge; public Boolean useSignedOffBy; public Boolean requireChangeId; 
import com.google.gerrit.extensions.webui.UiAction; import com.google.gerrit.reviewdb.client.Account; 
import com.google.gerrit.extensions.webui.UiAction; import com.google.gerrit.reviewdb.client.Account; 
import com.google.gerrit.server.mail.RevertedSender; import com.google.gerrit.server.notedb.ReviewerStateInternal; 
 public NoSuchEntityException(String message) { super(message); 
 rp.getRevWalk().reset(); if (ctl.canCreate(db, rp.getRevWalk(), obj)) { 
<|del|> 
<|del|> 
public abstract class RevWalkPredicate extends OperatorPredicate<ChangeData> { private static final Logger log = LoggerFactory.getLogger(RevWalkPredicate.class); 
 * @return true if it's not a draft, or we can link to drafts 
 } } else { username = req.getRemoteUser(); } if (username == null) { 
 String externalUsername = req.getHeader(authConfig.getLoginHttpHeader()); 
 public boolean match(Repository repo, RevWalk rw, Arguments args) { 
<|del|> 
 * In case the PushOp instance to be scheduled has the * same URI as one pending, but not marked "retrying," it 
 public void setAuthorNameText(final String authorEmail, final String nameText) { header.setWidget(0, 0, new AvatarImage(authorEmail, 26)); 
 return false; 
 return false; 
 return false; 
 } else { 
Copyright (C) 2013 OASP (c) 
Copyright (C) 2013 The Android Open Source Project 
 cherryPickCommit, labelTypes, newPatchSetInfo, Collections.<Account.Id> emptySet()); 
 return -1; 
 formatter.addColumn(Objects.firstNonNull( Strings.emptyToNull(member.name), "n/a")); 
 writer.write(errorText); 
 throw new IOException("Refusing to clear symlink " + dir.getPath()); 
 formatter.addColumn("id"); formatter.addColumn("username"); formatter.addColumn("full name"); 
 formatter.addColumn("id"); formatter.addColumn("username"); formatter.addColumn("full name"); 
 formatter.addColumn(member._id.toString()); formatter.addColumn(Objects.firstNonNull(member.username, "n/a")); 
 if (active != null && !active.isModified(jar)) { 
 try { ObjectLoader loader = repo.open(tw.getObjectId(0)); ByteArrayOutputStream out = new ByteArrayOutputStream(); loader.copyTo(out); return Base64.encodeBase64(out.toByteArray()); 
 } finally { repo.close(); 
 PATCHSET_ACTION_PANEL; 
 public final String name; public final List<MenuItem> items; 
 public final String url; public final String name; public final String target; 
 public final String url; public final String name; public final String target; 
 private static class ListMembersCommandImpl extends ListMembers { 
 OutputStream b64Out = BaseEncoding.base64().encodingStream( new OutputStreamWriter(out, Charsets.UTF_8)); loader.copyTo(b64Out); b64Out.close(); 
 CharArrayWriter w = new CharArrayWriter(4 * (((int)loader.getSize() - 1)/3 + 1)); loader.copyTo(BaseEncoding.base64().encodingStream(w)); return w.toString(); 
 return BaseEncoding.base64().encode(loader.getBytes()); 
 Map<String, FileInfo> toFileInfoMap(Change change, PatchSet patchSet, String difftype) 
<|del|> 
 assertTrue(e.getCause() instanceof SQLException); assertFalse(e instanceof OrmDuplicateKeyException); 
<|del|> 
 IdentifiedUser getUser() { return (IdentifiedUser) getControl().getCurrentUser(); 
 return new RevisionResource(change, ps).doNotCache(); 
 T data; 
<|del|> 
public class GitBlitTopMenu implements TopMenu { private final MenuEntry fullMenuEntries; private final MenuEntry restrictedMenuEntries; 
 public GitBlitTopMenu(final @PluginName String pluginName, final Provider<CurrentUser> userProvider) { 
<|del|> 
import java.util.Collections; import java.util.concurrent.Callable; 
 * @return the cached data; null if no such project exists, projectName is null or an error 
 ProjectState checkedGet(@Nullable Project.NameKey projectName) throws IOException; 
 private PatchSet.Id diffBaseId; 
<|del|> 
<|del|> 
 private Set<String> getFileListBy(final PatchSet.Id id) throws NoSuchChangeException, NoSuchEntityException, OrmException { final Set<String> fileList = new HashSet<String>(); 
 } return fileList; 
 b.setCanDelete(Objects.firstNonNull(info.canDelete, false)); 
 public static class BranchInfo { 
 if (!Strings.isNullOrEmpty(link)) { 
 return Strings.isNullOrEmpty(a.getFullName()) ? Response.none() : a.getFullName(); 
 info.id = Url.encode(group.getGroupUUID().get()); 
 info.ownerId = Url.encode(g.getOwnerGroupUUID().get()); AccountGroup o = groupCache.get(g.getOwnerGroupUUID()); 
 @Option(name = "--context", handler = ContextOptionHandler.class) 
 void addDiff(int endA, int endB, List<Edit> internalEdit) { 
 if (header[e - 1] == '\n') { 
 OrmException { if (!(self.get() instanceof IdentifiedUser)) { throw new AuthException("Authentication required"); } 
 String email = extId.getEmailAddress(); if (email != null) { 
 if (parent.getUser().getAccountId().equals(a)) { 
<|del|> 
import com.google.gerrit.server.project.ProjectCache; import com.google.gerrit.server.query.LimitPredicate; 
<|del|> 
import java.util.Map; import java.util.Optional; 
/** Parses a query string meant to be applied to change objects. */ 
 logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref"); commits.put(changeId, CodeReviewCommit.revisionGone(ctl)); 
<|del|> 
<|del|> 
 resizeHandler = Window.addResizeHandler(new ResizeHandler() { 
 public void replace(ChangeData cd) throws IOException; 
 } catch (OrmException e) { logError("Failed to get submit type for " + ctl.getChange().getKey(), e); 
 cmA = displaySide(diff.meta_a(), diff.text_a(), diffTable.getCmA()); cmB = displaySide(diff.meta_b(), diff.text_b(), diffTable.getCmB()); 
Copyright (C) 2013 The Android Open Source Project 
 private DiffTable diffTable; 
 add(diffTable = new DiffTable()); 
 private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) { 
public interface ChangeIndex { /** @return the schema version used by this index. */ public Schema<ChangeData> getSchema(); /** Close this index. */ public void close(); 
 private static final Logger log = LoggerFactory.getLogger(LuceneChangeIndex.class); 
<|del|> 
 if (loginHttpHeader != null) { String externalUsername = req.getHeader(loginHttpHeader); 
 " available from the object database.", e); 
 " actually commit objects.", e); 
 protected final Provider<ReviewDb> db; private final RepoWalksCache repoWalksCache; 
 protected final Provider<ReviewDb> db; private final RepoWalksCache repoWalksCache; 
/** {line, ch} objects used within CodeMirror. */ 
 private final native LineCharacter setLine(int line) /*-{ this.line = line; return this; }-*/; 
 private final native LineCharacter setCh(int ch) /*-{ this.ch = ch; return this; }-*/; 
 public final native int getLine() /*-{ return this.line; }-*/; public final native int getCh() /*-{ return this.ch; }-*/; 
<|del|> 
 public final native void setValue(String v) /*-{ this.setValue(v); }-*/; 
 return ChangeDataResultSet.change(db.get().changes().all()); 
<|del|> 
 * Validate a commit before it is merged. 
 public void onPreMerge(CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch) 
 public void validatePreMerge(CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch) 
 List<MergeValidationListener> validators = Lists.newLinkedList(); 
<|del|> 
 AccountState s = rsrc.getUser().state(); if (s.getUserName() == null) { 
 if (input.generate) { if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canGenerateHttpPassword()) { throw new AuthException("not allowed to generate HTTP password"); } 
 return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword); 
 VersionedAuthorizedKeys.Accessor authorizedKeys) { 
 private Index<ChangeData> index; 
/** Raw data stream supplied by the body of a PUT or POST. */ 
<|del|> 
 info.id = Url.encode(group.getGroupUUID().get()); 
 info.ownerId = Url.encode(g.getOwnerGroupUUID().get()); AccountGroup o = groupCache.get(g.getOwnerGroupUUID()); 
import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.notes.Note; 
import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.notes.Note; 
 refreshSshKeys(); updateDeleteButton(); 
 accountManager.lookup(new AccountExternalId.Key( AccountExternalId.SCHEME_GERRIT, externalUsername).get()); AccountState account = accountCache.get(accountId); 
<|del|> 
 public void submitOnPushNewPatchSet() throws GitAPIException, OrmException, IOException, ConfigInvalidException { 
 String fileName, String content) throws GitAPIException, IOException { 
 pushFactory.create(db, admin.getIdent(), subject, fileName, content); return push.to(git, ref); 
 public final native String path() /*-{ return this.path; }-*/; 
<|del|> 
 return new CommentApi(ChangeApi.revision(id).view("comments")); 
 public final native boolean has_line() /*-{ return this.hasOwnProperty('line'); }-*/; 
 private CommentApi() { 
 public static void comments(PatchSet.Id id, AsyncCallback<NativeMap<JsArray<CommentInfo>>> cb) { new CommentApi(ChangeApi.revision(id).view("comments")).get(cb); 
<|del|> 
<|del|> 
 public GetDiff setContext(int context) { this.context = context; return this; 
<|del|> 
 approvals.display(changeInfo); 
 RUN_AS + " disabled by auth.enableRunAs = false"); 
 // item is already contained in the table return middle; 
 // item is already contained in the table return middle; 
Copyright (C) 2013 The Android Open Source Project 
 writeStdOutSync("Nothing to replicate"); 
<|del|> 
 PermissionNameRenderer nameRenderer = new PermissionNameRenderer(projectAccess.getCapabilities()); normalName = new ValueLabel<String>(nameRenderer); deletedName = new ValueLabel<String>(nameRenderer); 
 permissions.put(e.getKey(), e.getValue()); permissions.put(e.getKey().toLowerCase(), e.getValue()); 
 String message = commitMessage.getText().trim(); if ("".equals(message)) { message = null; } 
 throws ResourceNotFoundException { throw new ResourceNotFoundException(id); 
 RestCollection<TopLevelResource, ConfigResource> { 
 ConfigCollection(DynamicMap<RestView<ConfigResource>> views) { 
 public RestView<TopLevelResource> list() throws ResourceNotFoundException { throw new ResourceNotFoundException(); 
 public final native void setLine(int line) /*-{ this.line = line; }-*/; public final native void setCh(int ch) /*-{ this.ch = ch; }-*/; 
/** Unit tests for EditIterator */ 
 new ReplicationState(ReplicationType.STARTUP); 
<|del|> 
<|del|> 
<|del|> 
 writeStdOutSync("Nothing to replicate"); 
<|del|> 
 || isOwner(); 
 private Provider<AddMembers> addMembers; 
 private Provider<AddIncludedGroups> addIncludedGroups; 
 String groupName = addIncludeBox.getText(); 
 CommentBox(CommentGroup group, CommentRange range) { this.group = group; 
 cmA = displaySide(diff.meta_a(), diff.text_a(),diffTable.getCmA()); cmB = displaySide(diff.meta_b(), diff.text_b(),diffTable.getCmB()); 
 mapper = LineMapper.Builder.build(); 
 colorLines(cmA, origLineA, aLength); colorLines(cmB, origLineB, bLength); mapper.appendCommon(Math.min(aLength, bLength)); 
 int deleteCnt = aLength - bLength; insertEmptyLines(cmB, mapper.getLineB(), deleteCnt); mapper.appendDelete(deleteCnt); 
 CodeMirror other = otherCM(cm); 
 JsArray<Span> edits, int startLine) { if (edits == null) { return; } 
 private void colorLines(CodeMirror cm, int line, int cnt) { 
 Widget header; 
 Element name; 
 Element summary; 
 Element date; 
 Element contentPanel; 
 Element contentPanelMessage; 
 // TODO: Format the comment box differently based on whether isDraft // is true. setAuthorNameText(author); 
 // TODO: Format the comment box differently based on whether isDraft // is true. setAuthorNameText(author); 
 setOpen(false); setClickHandler(); 
 if (open) { removeStyleName(style.close()); addStyleName(style.open()); } else { removeStyleName(style.open()); addStyleName(style.close()); } 
 return getStyleName().contains(style.open()); 
 Element cmA; 
 Element cmB; 
<|del|> 
<|del|> 
 if (!allScheduled) { return; 
 doAllPushTasksCompleted(); 
 wrappedLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state); 
 MergeValidators create(); 
 wrappedLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state); return; 
 writeStdErrSync("We are interrupted while waiting replication to complete"); 
 // Although we'd prefer to keep this class private, Velocity will only pick 
 * Format a link to a URL in the used Its' syntax. 
 // the input object is not a tree or something broke later. RevTree tree; 
 return new QuerySource(indexes, p, opts, getSort()); 
<|del|> 
 headerClick.removeHandler(); headerClick = null; 
 private static boolean isEmptyOrSlash(String path) { 
 public static void deleteDraftChange(final PatchSet.Id patchSetId, GitRepositoryManager gitManager, final GitReferenceUpdated replication, final ReviewDb db) 
 Change c = input.change(); if (c == null) { return null; } return c.getProject().get(); 
 public static void comment(PatchSet.Id id, String commentId, 
 public static void draft(PatchSet.Id id, String draftId, 
 public static void updateDraft(PatchSet.Id id, String draftId, CommentInfo content, AsyncCallback<NativeMap<JsArray<CommentInfo>>> cb) { revision(id, "drafts").id(draftId).put(content, cb); 
 private static RestApi revision(PatchSet.Id id, String type) { 
 headerClick = header.addDomHandler(new ClickHandler() { 
 if (headerClick != null) { headerClick.removeHandler(); headerClick = null; } 
<|del|> 
 for (Runnable r : resizeCallbacks) { 
 protected void onUnload() { 
<|del|> 
 return new File(sitePaths.index_dir, "gerrit_index.config"); 
 log.info("Gerrit Code Review " + myVersion() + " ready"); 
<|del|> 
import java.util.Set; import java.util.concurrent.TimeUnit; import org.eclipse.jgit.lib.Config; 
 ImmutableList.<SchemaDefinitions<?>>of( AccountSchemaDefinitions.INSTANCE, ChangeSchemaDefinitions.INSTANCE, GroupSchemaDefinitions.INSTANCE); 
 private final ListeningExecutorService batchExecutor; private final boolean closeExecutorsOnShutdown; 
 closedIndex.setDefaultCollection(CHANGES_CLOSED); 
 } catch (SolrServerException e) { 
 if (cd.getChange().getStatus().isOpen()) { 
 } catch (SolrServerException e) { 
 @Inject SolrIndexModule(@GerritServerConfig Config cfg) { this(cfg, true, 0); 
 bind(String.class).annotatedWith(SolrIndexUrl.class).toInstance(url); 
 sendUpdate(); 
<|del|> 
<|del|> 
 String[] splitKeyValue = arg.split("="); 
<|del|> 
 changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, 
 * labels for these arguments should be kept in ChangeQueryBuilder 
 positional = Lists.newArrayList(); keyValue = Maps.newHashMap(); 
 String[] splitArgs = args.split(","); 
 setDownloadHeaders(req, res, filename, format.mimeType); 
 .setTree(tree) 
 return path.substring(slash + 1); 
 throw new IllegalStateException( String.format("cannot set old revision on %s view", type)); 
<|del|> 
<|del|> 
import org.apache.lucene.index.Term; import org.apache.lucene.search.BooleanClause; 
 // Project.NameKey projectName = new Project.NameKey(p); 
<|del|> 
import java.util.Map; 
 changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, 
 return getTopic(input); 
 super(ChangeField.COMMIT, id.name()); 
 public static void ensureCurrentPatchSetLoaded(Iterable<ChangeData> changes) throws OrmException { 
 @Override public void markReady(boolean ready) throws IOException { // Arbitrary done on open index, as ready bit is set // per index and not sub index openIndex.markReady(ready); 
<|del|> 
Copyright (C) 2010 The Android Open Source Project 
 private static final Logger log = LoggerFactory.getLogger(IncludedInDetailFactory.class); 
 return c1.getCommitTime() - c2.getCommitTime(); 
 return c1.getCommitTime() - c2.getCommitTime(); 
 Set<RevCommit> targetReachableFrom = new HashSet<RevCommit>(); targetReachableFrom.add(target); 
<|del|> 
<|del|> 
<|del|> 
 expTags.add(TAG_2_5); expTags.add(TAG_2_5_ANNOTATED); expTags.add(TAG_2_5_ANNOTATED_TWICE); assertEquals(expTags, detail.getTags()); expBranches.add(BRANCH_2_5); assertEquals(expBranches, detail.getBranches()); 
 Document doc = searchers[sd.shardIndex].doc(sd.doc, fields); result.add(toChangeData(fields(doc, fields), fields, idFieldName, db)); 
 MessagePredicate(Provider<ReviewDb> db, ChangeIndex index, String value) { 
import java.util.Collection; import java.util.HashSet; 
 Predicate<ChangeData> p = Predicate.and( new LegacyChangeIdPredicate(object.getId()), this); for (ChangeData cData : index.getSource(p, QueryOptions.oneResult()).read()) { 
 Set<Ref> allTagsAndBranches = new HashSet<Ref>(); allTagsAndBranches.addAll(tags); allTagsAndBranches.addAll(branches); Set<Ref> allMatchingTagsAndBranches = includedIn(repo, rw, rev, allTagsAndBranches); 
 * Resolves which tip refs include the target commit. 
 return new AccountGroup.UUID(URL.decodeQueryString(id())); 
 static final Schema<ChangeData> V1 = release( 
import javax.annotation.Nullable; /** Dynamic pointers to the index versions used for searching and writing. */ 
 private final CopyOnWriteArrayList<ChangeIndex> writeIndexes; private final AtomicReference<ChangeIndex> searchIndex; 
 this.writeIndexes = Lists.newCopyOnWriteArrayList(); this.searchIndex = new AtomicReference<ChangeIndex>(); 
 /** * @return the current search index version, or null if the secondary index is * disabled. */ @Nullable 
 private Predicate<ChangeData> starredby(Set<Account.Id> who) { 
 // wasteful; see if we can determine which ones it is safe to close with 
 Thread t = new Thread() { 
 Provider<IdentifiedUser> identifiedUser, 
 if (original.has_line()) { input.setLine(original.line()); } 
 History.newItem(Dispatcher.toGroup(getRowItem(row).getId())); 
 public static KeyMap create() { return createObject().cast(); 
import com.google.gerrit.extensions.common.ReviewerUpdateInfo; 
 /** Execute merge validation plug-ins */ 
 DynamicSet<MergeValidationListener> mergeValidationListeners) { this.mergeValidationListeners = mergeValidationListeners; 
<|del|> 
 Util.GROUP_SVC.changeGroupOwner(getGroupId(), newOwner, new GerritCallback<VoidResult>() { public void onSuccess(final VoidResult result) { 
 state = update.state; maxObjectSizeLimit = update.maxObjectSizeLimit; 
 private void readGroupList() throws IOException { groupList = GroupList.parse(readUTF8(GroupList.FILE_NAME), this); } 
 useSignedOffBy = new CheckBox(Util.C.useSignedOffBy(), true); saveEnabler.listenTo(useSignedOffBy); agreementsPanel.add(useSignedOffBy); add(agreementsPanel); 
 List<MenuEntry> getEntries(); 
 String patchTableSize_LongModify(int insertions, int deletions); 
 public AccountGroup.Id getAdministratorsGroup() { return administratorsGroupId; 
 throw new RuntimeException(e); 
 entryTitle = rsrc.substring(nameOffset, rsrc.length() - 5).replace('-', ' '); 
 entryTitle = rsrc.substring(nameOffset, rsrc.length() - 3).replace('-', ' '); 
 entryTitle = rsrc.substring(nameOffset).replace('-', ' '); 
 @Option(name = "-o", usage = "Output options") void addOption(ListChangesOption o) { json.addOption(o); } 
 .getLogger(LegacyMessagePredicate.class); 
 } else if (name.startsWith("about.") && (about == null)) { 
 final PatchSetInserter.Factory patchSetInserterFactory) { 
 public interface Factory { RebaseChange create(); } private final ChangeControl.Factory changeControlFactory; private final PatchSetInfoFactory patchSetInfoFactory; private final ReviewDb db; 
 * @param chg the change that should be rebased 
 final Change chg, final Account.Id uploader, final RevCommit baseCommit, final boolean useContentMerge) throws NoSuchChangeException, 
 PatchSetInserter patchSetinserter = patchSetInserterFactory .create(git, revWalk, changeControl.getRefControl(), change, rebasedCommit) 
 final IdentifiedUser uploader = 
 public void onKeyDown(final KeyDownEvent event) { if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) { hide(); } 
 CRC32 crc = new CRC32(); 
 HashSet<String> tables = new HashSet<String>(); 
 COLLAPSED); 
 assertLineChsEqual(LineCharacter.create(0, 1), iter.advance(1)); 
 assertLineChsEqual(LineCharacter.create(0, 3), iter.advance(3)); 
 if (resizeHandler != null) { resizeHandler.removeHandler(); resizeHandler = null; 
 /** TODO: Unused now. Re-enable this after implementing auto-save */ 
<|del|> 
<|del|> 
<|del|>
 throw new ProvisionException("Cannot open ReviewDb", e); 
 try { for (String user : pluginConfig.getStringList('ignoreUser')) { if (commit.getAuthorIdent().getName() === user) { continue; } } 
<|del|> 
<|del|> 
 rw.parseCommit(ObjectId.fromString(u.getNewObjectId())); int maxReviewers = 3; //TODO Move to config 
<|del|> 
 DefaultActions.invoke(change, action, api); 
 public final native NativeMap<?> labels() /*-{ return this.labels }-*/; 
 Element fileName; 
 UIObject.setVisible(fileName, false); 
 Throwables.propagateIfPossible(e, OrmException.class); 
 List<String> plugins = Objects.firstNonNull(installPlugins, Lists.<String> newArrayList()); bind(new TypeLiteral<List<String>>() {}).annotatedWith( InstallPlugins.class).toInstance(plugins); 
 List<String> plugins = Objects.firstNonNull(installPlugins, Lists.<String> newArrayList()); bind(new TypeLiteral<List<String>>() {}).annotatedWith( InstallPlugins.class).toInstance(plugins); 
 private static boolean nullOrEmpty(List<?> list) { 
 final @InstallPlugins List<String> installPlugins) throws IOException, 
<|del|> 
 public ConfigInfo apply(ProjectResource resource) { 
 public interface HasLastModified { 
 return (o instanceof RevId) && id.equals(((RevId) o).id); 
 public interface HasLastModified { /** * @return time for the Last-Modified header. HTTP truncates the header * value to seconds. */ 
 initWidget(body = new FlowPanel()); 
 Gerrit.doSignIn(parent.getToken()); return; 
 body.add(box); table.updateFileCommentVisibility(false); 
 return o instanceof Account && ((Account) o).getId().equals(getId()); 
 return o instanceof Account && ((Account) o).getId().equals(getId()); 
public abstract class CapabilityDefinition { 
<|del|> 
 checkRequiresCapability(cmd); 
 private void checkRequiresCapability(Command cmd) 
<|del|> 
<|del|> 
 public static class Viewport extends JavaScriptObject { 
 public static class Viewport extends JavaScriptObject { 
 protected Viewport() { 
 InputStream in = Version.class.getResourceAsStream("Version"); 
 void updateFileCommentVisibility(boolean forceHide) { if (forceHide) { UIObject.setVisible(patchsetNavRow, false); } 
import com.google.gerrit.common.data.GitwebConfig; import com.google.gerrit.extensions.registration.DynamicItem; 
 private List<String> downloadSchemes; 
 if (!downloadSchemes.isEmpty() && !downloadSchemes.contains("ssh")) { return ""; 
 if (!downloadSchemes.isEmpty() && !downloadSchemes.contains("http")) { return ""; 
 private static final Binder uiBinder = GWT.create(Binder.class); 
 private final int key; private final String help; private final int cmd; 
 private final PatchSet.Id patchSetId; private final KeyCommandSet keys; 
 JsArray<FileInfo> files = result.values(); FileInfo.sortFileInfoByPath(files); 
 for (int i = 0; i < files.length(); i++) { 
<|del|> 
<|del|> 
 prevLink.setHref("/#" + url); prevLink.setHTML(SafeHtml.asis(Util.C.prevPatchLinkIcon() + fileName)); 
 prevLink.setHref("/#" + url); prevLink.setHTML(SafeHtml.asis(Util.C.prevPatchLinkIcon() + fileName)); 
 nextLink.setHref("/#" + url); nextLink.setHTML(SafeHtml.asis(fileName + Util.C.nextPatchLinkIcon())); 
<|del|> 
Copyright (C) 2013 The Android Open Source Project 
 private final PatchSet.Id revision; 
public class DialectOracleSQLTest { private final static String ORACLE_DRIVER = "oracle.jdbc.driver.OracleDriver"; 
 this.keys = keys; this.patchSetId = patchSetId; this.path = path; } @Override protected void onLoad() { ChangeApi.revision(patchSetId).view("files").get( 
 JsArray<FileInfo> files = result.values(); FileInfo.sortFileInfoByPath(files); 
 anchor.setHTML(new SafeHtmlBuilder() .append(SafeHtml.asis(fileName)) .append(SafeHtml.asis(Util.C.nextPatchLinkIcon())) .toSafeHtml()); 
 anchor.setHTML(new SafeHtmlBuilder() .append(SafeHtml.asis(fileName)) .append(SafeHtml.asis(Util.C.nextPatchLinkIcon())) .toSafeHtml()); 
 @UiField Element prevLinkCell; @UiField Element nextLinkCell; @UiField Element upLinkCell; 
<|del|> 
 private void setupNav(int key, String help, FileInfo info) { 
 nextLinkCell.appendChild(new InlineHyperlink(new SafeHtmlBuilder() .append(fileName) .append(SafeHtml.asis(Util.C.nextPatchLinkIcon())), url).getElement()); 
 nextLinkCell.appendChild(new InlineHyperlink(new SafeHtmlBuilder() .append(fileName) .append(SafeHtml.asis(Util.C.nextPatchLinkIcon())), url).getElement()); 
 nextLinkCell.appendChild(new InlineHyperlink(new SafeHtmlBuilder() .append(fileName) .append(SafeHtml.asis(Util.C.nextPatchLinkIcon())), url).getElement()); 
<|del|> 
<|del|> 
 final AccountResolver accountResolver; 
 final AccountResolver accountResolver; 
 if (null == filterGroups) { 
 private static class CustomComparator implements Comparator<GroupInfo> { 
 upLink.setTargetHistoryToken(PageLinks.toChange2( patchSetId.getParentKey(), String.valueOf(patchSetId.get()))); 
<|del|> 
 * If the specified file name is relative it will resolved as a sub directory of * the site directory, if it is absolute it will be used as is. * * If the specified file doesn't exist or isn't readable the servlet will 
 private final File robotsFile; 
 db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass); 
 public SshKeysImportServlet(final AddSshKey restAddSshKey, final GetSshKeys restGetSshKeys, 
<|del|> 
<|del|> 
<|del|> 
 /** Scope of the named capability. */ CapabilityScope scope() default CapabilityScope.CONTEXT; 
 if (pluginName != null && !"gerrit".equals(pluginName) && (rc.scope() == CapabilityScope.PLUGIN || rc.scope() == CapabilityScope.CONTEXT)) { 
 boolean value() default false; 
 defaultValue = t.getDeclaredMethod("value").invoke(a); 
<|del|> 
 return i.getAccountId().equals(change.getOwner()); 
 return i.getAccountId().equals(change.getOwner()); 
 admin.setDescription("Gerrit Site Administrators"); admin.setType(AccountGroup.Type.INTERNAL); 
<|del|> 
 grid.addHeader(new SmallHeading(Util.C.headingAgreements())); 
<|del|> 
 protected int startLine; 
 protected int startCharacter; 
 } if (comment.getRange() != null && comment.getLine() != comment.getRange().getEndLine()) { throw new IllegalStateException( "Range endLine must be on the same line as the comment"); } 
 line, rsrc.getAccountId(), Url.decode(in.inReplyTo)); 
<|del|> 
<|del|> 
 int line = in.line != null ? in.line : in.range != null ? in.range.getEndLine() : 0; 
 line, rsrc.getAccountId(), Url.decode(in.inReplyTo)); 
 return push.to(git, ref); 
class StartReplicationCapability extends CapabilityDefinition { 
class StartReplicationCapability extends CapabilityDefinition { 
 static final String START_REPLICATION = "startReplication"; 
 static final String START_REPLICATION = "startReplication"; 
 bind(CapabilityDefinition.class) .annotatedWith(Exports.named(DELETE_PROJECT)) .to(DeleteProjectCapability.class); 
 Permission startReplication = capabilities.getPermission("startReplication"); 
 md.setMessage(msg); 
<|del|> 
 libraries.mysqlDriver.downloadRequired(); } else if (dci instanceof OracleInitializer) { 
 databaseSection.string("Instance name", "instance", "xe"); 
 sql = CharMatcher.is(';').trimTrailingFrom(sql); 
 private static File url2file(final String urlString) throws IOException { 
 return new File(url.toURI()); } catch (URISyntaxException e) { return new File(url.getPath()); 
 } return null; 
 return i.getAccountId().equals(change.getOwner()); 
 * If this method return {@code true} then this validator will be executed for 
 .getLogger(CommitValidators.class); 
 if (!fastPath || validator.shouldValidateAllCommits()) { 
 libraries.mysqlDriver.downloadRequired(); } else if (dci instanceof OracleInitializer) { 
 StringBuilder msg = new StringBuilder() .append("\n") .append("Can not find the %s at this location: %s\n") .append("Please provide alternative URL"); 
 StringBuilder msg = new StringBuilder() .append("\n") .append("Can not find the %s at this location: %s\n") .append("Please provide alternative URL"); 
 public final native int end_line() /*-{ return this.end_line; }-*/; 
 public final native int end_line() /*-{ return this.end_line; }-*/; 
 @UiField Button cancel; @UiField Button discard; private HandlerRegistration messageClick; private boolean isNew; private PublishedBox replyToBox; private CodeMirror cm; 
 DiffScreen parent, CodeMirror cm, DisplaySide side, 
 void addReplyBox() { getCommentManager().addDraftBox( getCm().side(), CommentInfo.createReply(comment)).setEdit(true); 
class HelloWorldServlet extends HttpServlet { 
 rsp.setCharacterEncoding("UTF-8"); 
<|del|> 
 JsonObject tail = null; if (start != 0) { tail = new JsonObject(); 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
<|del|>
 p.setProperty(VELOCITY_JAR_RESOURCE_LOADER_PATH, "jar:file:" + new File(site.plugins_dir, pluginName + ".jar").getAbsolutePath()); 
<|del|> 
<|del|> 
<|del|> 
 log.error(String.format("User:%s Controller:%s Exception:%s '%s'", getUser(), getController(), e.getClass(), e.getLocalizedMessage()), e); 
 import com.google.gerrit.extensions.annotations.PluginName; 
 switch (getIntraLineStatus()) { case OFF: case OK: toggleShowIntraline(); break; default: break; } 
 try (Repository repo = getRepository()) { // Get the patch list: 
 currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename); 
 /** * No longer used except for Velocity. Remove this method when VTL support is * removed. */ private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) { 
 initReplyButton(); 
 } 
 private static final Binder uiBinder = GWT.create(Binder.class); 
 throw new ResourceNotFoundException(); 
 .setVisible(resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) 
 ChangeGlue.fireShowChange(changeInfo, changeInfo.revision(revision)); 
 public static RestApi drafts(@Nullable String project, int id) { return call(project, id, "drafts"); 
import static com.google.gerrit.server.change.RevisionResource.REVISION_KIND; import static com.google.gerrit.server.change.RobotCommentResource.ROBOT_COMMENT_KIND; 
 if (!str.asString().isEmpty()) { 
 return $wnd.Gerrit.change_actions[id]; 
 if (NativeString.is(msg)) { NativeString str = (NativeString) msg; 
 if (NativeString.is(msg)) { NativeString str = (NativeString) msg; 
 return $wnd.Gerrit.revision_actions[id]; 
 private Provider<CurrentUser> user; 
 return String.format("%s %s!", "Hello", Objects.firstNonNull(user.get().getUserName(), "world")); 
 .setVisible(user.get() instanceof IdentifiedUser); 
@CommandMetaData(name = "print", description = "Print greeting in different languages") 
 throw new ResourceNotFoundException(e.getMessage()); 
 DynamicSet.bind(binder(), WebUiPlugin.class) .toInstance(new JavaScriptPlugin("hello.js")); 
 Window.open(url.toString(), "", ""); 
<|del|> 
 bin.setAttachmentName("patch.diff").base64(); 
 bin.setAttachmentName("patch.diff").base64(); 
 child(CHANGE_KIND, "revisions").to(Revisions.class); get(REVISION_KIND, "actions").to(GetRevisionActions.class); 
 p.append(revision.get()).append("/").append(KeyUtil.encode(fileName)); 
 private static final Binder uiBinder = GWT.create(Binder.class); 
 setTitle(PatchUtil.C.addFileCommentToolTip()); addDomHandler(new ClickHandler() { 
 setTitle(PatchUtil.C.addFileCommentToolTip()); addDomHandler(new ClickHandler() { 
 private void renderDownload(ChangeInfo info, String revision) { downloadAction = new DownloadAction( info.legacy_id(), info.project(), info.revision(revision), style, download); 
 private DownloadBox downloadBox; 
 try { if (bin.getAttachmentName() != null) { res.setHeader( "Content-Disposition", "attachment; filename=\"" + bin.getAttachmentName() + "\""); } 
 return b64.setContentType("text/plain").setCharacterEncoding(ISO_8859_1); 
 /** Get the attachment file name; null if not set. */ 
<|del|> 
 CodeMirror.addKeyMap("vim_ro", km); CodeMirror.mapVimKey("j", "gj"); CodeMirror.mapVimKey("k", "gk"); CodeMirror.mapVimKey("Down", "gj"); CodeMirror.mapVimKey("Up", "gk"); 
<|del|> 
 @RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER) 
 public Object apply(ChangeResource rsrc, Input input) throws InterruptedException, ExecutionException { 
 }; 
 @Override public int hashCode() { int h = startLine; h = h * 31 + startCharacter; h = h * 31 + endLine; h = h * 31 + endCharacter; return h; 
 List<String> files = new ChangeData(c).currentFilePaths(db, plc); List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size()); for (String file : files) { filePredicates.add(new EqualsFilePredicate(db, plc, file)); 
Copyright (C) 2013 The Android Open Source Project 
 throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'"); 
 @UiField InlineHyperlink ownerLink; 
 @UiField InlineHyperlink ownerLink; 
 @UiField InlineHyperlink ownerLink; 
 .openTh().append(Resources.C.ps()).closeTh() 
 public Object apply(ProjectResource rsrc, Input input) 
 return Response.none(); 
 private RestReviewerSuggestOracle reviewerSuggestOracle; private HintTextBox nameTxtBox; 
 if (project.getNameKey().equals(allProjectsName)) { throw new MethodNotAllowedException(); 
 throw new ResourceConflictException(e.getMessage()); 
 post(PROJECT_KIND, "delete") 
 post(PROJECT_KIND, "delete") .to(DeleteAction.class); 
<|del|> 
 throw new OrmException(e); 
 UiAction<ProjectResource> { private final String pluginName; 
 @CanonicalWebUrl Provider<String> provider) { 
 private final Provider<IdentifiedUser> identifiedUser; 
 return identifiedUser.get().newCommitterIdent( serverIdent.getWhen(), serverIdent.getTimeZone()); 
Copyright (C) 2013 The Android Open Source Project 
<|del|> 
 return null; 
 + "consider changing the plugin filename.", 
 private static final Logger log = LoggerFactory.getLogger(ListCapabilities.class); 
 log.warn(String.format( "Plugin name %s must match [A-Za-z0-9-]+ to use capabilities;" + " rename the plugin", pluginName)); continue; 
 String id = String.format("%s-%s", pluginName, entry.getKey()); output.put(id, new CapabilityInfo( id, entry.getValue().get().getDescription())); 
<|del|> 
<|del|> 
 /** Set of changes starred by this user. */ public abstract Set<Change.Id> getStarredChanges(); /** Filters selecting changes the user wants to monitor. */ public abstract Collection<AccountProjectWatch> getNotificationFilters(); 
 /** Set of changes starred by this user. */ public abstract Set<Change.Id> getStarredChanges(); /** Filters selecting changes the user wants to monitor. */ public abstract Collection<AccountProjectWatch> getNotificationFilters(); 
 public LabelType(String name, List<LabelValue> valueList) { 
 abbreviation = defaultAbbreviation(name); 
 Set<LabelType> r = Sets.newTreeSet(Ordering.natural().onResultOf( new Function<LabelType, String>() { @Override public String apply(LabelType in) { return in.getName(); } })); 
 List<String> refs = l.getRefPatterns(); 
 private final Project.NameKey project; 
 Project.NameKey project, 
<|del|> 
<|del|> 
 return (isOwner() || getRefControl().canPublishDrafts()) && isVisible(db); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public List<SuggestReviewerInfo> apply(final ChangeResource rsrc) 
 final List<SuggestReviewerInfo> reviewer = new ArrayList<SuggestReviewerInfo>(suggestedAccounts.size()); for (final AccountInfo a : suggestedAccounts) { reviewer.add(new SuggestReviewerInfo(a)); 
 } return visibilityControl; 
 final Account p = accountCache.get(e.getAccountId()).getAccount(); final AccountInfo info = new AccountInfo(p.getId()); 
 && visibilityControl.isVisibleTo(account)) { 
 && visibilityControl.isVisibleTo(account)) { 
 throws ResourceNotFoundException, AuthException, OrmException, 
 throw new AuthException("Not permitted to delete this draft patch set"); 
 ResourceNotFoundException, ResourceConflictException, OrmException, AuthException { if (!rsrc.getPatchSet().isDraft()) { throw new ResourceConflictException("Patch set is not a draft"); } 
 private void loadLabelSections(Config rc) throws IOException { 
 return canPerform(UPLOAD, (short) 1); 
 private List<String> inputFiles = new ArrayList<String>(); 
 int pos = basename.lastIndexOf('.'); 
<|del|> 
<|del|> 
 } zip.close(); } catch (java.io.IOException e) { System.err.println(e.getMessage()); 
 public static void main(String[] args) { 
<|del|> 
 new Callable<Void>() { @Override public Void call() { runPushOperation(); return null; } 
 private final PluginEvent pluginEvent; private final String pluginName; 
 || "false".equalsIgnoreCase(suggest)) { 
 List<SuggestReviewerInfo> reviewer = Lists.newArrayList(); for (AccountInfo a : suggestedAccounts) { 
 List<SuggestReviewerInfo> reviewer = Lists.newArrayList(); for (AccountInfo a : suggestedAccounts) { 
 Project p = rsrc.getControl().getProject(); for (GroupReference g : suggestAccountGroup( rsrc.getControl().getProjectControl())) { if (suggestGroupAsReviewer(p, g, visibilityControl)) { 
<|del|> 
 return new VisibilityControl() { 
 LinkedHashMap<Account.Id, AccountInfo> r = Maps.newLinkedHashMap(); for (Account p : dbProvider.get().accounts() 
 for (AccountExternalId e : dbProvider.get().accountExternalIds() 
 Account p = accountCache.get(e.getAccountId()).getAccount(); AccountInfo info = new AccountInfo(p.getId()); 
 Account p = accountCache.get(e.getAccountId()).getAccount(); AccountInfo info = new AccountInfo(p.getId()); 
 return Lists.newArrayList(r.values()); 
<|del|> 
<|del|> 
 public int compareTo(SuggestReviewerInfo o) { 
 return new GerritServer(site, i, daemon, daemonService); 
 rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE)); 
public @interface GerritConfig { String name(); 
 "GerritConfig.name must be of the format" 
import static com.google.gerrit.server.project.Util.grant; 
 initRevisionActions(info, revInfo, hasUser); 
<|del|> 
<|del|> 
 static void delete(Change.Id id, String revision) { ChangeApi.deleteRevision(id.get(), revision, cs(id)); 
 static void delete(Change.Id id) { ChangeApi.deleteChange(id.get(), mine()); 
<|del|> 
 /** * A file based Config that can merge another Config instance. */ 
 return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue); 
 bu.doRefUpdates(false).execute(); 
 for (; ; ) { 
 for (; ; ) { 
 Set<String> labelNames = 
 @Option(name = "-a", usage = "a list of attributes, in the form key or key=value pair, to set on the document") 
 int equalsIndex = attribute.indexOf('='); 
 String name = attribute.substring(0, equalsIndex); String value = attribute.substring(equalsIndex + 1, attribute.length()); 
 private void invoke(String... parameters) { 
 parser.printUsage(System.err); System.exit(1); 
<|del|>
 System.err.println(e.getMessage()); System.exit(1); 
<|del|> 
<|del|> 
 Predicate.and(new LegacyChangeIdPredicate( db, object.getId()), this), 1).read()) { 
<|del|> 
 @Option(name = "--in-ext", usage = "extension for input files") 
 f.close(); zip.closeEntry(); 
 private void renderInput(Options options, String inputFile) { 
 protected boolean skipPlugins() { 
 public void testGerritCommon() { runPrologBasedTests(); 
 public static boolean isForReview(String refName) { 
 ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() { public void onSuccess(TopMenuList result) { 
 private static void addExtensionLink(final LinkMenuBar m, final TopMenuItem item) { 
 private static void addExtensionLink(final LinkMenuBar m, final TopMenuItem item) { 
<|del|> 
<|del|> 
 Change.Status status; 
 public CheckedFuture<?, IOException> indexAsync(Collection<Change.Id> ids) { List<ListenableFuture<?>> futures = new ArrayList<>(ids.size()); for (Change.Id id : ids) { futures.add(indexAsync(id)); } return allAsList(futures); 
<|del|> 
class ListTopMenus implements RestReadView<ConfigResource> { private final DynamicSet<TopMenu> extensions; 
class ListTopMenus implements RestReadView<ConfigResource> { private final DynamicSet<TopMenu> extensions; 
class TopMenuCollection implements 
 String cannotDownloadPlugin(String scriptPath); 
 LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET)); 
 || getRefControl().canAbandon() // user can abandon a specific ref 
 * project doesn't require 'Signed-Off-By' flag in commit message. This is an 
 * If this method returns {@code true} then this validator will be executed for 
 * @return {@code false} when this listener can be skipped during initial push, 
 if (((refs == null || refs.isEmpty()) && !branchSameAsAccess) || (branchSameAsAccess && accessSectionsLabels.contains(l))) { 
 @Override public void onFailure(final Throwable caught) { remove.setEnabled(true); super.onFailure(caught); 
<|del|> 
<|del|> 
<|del|> 
 private static final String URL_FIELD = "url"; 
 private String prefix = ""; 
 URL_FIELD, prefix + outputFile, Field.Store.YES)); 
 .to(registerDatabaseHandler()); 
<|del|> 
<|del|> 
 .setLabel("Ready") 
 .setLabel("WIP") 
 new RestApi("/config/server/top-menus").get(cb); 
 public Object apply(ConfigResource resource) { 
<|del|> 
<|del|> 
 public List<AccountAttribute> currentReviewers; 
<|del|> 
 public List<AccountAttribute> currentReviewers; 
 out.print(((String) value).replaceAll("\n", "\n" + indent).trim()); out.print('\n'); 
 out.print('\n'); boolean firstElement = true; 
<|del|> 
 } q = Predicate.and(q, queryBuilder.limit(maxLimit), visibleToMe); 
 public void defaultMessage() throws GitAPIException, IOException { String changeId = createChange(); ChangeInfo c = getChangeWithMessages(changeId); 
<|del|> 
 ListMultimap<RecipientType, Account.Id> accountsToNotify = 
 ChangeMessagesUtil.SET_TOPIC); 
<|del|> 
 return Callables.returning(null); 
 * @param change change to delete. 
 * @param cd change to delete. 
 html.openSpan() 
 "Can only install files with '.jar' or '.js' extension"); 
 parent - 1, 
 throw new Failure(1, "fatal: Error reading refs: '" + projectControl.getProject().getNameKey(), e); 
 doc.add(new TextField(TITLE_FIELD, title, Field.Store.YES)); 
 BufferedReader titleReader = new BufferedReader( new InputStreamReader(new FileInputStream(file), "UTF-8")); 
 * Add currentReviewers to an existing ChangeAttribute. 
 * Add currentReviewers to an existing ChangeAttribute. 
 ALL, MY, DIFFERENCES, PROJECTS, PEOPLE, PLUGINS, DOCUMENTATION; 
 /** * Get the String for link-name of the type. * * @return The String for link-name of the type */ public String getLinkName() { return name; } /** 
 GWT.runAsync( new AsyncSplit(token) { @Override public void onSuccess() { Gerrit.display(token, select()); } 
 CommentBox(CommentGroup group, CommentRange range) { this.group = group; 
/** Base class for SideBySide and Unified */ 
 void addReplyBox() { getCommentManager().addDraftBox( getCm().side(), CommentInfo.createReply(comment)).setEdit(true); 
 if (!isEnabled() || !userProvider.get().isIdentifiedUser()) { 
 FetchInfo fetchInfo = fetch.get(scheme.getValue(scheme.getSelectedIndex())); 
 command = command.replace("@*:", "@" + Window.Location.getHostName() + ":"); 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
 private static final int BUFSIZE = 4096; 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
Copyright (C) 2013 The Android Open Source Project 
<|del|> 
 byte[] buffer = new byte[BUFSIZE]; 
 sa.labels = new ArrayList<>(); 
 filter("/Documentation/*").through(QueryDocumentationFilter.class); 
 // We must NOT call dir.close() here, as DirectoryReader.open() expects an opened directory. 
<|del|> 
<|del|> 
 name.setTargetHistoryToken(PageLinks .toAccountQuery(owner(person), status)); 
 public RefUpdateAttribute asRefUpdateAttribute(final ObjectId oldId, final ObjectId newId, final Branch.NameKey refName) { 
 private final ChangeHooks hooks; 
<|del|> 
<|del|> 
 private void assignChangeOwnerPermissions(Repository git) 
 @UiField ListBox revisionList; 
 if (holder.plugin.getApiType() == ApiType.JS) { sendJsPlugin(holder.plugin, key, req, res); 
 writeToResponse(res, scanner.getInputStream(entry)); 
<|del|> 
<|del|> 
 return getExtension(file.getName()); 
 return null; 
 protected void migrateData( ReviewDb db, UpdateUI ui) throws OrmException { Repository git; try { git = mgr.openRepository(allProjects); } catch (IOException e) { throw new OrmException(e); 
 filter("/Documentation/").through(QueryDocumentationFilter.class); 
 log.error("Cannot initialize documentation full text index", e); 
 private List<DocResult> doQuery(String q) throws DocQueryException { 
 throw new DocQueryException(e); 
 log.warn("No index available"); 
 throw new DocQueryException("Documentation search not available"); 
 DocQueryException(Throwable e) { 
 for (DocResult docResult : res) { stdout.println(String.format("%s:\n%s%s\n", docResult.title, url, docResult.url)); } 
 for (DocResult docResult : res) { stdout.println(String.format("%s:\n%s%s\n", docResult.title, url, docResult.url)); } 
 for (DocResult docResult : res) { stdout.println(String.format("%s:\n%s%s\n", docResult.title, url, docResult.url)); } 
 fileName += ".jar"; 
 fileName = active.getSrcFile().getName(); 
 public static String nameOf(File plugin) { return nameOf(plugin.getName()); 
 String pluginCanonicalWebUrl, 
 .annotatedWith(PluginCanonicalWebUrl.class) .toInstance(canonicalWebUrl); 
 PersistentCacheFactory cacheFactory) { 
 rsp.setCharacterEncoding("UTF-8"); 
<|del|> 
 if (totalPushTasksCount == 0) { 
 state.setTitle(Util.toLongString(k.state())); table.setWidget(row, ProjectsTable.C_STATE, state); 
<|del|> 
 public static final int C_STATE = 1; public static final int C_NAME = 2; public static final int C_DESCRIPTION = 3; public static final int C_REPO_BROWSER = 4; 
 String projectStateAbbrev(); 
 public Project.State state; 
 AccountGroup.UUID adminGroupUUID = findAdminGroup(db, config); createGroup(db, "Change Owner", adminGroupUUID, 
<|del|> 
 AccountGroup.Id groupId = 
 private static AccountGroup.UUID findAdminGroup( 
 table.setText(0, ProjectsTable.C_REPO_BROWSER, Util.C.projectRepoBrowser()); 
 public static final int C_STATE = 1; public static final int C_NAME = 2; public static final int C_DESCRIPTION = 3; public static final int C_REPO_BROWSER = 4; 
 sb.append(project); sb.append(" ref "); sb.append(ref); 
 statusByProjectRef = HashBasedTable.create(); 
 countingLock.lock(); try { getRefStatus(project, ref).nodesToReplicateCount++; totalPushTasksCount++; } finally { countingLock.unlock(); } 
<|del|> 
 this.user = user; this.patchSetInfoFactory = patchSetInfoFactory; 
 public Project.State state; 
 void addCloseSessionListener(SshFutureListener<CloseFuture> l) { closeFuture.addListener(l); 
<|del|> 
 private void insertDocRow(final int row) { 
 parent.insertDocRow(dataBegin + rows); 
<|del|> 
 private void display(JsArray<DocInfo> result) { 
 protected Object getRowItemKey(DocInfo item) { 
 private void populateDocRow(int row, DocInfo d) { 
Copyright (C) 2013 The Android Open Source Project 
 private GitWebConfig gitWebConfig; private String pluginCanonicalWebUrl; 
 commitUrlPattern = (commitUrlPattern.startsWith("/") ? commitUrlPattern : pluginCanonicalWebUrl + commitUrlPattern); projectPattern = (projectPattern.startsWith("/") ? projectPattern : pluginCanonicalWebUrl + projectPattern); 
 private List<PermissionRule> access(String permissionName, boolean isChangeOwner) { 
<|del|> 
<|del|> 
<|del|> 
 List<PermissionRule> rules = cfg .getAccessSection(AccessSection.GLOBAL_CAPABILITIES) .getPermission(GlobalCapability.ADMINISTRATE_SERVER) .getRules(); 
<|del|> 
 PermissionRange range = u.controlForRef("refs/heads/master") .getRange(LABEL + "Code-Review", true); 
 if (ProjectScreen.INFO.equals(panel)) { return new ProjectInfoScreen(k); } 
<|del|> 
 private int rows = 0; private int dataBeginRow = 0; 
 public GitGraphServlet(@PluginCanonicalWebUrl String url, 
<|del|> 
 displayResults(result); display(); 
<|del|> 
 private final Map<Change.Id, ReplaceRequest> replaceByChange = new HashMap<>(); 
<|del|> 
<|del|> 
Copyright (C) 2013 The Android Open Source Project 
 PluginLoader.log.error("Cannot close " + jarFile.getName(), err); 
 List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size()); 
 List<String> files = new ChangeData(c).currentFilePaths(db, plc); List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size()); for (String file : files) { filePredicates.add(new EqualsFilePredicate(db, plc, file)); 
 List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(2); predicatesForOneChange .add(not(new LegacyChangeIdPredicate(db, c.getId()))); predicatesForOneChange.add(or(filePredicates)); 
 List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(2); predicatesForOneChange .add(not(new LegacyChangeIdPredicate(db, c.getId()))); predicatesForOneChange.add(or(filePredicates)); 
 site.getAbsolutePath())); new BaseInit(site, false, true, pluginsDistribution, pluginsToInstall).run(); 
 site.getAbsolutePath())); new BaseInit(site, new ReviewDbDataSourceProvider(), false, false, pluginsDistribution, pluginsToInstall).run(); 
 && !isAccountGroupEmpty) { 
 private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException { 
public class ReplicationState { private static final Logger repLog = ReplicationQueue.repLog; 
 private static class RefReplicationStatus { 
 if (refStatus.allDone()) { completedRefStatus = statusByProjectRef.remove(project, ref); 
 if (completedRefStatus != null) { doRefPushTasksCompleted(completedRefStatus); 
 TestAccount user = accounts.create("user", "user@example.com", "User"); TestAccount admin = accounts.admin(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; 
<|del|> 
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; 
 public void assertSchemaVersion() throws OrmException { 
 private Result createChange() throws GitAPIException, IOException { 
 if (sshKey != null) { sshKey = sshKey.trim(); 
<|del|> 
 new RestApi("config").id("server").view("serviceuser", "serviceusers").id(username).post(in, 
 public CreateServiceUserMenu() { 
 @Override public void onClick(ClickEvent event) { dialogBox.center(); dialogBox.show(); usernameTxt.setFocus(true); } }, ClickEvent.getType()); 
Copyright (C) 2013 The Android Open Source Project 
 interface RelatedChangesResources extends ClientBundle { @Source("related_changes.css") RelatedChangesCss css(); } 
 private boolean showIndirectAncestors; private boolean showMergedBranches; 
<|del|> 
<|del|> 
 public void setValue(final AccountDiffPreference dp) { listenablePrefs.set(dp); display(); 
Copyright (C) 2013 The Android Open Source Project 
 return Response.none(); 
<|del|> 
<|del|> 
import com.google.gerrit.extensions.common.CommitInfo; import com.google.gerrit.extensions.common.EditInfo; 
import com.google.gerrit.extensions.common.CommitInfo; import com.google.gerrit.extensions.common.EditInfo; 
 JsonString: @com.google.gerrit.client.rpc.NativeString::TYPE, 
 if (canCreateServiceUser()) { menuEntries.add(new MenuEntry("People", Collections .singletonList(new MenuItem("Create Service User", "", "", MENU_ID)))); } 
 Lists.newArrayListWithCapacity(2); predicatesForOneChange .add(not(new LegacyChangeIdPredicate(db, c.getId()))); 
 assertEquals(expected.getId().get(), actual._number); 
 assertEquals(message, expected.getId().get(), actual._number); 
<|del|> 
 || commit.compareTo(otherCommit) < 0) { 
 return Objects.hashCode(commit, otherCommit, submitType, contentMerge); 
 .maximumWeight(37400); 
 .maximumWeight(37400); 
 .maximumWeight(37400); 
 private final Cache<ConflictKey, Boolean> conflictsCache; 
 @Named(NAME) Cache<ConflictKey, Boolean> conflictsCache) { 
<|del|> 
<|del|> 
 new ConflictKey(cache.getTestAgainst(), other, submitType, cache.getProjectState().isUseContentMerge()); Boolean conflicts = conflictsCache.getIfPresent(conflictsKey); 
 protected RevCommit createCommit(AnyObjectId id) { 
 Set<RevCommit> alreadyAccepted = Sets.newHashSet(); 
 Cache(Change change, Provider<ReviewDb> db, ProjectCache projectCache) { this.change = change; this.db = db; this.projectCache = projectCache; } ObjectId getTestAgainst() 
 Cache(Change change, Provider<ReviewDb> db, ProjectCache projectCache) { this.change = change; this.db = db; this.projectCache = projectCache; } ObjectId getTestAgainst() 
 for (Ref r : repo.getAllRefs().values()) { 
 if (r.getObjectId() != null) { alreadyAccepted.add(r.getObjectId()); } 
 context.getElement().<SelectElement>cast().getOptions(); // WHOLE_FILE_CONTEXT is the last option in the list. 
 TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), view.getPathPart(), tree); if (tw.getFileMode(0) != FileMode.TREE) { return ObjectId.zeroId(); } return tw.getObjectId(0); 
 } else { 
 private Change retrieveChange(String ref, ReviewDb db) 
 public final String project; public final String ref; public final int nodesCount; 
 if (!checkObjectsEquals(expected.project, actualRefReplicatedEvent.project)) { 
 if (!checkObjectsEquals(expected.ref, actualRefReplicatedEvent.ref)) { 
 if (!checkObjectsEquals(expected.targetNode, actualRefReplicatedEvent.targetNode)) { 
 if (!checkObjectsEquals(expected.status, actualRefReplicatedEvent.status)) { 
 if (object1 == object2) { 
 if (object1 != null && !object1.equals(object2)) { 
 private static final String USER = "user"; private static final String KEY_CREATED_BY = "createdBy"; private static final String KEY_CREATED_AT = "createdAt"; 
 private static final String USER = "user"; private static final String KEY_CREATED_BY = "createdBy"; private static final String KEY_CREATED_AT = "createdAt"; 
 private static final String USER = "user"; private static final String KEY_CREATED_BY = "createdBy"; private static final String KEY_CREATED_AT = "createdAt"; 
<|del|> 
 final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, projectCache); 
<|del|> 
 String patchScreenDisplayControls(); String reviewedPanelBottom(); 
<|del|> 
 } 
 rw.resetRetain(RevFlag.UNINTERESTING, containsTarget); 
<|del|> 
 private void parseCommits(final Collection<Ref> refs) throws IOException { if (commitToRef != null) { return; } commitToRef = LinkedListMultimap.create(); 
 commitToRef.put(commit, ref.getName()); 
 throw new UnsupportedOperationException(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public static class ConfigParameterInfo { 
<|del|> 
 throw new ResourceConflictException("Cannot update project " + projectName, err); } finally { md.close(); 
<|del|> 
 import java.util.List; import java.util.Map; 
 void delete() throws RestApiException; String description() throws RestApiException; void description(String description) throws RestApiException; 
 replyAction.onReply(msg); 
 p.setStyleName(style != null ? style.replyBox() : style2.replyBox()); 
 public ChangeInserter setHashtags(Set<String> hashtags) { this.hashtags = hashtags; 
 start(); 
 private void start() { if (active >= 2 || toLoad.isEmpty() || !isAttached()) { return; } 
 this.executor = MoreExecutors.listeningDecorator(executor); this.mergeabilityCheckQueue = mergeabilityCheckQueue; 
 this.executor = MoreExecutors.listeningDecorator(executor); this.mergeabilityCheckQueue = mergeabilityCheckQueue; 
<|del|> 
 for (int i = list.length() - 1; i >= 0; i--) { 
 public static void list(int id, String base, String revision, 
 api.addParameter("base", base); 
<|del|> 
class MergeabilityCheckQueue { private final Set<Change.Id> pending = Sets.newHashSet(); 
class MergeabilityCheckQueue { private final Set<Change.Id> pending = Sets.newHashSet(); 
 synchronized void updatingMergeabilityFlag(Change change) { pending.remove(change.getId()); 
 public static void ensureReviewedByLoadedForOpenChanges(Iterable<ChangeData> changes) throws OrmException { 
 public ChangeScreen2(Change.Id changeId, String base, String revision, boolean openReplyBox, String panel) { 
 after.addAll(tipsByCommitTime.subList(insertionPoint, tipsByCommitTime.size())); 
 IsMergeablePredicate(Provider<ReviewDb> dbProvider) { 
 return c != null && c.isMergeable(); 
 * will use {@code com.google.gerrit.common.data.GlobalCapability}. 
 * Annotation on {@code com.google.gerrit.sshd.SshCommand} or * {@code com.google.gerrit.httpd.restapi.RestApiServlet} declaring a 
 * Annotation on {@code com.google.gerrit.sshd.SshCommand} or * {@code com.google.gerrit.httpd.restapi.RestApiServlet} declaring a 
 * @param <T> type of object the predicate can evaluate in memory. 
 log.warn("Config file " + config.getFile() + "does not exist; not replicating"); 
 log.warn("Config file " + config.getFile() + "does not exist; not replicating"); 
 log.info("Config file " + config.getFile() + " is empty; not replicating"); 
 private final native void setTabSize(int t) /*-{ this.tab_size = t; }-*/; 
 private DiffPreferencesPopup current; 
 private DiffPreferencesPopup current; 
 ShowDiffPreferencesCommand( 
 showPrefsCommand.onKeyPress(null); 
 if (cmA == null && cmB == null) { 
 if (prefs.get().isExpandAllComments()) { 
<|del|> 
 int largeChangeThreshold = cfg.getInt("change", "largeChange", 500); if (n < largeChangeThreshold / 4) { 
 } else if (n < largeChangeThreshold * 2) { 
 "Unnamed repository; edit this file 'description' to name the repository."; 
@CommandMetaData(name = "update-mergeability", description = "Update mergeability flag for a specific ref") 
 @Option(name = "--project", aliases = {"-p"}, metaVar = "NAME", usage = "project") 
 @SuppressWarnings("deprecation") 
 @SuppressWarnings("deprecation") 
 refControl, parent); 
 if (jar != null) { 
 private void sendJsPlugin(Plugin plugin, ResourceKey key, 
 return true; 
 StandaloneJsPluginModule(String pluginName, String fileName) { 
 DynamicSet.bind(binder(), WebUiPlugin.class).toInstance( new JavaScriptPlugin(fileName)); 
 inserter.release(); inserter = null; 
 name = Objects.firstNonNull( Strings.emptyToNull(n), AllProjectsNameProvider.DEFAULT); 
 Schema_85(Provider<Schema_84> prior) { 
 group.setDescription(description); group.setType(AccountGroup.Type.SYSTEM); 
 return rule.getGroup().getUUID(); 
 private String pluginName; 
<|del|> 
 public static final String PLUGIN_DIR = "WEB-INF/plugins/"; public static final String JAR = ".jar"; 
<|del|> 
 String fileExtension = getExtension(fileName); 
public class GuiceLogger { 
 GerritApi gApi; 
 private final ReviewerDeleted reviewerDeleted; 
 ReviewerDeleted reviewerDeleted, 
 this.reviewerDeleted = reviewerDeleted; 
import com.google.gerrit.server.project.ChangeControl; import com.google.gerrit.server.util.LabelVote; 
<|del|> 
<|del|> 
 GreetInfo(String m, String c, String h) { 
 private String name; 
<|del|> 
<|del|> 
<|del|> 
 final OutputStream cout = cpk.open(aout, zText.length); 
<|del|> 
import com.google.common.base.Objects; 
<|del|> 
<|del|> 
 public Map<String, Map<String, ConfigParameterInfo>> pluginConfig; 
 private DisplayCommand(String revision, JsArray<ChangeAndCommit> list) { this.table = new MyTable(list); 
 } initializedFilters = cleaned; 
 RefUpdate.Result result = ru.update(rw); assertEquals(result, RefUpdate.Result.NEW); 
 ObjectId newEdit = ins.insert(builder); ins.flush(); 
 int sshPort = SshAddressesModule.DEFAULT_PORT; 
<|del|> 
 REMOVED(new FooterKey("Removed")); private final FooterKey footerKey; private ReviewerState(FooterKey footerKey) { this.footerKey = footerKey; } FooterKey getFooterKey() { return footerKey; } 
 .markdownToDocHtml(sb.toString(), "UTF-8", true); 
 }, DiffApi.MergeDiffType.FIRST_PARENT); 
 private final ObjectId prior; private final ObjectId next; 
 static class Key implements Serializable { 
 this.prior = prior.copy(); this.next = next.copy(); 
 RevCommit next = walk.parseCommit(key.nextCommit); 
 private final PatchSet.Id priorId; private final PatchSet.Id nextId; private final String strategyName; private transient ObjectId priorCommit; private transient ObjectId nextCommit; 
 log.warn(warnMsg(next.getId(), project), e); 
<|del|> 
<|del|> 
 public RawInput content; 
 private final RevisionEditCommands editCommands; 
 publishRevisionEdit(rsrc); } else { publishDraft(rsrc); 
 enum TreeOperation { CHANGE_ENTRY, DELETE_ENTRY, RESTORE_ENTRY } 
 RevWalk rw = new RevWalk(repo); RevCommit commit = edit.get(repo, rw); 
<|del|> 
 patchSetInserterFactory.create(repo, rw, changeControlFactory.controlFor(c, me), commit); inserter.setPatchSet(ps).setMessage(String .format("Patch Set %d: New edit was published", basePs.getPatchSetId())) .insert(); 
 if (cmd.getResult() != ReceiveCommand.Result.OK) { 
<|del|> 
 bind(SecureStore.class).toProvider(SecureStoreProvider.class).in( Scopes.SINGLETON); 
 SecureStore secureStore = secureStoreItem.get(); String ssl_pass = secureStore.get("http", null, "sslKeyPassword"); 
 Set<String> secureStoreNames = Sets.newTreeSet(secureStores.keySet()); 
<|del|> 
 bind(SecureStore.class).toProvider(SecureStoreProvider.class); 
 bind(SecureStore.class).toProvider(SecureStoreProvider.class); 
 return store.getString(section, null, name); 
<|del|> 
 log.warn(String.format("Plugin provides its own name: <%s>," + " use it instead of the input name: <%s>", name, originalName)); 
 for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) { for (File file : entry.getValue()) { if (file.getName().endsWith(".disabled")) { 
 .setTitle(title) .setVisible((rsrc.getPatchSet().isDraft() || rsrc.getPatchSet().isEdit()) && hasAcl(rsrc) 
 .setTitle(title) .setVisible((rsrc.getPatchSet().isDraft() || rsrc.getPatchSet().isEdit()) && hasAcl(rsrc) 
 Gerrit.display(token, select()); 
<|del|> 
 info.revisions().get(revision)._number()); 
 text.setText(info.topic()); text.setTargetHistoryToken( PageLinks.toChangeQuery( PageLinks.op("topic", info.topic()))); 
 public static void topic(int id, String topic, AsyncCallback<String> cb) { RestApi call = call(id, "topic"); 
 } LabelInfo li = labels.get(type.getName()); 
 label.values.put(v.formatValue(), v.getText()); 
 if (isOnlyZero(label.values.keySet())) { label.values = null; 
<|del|> 
 } 
 Config cfg = allProjectsConfig.load(); 
<|del|> 
 assertEquals(1, reader.read(change).size()); modifier.restoreContent(change, ps, FILE_NAME); assertEquals(1, reader.read(change).size()); publisher.publish(change, ps); assertEquals(0, reader.read(change).size()); 
<|del|> 
 private DisplaySide startSide; private int startLine; private DiffPreferences prefs; 
 private DisplaySide startSide; private int startLine; private DiffPreferences prefs; 
 return bytes.length; 
 "The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName)); 
 public final void screenRegex(String regex, Screen.EntryPoint entry) { screenRegex(regex, wrap(entry)); 
 assertTrue(content.startsWith("<html>")); 
 int sshPort = SshAddressesModule.DEFAULT_PORT; 
 sshPort = SshAddressesModule.IANA_SSH_PORT; 
 if (!ObjectId.isId(rev)) { if (!rev.startsWith(Constants.R_REFS)) { rev = Constants.R_HEADS + rev; 
 cache(PROJECT_DOC_RESOURCES, ResourceKey.class, Resource.class) .maximumWeight(2 << 20) .weigher(ResourceWeigher.class); 
 if (changeMessage != null && changeMessage.getWrittenOn() != null) { setHeader("Date", new Date(changeMessage.getWrittenOn().getTime())); } 
<|del|> 
 RobotCommentUpdate.Factory robotCommentUpdateFactory, DeleteCommentRewriter.Factory deleteCommentRewriterFactory, 
 RobotCommentUpdate.Factory robotCommentUpdateFactory, DeleteCommentRewriter.Factory deleteCommentRewriterFactory, 
 protected final String url; 
Copyright (C) 2014 The Android Open Source Project 
Copyright (C) 2014 The Android Open Source Project 
<|del|> 
 private transient Map<String, LabelType> byLabel; private transient Map<String, Integer> positions; 
<|del|> 
 IdentifiedUser.GenericFactory userFactory, AccountGroup.UUID uuid) { 
 public Factory(GitRepositoryManager repoManager, AllUsersNameProvider allUsersProvider) { this.repoManager = repoManager; this.allUsersProvider = allUsersProvider; 
<|del|> 
 * NoteDb, but any attempts to write will generate an error. 
 PatchSetApproval psa = Iterables.getOnlyElement( notes.getApprovals().get(c.currentPatchSetId())); 
 @Named(ProjectDocLoader.Module.PROJECT_DOC_RESOURCES) LoadingCache<ProjectDocResourceKey, Resource> cache) { 
 Resource rsc = resourceCache.getUnchecked( new ProjectDocResourceKey(projectName, file, revId)); 
<|del|> 
 IdentifiedUser.GenericFactory userFactory, AccountCache accountCache, 
<|del|> 
 ChangeUpdateTask(SchemaFactory<ReviewDb> schemaFactory, Change change) { this(schemaFactory, change, false); } ChangeUpdateTask(SchemaFactory<ReviewDb> schemaFactory, Change change, boolean force) { this.schemaFactory = schemaFactory; 
 Plugin.get().screen("create", new CreateServiceUserScreen.Factory()); 
Copyright (C) 2014 The Android Open Source Project 
 BufferedReader titleReader = new BufferedReader( new InputStreamReader(new FileInputStream(file), "UTF-8")); 
 lbl = lbl.substring(0, i + 1).trim(); 
 velocityContext.put("labelscore", getLabelScore()); 
 if (v.getValue() != null) { 
 DynamicSet.bind(binder(), GitReferenceUpdatedListener.class) .to(ProjectConfigEntry.UpdateChecker.class); 
 getPluginConfig(control.getProjectState(), pluginConfigEntries, cfgFactory, allProjects); 
 private List<String> pluginConfigValues; 
 String pluginName = s2[0]; String paramName = s2[1]; Map<String, ConfigValue> l = m.get(pluginName); 
 final ResultSet<Change> changes; 
 Collection<PatchSet> patchSets = cd.patches(); TreeMap<Integer, PatchSet> result = Maps.newTreeMap(); 
 PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) throws OrmException { 
<|del|> 
 ChangeInfo c = getChange(changeId); 
 ChangeInfo c = getChangeWithMessages(changeId); 
 ChangeInfo c = getChangeWithMessages(changeId); 
 Iterator<ChangeMessageInfo> it = c.messages.iterator(); 
 private RestResponse POST(String endPoint, AddIncludedGroups.Input gi) throws IOException { 
 GroupInfo group = newGson().fromJson(r.getReader(), GroupInfo.class); 
<|del|> 
 String ctx = req.getContextPath() + "src/"; 
public class ProjectDocResourceKey implements ResourceKey, Serializable { 
Copyright (C) 2014 The Android Open Source Project 
Copyright (C) 2014 The Android Open Source Project 
 log.error("Unexpected error while trying to reload " + "secure.config: keeping existing credentials", e); 
 int i = path.indexOf('/'); 
<|del|> 
<|del|> 
 options |= SUPPRESS_ALL_HTML; 
 private ExtensionMetaData(String className, String annotationValue) { this.className = className; this.annotationValue = annotationValue; 
 /*-{ return this.plugin_config || {};}-*/; 
 return !pluginConfig.isEmpty() ? pluginConfig : null; 
 if ("STRING".equals(param.type())) { w = renderTextBox(g, param, false); } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) { w = renderTextBox(g, param, true); 
 if (!ObjectId.isId(rev)) { if (!rev.startsWith(Constants.R_REFS)) { rev = Constants.R_HEADS + rev; 
<|del|> 
 RevCommit commit = rw.parseCommit(repo.resolve(rev)); if (!projectControl.canReadCommit(rw, commit)) { Resource.NOT_FOUND.send(req, res); 
<|del|> 
public class GerritDebugLauncher extends ServletContainerLauncher { private final static boolean __escape = true; 
 escape(builder, msg.substring(start)); 
 return num(a) - num(b); 
 if (!title.isEmpty()) { 
<|del|> 
 String descr() default ""; 
 private Mode(int id) { this.id = id; } public boolean get() { return this.id == 0 ? false : true; } } 
 Mode mode() default Mode.BOTH; 
<|del|> 
 return createInjectorWithDefaultSecureStore(); 
 flags.cfg.unset("gerrit", null, SECURE_STORE_CONFIG_NAME); 
 new FooterKey("Submitted-with"); 
 rp.getRevWalk().reset(); if (ctl.canCreate(db, rp.getRevWalk(), obj)) { 
<|del|> 
 * Invoked by Gerrit just before a new project is going to be created. 
 public void onProjectCreation(CreateProjectArgs args) 
 public Collection<? extends Account.Id> initialMembers; public Collection<? extends AccountGroup.UUID> initialGroups; 
 public Collection<? extends Account.Id> initialMembers; public Collection<? extends AccountGroup.UUID> initialGroups; 
 bind(Commands.key(parent, meta.name(), meta.description())).to(clazz); 
 super(pluginName, "", jarFile); 
<|del|> 
runsAt = MASTER_OR_SLAVE) 
 this.suppressHtml = cfg.getBoolean("site", "suppressHtml", true); 
 private final boolean suppressHtml; private final Policy policy; 
 private final boolean suppressHtml; private final Policy policy; 
<|del|> 
<|del|> 
<|del|> 
 * Annotation tagged on a concrete Command to describe what it is doing and * whether it can be run on slaves. 
 runsAt = MASTER_OR_SLAVE) 
<|del|> 
<|del|> 
<|del|>
<|del|>
<|del|> 
 this.accountCache = accountCache; this.changes = changes; 
 this.sendEmailExecutor = sendEmailExecutor; this.changeUpdateExector = changeUpdateExector; 
 private static final String KEY_CHECK_RECEIVED_OBJECTS = "checkReceivedObjects"; private static final String KEY_ENABLE_SIGNED_PUSH = "enableSignedPush"; private static final String KEY_REQUIRE_SIGNED_PUSH = "requireSignedPush"; 
 for (GroupReference ref : groupsByUUID.values()) { 
<|del|> 
 String configPath = System.getProperty(PROPERTY_NAME, DEFAULT_PATH); if (configPath == null && filterConfig != null) { 
<|del|> 
 public Integer _accountId; 
 public Integer _revisionNumber; 
<|del|> 
 NAMES_ALL = new ArrayList<>(); 
<|del|> 
 Map<String, LabelInfo> r = Maps.newLinkedHashMap(); 
<|del|> 
 Change.Id changeId = change.getId(); 
 protected String secureStorePath() { 
<|del|> 
 Change.Id changeId = change.getId(); 
 : "Ready For Review"); String msg = Strings.nullToEmpty(input.message).trim(); if (!msg.isEmpty()) { buf.append("\n\n"); buf.append(msg); 
 public List<ChangeInfo> formatChangeDatas(Collection<ChangeData> in) throws OrmException { 
@RequiresCapability(value = GlobalCapability.ADMINISTRATE_SERVER, scope = CapabilityScope.CORE) 
<|del|> 
 STRING, INT, LONG, BOOLEAN, LIST, ARRAY 
<|del|> 
 "Commit message cannot be null or empty"); 
 "Not allowed to create a change on %s", ref)); 
<|del|> 
 ProjectConfigEntry.Type.ARRAY, null, false, "Users or groups can be provided as reviewers")); 
 private final Provider<SecureStore> secureStorePrvider; 
 final JettyEnv env, final Provider<SecureStore> secureStorePrvider) 
 bind(SecureStore.class).toProvider(SecureStoreProvider.class).in( Scopes.SINGLETON); 
import com.google.gerrit.server.securestore.SecureStore; 
 Provider<SecureStore> secureStoreProvider) { 
<|del|> 
 final Provider<SecureStore> secureStoreProvider) throws XsrfException { 
import com.google.gerrit.server.securestore.SecureStore; 
 final Provider<SecureStore> secureStoreProvider) { 
Copyright (C) 2013 The Android Open Source Project 
<|del|> 
<|del|> 
public class MaxRepositorySizeQuota implements ReceivePackInitializer, PostReceiveHook, RepoSizeCache { 
<|del|> 
 box.setItemText(inheritedIndex, InheritableBoolean.INHERIT.name() + " (" + inheritedBoolean.inherited_value() + ")"); 
 if (isAdmin || currentUser.equals(createdBy)) { 
 if (isAdmin || currentUser.equals(createdBy)) { 
 ChangeNotes notes; 
 } throw new IllegalStateException(); 
 log.error("Giving up after " + lockRetryCount + " attempts to replicate. Failing due to: " + e.getMessage()); 
 out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null; 
 bind(ScalaPluginScriptEngine.class); 
 private CommitMergeStatus statusCode; 
 fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell()); 
<|del|> 
 PostReview( Provider<ReviewDb> db, RetryHelper retryHelper, ChangeResource.Factory changeResourceFactory, 
<|del|> 
<|del|> 
 MaxRepositorySizeQuota(QuotaFinder quotaFinder, GitRepositoryManager gitManager) { 
Copyright (C) 2014 The Android Open Source Project 
 return cd.change().getLastUpdatedOn().getTime() >= cut.getTime(); 
 int p = start - pageSize; 
 return NumericRangeQuery.newLongRange( 
 */ @Deprecated 
 /** * This method will override Gerrit configuration index.name.commitWithin * until next Gerrit restart (or reconfiguration through this method). * * @param enable auto commit */ 
 * containing the unzipped gerrit.war 
<|del|> 
 log.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage()); 
 control = src.control; patchsetId = src.patchsetId; 
 throw die("plugin failed to enable"); 
<|del|> 
 @Option(name = "--zip") private boolean zip; 
 fmt.setRepository(repo); if (path != null) { fmt.setPathFilter(PathFilter.create(path)); } 
 }; 
 final native JsArrayString getBlockedNames() /*-{ return this.blocked_names; }-*/; 
 for (String v : Natives.asList(values)) { populate(row, v); 
<|del|> 
 remoteAdmin = cfg.getBoolean("plugins", null, "allowRemoteAdmin", false); 
 Gerrit.display(token, panel== null ? (useChangeScreen2 ? new ChangeScreen2(id, null, false) 
 private String basename; 
 public ChangeScreen2(Change.Id changeId, String base, String revision, boolean openReplyBox, String panel) { 
 String.valueOf(patchSetId.get()))+",sd"); 
 @Option(name = "--format") private String format; 
 final ArchiveFormat f = formats.get(format); if (f == null) { throw new BadRequestException("unknown archive format"); 
 final ArchiveFormat f = formats.get(format); if (f == null) { throw new BadRequestException("unknown archive format"); 
 final ArchiveFormat f = formats.get(format); if (f == null) { throw new BadRequestException("unknown archive format"); 
<|del|> 
<|del|> 
 } finally { if (close) { repo.close(); } 
 + "all service user owner accounts are inactive.", 
 protected void run() { 
 stdout.println("Hello, cookbook administrator"); 
 return Strings.isNullOrEmpty(a.getFullName()) ? Response.none() : a .getFullName(); 
<|del|>
 String.valueOf(patchSetId.get())) + ",sd"); 
 private static final Map<String, ArchiveFormat> formats = ArchiveFormat.init(); private final GitRepositoryManager repoManager; 
 .setTree(commit.getTree()) 
 return String.format("%s%s", rw.getObjectReader().abbreviate(commit,7).name(), format.getDefaultSuffix()); 
 String getPatchSetUrl(final String projectName, final String commit); 
 String getLinkName(); 
 public final native String link_name() /*-{ return this.link_name; }-*/; public final native String link_url() /*-{ return this.link_url; }-*/; 
 public final native String link_name() /*-{ return this.link_name; }-*/; public final native String link_url() /*-{ return this.link_url; }-*/; 
import com.google.gerrit.extensions.webui.PatchSetWebLink; import com.google.gerrit.extensions.webui.ParentWebLink; 
 WEB_LINKS(14); 
 private final boolean isMerged; 
 private static GitRepositoryManager gitMgr; 
 IncludedInDetail detail = new IncludedInDetail(); 
<|del|> 
 cmd.append(sshAddr.substring(0, p)); 
 if (!(pc.getUser().isIdentifiedUser())) { 
 return new RefControl(currentUser, destBranch.get()).canUpload(); 
 git().push() .setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")) .call(); assertThat(gApi.changes().id(changeId).get().status) .isEqualTo(ChangeStatus.MERGED); 
 if (scriptingFactory == null) { throw new IllegalArgumentException("Script file " + srcFile.getAbsolutePath() + " is not a known scripting language for a Gerrit plugin"); 
Copyright (C) 2014 The Android Open Source Project 
 int index = e.getMessage().indexOf("at Object"); new ErrorDialog(index == -1 ? e.getMessage() : e.getMessage().substring(0, index)).center(); 
<|del|> 
 if (depSet.size() > 1) { String msg = String.format("Plugin %s cannot be loaded: " + "Multiple plugin dependencies are currently not supported", n); PluginLoader.log.error(msg); throw new ProvisionException(msg); 
 PluginLoader.log.error("Plugin dependency graph contains a cycle", e); 
 PluginLoader.log.warn(msg); continue; 
 if (d != null) { for (String parentPlugin : d.deps) { Plugin p = running.get(parentPlugin); if (p instanceof JarPlugin) { parentLoader = ((JarPlugin)p).getClassloader(); } 
 List<RevCommit> lc = new ArrayList<>(); 
 List<RevCommit> lc = new ArrayList<>(); 
 try { RevWalk rw = new RevWalk(git); try { return IncludedInResolver.resolve(git, rw, commit); } finally { rw.release(); } } finally { git.close(); } 
 detail = resolveBranches(c); branches = detail.getBranches().size() != 0 ? detail.getBranches() : null; 
 detail = resolveBranches(c); branches = detail.getBranches().size() != 0 ? detail.getBranches() : null; 
 detail = resolveBranches(c); branches = detail.getBranches().size() != 0 ? detail.getBranches() : null; 
 detail = resolveBranches(c); branches = detail.getBranches().size() != 0 ? detail.getBranches() : null; 
 @com.google.gerrit.client.api.ApiGlue::install( Lcom/google/gwt/core/client/JavaScriptObject; Lcom/google/gerrit/client/api/Plugin;) (f,p); 
 String message = "Invalid commentlink: " + (index == -1 
 String fileExtension = getExtension(fileName); PluginDescriptor descr = DependencyResolver.getDescriptor(tmp); 
 Map<String, File> activePlugins = Maps.newLinkedHashMap(); 
 Preconditions.checkState(!activePlugins.containsKey(name)); 
 DynamicSet.bind(binder(), ScriptingPlugin.Factory.class).to(JsPlugin.Factory.class); bind(ScriptingPluginFactory.class); 
 boolean handlesExtension(String scriptExtension); 
 private final DynamicSet<ScriptingPlugin.Factory> scriptingFactories; 
 this.scriptingFactories = sf; 
 if (scriptingFactory == null) { throw new IllegalArgumentException("Script file " + srcFile.getAbsolutePath() + " is not a known scripting language for a Gerrit plugin"); 
 if(scriptingFactory.handlesExtension(srcFileExtension)) { 
 PluginLoader.log.warn(String.format( 
 n = Objects.firstNonNull( PluginLoader.getGerritPluginName(f), PluginLoader.nameOf(f)); 
 "Cannot read manifest for plugin %s: %s", f, e.getMessage())); 
 ClassLoader getClassLoader() { 
 private final Set<ClassLoader> parents = Sets.newLinkedHashSet(); 
 private final Set<ClassLoader> parents = Sets.newLinkedHashSet(); 
 private final Set<ClassLoader> parents = Sets.newLinkedHashSet(); 
 final ImmutableSet<String> deps; 
 // sort plugins in topological order: child, parent for (Plugin p : topologicalSort(running.values())) { 
 // induce subgraph to reload for given subset of nodes // and sort it in reverse topological order: parent, child for (Plugin active : reverseTopologicalSortSubgraph( running.values(), reload)) { 
 Plugin p = running.get(Iterables.getOnlyElement(d.deps)); 
 if (expanded.contains(node)) { return; } throw new DAGCycleException("Graph contains a cycle.", node); 
 private static IncludedInDetail resolveBranches(RevCommit commit) throws RepositoryNotFoundException, IOException, OrmException { 
<|del|> 
 final String refsHeads = "refs/heads/"; if (branch.ref().startsWith(refsHeads)) { return branch.ref().substring(refsHeads.length()); 
 final String refsHeads = "refs/heads/"; if (branch.ref().startsWith(refsHeads)) { return branch.ref().substring(refsHeads.length()); 
 stdout.print("unknown ssh backend\n"); 
 @Override 
 Builder setArchiveFormat(@Nullable ArchiveFormat archiveFormat) { this.archiveFormat = archiveFormat; 
 case 0: result.oldRevision = Revision.NULL; 
<|del|> 
Copyright (C) 2014 The Android Open Source Project 
 return avatarUrl.toString(); 
 } 
 MILLISECONDS.convert(5, MINUTES), MILLISECONDS); } catch (IllegalArgumentException e) { commitWithinMs = cfg.getLong("index", name, "commitWithin", 0); 
 if (commitPeriod < 0) { 
 new TrackingIndexWriter(new AutoCommitWriter(dir, writerConfig.getLuceneConfig(), AutoCommitType.BUFFER_CONFIG_ONLY)); 
 || !c.branch().equals(thisBranch)) { 
 return String.format(" gitdir=$(git rev-parse --git-dir); scp -p -P %d %s@%s:hooks/commit-msg ${gitdir}/hooks/", 
 return String.format(" gitdir=$(git rev-parse --git-dir); scp -p -P %d %s@%s:hooks/commit-msg ${gitdir}/hooks/", 
@RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER, scope = CapabilityScope.CORE) @CommandMetaData(name = "auto-degrade", description = "Enable automatic degrading") 
@RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER, scope = CapabilityScope.CORE) @CommandMetaData(name = "auto-degrade", description = "Enable automatic degrading") 
@RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER, scope = CapabilityScope.CORE) @CommandMetaData(name = "degrade", description = "Enable DEGRADED mode") 
 DynamicItem.itemOf(binder(), WebSession.class); 
 final @Nullable Binding<HttpServletResponse> responseBinding = 
class MaxDb extends BaseDataSourceType { 
<|del|> 
 IdentifiedUser me = identifiedUser.get(); 
 IdentifiedUser me = identifiedUser.get(); Map<String, Ref> names = repo.getRefDatabase().getRefs( RevisionEdit.getChangeEditsRef(me, change.getId()).toString()); 
 repo = gitManager.openRepository(change.getProject()); 
 private ObjectId createCommit(IdentifiedUser me, ObjectInserter inserter, 
 private RefUpdate.Result update(Repository repo, IdentifiedUser me, 
 private ObjectId writeNewTree(Repository repo, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, byte[] content, RevCommit base) 
 private void editTree(Repository repo, RevCommit base, DirCacheEditor dce, ObjectInserter ins, String path, byte[] content) 
 private PathEdit getPathEdit(Repository repo, RevCommit base, String path, 
 base.getTree().getId()); // If the file does not exist in the edit, still allow it to be // restored from the base of the edit. 
 private static DirCache createTree(ObjectReader reader, RevCommit prevEdit) 
 public RevCommit getCommit(Repository repo, RevWalk rw) throws IOException { 
<|del|> 
 private static final long serialVersionUID = 2L; 
 ProjectsImpl(ProjectsCollection projects, ProjectApiImpl.Factory api) { 
<|del|> 
 private final static long AGE = TimeUnit.DAYS.toMillis(7); 
 rsp.setHeader("Location", url); 
 @Override protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException { toGerrit(PageLinks.toChangeQuery(query), req, rsp); } }); 
 rdr.append(urlProvider.get()); 
 public OAuthFilter(GitHubOAuthConfig config, 
 public final native JsArray<TopMenuItem> my() /*-{ return this.my; }-*/; 
 public static final String REFS_DRAFT_COMMENTS = "refs/draft-comments/"; 
 public static final String REFS_DRAFT_COMMENTS = "refs/draft-comments/"; 
<|del|> 
 formGrid.setText(row, labelIdx, Util.C.diffViewLabel()); formGrid.setWidget(row, fieldIdx, diffView); 
 private void setListBox(final ListBox f, final short defaultValue, final short currentValue) { 
<|del|> 
 @CanonicalWebUrl Provider<String> provider, PersistentCacheFactory cacheFactory) { 
 public int hashCode() { return Objects.hashCode(storeName); 
 throw new SecureStoreException(String.format( "Cannot find secure store with name %s in plugin %s", storeName, pluginName)); 
 throw new SecureStoreException(String.format( "Cannot find plugin with name: %s", pluginName)); 
 if (scriptingFactory == null) { throw new IllegalArgumentException("Script file " + srcFile.getAbsolutePath() + " is not a known scripting language for a Gerrit plugin"); 
class History extends FlowPanel { // This basically means 7 days in milliseconds and could be rewritten as // TimeUnit.DAYS.toMillis(7) // in plain Java, but unfortunately it isn't available in GWT 
class History extends FlowPanel { // This basically means 7 days in milliseconds and could be rewritten as // TimeUnit.DAYS.toMillis(7) // in plain Java, but unfortunately it isn't available in GWT 
<|del|> 
 base, commit.getId(), user.getAccount()); 
 base, commit.getId(), user.getAccount()); 
 return storeName.equals(o.storeName); 
 return false; 
 skipNum.setText(PatchUtil.M.patchSkipRegion(Integer 
 skipNum.setText(PatchUtil.M.patchSkipRegion(Integer 
import com.google.gwt.i18n.client.Constants; 
<|del|> 
<|del|> 
 req.setAttribute(REQ_ATTR_KEY, "a/" + who.getAccountId()); 
 if (!isDone()) { notDoneNrtFutures.add(this); 
 boolean result = super.cancel(mayInterruptIfRunning); if (result) { notDoneNrtFutures.remove(this); 
 public void removeIfDone() throws IOException { if (isGenAvailableNowForCurrentSearcher()) { if (!isCancelled()) { notDoneNrtFutures.remove(this); set(null); } 
 private final class NrtFuture extends AbstractFuture<Void> { 
 void removeIfDone() { 
 void removeIfDone() { 
 public String otherBranchCommit; 
<|del|> 
 if (revisionInfo.commit().otherBranchCommit().equalsIgnoreCase("different branch commit")) { boolean reply = 
 if (reply == true) { 
 String commitBranchFlag = "different branch commit"; 
import java.text.SimpleDateFormat; import java.util.Date; 
 private static final int DEFAULT_CONNECT_TIMEOUT = 0; 
 Ints.checkedCast(ConfigUtil.getTimeUnit(cfg, "sendemail", null, "connectTimeout", DEFAULT_CONNECT_TIMEOUT, TimeUnit.MILLISECONDS)); 
 private static Account myAccount; private static String defaultScreenToken; 
 if (match(event.getScreen().getToken())) { Gerrit.selectMenu(bar); 
 if (match(event.getScreen().getToken())) { Gerrit.selectMenu(bar); 
 listBranchesProvider, project, null); 
 qi.maxRepoSize = qs.getMaxRepoSize(); 
 qi.namespace.maxTotalSize = qs.getMaxTotalSize(); 
 public long repoSize; 
 defaultValue = 0; 
 private boolean isInRange(short value, List<LabelValue> values) { 
<|del|> 
 if (!canLoadInIFrame(GWT.getModuleBaseURL() + GWT.getModuleName())) { 
 var s = scripts[i].src; return s.indexOf("loadInIFrame=true") != 0; 
 var s = scripts[i].src; return s.indexOf("loadInIFrame=true") != 0; 
 var s = scripts[i].src; return s.indexOf("loadInIFrame=true") != 0; 
 if (canLoadInIFrame) { 
 if (currentUser.isIdentifiedUser()) { 
 // Allow anonymous users a chance to login. // Avoid leaking information by not distinguishing between // project not existing and no access rights. 
 // Allow anonymous users a chance to login. // Avoid leaking information by not distinguishing between // project not existing and no access rights. 
 if (currentUser.isIdentifiedUser()) { 
 // Allow anonymous users a chance to login. // Avoid leaking information by not distinguishing between // project not existing and no access rights. 
 postReviewers.ccCurrentUser(revision.getUser(), revision); 
 public static void ensureReviewedByLoadedForOpenChanges(Iterable<ChangeData> changes) throws OrmException { 
 ChangeData create(ReviewDb db, Project.NameKey project, Change.Id id); 
<|del|> 
 private final IdentifiedUser.GenericFactory userFactory; private final AccountCache accountCache; 
<|del|> 
 private boolean isInRange(short value, List<LabelValue> labelValues) { for (LabelValue lv : labelValues) { if (lv.getValue() == value) { 
<|del|> 
 assertEquals(1, cfg.getValidationErrors().size()); assertEquals("project.config: Invalid defaultValue \"-2\" " + "for label \"CustomLabel\"", Iterables.getOnlyElement(cfg.getValidationErrors()).getMessage()); 
public class NoSuchUserException extends AccountException { 
 private static class PooledCommit { final ObjectId commit; final PersonIdent author; 
 return loadRegions(gen); 
 } return false; } } 
<|del|> 
 rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue()); 
 + "for label \"CustomLabel\"", Iterables.getOnlyElement(cfg.getValidationErrors()).getMessage()); 
 + "for label \"CustomLabel\"", Iterables.getOnlyElement(cfg.getValidationErrors()).getMessage()); 
 gitUrl = "ssh://" + addr + port + "/"; 
 private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) { 
 * @param up the UploadPack instance being processed 
 * @param up the UploadPack instance being processed 
<|del|> 
 if (isJarResource(resourceClass)) { return (Enumeration<T>) jarFile.entries(); } else { return Collections.emptyEnumeration(); } 
 public PluginContentScanner getScanner() { return EMPTY_SCANNER; 
 } } else { throw new IllegalArgumentException(srcFile.getAbsolutePath() + " is not a supported Gerrit plugin format"); 
 this.sysModule = load(sysName, classLoader); this.sshModule = load(sshName, classLoader); this.httpModule = load(httpName, classLoader); 
 ServerPlugin get(File srcFile, PluginUser pluginUser, 
 @Named(WebSessionManager.CACHE_NAME) Cache<String, Val> cache, 
 if ((self != null && v == self.value()) || (self == null && v.equals(dv))) { 
 private DiffInfo info; 
 /** * A default implementation which allows source compatibility * when adding new methods to the interface. **/ 
 public class NotImplemented implements GerritApi { 
 public class NotImplementedGerritApi implements GerritApi { 
 public class NotImplementedGerritApi implements GerritApi { 
import java.util.EnumSet; 
 public void starChange(String id) throws RestApiException { 
 public AccountApi id(String id) throws RestApiException { 
 Provider<SecureStore> secureStore = Providers.of(TEST_SECURE_STORE); return new Section(flags, site, ui, secureStore, name, subsection); 
<|del|> 
 Repository git = gitManager.openRepository(project); 
 RevCommit mergeTip = rw.parseCommit(destRef.getObjectId()); ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, authorIdent, authorIdent, input.message); 
 RevCommit mergeTip = rw.parseCommit(destRef.getObjectId()); ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, authorIdent, authorIdent, input.message); 
<|del|> 
 if (!refName.startsWith(Constants.R_REFS)) { refName = Constants.R_HEADS + input.destination; 
 if (!refName.startsWith(Constants.R_REFS)) { refName = Constants.R_HEADS + input.destination; 
 throw new AuthException("Authentication required"); 
 git = gitManager.openRepository(project); 
 throw new UnprocessableEntityException("Branch " 
 Change.Id createdChangeId = createNewChange(git, rw, changeKey, project, destRef, emptyCommit, refControl); 
 CommitBuilder commit) throws IOException, 
 throw new AuthException("Authentication required"); 
 Repository repo = gitManager.openRepository(change.getProject()); 
 ObjectInserter ins, byte[] content) 
 ObjectInserter ins, byte[] content) 
 ObjectInserter ins, byte[] content) 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 return null; 
<|del|> 
 /* Revsion edit reader command */ 
 throws AuthException, IOException { 
 Repository repo = gitManager.openRepository(change.getProject()); 
<|del|> 
 RevisionEdit.getChangeEditsRefs(repo, me, change.getId()); 
/* Revision edit publisher command */ 
 private final PatchSetInserter.Factory patchSetInserterFactory; private final ChangeControl.GenericFactory changeControlFactory; 
 private final PatchSetInserter.Factory patchSetInserterFactory; private final ChangeControl.GenericFactory changeControlFactory; 
 throw new AuthException("Authentication required"); 
 throw new AuthException("Authentication required"); 
/* Revision edit deleter command */ 
 throw new AuthException("Authentication required"); 
 Repository repo = gitManager.openRepository(change.getProject()); 
Copyright (C) 2014 The Android Open Source Project 
 byte[] content) throws AuthException, IOException, 
 table.setText(0, C_LAST_UPDATE, Util.C.changeTableColumnLastUpdate()); if (useNewFeatures) { table.setText(0, C_SIZE, Util.C.changeTableColumnSize()); } 
<|del|> 
 AutoRegisterModules(String pluginName, 
 AutoRegisterModules discover() throws InvalidPluginException { 
 } } else { submitChange(changeInfo, revisionInfo); 
 private boolean otherBranchCommit(Change change, PatchSet patchSet) 
 public PluginContentScanner getContentScanner() { 
 // UploadValidationException is used by the UploadValidators to 
<|del|> 
 private void parseRewind(ReceiveCommand cmd) { 
 private ChangeType changeType; 
 removeStyleName(style.hideB()); parent.syncScroll(DisplaySide.A); // match A's viewport 
<|del|> 
 private int start; private EnumSet<ListChangesOption> options = EnumSet.noneOf(ListChangesOption.class); 
 public QueryParameter withOptions(EnumSet<ListChangesOption> options) { this.options = options; 
 log.info("Created account '" + user.getUserName() + "'"); 
import static com.google.gerrit.extensions.client.ListChangesOption.REVIEWED; import static com.google.gerrit.extensions.client.ListChangesOption.REVIEWER_UPDATES; 
 public QueryParameter withOption(ListChangesOption options) { this.options.add(options); return this; } public QueryParameter withOptions(ListChangesOption... options) { this.options.addAll(Arrays.asList(options)); return this; } 
 } 
 protected boolean legacycidInChangeTable; 
 if (Strings.isNullOrEmpty(input.branch)) { throw new BadRequestException("branch must be non-empty"); 
 if (Strings.isNullOrEmpty(input.subject)) { 
 if (!refControl.canUpload() || !refControl.canRead()) { throw new AuthException("cannot upload review"); 
 IdentifiedUser me = (IdentifiedUser)userProvider.get(); PersonIdent author = me.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone()); 
 public void getDurationReturnsDuration() throws Exception { 
 } 
 projectControl.getProjectState().getConfig() 
 commitBranchFlag = false; 
 private static final String PRETTY_PARAM = "pretty"; 
 public LogSoyData(HttpServletRequest req, GitilesView view, boolean verbose) { this.req = req; this.view = view; this.verbose = verbose; } 
<|del|> 
<|del|> 
<|del|> 
 Ref targetRef = refDb.getRef(targetBranch); RevCommit mergeBase; 
 Ref targetRef = refDb.getRef(targetBranch); RevCommit mergeBase; 
 mergeBase = rw.next(); } else { return true; 
 return false; 
 return false; 
<|del|> 
 view.diffTable.setHideEmptyPane(prefs.hideEmptyPane()); if (prefs.hideEmptyPane()) { 
 view.diffTable.setHideEmptyPane(prefs.hideEmptyPane()); if (prefs.hideEmptyPane()) { 
// limitations under the License. 
 "com/google/gerrit/client/GerritConstants.properties"; 
<|del|> 
<|del|> 
// limitations under the License. 
 Project.NameKey projectNameKey) { 
 Project.NameKey projectNameKey) { 
 private MenuItem subMenuDocumentation(String nameKey, String link) { 
 public void setProjectFocus(String projectName) { currentProject = Project.NameKey.parse(projectName); 
 public List<TopMenu.MenuEntry> apply(ConfigResource resource) { 
 RevCommit target = rw.parseCommit(targetRef.getObjectId()); RevCommit mergeBase = null; 
 String remoteHost, UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws UploadValidationException { 
 onCancel(e); 
 Map<String, Object> entry = new CommitSoyData().setRevWalk(paginator.getWalk()) .toSoyData(req, c, fs, df); 
 boolean expandAllComments) { 
<|del|> 
 IncludedInDetail detail = resolveBranches(c); 
 validator.onPreUpload(repository, project, remoteHost, up, wants, haves); 
 session.getRemoteAddressAsString())); 
 * @param project The project * @param remoteHost Remote address/hostname of the user 
 // String description() throws RestApiException; void description(String description) throws RestApiException; 
 // String description() throws RestApiException; void description(String description) throws RestApiException; 
 // String description() throws RestApiException; void description(String description) throws RestApiException; 
 GerritTopMenus(Provider<CurrentUser> cup, GerritConstantsProperties gcp, GetPreferences gp) throws IOException { 
<|del|> 
 } catch (UnknownHostException e) { // Couldn't look up the hostname; this is non-fatal 
 } catch (UnknownHostException e) { // Couldn't look up the hostname; this is non-fatal 
 } 
 motd = config.getString("gerrit", null, "motd"); 
 new RestApi("/config/server/top-menus") .addParameterTrue("all") .addParameter("p", PROJECT_MENU_VAR) .get(cb); 
 for (PatchListEntry e : list.getPatches()) { 
 getClass().getResourceAsStream(GERRIT_CONSTANTS_PROPERTIES); 
 @Singleton 
<|del|> 
 Provider<GetPreferences> gp, GerritConstantsProperties gcp) throws IOException { 
 Provider<GetPreferences> gp, GerritConstantsProperties gcp) throws IOException { 
 preferences = getPreferences.get().apply(account); 
 private final DynamicSet<TopMenu> extensions; private final Provider<GerritTopMenus> topMenusProvider; 
 List<TopMenu.MenuEntry> entries = Lists.newArrayList(); if (returnAllMenusEnabled) { entries.addAll(topMenusProvider.get().getTopMenuBar(true, currentProject)); } 
 List<TopMenu.MenuEntry> entries = Lists.newArrayList(); if (returnAllMenusEnabled) { entries.addAll(topMenusProvider.get().getTopMenuBar(true, currentProject)); } 
 public DisplayMotd(CurrentUser user, MotdConfig config) { this.user = user; this.config = config; } 
 entries[0] = newCommitMessage(cmp, repo, reader, null, b); 
<|del|> 
 public final native boolean otherBranchCommit() /*-{ return this.other_branch_commit; }-*/; 
 } } catch (IOException e) { throw new PatchSetInfoNotAvailableException(e); 
 private static final String AUTHORIZED_PREFIX = "/a" + PLUGINS_PREFIX; 
 private static final String AUTHORIZED_PREFIX = "/a" + PLUGINS_PREFIX; 
 private static boolean isAuthorizedCall(HttpServletRequest req) { 
<|del|> 
import static org.easymock.EasyMock.createNiceMock; import static org.easymock.EasyMock.expect; import static org.easymock.EasyMock.replay; import static org.junit.Assert.assertEquals; 
<|del|> 
 assertEquals(CONTEXT + "/a/plugins/" + PLUGIN_NAME + "/" + RESOURCE, 
 HookResult hookResult; 
 return hookResult; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public ChangeKind kind; 
public interface Index<T> { 
 index = sysInjector.getInstance(ChangeIndexes.class).getSearchIndex(); 
<|del|> 
 /** @return read from the database and return the results. */ 
 // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR 
 throws ValidationException; 
 try (ObjectReader reader = repo.newObjectReader(); RevWalk rw = new RevWalk(reader); DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) { // b - current commit object (not a hash commit) 
 hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n"); 
 aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY; Text bText = Text.forCommit(reader, bCommit); 
 private final ChangeIndexes indexes; 
<|del|> 
<|del|> 
<|del|> 
 this.source = index.getSource(pred, 0, limit); 
 QueryRequest query(); QueryRequest query(String query); 
 QueryRequest query(); QueryRequest query(String query); 
 } 
 ListRequest list(); 
 throws UploadValidationException; 
 try (MergeOp op = mergeOpProvider.get()) { 
import com.google.gerrit.server.query.change.ChangeQueryBuilder.ChangeOperatorFactory; import com.google.gerrit.server.validators.EmailIdValidationListener; 
 return ImmutableList.copyOf(lp.apply().values()); 
 return ImmutableList.copyOf(lp.apply().values()); 
 ChangeQueryBuilder.FIELD_ADDED, FieldType.INTEGER_RANGE, false) { 
 private final Range range; 
<|del|> 
<|del|> 
<|del|> 
 long ifModifiedSince = req.getDateHeader(HttpHeaders.IF_MODIFIED_SINCE); if (ifModifiedSince > 0 && ifModifiedSince == lastModified) { 
 avatarTracker = at; 
 this.legacycidInChangeTable = legacycidInChangeTable; } 
 update(); 
<|del|> 
 config.setAvatarSupport(avatar.get() != null); 
 return list(this); 
 private List<ProjectInfo> list(ListRequest request) throws RestApiException { 
 return plugin + "-" + name; 
import com.google.gerrit.reviewdb.client.PatchLineComment; 
 } 
 } 
 private final TimeZone serverTimeZone; 
 uploader.newCommitterIdent(TimeUtil.nowTs(), 
<|del|> 
 private static String formatAsPercent(Integer i) { 
 DiskStats diskStats(); 
@RequiresCapability(GlobalCapability.VIEW_CACHES) @Singleton 
 CacheInfo result = newGson().fromJson(r.getReader(), CacheInfo.class); 
 CacheInfo result = newGson().fromJson(r.getReader(), CacheInfo.class); 
@RequiresCapability(GlobalCapability.FLUSH_CACHES) @Singleton 
 return refreshConfig && site.gerrit_config.lastModified() > cfg.getCreationTime(); 
 for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) { cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get())); 
 suffix = "s"; 
 public static class HitRatioInfo { 
 } else if (!user.isIdentifiedUser()) { 
 } else if (!user.isIdentifiedUser()) { 
Copyright (C) 2014 The Android Open Source Project 
 return Response.ok(""); 
 private final TimeZone serverTimeZone; 
 commitToCherryPick.getAuthorIdent(), committerIdent, message); 
<|del|> 
 private final ImmutableList<String> order; 
 return ImmutableList.of(); 
 private static void enablePartialGetFields(GsonBuilder gb, ListMultimap<String, String> config) { 
 e.getProvider()), null); 
<|del|> 
<|del|> 
<|del|> 
 ActionInfo action = actions.get("submit"); submit.setTitle(action.title()); submit.setHTML(new SafeHtmlBuilder() .openDiv() .append(action.label()) .closeDiv()); 
 "(${submitSize} changes including ancestors)"; 
 ChangeControl.GenericFactory changeControlFactory, 
 ChangeSet submittedChanges = ChangeSet.create(change); try { 
 FlushCache flushCache) { 
 flushCache.apply(cacheResource, null); 
 List<CacheResource> cacheResources = new ArrayList<>(cacheNames.size()); 
 flushCache.apply(rsrc, null); 
<|del|> 
 response.sendRedirect(redirectUrl); 
 gitHubOAuthUrl = getUrl(gitHubUrl, GITHUB_OAUTH_AUTHORIZE); gitHubOAuthAccessTokenUrl = getUrl(gitHubUrl, GITHUB_OAUTH_ACCESS_TOKEN); gitHubUserUrl = getUrl(gitHubApiUrl, GITHUB_GET_USER); 
Copyright (C) 2014 The Android Open Source Project 
 this.gson = gson; this.state = generateRandomState(); 
 "%s?client_id=%s&redirect_uri=%s&state=%s%s", config.gitHubOAuthUrl, config.gitHubClientId, getURLEncoded(config.oAuthFinalRedirectUrl), 
 public String loginPhase2(HttpServletRequest request, 
class GitHubLogin { private static final Logger log = LoggerFactory.getLogger(GitHubLogin.class); 
 String redirectUrl = oauth.getTargetUrl(request); if (redirectUrl == null) { 
 return obj != null && AccessToken.class.isAssignableFrom(obj.getClass()) && Objects.equal(access_token, ((AccessToken) obj).access_token); 
 new SecureRandom().nextBytes(randomState); 
 return requestState.substring(meEnd + 1); 
 log.debug("OAuthWebFilter({})", httpRequest.getRequestURL()); 
 log.debug("OAuthWebFilter({})", httpRequest.getRequestURL()); 
<|del|> 
 HttpHost localhost = new HttpHost("localhost", 80); 
 private static final String KEY_STARTTIME = "startTime"; 
 private static long interval(Config rc, String section) { 
 private static long initialDelay(Config rc, String section, long interval) { 
 private static long initialDelay(Config rc, String section, long interval) { 
 // handled by WorkQueue.stop() already 
 flushCache.apply(cacheResource, null); 
 return new ImmutableSet.Builder<String>() .addAll(secureConfigNames) .addAll(gerritConfigNames) .build(); 
<|del|> 
 private static final String SECURE_STORE_INTERFACE = SecureStore.class.getName(); private static final Logger log = LoggerFactory.getLogger(SecureStoreProvider.class); 
class UsageDataLogger implements UsageDataPublishedListener { 
class UsageDataLogger implements UsageDataPublishedListener { 
 if (log.isInfoEnabled()) { 
<|del|> 
 public Factory(GitRepositoryManager repoManager) { this.repoManager = repoManager; 
 for (ReviewerState state : ReviewerState.values()) { for (String line : commit.getFooterLines(state.getFooterKey())) { parseReviewer(state, line); } } 
 ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals = notes.getApprovals(); 
 ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals = notes.getApprovals(); 
 assertThat(comments.entries().asList().get(0).getValue().tag) .isEqualTo(coverageTag); 
 * Implementors can block the upload operation by throwing a 
 * @throws ValidationException to block the upload and send a message 
 return new ChangeNotes(args, change).load(); 
 return state.patchSets(); 
 return state.patchSets(); 
 return create(db, project, changeId); 
 PRIOR_REVISION_I_LAST_COMMENTED_ON 
 private Injector getPluginInjector(final File jarFile) throws IOException { final String pluginName = JarPluginProvider.getJarPluginName(jarFile); 
 public static String getJarPluginName(File srcFile) throws IOException { 
 public static String getJarPluginName(File srcFile) throws IOException { 
 File tmp = asTemp(in, tempNameFor(name), extension, tmpDir); 
<|del|> 
import com.google.gerrit.reviewdb.client.Account; import com.google.gerrit.reviewdb.client.Account.Id; 
<|del|> 
<|del|> 
<|del|> 
import java.util.Objects; import javax.annotation.Nullable; 
<|del|> 
 ChangeUpdate update = updateFactory.create(c, patchSet.getCreatedOn()); 
 db.changes().beginTransaction(c.getId()); try { if (!db.changes().get(c.getId()).getStatus().isOpen()) { throw new InvalidChangeOperationException(String.format( "Change %s is closed", c.getId())); } 
 abstract String filename(); 
 String n = newTopicName.get(); return Strings.isNullOrEmpty(n) ? Response.<String> none() : Response.ok(n); 
 message = newMessage(ctx); cmUtil.addChangeMessage(ctx.getDb(), update, message); return true; 
 for (ChangeData c : cs.changes()) { ChangeControl changeControl = c.changeControl(identifiedUser); 
 log.error("Cannot finish receiving commits", e); 
 log.error("[" + submissionId + "]" + msg); 
 private final Provider<MergeOp> mergeOpProvider; private final Provider<MergeOpRepoManager> ormProvider; 
 private static String getAbbreviation(String name) { 
 if (attributes == null) { 
<|del|> 
 * @return Manifest of the plugin or null if plugin has no meta-data 
 * Return the plugin resource associated to a path 
<|del|> 
 @Nullable Class<? extends Module> httpModule) throws InvalidPluginException { 
<|del|> 
 GcConfig(@GerritServerConfig Config cfg) { 
 this(rc, section, null); 
 if (interval == MISSING_CONFIG) { log.info(MessageFormat.format( "{0} schedule parameter \"{0}.{1}\" is not configured", section, KEY_INTERVAL)); 
 Lifecycle(WorkQueue queue, final GarbageCollectionRunner gcRunner, 
 if (delay == MISSING_CONFIG && interval == MISSING_CONFIG) { gcLog.info("Ignoring missing gc schedule configuration"); } else if (delay < 0 || interval <= 0) { gcLog.warn("Ignoring invalid gc schedule configuration"); 
 GarbageCollectionRunner(GarbageCollection.Factory garbageCollectionFactory, ProjectCache projectCache) { 
 gcLog.info("Triggering gc on all repositories"); 
import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; 
<|del|> 
 if (matchExact(SETTINGS_OAUTH_TOKEN, token) && Gerrit.info().auth().isOAuth()) { return new MyOAuthTokenScreen(); } 
 "SELECT category_id, name, function_name, copy_min_score" 
 String messageShowInReviewCategoryNone(); 
 Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME); Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME); 
<|del|> 
<|del|> 
 if (name.equalsIgnoreCase(usernameHeader)) { return username; 
class GitHubLogin { private static final Logger log = LoggerFactory.getLogger(GitHubLogin.class); 
 public String user; 
 return token != null && user != null; 
 boolean login(HttpServletRequest request, HttpServletResponse response) 
 log.debug("Login " + this); 
<|del|> 
 boolean isLoginRequest(HttpServletRequest httpRequest) { 
 return user; 
 private static final String GITHUB_OAUTH_AUTHORIZE = "/login/oauth/authorize"; public static final String GITHUB_OAUTH_ACCESS_TOKEN = 
<|del|> 
 GitHubOAuthConfig(@GerritServerConfig Config config, AuthConfig authConfig) 
 private static String trimTrailingSlash(String url) { return CharMatcher.is('/').trimTrailingFrom(url); 
 private String getUrl(String baseUrl, String path) 
 return baseUrl + trimTrailingSlash(baseUrl) + "/" + CharMatcher.is('/').trimLeadingFrom(path); 
class OAuthProtocol { 
 OAuthProtocol(GitHubOAuthConfig config, 
 return state + ME_SEPARATOR; 
 public static boolean isGerritLogin(HttpServletRequest request) { return request.getRequestURI().indexOf(GitHubOAuthConfig.GERRIT_LOGIN) >= 0; 
 List<NameValuePair> nvps = new ArrayList<>(3); 
 List<NameValuePair> nvps = new ArrayList<>(3); 
 return getAccessToken(accessTokenJson); 
 .getContent(), Charsets.UTF_8), JsonElement.class); if (accessTokenJson.isJsonObject()) { 
class OAuthWebFilter implements Filter { private static final Logger log = LoggerFactory 
class OAuthWebFilter implements Filter { private static final Logger log = LoggerFactory 
 OAuthWebFilter(GitHubOAuthConfig config, 
class PooledHttpClientProvider implements Provider<HttpClient> { 
 PooledHttpClientProvider() { 
 private static Optional<String> initEmail(GHUser gitHubUser) 
import com.google.gerrit.extensions.common.DiffInfo; 
 protected Context setApiUser(TestAccount account) { 
 gApi.changes().id(r.getChangeId()).revert(); 
 gApi.changes().id(r.getChangeId()).revert(); 
 gApi.changes().id(r.getChangeId()).revert(); 
 gApi.changes().id(r.getChangeId()).revert(); 
 @FunctionalInterface private interface Rebase { void call(String id) throws RestApiException; } 
 // Add an approval whose score should be copied on trivial rebase gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend()); 
 // Second change should have 2 patch sets and an approval ChangeInfo c2 = gApi.changes().id(changeId).get(CURRENT_REVISION, DETAILED_LABELS); 
 private boolean diffChange; private String panel; 
 loadCommit(rev, group); RevisionInfoCache.add(changeId, base); 
 uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost()); 
 up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true)); 
 up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks)); 
<|del|> 
 this.getDiff = getDiff; 
 private PrologMachineCopy consultRules(String name, Reader rules) throws CompileException { 
 ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserAccount().getGeneralPreferences() .getReviewCategoryStrategy(); 
<|del|> 
 stmt.executeUpdate("UPDATE ACCOUNTS SET " + "REVIEW_CATEGORY_STRATEGY='NAME' " + "WHERE (SHOW_USER_IN_REVIEW='Y')"); 
 if (!Gerrit.isSignedIn() || (!Gerrit.getUserAccount().getGeneralPreferences() .isLegacycidInChangeTable())) { 
 if (!Gerrit.isSignedIn() || (!Gerrit.getUserAccount().getGeneralPreferences() .isLegacycidInChangeTable())) { 
 boolean displayInfo = Gerrit.isSignedIn() && Gerrit.getUserAccount() .getGeneralPreferences().isShowInfoInReviewCategory(); 
 user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, 
<|del|> 
 } else if(titleWidget != null) { 
 OPTIONS.addAll(options); addOptions(call, OPTIONS); 
 label.rejected()); 
 Lifecycle(WorkQueue queue, GarbageCollectionRunner gcRunner, 
<|del|> 
 private static final DateTime NOW = DateTime.parse("2014-06-13T10:00:00-00:00"); 
 private static final DateTime NOW = DateTime.parse("2014-06-13T10:00:00-00:00"); 
 private static Config readConfig(String dat) 
 private static final int MAX_CONN_PER_ROUTE = 512; 
 return HttpClientBuilder .create() .setMaxConnPerRoute(MAX_CONN_PER_ROUTE) .setMaxConnTotal(MAX_TOTAL_CONN) .build(); 
 private final List<Data> data; 
 private final List<Data> data; 
 Provider<GetDiff> getDiff, 
 return new String(os.toByteArray(), StandardCharsets.UTF_8); 
 public static PermissionRule allow(ProjectConfig project, 
 public static PermissionRule allow(ProjectConfig project, 
 private FlushCache flushCache; 
 return s != null ? ReviewCategoryStrategy.valueOf(s) : ReviewCategoryStrategy.NONE; 
 ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.isSignedIn() ? Gerrit.getUserAccount().getGeneralPreferences() .getReviewCategoryStrategy() : ReviewCategoryStrategy.NONE; 
 ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.isSignedIn() ? Gerrit.getUserAccount().getGeneralPreferences() .getReviewCategoryStrategy() : ReviewCategoryStrategy.NONE; 
 .setCharacterEncoding(UTF_8.name()); 
<|del|> 
 private PostCaches postCaches; 
 } }; 
<|del|> 
 log.warn("Error creating RepoSizeEvent", e); 
 private static class RepoSizeEvent implements Event { 
 private void addData(final long value, final String projectName) { 
 } }; data.add(dataRow); 
 } }; data.add(dataRow); 
 PublisherScheduler(WorkQueue workQueue, Publisher publisher, PluginConfigFactory cfg) { 
 period = cfg.getFromGerritConfig("quota").getInt("publicationInterval", 0); 
 period = cfg.getFromGerritConfig("quota").getInt("publicationInterval", 0); 
 if (encodedToken.startsWith("/")) { encodedToken = encodedToken.substring(1); } token = Url.decode(encodedToken); 
<|del|> 
<|del|> 
 @Singleton 
 Project.NameKey project = MaxRepositorySizeQuota.projectName(up.getRepository(), basePath); 
 Project.NameKey project = MaxRepositorySizeQuota.projectName(rp.getRepository(), basePath); 
<|del|> 
 entryTitle = rsrc.substring(nameOffset).replace('-', ' '); 
 boolean isUnchanged(long lastModified) { 
 protected String username; 
 /** @return the username of the account holder */ public String getUsername() { return username; 
 * Formats an account as a name and an email address. 
 public String getUsername() { 
// limitations under the License. 
 * Provider of one Server plugin from one external file 
 UniversalServerPluginProvider(DynamicSet<ServerPluginProvider> sf) { 
 return providerMatch; 
// limitations under the License. 
@RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER) 
 if (showJVM && summary.jvmSummary != null) { 
class FetchAndPushCounter implements PostReceiveHook, PreUploadHook { 
 ProjectNameResolver projectNameResolver) { 
<|del|> 
 Project.NameKey project) { try { cache.get(project).incrementAndGet(); } catch (ExecutionException e) { log.warn("Couldn't increment usage counter for project " + project.get(), e); } 
 private static class Loader extends CacheLoader<Project.NameKey, AtomicLong> { 
 private static void incrementCount(LoadingCache<Project.NameKey, AtomicLong> cache, 
 persist(PUSH_COUNT_CACHE, Project.NameKey.class, AtomicLong.class) .expireAfterWrite(Integer.MAX_VALUE, TimeUnit.DAYS); persist(FETCH_COUNT_CACHE, Project.NameKey.class, AtomicLong.class) .expireAfterWrite(Integer.MAX_VALUE, TimeUnit.DAYS); 
 * @throws InvalidPluginException if plugin is supposed to be handled * but cannot be loaded for any other reason 
 throw new MultipleProvidersForPluginException(srcFile, providerHandlers); 
<|del|> 
<|del|> 
 log.warn("Error creating RepoSizeEvent", e); 
 private static class Loader extends CacheLoader<Project.NameKey, AtomicLong> { 
 * returns true and thus srcFile is a supported plugin format. 
 private static final Logger log = LoggerFactory.getLogger(UniversalServerPluginProvider.class); 
 private ServerPluginProvider providerOf(File srcFile) { 
<|del|> 
 return providerMatch; 
 return providerMatch; 
<|del|> 
 private static final long serialVersionUID = 1L; 
 + providersListToString(providersHandlers)); 
 if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) { log.warn("File is not a JAR nor JS plugin and " + "no Plugin provider was found that handles it: {}", fileName); 
 if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) { log.warn("File is not a JAR nor JS plugin and " + "no Plugin provider was found that handles it: {}", fileName); 
 name = newPlugin.getName(); // Pluggable plugin provider may have assigned // a plugin name that could be actually // different from the initial // one assigned during scan. It is safer then // to reassign it. 
 return loadExternalPlugin(srcPlugin, snapshot); 
 // The Key in returned multimap is the plugin name initially assigned from its filename. // Values are the files. Plugins can optionally provide their name in MANIFEST file. 
<|del|> 
 Iterable<ServerPluginProvider> providers = 
<|del|> 
<|del|> 
// limitations under the License. 
 try (JarFile jarFile = new JarFile(srcFile)) { 
<|del|> 
 static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException { 
Copyright (C) 2014 The Android Open Source Project 
 log.info(String.format("%s - %d %s", data.getProjectName(), data.getValue(), unitSymbol)); 
<|del|> 
 super( cfg, migration, noteUtil, serverIdent, anonymousCowardName, null, change, accountId, realAccountId, authorIdent, when); 
 checkArgument(!this.submitRecords.isEmpty(), "no submit records specified at submit time"); 
Copyright (C) 2014 The Android Open Source Project 
/** * Utility functions to parse PatchLineComments out of a note byte array and * store a list of PatchLineComments in the form of a note (in a byte array). **/ 
 public String formatTime(PersonIdent ident, Timestamp t) { 
 GitDateFormatter dateFormatter = new GitDateFormatter(Format.DEFAULT); // TODO(dborowitz): Use a ThreadLocal or use Joda. 
 OutputStreamWriter writer = new OutputStreamWriter(buf, UTF_8); PatchLineComment first = comments.get(0); 
 assertThat(newNotes(c).getChange().getDest()).isEqualTo( new Branch.NameKey(project, otherBranch)); 
 assertThat(newNotes(c).getChange().getDest()).isEqualTo( new Branch.NameKey(project, otherBranch)); 
 assertThat(newNotes(c).getChange().getOwner()).isEqualTo( changeOwner.getAccountId()); 
 c.setCurrentPatchSet(c.currentPatchSetId(), tabSubj, c.getOriginalSubject()); 
 private static final org.slf4j.Logger log = LoggerFactory .getLogger(SystemLog.class); 
 public static final String LOG_NAME = "gc_log"; private static final Logger gcLog = LoggerFactory.getLogger(LOG_NAME); 
 return change.isMergeable() != info.mergeable; 
 writer.write(':'); 
 String uuid = parseStringField(note, curr, changeId, enc, UUID); curr = RawParseUtils.nextLF(note, curr); 
 assertTrue(Ordering.natural().isOrdered(result)); 
<|del|> 
 MultipleProvidersForPluginException(File pluginSrcFile, Iterable<ServerPluginProvider> providersHandlers) { 
 /* * Pluggable plugin provider may have assigned a plugin name that could be * actually different from the initial one assigned during scan. It is * safer then to reassign it. */ name = newPlugin.getName(); 
<|del|> 
 log.warn("No Plugin provider was found that handles this file format: {}", fileName); 
 UniversalServerPluginProvider(DynamicSet<ServerPluginProvider> sf) { 
 @Override public boolean handles(File srcFile) { 
 /* * Pluggable plugin provider may have assigned a plugin name that could be * actually different from the initial one assigned during scan. It is * safer then to reassign it. */ name = newPlugin.getName(); 
 PluginDescription pluginDescription) throws InvalidPluginException; 
 return providers.get(0); 
 Class<?> clazz = Class.forName(name, false, pluginLoader); 
<|del|> 
 throw new RestApiException("Cannot retrieve draft", e); 
 builder.append("key=").append(key).append(','); 
 checkArgument(psId != null, "setPatchSetId must be called before putComment"); checkArgument(getCommentPsId(comment).equals(psId), "Comment on %s doesn't match previous patch set %s", getCommentPsId(comment), psId); 
<|del|> 
 Collections.sort(commentsForThisPS, ChangeNotes.PatchLineCommentComparator); byte[] note = commentsUtil.buildNote(commentsForThisPS); ObjectId noteId = inserter.insert(Constants.OBJ_BLOB, note, 0, note.length); 
<|del|> 
 String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Charset enc) throws ConfigInvalidException { Change.Id changeId = psId.getParentKey(); 
 if (newFile) { 
<|del|> 
 String parentUUID = null; 
 return RawParseUtils.decode(enc, note, startOfField, endOfLine - 1); 
 * @return a comment range. If the comment range line in the note only has 
 int startLine = RawParseUtils.parseBase10(note, ptr.value, ptr); 
 Change.Id changeId, Charset enc, String fieldName) 
 RawParseUtils.parseBase10(note, startOfPsId, i); 
 throw new ConfigInvalidException("could not parse comment timestamp", e); 
 private static <T> T checkResult(T o, String fieldName, Change.Id changeId) throws ConfigInvalidException { 
 private static int checkResult(int i, String fieldName, Change.Id changeId) 
 correct &= (note[curr + fieldName.length()] == ':'); correct &= (note[curr + fieldName.length() + 1] == ' '); 
 public static String formatTime(PersonIdent ident, Timestamp t) { 
<|del|> 
 * A list of the comments to be written to the returned note * byte array. 
 * A list of the comments to be written to the returned note * byte array. 
 return buf.toByteArray(); 
<|del|> 
 for (CustomIconInfo icon : customIcon.getIcons(project)) { 
 return new CustomIcons(projectIcons); 
 return "(" + type.getLinkName() + ")"; 
<|del|> 
<|del|> 
 CustomIconInfo icon1 = new CustomIconInfo("my icon", "plugins/cookbook/static/myicon.png"); CustomIconInfo icon2 = new CustomIconInfo("my 2nd icon", "plugins/cookbook/static/myicon2.png"); 
 CustomIconInfo icon1 = new CustomIconInfo("my icon", "plugins/cookbook/static/myicon.png"); CustomIconInfo icon2 = new CustomIconInfo("my 2nd icon", "plugins/cookbook/static/myicon2.png"); 
class HelloCustomIcon implements ProjectCustomIcon { 
 case 1: case 23000: 
 boolean ok = list ? list() : reindex(); return ok ? 0 : 1; 
 index.string("Elasticsearch Index Hostname", "hostname", "localhost"); index.string("Elasticsearch Index Port", "port", "9300"); 
<|del|> 
<|del|> 
 @Option(name = "--json", aliases = "-j", usage = "read review input json from stdin") 
<|del|> 
Copyright (C) 2014 The Android Open Source Project 
@CommandMetaData(name = "verify", description = "Verify one or more patch sets") 
 usage = "list of commits or patch sets to verify") void addPatchSetId(String token) { 
 public final static String TIMESTAMP_FORMAT = "yyyyMMdd_HHmm"; 
 public final static String TIMESTAMP_FORMAT = "yyyyMMdd_HHmm"; 
 public TimestampHandler(@Assisted CmdLineParser parser, @Assisted OptionDef option, @Assisted Setter<Timestamp> setter) { 
 timestamp, TIMESTAMP_FORMAT), e); 
 if (from == null && to == null) { entries = limit > 0 ? r.getReverseEntries(limit) : r.getReverseEntries(); 
 @Option(name = "--verification", aliases = "-v", usage = "verification to set the result for", metaVar = "VERIFY=OUTCOME") 
 case 1: // ORA-00001: unique constraint violated 
 plcUtil.addPublishedComments(db, update, commentsByOwner); 
 throws OrmException { 
 httpGen.dynamicSetBind(WebUiPlugin.class, new JavaScriptPlugin( 
 /** * Allows dynamically bind something in Guice module. * * Currently it is used for auto registering {@link DynamicSet} elements during * jar plugin scan */ 
 result.put(annotation, value); 
 result.put(annotation, value); 
 public <T> void dynamicSetBind(final Class<T> setOf, final T instance) { 
Copyright (C) 2014 The Android Open Source Project 
 Task<?> task = workQueue.getTask((int) Long.parseLong(id, 16)); deleteTask.apply(new TaskResource(task), null); } catch (NumberFormatException e) { 
<|del|> 
 GitilesAccess access = getAccess(req); RepositoryDescription desc = access.getRepositoryDescription(); renderJson(req, res, desc, desc.getClass()); 
 GitilesAccess access = getAccess(req); RepositoryDescription desc = access.getRepositoryDescription(); renderJson(req, res, desc, desc.getClass()); 
 Entry<String,File> entry = it.next(); sortedPlugins.add( new AbstractMap.SimpleImmutableEntry<String, File>( entry.getKey(), entry.getValue())); 
 dirty |= insertComments(ctx); dirty |= insertRobotComments(ctx); 
 NotesMigration migration = injector.getInstance(NotesMigration.class); 
 PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class); 
<|del|> 
 cfg.unset(MY, section, key); 
 if (javascript != null) { 
 renderJson(req, res, jsonRefs, new TypeToken<Map<String, RefJsonData>>() {}.getType()); 
 public String value; public String peeled; 
 public String value; public String peeled; 
 Map<String, RefJsonData> jsonRefs = new LinkedHashMap<String, RefJsonData>(); 
 private static class RefJsonData { public RefJsonData(Ref ref) { 
 renderJson(req, res, desc, new TypeToken<RepositoryDescription>() {}.getType()); 
 ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet(); 
 throws OrmException { 
<|del|> 
 index.string("Elasticsearch Index Hostname", "hostname", "localhost"); index.string("Elasticsearch Index Port", "port", "9300"); 
<|del|> 
 public void testThrowsOrmDuplicateKeyExceptionWhenTryingToInsertDuplicates() 
 public void testThrowsOrmDuplicateKeyExceptionWhenTryingToInsertDuplicates() 
 public void itThrowsOrmExceptionForOtherErrors() throws Exception { 
 writeError("invalid review input\n"); 
 throw error("json and message are mutually exclusive"); 
 throw error("json and project are mutually exclusive"); 
 writeError("error: Invalid contents in request\n"); } catch (AuthException | UnloggedFailure e) { 
 writeError("error: Invalid contents in request\n"); } catch (AuthException | UnloggedFailure e) { 
Copyright (C) 2012 The Android Open Source Project 
 @Column(id = 5, notNull = false, length = 255) protected String verifier; @Column(id = 6, notNull = false, length = 255) protected String comment; 
 c.setValue(ent.getValue().value); c.setGranted(timestamp); c.setUrl(ent.getValue().url); c.setVerifier(ent.getValue().verifier); c.setComment(ent.getValue().comment); ups.add(c); 
 String messageEnableEmailNotifications(); 
 SetPreferences(MetaDataUpdate.User metaDataUpdateFactory, AllUsersName allUsersName) { 
 + "EMAILING_OPTIONS_STRATEGY='CC_ME_ON_COMMENTS_I_WRITE' " 
 private Set<String> findReviewers( List<ReviewerFilterSection> sections, final ReviewDb reviewDb, 
 ChangeData changeData = changeDataFactory.create(reviewDb, change); 
 if (input != null) { applyReview(patchSet, input); 
 input = reviewFromJson(); 
 input = reviewFromJson(); 
<|del|> 
 protected abstract Project.NameKey getProjectName(); 
 this.change = new Change(change); 
 * which is not necessarily the same as the change's project. 
 checkArgument( old.equals(changeId), 
 old, changeId); 
<|del|> 
 stmt.executeUpdate("UPDATE ACCOUNTS SET " + "EMAILING_OPTIONS_STRATEGY='ENABLE_EMAIL_NOTIFICATIONS' " + "WHERE (COPY_SELF_ON_EMAIL='N')"); stmt.executeUpdate("UPDATE ACCOUNTS SET " 
 throw new CommitValidationException("failed to check for required footers", e); 
 } client.admin().indices() .prepareCreate(INDEX_NAME) .setSettings(settings) .execute() .actionGet(); 
 public void dispatchAddGroupMembers(Account.Id actor, Collection<AccountGroupMember> added) { 
 } catch (IOException e) { 
 } catch (IOException e) { 
 void onAddMembers(Account.Id actor, Collection<AccountGroupMember> added) throws IOException; 
 void onAddMembers(Account.Id actor, Collection<AccountGroupMember> added) throws IOException; 
 throws IOException { List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList(); for (AccountGroupMember m : toBeAdded) { AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs()); 
 throws IOException { List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList(); for (AccountGroupMember m : toBeAdded) { AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs()); 
 throws IOException { List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList(); for (AccountGroupMember m : toBeAdded) { AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs()); 
 public void onDeleteMembers(Id me, Collection<AccountGroupMember> toBeRemoved) throws IOException { 
<|del|> 
 r = GET("/projects/?r=.*"); 
 token = '#' + PageLinks.MINE; } else { token = Url.decode(token.substring(1)); 
 token = '#' + PageLinks.MINE; } else { token = Url.decode(token.substring(1)); 
class DbGroupMemberAuditListener implements GroupMemberAuditListener { 
 for (AccountGroupMember m : toBeRemoved) { 
 token = CharMatcher.is('/').trimLeadingFrom(Url.decode(encodedToken)); 
 public Iterable<CustomIconInfo> getProjectIcons(String project) { List<CustomIconInfo> icons = Lists.newArrayList(); 
 String messageEnabled(); 
<|del|> 
 for (File dir : allDirsCreated) { 
 for (File dir : allDirsCreated) { 
 for (File dir : allDirsCreated) { 
 myAccount = null; 
 return CharMatcher.is('/').trimLeadingFrom(Url.decode(encodedToken)); 
 cancel += LoginUrlToken.getToken(req); 
 dest.append(LoginUrlToken.getToken(req)); 
 cancel += LoginUrlToken.getToken(req); 
<|del|>
 AccountState state = accountCache.getByUsername(ident); 
 "The author for the following comment does not match the author of " 
 checkArgument(old != null, "Cannot delete following draft because one " 
 AtomicBoolean removedAllComments = new AtomicBoolean(); ObjectId treeId = storeCommentsInNotes(removedAllComments); 
 msg.append("Comment on patch set ").append(psId.get()); 
 msg.append("Comment on patch set ").append(psId.get()); 
 private GerritServer(Injector testInjector, Daemon daemon, ExecutorService daemonService) throws IOException, ConfigInvalidException { 
<|del|> 
 File tmp = File.createTempFile("gerrit_test_", "").getCanonicalFile(); 
 void onAddAccountsToGroup(Account.Id actor, Collection<AccountGroupMember> added) 
 github.passwordForKey("GitHub Client Secret", "clientSecret"); 
 return builder.build(); 
 case OAUTH_GITHUB: 
 case OAUTH_GITHUB: 
 public String passwordForKey(String descr, String password) { 
 // If the password is already stored, try to reuse it 
 if (ui.isBatch() || !ui.yesno(false, "Change %s", key)) { 
 proxyUrl = new URL(config.getString("http", null, "proxy")); if (proxyUrl != null) { 
/** Indicates that the commit is already contained in destination banch. */ 
 stmt.executeUpdate("UPDATE accounts SET " 
 if (revision != null) { ru.setExpectedOldObjectId(revision); } 
 if (revision != null) { ru.setExpectedOldObjectId(revision); } 
 throw new IOException("Cannot delete " + ru.getName() + " in " 
 (c.getSide() == (short) 0) ? draftNotes.getDraftBaseComments() : 
 hasComments = true; ObjectId dataBlob = ins.insert(OBJ_BLOB, data); rnm.noteMap.set(id, dataBlob); 
<|del|> 
<|del|> 
 Schema_99(Provider<Schema_98> prior) { 
 return ghLogin.getHub().getOrganization(organisation) .getRepository(repoName); 
 public Response<EmailInfo> apply(IdentifiedUser user, Input input) 
 void onAddAccountsToGroup(Account.Id actor, Collection<AccountGroupMember> added) throws IOException; 
 for (Iterator<Address> j = smtpRcptTo.iterator(); j.hasNext();) { if (j.next().email.equals(fromEmail)) { j.remove(); 
<|del|> 
 CommentsInNotesUtil commentsUtil, @Assisted ChangeControl ctl) throws OrmException { this(serverIdent, repoManager, migration, updateFactory, draftNotesFactory, allUsers, commentsUtil, ctl, serverIdent.getWhen()); 
<|del|> 
 CommentsInNotesUtil commentsUtil, @Assisted ChangeControl ctl, @Assisted Date when) throws OrmException { 
 c.getSide() == (short) 0 ? draftNotes.getDraftBaseComments() : draftNotes.getDraftPsComments(); 
 "setPatchSetId must be called first"); 
 "The author for the following comment does not match the author of" + " this ChangeDraftUpdate (%s): %s", accountId, comment); 
<|del|> 
 + "requires the Generate HTTP Password permission"); 
 + "requires the Generate HTTP Password permision"); 
 throw new RuntimeException(e); 
 String diff = diff(oldFile, newFile); audit("about to change config file", oldFile.getPath(), diff); 
 "A comment already exists with the same key," + " so the following comment cannot be inserted: %s", c); 
 checkArgument(draftNotes.containsComment(c), "Cannot delete this comment" + " because it didn't previously exist as a draft"); 
<|del|> 
 List<PatchLineComment> list = (c.getSide() == (short) 0) ? getBaseComments().get(psId) : getPatchSetComments().get(psId); 
 private final ChangeDraftUpdate.Factory draftUpdateFactory; 
 Provider<AllUsersName> allUsers, ChangeDraftUpdate.Factory draftUpdateFactory, 
 Provider<AllUsersName> allUsers, ChangeDraftUpdate.Factory draftUpdateFactory, 
 Provider<AllUsersName> allUsers, ChangeDraftUpdate.Factory draftUpdateFactory, 
 "A comment already exists with the same key as the following comment," + " so we cannot insert this comment: %s", c); 
 draftUpdate = draftUpdateFactory.create(ctl, when); 
 "Cannot add a draft comment to a ChangeUpdate. Use a ChangeDraftUpdate" + " for draft comments"); 
 AllUsersName allUsers, 
 this.draftsProject = allUsers; 
 String reviewerId = reviewerSuggestOracle.getSelectedReviewerId(); if (reviewerId != null && !reviewerId.isEmpty()) { addReviewer(reviewerId, false); 
 String reviewerId = reviewerSuggestOracle.getSelectedReviewerId(); if (reviewerId != null && !reviewerId.isEmpty()) { addReviewer(reviewerId, false); 
 if (!isAdmin) { 
 if (!isAdmin) { 
 String[] parts = name.split("/"); int n = parts.length; 
 int id = Integer.parseInt(parts[1].replaceAll("[^0-9]","")); 
 NoSuchEntityException { if (psId instanceof PatchSet.CommonAncestorId || psId.get() == 0) { return new CommonAncestorObjectId(); } 
 for (PatchLineComment c : byChange(db, notes)) { 
 private Set<String> getRefNamesAllUsers(String prefix) throws OrmException { 
 return false; 
 if (!args.plcUtil .draftByChangeAuthor(args.db.get(), object.notes(), accountId) .isEmpty()) { return true; 
 cfg.setBoolean("notedb", "publishedComments", "read", true); cfg.setBoolean("notedb", "draftComments", "read", true); 
 return !args.plcUtil .draftByChangeAuthor(args.db.get(), object.notes(), accountId) .isEmpty(); 
 Preconditions.checkNotNull(change); return String.format("%s/edit-%d", RefNames.refsUsers(user.getAccountId()), change.getId().get()); 
 Collection<AccountGroupMember> added); 
import com.google.gerrit.reviewdb.client.Account; 
 logOrmExceptionForAccounts( "Cannot log add accounts to group event performed by user", me, added, e); 
 logOrmExceptionForAccounts( "Cannot log delete accounts from group event performed by user", me, removed, e); 
 if (refFlags.isEmpty() && mask.isEmpty()) { 
 return true; } 
 .toProvider(Providers.<IdentifiedUser> of(null)); 
 checkNotNull(user); checkNotNull(change); checkNotNull(ref); 
 public static String editRefName(Account.Id accountId, 
<|del|> 
 * per user and change. 
 IdentifiedUser identifiedUser = (IdentifiedUser) user.get(); 
<|del|> 
 editUtil.delete(edit.get()); edit = editUtil.byChange(change); assertFalse(edit.isPresent()); 
 Optional<RevisionEdit> edit = editUtil.byChange(rsrc.getChange()); if (edit.isPresent()) { RevisionEdit src = edit.get(); res.put(src.getRevision().get(), toRevisionInfo(rsrc, src)); 
 for (PatchLineComment c : draftByChange(db, notes)) { if (key.equals(c.getKey())) { return Optional.of(c); } } return Optional.absent(); 
 updateFactory.create(getProjectName(), getUser(), bru); 
 * @return revision edits wrapped inside Optional when edit for this * change exists or absent otherwise 
 public Optional<RevisionEdit> byChange(Change change) 
<|del|> 
 IdentifiedUser me = (IdentifiedUser) currentUser.get(); 
 if (repo.getRefDatabase().getRef(refName) != null) { 
 IdentifiedUser me = (IdentifiedUser) currentUser.get(); 
<|del|> 
 if (reply == true) { 
 public PatchLineCommentsUtil(GitRepositoryManager repoManager, AllUsersNameProvider allUsersProvider, 
 parent = plcUtil.get(args.db.get(), changeData.notes(), key); 
 batch = update.openUpdate(); 
 * Retrieve edits for a change and user. Max. one change edit can * exist per user and change. 
import java.io.IOException; 
 Iterable<String> filtered = getDraftRefs(notes.getChangeId()); 
 if (c.getRevId() != null) { return; } PatchList patchList; 
 setCommentRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet()); 
 private final static byte[] CONTENT_OLD = "bar".getBytes(UTF_8); private final static byte[] CONTENT_NEW = "baz".getBytes(UTF_8); private final static byte[] CONTENT_NEW2 = "qux".getBytes(UTF_8); 
<|del|> 
 CONTENT_NEW)); 
 edit = editUtil.byChange(change); assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME))); 
 public void amendExistingFile() throws Exception { 
 CONTENT_NEW2)); 
 public void addNewFileAndAmend() throws Exception { 
 @Test 
 try { modifier.modifyFile( editUtil.byChange(change).get(), FILE_NAME, CONTENT_OLD); fail(); } catch (InvalidChangeOperationException e) { assertEquals("no changes were made", e.getMessage()); } 
 public static final TypeLiteral<RestView<ChangeEditResource>> CHANGE_EDIT_KIND = 
 * exist per user and change. * 
 Account.Id accountId = new Account.Id(1000042); Change.Id changeId = new Change.Id(56414); 
<|del|> 
 private static enum TreeOperation { 
 * Create new change edit. * 
 * Restore file in existing change edit. * 
 return inserter.insert(builder); 
 String refName, RevWalk rw, RevCommit base, 
 throw new InvalidChangeOperationException(String.format( "cannot restore path %s: missing in base revision %s", path, base.abbreviate(8))); 
 //TODO (Simon Lei): use another means of registering plugins that doesn't //require a redundant input. public ConfigRegistration() {} 
 //TODO (Simon Lei): use another means of registering plugins that doesn't //require a redundant input. public ConfigRegistration() {} 
 if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) { 
 ? new RevId(ObjectId.toString(patchList.getOldId())) : new RevId(ObjectId.toString(patchList.getNewId()))); 
 final String suffix = RefNames.DRAFTS + changeId.get(); 
 return Optional.fromNullable(db.patchComments().get(key)); 
 public Collection<PatchLineComment> publishedComments() 
 public Object apply(TopLevelResource resource) { 
<|del|>
 if (token.isError()) { LOG.error("POST " + config.gitHubOAuthAccessTokenUrl + " returned an error token: " + token); 
 putPreferred(preferredEmail); 
 repo.close(); 
 publishedComments = plcUtil.publishedByChange(db, notes()); 
 r.append(REFS_DRAFT_COMMENTS); int n = accountId.get() % 100; if (n < 10) { r.append('0'); } r.append(n); 
<|del|> 
 ObjectId idFromNotes = firstNonNull(notes.load().getRevision(), ObjectId.zeroId()); 
 "Multiple JavaScript plugins detected: %s, %s", this.javascript, 
public class AutoRegisterModules { private static final int SKIP_ALL = ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES; 
public class AutoRegisterModules { private static final int SKIP_ALL = ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES; 
 private final JarFile jarFile; 
 private final JarFile jarFile; 
 + "/edit"; 
 * Retrieve git commit for change edit. * 
 * Retrieve parent git commit for change edit. * 
 private static void deleteRef(Repository repo, ChangeEdit edit) 
 private static RevCommit writeSquashedCommit(RevWalk rw, 
 private static RevCommit writeSquashedCommit(RevWalk rw, 
 private static RevCommit writeSquashedCommit(RevWalk rw, 
 private static ObjectId commit(ObjectInserter inserter, CommitBuilder mergeCommit) throws IOException { 
 createdOn = ts; 
 RevCommit commit = rw.parseCommit(repo.resolve(revstr)); 
 assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content))); 
 if (!migration.readComments()) { return db.patchComments().publishedByChangeFile(changeId, file).toList(); 
 filtered.add(r); 
 assertEquals(filtered, Ordering.natural().sortedCopy(s.split(out))); 
 @Option(name = "--start", aliases = {"-S"}, usage = "Number of changes to skip") 
@CommandMetaData(name = "ls-logging-level", description = "list the level of loggers", runsAt = MASTER_OR_SLAVE) 
@CommandMetaData(name = "set-logging-level", description = "Change the level of loggers", runsAt = MASTER_OR_SLAVE) 
 switch (level.toLowerCase()) { 
<|del|> 
 PropertyConfigurator.configure(getClass().getClassLoader().getResource( LOG_CONFIGURATION)); 
 @RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER) 
 for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements();) { 
 for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements();) { 
<|del|> 
public class SetLoggingLevelCommand extends SshCommand { 
 protected void run() { 
 protected void run() { 
 setLoggingLevel(Level.toLevel(level.name())); 
 return newRawInput(content.getBytes(StandardCharsets.UTF_8)); 
 private String urlEditFile() { return urlEdit() + "/" + FILE_NAME; } private String urlEditFile2() { 
 public ChangeEditResource(ChangeResource change, ChangeEdit edit, String path) { 
 return newGson().fromJson(r.getReader(), new TypeToken<Map<String, EditInfo>>() {}.getType()); 
 for (EmailInfo e : getEmails.apply(rsrc)) { 
 stderr.write("preferred email not found: " + email + "\n"); 
 stderr.write("preferred email not found: " + email + "\n"); 
 String timeout = LdapRealm.optional(config, "readTimeout"); if (timeout != null) { readTimeOutMillis = Long.toString(ConfigUtil.getTimeUnit(timeout, 0, 
 if (readTimeOutMillis != null) { env.put("com.sun.jndi.ldap.read.timeout", readTimeOutMillis); 
 Throwables.propagateIfPossible(e.getException(), NamingException.class); Throwables.propagateIfPossible(e.getException(), RuntimeException.class); 
 Throwables.propagateIfPossible(e.getException(), NamingException.class); Throwables.propagateIfPossible(e.getException(), RuntimeException.class); 
 static String optional(Config config, String name, String defaultValue) { 
<|del|> 
 ChangeEditModifier(@GerritPersonIdent PersonIdent gerritIdent, 
 public void modifyFile(Repository repository, ChangeEdit changeEdit, String filePath, RawInput newContent) throws AuthException, 
 assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode()); 
 return Response.none(); 
<|del|> 
 assertThat(newNotes(c).getChange().getOwner()).isEqualTo( changeOwner.getAccountId()); 
 // Add an approval whose score should be copied on trivial rebase gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend()); 
<|del|> 
<|del|> 
 assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode()); 
 EditInfo info = toEditInfo(); 
 assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode()); 
<|del|> 
<|del|> 
<|del|> 
<|del|>
 return "Error AccessToken [error=" + error + ", error_description=" 
 public OAuthProtocol(GitHubOAuthConfig config, GitHubHttpProvider httpClientProvider, 
 if (token.isError()) { LOG.error("POST " + config.gitHubOAuthAccessTokenUrl + " returned an error token: " + token); 
 public void putReviewer(Account.Id reviewer, ReviewerState type) { checkArgument(type != ReviewerState.REMOVED, "invalid ReviewerType"); reviewers.put(reviewer, type); 
 public void removeReviewer(Account.Id reviewer) { reviewers.put(reviewer, ReviewerState.REMOVED); 
 @Override 
 public void setInserter(ObjectInserter inserter) { this.inserter = inserter; 
 try (DraftCommentNotesParser parser = new DraftCommentNotesParser( getChangeId(), walk, rev, repoManager, draftsProject, author)) { 
 editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream())); 
 private EditInfo toEditInfo() throws IOException { 
 assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile( edit.get(), FILE_NAME, CONTENT_NEW)); 
 private boolean useFullTextSearch; private final Config cfg; 
<|del|> 
 return reviewer; } else { return reviewer.subList(0, limit); 
 * Represents change edit resource, that is actualy two kinds of resources: * <ul> 
 public static class Input { @DefaultInput 
 if (input.content == null) { throw new ResourceConflictException("no input provided"); 
 assertEquals(SC_NO_CONTENT, session.delete(urlEditFile()).getStatusCode()); 
 /** * Handler to delete a file. * <p> * This deletes the file from the repository completely. This is not the same * as reverting or restoring a file to its previous contents. 
<|del|> 
 } try { editInfo.files = fileInfoJson.toFileInfoMap( rsrc.getChange(), edit.get().getRevision(), basePatchSet); } catch (PatchListNotAvailableException e) { throw new ResourceNotFoundException(e.getMessage()); } 
 // Edit is wiped out 
 // Edit is wiped out 
 execute(bru, repo); execute(bruForDrafts, allUsersRepo); 
 execute(bru, allUsersRepo); 
 }, MoreExecutors.sameThreadExecutor()); 
 if (a.run(log.getName())) { stdout.println(log.getName() + ": " + log.getEffectiveLevel()); 
 public void setInserter(Repository repo) { inserter = repo.newObjectInserter(); 
 throw new BadRequestException( 
 throw new BadRequestException( 
 /** Checks if the supplied ref name ends with auto-close parameter */ 
 throws AuthException, ResourceConflictException, IOException, InvalidChangeOperationException, OrmException { 
 "edit for change %s is already on latest patch set: %s", 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 RevFlag flag = newFlag(rw); try { return new IncludedInResolver(repo, rw, commit, flag).includedInOne(refs); } finally { rw.disposeFlag(flag); } 
<|del|>
<|del|>
 if (itsAllowedStatus.length > 0) { 
 if (!correctStatus) { synopsis = "Attempting to associate to issue in invalid state"; 
 expect(serverConfig.getStringList("commentLink", "ItsTestName", "allowedStatus")) .andReturn(new String[]{}).atLeastOnce(); 
@CommandMetaData(name = "ls-level", description = "list the level of loggers", 
 if (logger.startsWith("^")) { 
 if (logger.startsWith("^")) { 
 LogManager.getLogger(logger).setLevel(Level.toLevel(level.name())); 
 logger.nextElement().setLevel(null); 
 RunAutomaton a = new RunAutomaton(new RegExp(regex).toAutomaton()); 
 RunAutomaton a = new RunAutomaton(new RegExp(regex).toAutomaton()); 
 for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements();) { 
 * Converters to classes in {@code com.google.gerrit.extensions.common}. 
<|del|> 
 public CustomMappingAnalyzer(Analyzer delegate, Map<String, String> customMappings) { 
 } 
 for (Map.Entry<String, String> e : customMappings.entrySet()) { 
 return new MappingCharFilter(builder.build(), reader); 
 private static final String HASHTAG_FIELD = ChangeField.HASHTAG_CASE_AWARE.getName(); 
 /** * No longer used outside Velocity. Remove this method when VTL support is * removed. */ 
 assertResultEquals(change1, queryOne("message:foo_bar")); assertResultEquals(change1, queryOne("message:foo bar")); 
<|del|> 
 String path = System.getProperty(JAVA_OPTIONS_LOG_CONFIG); if (Strings.isNullOrEmpty(path)) { 
<|del|> 
 protected void resetProject() throws Exception { dbHandler.delete(project); fsHandler.delete(project, false); cacheHandler.delete(project); } 
 && !revisionInfo.is_edit(); 
 if (Gerrit.isSignedIn()) { // TODO(davido): It shouldn't be necessary to make this call. // PatchSetsBox is constructed via PatchSetsAction which is // only initialized by CS2 after loading the EditInfo in that path. 
 RevisionInfo revisionInfo = createObject().cast(); 
 public final native boolean is_edit() /*-{ return this._number == 0; }-*/; 
 } 
import com.google.inject.Singleton; 
<|del|>
<|del|>
 Map<String, Object> data = Maps.newHashMapWithExpectedSize(7); List<Map<String, Object>> tags = RefServlet.getTagsSoyData(req, timeCache, walk, REF_LIMIT); 
 for (BranchInfo b : branches) { 
 FlowPanel mwrap = new FlowPanel(); 
 if (branch.ref().startsWith(Branch.R_HEADS)) { return branch.ref().substring(Branch.R_HEADS.length()); 
 static class Input { 
 in.subject = input.subject; if (input.draft != null && input.draft) { in.status = ChangeStatus.DRAFT; } 
 ThreeWayMergeStrategy mergeStrategy, 
 include = FluentIterable.from(include).filter(new Predicate<Ref>() { @Override public boolean apply(Ref ref) { return !TagSet.skip(ref); } }).toList(); 
 if (clazz.isLocalClass()) { 
 Op(ChangeResource rsrc, Map<Account.Id, ChangeControl> reviewers, ReviewerState state) { 
 return projectControl .controlForRef("refs/for/" + getRefName()) .canPerform(Permission.PUSH_MERGE) 
 return projectControl .controlForRef("refs/for/" + getRefName()) .canPerform(Permission.PUSH_MERGE) 
 return canPerform(Permission.REBASE) && canWrite(); 
 try (InputStream constantsStream = getClass().getResourceAsStream(GERRIT_CONSTANTS_PROPERTIES)) { if (constantsStream != null) { 
 public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) 
public class DummyIndex implements ChangeIndex, LifecycleListener { 
<|del|> 
 bind(ChangeIndex.class).toInstance(new DummyIndex()); 
@CommandMetaData(name = "query", description = "Query the change database") public class Query extends SshCommand implements DynamicOptions.BeanReceiver { 
 public boolean canSubmit() { 
 BytesRefBuilder builder = new BytesRefBuilder(); NumericUtils.intToPrefixCodedBytes(value, 0, builder); return new Term(name, builder.get()); 
 public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) 
 throw new UnsupportedOperationException(); 
 bind(ChangeIndex.class).toInstance(new DummyIndex()); 
 * {@literal @}RunWith(ConfigSuite.class) 
<|del|> 
 stubChangeControl(repoManager, migration, c, allUsers, user), TimeUtil.nowTs(), Ordering.<String> natural()); 
 if (o instanceof PatchSetVerification) { PatchSetVerification p = (PatchSetVerification) o; 
<|del|> 
 throw failure; } catch (Error failure) { if (init.flags.deleteOnFailure) { recursiveDelete(getSitePath()); } throw failure; 
 throw failure; } catch (Error failure) { if (init.flags.deleteOnFailure) { recursiveDelete(getSitePath()); } throw failure; 
 System.err.println("Initialized " + getSitePath().getCanonicalPath()); 
 include = FluentIterable.from(include).filter(new Predicate<Ref>() { @Override public boolean apply(Ref ref) { return !TagSet.skip(ref); } }).toList(); 
 // Equivalent to --fixed-strings, to avoid pathological performance of Java // regex matching. 
 // git log --author matches any part of the email, local or domain. 
 private Button createChangeAction() { final Button createChange = new Button("Create change"); createChange.setTitle("Create change directly in browser"); 
public class DummyIndex implements ChangeIndex { 
 log.warn("Couldn't setMaxPackSizeLimit on receive-pack for " + project.get(), e); 
 addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName(), null); 
<|del|> 
 static abstract class CallbackWrapper<I, O> implements AsyncCallback<I> { 
 @Option(name = "--limit", aliases = {"-n"}, metaVar = "CNT", usage = "maximum number of branches to list") 
 @Option(name = "--start", aliases = {"-s"}, metaVar = "CNT", usage = "number of branches to skip") 
 @Option(name = "--match", aliases = {"-m"}, metaVar = "MATCH", usage = "match branches substring") 
 @Option(name = "--regex", aliases = {"-r"}, metaVar = "REGEX", usage = "match branches regex") 
 if ((matchSubstring != null && !matchSubstring.isEmpty()) || (matchRegex != null && !matchRegex.isEmpty())) { 
<|del|> 
 return branches.subList(start, (start + limit) < branches.size() ? (start + limit) : branches.size() - 1); 
 public CommitInfo commit; public Map<String, ActionInfo> actions; 
 throw new RuntimeException("Cannot read gerrit.config file", e); 
 if (instance == null) { instance = injector.getInstance(getSecureStoreImpl()); } return instance; 
 daemonArgumentSeparator = true; 
 new String[sdmLauncherOptions.size()]))) { log.error("Failed to parse codeserver arguments"); 
 new String[sdmLauncherOptions.size()]))) { log.error("Failed to parse codeserver arguments"); 
<|del|> 
 ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet()); 
 assertThat(notes.getApprovals()).containsExactlyEntriesIn( ImmutableMultimap.of( psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen()))); 
 assertThat(notes.getApprovals()).containsExactlyEntriesIn( ImmutableMultimap.of( psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen()))); 
<|del|> 
 CommitMergeStatus.NO_PATCH_SET); 
 throw new MergeValidationException(CommitMergeStatus.NO_PATCH_SET); 
<|del|> 
 CommitMergeStatus.REJECTED_BY_PLUGIN, "Submitter not found"); 
// limitations under the License. 
 private final Provider<ReviewDb> reviewDb; 
 CommitMergeStatus.REJECTED_BY_PLUGIN); 
 for (Class<? extends Annotation> annotation : annotations) { String descr = classObjToClassDescr.get(annotation); 
 result.put(annotation, value); 
 if (id.equals("0")) { return loadEdit(change, null); } if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) { 
 if (id.equals("0")) { return loadEdit(change, null); } if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) { 
 return loadEdit(change, revid); 
 return Collections.emptyList(); 
 } else if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) { 
 // added to the list of revisions. Additionally under certain 
 private final Widget relativeTo; 
 p.showRelativeTo(relativeTo); 
 private boolean isEditable(FileInfo info) { 
 boolean editable = isEditable(info); 
 private final Logger log = LoggerFactory.getLogger(ElasticsearchChangeIndex.class); private final String DEFAULT_INDEX_NAME = "gerrit"; 
 private final Logger log = LoggerFactory.getLogger(ElasticsearchChangeIndex.class); private final String DEFAULT_INDEX_NAME = "gerrit"; 
 private final Logger log = LoggerFactory.getLogger(ElasticsearchChangeIndex.class); private final String DEFAULT_INDEX_NAME = "gerrit"; 
 private String indexName; 
 indexName = cfg.getString("index", null, "name"); if (Strings.isNullOrEmpty(indexName)) { indexName = DEFAULT_INDEX_NAME; 
 schema, new CustomMappingAnalyzer(new StandardAnalyzer( CharArraySet.EMPTY_SET), CUSTOM_CHAR_MAPPING)); 
 flush(type);*/ 
 insertIndex = OPEN_CHANGES; deleteIndex = CLOSED_CHANGES; 
 Sorting order = hasNonTrivialSortKeyAfter(schema, p) ? Sorting.ASC : Sorting.DESC; 
 if (Ints.tryParse(value) == null) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public <T extends JavaScriptObject> void delete(JavaScriptObject content, AsyncCallback<T> cb) { 
 return new SafeHtmlBuilder(); 
 } 
 PushOneCommit.Result r = pushTo("refs/heads/master"); 
 short m = p.getMaximumPageSize(); 
 // Retrieve one more branch than page size to determine if there are more // branches to display ProjectApi.getBranches(getProjectKey(), pageSize + 1, startPosition, subname, 
 buttons.add(next); add(branchTable); 
 buttons.add(next); add(branchTable); 
 List<BranchInfo> filteredBranches; 
<|del|> 
<|del|> 
 DataSourceType dst) { 
 p.setProperty("password", password); 
 public static RestApi hashtags(int changeId) { return change(changeId).view("hashtags"); 
 public static RestApi hashtag(int changeId, String hashtag){ return change(changeId).view("hashtags").id(hashtag); 
 public static RestApi hashtag(int changeId, String hashtag){ return change(changeId).view("hashtags").id(hashtag); 
 List<BranchSuggestion> suggestions = new ArrayList<>(); 
 if (branch.ref().startsWith(Branch.R_HEADS)) { return branch.ref().substring(Branch.R_HEADS.length()); 
 sendButton.setText(Util.C.buttonCreate()); message.setText(Util.C.buttonCreateDescription()); 
 final Button createChange = new Button(Util.C.buttonCreateChange()); createChange.setTitle(Util.C.buttonCreateChangeDescription()); 
 super(enableOnFailure, true, Util.C.dialogCreateChangeTitle(), Util.C.dialogCreateChangeHeading()); 
 panel.insert(new SmallHeading(Util.C.newChangeBranchSuggestion()), 0); 
 public static void submit( @Nullable String project, int id, String commit, AsyncCallback<SubmitInfo> cb) { 
<|del|> 
import com.google.gerrit.extensions.events.GitReferenceUpdatedListener; import com.google.gerrit.extensions.registration.DynamicItem; 
 VALUES.put(canonicalize(s), s); 
 ProjectControl.Factory projectControlFactory, ProjectCache projectCache, Provider<GetHead> getHead, GitRepositoryManager repoManager, @CanonicalWebUrl Provider<String> webUrl) { 
 project = new Project.NameKey(p); 
 public InheritableBoolean useAllNotInTarget; 
 controlFactory.controlFor(new Project.NameKey(input.projectName), user.get()); throw new NameAlreadyUsedException(input.projectName); } catch (NoSuchProjectException e) { 
<|del|> 
 return Hashing.md5().newHasher() .putUnencodedChars(project.get()) .putUnencodedChars(revId.getName()) .putUnencodedChars(file) .hash().toString(); 
 XDocResourceKey(Project.NameKey project, String r, ObjectId revId) { 
 if (hashtags != null) { 
import com.google.gerrit.reviewdb.client.Branch; 
import com.google.gerrit.reviewdb.client.PatchSet; 
<|del|> 
 ChangeControl control = req.getControl(); if (!control.canEditHashtags()) { throw new AuthException("Editing hashtags not permitted"); } 
Copyright (C) 2014 The Android Open Source Project 
 if (hashtags == null) { hashtags = ImmutableSet.of(); } 
 if (hashtags == null) { hashtags = ImmutableSet.of(); } 
 }; hashtags.addAll(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",;")) .trimResults().split(input.hashtags))); 
<|del|> 
 }; hashtags.addAll(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",;")) .trimResults().split(input.hashtags))); 
<|del|> 
 return object.notes().load().getHashtags().contains(getValue()); 
 return object.notes().load().getHashtags().contains(getValue()); 
 * It is implementator's responsibility to encrypt and store values. 
 * To deploy new SecureStore one needs to provide a jar file with explicitly one * class that extends {@code SecureStore} and put it in Gerrit server. Then run: 
 private static final GetErrorMessages GET_ERRORS = new GetErrorMessages(); private static final Logger LOG = LoggerFactory.getLogger(RefOperationValidators.class); 
<|del|> 
 AllUsersName allUsersName, DynamicSet<RefOperationValidationListener> refOperationValidationListeners, @Assisted Project project, @Assisted IdentifiedUser user, 
 boolean withException = false; List<RefOperationValidationListener> listeners = new ArrayList<>(); listeners.add(new DisallowCreationAndDeletionOfUserBranches(allUsersName)); refOperationValidationListeners.forEach(l -> listeners.add(l)); 
<|del|> 
 public ValidationMessage(String message, boolean isError) { 
<|del|> 
 public void set(PatchSet.Id base, PatchSet.Id curr, ChangeScreen2.Style style, 
 public CommitValidationMessage(String message, boolean isError) { 
 public ValidationMessage(String message, boolean isError) { 
<|del|> 
 String removeHashtag(String name); 
 if (secureStoreInitData != null) { bind(SecureStoreInitData.class).toInstance(secureStoreInitData); } else { bind(SecureStoreInitData.class).toProvider( Providers.<SecureStoreInitData> of(null)); } 
 if (secureStoreInitData != null) { bind(SecureStoreInitData.class).toInstance(secureStoreInitData); } else { bind(SecureStoreInitData.class).toProvider( Providers.<SecureStoreInitData> of(null)); } 
 throw new InvalidSecureStoreException(String.format( 
 throw new InvalidSecureStoreException(String.format("%s is not a valid lib", 
Copyright (C) 2014 The Android Open Source Project 
 private static final int DEFAULT_MAX_SUGGESTED = 10; private static final int DEFAULT_MAX_MATCHES = 100; 
 ProjectControl u = user(local, DEVS); ProjectControl d = user(local, DEVS); assertCanRead("refs/heads/foo-QA-bar", u); assertCanRead("refs/heads/foo-QA-bar", d); 
 @Option(name = "--new-change-for-all-not-in-target", usage = "if a new change will be created for every commit not in target branch") private InheritableBoolean createNewChangeForAllNotInTarget = InheritableBoolean.INHERIT; 
 void setAllNotInTarget(boolean on) { 
<|del|> 
 @Option(name = "--new-change-for-all-not-in-target", usage = "if a new change will be created for every commit not in target branch") private InheritableBoolean createNewChangeForAllNotInTarget = InheritableBoolean.INHERIT; 
<|del|> 
 ChangeFileApi.getContent(id, getText(), new GerritCallback<String>() { @Override public void onSuccess(String result) { textArea.setText(result); } 
 private static RestApi contentEditOrPs(PatchSet.Id id, String filename) { 
 public static void getContent(PatchSet.Id id, 
 info.revisions().values()); 
 ApprovalsUtil approvalUtil, PatchSetUtil patchSetUtil, 
<|del|> 
 Set<String> updatedHashtags = new HashSet<>(); 
 if (toAdd.size() > 0) { updatedHashtags.addAll(toAdd); 
 if (existingHashtags != null && !existingHashtags.isEmpty()) { 
 Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",;")) .trimResults().omitEmptyStrings().split(input.hashtags))); 
 * refs/users/UU/UUUU/edit-CCCC/P where UU/UUUU is sharded representation 
 * refs/users/UU/UUUU/edit-CCCC/P where UU/UUUU is sharded representation 
 * Retrieve edit for a given change. 
 * @throws IOException * @throws OrmException 
<|del|> 
 if (this == b) { 
 private boolean updateLabels(RevisionResource resource, 
 onAdd(null); 
 List<Account> fullNameMatches = Lists.newArrayListWithCapacity(fullTextMaxMatches); List<Account> emailMatches = Lists.newArrayListWithCapacity(fullTextMaxMatches); 
 private final int fullTextMaxMatches; private final int maxSuggestedReviewers; 
 this.maxSuggestedReviewers = cfg.getInt("suggest", "maxsuggestedreviewers", DEFAULT_MAX_SUGGESTED); this.fullTextMaxMatches = cfg.getInt("suggest", "fulltextsearchmaxmatches", DEFAULT_MAX_MATCHES); 
<|del|> 
 if (fullNameMatches.size() >= fullTextMaxMatches) { 
 throw new UnsupportedOperationException("not used by tests"); 
 List<EntryKey> result = new ArrayList<>(); 
 * `java -jar gerrit.war switch-secure-store -d $gerrit_site SwitchSecureStore * --new-secure-store-lib $path_to_new_secure_store.jar` 
 * `java -jar gerrit.war switch-secure-store -d $gerrit_site SwitchSecureStore * --new-secure-store-lib $path_to_new_secure_store.jar` 
 * Creates EntryKey. * * @param section * @param subsection * @param name 
 * list or {@code null} when property was not found. 
 * from SecureStore. 
 Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",;")) .trimResults().omitEmptyStrings().split(input.hashtags))); 
 int pos = ref.getName().lastIndexOf("/"); checkArgument(pos >0, "invalid edit ref: %s", ref.getName()); 
<|del|> 
 private List<ChangeAndCommit> getRelated(Change.Id changeId, int ps) 
 return new InlineHyperlink(label, Dispatcher.toSideBySide( 
 return new InlineHyperlink(label, Dispatcher.toSideBySide( 
 Gerrit.display(PageLinks.toChange(result.legacy_id())); 
 assertResult(POST(changeId, "tag1", null), expected); assertResult(POST(changeId, null, "tag1"), ImmutableList.<String>of()); 
<|del|> 
 public String getSideBContent() { 
 public void setSideBContent(String content) { 
 public Response<? extends Set<String>> apply(ChangeResource req) 
Copyright (C) 2014 The Android Open Source Project 
 HashSet<String> result = new HashSet<>(); for (String hashtag : input) { 
 HashSet<String> result = new HashSet<>(); for (String hashtag : input) { 
 public Response<? extends Set<String>> apply(ChangeResource req, Input input) 
 if (toAdd.size() > 0 || toRemove.size() > 0) { updatedHashtags.addAll(toAdd); updatedHashtags.removeAll(toRemove); update.setHashtags(updatedHashtags); update.commit(); indexer.index(dbProvider.get(), update.getChange()); 
<|del|> 
 || (input.add == null && input.remove == null)) { 
<|del|> 
 GitOverHttpServlet( Resolver resolver, UploadFactory upload, UploadFilter uploadFilter, ReceivePackFactory<HttpServletRequest> receive, ReceiveFilter receiveFilter) { 
<|del|> 
 public void validateHashtags(Change change, Set<String> toAdd, Set<String> toRemove) throws ValidationException; 
 if (this.command.contains("ListenableFutureTask")) { 
 if (thread != null) { 
 private static final Ordering<SuggestedReviewerInfo> SUGGESTED_REVIEWER_INFO_ORDERING = 
 private static final Ordering<SuggestedReviewerInfo> SUGGESTED_REVIEWER_INFO_ORDERING = 
 RefValidationHelper(RefOperationValidators.Factory refValidatorsFactory, @Assisted Type operationType) { 
 public IdentifiedUser getUser() { return user; 
 Map<String, Short> labels = new HashMap<>(); String message; 
 throw InvalidHashtagException.hashtagsMayNotContainCommas(); 
 String newSecureStore = getNewSecureStoreClassName(newSecureStoreFile); String currentSecureStoreName = getCurrentSecureStoreClassName(sitePaths); 
 String newSecureStore = getNewSecureStoreClassName(newSecureStoreFile); String currentSecureStoreName = getCurrentSecureStoreClassName(sitePaths); 
 log.info("Current secureStoreClass property ({}) will be replaced with {}", currentSecureStoreName, newSecureStore); 
 return Iterables.getOnlyElement(newSecureStores); 
 reject(cmd); 
 } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | NoSuchProjectException | RuntimeException e) { 
 commit.change = chg; commit.patchsetId = ps.getId(); commit.originalOrder = commitOrder++; commits.put(changeId, commit); 
<|del|> 
 String.format( "SecureStore is already set to %s. To change it use SwitchSecureStore program.", currentSecureStore)); 
 String.format( "SecureStore is already set to %s. To change it use SwitchSecureStore program.", currentSecureStore)); 
 insertIndex = OPEN_CHANGES; deleteIndex = CLOSED_CHANGES; 
 return user.getRealUser(); 
 url = sshUrl; 
 hashtag = cleanupHashtag(hashtag); if (!hashtag.isEmpty()) { result.add(hashtag); 
 for (String hashtag : object.notes().load().getHashtags()) { if (hashtag.equalsIgnoreCase(getValue())) { return true; } } return false; 
 return object.notes().load().getHashtags().contains(getValue()); 
<|del|> 
 assertThat(Iterables.getLast(ci.messages).message) .isEqualTo("Uploaded patch set 2: Code-Review+2."); // Check that the user who pushed the change was added as a reviewer since they added a vote assertThatUserIsOnlyReviewer(ci, admin); 
 @Assisted ProjectState project) { this.cfg = cfgFactory.getProjectPluginConfigWithInheritance(project, pluginName); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 @Option(name = "--prefix", usage = "Prepend <prefix>/ to each filename in the archive.") 
 private Options options = new Options(); 
 private Options options = new Options(); 
 List<ArchiveCommand.Format<ArchiveOutputStream>> formats = Arrays.asList( 
 new SideBandOutputStream(SideBandOutputStream.CH_DATA, 
 if (wasFormatRegistered) { 
Copyright (C) 2014 The Android Open Source Project 
Copyright 2014 Google Inc. All Rights Reserved. 
 private static enum LevelOption { 
<|del|> 
 private static final ThreadLocal<Integer> level = 
 * on each request. 
 ArchiveCommand.Format<ArchiveOutputStream>> archiveFormats; 
 * then parses them to fill the options object. 
 String argCmd = "argument "; 
 String argCmd = "argument "; 
 for (;;) { 
 //Parse them into the 'options' field 
<|del|> 
 String format = options.format; boolean wasFormatRegistered = registerArchiveFormat(format); 
 } else if (v.isEmpty() || "off".equalsIgnoreCase(v)) { 
 } else { 
 GroupIncludeCache groupIncludeCache, 
 addMembers(groupId, createGroupArgs.initialMembers); 
 public final native boolean isProtected() /*-{ return this.is_protected }-*/; 
 resource.getRevision().getPatchSet().getRefName(), 
 if (cmHashtags != null && !cmHashtags.isEmpty() && !Sets.intersection(cmHashtags, toRemove).isEmpty()) { throw new HashtagsValidationException( "Hashtags specified in the commit message cannot be removed"); } 
 if (cmHashtags != null && !cmHashtags.isEmpty() && !Sets.intersection(cmHashtags, toRemove).isEmpty()) { throw new HashtagsValidationException( "Hashtags specified in the commit message cannot be removed"); } 
 if (cmHashtags != null && !cmHashtags.isEmpty() && !Sets.intersection(cmHashtags, toRemove).isEmpty()) { throw new HashtagsValidationException( "Hashtags specified in the commit message cannot be removed"); } 
 if (cmHashtags != null && !cmHashtags.isEmpty() && !Sets.intersection(cmHashtags, toRemove).isEmpty()) { throw new HashtagsValidationException( "Hashtags specified in the commit message cannot be removed"); } 
 throw new ValidationException("Can remove hashtags in commit message", e); 
 } 
 return new WebLinkInfo(getLinkName(), getImageUrl(), getBranchUrl( resource.getName(), resource.getBranchKey().get()), getTarget()); 
 return new WebLinkInfo(getLinkName(), getImageUrl(), getProjectUrl(resource.getName()), getTarget()); 
 serve("/etc/*", "/static/*").with(ServerConfigServlet.class); 
public interface GarbageCollectorListener { 
 private void fire(final Project.NameKey p) { 
 PluginLoader.log.warn(String.format("Jar %s has invalid class file %s", jarFile.getName(), entry.getName()), err); 
 PluginLoader.log.warn(String.format("Jar %s has invalid class file %s", jarFile.getName(), entry.getName()), err); 
class HelloWeblink { 
 return name; 
 public static class PatchSetWeblink implements WebLink<RevisionResource> { 
 public static class PatchSetWebLink implements WebLink<RevisionResource> { 
 public String ref; public String revision; public String commit; public String message; public GitPerson tagger; 
 public String ref; public String revision; public String commit; public String message; public GitPerson tagger; 
 this(ref, revision); 
 public TagInfo apply(TagResource resource) { 
 public TagInfo apply(TagResource resource) { 
 import java.io.IOException; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.Map; @Singleton 
<|del|> 
<|del|> 
 throws ResourceNotFoundException, IOException { 
 for (TagInfo t : tags) { 
 e.execute("DROP TABLE " + table); for (String index : dialect.listIndexes(conn, table)) { e.execute("DROP INDEX " + index); } 
<|del|> 
 .annotatedWith(Exports.named(AsciidoctorFormatter.NAME)) .to(AsciidoctorFormatter.class); 
 changeDataFactory.create(db.get(), rsrc.getChange())); 
 return getRefControl().canSubmit(); 
 private static final String DEFAULT_MSG = "Error evaluating project rules, check server log"; 
 * @param ps patch set of the change to evaluate. If not set, the current * patch set will be loaded from {@link #evaluate()} or {@link * #getSubmitType}. 
 && RawText.isBinary(bytes)) { return Resources.METHOD_NOT_ALLOWED; 
 for (TagInfo t : tags) { 
 for (TagInfo t : tags) { 
 throw new ResourceNotFoundException(id); 
 this.css = StringEscapeUtils.escapeHtml(css); 
 * @param ps patch set of the change to evaluate. If not set, the current * patch set will be loaded from {@link #evaluate()} or {@link * #getSubmitType}. 
 * @return List of {@link SubmitRecord} objects returned from the evaluated * rules, including any errors. 
 new File(baseDir, "tmp/asciidoctor-" + TimeUtil.nowTs().getNanos() + ".tmp"); 
 } // if there is no project-specific CSS and f.setCss(null) is invoked // com.google.gerrit.server.documentation.MarkdownFormatter applies the // default CSS 
 * Exception thrown when the label term of a submit record * unexpectedly didn't contain a user term. 
 return 17 * value + name.hashCode(); 
<|del|> 
 void remove(Project.NameKey p); 
 private Repository getRepository(Project.NameKey project) throws ResourceNotFoundException, IOException { 
<|del|> 
<|del|> 
<|del|> 
 Map<String, Ref> tags = new HashMap<>(); 
 void maybeRefresh() throws IOException { 
 Provider<ReviewDb> dbProvider, TagCache tagCache, 
 public static final String NAME = "ASCIIDOCTOR"; 
<|del|> 
 .backend(BACKEND) .docType(DOCTYPE) .eruby(ERUBY) .safe(SafeMode.SECURE) .attributes(getAttributes(cfg, revision)) .mkDirs(true) .toFile(out) .get(); 
<|del|> 
<|del|> 
import com.google.gerrit.server.project.ProjectControl; 
 assertTrue(backend.handles(ANONYMOUS_USERS)); assertTrue(backend.handles(PROJECT_OWNERS)); assertFalse(backend.handles(OTHER_UUID)); 
 public ListenableFuture<Object> apply(Object o) { return (ListenableFuture<Object>) indexer.indexAsync(c.getId()); 
 public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch( Branch.NameKey branch, MergeOpRepoManager orm) throws IOException { logDebug("Calculating possible superprojects for " + branch); 
 hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount()); ResultSet<SubmoduleSubscription> submoduleSubscriptions = schema.submoduleSubscriptions().bySuperProject(rsrc.getBranchKey()); schema.submoduleSubscriptions().delete(submoduleSubscriptions); 
 if (!embeddedHtml && !line.startsWith("++++")) { sb.append(line); 
<|del|> 
 String.format("Cannot migrate entry for %s", key.section); 
 String.format("Cannot load SecureStore implementation: %s", className), e); 
 writeEnum(out, submitType); 
 // this is why we must specify an output file and then read its content 
 // Don't try to guess whether Mergeable will reindex; just turn // off reindexing in that code path and do it explicitly below. ListenableFuture<Void> b = 
 public ListenableFuture<Object> apply(Object o) { return (ListenableFuture<Object>) indexer.indexAsync(c.getId()); 
 private static final String ATTRIBUTE_ERROR_TRACE = 
 * @return WebLinkInfo that links to project in external service, * null if there should be no link. 
 addIfValid(links, link, webLink.getClass().getName()); 
 private void toAnchor(String href, String name) { Anchor a = new Anchor(); a.setHref(href); a.setText(name); webLinkPanel.add(a); } private void setParents(String project, JsArray<CommitInfo> commits) { 
 * @param change the change to perform the rebase for 
 return 16 + 2 * (16 + 20) + 4 * 8 // Size of EntryKey, 64-bit JVM. 
<|del|> 
 public FluentIterable<WebLinkInfo> getPatchSetLinks(final String project, 
 FluentIterable<WebLinkInfo> linkInfos = FluentIterable 
 Function<WebLink, WebLinkInfo> transformer) { 
 private static final Predicate<WebLinkInfo> INVALID_WEBLINK = 
 if (link == null){ 
<|del|> 
 private List<WebLinkInfo> linksToList(DynamicSet<? extends WebLink> links, 
 private static boolean started; 
 protected ReviewDb db; protected Event event; 
 log.error("Failed to reindex changes after " + event, e); 
 log.warn(String.format("%s is missing name and/or url", link.getClass().getName())); 
 * @return Links for patch sets. 
 * @return Links for branches. 
 private GroupList(Map<AccountGroup.UUID, GroupReference> byUUID) { 
 private GroupList groupList; 
<|del|> 
<|del|> 
 public AllProjectsConfig load() throws IOException, ConfigInvalidException { 
<|del|> 
<|del|> 
 log.error("Error parsing file " + GroupList.FILE_NAME + ": " + error.getMessage()); 
<|del|> 
 adminRestSession.post(urlRebase()).assertConflict(); 
 private final List<String> projectPatterns; 
 private final List<String> projectPatterns; 
 private final List<String> projectPatterns; 
 for (String pattern : projectPatterns) { if (isRE(pattern)) { // pattern is a regular expression if (projectName.matches(pattern)) { 
<|del|> 
 indexer.index(db.get(), change); 
 if (cache.get(commit, toId(other), SubmitType.CHERRY_PICK, strategy, 
 private final ChangeData cd; private final ChangeControl control; 
 Label l = new Label("Unable to load document: " + message); 
 return url == null ? null : new WebLinkInfo(README, getImageUrl(), url, Target.SELF); 
 return new ReplicationFilter(Collections.<String> emptyList()); 
 return new ReplicationFilter(Collections.<String> emptyList()); 
 private final List<String> projectPatterns; public ReplicationFilter(List<String> patterns) { projectPatterns = patterns; 
 public void listTagsOfNonExistingProject_NotFound() throws Exception { 
 private static List<TagInfo> toTagInfoList(RestResponse r) throws Exception { 
<|del|> 
 return false; 
 return false; 
 case EXACT_MATCH: 
 post(REVISION_KIND, "message").to(EditMessage.class); 
 Set<String> invalidHashtags = Sets.newHashSet(); 
 "Cannot remove any cookbook hashtags"); 
 assertThat(result).containsExactlyElementsIn(expected); 
 checkArgument((dest == null && repo == null) || (dest != null && repo != null), "must specify both repo and dest, or neither"); 
<|del|> 
 return Objects.hash(this); 
 // Loop over the comments and collect them into groups based on the file // location of the comment. FileCommentGroup currentGroup = null; 
<|del|> 
 private String a; 
 private transient LoadHelper load; 
 key.load = null; 
 public static class MergeabilityWeigher 
 return 16 + 2 * (16 + 20) + 3 * 8 // Size of EntryKey, 64-bit JVM. + 8; // Size of Boolean. 
 return 16 + 2 * (16 + 20) + 3 * 8 // Size of EntryKey, 64-bit JVM. + 8; // Size of Boolean. 
 gApi.changes().id(changeId).current().review(ReviewInput.recommend()); 
 private final String link; private final String html; private final String name; 
 public CommentLinkInfo(String name, Pattern compiledMatch, String link, String html) { 
 public CommentLinkInfo(String name, Pattern compiledMatch, String link, String html) { 
 public CommentLinkInfo(String name, Pattern compiledMatch, String link, String html) { 
<|del|> 
<|del|> 
 static private final String COMMENTLINK = "commentlink"; static private final String REGEXP_HTTP_CHANGE_ID; static private final Pattern HTTP_URL_PATTERN; static private final Pattern CHANGE_ID_PATTERN; 
 static private final String COMMENTLINK = "commentlink"; static private final String REGEXP_HTTP_CHANGE_ID; static private final Pattern HTTP_URL_PATTERN; static private final Pattern CHANGE_ID_PATTERN; 
 static private final String COMMENTLINK = "commentlink"; static private final String REGEXP_HTTP_CHANGE_ID; static private final Pattern HTTP_URL_PATTERN; static private final Pattern CHANGE_ID_PATTERN; 
<|del|> 
 String regexp = REGEXP_HTTP_CHANGE_ID; 
 } this.commentLinks = Collections.unmodifiableList(list); try { allPattern = Pattern.compile(regexp); } catch (RuntimeException err) { System.err.println("Could not compile all commentlinks as a whole"); } 
 new CommentLinkInfo("ChangeIdLinks", CHANGE_ID_PATTERN, baseGerritUrl + "#/q/$2,n,z", ""); List<CommentLinkInfo> operationalCommentLinks = new ArrayList<CommentLinkInfo>(commentLinks); operationalCommentLinks.add(changeIds); 
<|del|> 
<|del|> 
<|del|> 
 private static final String COMMENTLINK = "commentlink"; private static final Pattern HTTP_URL_PATTERN; private static final Pattern CHANGE_ID_PATTERN; 
 private final List<CommentLinkInfo> commentLinks; private final Pattern allPattern; 
 private final List<CommentLinkInfo> commentLinks; private final Pattern allPattern; 
 allPattern = Pattern.compile(Joiner.on('|').join(patterns)); 
 allPattern = Pattern.compile(Joiner.on('|').join(patterns)); 
 List<CommentLinkInfo> operationalCommentLinks = new ArrayList<>(commentLinks); 
 // Go through the individual regexps now for replacement. for (CommentLinkInfo cli : operationalCommentLinks) { List<Map<String, String>> resultingReplacement = cli.replace(piece.get("text")); 
 // Go through the individual regexps now for replacement. for (CommentLinkInfo cli : operationalCommentLinks) { List<Map<String, String>> resultingReplacement = cli.replace(piece.get("text")); 
<|del|> 
 log.info("Updating job " + c.getLabel() + " for change " + c.getPatchSetId()); 
 log.info("Adding job " + c.getLabel() + " for change " + c.getPatchSetId()); 
 void setSchemaFactory(SchemaFactory<ReviewDb> dbFactory) { this.dbFactory = dbFactory; 
 expect(schema.submoduleSubscriptions()).andReturn(subscriptions); 
 * @param id change document id 
 public void delete(int id) throws IOException; 
<|del|> 
import static com.google.common.truth.Truth.assertThat; 
 assertThat(a.val()).isEqualTo("foo"); assertThat(a.toString()).isEqualTo("Auto{val=foo}"); 
import static org.easymock.EasyMock.anyObject; import static org.easymock.EasyMock.capture; import static org.easymock.EasyMock.eq; import static org.easymock.EasyMock.expect; 
<|del|> 
 assertThat(response).contains(expectedError); 
 private static void addLink(List<Map<String, String>> parts, String text, String url) { parts.add(ImmutableMap.of("text", text, "url", url)); 
 ui.header("Wrong Primary Key Column Order Detected"); ui.message("The following tables are affected:\n"); ui.message("%s\n", Joiner.on(", ").join(corrections.keySet())); 
 Map<String, List<String>> corrections = new TreeMap<>(); 
 List<String> expectedPK = relationPK(rm); List<String> actualPK = dbTablePK(meta, tableName); if (!expectedPK.equals(actualPK)) { corrections.put(tableName, expectedPK); 
 List<String> expectedPK = relationPK(rm); List<String> actualPK = dbTablePK(meta, tableName); if (!expectedPK.equals(actualPK)) { corrections.put(tableName, expectedPK); 
<|del|> 
 Collection<ColumnModel> cols = rm.getPrimaryKeyColumns(); List<String> pk = new ArrayList<>(cols.size()); for (ColumnModel cm : cols) { pk.add(cm.getColumnName().toUpperCase(Locale.US)); 
 Collection<ColumnModel> cols = rm.getPrimaryKeyColumns(); List<String> pk = new ArrayList<>(cols.size()); for (ColumnModel cm : cols) { pk.add(cm.getColumnName().toUpperCase(Locale.US)); 
 try { Map<Short, String> seqToName = new TreeMap<>(); while (cols.next()) { seqToName.put(cols.getShort("KEY_SEQ"), cols.getString("COLUMN_NAME")); } 
 try { Map<Short, String> seqToName = new TreeMap<>(); while (cols.next()) { seqToName.put(cols.getShort("KEY_SEQ"), cols.getString("COLUMN_NAME")); } 
 try { Map<Short, String> seqToName = new TreeMap<>(); while (cols.next()) { seqToName.put(cols.getShort("KEY_SEQ"), cols.getString("COLUMN_NAME")); } 
 List<String> pk = new ArrayList<>(seqToName.size()); for (String name : seqToName.values()) { pk.add(name.toUpperCase(Locale.US)); } return pk; } finally { cols.close(); 
<|del|> 
 if (dialect instanceof DialectPostgreSQL) { executor.execute("ALTER TABLE " + tableName + " DROP CONSTRAINT " + tableName + "_pkey"); } else { executor.execute("ALTER TABLE " + tableName + " DROP PRIMARY KEY"); } 
 assert_().withFailureMessage(sshSession.getError()) .that(sshSession.hasError()).isFalse(); 
 assert_().withFailureMessage(sshSession.getError()) .that(sshSession.hasError()).isFalse(); 
 assert_().withFailureMessage(sshSession.getError()) .that(sshSession.hasError()).isFalse(); 
 assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo( c1.getChangeId()); assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo( c2.getChangeId()); 
 import org.junit.Before; import org.junit.Test; 
 @Inject private Provider<ChangesCollection> changes; 
 assertThat(related).isEmpty(); 
 add(git, FILE_A, "1"); rm(git, FILE_D); Commit c = createCommit(git, admin.getIdent(), SUBJECT_2); pushHead(git, "refs/for/master", false); 
 assertThat(q.all).hasSize(1); 
<|del|> 
 GitReferenceUpdated referenceUpdated, ChangeHooks hooks) { 
 dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey()); dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions); 
 get(COMMENT_KIND).to(GetComment.class); delete(COMMENT_KIND).to(DeleteComment.class); post(COMMENT_KIND, "delete").to(DeleteComment.class); 
 r.webLinks = links.isEmpty() ? null : links; 
 r.webLinks = links.isEmpty() ? null : links; 
 get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class); get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class); 
<|del|> 
 })); 
 if (html != null) log.warn( 
 assertThat(c.getParentCount()).is(2); 
 assertThat(pushResult.getRemoteUpdate("refs/heads/master").getMessage()) .startsWith("contains banned commit"); 
 assertThat(projectInfoList).hasSize(2); 
 private List<String> relationPK(RelationModel rm) { 
<|del|> 
 public CommentLinkInfo(Pattern pattern, String link) { this.pattern = pattern; 
 public List<Map<String, String>> linkify(String input) { 
 String text = m.group(0); addLink(parsed, text, pattern.matcher(text).replaceAll(link)); 
 return ImmutableList.copyOf(parsed); 
<|del|> 
<|del|>
 String text = parsed.get(index).get("text"); List<Map<String, String>> resultingReplacement = cli.linkify(text); parsed.remove(index); parsed.addAll(index, resultingReplacement); 
 * .linkify("do something nice\n\nbug 5") 
 this.pattern = checkNotNull(pattern); 
 log.warn("invalid commentlink.%s.match", subsection); continue; 
 FormatterUtil(@PluginName String pluginName, @PluginData File baseDir, 
 list.add(new CommentLinkInfo(pattern, link)); 
 assertUserPreferences(out, new UserPreferences()); 
 private void assertUserPreferences(UserPreferences out, UserPreferences in) { 
 String getIndexRef() { return MoreObjects.firstNonNull( cfg.getString(SECTION_WEB, null, KEY_INDEX_REF), Constants.HEAD); 
<|del|> 
 reviewDB.accountGroupMembersAudit().update(auditUpdates); reviewDB.accountGroupMembersAudit().insert(auditInserts); 
 boolean isValid; 
 private boolean isValidUTF8(byte[] input) { 
 cs.decode(ByteBuffer.wrap(input)); return true; } catch(CharacterCodingException e) { return false; 
 private boolean validateLine(byte[] line, int lineStart, int lineEnd) { 
 // Is the seventh bit set on the UTF8 start character? if ((line[utf8Index] & utf8Bit) == 0) 
 // Is the seventh bit set on the UTF8 start character? if ((line[utf8Index] & utf8Bit) == 0) 
 return false; } 
<|del|> 
 if (dialect instanceof DialectPostgreSQL) { // postgresql doesn't support the ALTER TABLE foo DROP PRIMARY KEY form 
 /** Can run the Git garbage collection. */ public static final String RUN_GC = "runGC"; 
 /** Can perform streaming of Gerrit events. */ public static final String STREAM_EVENTS = "streamEvents"; 
 /** Can perform streaming of Gerrit events. */ public static final String STREAM_EVENTS = "streamEvents"; 
<|del|> 
<|del|> 
<|del|> 
 final private int systemMaxBatchChangesOf; 
<|del|> 
<|del|>
 if (Strings.isNullOrEmpty(gerritUsername) || Strings.isNullOrEmpty(gerritToken)) { return null; 
 httpRequest.getSession().setAttribute(Constants.AUTHENTICATION_TYPE, AuthenticationType.CONTAINER); 
<|del|> 
<|del|> 
 private enum Validation { NONE, FULL, FAST } 
 CharsetDecoder cs = java.nio.charset.StandardCharsets.UTF_8.newDecoder(); 
 case 'a': // Check author case 'c': // Check committer 
 case 'a': // Check author case 'c': // Check committer 
 private void readConfiguration() { 
 for (; lineStart < lineEnd; lineStart++) { if ((line[lineStart] & 128) > 0) { 
 for (; lineStart < lineEnd; lineStart++) { if ((line[lineStart] & 128) > 0) { 
 // Is the seventh bit set on the UTF8 start character? if ((line[utf8Index] & utf8Bit) == 0) { 
 return false; } 
 private boolean validateCommit(byte[] commit) { 
 for (int offset = 0; returnValue && offset < commit.length; offset++) { 
 switch (commit[offset]) { 
<|del|> 
 h.putUnencodedChars( parent.getConfig().getRevision() != null ? parent.getConfig().getRevision().getName() : ObjectId.zeroId().getName()); 
 if (0 < cnt) { Preconditions.checkNotNull(ps); 
 mockMaker.replay(); 
 mockMaker.verify(); 
import static com.google.gerrit.common.data.GlobalCapability.BATCH_CHANGES_LIMIT; 
@Singleton class GetReviewers implements RestReadView<ProjectResource> { 
@Singleton class GetReviewers implements RestReadView<ProjectResource> { 
@Singleton class GetReviewers implements RestReadView<ProjectResource> { 
<|del|> 
<|del|> 
<|del|> 
 private final int systemMaxBatchChanges; 
<|del|> 
import java.nio.charset.CharacterCodingException; import java.util.Collections; import java.util.List; import java.util.regex.*; 
import java.nio.charset.CharacterCodingException; import java.util.Collections; import java.util.List; import java.util.regex.*; 
 denotes the number of bytes following that is part of that character. 
 ; lineStart++, utf8Bit >>= 1) {}; 
 for (lineEnd = offset; lineEnd < commit.length && commit[lineEnd] != '\n'; lineEnd++) {}; 
<|del|> 
<|del|> 
 * @param raw the raw stream * @return the content from the given stream formatted as html 
 return Hashing.md5().newHasher().putUnencodedChars(project.get()) .putUnencodedChars(revId.getName()).putUnencodedChars(file).hash() .toString(); 
 r = session.get(url()); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); assertEquals(0, toEditInfoMap(r).size()); 
 if ((cp >= 'a' && cp <= 'z') || (cp >= 'A' && cp <= 'Z') || (cp >= '0' && cp <= '9')) { 
 return true; } 
 assertEquals("=?UTF-8?Q?A_=E2=82=AC_B_=28Code_Review=29?= <a@a>", format("A \u20ac B (Code Review)", "a@a")); 
 if (('a' <= cp && cp <= 'z') || ('A' <= cp && cp <= 'Z') || ('0' <= cp && cp <= '9')) { 
 new PatchListKey(change.getProject(), a, b, Whitespace.IGNORE_NONE)); 
 } 
 } 
 private final Set<String> uaInitialized = new HashSet<>(); 
<|del|> 
<|del|> 
<|del|> 
 log.debug(logPrefix + msg, args); 
 * Class describing a merge tip during merge operation. 
 * Class describing a merge tip during merge operation. 
 * @param initial Tip before the merge operation. 
 appendMergeResult(commit, commit.getName()); 
 * Moves this MergeTip to newTip and appends mergeResult. * 
 * @return The merge results of the merge operation Map<<sha1 of the commit to be merged>, <sha1 of the merge result>> 
 mergeTip = new MergeTip(n, toMerge); 
<|del|> 
Copyright (C) 2014 The Android Open Source Project 
Copyright (C) 2014 The Android Open Source Project 
/** Output options available for retrieval of change details. */ 
 String path = URL.decode(screen.getToken(2)); screen.show(new XDocScreen(projectName, "HEAD", path)); screen.setWindowTitle(getFileName(path)); 
 String path = URL.decode(screen.getToken(3)); screen.show(new XDocSideBySideDiffScreen(change, patchSet, path)); screen.setWindowTitle(XDocScreen.getFileName(path)); 
 private Response makeCompilerOutputPage(String target) { 
@Ignore // TODO(davido): Enable it again, when gwt-test-utils lib is fixed. 
 "Modify edit against root commit not supported"); 
 merge, merge.getName()); 
 revisionA = getRevision(change, patchSet.substring(0, i)); 
 Plugin.get().screenRegex("c/(.*)/([0-9]+(\\.{2}[0-9]+)?)/(.*),unified", 
 @Override protected void updateProjectInput(ProjectInput in) { in.submitType = getSubmitType(); if (in.useContentMerge == InheritableBoolean.INHERIT) { in.useContentMerge = InheritableBoolean.FALSE; } } 
 appendMergeResult(commit, commit.getName()); 
 mergeTip.moveTipTo(newMergeTipCommit, newMergeTipCommit.getName()); 
<|del|> 
<|del|> 
import static com.google.common.truth.Truth.assertThat; 
 /** Get commit message in a PatchSet or change edit. */ 
<|del|> 
 private IdentifiedUser.GenericFactory factory; 
 RestResponse b = adminSession.get("/projects/" + project.get() + "/branches/" + change.branch); 
 CodeReviewCommit currentTip = 
 String mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commitName) : null; 
 * @return The merge results of the merge operation Map<<sha1 of the commit to * be merged>, <sha1 of the merge result>> 
 return branchTip; 
 mergeTip.moveTipTo( args.mergeUtil.mergeOneCommit(args.serverIdent.get(), args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), n), n.getName()); 
 private static final String PATTERN = "(?:\\s|\\A)#[A-Za-z0-9-_]+"; 
 private static final String PATTERN = "(?:\\s|\\A)#[A-Za-z0-9-_]+"; 
<|del|>
 ObjectLoader blobLoader = reader.open(tw.getObjectId(0), OBJ_BLOB); byte[] raw = blobLoader.isLarge() ? null : blobLoader.getCachedBytes(); return registry.getMimeType(path, raw).toString(); 
 GerritGitBlitContext(SitePaths sitePaths, IRuntimeManager runtime, INotificationManager notificationManager, IUserManager userManager, 
 GerritGitBlitContext(SitePaths sitePaths, IRuntimeManager runtime, INotificationManager notificationManager, IUserManager userManager, 
 logger.info("All Gitblit managers started."); 
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|>
 public WrappedPagesFilter(DynamicItem<WebSession> webSession, GerritAuthFilter gerritAuthFilter, 
 addArg(args, "--new-rev", mergeResultRev); 
 private CodeReviewCommit branchTip; 
 private CodeReviewCommit branchTip; 
 mergeTip.moveTipTo(merge, merge.getName()); 
<|del|> 
 public long eventCreatedOn = System.currentTimeMillis() / 1000L; 
 public long eventCreatedOn = TimeUtil.nowMs() / 1000L; 
 return !revision.contains(":") 
 boolean showAddMeButton = info.owner()._account_id() != currentUser 
<|del|> 
import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.transport.ReceiveCommand.Type; 
 c = db.changes().get(c.getId()); assertThat(c.getStatus()).isEqualTo(Change.Status.MERGED); assertProblems(c); 
import com.google.gerrit.server.contact.ContactStoreProvider; 
 if (rejectImplicitMerges) { Collections.addAll(mergedParents, c.getParents()); mergedParents.remove(c); } boolean commitAlreadyTracked = !existingRefs.isEmpty(); if (commitAlreadyTracked) { alreadyTracked++; 
 if (rejectImplicitMerges) { Collections.addAll(mergedParents, c.getParents()); mergedParents.remove(c); } boolean commitAlreadyTracked = !existingRefs.isEmpty(); if (commitAlreadyTracked) { alreadyTracked++; 
 if (rejectImplicitMerges) { Collections.addAll(mergedParents, c.getParents()); mergedParents.remove(c); } boolean commitAlreadyTracked = !existingRefs.isEmpty(); if (commitAlreadyTracked) { alreadyTracked++; 
 public Arguments getArgs() { return args; } 
 public Arguments getArgs() { return args; } 
 try { for (FooterLine f : c.commitFooters()) { if (f.getKey().equals()) { return f.getValue(); } } } catch (NoSuchChangeException | IOException e) { } return null; 
 try { for (FooterLine f : c.commitFooters()) { if (f.getKey().equals()) { return f.getValue(); } } } catch (NoSuchChangeException | IOException e) { } return null; 
 try { for (FooterLine f : c.commitFooters()) { if (f.getKey().equals()) { return f.getValue(); } } } catch (NoSuchChangeException | IOException e) { } return null; 
<|del|> 
 //if rebase happens, let rebase be transparent or not to user. private transient Boolean isRebaseTransparent; 
 //if rebase happens, let rebase be transparent or not to user. private transient Boolean isRebaseTransparent; 
 && whitespace == k.whitespace && isRebaseTransparent == k.isRebaseTransparent(); 
package com.google.gerrit.common; 
public class FooterConstants { /** The ChangeId as used to track patch sets. */ 
 /** The change ID as used to track patch sets. */ 
 /** The footer telling us who reviewed the change. */ public static final FooterKey REVIEWED_BY = new FooterKey("Reviewed-by"); 
 /** The footer telling us who reviewed the change. */ public static final FooterKey REVIEWED_BY = new FooterKey("Reviewed-by"); 
 /** The footer telling us who tested the change. */ 
import com.google.common.collect.Multimap; 
 private static final String EXPECTED = 
 for (ZipEntry entry; (entry = zip.getNextEntry()) != null;) { 
 /*-{ return this.show_on_side_by_side_diff_view || false; }-*/; 
 ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet()); 
 logDebug("Multiple commits with Change-Id {}", p.changeKey); reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES); 
 /** * Get the contents of a file or commit message in a PatchSet or change * edit. **/ 
 /** * Get the contents of a file or commit message in a PatchSet or change * edit. **/ 
 public static CodeMirror create(Element parent, Configuration cfg) { 
 return filteredDiffWebLinks; 
 FAILURE 
 public static final String URL_LAUNCHPAD = "https://login.launchpad.net/+openid"; public static final String URL_YAHOO = "https://me.yahoo.com"; 
 private List<InlineHyperlink> getLinks() { // skip change edits 
<|del|> 
 throw new IllegalStateException("unknown table type: " + contentTable.getClass().getSimpleName()); 
 if (add(matching, w, type)) { 
 if (w.isNotify(type)) { 
 logDebug("Replacing change {}", changeEnt.getId()); 
 result.webLinks = links.isEmpty() ? null : links.toList(); 
<|del|> 
 public void onEvent(Event event); 
 super("hashtags-changed"); 
 String type = event.getType(); typesByString.put(type, event.getClass()); 
<|del|> 
/** Distributes Events to ChangeListeners. Register listeners here. */ 
<|del|> 
Copyright (C) 2014 The Android Open Source Project 
<|del|> 
<|del|> 
<|del|> 
 ChangeListenerHolder(ChangeListener l, CurrentUser u) { listener = l; user = u; } 
 listener.onEvent(event); 
 public void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException { 
 if (isVisibleTo(branchName, holder.user)) { holder.listener.onEvent(event); } 
 ProjectState pe = projectCache.get(branchName.getParentKey()); if (pe == null) { return false; } ProjectControl pc = pe.controlFor(user); return pc.controlForRef(branchName).isVisible(); 
 ProjectState pe = projectCache.get(branchName.getParentKey()); if (pe == null) { return false; } ProjectControl pc = pe.controlFor(user); return pc.controlForRef(branchName).isVisible(); 
 Class<?> cls = EventTypes.getClass(type); 
 /** Register all known Events using this method. */ 
<|del|> 
 // when running `buck test`, thus highlighting any compilation errors. 
import org.eclipse.jgit.archive.TarFormat; import org.eclipse.jgit.archive.Tbz2Format; import org.eclipse.jgit.archive.TgzFormat; import org.eclipse.jgit.archive.TxzFormat; 
 @Override 
 ((ZipArchiveOutputStream) archiveStream).setLevel(level); 
 @Override 
 @Override 
 static void setLevel(int value) { 
 static void resetLevel() { 
<|del|> 
<|del|> 
<|del|> 
 ArchiveFormat f = allowedFormats.getExtensions().get("." + options.format); if (f == null) { throw new Failure(3, "fatal: upload-archive not permitted"); 
 sidebandError.write(f.getMessage().getBytes("UTF-8")); 
 SideBandOutputStream.MAX_BUF, out); 
 SideBandOutputStream.MAX_BUF, out); sidebandError.write(f.getMessage().getBytes(UTF_8)); 
public class FakeRealm extends AbstractRealm { 
public class LdapRealm extends AbstractRealm { 
 /** Include patch set weblinks. */ WEB_LINKS(14), 
<|del|> 
<|del|> 
 assertThat(gApi.changes() 
class CommentJson { 
 Map<String, List<CommentInfo>> format(Iterable<PatchLineComment> l, 
 .loader(GroupsAccountsLoader.class); 
 .loader(GroupsAccountsLoader.class); 
 ReviewDb db = schema.open(); 
 void deleteVote(String label, Short value) throws RestApiException; 
 Iterable<PatchSetApproval> byPatchSetUser = approvalsUtil.byPatchSetUser( db.get(), rsrc.getControl(), rsrc.getChange().currentPatchSetId(), rsrc.getReviewerUser().getAccountId()); for (PatchSetApproval psa : byPatchSetUser) { 
 private final Map<String, String> templateVars; 
 in.message = "nit: trailing whitespace"; 
 in.message = "nit: trailing whitespace"; 
 @Source("soy/soy.js") @DoNotEmbed DataResource soy(); @Source("sql/sql.js") @DoNotEmbed DataResource sql(); 
 @Source("soy/soy.js") @DoNotEmbed DataResource soy(); @Source("sql/sql.js") @DoNotEmbed DataResource sql(); 
import com.google.gerrit.extensions.client.Theme; /* This class is stored in Git config file. */ 
 public Integer tabSize; public Integer lineLength; public Boolean showTabs; public Boolean showWhitespaceErrors; public Boolean syntaxHighlighting; public Boolean hideLineNumbers; 
 public Integer tabSize; public Integer lineLength; public Boolean showTabs; public Boolean showWhitespaceErrors; public Boolean syntaxHighlighting; public Boolean hideLineNumbers; 
 public static <T> void storeSection(Config cfg, String section, String sub, T s, T defaults) throws ConfigInvalidException { 
 if (p.isActive()) { addSuggestion(r, p.getId(), visibilityControl); } 
 if (!firstPopupLoad && !popup.isShowing()) { 
 /** Look up mode by MIME type or file extension from a path. */ 
 if (d == -1 || s > d) { 
 fileSize = bucketFileSize(diffInfo); // Load theme after CM library to ensure theme can override CSS. ThemeLoader.loadTheme(prefs.theme(), themeCallback); 
 public boolean execute() { if (prefs.syntaxHighlighting() && view.isAttached()) { 
/** REST API helpers to remotely edit a change. */ 
 ModeInfo mode = ModeInfo.findMode(result, path); type = mode != null ? mode.mime() : null; 
 static native <T extends JavaScriptObject> HttpResponse<T> wrap(Response h, T r) /*-{ return {h: h, r: r} }-*/; 
 cb.onSuccess(HttpResponse.wrap(res, data)); 
 // Read from a published revision, when change edit doesn't // exist for the caller, or is not currently active. 
 out.fetch = makeFetchMap(ctl, in); out.kind = changeKindCache.getChangeKind(repo, cd, in); 
 // in arguments 
 * 
Copyright (C) 2014 The Android Open Source Project 
 } else if (args.group != null) { 
 } else if (args.group != null) { 
 patchIndex, // patchSetDetail, // patchTable, // top, // baseId // ); } else if ("cm".equals(panel)) { return new SideBySide2(baseId, id.getParentKey(), id.get()); 
 * If a view type is specified, it will be retained in the request's * {@link HTML_VIEW_TYPE_ATTRIBUTE} attribute. 
 public ImmutableMap<String, String> getTemplateVars() { 
 for (String enabledBranch : enabledBranches) { if (match(branch, enabledBranch)) { 
 * have been applied. 
 * @param args E-mail properties. Some are mutable. * @throws ValidationException if validation fails. 
 * @param args E-mail properties. Some are mutable. * @throws ValidationException if validation fails. 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
 for (int i = C_SIZE + 1; i < columns; i++) { 
 Provider<InternalChangeQuery> queryProvider, PatchSetUtil psUtil) { 
Copyright (C) 2015 The Android Open Source Project 
 private void loadConfigInfo(final ChangeInfo info, final String base) { 
 renderChangeInfo(info); 
 BinaryResult content() throws RestApiException; 
 private final Provider<GetDiff> getDiff; 
 Provider<GetDiff> getDiff, 
 range = r == null 
 if (!changeControl.isVisible(dbProvider.get())) { 
 adjustCodeMirrorHeight(); setLineLength(prefs.lineLength()); 
 final Change.Id changeId = patchKey.getParentKey().getParentKey(); final Change change = db.changes().get(changeId); if (change == null) { throw new NoSuchChangeException(changeId); } 
 final List<Patch> patches = list.toPatchList(patchSet.getId()); 
 Change change = db.changes().get(patchKey.getParentKey().getParentKey()); if (change == null) { throw new NoSuchEntityException(); } 
 final FileTypeRegistry ftr, final ChangeControl.GenericFactory ccf, final Provider<CurrentUser> usrprv) { 
 ReviewDb db = dbProvider.get(); Change change = db.changes().get(patchKey.getParentKey().getParentKey()); ChangeControl control = changeControlFactory.validateFor(change, userProvider.get()); 
@CommandMetaData(name = "close-connection", description = "Close the specified SSH connection", runsAt = MASTER_OR_SLAVE) 
 if (!new File(alternateBasePath).isAbsolute()) { 
 if (!new File(alternateBasePath).isAbsolute()) { 
<|del|> 
 projectKey = pk; oldId = a != null ? a.copy() : null; newId = b.copy(); whitespace = ws; 
 ResultSet<Change> byTopic(String s) throws OrmException; 
 checkSubmitRule(c, c.currentPatchSet(), false); 
 } catch (NoSuchChangeException | OrmException e) { 
 ReviewDb db = requestDb.get(); Change change = db.changes().get(changeId); 
@CommandMetaData(name = "close-connection", description = "Close the specified SSH connection", runsAt = MASTER_OR_SLAVE) 
@CommandMetaData(name = "close-connection", description = "Close the specified SSH connection", runsAt = MASTER_OR_SLAVE) 
 @Argument(index = 0, multiValued = true, required = true, metaVar = "SESSION_ID", usage = "List of SSH session ids to be closed") 
<|del|> 
 for (IoSession io : acceptor.getManagedSessions().values()) { 
 if (sshSession != null && sshSession.getSessionId() == id) { 
 stderr.print("close connection " + sessionId + ": no such connection\n"); 
 // We don't care; better, we could check if index was already renamed, but // gwtorm didn't expose this functionality at the time this schema upgrade // was written. 
 modules.add(cfgInjector.getInstance(GerritGlobalModule.class)); modules.add(new SearchingChangeCacheImpl.Module()); 
 stdout.println("closed connection " + sessionId); 
 // DELETED: id = 10 (reversePatchSetOrder) 
 if(!new File(alternateBasePath).isAbsolute()){ throw new IllegalStateException("repository.<name>.basePath must be " + "absolute path, change the following path: " + alternateBasePath); 
 String basePath3 = "/someAbsolutePath3/someDirectory"; String basePath4 = "/someAbsolutePath4/someDirectory"; 
 try (Statement stmt = newStatement(db); ResultSet rs = stmt.executeQuery( 
 try (Statement oldGroupIncludesStmt = newStatement(db); ResultSet oldGroupIncludes = oldGroupIncludesStmt.executeQuery( "SELECT * FROM account_group_includes")) { 
 try (PreparedStatement stmt = prepareStatement(db, 
 try (Connection conn = connectToDb()) { 
 public static final Ordering<CodeReviewCommit> ORDER = Ordering.natural() 
 private static final Logger log = LoggerFactory.getLogger(Submit.class); 
 this.submitTopicTooltip = new ParameterizedString(MoreObjects.firstNonNull( 
 private boolean areChangesSubmittable(ResultSet<Change> changes, 
 String.valueOf(c.getId()), e); 
<|del|> 
 boolean force) throws ResourceConflictException, OrmException { ChangeData cd = changeDataFactory.create(dbProvider.get(), rsrc.getControl()); List<SubmitRecord> results = new SubmitRuleEvaluator(cd) .setPatchSet(rsrc.getPatchSet()) .canSubmit(); 
 boolean force) throws ResourceConflictException, OrmException { ChangeData cd = changeDataFactory.create(dbProvider.get(), rsrc.getControl()); List<SubmitRecord> results = new SubmitRuleEvaluator(cd) .setPatchSet(rsrc.getPatchSet()) .canSubmit(); 
<|del|> 
<|del|> 
<|del|> 
 for (ChangeData cd : queryProvider.get().allSubmitted()) { 
<|del|> 
 this.scrollIntoView(null); 
<|del|> 
<|del|> 
<|del|> 
 // 2. Reload of current plugin 
Copyright (C) 2015 The Android Open Source Project 
Copyright (C) 2015 The Android Open Source Project 
 public Rebase(Provider<RebaseChange> rebaseChange, ChangeJson json, 
 this.rebaseChange = rebaseChange; this.json = json .addOption(ListChangesOption.CURRENT_REVISION) .addOption(ListChangesOption.CURRENT_COMMIT); 
 PatchSet.Id basePatchSetId = PatchSet.Id.fromRef(base); if (basePatchSetId != null) { // try parsing the base as a ref string return db.patchSets().get(basePatchSetId); 
 PatchSet.Id basePatchSetId = PatchSet.Id.fromRef(base); if (basePatchSetId != null) { // try parsing the base as a ref string return db.patchSets().get(basePatchSetId); 
 private static final Logger log = LoggerFactory.getLogger(DeleteBranches.class); static class Input { 
 delete(BRANCH_KIND).to(DeleteBranch.class); post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class); 
 this.scrollIntoView(null); 
 for (String index : Sets.intersection(toDelete, all)) { ui.message("Dropping index " + index + " on table " + table); try { 
 } catch (Exception e) { throwRestApiException("Cannot abandon change", e); 
<|del|> 
 metaVar = "SESSION_ID", usage = "List of SSH session IDs to be closed") 
 stdout.println("closed connection " + sessionId); 
<|del|> 
 private Map<String, String> mergeResults; 
 addArg(args, "--newrev", mergeResultRev); 
 if (ref == null) { log.warn("Branch %s doesn't exist", branch); 
 RevWalk rw = new RevWalk(r); try { batchUpdate.execute(rw, NullProgressMonitor.INSTANCE); } finally { rw.release(); } 
 if (errorMessages.length() > 0) { 
 if (errorMessages.length() > 0) { 
 if (errorMessages.length() > 0) { 
<|del|> 
 SortedSet<Project.NameKey> n = new TreeSet<>(names); n.add(newProjectName); names = Collections.unmodifiableSortedSet(n); } finally { namesUpdateLock.unlock(); 
 ui.message("listing all projects ..."); SortedSet<Project.NameKey> repoList = repoManager.list(); ui.message("done"); ui.message("creating reflog files for refs/meta/config branches ..."); for (Project.NameKey project : repoList) { 
 private static RestApi edit(int id) { 
 } public static class EditInfo extends JavaScriptObject { public final native String name() /*-{ return this.name; }-*/; protected EditInfo() { } } 
 base = parsePatchSet(patchSetString.substring(0, i)); revisionA = getRevision(change, base); 
 Account.Id account) { super(ChangeField.LABEL, ChangeField.formatLabel(label, expVal, account, args.group)); 
 batchUpdate.addCommand(createDeleteCommand(project, r, branch)); 
<|del|> 
 "Failed to create reflog for %s in repository %s", 
 ChangeApi.createDraftChange(project, getDestinationBranch(), message.getText(), null, 
 call(project, id, "abandon").post(input, cb); 
 public static void createChange( String project, String branch, String topic, String subject, String base, AsyncCallback<ChangeInfo> cb) { 
 public static void deleteEdit( @Nullable String project, int id, AsyncCallback<JavaScriptObject> cb) { edit(project, id).delete(cb); 
 GitRepositoryManager repoManager, Provider<ReviewDb> dbProvider, GitReferenceUpdated referenceUpdated, ChangeHooks hooks) { 
<|del|> 
 "it doesn't exist or you do not have permission to delete it"); 
 /** * Create a new change. 
 public void setCancelVisible(boolean visible) { 
 buttons.setStyleName(Gerrit.RESOURCES.css().branchTablePrevNextLinks()); 
 if (table.getRowCount() <= pageSize || pageSize == 0) { 
 pageSize = AccountGeneralPreferences.DEFAULT_PAGESIZE; 
 if (table.getRowCount() <= pageSize) { 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
 GET("Code-Review,user=bogus"); 
 List<ChangeInfo> changeInfos = GET("Code-Review"); 
 super(ChangeField.LABEL, ChangeField.formatLabel(label, expVal, account, args.group)); 
 if (sortFields(t).length > 0) { 
 public List<ChangeData> byTopicOpen(String topic) 
 directChildren = new HashSet<String>( Math.max(changes.length() * 4 / 3, 16)); 
 RowSafeHtml(ChangeAndCommit info, boolean notConnected, boolean directChild) { 
<|del|> 
<|del|> 
 final FlexCellFormatter fmt = table.getFlexCellFormatter(); 
<|del|> 
<|del|> 
<|del|> 
/** Class for registering event types */ 
<|del|> 
 Boolean csIsMergeable = isPatchSetMergeable(cs); if (csIsMergeable == null) { 
<|del|> 
 final SitePathInitializer initializer) { 
Copyright (C) 2015 The Android Open Source Project 
 final CanonicalWebUrl urlProvider, final AccountManager accountManager, final HttpAuthFilter authFilter, final AuthConfig authConfig) { 
 log.debug("Associating external identity \"{}\" to user \"{}\"", user, remoteExternalId); 
 log.debug("Associating external identity \"{}\" to user \"{}\"", user, remoteExternalId); 
 log.error("Unable to associate external identity \"" + remoteExternalId 
 log.error("Unable to associate external identity \"" + remoteExternalId 
 /** Scheme for external identity token used during authentication, e.g. OAuth Token */ 
<|del|> 
 String keyScheme, ResultSet<AccountExternalId> externalIds) { 
 String secureStore = getSecureStoreLib(); if (Strings.isNullOrEmpty(secureStore)) { 
 @Option(name = "--secure-store-lib", usage = "Path to jar providing SecureStore implementation class") private String secureStoreLib; 
 @Option(name = "--secure-store-lib", usage = "Path to jar providing SecureStore implementation class") private String secureStoreLib; 
 public abstract static class ChangeOp { 
 log.error("Old and new SecureStore implementation names " + "are the same. Migration will not work"); 
 @Option(name = "--new-secure-store-lib", usage = "Path to new SecureStore implementation", required = true) 
 log.error( "Old and new SecureStore implementation names are the same. Migration will not work"); 
 * `java -jar gerrit.war SwitchSecureStore -d $gerrit_site --new-secure-store-lib * $path_to_new_secure_store.jar` 
public class GetActions implements RestReadView<ChangeResource> { private final ActionJson delegate; 
 /** Scheme for external auth used during authentication, e.g. OAuth Token */ 
 /** Scheme for external identity token used during authentication, e.g. OAuth Token */ 
<|del|> 
import java.util.regex.Matcher; import java.util.regex.Pattern; 
 (line[lineStart] & 64) == 0; // Seventh bit is *NOT* set lineStart++, utf8Bit >>= 1) { } 
 lineEnd++) { } 
<|del|> 
 trimTrailingSlash(MoreObjects.firstNonNull( 
 trimTrailingSlash(MoreObjects.firstNonNull( 
 String retrieveUser(String authToken) { 
 "Invalid JSON '%s': not a JSON Object", accessTokenJson.toString())); 
 * implicitly trust the GitHub user in this HTTP header as unique identity. 
 this.changeDataFactory = changeDataFactory; 
 public ChangeInfo addChangeActions(ChangeInfo to, ChangeData cd) throws OrmException { to.actions = toChangeActionInfoMap(cd); return to; 
 return Response.withMustRevalidate(delegate.get().format(rsrc)); 
<|del|> 
<|del|> 
 public Map<String, ActionInfo> format(RevisionResource rsrc) { return toActionMap(rsrc); 
<|del|> 
<|del|> 
 tip = parseCommit(dest.getObjectId(), "destination ref " + refName); 
 throw new MethodNotAllowedException("draft workflow is disabled"); 
 throw new MethodNotAllowedException("draft workflow is disabled"); 
 ChangeApi.createChange(project, "refs/meta/config", 
<|del|> 
<|del|> 
<|del|> 
 AccountExternalId.Key key = id(who); List<AccountExternalId.Key> filteredKeysByScheme = 
 "pooledMaxTotalConnections", 32); 
 private final String usernameHeader; private final String username; 
 public static final String CONF_SECTION = "github"; public static final String GITHUB_OAUTH_AUTHORIZE = "/login/oauth/authorize"; 
 "Request for access token not authorized"); 
 "Request for access token not authorized"); 
 if (!new File(alternateBasePath).isAbsolute()) { 
 private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) { 
 if (ctl.getCurrentUser().isIdentifiedUser()) { Provider<CurrentUser> userProvider = Providers.of(ctl.getCurrentUser()); 
 i = toChangeInfo(cd, Optional.<PatchSet.Id> absent()); } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) { 
 i = toChangeInfo(cd, Optional.<PatchSet.Id> absent()); } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) { 
<|del|> 
<|del|> 
 public BatchUpdate addRefUpdate(ReceiveCommand cmd) { 
 public BatchUpdate addChangeOp(ChangeOp op) { 
 public BatchUpdate addPostOp(Callable<?> update) { 
<|del|> 
 @Singleton 
public class GetRevisionActions implements RestReadView<RevisionResource> { private final ActionJson delegate; 
public class GetRevisionActions implements RestReadView<RevisionResource> { private final ActionJson delegate; 
 public Object apply(RevisionResource rsrc) { return Response.withMustRevalidate(delegate.format(rsrc)); 
 try (ObjectStream os = lo.openStream(); ByteArrayInputStream b = new ByteArrayInputStream(sep); ObjectStream ts = lt.openStream(); UnionInputStream union = new UnionInputStream(os, b, ts)) { 
 try (ByteArrayInputStream b = new ByteArrayInputStream(sep); UnionInputStream union = new UnionInputStream( lo.openStream(), b, lt.openStream())) { 
 lt.openStream())) { ObjectId noteData = inserter.insert(Constants.OBJ_BLOB, lo.getSize() + sep.length + lt.getSize(), union); return new Note(ours, noteData); } 
 try (InputStream in = zf.getInputStream(ze)) { processor.process(pluginName, in); } 
 assertPermitted(gApi.changes().id(changeId).get(DETAILED_LABELS), "Code-Review", 2); 
Copyright (C) 2015 The Android Open Source Project 
 private static final String PREFERRED_EMAIL_ERROR_PAGE = "/static/openid2oautherror.html"; 
 OAuthWebFilter webFilter, Injector injector, SchemaFactory<ReviewDb> schema, 
 return true; 
 return false; 
<|del|> 
<|del|> 
 if (results.isEmpty()) { continue; } else if (results.size() > 1) { 
 Account.Id accountId = results.get(0).getId(); 
 "whose preferred email '%s' matched their GitHub account.", myself.getLogin(), email.getEmail())); 
 catch(OrmException orex) { 
<|del|> 
 SuggestAccountsRequest suggestAccounts() throws RestApiException; /** * Suggest users for a given query. * <p> * Shortcut API for {@code suggestAccounts().withQuery(String)}. * * @see #suggestAccounts() */ 
 /** * API for setting parameters and getting result. * Used for {@code suggestAccounts()}. * * @see #suggestAccounts() */ 
 || group.getName().startsWith("ldap/") || user.getCapabilities().canAdministrateServer(); 
 || group.getName().startsWith("ldap/") || user.getCapabilities().canAdministrateServer(); 
import java.nio.file.SimpleFileVisitor; import java.nio.file.attribute.BasicFileAttributes; 
 bind(LifecycleListener.class) .annotatedWith(UniqueAnnotations.create()) .to(DeleteTrashFolders.class); 
 try { Files.walkFileTree(gitDir.toPath(), new TrashFolderRemover()); } catch (IOException e) { log.warn("Exception occured while trying to delete trash folders", e); } 
 throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { 
public interface ETagView<R extends RestResource> extends RestReadView<R> { public String getETag(R rsrc); 
 String type = event.getType(); if (typesByString.containsKey(type)) { throw new IllegalArgumentException( "Event type already registered: " + type); } typesByString.put(type, event.getClass()); 
 String type = event.getType(); if (typesByString.containsKey(type)) { throw new IllegalArgumentException( "Event type already registered: " + type); } typesByString.put(type, event.getClass()); 
 /** Get the class for an event type. * * @param type The type. * @return The event class, or null if no class is registered with the * given type **/ 
 throw new JsonParseException("Unknown event type: " + type); 
 .view("submit_type") .get(new AsyncCallback<NativeString>() { @Override public void onSuccess(NativeString result) { renderSubmitType(result.asString()); } 
 // This includes all information relevant for ETag computation // unrelated to the UI. public void prepareETag(Hasher h, CurrentUser user) { 
 // This includes all information relevant for ETag computation // unrelated to the UI. public void prepareETag(Hasher h, CurrentUser user) { 
 EventTypes.registerClass(new TestEvent2()); 
<|del|> 
 this.secureStoreClassName = secureStoreClassName; 
 super(injector, sitePaths, secureStoreInitData.className); 
 "%s has more that one implementation of %s interface", 
 return new Section(flags, site, secureStore, ui, name, subsection); 
<|del|> 
 super(injector, sitePaths, secureStoreInitData.className); 
 final File jarFile; 
 SecureStoreInitData(File jar, String className) { 
 InitStepSecureStoreProvider( Injector injector, SitePaths sitePaths, SecureStoreInitData secureStoreInitData) { super(injector, sitePaths, Providers.of(secureStoreInitData.className)); 
 InitStepSecureStoreProvider( Injector injector, SitePaths sitePaths, SecureStoreInitData secureStoreInitData) { super(injector, sitePaths, Providers.of(secureStoreInitData.className)); 
 // break is omitted as we need the HTTP modules as well //$FALL-THROUGH$ 
 msg = msg + String.format(".%s", key.subsection); 
 "Found too many implementations of SecureStore:\n%s\nin %s", Joiner 
 public List<String> findSubClassesOf(Class<?> superClass) throws IOException { return findSubClassesOf(superClass.getName()); 
 res.setHeader(HttpHeaders.ETAG, curEtag); 
 StringBuilder p = new StringBuilder(GEN.length() + 40 * 2 + 2); p.append(GEN).append('-').append(srcmd.id.name()); 
 res.setDateHeader(HttpHeaders.EXPIRES, now); res.setDateHeader(HttpHeaders.DATE, now); res.setHeader(HttpHeaders.CACHE_CONTROL, "private, max-age=0, must-revalidate"); 
 String renderHTML(RootNode root) { return new HtmlFormatter(links, new TocSerializer(root, 3)).toHtml(root); 
 private final String style; 
 cols(), note(), toc(), 
<|del|> 
<|del|> 
<|del|> 
 if (result.length() != 0) { 
<|del|> 
 bind(HttpClient.class).toProvider(PooledHttpClientProvider.class).in( Scopes.SINGLETON); 
 this.httpProvider = httpProvider; 
 static String generateRandomState() { byte[] state = new byte[32]; randomState.nextBytes(state); return Base64.encodeBase64URLSafeString(state); 
 throw new IllegalArgumentException( "Failed to use UTF-8 encoding charset", e); 
<|del|> 
 if (showChangeSizeBars) { 
 if (showChangeSizeBars 
 String page = renderer.render(SOY_TEMPLATE, data); 
 adminRestSession.post(urlPublish(), input).assertNoContent(); 
 .contains("<h1><a class=\"h\" name=\"page\" href=\"#page\"><span></span></a>page</h1>"); 
 changeExtension, change, rev); 
<|del|> 
 @Nullable @SecureStoreClassName String className) { 
 buttons.setStyleName(Gerrit.RESOURCES.css().branchTablePrevNextLinks()); 
<|del|> 
 return filteredBranches.subList(start, (start + limit) < filteredBranches.size() ? (start + limit) : filteredBranches.size()); 
 ChangeApi.createChange( project.get(), RefNames.REFS_CONFIG, null, AdminConstants.I.editConfigMessage(), null, new GerritCallback<ChangeInfo>() { 
<|del|> 
 private static final long serialVersionUID = 1L; 
 renderer.getTemplateHash(SOY_FILE).writeBytesTo(b, 0, b.length); h.putBytes(b); 
 static Map<String, Object> bannerSoyData(GitilesView view, RootNode nav) { 
 seed = (seed << 8) | (b & 0xff); 
<|del|> 
<|del|> 
<|del|> 
 super(Util.C.rebaseTitle(), null); sendButton.setText(Util.C.buttonRebaseChangeSend()); 
 LinkedList<ChangeSuggestion> suggestions = new LinkedList<>(); 
 // suggest the most recent 50 changes 
 // suggest the most recent 50 changes 
 + " AND is:open NOT age:90d", 0, 50, 
 return String.valueOf(change.legacy_id().get()) + ": " + change.subject(); 
 import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
 import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
<|del|> 
 } catch (OrmException e) { log.error("Failed to get ancestors of patch set " + patchSetId.toRefName(), e); 
 psId = notes.getChange().currentPatchSetId(); 
 addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false)); 
<|del|> 
 private static final String BLOCKED_TOPIC_TOOLTIP = 
<|del|> 
 log.error("Error checking if change is submittable", e); 
 if (topicProblems != null) { 
 GroupMembership membershipsOf(AccountState user); 
import com.google.gerrit.server.account.AccountState; 
 DynamicSet.setOf(binder(), ReplicationStateListener.class); DynamicSet.bind(binder(), ReplicationStateListener.class).to(ReplicationStateLogger.class); 
import com.google.common.collect.Iterables; 
<|del|> 
 if (!servlets.containsKey(type)) { 
<|del|> 
import com.google.common.util.concurrent.ThreadFactoryBuilder; import com.google.gerrit.common.data.ContributorAgreement; 
<|del|> 
<|del|> 
import static com.google.gerrit.extensions.client.ListChangesOption.CURRENT_ACTIONS; import static com.google.gerrit.extensions.client.ListChangesOption.CURRENT_REVISION; 
<|del|> 
 } // no other actions assertThat(actions).hasSize(2); 
<|del|> 
<|del|> 
<|del|> 
public class GetRevisionActions implements ETagView<RevisionResource> { 
 private static final ImmutableMap<String, String> TYPES = ImmutableMap.of( "png", "image/png", "gif", "image/gif", "jpg", "image/jpeg", "jpeg", "image/jpeg"); 
 if (HtmlBuilder.isValidHttpUri(url)) { 
 String err = String.format( "Different secure store was previously configured: %s.", currentSecureStoreClassName); die(err, new RuntimeException("secure store mismatch")); 
 private final PluginEvent pluginEvent; private final String pluginName; 
 "Different secure store was previously configured: %s. " 
 String.format( "Different secure store was previously configured: %s." + "Use SwitchSecureStore program to switch between implementations.", currentSecureStoreClassName); 
 public boolean groupsVisibleToAll() { 
 assertThat(title).isEqualTo("Gerrit Code Review"); 
 public WebDriver getDriver() { File home = getUserHome(); System.setProperty("webdriver.chrome.driver", home.getAbsolutePath() + "/chromedriver"); 
 BatchUpdate.Factory batchUpdateFactory) { 
 } 
 db.changes().atomicUpdate( change.getId(), 
<|del|> 
 update = updateFactory.create(control, change.getLastUpdatedOn()); ChangeMessage message = newMessage(input, caller, change); 
 public void listPatchesAgainstBase() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException { add(git, FILE_D, "4"); createCommit(git, admin.getIdent(), SUBJECT_1); pushHead(git, "refs/heads/master", false); 
<|del|> 
 List<PatchListEntry> entries = getCurrentPatches(id); assertThat(entries).hasSize(3); 
 change = changeNotesFactory .create(db, change.getProject(), change.getId()).getChange(); 
<|del|> 
 LoggerFactory.getLogger(Rebase.class); 
 LoggerFactory.getLogger(Rebase.class); 
 private static final Logger log = LoggerFactory.getLogger(HttpLoginServlet.class); 
 return null != scheme ? getExternalId().substring(scheme.length() + 1) 
 List<AccountExternalId.Key> filteredExternalIds = new ArrayList<>(); 
 assertThat(title).isEqualTo("Gerrit Code Review"); 
<|del|> 
 expect(schema.submoduleSubscriptions()).andReturn(subscriptions); final ResultSet<SubmoduleSubscription> emptySubscriptions = new ListResultSet<>(new ArrayList<SubmoduleSubscription>()); expect(subscriptions.bySubmodule(sourceBranchNameKey)).andReturn( emptySubscriptions); 
 && resource.isCurrent()); 
 builder.field(name, ((Timestamp) value).getTime()); 
 res.setCharacterEncoding(StandardCharsets.UTF_8.name()); 
<|del|> 
<|del|> 
 if (name == null) { 
 return !mergeabilityMap.values().contains(Boolean.FALSE); 
 long ts = FileUtil.lastModified(p); 
 try { raw = Files.readAllBytes(p); } catch (NoSuchFileException e) { 
 try { raw = Files.readAllBytes(p); } catch (NoSuchFileException e) { 
 (int) ConfigUtil.getTimeUnit(config, "gerrit", null, "sshCommandTimeout", 0, SECONDS); 
<|del|> 
 * Tries to get username from a request with following strategies: 
 * Extracts username from an HTTP Basic or Digest authentication 
<|del|> 
 public static PushResult pushHead(Git git, String ref, boolean pushTags, boolean force) throws GitAPIException { 
<|del|> 
<|del|> 
 GarbageCollectionResult result = garbageCollectionFactory.create().run( Collections.singletonList(rsrc.getNameKey()), true, input.showProgress ? writer : null); 
<|del|> 
 public void forcePushNotAllowed() throws Exception { 
class DeleteLog implements LifecycleListener { 
final class DeleteLogLayout extends Layout { 
 Multimap<String, Object> params = HashMultimap.create(); params.put("class", DeleteLog.class); params.put("project", project.get()); params.put("force", String.valueOf(options.force)); params.put("preserve", String.valueOf(options.preserve)); 
 @Argument(index = 0, required = true, metaVar = "PROJECT", usage = "name of the project") 
 @Option(name = "--new-head", required = true, metaVar = "REF", usage = "new HEAD reference") 
 @Argument(index = 0, required = true, metaVar = "NAME", usage = "name of the project") 
<|del|> 
 new com.google.gerrit.server.account.AuthRequest(user.getExternalId()); areq.setUserName(user.getUserName()); areq.setEmailAddress(user.getEmailAddress()); areq.setDisplayName(user.getDisplayName()); 
 public boolean isAggressive() { return aggressive; } 
 Collections.singletonList(rsrc.getNameKey()), input.aggressive, 
 private static final Logger log = LogManager.getLogger(DELETE_LOG_NAME); 
 private static final Logger log = LogManager.getLogger(DELETE_LOG_NAME); 
 private boolean started; 
 null, // exception information null, // current NDC string null, // caller location null // MDC properties 
 * [2015-03-05 09:13:28,912 +0100] INFO 1000000 admin OK \ 
<|del|> 
 private final Configuration cfg; private final ProjectConfig.Factory projectConfigFactory; 
 throws IOException, RestApiException { 
 String passphrase = config.getString("remote", remoteName, "passphrase"); return new SecureCredentialsProvider(user, pass, passphrase); 
 this.cfgPassphrase = passphrase; 
 DynamicSet.setOf(binder(), ExternalIncludedIn.class); 
 // The following commands can only be run on a server in Master mode 
 command("git-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class); command("gerrit-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class); command(git, "receive-pack").to(NotSupportedInSlaveModeFailureCommand.class); 
<|del|> 
 listener = new EventHandler(storeMock, poolMock); 
 pool.execute(new StoreEventTask((ProjectEvent) event)); 
 return "(Events-log) Insert Event"; 
 if (Objects.equals(m.getAuthor(), id)) { 
 try (TreeWalk tw = TreeWalk.forPath(reader, path, fromCommit.getTree())) { if (tw == null) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); return; } 
<|del|> 
<|del|> 
 private static int getPluginsLoadTimeout(Config cfg) { 
 try { if (refreshHeaderFooter && p.isStale()) { p = new Page(); page = p; 
 parentCommits.add(copyLabel); addLinks(project, c, parentWebLinks); 
/** * Thrown if a goal exceeds the configured reduction limit. * * @see com.googlecode.prolog_cafe.lang.PrologControl#setReductionLimit(long) */ 
 private void syncDisabledPlugins(SetMultimap<String, Path> jars) { 
 public ProjectApi create(ProjectInput in) throws RestApiException { 
Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 public static void initLogSystem(Path sitePath, String logName, String pattern) throws IOException { 
 .that(Url.decode(info.id)) .isEqualTo(info.name); 
 Files.createDirectories(ruleDir); 
<|del|> 
 try { @SuppressWarnings("resource") PushbackReader in = (PushbackReader) stream; 
 ref.getUUID())); 
<|del|> 
 popup: function(e){ this._p=@com.google.gerrit.client.api.PopupHelper::popup( Lcom/google/gerrit/client/api/ActionContext;Lcom/google/gwt/dom/client/Element;)(this,e)}, 
 + format("VALUES('%s', '%s', '%s')", projectName.get(), new Timestamp(event.eventCreatedOn * 1000L), json)); 
 /* final */LibraryDownloader db2Driver; /* final */LibraryDownloader db2DriverLicense; 
import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth8.assertThat; 
<|del|> 
 } } 
 modules.add( new AbstractModule() { @Override protected void configure() { bind(Path.class) .annotatedWith(SitePath.class) .toProvider(SitePathFromSystemConfigProvider.class) .in(SINGLETON); } }); 
 .setNameFormat("Diff-%d").setDaemon(true).build()); 
 writer.getIndexWriter().close(); } catch (AlreadyClosedException e) { // Ignore. 
 TestRepository<?> subRepo = cloneProject(subscribedProject, sshSession); grant(Permission.PUSH, subscribedProject, "refs/heads/*"); 
 String url = cfg.getString("remote", "origin", "url"); 
 RevWalk superRW = superRepo.getRevWalk(); 
 assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse(); } 
import static com.ericsson.gerrit.plugins.eventslog.EventsLogConfig.DEFAULT_CONN_TIME; 
<|del|> 
 ProjectState projectState = destRefControl.getProjectControl().getProjectState(); 
 String submittable(); String tabPanel(); 
<|del|> 
 } catch (OrmException | IOException e) { 
 cs = mergeSuperSet.completeChangeSet(db, cd.change(), resource.getUser()); 
 String changeId = createChangeWithTopic().getChangeId(); 
 testRepo.reset("HEAD~2"); submit(createChangeWithTopic(testRepo, "off_topic", "rewriting file b", 
 assertThat(info.title).isEqualTo( "Clicking the button would fail for other changes in the topic."); 
<|del|> 
<|del|> 
<|del|> 
 private void createSubscription( TestRepository<?> repo, String branch, String subscribeToRepo, String subscribeToBranch) throws Exception { 
 // The submodule subscription module checks for gerrit.canonicalWebUrl to // detect if it's configured for automatic updates. It doesn't matter if // it serves from that URL. 
 return true; 
 private static String buildSubmoduleSection(String name, 
 public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { 
public class ActionsIT extends AbstractDaemonTest { 
<|del|> 
 : 0); 
 } catch (IOException | ConfigInvalidException e) { 
 private static Set<RevCommit> alreadyAccepted(RevWalk rw, Iterable<Ref> refs) throws MissingObjectException, IOException { 
 AutoTopicListener(Provider<ReviewDb> db) { this.dbProvider = db; } 
 ChangeAttribute change = ((PatchSetCreatedEvent) event).change; if (change.topic != null) { 
 Matcher matcher = pattern.matcher(change.commitMessage); 
 } if (f == ArchiveFormat.ZIP) { throw new MethodNotAllowedException("zip format is disabled"); } 
<|del|> 
 QueryList.parse(L_BAD, null); fail("Expected exception"); 
 // Expected 
 ql = QueryList.parse(asText, null); asText = ql.asText(); assertThat(asText).isEqualTo(expectedText); 
<|del|> 
<|del|> 
<|del|> 
 if (lifecycle != null) { lifecycle.stop(); } 
 schemaFactory = InMemoryDatabase.newDatabase(); 
 lifecycle = new LifecycleManager(); 
 if (lifecycle != null) { lifecycle.stop(); } 
 void removeMembers(String... members) throws RestApiException; 
 void removeGroups(String... groups) throws RestApiException; 
 throw new RestApiException("Cannot remove group members", e); 
 throw new RestApiException("Cannot remove group members", e); 
<|del|> 
 Modes.I.puppet(), Modes.I.python(), 
<|del|> 
<|del|> 
<|del|> 
 Panel p, ChangeInfo change) { 
<|del|>
 public static final String VERSION = "2.10.3"; 
 OAuthProtocol oauth, @PluginName String name) { 
 Exports.named("github")).to(GitHubOAuthServiceProvider.class); 
 fileTable.registerKeys(); 
<|del|> 
 private static AtomicInteger contentCounter = new AtomicInteger(0); 
 private static AtomicInteger contentCounter = new AtomicInteger(0); 
<|del|> 
 String url = cfg.getString("gerrit", null, "canonicalWebUrl") + "/" + subscribeToRepo; 
<|del|> 
import static com.google.common.truth.Truth.assertThat; 
<|del|> 
 * matching which can be specified by ending the name with a {@code *}. 
 * SubSection can use the * pattern so if project name matches more than one 
 Iterable<Ref> refs = Iterables.concat( 
 RefDatabase refDb = repo.getRefDatabase(); for (Ref r : Iterables.concat( refDb.getRefs(Constants.R_HEADS).values(), refDb.getRefs(Constants.R_TAGS).values())) { 
 public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException { 
 ru.setExpectedOldObjectId(edit.getRef().getObjectId()); 
 ru.setExpectedOldObjectId(edit.getRef().getObjectId()); 
<|del|> 
 private static Set<Change.Id> editsForProject(Arguments args, IdentifiedUser user, String project) throws QueryParseException { 
 public static String refsEditPrefix(Account.Id accountId) { return refsUsers(accountId) + '/' + EDIT_PREFIX; } 
<|del|> 
<|del|> 
 @Override 
 log.error("Error running hook " + hook.toAbsolutePath(), err); 
<|del|> 
 .timestamp(new Date(TimeUtil.nowMs())) 
 Set<SubmoduleSubscription> alreadySubscribeds = new HashSet<>(); 
import com.google.gerrit.reviewdb.client.PatchSetApproval; import com.google.gerrit.reviewdb.client.Project; 
 public RepositoryConfig(@GerritServerConfig Config cfg) { 
 .setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))) .call(); 
 expectToHaveSubmoduleState(superRepo, "master", 
 expectToHaveSubmoduleState(superRepo, "master", 
 + " Setting lastest revision %s as current patch set.", 
 + " Setting lastest revision %s as current patch set.", 
 PageLinks.toChangeQuery(queryOutgoing(who)))); 
<|del|> 
 redirectToken = null; 
 private final boolean slave; 
 if (slave) { 
 DynamicSet.bind(binder(), GitReferenceUpdatedListener.class) .to(SearchingChangeCacheImpl.class); 
 try (Repository repo = repoManager.createRepository(projectA)) { assertThat(repo).isNotNull(); } try (Repository repo = repoManager.openRepository(projectA)) { assertThat(repo).isNotNull(); } assertThat(repoManager.list()).containsExactly(projectA); 
 try (Repository repo = repoManager.createRepository(projectA)) { assertThat(repo).isNotNull(); } 
 gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).rebase(ri); 
 public void onClose(CloseEvent<PopupPanel> event) { super.onClose(event); 
Copyright (C) 2015 The Android Open Source Project 
 newSubscriptions = subSecParserFactory.create(bbc, thisServer, target) .parseAllSections(); } else { newSubscriptions = Collections.emptyList(); } 
 private static final String KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE = "copyAllScoresIfNoCodeChange"; 
 private static final char endl = '\n'; 
 private static final char endl = '\n'; 
 obj.add(key, list); 
 stdout.print(obj.toString() + endl); 
@RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER) @CommandMetaData(name = "list", description = "List specific remote destinations information") 
 private boolean matches(String name) { if ( Strings.isNullOrEmpty(remote)) { 
 private boolean matches(String name) { if ( Strings.isNullOrEmpty(remote)) { 
 private void addProperty(JsonObject obj, String key, String[] values) { 
<|del|> 
<|del|> 
 if (Strings.isNullOrEmpty(remote)) { 
 try (BatchUpdate bu = updateFactory.create( db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) { 
<|del|> 
<|del|> 
 return new IndexSearcher(DirectoryReader.open(idx)); 
 return new IndexSearcher(DirectoryReader.open(idx)); 
 private static void addAccount(IndexWriter writer, Account a, ReviewDb db) 
 doc.add(new IntField(ID, a.getId().get(), Store.YES)); 
<|del|> 
<|del|> 
 assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo( SC_NO_CONTENT); 
 ReviewerSuggestionCache(Provider<ReviewDb> db, 
 assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P); assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B); 
 String expectedText = HEADER + "#\n" + F_PROPER; 
 Boolean enabled; try { enabled = cd.isMergeable(); } catch (OrmException e) { throw new OrmRuntimeException("Could not determine mergeability", e); } 
 return CHANGES_NOT_MERGEABLE; 
 List<DiffWebLinkInfo> links = 
 ReviewerSuggestionCache(Provider<ReviewDb> db, 
 VisibilityControl visibilityControl) throws IOException, OrmException { 
 if (request.getParameter("link") != null) { oauthSession.setLinkMode(true); 
 IPluginManager pluginManager, INotificationManager notificationManager, IUserManager userManager, IRepositoryManager repositoryManager) { 
 gitWeb.string("Link name", "linkname", "GitBlit"); } private void initGitBlitPluginConfig() { 
 pluginCfg.string( "\"Browse\" submenu title for the \"Projects\" top-level menu", "browse", "Browse", true); // If everything is at the default, then make sure we don't have the section // at all. 
 public Boolean binary; 
 protected transient String commitIdA; protected transient String commitIdB; 
 public static enum IntraLineStatus { 
 public static enum IntraLineStatus { 
 aId == null ? null : aId.getName(), bId == null ? null : bId.getName()); 
 gApi.changes().id(changeId).revision(rev).comments(); 
 * which is not necessarily the same as the change's project. 
 commit.name(), changeId, change.getKey().get())); 
 AccountInfo info = new AccountInfo( doc.getField(ID).numericValue().intValue()); 
 void evict(Project.NameKey p); 
 this.repoSizeCache = repoSizeCache; 
 repoSizeCache.evict(new Project.NameKey(event.getProjectName())); 
 reviewers = suggestReviewers(changeId, user1.username + " example"); 
 } public final boolean isOAuth() { return authType() == AuthType.OAUTH; } 
<|del|> 
 reviewers = suggestReviewers(changeId, "first1 last2"); 
 } private void display(JsArrayString hashtags) { hashtagsText.setInnerSafeHtml(formatHashtags(hashtags)); } 
 Window.open(Gerrit.getServerInfo().auth().editFullNameUrl(), "_blank", null); 
 info = new Grid( (Gerrit.getServerInfo().auth().siteHasUsernames() ? 1 : 0) + 4, 2); 
 assertWithMessage("submodule subscription update should have made one commit") .that(superRepo.getRepository().resolve("origin/master^")) .isEqualTo(superPreviousId); 
Copyright (C) 2008 The Android Open Source Project 
 * @param branch the branch name key 
 * @param branch the branch name key 
 if (!Gerrit.info().auth().canEdit(FieldName.USER_NAME) 
 if (Gerrit.info().gerrit().isAllProjects(projectAccess.getProjectName()) 
 public final native String all_projects() /*-{ return this.all_projects; }-*/; public final native String all_users() /*-{ return this.all_users; }-*/; 
 public final native String all_projects() /*-{ return this.all_projects; }-*/; public final native String all_users() /*-{ return this.all_users; }-*/; 
 public final native ContactStoreInfo contact_store() /*-{ return this.contact_store; }-*/; 
<|del|> 
 public Boolean allowDrafts; 
Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 public final native String all_projects() /*-{ return this.all_projects; }-*/; public final native String all_users() /*-{ return this.all_users; }-*/; 
 // don't let user shoot himself in the foot. 
 for (GarbageCollectorListener l : listeners) { try { l.onGarbageCollected(event); } catch (RuntimeException e) { log.warn("Failure in GarbageCollectorListener", e); } 
 && !self.get().getCapabilities().canModifyAccount()) { throw new AuthException("restricted to members of Modify Accounts"); 
 List<CommentInfo> formatAsList(Iterable<PatchLineComment> l) throws OrmException { 
 * @param cfg config in which the values should be stored 
 * @param cfg config in which the values should be stored 
 * @param s instance of class with config values 
 } else if (t.isEnum()) { 
 * @param cfg config from which the values are loaded 
 * @param s instance of class in which the values are set 
 if (isString(t)) { 
 } else if (t.isEnum()) { 
 return Integer.class == t || int.class == t; 
<|del|> 
<|del|> 
 assertThat(out.id).isEqualTo(d.id); 
 assertThat(out.ld).isEqualTo(d.ld); 
 assertThat(out.sd).isEqualTo(d.sd); 
 * Wrapper around a Logger that also logs out the replication state. 
 LOGGER.warn(MSG("Connection closed. Cause: {}"), cause.getMessage()); 
 .timestamp(new Date(TimeUtil.nowMs())) 
 public WalkSorter includePatchSets(Iterable<PatchSet.Id> patchSets) { Iterables.addAll(includePatchSets, patchSets); 
 sortedByProject.add(sortProject(e.getKey(), e.getValue())); 
 return byCommit; 
 patchSetData(cd2, c2_2))); 
 LOGGER.warn("Cannot access field {}. Cause: {}", f.getName(), ex.getMessage()); 
 assertThat(out.matchBrackets).isTrue(); 
 i.matchBrackets = true; 
 } catch (IllegalAccessException ex) { LOGGER.warn("Cannot access field {}. Cause: {}", f.getName(), ex.getMessage()); 
 * @throws IOException if accessing the repository fails. 
 * allowed. * @throws IOException if accessing the repository fails. * @throws OrmException if accessing the database fails. 
 * allowed. * @throws IOException if accessing the repository fails. * @throws OrmException if accessing the database fails. 
 my.add(new TopMenu.MenuItem("Edits", "#/q/has:edit", null)); 
 RevWalk rw = new RevWalk(repo)) { rw.setRetainBody(retainBody); 
<|del|> 
public interface IncludedIn { 
 * * The tags and branches in which the commit is included are provided so that * a RevWalk can be avoided when a system runs a certain tag or branch. * 
 List<String> getIncludedIn(String project, String commit, 
<|del|> 
 RefControl refControl = rsrc.getControl().controlForRef(refName); if (!refControl.canUpload() || !refControl.canRead()) { throw new AuthException("cannot upload review"); } Project.NameKey project = rsrc.getNameKey(); 
 try (Repository repo = repoManager.openRepository(project); RevWalk revWalk = new RevWalk(repo); ObjectInserter inserter = repo.newObjectInserter()) { 
Copyright (C) 2015 The Android Open Source Project 
 log.error("Unable to delete replication error status " 
<|del|> 
 JsArrayString external = r.external(n); if (external.length() > 0) { appendRow(n, external); } 
 bind(ReplicationStatusStore.class).to(ReplicationStatusFlatFile.class) .in(Scopes.SINGLETON); 
 public ReplicationErrorListener(ReplicationStatusStore statusStore) { 
<|del|>
 .in(Scopes.SINGLETON); 
 public ChangeScreen(Change.Id changeId, String base, String revision, boolean openReplyBox, FileTable.Mode mode) { 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 ReviewersAndFilters matched = findReviewers(sections, changeData); Set<String> reviewers = matched.reviewers; 
<|del|> 
 * the user. Only supported if {@link #noConfirmation} is set or if the 
 List<Predicate<ChangeData>> predicates = new ArrayList<>(ids.size()); 
 */ @Deprecated 
 if (schema.hasField(EXACT_TOPIC)) { return schema.getFields().get(EXACT_TOPIC.getName()); 
 if (t == null && getField() == ChangeField.LEGACY_TOPIC2) { 
 public InternalChangeQuery setRequestedFields(Set<String> fields) { qp.setRequestedFields(fields); return this; 
 inserter.setUploader(edit.getUser().getAccountId()); 
 assertEquals(RefUpdate.Result.NEW, modifier.createEdit( change, ps)); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile( editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW)); 
 assertThat(editUtil.byChange(change).isPresent()).isFalse(); 
 assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))) .isEqualTo(RefUpdate.Result.FORCED); 
 assertThat(gApi.config().server().getVersion()) .isEqualTo(Version.getVersion()); 
 assertThat(gApi.config().server().getVersion()) .isEqualTo(Version.getVersion()); 
 assertThat(gApi.config().server().getVersion()) .isEqualTo(Version.getVersion()); 
 assertThat(gApi.config().server().getVersion()) .isEqualTo(Version.getVersion()); 
 assert_() .withFailureMessage(errorMessage) .that(url).isNotNull(); 
 suggestions.add("commentby:"); suggestions.add("from:"); 
 suggestions.add("commentby:"); suggestions.add("from:"); 
public class ConfigImpl implements Config { 
 private boolean isInRange(short value, List<LabelValue> values) { 
 public final native boolean linkDrafts() /*-{ return this.link_drafts || false; }-*/; public final native boolean urlEncode() /*-{ return this.url_encode || false; }-*/; 
 public final native boolean linkDrafts() /*-{ return this.link_drafts || false; }-*/; public final native boolean urlEncode() /*-{ return this.url_encode || false; }-*/; 
 public final native boolean linkDrafts() /*-{ return this.link_drafts || false; }-*/; public final native boolean urlEncode() /*-{ return this.url_encode || false; }-*/; 
 public final native GitWebTypeInfo type() /*-{ return this.type; }-*/; 
 try (ManualRequestContext ctx = oneOffRequestContext.open()) { 
 if (addToLocal) { local.add(right); } else { inherited.add(right); } 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public static final String MSG = "Error in events-log plugin"; 
 private static final Logger log = LoggerFactory .getLogger(EventsRestApiServlet.class); 
 log.error("Bad Request", e); 
 public void badParameters() throws Exception { 
 class SQLEntry implements Comparable<SQLEntry> { 
 EasyMock.anyObject(CurrentUser.class))) .andThrow(new NoSuchProjectException(projectMock)); 
Copyright (C) 2015 The Android Open Source Project 
 ChangeControl.GenericFactory changeControlFactory, 
<|del|> 
<|del|> 
 try (ObjectReader or = repo.newObjectReader()) { 
<|del|> 
 List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp); 
 BatchUpdate.execute( orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits)); 
 private boolean validRefOperation(ReceiveCommand cmd) { 
import com.google.gerrit.server.events.RefReceivedEvent; 
 change = abandon(control, input.message, caller.getAccount()); 
 private static final Logger log = LoggerFactory.getLogger(AbandonUtil.class); 
 try { abandon.abandon(changeControl(cd), cfg.getAbandonMessage(), null); } catch (ResourceConflictException e) { // Change was already merged or abandoned. } 
 return changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())); 
 Lifecycle(WorkQueue queue, ChangeCleanupRunner runner, 
 public void testIsEnabledEventMultiBranchExact() { String[] branches = {"refs/heads/foo", "refs/heads/testBranch"}; 
 protected List<WebLinkInfoCommon> fileHistoryLinks; 
 return fileHistoryLinks; 
 webLinks.getFileHistoryLinksCommon(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG); 
 if (!(obj instanceof RevCommit)) { 
 new DevServer(GitilesConfig.defaultFile()).start(); 
 if (!Strings.isNullOrEmpty(issueId)) { 
 try (ReviewDb db = schema.open()) { AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, userName); return auth(db.accountExternalIds().get(key)); 
 try (ReviewDb db = schema.open()) { List<Account> matches = db.accounts().byPreferredEmail(email).toList(); return matches.size() == 1 ? auth(matches.get(0)) : null; 
 try (ReviewDb db = schema.open()) { return auth(db.accounts().get(id)); 
 final ReviewDb db = schema.open(); try { 
<|del|> 
 try (ReviewDb db = schema.open()) { final CurrentSchemaVersion currentVer = getSchemaVersion(db); final int expectedVer = SchemaVersion.getBinaryVersion(); 
<|del|> 
 /** Capabilities at least one of which is required to invoke this action. */ 
 "only site maintainers can flush %s", WEB_SESSIONS)); 
 "only site maintainers can flush %s", WEB_SESSIONS)); 
import com.google.common.collect.SetMultimap; import com.google.gerrit.common.Nullable; 
import com.google.gerrit.reviewdb.client.Project; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.CurrentUser; 
 if (user != null) { if (!cd.changeControl(user).isVisible(db, cd)) { hidden = true; continue; } 
 public ChangeSet(ChangeData change, ReviewDb db, @Nullable CurrentUser user) throws OrmException { this(ImmutableList.of(change), db, user); 
 problemChanges.add(id.getParentKey()); 
<|del|> 
 for (Branch.NameKey branch : cs.branchesByProject().get(project)) { 
 r.assertChange(Change.Status.NEW, null, admin); r.assertMessage(CommitMergeStatus.PATH_CONFLICT.getMessage()); 
 String msg = "Missing current patch set on change"; logError(msg + " " + changeId); commits.problem(changeId, msg); 
 commits.logProblem(changeId, e); 
<|del|> 
<|del|> 
 } catch (IOException | ConfigInvalidException e) { 
 final native void set_id(String i) 
 GitwebLink gw = Gerrit.getGitwebLink(); if (gw != null && (!info.has_change_number() || !info.has_revision_number())) { 
 GitwebLink gw = Gerrit.getGitwebLink(); if (gw != null && (!info.has_change_number() || !info.has_revision_number())) { 
<|del|> 
 if (input.generate || input.httpPassword == null) { 
 final native void generate(boolean g) /*-{ if (g) this.generate = g; }-*/; 
 for (Branch.NameKey branch : br.get(project)) { 
 public List<ChangeData> byCommitsOnBranch(Branch.NameKey branch, 
 ref(branch), project(branch.getParentKey()), 
 sig.update(Constants.encode(cert.toText())); if (!sig.verify()) { msgOut.write("Push certificate signature does not match\n"); rejectInvalid(commands); } 
<|del|> 
 p.retainHeader = retainHeader(); 
<|del|> 
<|del|> 
 try (Repository git = gitMgr.openRepository(allUsersName.get())) { 
 static final long serialVersionUID = 18L; 
 static { checkState(WHITESPACE_TYPES.size() == Whitespace.values().length); } 
<|del|> 
 try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement(); ResultSet rs = stmt.executeQuery( 
 ImmutableSetMultimap.Builder<Project.NameKey, Branch.NameKey> pbb = ImmutableSetMultimap.builder(); ImmutableSetMultimap.Builder<Project.NameKey, Change.Id> pcb = ImmutableSetMultimap.builder(); 
 public abstract ImmutableSet<Project.NameKey> projects(); 
 public abstract ImmutableSetMultimap<Project.NameKey, Branch.NameKey> branchesByProject(); public abstract ImmutableSetMultimap<Project.NameKey, Change.Id> changesByProject(); 
 public abstract ImmutableSetMultimap<Project.NameKey, Branch.NameKey> branchesByProject(); public abstract ImmutableSetMultimap<Project.NameKey, Change.Id> changesByProject(); 
 ChangeSet cs = mergeSuperSetFactory .create(changes, Submit.wholeTopicEnabled(cfg)) .completeChangeSet(); 
 logDebug("Write out the new branch tips"); for (Project.NameKey project : cs.projects()) { 
 * Calculates the minimal superset of changes required to be merged. 
<|del|> 
<|del|> 
 GitRepositoryManager repoManager) { 
 for (Project.NameKey project : changes.projects()) { 
 SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType(); 
 // Collect unmerged ancestors 
 rw.reset(); rw.sort(RevSort.TOPO); 
<|del|> 
 for (Change.Id cId : newCs.ids()) { // TODO(sbeller): Cache the change data here and in completeChangeSet // There is no need to reread it a few times. 
 chgs.add(addCd.change()); 
 chgs.add(addCd.change()); 
 r.append(accountId.get()); r.append('-'); 
 + path, cfg.getUrlOptions()); 
<|del|> 
 throw new IllegalStateException(e); 
 return cfg.getBoolean("receive", null, "enableSignedPush", false); 
 editUtil.publish(edit.get()); 
 private static final PrettifyParser parser = new Parser(); 
 String query = "status:new age:" 
 // Change was already merged or abandoned. } catch (Throwable e) { log.error(String.format( "Failed to auto-abandon inactive open change %d.", cd.getId().get()), e); 
 log.warn(String.format( "Ignoring invalid changeCleanup schedule configuration: %s", scheduleConfig)); 
 query += " -is:mergeable"; 
 abandonIfMergeable = cfg.getBoolean(SECTION, null, KEY_ABANDON_IF_MERGEABLE, true); 
 logDebug("Submitting all calculated changes while " 
 .open("span").close("span") .close("a"); 
 private static String projectBaseName(String project) { 
<|del|> 
 log.error("Failed to query inactive open changes for auto-abandoning.", e); 
 } catch (IllegalArgumentException | NoSuchGroupException e) { // Ignored 
<|del|> 
 Set<String> allJails = new HashSet<>(Arrays.asList(cfg.getStringList(KEY_JAIL))); Set<String> allProtectorates = new HashSet<>(Arrays.asList(cfg.getStringList(KEY_PROTECTORATE))); 
 Set<String> allJails = new HashSet<>(Arrays.asList(cfg.getStringList(KEY_JAIL))); Set<String> allProtectorates = new HashSet<>(Arrays.asList(cfg.getStringList(KEY_PROTECTORATE))); 
 logError("The gitLinks were not updated according to the" + "subscriptions", e); 
 logError("The gitLinks were not updated according to the" + "subscriptions", e); 
 branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName())); 
 void updateSubmoduleSubscriptions(ReviewDb db, Set<Branch.NameKey> branches) 
<|del|> 
 void updateSubmoduleSubscriptions(ReviewDb db, Set<Branch.NameKey> branches) 
 try (Repository repo = repoManager.openRepository( destBranch.getParentKey()); RevWalk rw = new RevWalk(repo);) { 
 newSubscriptions = subSecParserFactory.create(bbc, thisServer, destBranch).parseAllSections(); 
 Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create(); 
<|del|> 
<|del|> 
 * @param updates The submodule updates which should be updated to. 
 protected RevCommit getRemoteHead(Project.NameKey project, String branch) throws IOException { 
 "We're interested in submitting this change", 
 "We're interested in submitting this change", 
 change3.getCommit().getShortMessage()); } else { assertThat(tip2.getShortMessage()).isEqualTo( initialHead2.getShortMessage()); assertThat(tip3.getShortMessage()).isEqualTo( initialHead3.getShortMessage()); 
 // Create a merge conflict for change3 which is only indirectly related // via topics. repo3.reset(initialHead3); 
 "This commit is based on master, which includes change2, " 
 "This commit is based on change2 pending for master, " 
 "some accompanying changes for change3a in another repo " 
 RevCommit tipbranch = getRemoteLog(project, "branch").get(0); assertThat(tipbranch.getShortMessage()).isEqualTo( 
 private static final Logger log = LoggerFactory.getLogger(SubmittedTogether.class); private final ChangeJson json; 
 throw e; 
 dir.mkdir(); 
 ChangeApi.change(info.legacyId().get()).view("submitted_together") .get(new TabChangeListCallback(Tab.SUBMITTED_TOGETHER, info.project(), revision)); 
 Iterables.transform(actual, new Function<ChangeInfo, String>() { @Override public String apply(ChangeInfo input) { return input.changeId; } })).inOrder(); 
 List<ChangeData> changes) throws OrmException, IOException { 
<|del|> 
 assertThat(Arrays.asList(expected)) .containsExactlyElementsIn( Iterables.transform(actual, new Function<ChangeInfo, String>() { @Override public String apply(ChangeInfo input) { return input.changeId; } })).inOrder(); 
 private RevCommit getRemoteHead() throws IOException { 
<|del|> 
 private static final Logger log = LoggerFactory.getLogger( SubmittedTogether.class); 
 private static final Logger log = LoggerFactory.getLogger( SubmittedTogether.class); 
<|del|> 
 * Optimize the storage by unsetting a variable if it is set to * the server default. 
 } accountLoader.fill(); 
 Config(@PluginName String pluginName, PluginConfigFactory cfgFactory) { 
 gApi.changes().id(changeId).revision(rev).comments(); 
 updatePatchSetsTextStyle(isPatchSetCurrent); 
import com.google.gerrit.extensions.common.ChangeInfo; import com.google.gerrit.extensions.restapi.BadRequestException; 
 ValidationException { 
 if(last != null && Boolean.TRUE.equals(last._moreChanges)) { start += DEFAULT_MAX_QUERY_LIMIT; } else { 
 new FieldDef.Single<ChangeData, Integer>("_id", 
 start, limit); start += changes.size(); 
<|del|> 
 start, limit); if(changes.isEmpty()) { break; } 
 if(!Boolean.TRUE.equals(last._moreChanges)) { 
<|del|> 
<|del|> 
 assertWithMessage("submodule subscription update " + "should have made one commit") .that(superRepo.getRepository().resolve("origin/master^")) .isEqualTo(superPreviousId); 
 assertWithMessage("submodule subscription update " + "should have made one commit") .that(superRepo.getRepository().resolve("origin/master^")) .isEqualTo(superPreviousId); 
 logDebug("Updating submodule subscriptions for branch {}", destBranch); 
 private void updateSuperProjects(SubmoduleOp subOp, Set<Branch.NameKey> branches) { 
 logError("The gitlinks were not updated according to the " 
 branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName())); 
 log.error("Can't update submodule subscriptions" + "or update the superprojects", e); 
<|del|> 
 void updateSubmoduleSubscriptions(ReviewDb db, Set<Branch.NameKey> branches) 
 try (Repository repo = repoManager.openRepository( destBranch.getParentKey()); RevWalk rw = new RevWalk(repo);) { 
 protected void updateSuperProjects(ReviewDb db, Set<Branch.NameKey> updatedBranches) throws SubmoduleException { try { 
 Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create(); 
 updatedSubscribers.addAll(updatedBranches); // Update subscribers. 
 updatedSubscribers.addAll(updatedBranches); // Update subscribers. 
 updatedSubscribers.addAll(updatedBranches); // Update subscribers. 
 log.warn("Cannot update gitlinks for " + dest + " due to " + e.getMessage(), e); 
 log.warn("Cannot update gitlinks for " + dest + " due to " + e.getMessage(), e); 
 * Update the submodules in one branch of one repository. 
 * @param updates submodule updates which should be updated to. 
 private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, 
 StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n"); 
<|del|> 
<|del|> 
 // the full submodule history to the commit message, so omit it. 
 msgbuf.append(c.getFullMessage() + "\n\n"); 
 } } 
 ObjectId currentCommitId = 
 protected void addSubscriptionEntry(Config config, String subscribeToRepo, 
public class HelloWeblink { private static String name = "HelloLink"; private static String myImageUrl = "http://placehold.it/16x16.gif"; private static String placeHolderUrlProject = 
 log.error("Unable to create directory " + dir, e); 
 if (running.compareAndSet(false, true)) { Thread t = new Thread() { @Override public void run() { try { reindex(); } finally { running.set(false); } 
 ADD_USER, REMOVE_USER, ADD_GROUP, REMOVE_GROUP 
 return ConfigUtil.getTimeUnit(gerritConfig, "cache", "web_sessions", "maxAge", MAX_AGE_MS, MILLISECONDS); 
 log.error("Can't update submodule subscriptions " 
 RevWalk rw = new RevWalk(repo)) { 
 log.warn("Cannot update gitlinks for " + dest, e); 
 final ObjectId updateTo = ref.getObjectId(); RevCommit newCommit = rw.parseCommit(updateTo); 
<|del|> 
 assertThat(Files.exists(fileToDelete)).isTrue(); 
 public void invalidateTestObjectNotString() throws Exception { createKeysCollection(); assertThat(flatFileWebSessionCache.size()).isEqualTo(DEFAULT_KEYS_SIZE); 
 entry4 = new SQLEntry("name4", timestamp, "event4", Integer.MAX_VALUE); 
 entry4 = new SQLEntry("name4", timestamp, "event4", Integer.MAX_VALUE); 
 return 31 + id; 
// Licensed under the Apache License, Version 2.0 (the "License"); 
 assertThat(entry1.equals(entry2)).isFalse(); assertThat(entry1.equals(entry4)).isTrue(); 
 this( cfg, serverIdent, anonymousCowardName, migration, accountCache, updateManagerFactory, draftUpdateFactory, robotCommentUpdateFactory, deleteCommentRewriterFactory, ctl, 
 @AnonymousCowardName String anonymousCowardName, GitRepositoryManager repoManager, 
/** A KeyCommand that does nothing, used to display a help message */ 
/** Collapses common regions with {@link SideBySideSkipBar} for {@link SideBySide}. */ 
/** Collapses common regions with {@link SideBySideSkipBar} for {@link SideBySide} * and {@link Unified}. */ 
class UnifiedSkipBar extends Composite implements SkipBar { 
 protected void prepareSubscriptionConfigEntry(Config config, String subscribeToRepo, String subscribeToBranch) { 
 protected void beforeTest(Description description) throws Exception { 
<|del|> 
 /** Get audit log of a group. */ 
 RobotCommentUpdate.Factory robotCommentUpdateFactory, DeleteCommentRewriter.Factory deleteCommentRewriterFactory, 
 Object obj = it.next(); if (obj instanceof PGPPublicKeyRing) { keys.add((PGPPublicKeyRing) obj); } checkState(!it.hasNext(), "expected one PGP object per ArmoredInputStream"); } 
 notes = NoteMap.read(reader, rw.parseCommit(ref.getObjectId())); 
<|del|> 
<|del|> 
 assertSubmitter(change.getChangeId(), 1); assertAuthor(head, admin.getIdent()); assertCommitter(head, admin.getIdent()); 
 assertNoSubmitter(change2.getChangeId(), 1); 
 assertNoSubmitter(change3.getChangeId(), 1); 
 assertThat(log.get(0)).isEqualTo(initialHead.getId()); assertNoSubmitter(change3.getChangeId(), 1); 
 change3Conflict.getCommit().getShortMessage()); assertNoSubmitter(change2a.getChangeId(), 1); assertNoSubmitter(change2b.getChangeId(), 1); assertNoSubmitter(change3.getChangeId(), 1); 
 ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto); 
 ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto); 
 assertSubmitter(change2.getChangeId(), 2); assertPersonEquals(admin.getIdent(), newHead.getAuthorIdent()); // TODO: Check the committer, too. // assertPersonEquals(admin.getIdent(), newHead.getCommitterIdent()); 
 @Column(id = 7) 
<|del|> 
<|del|> 
<|del|> 
 ADD_USER, REMOVE_USER, ADD_GROUP, REMOVE_GROUP 
 * Register a panel for a UI extension point. 
 .append(username.get()) 
 public void onSuccess(PreferencesInfo result) { LabelUIPlugin.refreshDefaultLabelUi(result.ui()); 
 ChildCollection<ConfigResource, QuotaResource> { 
 @Option(name = "--prefix", aliases = {"-p"}, metaVar = "PREFIX", usage = "match project prefix") 
 if (scheme instanceof SshScheme) { 
 .append("/.git/hooks/") .toString(); 
 .append("/.git/hooks/") .toString(); 
 private static final String CHANGES_NOT_MERGEABLE = "See the \"Submitted Together\" tab for problems"; 
 .setLabel(submitTopicLabel) 
 maven = buckOutIdx == 0; standalone = checkStandalone(basePath); if (maven) { 
 * @throws RestApiException if id is not account ID or is a user that isn't known to be a reviewer * for this change. 
 * @throws RestApiException if id is not account ID or is a user that isn't known to be a reviewer * for this change. 
 if (partialPath.endsWith("gerrit/" + BUCKOUT)) { 
 "(${submitSize} changes including ancestors and their " + "topic related changes. ${numberTopics} different topics altogether)"; 
 private static final native NativeMap<NativeString> settingsScreens() /*-{ return $wnd.Gerrit.settingsScreens; }-*/; 
 // Disable JavaScript clipboard and try flash movie in another instance. 
 boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled(); final Grid formGrid = new Grid(10 + (flashClippy ? 1 : 0), 2); 
 installed = hasFlash(); checked = true; 
<|del|> 
<|del|> 
 if (this == obj) { return true; 
 if (!(obj instanceof AccessToken)) { return false; } return Objects.equals(value, ((AccessToken) obj).value); 
 if (response.getCode() != HTTP_OK) { 
 if (response.getCode() != HTTP_OK) { 
 gApi.changes().id(r.getChangeId()).revert(); 
 void deleteVote(String label) throws RestApiException; 
 final ReplicationSshSessionFactory sshSessionFactory) { 
<|del|> 
 "(${submitSize} changes including ancestors and other " + "changes related by topic)"; 
 "(${submitSize} changes including ancestors and other " + "changes related by topic)"; 
 short changesPerPage = 
<|del|> 
 return pat.replace(token, Gerrit.info().urlAliasToken(urlAliasMatch)); 
/** Dialect for <a href="https://db.apache.org/derby//">Apache Derby</a> */ 
<|del|> 
 DriverManager.getConnection(CONNECT + ";drop=true"); 
 } 
 LegacyChangeIdPredicate(Schema<ChangeData> schema, Change.Id id) { super(idField(schema), ChangeQueryBuilder.FIELD_CHANGE, id.toString()); 
 private void submit(String changeId, int expectedStatus) throws IOException { 
<|del|> 
<|del|> 
 id1 + "], which could not be submitted because:\n" + id1 + ": needs Code-Review;"); 
 @Singleton 
 Timestamp ts = _getRegisteredOn(); if (ts == null) { ts = JavaSqlTimestamp_JsonSerializer.parseTimestamp(registeredOnRaw()); _setRegisteredOn(ts); } return ts; 
 btmmenu.add(new InlineLabel(C.keyHelp())); 
 return PageLinks.toChangeQuery("is:starred"); 
 private static final Logger logger = LoggerFactory.getLogger(PingHandler.class); 
 private static final long serialVersionUID = 1L; 
 public WebhookServlet(UserScopedProvider<GitHubLogin> loginProvider, ScopedProvider<GitHubLogin> requestScopedLoginProvider, Injector injector, GitHubConfig config, DynamicItem<WebSession> session) { 
 "Cannot login to github as {}. {}.webhookUser is not correctly configured?", 
 * @return true if webhook secret is not configured or signatureHeader is * valid against payload and the secret, false if otherwise. 
 void doAction(T payload, HttpServletRequest req, HttpServletResponse resp) throws IOException; 
 private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) { 
 FluentIterable.from(doc.get(REVIEWER_FIELD)) 
 Predicate.and(new LegacyChangeIdPredicate( index.getSchema(), object.getId()), this), 0, 1).read()) { 
 Predicate<ChangeData> thisId = new LegacyChangeIdPredicate(index.getSchema(), cd.getId()); Iterable<ChangeData> results = index.getSource(and(thisId, this), 0, 1).read(); 
 private static List<Predicate<ChangeData>> predicates( Schema<ChangeData> schema, Set<Change.Id> ids) { 
 Predicate.and(new LegacyChangeIdPredicate( index.getSchema(), object.getId()), this), 0, 1).read()) { 
 } return null; 
 @NoHttpd 
 // Change 2 depends on an outdated revision of change 1, which should 
 // so the error triggered should come from the outdated revision. 
 throw new ResourceConflictException("Change " + cd.getId() + " is included with revision " + cd.getId() + " / " + cd.change().currentPatchSetId()); 
 throw new UnprocessableEntityException(String.format( "Branch %s does not exist.", refName)); 
 @Inject private AccountCache accountCache; 
 exception.expectMessage( "Cherry Pick: Parent 0 does not exist. Please specify a parent in range [1, 2]."); gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput); 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
 return ChangeField.getAuthorParts(object).contains(value); 
class FlatFileWebSessionCacheCleaner implements Runnable { 
 this.cleaner = cleaner; this.maxAge = maxAge; 
 assertThat(flatFileWebSessionCache.getAllPresent(keys)) .containsKey(existingKey); 
<|del|> 
 final Grid formGrid = new Grid(11 + (flashClippy ? 1 : 0), 2); 
<|del|> 
<|del|> 
 LoggerFactory.getLogger(BackupBranch.class); 
 public static final String USERNAME_CANNOT_BE_CHANGED = "Username cannot be changed."; 
 throw new ResourceConflictException("username already used"); 
 log.warn("Error trying to delete {} or its parents", trash, e); } finally { sendProjectDeletedEvent(project); 
 try { super.close(); } finally { repo.close(); } 
 "Failed to delete public key: " + saveResult); 
 toDelete.add(getRowItem(row).fingerprint()); 
<|del|> 
<|del|> 
<|del|> 
 + webUrl + "#" + PageLinks.SETTINGS_WEBIDENT); 
 private DynamicSet<AllRequestFilter> initializedFilters; 
 private DynamicSet<AllRequestFilter> initializedFilters; 
 exception.expect(UnprocessableEntityException.class); gApi.groups().id("Administrators").addMembers("non-existing"); 
<|del|> 
 long keyId = keyId(fp); 
 return NB.decodeInt32(fp, 4); 
<|del|> 
<|del|> 
<|del|> 
 public void onSuccess(NativeMap<GpgKeyInfo> result) { keyText.setEnabled(true); 
 public void onFailure(Throwable caught) { keyText.setEnabled(true); 
 CommitData cd = cdb .setRevWalk(walk) .setArchiveFormat(archiveFormat) .build(req, c, fs); 
 throw new RestApiException("Cannot delete GPG key", e); 
 return changeData.size(); 
<|del|> 
/** Base class for servlet tests. */ 
 repo = new TestRepository<DfsRepository>( new InMemoryRepository(new DfsRepositoryDescription("repo"))); 
 protected FakeHttpServletResponse buildResponse( String path, String queryString, int expectedStatus) 
 protected FakeHttpServletResponse buildResponse( String path, String queryString, int expectedStatus) 
 FakeHttpServletResponse res = buildResponse(path, "format=text", SC_OK); 
 FakeHttpServletResponse res = buildResponse(path, "format=json", SC_OK); 
 protected void assertNotFound(String path, String queryString) throws Exception { buildResponse(path, queryString, SC_NOT_FOUND); 
 public ImmutableSet<Change.Id> ids() { ImmutableSet.Builder<Change.Id> ret = ImmutableSet.builder(); 
 ret.put(cd.change().getProject(), cd.change().getDest()); 
 for (Change.Id id : cbb.get(branch)) { 
 })).inOrder(); 
 * <p> * This class is not thread safe. 
 * <p> * This class is not thread safe. 
 private ImmutableSet<ChangeData> changeData; 
 public List<Change.Id> ids() { List<Change.Id> ret = new ArrayList<>(); 
 for (Change.Id id : cs.changesByBranch().get(branch)) { 
import static org.easymock.EasyMock.eq; import static org.easymock.EasyMock.newCapture; 
 * This method adds the given filter to all 
 * This method adds the given filter to all 
 return links.isEmpty() ? null : links.toList(); 
 List<String> delete) throws RestApiException { 
 * @param prefix repository base path to list. Trailing "/" is implicitly * added if missing. Null or empty string will match all repositories. 
 String prefix = ViewFilter.getView(req).getRepositoryPrefix(); Map<String, RepositoryDescription> descs = list(req, res, prefix, parseShowBranch(req)); 
<|del|> 
 private static final Logger log = LoggerFactory.getLogger(AddSshKey.class); 
 } catch (EmailException e) { log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e); 
 private static final Logger log = LoggerFactory.getLogger(AddSshKey.class); 
 addedKeys.add(key); 
 public AddKeySender create(IdentifiedUser user, AccountSshKey sshKey); public AddKeySender create(IdentifiedUser user, List<PGPPublicKey> gpgKey); 
 @Assisted IdentifiedUser user, @Assisted AccountSshKey sshKey) { super(ea, "addkey"); 
 add(RecipientType.TO, new Address(getEmail())); 
 } else if (gpgKeys != null) { 
 log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e); 
 setHeader("Subject", String.format("[Gerrit Code Review] %s Key Added", getKeyType())); 
 } else if (gpgKey != null) { 
 return (sshKey != null) ? sshKey.getSshPublicKey() : null; 
 return (gpgKey != null) ? PublicKeyStore.keyToString(gpgKey) : null; 
<|del|> 
Copyright (C) 2015 Google Inc. All Rights Reserved. 
<|del|> 
 } catch (ConcurrentRefUpdateException e) { stderr.println(e.getMessage()); 
 } catch (OrmException | IOException | ConcurrentRefUpdateException x) { 
 } catch (OrmException | IOException | ConcurrentRefUpdateException x) { 
 CreateReviewNotes crn = reviewNotesFactory.create(db, project, git); crn.createNotes(changes, monitor); crn.commitNotes(); 
<|del|> 
 groupCache.onCreateGroup(IMPORTED_USERS_NAME); 
<|del|> 
 List<CommentLinkInfo> operationalCommentLinks = new ArrayList<>(commentLinks); 
 return Joiner.on("\n").join(gpgKeys); 
 PushCertificate cert = rp.getPushCertificate(); 
 private final DestinationList destinations = new DestinationList(); 
 static { 
 assertThat(branches).containsExactlyElementsIn(D_SIMPLE); 
 assertThat(text).isEqualTo(dl.asText(LABEL2)); 
<|del|> 
 return ChangeField.getAuthorParts(object).contains(value); 
 * Returns {@code true} if this set contains the given item. 
 * @param item item to check whether or not it is contained. * @return {@code true} if this set contains the given item. 
 // And now 4 should no longer be contained. assertThat(ds).doesNotContain(4); 
 try (TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree())) { 
 public boolean match(ChangeData object) throws OrmException { return ChangeField.getAuthorParts(object).contains( getValue().toLowerCase()); 
<|del|> 
 /** * The exact email address, or any part of the author name or email address, * in the current patch set. */ 
 /** * The exact email address, or any part of the committer name or email address, * in the current patch set. */ 
 public boolean match(ChangeData object) throws OrmException { return ChangeField.getAuthorParts(object).contains( getValue().toLowerCase()); 
 public boolean match(ChangeData object) throws OrmException { return ChangeField.getAuthorParts(object).contains( getValue().toLowerCase()); 
 public Predicate<ChangeData> reviewerin(String group) throws QueryParseException { 
 private static final String ZIP_TYPE = "application/zip"; private static final Random rng = new Random(); 
 private static final String ZIP_TYPE = "application/zip"; private static final Random rng = new Random(); 
 String decoration = randSuffix(); if (!Strings.isNullOrEmpty(suffix)) { decoration = suffix + '-' + decoration; } ZipEntry e = new ZipEntry(safeFileName(path, decoration)); 
 }.setContentType(ZIP_TYPE) .setAttachmentName(safeFileName(path, suffix) + ".zip") 
 }.setContentType(ZIP_TYPE) .setAttachmentName(safeFileName(path, suffix) + ".zip") 
<|del|> 
 Hasher h = Hashing.md5().newHasher(); 
 h.putBytes(buf); 
<|del|> 
<|del|> 
<|del|> 
 } MimeType contentType = registry.getMimeType(path, raw); return registry.isSafeInline(contentType) ? wrapBlob(project, path, obj, raw, contentType, side) : zipBlob(path, obj, commit, side); 
 } MimeType contentType = registry.getMimeType(path, raw); return registry.isSafeInline(contentType) ? wrapBlob(project, path, obj, raw, contentType, side) : zipBlob(path, obj, commit, side); 
 private BinaryResult zipBlob(final String path, final ObjectLoader obj, RevCommit commit, final @Nullable String side) { 
 }.setContentType(ZIP.toString()) .setAttachmentName(safeFileName(path, side) + ".zip") .setContentLength(-1) // it is not practical to determine this .disableGzip(); 
 .retainFrom(Strings.nullToEmpty(suffix))); 
 if (Gerrit.isSignedIn() && !schemeStr.equals(prefs.downloadScheme())) { 
 private final ImmutableCollection<ChangeData> changeData; 
<|del|> 
<|del|> 
 pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status, refUpdateStatus); 
 public void testChangeRefReplicated() throws URISyntaxException, OrmException { Change expectedChange = new Change(null, null, null, null, null); reset(changeAccessMock); expect(changeAccessMock.get(anyObject(Change.Id.class))).andReturn(expectedChange); replay(changeAccessMock); 
import com.google.common.base.Joiner; 
import static java.util.stream.Collectors.joining; import static org.eclipse.jgit.lib.Constants.OBJ_BLOB; 
 try (RevWalk rw = new RevWalk(git); RevWalk merged = new RevWalk(git)){ 
 @Option(name = "--user", aliases = {"-u"}, usage = "user for which the groups should be listed") 
 /** * This method will override Gerrit configuration index.name.commitWithin * until next Gerrit restart (or reconfiguration through this method). * * @param enable auto commit */ 
 problems.add("Invalid public key " + keyToString(signer) + ":\n " + Joiner.on("\n ").join(result.getProblems())); 
<|del|> 
 try (FileWriter unbufferedWriter = new FileWriter(ruleBaseFile); 
 try (FileWriter unbufferedWriter = new FileWriter(templateFile); 
import com.google.gerrit.extensions.client.EditPreferencesInfo; import com.google.gerrit.extensions.client.Theme; 
<|del|> 
<|del|> 
public class RefControlTest extends TestCase { private static void assertOwner(String ref, ProjectControl u) { assertTrue("OWN " + ref, u.controlForRef(ref).isOwner()); } 
 return ImmutableMap.of( "variant", variant, "entry", entry); 
 * Post a stream event that is related to a project. * 
abstract class PaginatedProjectScreen extends ProjectScreen { 
 protected abstract String getScreenToken(); 
<|del|> 
<|del|> 
 protected ListGroups(final GroupCache groupCache, 
<|del|> 
 private final EventDispatcher dispatcher; 
 groups = gApi.groups().list().withSuggest("Adm").getAsMap(); 
<|del|> 
<|del|> 
 } return a.run(ref); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } return false; 
 protected GitHubOAuthConfig( @GerritServerConfig Config config, CanonicalWebUrl canonicalWebUrl, AuthConfig authConfig) { this.config = config; this.canonicalWebUrl = canonicalWebUrl; 
 enabled = config.getString("auth", null, "type").equalsIgnoreCase(AuthType.HTTP.toString()); 
 } public String getRaw() { return raw; } public void setRaw(String raw) { this.raw = raw; } public OAuthToken toOAuthToken() { return new OAuthToken(accessToken, null, getRaw()); } 
 if (requestUri.endsWith(suffix)) { 
 if (user.isIdentifiedUser()) { 
 return new Text(str.getBytes()); 
<|del|> 
 * @param projectCache the project cache instance for the server. * @param accountCache the account cache instance for the server. * @param eventFactory the event factory. * @param dispatcher the event dispatcher. 
 * @param projectCache the project cache instance for the server. * @param unrestrictedListeners listeners to receive all events. 
 public void postEvent(Change change, Event event, ReviewDb db) throws OrmException { 
 * @param event The event to post. * @param db The database. 
<|del|> 
 return new RevisionResource( changeResourceFactory.create(rev.getNotes(), reviewer), rev.getPatchSet()); 
 private void checkLabels(RevisionResource rsrc, LabelTypes labelTypes, Map<String, Short> labels) throws BadRequestException, AuthException, PermissionBackendException { PermissionBackend.ForChange perm = rsrc.permissions(); 
 private void checkLabels(RevisionResource rsrc, LabelTypes labelTypes, Map<String, Short> labels) throws BadRequestException, AuthException, PermissionBackendException { PermissionBackend.ForChange perm = rsrc.permissions(); 
 private final LabelType P = category("CustomLabel2", 
 P.setFunctionName("AnyWithBlock"); 
 accountUpdates.add(a -> a.setPreferredEmail(newEmail)); 
 case LUCENE: case ELASTICSEARCH: 
Copyright 2015 The Android Open Source Project 
 @Override public String getCreateSequenceSql(SequenceModel seq) { final Sequence s = seq.getSequence(); final StringBuilder r = new StringBuilder(); r.append("CREATE SEQUENCE "); r.append(seq.getSequenceName()); 
Copyright 2015 The Android Open Source Project 
import static com.google.common.truth.Truth.assertThat; import static org.easymock.EasyMock.anyObject; import static org.easymock.EasyMock.expect; import static org.easymock.EasyMock.replay; 
 return baseInjector.createChildInjector(module).getInstance( GerritTopMenus.class); 
 assertThat(menuEntries).isNotEmpty(); 
 @Test public void testTopMenuForAnonymousUserShouldHaveAllThreeMenuEntries() { Collection<MenuEntry> entries = gerritTopMenusWithModule(anonymousUserModule).getTopMenuBar(null); Iterator<MenuEntry> entriesIterator = entries.iterator(); 
<|del|> 
<|del|> 
<|del|> 
 "isRegistered"); } catch (OrmException e) { fail(e.getMessage()); e.printStackTrace(); 
 assertThat(q.all).hasSize(2); 
 throw new IllegalStateException(); 
 private String changeSet; 
 public boolean match(ChangeData object) throws OrmException { 
 if (change.getSubmissionId() == null) { 
 if (o.name().equalsIgnoreCase(option)) { 
 assertNoProblems(checkerA.check(keyA.getPublicKey(), store)); // Checker for B, checking B. Trust chain and IDs are correct, so the only // problem is with the key itself. GerritPublicKeyChecker checkerB = checkerFactory.create(userB); 
<|del|> 
 + " because it has an obsolete/unsupported state"); 
 @Nullable String prefix, Set<String> branches) throws ServiceNotEnabledException, ServiceNotAuthorizedException, IOException { 
<|del|> 
 unified(token, baseId, id, side, line); 
 info.problems = checkResult.getProblems(); 
<|del|> 
 FlexCellFormatter fmt = table.getFlexCellFormatter(); 
 int row = table.getRowCount(); 
 FlexCellFormatter fmt = table.getFlexCellFormatter(); 
<|del|> 
<|del|> 
 * @throws RestApiException if updating the change fails due to an underlying * API call failing. * @throws UpdateException if updating the change fails. 
 * @throws RestApiException if updating the change fails due to an underlying * API call failing. * @throws UpdateException if updating the change fails. 
 } else if (!bad && sigResult.getStatus() == TRUSTED) { 
 if (!isAllowed(result, commands)) { 
 PatchSetInserter create(BatchUpdate batchUpdate, ChangeControl ctl, 
 Throwables.propagateIfPossible(e.getCause()); throw new OrmException(e); 
<|del|> 
 InvalidChangeOperationException, MergeConflictException, UpdateException, RestApiException { 
<|del|> 
 if (!currentUser.hasEmailAddress(author.getEmailAddress()) && !refControl.canForgeAuthor()) { List<CommitValidationMessage> messages = new LinkedList<>(); 
 messages.add(getInvalidEmailError(receiveEvent.commit, "author", author, currentUser, canonicalWebUrl)); 
 public static class CommitterUploaderValidator implements CommitValidationListener { 
 Path propertiesPath = gen.resolve(Paths.get("tools/buck/buck.properties")); 
 PatchSetInserter create(BatchUpdate batchUpdate, ChangeControl ctl, 
 caller.getAccountId(), now, c.currentPatchSetId()); 
 * Create a new EventSourceImpl. 
 public EventSourceImpl(ProjectCache projectCache, DynamicSet<EventListener> unrestrictedListeners) { 
import com.google.gerrit.server.IdentifiedUser; 
 newCommit, 
 if (strs.length != 0) { 
<|del|> 
 dir = dir.getParent(); 
 if (getCurrentUser() instanceof IdentifiedUser) { final IdentifiedUser i = (IdentifiedUser) getCurrentUser(); return i.getAccountId().equals(change.getOwner()); 
 /** Set of changes starred by this user. */ public abstract Set<Change.Id> getStarredChanges(); /** Filters selecting changes the user wants to monitor. */ public abstract Collection<AccountProjectWatch> getNotificationFilters(); 
<|del|> 
 token = '#' + PageLinks.MINE; } else { token = Url.decode(token.substring(1)); 
 if (approvals != null && !approvals.isEmpty()) { 
 Pattern p = Pattern.compile("^Error in operator (.*:self|is:watched|is:owner|is:reviewer)$"); 
<|del|> 
 System.err.println(" RebuildNotedb Rebuild the review notes database"); 
 System.err.println(" RebuildNotedb Rebuild the review notes database"); 
<|del|> 
 public void basicLog() throws Exception { RevCommit commit = repo.branch("HEAD").commit().create(); repo.getRevWalk().parseBody(commit); 
 JsonElement result = buildJson("/repo/+log", ""); 
 for (String c: constraintNames) { execute("alter table " + tableName + " drop check " + c); 
 for (String c: constraintNames) { execute("alter table " + tableName + " drop check " + c); 
 for (String cd: checkDefs) { 
 for (String cd: checkDefs) { 
<|del|> 
 private static OAuthUserInfo getAsOAuthUserInfo(UserInfo userInfo) { 
 if (response.getCode() != HTTP_OK) { 
 public static void loadJARs(Path jar) { loadJARs(Collections.singleton(jar)); 
 RestResponse r = adminSession.post(urlRebase()); assertThat(r.getStatusCode()).isEqualTo(SC_CONFLICT); editUtil.delete(editUtil.byChange(change2).get()); 
 private static final String[] TEST_CASES = { "", "FirstName.LastName@Corporation.com", "!#$%&'+-/=.?^`{|}~@[IPv6:0123:4567:89AB:CDEF:0123:4567:89AB:CDEF]" }; 
 try (ReviewDb db = schema.get()) { 
 String destinationBranch = pr.getBase().getRef(); 
 @Nullable String prefix, Set<String> branches) throws ServiceNotEnabledException, ServiceNotAuthorizedException, IOException { 
<|del|> 
public class DiffPreferencesIT extends AbstractDaemonTest { @ConfigSuite.Config public static Config readFromGitConfig() { Config cfg = new Config(); cfg.setBoolean("user", null, "readPrefsFromGit", true); return cfg; } 
<|del|> 
 a.setLineLength(i.lineLength == null ? DiffPreferencesInfo.DEFAULT_LINE_LENGTH : i.lineLength); 
 static final long serialVersionUID = 18L; 
 public boolean omitDuplicateComments; 
 if (type == null) { 
<|del|> 
<|del|> 
<|del|> 
 @Inject private IdentifiedUser.GenericFactory identifiedUserFactory; 
 HashSet<String> emails = new HashSet<>(Arrays.asList(TEST_CASES)); 
<|del|> 
 public void expiredKeyIsExpired() throws Exception { assertProblems(expiredKey(), "Key is expired"); 
 public void selfRevokedKeyIsRevoked() throws Exception { assertProblems(selfRevokedKey(), "Key is revoked"); 
 StringBuilder r = new StringBuilder("Key is revoked ("); 
Copyright (C) 2015 The Android Open Source Project 
 IGNORE_TRAILING, IGNORE_LEADING_AND_TRAILING, IGNORE_ALL; 
 * If set, the top-level key passed to {@link #check(PGPPublicKey)} must * belong to the given user. (Other keys checked in the course of verifying * the web of trust are checked against the set of identities in the database 
 return check(key, null, 0, false, null); 
 chain.doFilter(httpRequest, httpResponse); 
 String user = uri.getUser(); if (user == null) { user = GitHubRepository.this.username; 
 CacheLoader<String, Multimap<String, String>> { private static final Logger logger = LoggerFactory .getLogger(OrganisationLoader.class); 
 String passwd = GitHubRepository.this.password; if (passwd == null) { 
 private final Provider<MetaDataUpdate.User> metaDataUpdateFactory; 
<|del|> 
 private List<ChangeData> getChangesCorrespondingToId(Change.Id changeId) throws OrmException { InternalChangeQuery query = queryProvider.get().noFields(); return query.byLegacyChangeId(changeId); } 
 allPastReviewers = new ArrayList<>(); reviewerChanges = new ArrayList<>(); 
 a.setIgnoreWhitespace(i.ignoreWhitespace == null ? Whitespace.IGNORE_NONE : Whitespace.forCode( PatchListKey.WHITESPACE_TYPES.get(i.ignoreWhitespace))); 
 a.setManualReview(b(i.manualReview)); 
 PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) 
<|del|> 
 comment.getLine(), Side.fromShort(comment.getSide()), checkNotNull( Hashing.sha1().hashString((CharSequence) comment.getMessage(), Charset.defaultCharset())), comment.getRange()); 
 abstract HashCode message(); @Nullable abstract CommentRange range(); 
 CommentSetEntry cse = CommentSetEntry.create(c, psId); 
 private static CommentSetEntry create(Patch.Key key, 
 Hashing.sha1().hashString(comment.getMessage(), UTF_8), 
 abstract Side side(); 
 setApiUser(user); String changeId = result.getChangeId(); assertThat(gApi.changes().id(changeId).get().isPrivate).isNull(); 
 * @param notify Notify handling that defines to whom email notifications should be sent after the * change edit is published. * @param accountsToNotify Accounts that should be notified after the change edit is published. 
 plcUtil.putComments(ctx.getDb(), u, ups); 
<|del|> 
<|del|> 
 | InvalidChangeOperationException e) { 
 in = new URL(input.url).openStream(); } catch (MalformedURLException e) { throw new BadRequestException(e.getMessage()); 
 in = new URL(input.url).openStream(); } catch (MalformedURLException e) { throw new BadRequestException(e.getMessage()); 
<|del|> 
 private static final String BASIC = "Basic "; 
 DynamicItem<OAuthLoginProvider> loginService, AccountCache accountCache, AccountManager accountManager, 
 private static String encoding(HttpServletRequest req) { return MoreObjects.firstNonNull(req.getCharacterEncoding(), UTF_8.name()); 
 private static String encoding(HttpServletRequest req) { return MoreObjects.firstNonNull(req.getCharacterEncoding(), UTF_8.name()); 
 .in(SINGLETON); bind(FromAddressGenerator.class).toProvider( FromAddressGeneratorProvider.class).in(SINGLETON); bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class) .toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON); 
 if (response.getCode() != HTTP_OK) { 
 public static final String XSRF_COOKIE_NAME = "xsrfToken"; 
<|del|> 
 WebServer(SourceHandler handler, SymbolMapHandler symbolMapHandler, JsonExporter jsonExporter, OutboxTable outboxes, JobRunner runner, JobEventTable eventTable, String bindAddress, int port) { 
 newHandler.addServlet(new ServletHolder(new HttpServlet() { private static final long serialVersionUID = 1L; 
 Map<String, String> result = new HashMap<>(); 
 if (expires.isBefore(new DateTime())) { 
 if (expires.isBefore(new DateTime())) { 
 CleanerLifecycle( WorkQueue queue, FlatFileWebSessionCacheCleaner cleaner, @CleanupInterval long cleanupInterval) { 
 @CleanupInterval Long getCleanupInterval(PluginConfigFactory cfg, @PluginName String pluginName) { 
 "cleanupInterval")); 
 String newGroupName = "newGroup"; 
 String newGroupName = "newGroup"; 
 String wrongGroupName = "newG"; String newProjectName = "invalidProject"; 
 GroupReference group = GroupBackends.findExactSuggestion(groupBackend, n); 
 public static boolean isNoteDbTestEnabled() { 
 public static boolean isNoteDbTestEnabled() { 
 private GarbageCollection.Factory garbageCollectionFactory; 
 @Override public BinaryResult apply(final ProjectResource rsrc, final Input input) { 
 @Override public BinaryResult apply(final ProjectResource rsrc, final Input input) { 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
 protected static TestPredicate f(String name, String value) { 
 assertStatus(HttpStatus.SC_UNPROCESSABLE_ENTITY); 
 } rdr.append(Url.decode(token)); 
 String newProjectName = "newProject"; 
 GroupReference group = GroupBackends.findExactSuggestion(groupBackend, n); 
 if (firstParent != null) { return rw.parseCommit(firstParent).getTree(); 
 else { 
 } catch (ExecutionException e) { 
 rsp.setHeader(ETAG, r.etag); 
<|del|> 
<|del|> 
 .withFailureMessage(String.format("Expected status code %d", status)) .that(getStatusCode()) .isEqualTo(status); 
 .get("/projects/non-existing/tags") .assertNotFound(); 
<|del|> 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
 AvailablePluginsCollection(DynamicMap<RestView<PluginResource>> views, Provider<ListAvailablePlugins> list) { 
 } return "stable-" + versionNumbers[0] + "." + versionNumbers[1]; 
Copyright (C) 2015 The Android Open Source Project 
 throw new RestApiException( "Unable to load the list of available plugins", e); 
 output.put(p.name, p); 
 return OutputFormat.JSON.newGson().toJsonTree( output, new TypeToken<Map<String, Object>>() {}.getType()); 
<|del|> 
 private static final Logger log = LoggerFactory .getLogger(JenkinsCiPluginsRepository.class); 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
 * Create a new EventBroker. 
 * <p> 
// ClippyResources as used herein. 
// ClippyResources as used herein. 
// The above license applies to this file, whereas the below license applies to // clipboard-16.png as used herein. // The MIT License (MIT) 
 copier = new Button(new SafeHtmlBuilder().openElement("img") .setAttribute("src", ClippyResources.I.clipboard().getSafeUri().asString()) .setWidth(14).setHeight(14).closeSelf()); 
 /** Define the static operators */ 
 } c = c.getSuperclass(); 
 public Definition<T, ? extends QueryBuilder<T>> getDynamicDefinition() { 
 public boolean match(ChangeData object) { 
<|del|> 
 // Return initialization time of this class, since the GWT outputs from the // build process all have mtimes of 1980/1/1. 
 // Return initialization time of this class, since the GWT outputs from the // build process all have mtimes of 1980/1/1. 
 poolSize = config.getInt("sshd", "threads", 3 * cores / 2); batchThreads = config.getInt("sshd", "batchThreads", cores == 1 ? 1 : 2); 
 throws AuthException, ResourceNotFoundException, ResourceConflictException, EmailException, OrmException { PatchSet ps = rebase.dbProvider.get().patchSets() .get(rsrc.getChange().currentPatchSetId()); 
<|del|> 
 if (ps.isDraft() && !isDraftVisible(db, null)) { 
<|del|> 
 sshdThreads = cfg.getInt("sshd", "threads", 3 * cores / 2); 
 public void failChangedLabelValueOnOutdatedPatchSet() throws Exception { 
<|del|> 
 PatchSet.Id first = r.getPatchSetId(); 
 .review(ReviewInput.approve()); 
 } for (PatchSetApproval approval : approvalsUtil.byPatchSet(db, r.getChange().changeControl(), r.getPatchSetId())) { assertThat(approval.getLabelId().equals(codeReview)); assertThat(approval.getValue() == -2); } 
 public interface Event extends RevisionEvent { public AccountInfo getAbandoner(); public String getReason(); 
 public interface Event extends RevisionEvent { public AccountInfo getSubmitter(); public String getNewRevisionId(); 
<|del|> 
 this.metrics = metrics; 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
 private static final Map<Object, MetricRegistry> pluginMetricRegistry = new HashMap<>(); 
 return registry != null ? registry : new MetricRegistryPluginProxy( pluginOwner, coreRegistry, pluginMetrics); 
 public MetricRegistryPluginProxy(Object pluginOwner, MetricRegistry coreRegistry, Map<Object, String> pluginMetrics) { 
 this.executionTime = metrics.getRegistry().timer(name("queries", "executiontime")); 
 private final MetricRegistry coreRegistry; private final Map<Object, String> pluginMetrics; private final Map<Object, MetricRegistry> pluginMetricRegistry; 
 private final MetricRegistry coreRegistry; private final Map<Object, String> pluginMetrics; private final Map<Object, MetricRegistry> pluginMetricRegistry; 
 private final MetricRegistry coreRegistry; private final Map<Object, String> pluginMetrics; private final Map<Object, MetricRegistry> pluginMetricRegistry; 
 if (registry != null) { return registry; } registry = new MetricRegistryPluginProxy(pluginOwner, coreRegistry, pluginMetrics); pluginMetricRegistry.put(pluginOwner, registry); return registry; 
<|del|> 
 MetricRegistry getMetricsRegistry() { return metricRegistry; 
 } 
 final MetricRegistryPluginProxy metrics = new MetricRegistryPluginProxy(metricRegistry); bind(MetricRegistry.class).toInstance(metrics); install(new LifecycleModule() { @Override public void configure() { listener().toInstance(metrics); } }); 
 MetricRegistry registry) { 
 public String getItem(String key) { 
 if (storage.getKeys().contains(getReplyCommentName())) { return true; } return false; 
 if (storage.getKeys().contains(getReplyCommentName())) { return true; } return false; 
 private class AuthInfo { private final String username; private final String tokenOrSecret; private final String pluginName; private final String exportName; 
 private static class Response extends HttpServletResponseWrapper { 
 private static class Response extends HttpServletResponseWrapper { 
 throw new ResourceConflictException( "Submission depends on revision " + id.get() + " of Change " + id.getParentKey().get() + ", but latest revision is " + cd.change().currentPatchSetId().get()); 
<|del|> 
 batchThreads = config.getInt("sshd", "batchThreads", threadsSettingsConfig.getSshdBatchTreads()); 
 public GerritGraphiteReporter(PluginConfigFactory configFactory, @PluginName String pluginName, @PluginMetrics MetricRegistry registry) { 
<|del|> 
 throws OrmException, BadRequestException { 
 try { gApi.changes() .id(change3.getId().get()) .revision(ps3_1.get()) .review(ReviewInput.recommend()); fail("Expected ResourceConflictException"); } catch (ResourceConflictException e) { // Expected } 
<|del|> 
 AccountInfo getAbandoner(); String getReason(); 
 AccountInfo getMerger(); /** Represents the merged Revision when the submit strategy is cherry-pick */ String getNewRevisionId(); 
 AccountInfo getMerger(); /** Represents the merged Revision when the submit strategy is cherry-pick */ String getNewRevisionId(); 
 public Map<String, ApprovalInfo> getApprovals(); 
 AccountInfo getPublisher(); 
 public interface Event extends ChangeEvent { AccountInfo getReviewer(); 
 private final Provider<CurrentUser> currentUser; 
 private final int maxSuggestedTopics; 
 usage = "maximum number of topics to list") 
 usage = "match topics query") 
 this.maxSuggestedTopics = cfg.getInt("suggest", "maxSuggestedTopics", DEFAULT_MAX_SUGGESTED); this.limit = this.maxSuggestedTopics; 
 this.maxSuggestedTopics = cfg.getInt("suggest", "maxSuggestedTopics", DEFAULT_MAX_SUGGESTED); this.limit = this.maxSuggestedTopics; 
 UploadFactory(TransferConfig tc, UploadPackMetricsHook uploadMetrics, 
<|del|> 
 * @param helpText a short one-sentence string explaining the values captured * by the metric. This may be made available to administrators as * documentation in the reporting tools. 
 throw new IllegalArgumentException("unsupported value type " + valueClass.getName()); 
<|del|> 
Copyright (C) 2015 The Android Open Source Project 
 event.setProperty(P_AGENT, peerAgent); 
Copyright (C) 2015 The Android Open Source Project 
 public MetricJson apply(MetricResource resource) throws AuthException { 
 return new MetricJson( resource.getMetric(), metrics.getAnnotations(resource.getName()), dataOnly); 
 @Singleton 
import com.google.common.annotations.VisibleForTesting; 
 } catch (OrmException err) { 
 REMOVED(new FooterKey("Removed"), ReviewerState.REMOVED); 
public class GerritJmxReporter implements LifecycleListener { 
 private final SimpleDateFormat tzFormat; 
 .compare(a.name, b.name, createOrdering()) .compare(a.email, b.email, createOrdering()) .compare(a._accountId, b._accountId, createOrdering()) 
 .compare(a.name, b.name, createOrdering()) .compare(a.email, b.email, createOrdering()) .compare(a._accountId, b._accountId, createOrdering()) 
package com.google.gerrit.metrics; 
/** Exports no metrics, useful for running batch programs. */ 
 public <F1> Counter1<F1> newCounter(String name, Description desc, Field<F1> field1) { 
package com.google.gerrit.metrics; 
 interface Event extends RevisionEvent { 
 Map<String, ApprovalInfo> getApprovals(); Map<String, ApprovalInfo> getOldApprovals(); 
 interface Event extends RevisionEvent { 
 interface Event extends RevisionEvent { 
<|del|> 
 public void fire(Change change, PatchSet ps, Account abandoner, String reason) { 
<|del|> 
 gitRefUpdated.fire(project, refUpdate, (AccountInfo) null); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // TODO(dborowitz): These fragments conflict with the REST API namespace, so // they will need to use a different path. //serve("/groups/*").with(PolyGerritUiIndexServlet.class); //serve("/projects/*").with(PolyGerritUiIndexServlet.class); 
 final Counter1<Integer> errors; final Counter1<Integer> successes; 
 "http/server/error_count", 
 Field.ofInteger("status", "HTTP status code")); 
 Field.ofInteger("status", "HTTP status code")); 
 private static class Response extends HttpServletResponseWrapper { 
 Response(HttpServletResponse response, RequestMetrics metrics) { 
 RestView<RestResource> view = views.get(p.get(0), method + "." + viewname); 
<|del|> 
 private final Counter1<String> events; 
 private final Counter1<String> events; 
 events = metricMaker.newCounter( "events", new Description("Triggered events") 
 events.increment(event.getType()); 
 String message = "Forced message"; 
<|del|> 
<|del|> 
 } catch (OrmException e) { log.error("PatchsetCreated hook failed to run " + ev.getChange()._number, e); 
 getAccount(ev.getAuthor()), getPatchSet(ev.getRevision()), ev.getComment(), approvals, db.get()); 
 public void doClaSignupHook(Account account, String claName) { if (!claSignedHook.isPresent()) { return; } 
 void doClaSignupHook(Account account, String claName); 
<|del|> 
<|del|> 
 PatchSet.Id first = r.getPatchSetId(); 
 private final Change.Id changeId; private final PatchSet.Id psId; private final StorageBackend storage; 
 private final Change.Id changeId; private final PatchSet.Id psId; private final StorageBackend storage; 
 private final Change.Id changeId; private final PatchSet.Id psId; private final StorageBackend storage; 
 private final Storage storageBackend; 
 public String annotation; 
 public String annotation; 
 + annotation; 
<|del|> 
 return reviewer; } else { return reviewer.subList(0, limit); 
 final Set<CallbackMetric<?>> cacheMetrics = ImmutableSet.<CallbackMetric<?>>of( memEnt, memHit, memEvict, perDiskEnt, perDiskHit); 
 final Set<CallbackMetric<?>> cacheMetrics = ImmutableSet.<CallbackMetric<?>>of( memEnt, memHit, memEvict, perDiskEnt, perDiskHit); 
<|del|> 
 private static double hitRatio(PersistentCache.DiskStats d) { 
 final CallbackMetric1<String, Long> memEnt = metrics.newCallbackMetric("caches/memory_cached", Long.class, new Description("Memory entries").setGauge().setUnit("entries"), F_NAME); 
 F_NAME); 
 public CacheMetrics(MetricMaker metrics, 
 return ((double) d.hitCount() / d.requestCount() * 100); 
<|del|> 
 return json.create(ChangeJson.NO_OPTIONS).format(req.getChange()); 
 public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException { 
 String submitDialogCancel(); 
 SubmitDialog(ChangeInfo changeInfo, JsArray<ChangeAndCommit> sameTopicChnages, 
 "submitSize", String.valueOf(cs.size()), "numberTopics", String.valueOf(cs.topics().size())); 
 public static final AccountInfoComparator ORDER_NULLS_FIRST = 
 public static AccountInfoComparator ORDER_NULLS_FIRST = new AccountInfoComparator(); public static AccountInfoComparator ORDER_NULLS_LAST = new AccountInfoComparator().setNullsLast(); 
 private final Config cfg; 
<|del|> 
 } return EqualsFilePredicate.create(args, file); 
 "sql/reviewdb/pool_exhausted", 
 AgreementSignup agreementSignup) { 
 this.changeMerged = changeMerged; 
 ai.username = a.getUserName(); 
<|del|> 
 gitRefUpdated.fire(project, refUpdate, (AccountInfo) null); 
 input.revision = ObjectId.toString( revWalk.parseCommit(ObjectId.fromString(event.refUpdate.oldRev)) 
<|del|> 
<|del|> 
<|del|> 
 /** * Stop the timer and record the elapsed time. * * @return the elapsed time in nanoseconds. * @throws IllegalStateException if the timer is already stopped. */ 
 if (!stopped) { stop(); } 
 **/ 
 */ 
 repLog.info("Replication {} was canceled", getURI()); 
 if (!pool.requestRunway(this)) { if (!canceled) { 
 EventUtil(AccountCache accountCache) { 
 /** Draft inline comments of a user on a change */ public static final String REFS_DRAFT_COMMENTS = "refs/draft-comments/"; 
 if (!(initFlags.installPlugins.contains(pluginName) || ui.yesno(false, 
<|del|> 
import java.io.IOException; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Set; 
<|del|> 
 batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName)); 
 throw new IOException(String.format( "Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult())); 
Copyright (C) 2015 The Android Open Source Project 
 /** * Start the replication latency timer for a destination. * @param name the destination name. * @return the timer context. */ 
 // A batch size of N may overload get(Iterable), so use something smaller, // but still >1. 
 @Singleton 
 public void unstarAll(IdentifiedUser user, Change.Id changeId) throws OrmException { 
 @Override public Change.Id apply(String changeId) { return Change.Id.parse(changeId); } 
 return new ChangeIsVisibleToPredicate( args.db, args.notesFactory, args.changeControlGenericFactory, user); 
 public Predicate<ChangeData> o(String who) throws QueryParseException, OrmException { 
 // A batch size of N may overload get(Iterable), so use something smaller, // but still >1. 
 return canReadCommitFromVisibleRef(db, repo, commit); 
<|del|> 
 /** Invoked when the server is starting. */ 
 void onChangeIndexed(Event event); /** Invoked when a change is deleted from the index. */ 
 private final LoadingCache<CacheKey, HashMultimapPair<Account.Id, Change.Id>> cache; 
 @Named(CACHE_NAME) LoadingCache<CacheKey, HashMultimapPair<Account.Id, Change.Id>> cache) { 
 return all().getBySecondKey(changeId); 
 install(SectionSortCache.module()); install(SubmitStrategy.module()); 
 import java.sql.SQLException; import java.sql.Statement; 
/** Notified whenever a change is indexed or deleted from the index. */ 
 public void unstar(Account.Id accountId, Change.Id changeId) 
 BuckUtils.displayFailure(TARGET, msg.getBytes(UTF_8), res); 
<|del|> 
 a.setValue((short)0); update.putApproval(labelVote.label(), (short)0); 
<|del|> 
 final IdentifiedUser.GenericFactory identifiedUserFactory, 
<|del|> 
 * @throws RestApiException if id is not account ID or is a user that isn't * known to be a reviewer for this change. 
 public final Set<Integer> removableReviewerIds() { 
 public final Set<Integer> removableReviewerIds() { 
 ctx.getChangeUpdate().setPatchSetId(psId); ctx.getChangeUpdate().removeApproval(label); 
 public VoteResource(ReviewerResource reviewer, String label) { 
 if (dropdown != null && dropdown.getSelectedValue().equals(Gerrit.C.searchDropdownDoc())) { 
 gApi.changes().id(r1.getChangeId()).revision(ps1.getRevision().get()).rebase(ri); 
 ctx.getWhen(), 
<|del|> 
 enhanceButton(msg); 
 private void enhanceButtonUponExpiredSession(String errorMessage) { if (errorMessage.equals(NotSignedInException.MESSAGE)) { // Redirection added for 'My.*' menus 
 private void enhanceButtonUponExpiredSession(String errorMessage) { if (errorMessage.equals(NotSignedInException.MESSAGE)) { // Redirection added for 'My.*' menus 
 } else if (errorMessage.equals(Gerrit.C.notFoundBody())) { // If a My.Changes item is clicked, 'Continue' button redirects to login 
class HashMultimapPair<K1, K2> implements Serializable { 
<|del|> 
 DynamicSet.setOf(binder(), BranchWebLink.class); DynamicMap.mapOf(binder(), OAuthLoginProvider.class); 
 assertThat(res.getStatus()).isEqualTo(SC_NOT_FOUND); 
 assertHasETag(res); // Miss on getIfPresent, miss on get. 
 } else if (rcptTo.remove(fromId)) { // If they don't want a copy, but we queued one up anyway, // drop them from the recipient lists. // removeUser(fromUser); 
 public Future<?> loadAsync() { return workQueue.getDefaultQueue().submit(new Runnable() { @Override public void run() { load(); } }); } public void load() { 
 /* * (non-Javadoc) * 
<|del|> 
 return lineIterator != null && lineIterator.hasNext() || entryIterator.hasNext(); 
 if (lineIterator == null || !lineIterator.hasNext() && entryIterator.hasNext()) { 
 } 
 assertThat(diff.getDiffLines()).hasSize(lines.size()); 
 assertThat(diff.getDiffLines()).hasSize(0); 
 public static void blame(PatchSet.Id id, String path, boolean base, AsyncCallback<ChangeInfo> cb) { 
 void set(DiffPreferences prefs, JsArray<RevisionInfo> list, DiffInfo info, ClickHandler onBlameA, ClickHandler onBlameB, boolean editExists, boolean current, boolean open, boolean binary) { 
 void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, ClickHandler onBlame, boolean editExists, boolean current, boolean open, boolean binary) { 
 Anchor anchor = new Anchor(new ImageResourceRenderer() .render(Gerrit.RESOURCES.blame())); 
<|del|> 
 boolean isBase = base == null; PatchSet.Id rev = isBase ? base : revision; 
 PageLinks.toChange(new Change.Id(blame.changeId()), String.valueOf(blame.patchSetId())) + "/" + path); 
<|del|> 
 GetDiff getDiff, InternalChangeQuery internalChangeQuery, BlameCache blameCache) { 
 throws RestApiException, QueryParseException, OrmException, IOException, InvalidChangeOperationException { 
 } else if (parents.length == 2) { 
 throw new ResourceNotFoundException("Cannot generate blame for merge commit" 
 List<ChangeData> changeDatas = internalChangeQuery.byCommit(ObjectId.fromString(blame.meta.id)); for (ChangeData changeData : changeDatas) { 
<|del|> 
 EmailStrategy strategy = fromUser.getGeneralPreferences().getEmailStrategy(); 
 // his email notifications then drop him from recipients list 
<|del|> 
 if (cherryPickCommit == null) { throw new MergeException("Could not create a merge commit during the cherry pick"); } 
Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 // What we want to avoid in any event is to create new 
 private volatile StarredChangesCache defaultStarredChangesCache; 
 // it may deviate from the really old OpenID identity. 
 if (!votesRemoved) { msg.append(" with the following votes:\n\n"); 
 } update.commit(); indexer.index(db, rsrc.getChange()); return Response.none(); } 
<|del|> 
<|del|> 
<|del|> 
 public static final String RUN_REINDEX = "No index versions ready; run java -jar <gerritwar> reindex"; 
 @Override public void onFailure(Throwable caught) { } })); 
 assertThat(r.getChange().change().getDest()).isEqualTo(newBranch); 
 }); 
 Map<String, FileInfo> toFileInfoMap(Change change, RevId revision, @Nullable PatchSet base, @Nullable DiffType diffType) throws PatchListNotAvailableException { 
 MoveInput in = new MoveInput(); in.destination = destination; move(in); 
 diffType)); 
 if (claimedId == null) { log.debug("Claimed identity is unknown"); } 
 public boolean run(SubmitType submitType, Repository repo, 
 this.delegate = delegate; 
 gApi.changes().id(changeId).abandon(); 
<|del|> 
 try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) { 
 public MetaDataUpdate(GitReferenceUpdated gitRefUpdated, 
 this.db = db; this.batch = batch; 
 public static final String RUN_REINDEX = 
 "No index versions ready; run java -jar " + GerritLauncher.getDistributionArchive().getName() + " reindex"; 
<|del|>
 String runReindex = 
 String runReindex = 
 "No index versions ready; run java -jar " + sitePaths.gerrit_war.toAbsolutePath() + 
 for (ChangeData cData : index.getSource( Predicate.and(new LegacyChangeIdPredicate(index.getSchema(), object.getId()), this), 0, 1) .read()) { 
 for (ChangeData cData : index.getSource( Predicate.and(new LegacyChangeIdPredicate(index.getSchema(), object.getId()), this), 0, 1) .read()) { 
 Change change = cacheById.getIfPresent(id); 
 Change change = cacheById.getIfPresent(id); 
 SingleChangeLoader(Provider<ReviewDb> db) { 
 SingleChangeLoader(Provider<ReviewDb> db) { 
 GetPreference(Provider<IdentifiedUser> self, ProjectCache projectCache, @PluginName String pluginName, Provider<GetConfig> getConfig) { 
 return Response.none(); 
 PutPreference(Provider<IdentifiedUser> self, ProjectCache projectCache, MetaDataUpdate.User metaDataUpdateFactory, @PluginName String pluginName) { 
 boolean showEmoticons = db.getBoolean(PREFERENCE, username, KEY_SHOW_EMOTICONS, true); 
<|del|> 
 public OnEditEnabler(FocusWidget w, TextBoxBase tb) { 
<|del|> 
 private Gson gson; 
import com.google.gerrit.server.query.change.ChangeData.ChangedLines; import com.google.gerrit.server.query.change.PluginDefinedAttributesFactory; 
<|del|> 
 throw new IllegalStateException( "daemonStart can be called only once per JVM instance"); 
 super(cache, true); buildCommand = builder.buildCommand(new BuildSystem.Label("//polygerrit-ui", "polygerrit_components")); 
 return builder.targetPath( new BuildSystem.Label( "polygerrit-ui", "polygerrit_components", "polygerrit_components.bower_components.zip")); 
<|del|> 
<|del|> 
<|del|> 
 if (!self.get().equals(rsrc.getUser()) 
<|del|> 
<|del|> 
 throw new AuthException("restricted to members of Modify Accounts"); 
<|del|> 
 if (counter >= limit) { 
 // may do it properly (certainly InMemoryRepository doesn't). 
 newId = ins.insert(OBJ_BLOB, Integer.toString(val).getBytes(UTF_8)); 
 // s2 acquires 7-9; s1 acquires 10-12. 
<|del|> 
 public Change get(Change.Id id) { 
 public void evict(Change.Id id) { 
 GenericFactory(ProjectControl.GenericFactory p, Provider<ReviewDb> d, ChangeCache c) { 
<|del|> 
 api.addParameter("diff-type", difftype); 
 api.addParameter("diff-type", difftype); 
 final GroupIncludeCache groupIncludeCache) throws ConfigInvalidException, IOException { 
 if (change == null && lazyLoad) { 
 } throw new IllegalStateException(); 
 for (Change.Id id : commits.getChangeIds()) { 
 Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap(); 
Copyright (C) 2016 The Android Open Source Project 
 + "' does not contain " + USER_PLACEHOLDER 
 private String replaceInUrl(String placeholder, String url, String replacement, boolean lowerCase) { if (url == null || replacement == null || !url.contains(placeholder)) { 
 // as we can't assume anything of 'replacement', we're URL encoding it return url.replace(placeholder, Url.encode(replacement)); 
 new ProcessBuilder("ssh-keygen", // 
 for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) { 
 * * @param url The URL, usually containing #{REPLACE_MARKER} 
<|del|> 
<|del|> 
 initAccountGeneralPreferences(p, i); 
 initAccountGeneralPreferences(p, i); 
 private void checkDownloadScheme(String downloadScheme) 
 @Option(name = "--stop-only", usage = "Stop the daemon", hidden = true) 
 if (stopOnly) { 
 LabelType lt = category("Verified", value(1, "Verified"), value(0, "No score"), value(-1, "Fails")); 
<|del|> 
 public PatchSetInfo getPatchSetInfo() { return patchSetInfo; 
 dst.addLine(line, src.getString(line)); 
 protected Change newChange() throws IOException, OrmException, ConfigInvalidException { 
 stmt.execute("ALTER TABLE patch_sets " 
 protected void preUpdateSchema(ReviewDb db) { 
 Header(KeyCommandSet keys, 
 DiffApi.list(patchSetId, base, diffType, new GerritCallback<NativeMap<FileInfo>>() { 
 Map<String, FileInfo> toFileInfoMap(Change change, PatchSet patchSet, DiffType difftype) throws PatchListNotAvailableException { 
<|del|> 
 return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()])); 
 stmt.execute("ALTER TABLE patch_sets MODIFY push_certificate clob"); } catch (SQLException e) { // Ignore. Type may have already been modified manually. 
<|del|> 
 protected final Change.Key testChangeKey = new Change.Key( "Ic19f7bf6c8b4685c363a8204c32d827ffda52ec0"); protected final Change.Id testChangeId = new Change.Id(1); protected final Account.Id testAccountId = new Account.Id(1); 
 protected final Change.Key testChangeKey = new Change.Key( "Ic19f7bf6c8b4685c363a8204c32d827ffda52ec0"); protected final Change.Id testChangeId = new Change.Id(1); protected final Account.Id testAccountId = new Account.Id(1); 
 assertThat(BackupRef.getTimestampBranch(ref)).isEqualTo(ref); 
<|del|> 
 if (ptr <= changeMessageStart) return; String changeMessage = RawParseUtils.decode(enc, wholeCommitMsgBytes, changeMessageStart, changeMessageEnd + 1); changeMessages.add(changeMessage); 
 throws ResourceConflictException, OrmException, IOException { boolean ret = patchSetInserter.updateChange(ctx); 
 ChangeNotes notes = newNotes(db, change); 
 * @param approvalStatus Map of label IDs to updated flag 
 List<CommentInput> list = ent.getValue(); 
<|del|> 
 String name = name("user42"); user42 = accounts.create(name, name + "@example.com", "User 42"); 
import com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.DownloadCommand; import com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.EmailStrategy; 
 writeToDb(id, n); cache.evict(id); 
 * Marker on the global {@link WorkQueue.Executor} used to send email. 
<|del|> 
 zip = getZipPath(buckOut); if (zip == null || !Files.exists(zip)) { bowerComponents = null; } else { bowerComponents = GerritLauncher .newZipFileSystem(zip) .getPath("bower_components/"); 
 throws URISyntaxException { String cdnPath = cfg.getString("gerrit", null, "cdnPath"); return new IndexServlet(canonicalUrl, cdnPath); 
 p.muteCommonPathPrefixes = b(p.muteCommonPathPrefixes); p.sizeBarInChangeTable = b(p.sizeBarInChangeTable); 
 assertThat(cm1.getMessage()) .isEqualTo("This is the change message for the first PS."); assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId()); 
 notes.getChangeMessagesByPatchSet(); assertThat(changeMessages.keySet()).hasSize(1); 
 } } else { for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) { ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change); if (predicate.apply(notes)) { m.put(change.getProject(), notes); 
import com.google.gerrit.client.patches.PatchScreen; import com.google.gerrit.client.rpc.CallbackGroup; 
<|del|> 
<|del|> 
 public void publish(ReviewDb db, ChangeUpdate update, PatchSet ps) throws OrmException { 
 List<RevisionResource> out = new ArrayList<>(); for (PatchSet ps : psUtil.byChange(dbProvider.get(), change.getNotes())) { 
 Field<String> DEST_FIELD = Field.ofString("destination"); 
 class TestModule extends LifecycleModule { @Override protected void configure() { bind(Configuration.class).toInstance(config); bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class) .in(Scopes.SINGLETON); } } 
 public void testIndexEventHandlerIsForwarded() throws Exception { setUpMocks(false); 
 if (!sameUpdate(e, update)) { 
 if (update != null) { writeToBatch(batch, update); 
<|del|> 
 b.append("Hashtag"); if (hashtags.size() > 1) { b.append("s"); } b.append(" "); 
 public void testPutSingleHashtag() throws Exception { 
 public static List<String> getGroupNames() { return Arrays.asList(ANONYMOUS_USERS_GROUP_NAME, REGISTERED_USERS_GROUP_NAME, PROJECT_OWNERS_GROUP_NAME, CHANGE_OWNER_GROUP_NAME); 
 public static List<String> getGroupNames() { return Arrays.asList(ANONYMOUS_USERS_GROUP_NAME, REGISTERED_USERS_GROUP_NAME, PROJECT_OWNERS_GROUP_NAME, CHANGE_OWNER_GROUP_NAME); 
Copyright (C) 2016 The Android Open Source Project 
 stmt.execute("ALTER TABLE patch_sets " 
 stmt.execute("ALTER TABLE patch_sets " 
 allow(allProjects, "read", ANONYMOUS_USERS, "refs/*"); 
<|del|> 
 Integer instanceNumber = Ints.tryParse(instance); if (instanceNumber == null || instanceNumber < 0 || instanceNumber > 99) { 
 private HANA hana; 
 public void setup() { config = new Config(); 
 assertThat(hana.getUrl()).isEqualTo("jdbc:sap://my.host:30315"); 
 .setUnit(Description.Units.MILLISECONDS), DEST_FIELD); 
 private Change.Id getIdFromRequest(String path) { String changeId = path.substring(path.lastIndexOf('/') + 1); return Change.Id.parse(changeId); 
 final ReviewDb db, final PatchSetUtil psUtil, final ChangeNotes.Factory notesFactory) { 
 } ui.message("done"); 
 LabelTypes labelTypes = new LabelTypes(Arrays.asList(Util.codeReview(), Util.verified())); 
 ui.message("listing all repositories ..."); 
 return wholeTopicEnabledConfig(); 
 ChangeNotes notes = notesFactory.createFromIndexedChange(c); 
 checkLimit(maxTerms, "maxTerms", 1024), 
 checkLimit(maxTerms, "maxTerms", DEFAULT_MAX_TERMS), 
 Change c = notes.getChange(); if (c == null) { throw new OrmException("Change missing: " + cid); } 
 if (!fields.contains(CHANGE.getName()) && !fields.contains(PROJECT.getName())) { 
<|del|> 
 rw.markStart(rw.parseCommit(cmd.getNewId())); 
import com.google.gerrit.common.TimeUtil; 
import com.google.gerrit.server.PatchSetUtil; 
 ApprovalsUtil approvalsUtil, PatchSetUtil psUtil, 
 Account.Id accountId = accounts.parse(input.reviewer).getAccountId(); 
 throws UpdateException, RestApiException, OrmException, IOException { 
 AddReviewerSender cm = addReviewerSenderFactory .create(change.getProject(), change.getId()); 
 @Assisted IdentifiedUser user, 
 public void testCreateGroup() throws Exception { 
 public static List<String> getNames() { 
 final String projectOwners = groupBackend.get(SystemGroupBackend.PROJECT_OWNERS).getName(); 
 Change c = notesFactory .create(db, new Project.NameKey(event.getProjectName()), id) .getChange(); 
 DiffInfo diff(String base) throws RestApiException; 
 if (r.getWhitespace() != null) { diff.setWhitespace(r.getWhitespace()); 
 fs.setUserHome(null); 
 @NoHttpd 
 List<ChangeAttribute> changes = executeSucessfullQuery("1234"); 
 private static List<ChangeAttribute> getChanges(String rawResponse) { 
 changes.add(gson.fromJson(lines[i], ChangeAttribute.class)); 
 for (Map.Entry<String, Short> entry : approvals.entrySet()) { 
 for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) { 
 private List<ChangeAttribute> executeSuccessfulQuery(String params) 
 try (Repository git = gitManager.openRepository(notes.getProjectName()); 
import com.google.gerrit.server.api.accounts.GpgApiAdapter; import com.google.gerrit.server.config.TrackingFooters; 
 public ChangeNotes get(ReviewDb db, Change c) 
 protected Project.NameKey createProject( String nameSuffix, Project.NameKey parent, boolean createEmptyCommit) throws RestApiException { 
 * @throws IOException 
 RevWalk rw = new RevWalk(git)) { 
 if (!Strings.isNullOrEmpty(domain)) { 
 log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e); account.setGeneralPreferences(GeneralPreferencesInfo.defaults()); 
 public ChangeNotes create(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException { return new ChangeNotes(args, loadChangeFromDb(db, project, changeId)) .load(); } 
Copyright (C) 2016 The Android Open Source Project 
 db.changes().atomicUpdate( change.getId(), 
 DynamicMap.mapOf(binder(), OAuthLoginProvider.class); DynamicSet.setOf(binder(), AccountExternalIdCreator.class); 
 changeKind = changeKindCache.getChangeKind( projectControl.getProject().getNameKey(), ctx.getRepository(), priorCommit, commit); 
 throws RestApiException, OrmException, IOException { 
 String approvalMessage = ApprovalsUtil.renderMessageWithApprovals( patchSetId.get(), approvals, scanLabels(ctx, approvals)); 
 // Try to get a gitiles.config file from the refs/meta/config branch // of the project. For non-project access, use All-Projects as project. 
<|del|> 
 ChangeControl ctrl = changeControlFactory.controlFor(db.get(), change, currentUser); 
 commentAdded.fire( change, newPatchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen()); 
<|del|> 
<|del|> 
public class SubmitResolvingMergeCommitIT extends AbstractDaemonTest { 
 String project1Name = name("Project1"); String project2Name = name("Project2"); gApi.projects().create(project1Name); gApi.projects().create(project2Name); 
 // When the parent name is not explicitly set, it should be 
 assertThat(newParent).isEqualTo(AllProjectsNameProvider.DEFAULT); 
<|del|> 
 @NoHttpd 
 Modes.I.puppet(), Modes.I.python(), 
<|del|> 
 r.assertOK(); 
 r.assertOK(); 
 private final AccountCache accountCache; 
<|del|> 
 for (PatchSetApproval psa : normalized.updated()) { 
<|del|> 
 private ChangeMergedEvent mockChangeMergedEvent = 
 boolean rejectSymlink = cfg.getBoolean(KEY_CHECK_SYMLINK, false); 
 tw.addTree(receiveEvent.commit.getTree()); if (receiveEvent.commit.getParentCount() >= 1) { 
 if ((diff && (tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK)) { addValidationMessage(messages, tw); 
 if ((diff && (tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK)) { addValidationMessage(messages, tw); 
 if ((diff && (tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK)) { addValidationMessage(messages, tw); 
 if (diff && isSymLink(tw.getRawMode(0))) { 
 this.changeAvatarUrl = cfgFactory.getFromGerritConfig(pluginName) .getString("changeAvatarUrl", "http://www.gravatar.com"); 
 return (rawMode & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK; 
 for (int p = 1; p <= receiveEvent.commit.getParentCount(); p++) { if (tw.getObjectId(0).equals(tw.getObjectId(p))) { 
<|del|> 
<|del|> 
<|del|> 
 final native void name(String n) /*-{ if(n)this.name=n; }-*/; 
<|del|> 
<|del|> 
public abstract class AbstractChangeNotesTest extends GerritBaseTests { 
<|del|> 
public class GerritBaseTests { 
<|del|> 
 Change change = notesFactory .create(db, refEvent.getProjectNameKey(), cid).getChange(); 
<|del|> 
 return rw.parseCommit(firstparent(rw, b)); 
 return rw.parseCommit(firstparent(rw, b)); 
 return createTestChange(testRepo, subject, "", "", parents, "refs/for/master"); 
<|del|> 
<|del|> 
 @NoHttpd 
 for (ChangeMessageInfo info : messages) { actual.add(info.message); 
<|del|> 
<|del|> 
 final List<CommitValidationMessage> messages = new LinkedList<>(); CommitUtils.runOnChangedTreeEntry(repo, c, new TreeWalkVisitor() { @Override public void onVisit(TreeWalk tw) { if (isSymLink(tw)) { addValidationMessage(messages, tw); 
<|del|> 
 * onVisit() method of the class TreeWalkVisitor. 
 public static void visitChangedEntries(Repository repo, RevCommit c, 
 TreeWalkVisitor visitor) throws IOException { 
public interface TreeWalkVisitor { 
 ProjectCache projectCache, ChangeNotes.Factory notesFactory) { 
 return Collections.unmodifiableCollection(refSpecs); 
 /** * Loads the .gitmodules file of the specified project/branch. * It can be queried which submodules this branch is subscribed to. */ 
<|del|> 
 Project.NameKey project = branch.getParentKey(); try (Repository repo = repoManager.openRepository(project); MetaDataUpdate md = metaDataUpdateFactory.create(project)) { ProjectConfig cfg = ProjectConfig.read(md); 
 return rw.parseAny(firstparent(rw, b)); 
 } 
 .view("files").id(path) .view("blame") .addParameter("base", base); 
 .render(Gerrit.RESOURCES.blame())); 
 @Override public void onSuccess(BlameInfo result) { cmA.extras().toggleAnnotation(result); } }); } 
 @Override public void onSuccess(BlameInfo result) { cmB.extras().toggleAnnotation(result); } }); } 
 }, edit != null, current, changeStatus.isOpen(), diff.binary()); 
 PageLinks.toChange(new Change.Id(blame.changeId()), String.valueOf(blame.patchSetId())) + "/" + path); 
 usage = "whether to load the blame of the base revision") 
 ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName(); 
 List<BlameInfo.BlameLine> localBlames = blame(parents[0].getId(), path, repository); List<BlameInfo.BlameLine> remoteBlames = blame(parents[1].getId(), path, repository); 
 List<BlameInfo.BlameLine> localBlames = blame(parents[0].getId(), path, repository); List<BlameInfo.BlameLine> remoteBlames = blame(parents[1].getId(), path, repository); 
 + " with more than 2 parents"); 
 internalChangeQuery.byCommit(ObjectId.fromString(blame.meta.id)); 
 && next.meta.id.equals(current.meta.id)); 
 final Grid formGrid = new Grid(13 + (flashClippy ? 1 : 0), 2); 
 // Initialize UUID for NoteDb on first init. String id = idSection.get(GerritServerIdProvider.KEY); if (Strings.isNullOrEmpty(id)) { idSection.set( GerritServerIdProvider.KEY, GerritServerIdProvider.generate()); } 
 String origId = cfg.getString(SECTION, null, KEY); if (!Strings.isNullOrEmpty(origId)) { 
 ParameterizedType parametrizedType = (ParameterizedType) typeOfT; if (parametrizedType.getActualTypeArguments().length != 1) { 
 Type supplierOf = parametrizedType.getActualTypeArguments()[0]; return Suppliers.ofInstance(context.deserialize(json, supplierOf)); 
 ParameterizedType parameterizedType = (ParameterizedType) typeOfT; if (parameterizedType.getActualTypeArguments().length != 1) { 
 Map<String, Short> labels = new HashMap<>(); 
 Map<String, Short> union = Collections.emptyMap(); 
 ObjectId b = ObjectId.fromString(revision.get()); ObjectId a = getObjectIdA(base, b, change, diffType); 
 try (Repository git = repoManager.openRepository(project)) { bId = toObjectId(psEntityB); aId = toObjectIdA(psEntityA, git); 
 ReplicationStateListener sl, Provider<SshSessionFactory> sshSessionFactoryProvider) { 
 return sshSessionFactoryProvider.get().getSession(uri, null, FS.DETECTED, SSH_REMOTE_TIMEOUT); 
<|del|> 
<|del|> 
 ChangeControl ctl = rev.getControl().forUser(reviewer); return new RevisionResource(changes.parse(ctl), rev.getPatchSet()); 
 ChangeControl ctl = rev.getControl().forUser(reviewer); return new RevisionResource(changes.parse(ctl), rev.getPatchSet()); 
 assertThat(approval.oldValue).isNull(); 
 * @param oldApprovals Map of label IDs to old approval scores 
 private Map<String, Short> approvals = new HashMap<>(); private Map<String, Short> oldApprovals = new HashMap<>(); 
<|del|> 
 oldApprovals.put(ent.getKey(), null); 
 public String oldValue; 
 protected boolean createProject(CredentialsProvider credentialsProvider, URIish uri, String projectName, String head) { 
 log.error(String.format("Error creating remote repository at %s:%n" + " Exception: %s%n Command: %s%n Output: %s", uri, e, 
 log.error(String.format("Error creating remote repository at %s:\n" + " Exception: %s\n Command: %s\n Output: %s", uri, e, 
 eventListenerRegistration = source.add(new UserScopedEventListener() { 
 eventListenerRegistration = source.add(new UserScopedEventListener() { 
 ReviewInput input = new ReviewInput().label(P.getName(), 0); input.message = "foo"; 
 assertThat(lastCommentAddedEvent.comment).isEqualTo( "Patch Set 1:\n\n" + input.message); 
 // get all approvals in cases of quick approve vote Map<String, Short> allApprovals = Collections.emptyMap(); 
 allApprovals = psaToMap(current.values()); 
 if (!Files.exists(hook)) { 
 removedVotesMsg.append("* ").append(a.getLabel()) 
 public void postUpdate(Context ctx) { if (changeMessage == null) { return; } 
 /** Next unique id for an {@link AccountSshKey}. */ 
 user.getAccountId(), max + 1), sshPublicKey); 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
<|del|> 
 @Option(name = "--json", aliases = "-j", usage = "read review input json from stdin") 
 Schema_120(Provider<Schema_119> prior) { 
Copyright (C) 2016 The Android Open Source Project 
 GerritGSSAuthenticator(AccountCache accounts, SshScope sshScope, SshLog sshLog, IdentifiedUser.GenericFactory userFactory, @GerritServerConfig Config config) { 
 return getProject().getState().equals( com.google.gerrit.extensions.client.ProjectState.HIDDEN); 
 return (user.isInternalUser() || canPerformOnAnyRef(Permission.READ)); 
Copyright (C) 2016 The Android Open Source Project 
 Text aText = new Text(a.getBytes(UTF_8)); Text bText = new Text(b.getBytes(UTF_8)); 
 @Test public void rewriteAtStartOfLineIsRecognized() throws Exception { String a = "abc1\n"; String b = "def1\n"; assertThat(intraline(a, b)).isEqualTo(wordEdit(0, 3, 0, 3)); } 
<|del|> 
 boolean apply(Project project, String hash, String name, GitRepositoryManager gitRepoManager) throws RefAlreadyExistsException, InvalidRefNameException, RefNotFoundException, GitAPIException, IOException; 
<|del|> 
<|del|> 
 public static final String TYPE = "ref-replication-scheduled"; 
 public final String targetNode; 
 this.targetNode = targetNode; 
<|del|> 
<|del|> 
 if (!currentLabels.containsKey(ent.getKey())) { 
 approvals.put(normName, (short) 0); 
 approvals.put(normName, (short) 0); 
<|del|> 
<|del|> 
 return sshKeyCache.create(new AccountSshKey.Id(id, 1), sshKey.trim()); 
 protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException { 
 stmt.execute("ALTER SEQUENCE ACCOUNT_SSH_KEY_ID RESTART WITH " + (maxId + 1) + ";"); 
 Project.NameKey submodule = new Project.NameKey(rs.getString(4)); Branch.NameKey subbranch = new Branch.NameKey(submodule, rs.getString(5)); allowSubmoduleSubscription(subbranch, superbranch); } } execute(db, "DROP TABLE submodule_subscriptions;"); 
 Project.NameKey submodule = new Project.NameKey(rs.getString(4)); Branch.NameKey subbranch = new Branch.NameKey(submodule, rs.getString(5)); allowSubmoduleSubscription(subbranch, superbranch); } } execute(db, "DROP TABLE submodule_subscriptions;"); 
 private void allowSubmoduleSubscription(Branch.NameKey submodule, 
 info = gApi.accounts().self().listSshKeys(); assertThat(info).hasSize(3); 
 MetaDataUpdate.User updateFactory, DraftCommentNotes.Factory draftNotesFactory, Provider<AllUsersName> allUsers, ChangeDraftUpdate.Factory draftUpdateFactory, 
 private final boolean replicatePermissions; private final String remoteNameStyle; private volatile WorkQueue.Executor pool; 
import com.google.common.base.MoreObjects; import com.google.common.collect.ImmutableList; import org.eclipse.jgit.lib.Config; import org.eclipse.jgit.transport.RemoteConfig; 
 "^(?:/a)?(?:/p/|/)(.+)(?:/info/lfs/objects/batch)$"; 
<|del|> 
 try { // TODO use StandardCharsets.UTF_8.name() with API level 19 return URLEncoder.encode(query, "UTF-8"); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } 
 private static final String STAR_FIELD = ChangeField.STAR.getName(); @Deprecated private static final String STARREDBY_FIELD = ChangeField.STARREDBY.getName(); 
 doc.add(new NumericDocValuesField(ID_SORT_FIELD, v)); 
 //TODO: expected failure // the current code does not work on the first line // and the insert marker is in the wrong location 
<|del|> 
<|del|> 
 expected.add(new Edit(0, 2, 0, 0)); expected.add(new Edit(8, 10, 6, 6)); 
 if (s.charAt(i) == '\n') { count++; } 
 if (!binary && open && idActive != null && Gerrit.isSignedIn()) { if ((editExists && idActive.get() == 0) || (!editExists && current)) { 
 } // The line might be within or after a diff chunk. 
 Edit e = edits.get(i); 
<|del|> 
 public List<Path> getAllBasePaths() { List<Path> basePaths = new ArrayList<>(); 
 if (repoConfig.getAllBasePaths().isEmpty()) { 
<|del|> 
 final private List<RefSpec> refSpecs; final private Project.NameKey project; 
<|del|> 
 Project.NameKey project = branch.getParentKey(); logDebug("Loading .gitmodules of {} for project {}", branch, project); try (Repository repo = repoManager.openRepository(project); 
 Project.NameKey project = branch.getParentKey(); logDebug("Loading .gitmodules of {} for project {}", branch, project); try (Repository repo = repoManager.openRepository(project); 
 for (Ref ref : repo.getRefDatabase().getRefs( RefNames.REFS_HEADS).values()) { 
 ProjectConfig cfg = projectCache.get(project).getConfig(); try { 
 Collection<Branch.NameKey> updatedBranches, String updateId) 
 private void allowSubmoduleSubscription(Branch.NameKey submodule, 
 SubscribeSection s = new SubscribeSection(superProject.getParentKey()); // For the migration we use only exact RefSpecs, we're not trying to // generalize it. 
 SubscribeSection s = new SubscribeSection(superProject.getParentKey()); // For the migration we use only exact RefSpecs, we're not trying to // generalize it. 
 ui.message("Errors occurred during update."); 
 assertThat(intraline(a, b)).isEqualTo(ref() .common("start middle").insert("middle").common(" end\n").edits ); 
 * over its data type, exposed as a map of version number to schema definition. 
<|del|> 
Copyright (C) 2016 The Android Open Source Project 
 private final RefValidationHelper refCreationValidator; private String ref; 
 protected GerritSshApi(SshHelper sshHelper) { this.sshHelper = sshHelper; 
<|del|> 
<|del|> 
<|del|> 
 } } finally { replaying = false; 
 /** * Check if the height of the browser view is greater than its width. */ public static boolean isPortrait() { return Window.getClientHeight() > Window.getClientWidth(); } 
Copyright (C) 2014 The Android Open Source Project 
 private Map<String, Short> newApprovals = new HashMap<>(); private Map<String, Short> oldApprovals = new HashMap<>(); 
 private Op(Account.Id accountId, String label) { 
 cm.setFrom(user.getAccountId()); 
 protected DeleteVoteSender(EmailArguments ea, 
<|del|> 
 public static class Line { public Meta meta; 
 public static class Meta { 
<|del|> 
<|del|> 
<|del|> 
 public final native JsArray<BlameLine> blames() /*-{ return this.blames; }-*/; 
 private Anchor createBlameIcon() { 
 String detailedBlameMsg(String commitId, String author, String time, String msg); 
 String detailedBlameMsg(String commitId, String author, String time, String msg); 
<|del|> 
 public final native boolean isAnnotated(CodeMirror c) /*-{ 
 for (int l = fromTo.from() - 1; l < fromTo.to(); l++) { annotations .push(LintLine.create(shortBlame, detailedBlame, shortId, Pos.create(l))); 
 + " content:'" + shortMsg + "';\n" 
<|del|> 
 List<BlameInfo.Line> commonBlames = blame(repository.resolve(blameRef).toObjectId(), path, repository, revWalk); List<BlameInfo.Line> blames; 
 List<BlameInfo.Line> commonBlames = blame(repository.resolve(blameRef).toObjectId(), path, repository, revWalk); List<BlameInfo.Line> blames; 
 List<BlameInfo.Line> commonBlames = blame(repository.resolve(blameRef).toObjectId(), path, repository, revWalk); List<BlameInfo.Line> blames; 
 List<BlameInfo.Line> localBlames = blame(parents[0].getId(), path, repository, revWalk); List<BlameInfo.Line> remoteBlames = blame(parents[1].getId(), path, repository, revWalk); 
<|del|> 
<|del|> 
 private static List<BlameInfo.Line> selectBlames( ConflictMarker conflictMarker, List<BlameInfo.Line> commonBlames, List<BlameInfo.Line> localBlames, List<BlameInfo.Line> remoteBlames) { switch (conflictMarker) { 
 private List<BlameInfo.Line> blame(ObjectId id, String path, Repository repository, RevWalk revWalk) throws IOException { 
 && next.meta.id.equals(current.meta.id)); 
 bind(BlameCache.class).to(BlameCacheImpl.class); 
 cfg.setString(SECTION, indexDirName(ChangeSchemaDefinitions.NAME, v), KEY_READY, ready); 
 GetPreferences(Provider<CurrentUser> self, AccountCache accountCache) { 
 IndexCollection<Account.Id, AccountState, AccountIndex> { 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
<|del|> 
 return new RAMDirectory(); } else { Path indexDir = LuceneVersionManager.getDir(sitePaths, ACCOUNTS + "_", schema); return FSDirectory.open(indexDir); 
 @Assisted Schema<AccountState> schema) throws IOException { super(schema, sitePaths, dir(schema, cfg, sitePaths), ACCOUNTS, 
 ImmutableList.<SchemaDefinitions<?>>of( AccountSchemaDefinitions.INSTANCE, ChangeSchemaDefinitions.INSTANCE, GroupSchemaDefinitions.INSTANCE); 
 AccountIndexDefinition accounts, ChangeIndexDefinition changes, GroupIndexDefinition groups) { 
<|del|> 
 bind(BlameCache.class).to(BlameCacheImpl.class); 
 bind(BlameCache.class).to(BlameCacheImpl.class); 
<|del|> 
 private final List<RefSpec> refSpecs; private final Project.NameKey project; 
 ? "" 
import java.util.Map; 
 public static class Line extends JavaScriptObject { 
 public final BlameInfo.Line getBlame(int lineNum) { 
 RevWalk revWalk = new RevWalk(repository)) { 
 public Boolean allowBlame; public Boolean allowDrafts; 
 + "from " + tableName)) { 
<|del|> 
 public AllDiffScreen( PatchSet.Id base, PatchSet.Id revision, DiffView diffScreenType) { 
 void setUpBlameIconA(CodeMirror cm, boolean isBase, PatchSet.Id rev, String path) { 
 void setUpBlame(final CodeMirror cm, final boolean isBase, final PatchSet.Id rev, final String path) { 
 for (int l = fromTo.from() - 1; l < fromTo.to(); l++) { annotations .push(LintLine.create(shortBlame, detailedBlame, shortId, Pos.create(l))); 
 for (int l = fromTo.from() - 1; l < fromTo.to(); l++) { annotations .push(LintLine.create(shortBlame, detailedBlame, shortId, Pos.create(l))); 
 public final native BlameInfo getBlameInfo() /*-{ 
 public final native void setBlameInfo(BlameInfo blame) /*-{ 
 public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) { if (Element.as(clickEvent.getEventTarget()) .hasClassName(getLineNumberClassName()) 
 PersonIdent p = new PersonIdent(repo.getRepository()); 
<|del|> 
<|del|> 
 annotations.push(LintLine.create(shortBlame, detailedBlame, shortId, 
 /** Tag associated with change message */ 
 @GerritServerConfig Config cfg) { 
 throws RestApiException, OrmException, IOException, 
 throw new ResourceNotFoundException( "Cannot generate blame for merge commit with more than 2 parents"); 
<|del|> 
 fireEventForUnrestrictedListeners(event); 
 HookResult doRefUpdateHook(Project project, String refName, 
 ctx.getWhen(), currPs); 
 factory(DeleteVoteSender.Factory.class); 
/** Let users know that a reviewer and possibly her review have 
 msgs.add("Repository not found for change, cannot convert: " + c); 
 gApi.changes().id(id.get()).topic(name("new-topic")); checker.checkChanges(id); 
 StringBuilder sb = new StringBuilder(changeMetaId().name()); 
 ds.setRemoveAbandoned( cfg.getBoolean("database", "removeabandoned", false)); ds.setRemoveAbandonedTimeout( cfg.getInt("database", "removeabandonedtimeout", 300)); ds.setLogAbandoned(cfg.getBoolean("database", "logabandoned", false)); 
 String getLineNumberClassName() { return LINE_NUMBER_CLASSNAME; 
 String getLineNumberClassName() { return UnifiedTable.style.unifiedLineNumber(); 
 return rev; } else { new ErrorDialog( Resources.M.changeWithNoRevisions(info.legacyId().get())).center(); throw new IllegalStateException("no revision, cannot proceed"); 
<|del|> 
 from.line(fromInfo.line); // Force the end line to be on the same side as the start line. 
 GerritGSSAuthenticator(AccountCache accounts, SshScope sshScope, SshLog sshLog, IdentifiedUser.GenericFactory userFactory, @GerritServerConfig Config config) { 
 return input.getUserName().toLowerCase(); 
 ApprovalAttribute attr = getApprovalAttribute(label); 
 // reply message only so vote is shown as 0 ApprovalAttribute attr = getApprovalAttribute(label); 
 usage = "index name to start") 
 } finally { if (rw != null) { rw.close(); } 
<|del|> 
<|del|> 
 usage = "whether to load the blame of the base revision (the direct" + " parent of the change) instead of the change") public void setBase() { this.base = true; 
 usage = "whether to load the blame of the base revision (the direct" + " parent of the change) instead of the change") public void setBase() { this.base = true; 
 usage = "whether to load the blame of the base revision (the direct" + " parent of the change) instead of the change") public void setBase() { this.base = true; 
 blameObj = revCommit.toObjectId(); 
 List<BlameInfo.Line> theirsBlames = blame(parents[1].getId(), path, 
 List<BlameInfo.Line> oursBlames, List<BlameInfo.Line> theirsBlames) { 
 private void parseCreate(final ReceiveCommand cmd) { 
 throws OrmException, IOException { 
 DiffInfo diff = getDiff.apply(resource).value(); List<BlameInfo.Line> common = blame(revCommit, path, repository, revWalk); blames = blameAutoMergeTree(diff, common, oursBlames, theirsBlames); 
 public final native void setBlameInfo(JsArray<BlameInfo> blameInfos) /*-{ this['blameInfos'] = blameInfos; 
 public void setBase(boolean on) { 
 // Jetty doesn't doesn't allow symlinks, so canonicalize. sourceRoot = findSourceRoot().toRealPath(); 
 static public String renderMessageWithApprovals(int patchSetId, 
<|del|> 
 message.append("\n").append(reviewMessage); 
 Maps.newHashMapWithExpectedSize(parts.size() - 1); 
 .id(admin.getId().toString()) 
 checkArgument(!parts.isEmpty(), "invalid state string for change %s: %s", id, str); 
 Maps.newHashMapWithExpectedSize(parts.size() - 1); 
 checkArgument(draftParts.size() == 2, "invalid draft state part for change %s: %s", id, p); 
 * the All-Users meta repo for any affected changes, with proper ordering. 
 Schema_121(Provider<Schema_120> prior) { 
 text.append(" commented\\n>>>"); 
 info.jsResourcePaths = new ArrayList<>(); 
<|del|> 
 if (newState == null) { return super.openHandle(repo); // May be null in tests. } 
 if (walk() != null) { walk().close(); } 
 && ((CommitValidationMessage) obj).getMessage().equals(getMessage()); 
 return Objects.hash(getMessage(), isError()); 
 Account.Id submitter, NotifyHandling notifyHandling); 
 this.draftUpdateFactory = draftUpdateFactory; this.robotCommentUpdateFactory = robotCommentUpdateFactory; 
 public static String renderMessageWithApprovals(int patchSetId, 
<|del|> 
 .view("files") .id(path) 
 boolean reviewingBase = base == null; getDiffTable().setUpBlameIconA(cmA, reviewingBase, reviewingBase ? revision : base, path); getDiffTable().setUpBlameIconB(cmB, revision, path); 
 shortId, format.format(commitTime), line.author()); 
 try (ObjectInserter ins = repo.newObjectInserter()) { commitId = ins.insert(cb); ins.flush(); 
 throw expectedOneFooter(FOOTER_TAG, tagLines); 
<|del|> 
 private List<BlameInfo.Blame> blame(ObjectId id, String path, 
 } annotations.push(LintLine.create(shortBlame, detailedBlame, shortId + "-" + side + "-" + i, Pos.create(i), blameNum % 2 == 0)); 
 private final native String grantedRaw() /*-{ return this.granted; }-*/; 
<|del|> 
 expected.add("invalid characters found in filename: " + filenames + true); 
 return Lists.transform(messages, new Function<CommitValidationMessage, String>() { @Override public String apply(CommitValidationMessage input) { return input.getMessage() + input.isError(); } }); 
 return ImmutableList.copyOf(cfg.getStringList(SECTION_NAME, findSubSection(project.get()), OWNER_GROUP_NAME)); 
 return ImmutableList.copyOf(groups); 
 public void moveChangeWithShortRef() throws Exception { 
<|del|> 
 @Column(id = 8, notNull = false, length = 255) 
 extractMailExample("DeleteReviewer.vm"); extractMailExample("DeleteVote.vm"); 
<|del|> 
<|del|> 
 public void addReviewers(Collection<Account.Id> cc) { 
 public void addReviewers(Collection<Account.Id> cc) { 
 includeWatchers(NotifyType.ALL_COMMENTS); add(RecipientType.TO, reviewers); 
 String pre = (input.isError()) ? "ERROR: " : "MSG: "; return pre + input.getMessage(); 
 RevCommit am = autoMerger.merge(repo, walk, b, mergeStrategy); return am == null ? null : am.getTree(); 
 cb.setMessage("Auto-merge of " + merge.name()); for (RevCommit p : merge.getParents()) { 
 * Perform an auto-merge of the parents of the given merge commit. * 
 return ImmutableList.copyOf(cfg.getStringList(SECTION_NAME, findSubSection(project.get()), OWNER_GROUP_NAME)); 
 Paths.get("/someBasePath1"), Paths.get("/someBasePath2"), 
 Comment comment1 = newComment( psId, filename, uuid1, range, range.getEndLine(), otherUser, null, timeForComment1, "comment 1", side, rev, false); 
 Comment comment1 = newComment( psId, filename, uuid1, range, range.getEndLine(), otherUser, null, timeForComment1, "comment 1", side, rev, false); 
public class AutoMerger { 
public class AutoMerger { 
 int adjustedLength = Patch.COMMIT_MSG.equals(path) ? 72 : length; cmOrig.extras().lineLength(adjustedLength); cmEdit.extras().lineLength(adjustedLength); 
 cmOrig.setOption("showTrailingSpace", show); 
 cmEdit.operation(new Runnable() { 
 .set("value", "")); 
 ApprovalAttribute labelAttr = getApprovalAttribute(label); assertThat(labelAttr.oldValue).isEqualTo("0"); assertThat(labelAttr.value).isEqualTo("-1"); 
 ApprovalAttribute pLabelAttr = getApprovalAttribute(pLabel); assertThat(pLabelAttr.oldValue).isNull(); assertThat(pLabelAttr.value).isEqualTo("0"); 
 LabelType crLabel = LabelType.withDefaultValues("Code-Review"); ApprovalAttribute crlAttr = getApprovalAttribute(crLabel); assertThat(crlAttr.oldValue).isNull(); assertThat(crlAttr.value).isEqualTo("0"); 
 LabelType crLabel = LabelType.withDefaultValues("Code-Review"); ApprovalAttribute crlAttr = getApprovalAttribute(crLabel); assertThat(crlAttr.oldValue).isNull(); assertThat(crlAttr.value).isEqualTo("0"); 
 return Lists.transform(messages, new Function<CommitValidationMessage, String>() { @Override public String apply(CommitValidationMessage input) { return input.getMessage() + input.isError(); } }); 
 @Option(name = "--install-all-plugins", usage = "Install all plugins from war without asking") 
 ui.message( "Cannot use --install-plugin together with --install-all-plugins.\n"); 
 } sshKeyCache.evict(user.getUserName()); return Response.<SshKeyInfo>created(new SshKeyInfo(sshKey)); } catch (InvalidSshKeyException e) { throw new BadRequestException(e.getMessage()); 
 VersionedAuthorizedKeys.Accessor authorizedKeys) { 
 this.authorizedKeys = authorizedKeys; 
<|del|> 
<|del|> 
 for (String blockedExtension : getBlockedExtensions(cfg)) { if (file.toLowerCase().endsWith(blockedExtension)) { 
 * Creates a new CommentAddedMessageGenerator instance using the provided 
 } else { // 3 stage conflict, no resolve above 
<|del|> 
 JsArray<FileInfo> files = result.values(); 
 reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES); 
 gitRefUpdated.fire(projectName, ru, user == null ? null : user.getAccount()); 
<|del|> 
 public boolean updateChange(ChangeContext ctx) 
 LabelTypes labelTypes = ctx.getControl().getLabelTypes(); 
<|del|> 
<|del|> 
<|del|> 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 try (ReviewDb db = schema.get()) { 
 new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, b), 10)) { 
 try (ReviewDb db = schema.get()) { 
<|del|> 
 try (ReviewDb db = schema.get()) { 
 .suggestByKey( new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, b), 10)) { 
 .suggestByKey( new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, b), 10)) { 
 .suggestByEmailAddress(a, b, 10)) { 
<|del|> 
 return Collections.singleton(m.get(0).getId()); 
 result.add(extId.getAccountId()); 
 ReviewDb db = null; db = schema.get(); try { Account account = db.accounts().get(id); } finally { if ( db != null ) { db.close(); db = null; } } 
 ReviewDb db = null; db = schema.get(); try { Account account = db.accounts().get(id); } finally { if ( db != null ) { db.close(); db = null; } } 
 ReviewDb db = null; db = schema.get(); try { Account account = db.accounts().get(id); } finally { if ( db != null ) { db.close(); db = null; } } 
<|del|> 
 for (String blockedExtension : lowercaseExtensions) { 
<|del|> 
 if (mergeResultRev != null) { 
 @Column(id = 9, notNull = false) 
 RevCommit base = prevEdit.getParent(0); rw.parseHeaders(base); tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree()); if (tw == null) { dce.add(new DeletePath(fileName)); break; } 
 public static final String FILE_NAME = "authorized_keys"; 
 Header(KeyCommandSet keys, PatchSet.Id base, PatchSet.Id patchSetId, String path, DiffView diffSreenType, DiffPreferences prefs) { 
 String[] resourcePaths = { "/usr/share/gitweb/static", "/usr/share/gitweb", "/var/www/static", "/var/www", }; 
@RequiresCapability(value = GlobalCapability.MAINTAIN_SERVER, scope = CapabilityScope.CORE) @CommandMetaData(name = "fsck", description = "Check specific projects or changes") 
 @Option(name = "--fix", usage = "attempt fixing errors, may remove missing changes from DB") 
 if (change == null || change.size() == 0) { 
 public static final String INVALID_KEY_COMMENT_PREFIX = "# INVALID "; 
 @Override public void load(Repository git) throws IOException, ConfigInvalidException { checkState(this.git == null); this.git = git; super.load(git); } @Override 
 return Lists.newArrayList(Optional.presentInstances(keys.values())); 
<|del|> 
 keys.put(seq, Optional.of(key)); 
 boolean hasCommentForPath(String filePath) { 
<|del|> 
 String[] invalidFilenamePattern = {"^.*(\\[|\\]|\\*|#).*$", "[%:@]"}; 
 public static <V> Schema<V> schema(Schema<V> schema, 
 return cd.starredBy().contains(accountId); 
import java.io.IOException; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.Set; 
 private static final Logger log = LoggerFactory.getLogger(StarredChangesUtil.class); 
 public ResultSet<Change.Id> query(Account.Id accountId) { try { if (!migration.readChanges()) { return new ChangeIdResultSet( dbProvider.get().starredChanges().byAccount(accountId)); } 
 public ResultSet<Change.Id> query(Account.Id accountId) { try { if (!migration.readChanges()) { return new ChangeIdResultSet( dbProvider.get().starredChanges().byAccount(accountId)); } 
 batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName)); 
<|del|> 
import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.revwalk.RevWalk; 
<|del|> 
 SSH, HTTP 
<|del|> 
 public ImmutableMap<Account.Id, StarRef> byChange(Change.Id changeId) throws OrmException { 
 Integer id = Ints.tryParse(s.substring(0, p)); if (id == null) { 
 PermissionBackend.ForChange perm = permissionBackendForChange(user, cd); 
 public static class Star implements RestResource { public static final TypeLiteral<RestView<Star>> STAR_KIND = new TypeLiteral<RestView<Star>>() {}; private final IdentifiedUser user; 
 throw new AuthException( "not allowed to list stars of another account"); 
 .deleteVote("Code-Review"); 
<|del|> 
 if (msg.length() > 0) { changeMessage = new ChangeMessage( new ChangeMessage.Key(currChange.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), currPs.getId()); 
 private final boolean enableGwtUi; 
 this.enableGwtUi = cfg.getBoolean("gerrit", null, "enableGwtUi", true); 
 cmEdit.setOption("indentUnit", Patch.COMMIT_MSG.equals(path) ? 2 : indent); 
 this.enableGwtUi = cfg.getBoolean("gerrit", null, "enableGwtUi", true); 
 private static class PolyGerritFilter implements Filter { private final GerritOptions options; 
 if (blameCache.findLastCommit(repository, id, path) == null) 
 @Named(CACHE_NAME) LoadingCache<String, Pattern> patternCache, FileTypeRegistry mimeUtil) { 
 @Named(CACHE_NAME) LoadingCache<String, Pattern> patternCache, FileTypeRegistry mimeUtil) { 
 IdentifiedUser.GenericFactory userFactory, AccountCache accountCache, 
 ContentTypeUtil contentTypeUtil, PluginConfigFactory cfgFactory, 
 public void testMatchesAny() throws ExecutionException { ContentTypeUtil ctu = new ContentTypeUtil(PATTERN_CACHE); String[] patterns = 
 .review(ReviewInput.reject()); 
 .review(ReviewInput.reject()); 
 .review(ReviewInput.dislike()); 
 .review(ReviewInput.recommend()); 
 .review(ReviewInput.approve()); 
 checkMutuallyExclusiveLabels(labels); 
 public void setStars(String changeId, StarsInput input) throws RestApiException { 
public class Stars implements ChildCollection<AccountResource, AccountResource.Star> { 
 gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue"))); 
 assertThat(change.stars) .containsExactly("blue", "red", DEFAULT_LABEL).inOrder(); assertThat(gApi.accounts().self().getStars(triplet)) .containsExactly("blue", "red", DEFAULT_LABEL).inOrder(); 
<|del|> 
 public StarsInput() { 
 } Account.Id accountId = new Account.Id(id); String label = s.substring(p + 1); return create(accountId, label); 
 return stars.list().apply(account); } catch (OrmException e) { 
 @Deprecated static final Schema<ChangeData> V37 = schema(V36); 
import java.sql.Connection; import java.sql.PreparedStatement; 
 assertThat(e.getMessage()).isEqualTo("revision not current"); 
<|del|> 
<|del|> 
 usage = "whether to load the blame of the base revision (the direct" + " parent of the change) instead of the change") public void setBase() { this.base = true; 
 public void setBase(@SuppressWarnings("unused") boolean on) { // Ignoring method parameter to support usage of argument without requiring // to specify boolean value. 
 } else if (p.endsWith("*") && s.startsWith(p.substring(0, p.length() - 1))) { 
 final ProjectState project; 
 private OpenRepo(Repository repo, ProjectState project) { 
 throw new SubmoduleException("Could not update superproject", e); 
Copyright (C) 2016 The Android Open Source Project 
 ALLOW, DENY, BLOCK, INTERACTIVE, BATCH 
Copyright (C) 2016 The Android Open Source Project 
 TagApiImpl.Factory tagApiFactory, GetAccess getAccess, SetAccess setAccess, ListBranches listBranches, ListTags listTags, 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 AccessApiImpl(GetAccess getAccess, @Assisted ProjectResource project) { 
<|del|> 
 ProjectConfig config = resource.getControl().getProjectState().getConfig(); ProjectControl pc = resource.getControl(); RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG); 
 public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, String tag, Timestamp date) { 
<|del|> 
 private IdentifiedUser author; 
 referenceUpdated.fire( name.getParentKey(), u, ReceiveCommand.Type.CREATE, 
 PatchLineCommentsUtil plcUtil, 
 info.local.put(name, createAccessSection(section)); 
 info.local.put(name, createAccessSection(section)); 
 } else if (metaConfigControl.isVisible()) { info.local.put(section.getName(), createAccessSection(section)); 
 } else if (metaConfigControl.isVisible()) { info.local.put(section.getName(), createAccessSection(section)); 
 } else if (metaConfigControl.isVisible()) { info.local.put(section.getName(), createAccessSection(section)); 
 } else if (metaConfigControl.isVisible()) { info.local.put(section.getName(), createAccessSection(section)); 
 String newProjectName = createProject("newProjectAccess").get(); 
<|del|> 
 ProjectCache projectCache, MetaDataUpdate.Server metaDataUpdateFactory, GroupControl.Factory groupControlFactory, GroupBackend groupBackend, AllProjectsName allProjectsName, ProjectJson projectJson) { 
 AccessApiImpl create(ProjectResource project); 
 AccessApiImpl(GetAccess getAccess, @Assisted ProjectResource project) { 
 try { ok = Iterables.all( Futures.allAsList(futures).get(), Predicates.equalTo(true)); } catch (InterruptedException | ExecutionException e) { log.error("Error rebuilding projects", e); ok = false; } 
 LoggerFactory.getLogger(ChangeRebuilderImpl.class); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 CallbackGroup group1 = new CallbackGroup(); 
 if (revision.get() > 0) { baseContent = fc; } 
 @Option(name = "--base", aliases = {"-b"}, 
 private final AutoMerger autoMerger; 
<|del|> 
 return id.hashCode(); } 
<|del|> 
 @Column(id = 9) 
 if (Boolean.TRUE.equals(ent.getValue().abstain)) { c.setAbstain(true); } 
 cfg.unset("plugin", pluginName, "showJobsPanel"); 
 cfg.unset("plugin", pluginName, "showJobsDropDownPanel"); 
 ListMultimap<BlameInfo, RangeInfo> ranges = ArrayListMultimap.create(); 
 ranges.put(blameInfo, new RangeInfo(from, from + region.getCount() - 1)); 
 private static BlameInfo toBlameInfo(RevCommit commit, PersonIdent sourceAuthor) { 
 diffTable.removeStyleName(SideBySideTable.style.showLineNumbers()); 
 void setShowLineNumbers(boolean b) { 
 void setShowLineNumbers(boolean b) { super.setShowLineNumbers(b); 
 try { return this.apply(new ProjectResource( projectControlFactory.controlFor(nameKey, self.get()))); } catch (NoSuchProjectException e) { throw new ResourceNotFoundException(nameKey.get()); } 
 throws ResourceNotFoundException, ResourceConflictException, IOException { 
 return this.apply(nameKey); 
 return this.apply(nameKey); 
 usage = "projects for which the access rights should be returned") 
 public ProjectAccessInfo get() throws RestApiException { try { return getAccess.apply(project); } catch (IOException e) { throw new RestApiException("Cannot get access rights", e); } 
 final LineMapper lineMapper; 
<|del|> 
<|del|> 
 index(id); 
 public Boolean showBase; 
 String hideBase(); 
 ChangeEditApi.get(revision, path, true /* base */, new HttpCallback<NativeString>() { 
 private void setCmBaseValue() { cmBase.setValue(baseContent != null && baseContent.getResult() != null 
 ChangeEditApi.getFileContent(revision.getParentKey().get(), result.baseRevision(), path, 
 removeUser(accountState.getAccount()); 
<|del|> 
 A, B 
 return cfg.getBoolean(SECTION, indexDirName(indexName, version), KEY_READY, false); 
 this.name = name; final String index = Joiner.on('_').skipNulls().join(name, subIndex); 
<|del|> 
 private final String REFS_ALL = Constants.R_REFS + "*"; 
<|del|> 
<|del|> 
<|del|> 
 public void addAccessSection() throws Exception { 
 ProjectAccessInput accessInfo = newProjectAccessChangeInfo(); 
 public void removePermissionRulesAndCleanupEmptyEntries() throws Exception { 
 private AccessSectionInfo newAccessSectionInfo() { 
 return Objects.equals(permissions, ((AccessSectionInfo) obj).permissions); 
 if (!Objects.equals(label, p.label)) { return false; } if (!Objects.equals(exclusive, p.exclusive)) { return false; } if (!Objects.equals(rules, p.rules)) { return false; } 
 if (!Objects.equals(label, p.label)) { return false; } if (!Objects.equals(exclusive, p.exclusive)) { return false; } if (!Objects.equals(rules, p.rules)) { return false; } 
 public ProjectAccessInfo access(ProjectAccessInput p) throws RestApiException { 
 public ProjectAccessInfo access(ProjectAccessInput p) throws RestApiException { try { return setAccess.apply(checkExists(), p); } catch (IOException e) { throw new RestApiException("Cannot put project description", e); } 
 if (section != null) { 
 if (section != null && permission != null) { 
<|del|> 
<|del|> 
 private final Provider<MetaDataUpdate.User> metaDataUpdateFactory; 
 boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { checkGlobalCapabilityPermissions(config.getName()); } if (isGlobalCapabilities 
 boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { checkGlobalCapabilityPermissions(config.getName()); } if (isGlobalCapabilities 
 if (!Strings.isNullOrEmpty(input.message)) { 
 if (!Strings.isNullOrEmpty(input.message)) { 
 } catch (InvalidNameException e) { throw new ResourceNotFoundException(e.toString()); } catch (ConfigInvalidException e) { throw new ResourceConflictException(rsrc.getName()); 
 if (entry.getValue().permissions == null) { continue; } 
 if (permissionEntry.getValue().rules == null) { continue; } for (Map.Entry<String, PermissionRuleInfo> permissionRuleInfoEntry : permissionEntry.getValue().rules.entrySet()) { 
 if (group == null) { throw new ResourceNotFoundException( permissionRuleInfoEntry.getKey() + " is not a valid group ID"); 
 ProjectConfig config, MetaDataUpdate md) throws IOException { 
<|del|> 
 throws OrmException, AccountException, IOException, ConfigInvalidException { 
 private static final RegExp CHANGE_ID_PATTERN = RegExp.compile("^" + ID_PATTERN); private static final RegExp UNIQUE_CHANGE_ID_PATTERN = RegExp.compile("^(.)+~(.)+~" + ID_PATTERN); 
 if (CHANGE_ID_PATTERN.test(query) || UNIQUE_CHANGE_ID_PATTERN.test(query)) { 
 ? ObjectId.fromString( edit.getBasePatchSet().getRevision().get()) : ObjectId.fromString(edit.getRevision().get()), 
 public static boolean isEndingWithAutoClose(String refName) { 
 public void markUninteresting(RevCommit c) throws MissingObjectException, IncorrectObjectTypeException, IOException { 
 addonUris.put(Addons.I.merge_bundled().getName(), Addons.I.merge_bundled().getSafeUri()); 
<|del|> 
 /** Checks if the supplied ref name ends with auto-close parameter */ 
<|del|> 
 ProjectAccessInput accessInput = newProjectAccessInput(); 
 accessInput.addition.get(REFS_HEADS).permissions .remove(Permission.LABEL + LABEL_CODE_REVIEW); 
 accessInput.addition.get(REFS_HEADS).permissions .get(Permission.LABEL + LABEL_CODE_REVIEW) 
 accessInput.addition.put(AccessSection.GLOBAL_CAPABILITIES, 
 exception.expect(AuthException.class); gApi.projects().name(allProjects.get()).access(accessInput); 
 accessInput.addition.put(AccessSection.GLOBAL_CAPABILITIES, 
 gApi.projects().name(allProjects.get()).access(accessInput); 
 accessInput.addition.clear(); accessInput.deduction.put(AccessSection.GLOBAL_CAPABILITIES, 
 private ProjectAccessInput newProjectAccessInput() { 
 accessSection.permissions.put(Permission.LABEL + LABEL_CODE_REVIEW, codeReview); 
 if (!Objects.equals(label, p.label)) { return false; } if (!Objects.equals(exclusive, p.exclusive)) { return false; } if (!Objects.equals(rules, p.rules)) { return false; } 
 throw new RestApiException("Cannot put access rights", e); 
 checkGlobalCapabilityPermissions(config.getName()); } else if (!projectControl.controlForRef(section.getName()).isOwner()) { throw new AuthException("You are not allowed to edit permissions" + "for ref: " + section.getName()); 
 throw new BadRequestException(e.toString()); 
 if (entry.getValue().permissions == null) { continue; } 
 throw new UnprocessableEntityException( 
 throws BadRequestException, AuthException { 
 + "for projects other than " + allProjects.get()); 
 + "for projects other than " + allProjects.get()); 
 if (!identifiedUser.get().getCapabilities().canAdministrateServer()) { throw new AuthException("Editing global capabilities " + "requires " + GlobalCapability.ADMINISTRATE_SERVER); 
 public DiffPreferencesInfo getDiffPreferences() throws RestApiException { 
 if (!identifiedUser.get().getCapabilities().canAdministrateServer()) { throw new AuthException("Editing global capabilities " + "requires " + GlobalCapability.ADMINISTRATE_SERVER); 
<|del|> 
<|del|> 
 void deleteWatchedProjects(DeleteWatchedProjectsInput in) 
<|del|> 
<|del|> 
 throws OrmException, UnprocessableEntityException, AuthException, BadRequestException, IOException { if (self.get() != rsrc.getUser()) { throw new AuthException("It is not allowed to edit project watches " + "of other users"); } 
 throw new BadRequestException("Project name must be specified"); 
 Project.NameKey projectKey = projectsCollection.parse(a.project).getNameKey(); 
 getIndex().replace(byIdCache.get(id)); 
 int seq = keys.size() + 1; 
 keys.set(seq - 1, Optional.<AccountSshKey> absent()); 
<|del|> 
 if (!isGlobalCapabilities) { if (!AccessSection.isValid(name)) { throw new BadRequestException(""); } 
 throw new AuthException("You are not allowed to edit permissions" + "for ref: " + name); 
<|del|> 
 throws UnprocessableEntityException { 
 if (permissionEntry.getValue().rules == null) { continue; } 
 private void updateProjectConfig(CurrentUser user, ProjectConfig config, MetaDataUpdate md, ObjectId base) throws IOException { 
 static Tree toJsonData(ObjectId id, TreeWalk tw, boolean includeSizes) throws IOException { 
 if (includeSizes) { 
<|del|> 
<|del|> 
 .containsExactlyElementsIn(projectsToWatch).inOrder(); 
 assertThat(persistedWatchedProjects).doesNotContain(wpi); assertThat(persistedWatchedProjects).containsAllIn(projectsToWatch); 
 throw new UnprocessableEntityException(projectKeyToDelete 
 public boolean enableGwtUi() { return !headless && enableGwtUi; 
 private class PolyGerritModule extends ServletModule { 
 private class PolyGerritModule extends ServletModule { 
 String v = c.getValue().toUpperCase(); UiPreference pref = Enums.getIfPresent(UiPreference.class, v).or(siteDefault); return pref == UiPreference.POLYGERRIT; 
<|del|> 
<|del|> 
<|del|> 
 private Iterable<String> getUsernames(CurrentUser user) { 
 if (user.getUserName() == null) { return emails; } else if (emails.isEmpty()) { return ImmutableSet.of(user.getUserName()); } Iterables.concat(emails, ImmutableSet.of(user.getUserName())); 
 return ImmutableSet.of(user.getUserName()); 
 private Set<String> getUsernames(CurrentUser user) { Set<String> r; 
 @Test public void signNonExistingAgreement() throws Exception { exception.expect(ResourceNotFoundException.class); gApi.accounts().self().signAgreement("does-not-exist"); } @Test 
 public List<AgreementInfo> apply(AccountResource resource) throws RestApiException { if (!agreementsEnabled) { throw new MethodNotAllowedException("contributor agreements disabled"); } 
 List<AccountGroup.UUID> groupIds = new ArrayList<>(); 
 .createMergeCommit(git, oi, mergeTip, sourceCommit, author, commitMessage, rw); 
 ThreeWayMerger m = newThreeWayMerger(repo, inserter); 
 final AtomicReference<IOException> ioe = 
 icoe.set(new InvalidChangeOperationException( "Invalid object id: " + e.getMessage())); 
// limitations under the License. 
 Provider<IdentifiedUser> self) { 
 throws AuthException, BadRequestException, OrmException, IOException, ConfigInvalidException { 
 throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException { 
 void deleteWatchedProjects(List<String> in) 
 .containsAllIn(projectsToWatch).inOrder(); 
 String projectName = project.get(); 
 RunwayStatus requestRunway(PushOne op) { 
 static final String TYPE = "ref-replication-scheduled"; 
 final String project; final String ref; final String targetNode; 
 final String project; final String ref; final String targetNode; 
<|del|> 
 final List<AccountGroupById> toRemove = new LinkedList<>(); 
 final Map<AccountGroup.UUID, AccountGroupById> groups = new HashMap<>(); 
 checkSequenceValue(s); 
 checkSequenceValue(newValue); 
 * After the value for a ref is read from the repo once, it is cached as in 
 * for short-term caching, and do not support invalidation. It is also not 
 OAuthTokenEncrypter enc = encrypter.get(); if (token == null || enc == null) { 
 private final String REFS_HEADS = Constants.R_HEADS + "*"; 
 String inheritedName = pApi.access().inheritsFrom.name; 
<|del|> 
 assertThat(pApi.access().local).isEqualTo(accessInput.additions); 
 exception.expect(AuthException.class); exception.expectMessage("not administrator"); 
<|del|> 
 public Map<String, AccessSectionInfo> deductions; public Map<String, AccessSectionInfo> additions; 
 public Map<String, AccessSectionInfo> deductions; public Map<String, AccessSectionInfo> additions; 
<|del|> 
<|del|> 
 if (a.getPermissions().isEmpty()) { 
<|del|> 
 if (section.getPermissions().isEmpty()) { 
<|del|> 
 final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto); 
 if (user != null && token != null) { tokenCache.put(user, token); } 
 cache.put(checkNotNull(user.getUserName()), encrypt(checkNotNull(accessToken))); 
 if (enc == null) { 
 //TODO: Why doesn't it work when this is removed? IdentifiedUser user = identifiedUserFactory.create( db, self.get().getAccountId()); if (user.getEffectiveGroups().containsAnyOf(groupIds)) { 
 //TODO: Why doesn't it work when this is removed? IdentifiedUser user = identifiedUserFactory.create( db, self.get().getAccountId()); if (user.getEffectiveGroups().containsAnyOf(groupIds)) { 
<|del|> 
 private final Provider<GetSshKeys> getSshKeys; private final ExternalIds externalIds; 
<|del|> 
<|del|> 
 if (p.getRules().isEmpty()) { 
 Change change = unwrap(db).changes().get(changeId); if (change == null || !change.getProject().equals(project)) { 
<|del|> 
 /** * The updater, could be null if it's the server. */ @Nullable AccountInfo getUpdater(); 
 static void execute(Collection<BatchUpdate> updates, Listener listener) throws UpdateException, RestApiException { 
<|del|> 
 gitRefUpdated.fire(project, refUpdate, (AccountInfo) null); 
 public Set<AccountGroup.Id> getOwners() { return owners; 
 public Set<AccountGroup.Id> getOwners() { return owners; 
 * Allows to intercept and act when a Gerrit user logs in or logs out of 
 void onLogin(HttpServletRequest request, HttpServletResponse response); 
 public void createMergeChange() throws Exception { changeInTwoBranches("a.txt", "b.txt"); ChangeInput in = newMergeChangeInput("master", "branchA", ChangeStatus.NEW); assertCreateSucceeds(in); } 
 String.valueOf(-parentNo)); 
 selectedIdx = list.length() + -parentNo; 
 new PatchListKey((AnyObjectId) null, key.getNewId(), key.getWhitespace()); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private final int parentNum; 
 if (parentNum < 0) { 
 PluginLoader pluginLoader, @PluginData Path pluginData, 
 DynamicSet.bind(binder(), WebLoginListener.class) .to(FirstWebLoginListener.class); 
 + "/branches/master/mergeable?source=branchA"); 
<|del|> 
 public boolean mergeable; public List<String> conflicts; 
 return rw.parseCommit(MergeUtil .createMergeCommit(repo, oi, mergeTip, sourceCommit, mergeStrategy, authorIdent, commitMessage)); 
 if (m.merge(false, mergeTip, originalCommit)) { 
 List<String> conflicts = null; if (m instanceof ResolveMerger) { conflicts = ((ResolveMerger) m).getUnmergedPaths(); } throw new MergeConflictException(createConflictMessage(conflicts)); 
 accessInput.add.get(REFS_HEADS) .permissions.remove(Permission.LABEL + LABEL_CODE_REVIEW); 
 public Map<String, AccessSectionInfo> remove; public Map<String, AccessSectionInfo> add; 
 throws RestApiException { 
 private SetAccess(GroupBackend groupBackend, 
 throw new BadRequestException("invalid section name"); 
 throw new BadRequestException("Cannot add non-global capability " + p.getName() + " to global capabilities"); 
 throw new BadRequestException("Cannot add non-global capability " + p.getName() + " to global capabilities"); 
 throws UnprocessableEntityException { 
 permissionEntry.getValue().rules.entrySet()) { 
 GroupReference.forGroup(group)); 
<|del|> 
 r.assertOkStatus(); gApi.projects() .name(project.get()) .branch("otherBranch") .create(new BranchInput()); PushOneCommit.Result r2 = push.to("refs/for/otherBranch"); r2.assertOkStatus(); 
 final RevCommit h = walk.parseCommit(targetRef.getObjectId()); final RevFilter oldRevFilter = walk.getRevFilter(); 
 final RevCommit h = walk.parseCommit(targetRef.getObjectId()); final RevFilter oldRevFilter = walk.getRevFilter(); 
 public void mergeWithMissingChange() throws Exception { // create a draft change 
 // create a new change based on the draft change 
 // delete the draft change 
 } firstFastForward = sorted.remove(0); 
 private boolean canceled; 
 repLog.info("Replication {} was canceled", getURI()); canceledByReplication(); pool.pushWasCanceled(this); 
 repLog.info("Replication {} was canceled", getURI()); canceledByReplication(); pool.pushWasCanceled(this); 
 void canceledByReplication() { canceled = true; 
 boolean wasCanceled() { return canceled; 
 repLog.info("Cannot replicate to " + uri + "." + " It was canceled while running", e); 
<|del|> 
 final ProjectWatchInfo projectWatchInfo = JavaScriptObject .createObject().cast(); 
 AccountApi.getWatchedProjects("self", new AsyncCallback<JsArray<ProjectWatchInfo>>() { 
 return infos; 
 for (int i = 0; i < result.length(); i++) { 
 createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master"); 
 for (SubscribeSection s : projectStateFactory.create(cfg) .getSubscribeSections(branch)) { 
 .message("new change on superproject") .add("foo", "bar") .create(); 
 return (entryName.startsWith("WEB-INF/plugins") && entryName.endsWith(".jar")); 
 "No core plugins available for version {} which is different than " + "the current running Gerrit", gerritVersion); 
<|del|> 
<|del|> 
 private static DiffPreferencesInfo updateDefaults(DiffPreferencesInfo input) { DiffPreferencesInfo result = DiffPreferencesInfo.defaults(); 
 private static DiffPreferencesInfo updateDefaults(DiffPreferencesInfo input) { DiffPreferencesInfo result = DiffPreferencesInfo.defaults(); 
 private static DiffPreferencesInfo updateDefaults(DiffPreferencesInfo input) { DiffPreferencesInfo result = DiffPreferencesInfo.defaults(); 
 log.warn("Cannot get default diff preferences from All-Users", e); return DiffPreferencesInfo.defaults(); 
<|del|> 
 refCreationValidator.validateRefOperation( rsrc.getName(), identifiedUser.get(), u); 
<|del|> 
 refDeletionValidator.validateRefOperation( rsrc.getName(), identifiedUser.get(), u); 
<|del|> 
 u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null); 
 private void integrateIntoHistory(ChangeSet cs) 
 //Legacy numeric identifier. private static final RegExp NUMERIC_ID = RegExp.compile("^[1-9][0-9]*$"); // Commit SHA1 hash private static final RegExp COMMIT_SHA1 = 
 public DiffPreferencesInfo apply(ConfigResource configResource) 
public class GetDiffPreferences implements RestReadView<ConfigResource> { 
 GetDiffPreferences(GitRepositoryManager gitManager, AllUsersName allUsersName) { 
 static DiffPreferencesInfo readFromGit(GitRepositoryManager gitMgr, AllUsersName allUsersName, DiffPreferencesInfo in) 
 throws BadRequestException, Exception { 
 throws BadRequestException, Exception { 
 if (!hasSetFields(in)) { 
 VersionedAccountPreferences prefs = VersionedAccountPreferences.forDefault(); 
import com.google.gerrit.extensions.restapi.BadRequestException; import com.google.gerrit.extensions.restapi.RestModifyView; 
 Provider<MetaDataUpdate.User> metaDataUpdateFactory, AllUsersName allUsersName) { 
 private static final Logger log = LoggerFactory.getLogger(GetDiffPreferences.class); 
 updateDefaults(allUserPrefs), in); 
 private static final RegExp CHANGE_ID_PATTERN = RegExp.compile("^" + ID_PATTERN); private static final RegExp UNIQUE_CHANGE_ID_PATTERN = RegExp.compile("^(.)+~(.)+~" + ID_PATTERN); 
 if (CHANGE_ID_PATTERN.test(query) || UNIQUE_CHANGE_ID_PATTERN.test(query)) { 
 throw new IntegrationException("nothing to merge"); 
 throw new IntegrationException("nothing able to merge"); 
 log.debug("Cannot get a proper name for TrustedListenableFutureTask: {}", 
/** Notified whenever a comment is added to a change. */ 
 final int line; private final CommentManager manager; private final CodeMirror cm; 
 @Test 
 private void assertPrefsEqual(DiffPreferencesInfo actual, DiffPreferencesInfo expected) throws Exception { for (Field field : actual.getClass().getDeclaredFields()) { 
 private void assertPrefsEqual(DiffPreferencesInfo actual, DiffPreferencesInfo expected) throws Exception { for (Field field : actual.getClass().getDeclaredFields()) { 
 private void assertPrefsEqual(DiffPreferencesInfo actual, DiffPreferencesInfo expected) throws Exception { for (Field field : actual.getClass().getDeclaredFields()) { 
 private void assertPrefsEqual(DiffPreferencesInfo actual, DiffPreferencesInfo expected) throws Exception { for (Field field : actual.getClass().getDeclaredFields()) { 
 result = getResult( adminRestSession.get("/config/server/preferences.diff")); assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength); DiffPreferencesInfo expectedDPI = DiffPreferencesInfo.defaults(); expectedDPI.lineLength = newLineLength; compare(result, expectedDPI); 
 private DiffPreferencesInfo put(DiffPreferencesInfo input) throws Exception { 
 /** * Represents the merged Revision when the submit strategy is cherry-pick or * rebase-if-necessary. */ 
 ? user.asIdentifiedUser().getAccount() 
 private static class NoteParser extends AbstractBlockParser { private final BlockNote block; 
 "\\s+([a-z-]+)\\s*=\\s*([^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\")", Pattern.CASE_INSENSITIVE); 
<|del|> 
 throw new IllegalArgumentException("unsupported alignment " + alignment); 
Copyright (C) 2016 The Android Open Source Project 
 + "branch = master\n"); 
 + "branch = master\n"); 
 + "branch = master\n"); 
<|del|> 
 throws ConfigInvalidException, IOException { this.injector = injector; 
 this.canonicalWebUrl = canonicalWebUrl; 
 public SubmoduleSectionParser(Config bbc, String canonicalWebUrl, 
 public static final Pattern CHANGE_ID_PATTERN = Pattern.compile("^[iI][0-9a-f]{4,}.*$"); 
 "error rendering %s/%s %s:%s", 
 // Ignore, the change could have been a draft and got deleted 
 if (isSignedIn()) { user = identified.create(val.getAccountId()); } else { user = anonymousProvider.get(); } 
<|del|> 
<|del|> 
<|del|> 
@CommandMetaData(name = "changes", description = "Index changes") 
 if (parentNum < 0) { 
 if (jars == null || !jars.iterator().hasNext()) { return; 
 if (jars == null || !jars.iterator().hasNext()) { return; 
 // for backwards compatibility, first try to access the old customHeader config var, // then read the new customVariant variable. 
 c4.setTopic(" "); 
 HashMap<AccountProjectWatch.Key, AccountProjectWatch> watchedProjectsMap = new HashMap<>(); 
 return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").parse(str); 
 ReadmeHelper(ObjectReader reader, GitilesView view, Config cfg, RevTree rootTree) { 
 ReadmeHelper(ObjectReader reader, GitilesView view, Config cfg, RevTree rootTree) { 
 * reference. May be null. 
 return trimLeadingSlash(target); 
 side = in.parent == null ? 0 : (short) -in.parent.shortValue(); 
 side = in.parent == null ? 0 : (short) -in.parent.shortValue(); 
 e.setSide(c.side == Side.PARENT ? (short) -c.parent.shortValue() : 1); 
<|del|> 
<|del|> 
 NB.encodeInt32(time, 0, (int) MILLISECONDS.toSeconds(createdMillis)); 
 private static final String CMD_RAW = "+raw"; private static final String CMD_REFS = "+refs"; 
 public static void validateRegExp(String refPattern) throws InvalidNameException { 
 Set<ProjectWatchInfo> watchedProjectInfos, 
 Set<ProjectWatchInfo> watchedProjectInfos, 
 new GerritCallback<JsArray<ProjectWatchInfo>>() { 
 new GerritCallback<JsArray<ProjectWatchInfo>>() { 
 AccountApi.updateWatchedProject("self", info, new GerritCallback<JsArray<ProjectWatchInfo>>() { 
<|del|> 
 for (ProjectWatchInfo info : Natives.asList(result)) { 
<|del|> 
<|del|>
 while ((iP = url.indexOf(":")) >= 0) { if (url.startsWith("file:")) { 
 while ((iP = url.indexOf(":")) >= 0) { if (url.startsWith("file:")) { 
 if (iA < 0) { iA = url.length(); } if (++iP > url.length()) { break; } 
 .byAccount(who, StarredChangesUtil.DEFAULT_LABEL)); 
 md.getCommitBuilder().setCommitter(serverUser); md.setMessage(COMMIT_MSG); 
<|del|> 
import com.google.common.collect.Lists; import com.google.common.collect.Multimap; 
 private static final String CLICK_FAILURE_OTHER_TOOLTIP = "Clicking the button would fail for other changes"; 
 && RefNames.isRefsEditOf( ref.getLeaf().getName(), currAccountId)) 
 && (RefNames.isRefsEditOf(ref.getLeaf().getName(), currAccountId) 
 } // The line might be within a DiffChunk 
 List<PatchSetApproval> cells = new ArrayList<>(approvals.size()); Date ts = update.getWhen(); 
<|del|> 
 static final Schema<ChangeData> V28 = schema(V27, ChangeField.STARREDBY); 
 this.canonicalWebUrl = canonicalWebUrl; 
 /** * {@code source} can be any Git object reference expression. * * @see <a href="https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html">gitrevisions(7)</a> */ 
 rw.parseCommit(repo.resolve(merge.source)); if (!projectControl.canReadCommit(db.get(), repo, sourceCommit)) { throw new BadRequestException( "do not have read permission for: " + merge.source); } 
<|del|> 
 mergeCommit.setAuthor(committerIndent); 
 List<String> conflicts = ImmutableList.of(); 
 for (String c : conflicts) { sb.append('\n' + c); 
 for (String c : conflicts) { sb.append('\n' + c); 
 Ref destRef = git.getRefDatabase().exactRef(resource.getRef()); if (destRef == null) { throw new ResourceNotFoundException( "can not find reference " + resource.getRef()); } 
<|del|> 
<|del|> 
<|del|> 
 static final Schema<ChangeData> V29 = schema(V28, ChangeField.HASHTAG_CASE_AWARE); 
 log.error("Error rechecking if change " + getChangeId() 
 ObjectId revid = repo.resolve(baseRevision); 
 public static String getRefPrefix(String refName) { int i = refName.lastIndexOf('/'); 
<|del|> 
 text.setTargetHistoryToken(PageLinks.topicQuery(info.topic())); 
 return notes.revisionNoteMap; 
 "cannot combine base, parent, reviewed, query"); 
 boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n"); 
 assertThat(md.href("git://")).isEqualTo("#zSoyz"); assertThat(md.href("git://example.com/../root")).isEqualTo("#zSoyz"); assertThat(md.href("git://example.com/root/..")).isEqualTo("#zSoyz"); 
 return ComparisonChain.start() .compare(other.size, size) .compare(other.name.get(), name.get()) .result(); 
 RevCommit c1 = repo1.branch("HEAD").commit().insertChangeId() .add("a.txt", "1") .message("subject: 1") .create(); 
 i.subject = "Some changes are not visible"; 
 i.subject = "Some changes are not visible"; 
import java.io.IOException; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import java.util.Set; 
 String invisibleId = "Some changes are not visible"; 
 fail("Expected ResourceNotFoundException"); } catch (ResourceNotFoundException e) { 
 fail("Expected ResourceNotFoundException"); } catch (ResourceNotFoundException e) { 
 public ImmutableMap<Change.Id, ChangeData> changesById() { return changeData; } 
 ChangeField.PATCH_SET.getName(), ChangeField.REVIEWER.getName()); 
 if (!str.isOk()) { 
<|del|> 
 public ChangeSet(ChangeData change) { this(ImmutableList.of(change)); 
<|del|> 
 } refUpdatedImpl(ctx); } protected void refUpdatedImpl(Context ctx) throws Exception { Account account = args.accountCache.get(submitter.getAccountId()).getAccount(); 
<|del|> 
<|del|> 
 factory.setPassword(amqp.password); 
 public static RevisionInfo forParent(int number, CommitInfo commit) { 
 private native void takeFromParent(int number, CommitInfo commit) /*-{ this._number = number; 
<|del|> 
 e.setSide(side(c)); 
 private final int parentNum; 
 psUtil.setGroups(ctx.getDb(), ctx.getUpdate(psId), ps, groups); return true; } }); bu.execute(); 
<|del|> 
 PutAgreement putAgreement, 
 ObjectId newTreeId) throws Exception { 
<|del|> 
 private final RegistrationHandle eventListenerRegistration; private final Multimap<String, RefEvent> recordedEvents; 
 // Admin user trying to move from ready to WIP should succeed. 
<|del|> 
<|del|> 
 assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name()); 
 assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name()); 
 return (ChangeMergedEvent) events.get(0); 
<|del|> 
 /** Dummy for changes not visible. */ 
<|del|> 
 @Option(name = "-o", usage = "Output options") 
 TestRepository<InMemoryRepository> adminTestRepo = cloneProject(project, admin); TestRepository<InMemoryRepository> userTestRepo = cloneProject(project, user); 
 PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo); 
<|del|> 
<|del|> 
<|del|> 
 grant(config, refsFor, Permission.PUSH_PATCH_SET, registered); 
 "Add Push Patch Set permission to all projects"; 
 AccessSection drafts = config.getAccessSection("refs/for/*", true); grant(config, drafts, Permission.PUSH_PATCH_SET, false, false, registered); 
<|del|> 
 res.setStatus(SC_NOT_FOUND); } else { renderJson( req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class); 
 try { changeNotes.add(create(db, project, id)); } catch (NullPointerException | IllegalArgumentException e){ log.error(e.getMessage()); } 
 try { changeNotes.add(create(db, project, id)); } catch (NullPointerException | IllegalArgumentException e){ log.error(e.getMessage()); } 
 Project.NameKey p = createProject("addPatchSet1"); 
 Project.NameKey p = createProject("addPatchSet2"); 
 Project.NameKey p = createProject("addPatchSet3"); 
 Project.NameKey p = createProject("addPatchSet4"); 
 ChangeInfo c = gApi.changes() .id(r1.getChangeId()).get(); r2.assertErrorStatus("cannot place onto patch set 1."); 
 Project.NameKey p = createProject("pushPatchSetEdit"); 
 public void createNewPatchSetAsReviewerOnDraftChange() throws Exception { 
<|del|> 
 if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) { 
 Optional<ObjectId> start = getStart(view.getParameters(), walk.getObjectReader()); 
 log.warn("ChangeHook.doCommentAddedHook invocation failed", e); 
 ? ObjectId.zeroId().name() 
 testRepo.reset(initial); 
 ).containsExactly(Patch.COMMIT_MSG, "foo", "bar"); 
 assertThat(Side.REVISION).isEqualTo(expected.side); assertThat(actual.parent).isNull(); 
 return REVISION; 
 try { 
 this.parentNo = parentNo; 
 this.parentNo = parentNo; 
<|del|>
 replaceByChange.get(notes.getChangeId()).notes = notes; 
 for (int c = 1; c < 3; c++) { 
 private static void writeResult( 
<|del|> 
<|del|> 
<|del|> 
 for (ChangeOp op : e.getValue()) { op.call(db, update); 
 @Inject private IdentifiedUser.GenericFactory userFactory; @Inject private InMemoryDatabase schemaFactory; @Inject private InMemoryRepositoryManager repoManager; @Inject private SchemaCreator schemaCreator; @Inject private ThreadLocalRequestContext requestContext; @Inject private BatchUpdate.Factory batchUpdateFactory; 
 /* The agreement name. */ 
 throw new UnprocessableEntityException("contributor agreement not found"); 
 throw new ResourceConflictException("autoverify group uuid not found"); 
 throw new ResourceConflictException("autoverify group not found"); 
 public static String appendUrlOptions(Config cfg, String url) { long h2CacheSize = cfg.getLong("database", "h2", "cacheSize", -1); boolean h2AutoServer = cfg.getBoolean("database", "h2", "autoServer", false); 
 public static String appendUrlOptions(Config cfg, String url) { long h2CacheSize = cfg.getLong("database", "h2", "cacheSize", -1); boolean h2AutoServer = cfg.getBoolean("database", "h2", "autoServer", false); 
 } catch (SubmoduleException | OrmException | IOException e) { 
<|del|> 
 return !Strings.isNullOrEmpty(v) && v.equalsIgnoreCase("Y"); 
 private AccountManager accountManager; 
 ChangeNotes notes = getNotes(ev.getChange()); hooks.doReviewerAddedHook(notes.getChange(), getAccount(ev.getReviewer()), psUtil.current(db.get(), notes), 
 ChangeNotes notes = getNotes(ev.getChange()); hooks.doReviewerAddedHook(notes.getChange(), getAccount(ev.getReviewer()), psUtil.current(db.get(), notes), 
 ChangeNotes notes = getNotes(ev.getChange()); hooks.doReviewerDeletedHook(notes.getChange(), getAccount(ev.getReviewer()), psUtil.current(db.get(), notes), 
 Map<String, ApprovalInfo> oldApprovals) { if (!listeners.iterator().hasNext()) { return; } 
 return getNotes(info).getChange(); 
 AccountIndex index = indexes.getSearchIndex(); checkNotNull(index, "no active search index configured for accounts"); 
 return new GsonBuilder().registerTypeAdapter(Supplier.class, new SupplierSerializer()).create(); 
 Integer limitFromPredicate = LimitPredicate.getLimit(FIELD_LIMIT, p); 
 this(displayName, defaultValue, ProjectConfigEntryType.STRING, null, inheritable, description); 
 throw new AuthException("cannot add patch set"); 
 reject(inputCommand, "cannot add patch set to " 
 /** @return true if this user can add a new patch set to this ref */ public boolean canAddPatchSet() { 
 changeCtl = projectControl.controlFor(notes); 
 ChangeNotes notes = getNotes(ev.getChange()); hooks.doReviewerAddedHook(notes.getChange(), getAccount(ev.getReviewer()), psUtil.current(db.get(), notes), 
 private ChangeNotes getNotes(ChangeInfo info) throws OrmException { try { return changeNotesFactory.createChecked(new Change.Id(info._number)); } catch (NoSuchChangeException e) { throw new OrmException(e); } 
 private PatchSet getPatchSet(ChangeNotes notes, RevisionInfo info) throws OrmException { return psUtil.get(db.get(), notes, PatchSet.Id.fromRef(info.ref)); 
<|del|>
 } return 1; 
 ObjectId getOldId(Change change, PatchSet patchSet, Integer parentNo) 
<|del|> 
 String changeId, String ref, TestAccount testAccount, TestRepository<?> repo) throws Exception { 
 // Amend change as admin 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public void updateRepo(RepoContext ctx) throws IOException { 
 changeControlFactory.controlFor(reviewDb.get(), change, me); 
<|del|> 
 "Add addPatchSet permission to all projects"; 
 AccessSection refsFor = config.getAccessSection("refs/for/*", true); grant(config, refsFor, Permission.ADD_PATCH_SET, false, false, registered); 
<|del|> 
<|del|> 
 Timer1.Context context = metrics.executionTime.start(indexName); 
 try (ReviewDb db = unwrapDb(schemaFactory.open())) { 
<|del|> 
 ReviewDb db = dbProvider.get(); return ReviewDbUtil.unwrapDb(db); 
import static com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb; 
 return ReviewDbUtil.unwrapDb(dbProvider.get()); 
 protected PushOneCommit.Result amendChange(String changeId, String ref, TestAccount testAccount, TestRepository<?> repo) throws Exception { 
 Project.NameKey p = createProject("pushPathSet1"); 
 Project.NameKey p = createProject("pushPathSet1"); 
 Project.NameKey p = createProject("pushPathSet4"); 
 Project.NameKey p = createProject("pushPathSet4"); 
 // Add user as reviewer AddReviewerInput in = new AddReviewerInput(); in.reviewer = user.email; gApi.changes() .id(r1.getChangeId()) .addReviewer(in); 
 SchemaDefinitions<T> schemaDef, 
 Timer1.Context context = metrics.executionTime.start(schemaDef.getName()); 
 public Predicate<AccountState> limit(String query) throws QueryParseException { Integer limit = Ints.tryParse(query); if (limit == null) { throw error("Invalid limit: " + query); } return new LimitPredicate<>(FIELD_LIMIT, limit); 
 // only measure successful queries 
 @Singleton GroupIndexer getGroupIndexer(GroupIndexerImpl.Factory factory, GroupIndexCollection indexes) { return factory.create(indexes); } @Provides @Singleton 
 String responseJson = new String(charArray); 
 updatedSubscribers = new HashSet<>(); 
 * Amend the commit with gitlink update * @param commit 
 * NoteDb, but any attempts to write will generate an error. 
 qp = queryProcessor.enforceVisibility(false); 
 public QueryOptions convertForBackend() { 
 private static int toParentNum(String parentToken) { 
 int parentNum; 
 ObjectId commitId, int parentNum) throws IOException { 
 private static final int MAX_BATCH_SIZE = 1000; 
<|del|> 
 return AccountInfoComparator.ORDER_NULLS_LAST.sortedCopy(matches); 
 ApprovalInfo ai = approvalInfo(accountId, 0, null, null); 
 !IsVisibleToPredicate.class.isAssignableFrom(IndexPredicate.class), 
 implements Matchable<ChangeData> { protected ChangeIndexPredicate(FieldDef<ChangeData, ?> def, String value) { 
public class DeletedPredicate extends IntegerRangeChangePredicate { 
class RegexRefPredicate extends ChangeRegexPredicate { 
 in.newBranch = true; 
 in.newBranch = true; 
 if (c instanceof ClassNotFoundException 
 if (query.matches("^[1-9][0-9]*$")) { return new AccountIdPredicate(Account.Id.parse(query)); } throw error("User " + query + " not found"); 
 // Need to create at least one user to be admin before creating a "normal" // registered user. // See AccountManager#create(). 
 // Need to create at least one user to be admin before creating a "normal" // registered user. // See AccountManager#create(). 
 // Need to create at least one user to be admin before creating a "normal" // registered user. // See AccountManager#create(). 
 protected void saveProjectConfig(ProjectConfig cfg) throws Exception { 
 // Anonymous user group has ALLOW READ permission in refs/*. 
 args.add(Strings.nullToEmpty(value)); 
 args.add(firstNonNull(value, false).toString()); 
 String url = urlProvider.get(); if (change != null && url != null) { args.add(url + change.changeId); } else { args.add(""); 
<|del|> 
 StringBuilder who = new StringBuilder( firstNonNull(account.name, anonymousCowardName)); 
 .setNameFormat("SyncHook-%d") .setUncaughtExceptionHandler(LOG_UNCAUGHT_EXCEPTION) 
 if (!Files.exists(hook)) { 
 return new SynchronousHook( syncHookExecutor, getHookPath(configName, defaultName)); 
 if (Files.exists(hook)) { 
 if (!Strings.isNullOrEmpty(output)) { 
 if (!s.toLowerCase().contains(query.toLowerCase()) && info.secondaryEmails() != null) { 
 public static Set<String> getEmails(Collection<AccountExternalId> ids) { Set<String> emails = new HashSet<>(); 
<|del|> 
 .create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1") 
 "DONT_TRIGGER", "a", "a1").to("refs/for/master"); 
 assertThat(m.body()).contains("Change subject: TRIGGER\n"); 
 .create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1") 
 "DONT_TRIGGER", "b.txt", "b1").to("refs/for/master"); 
 assertThat(m.body()).contains("Change subject: TRIGGER\n"); 
<|del|> 
<|del|> 
 private Set<URIish> getURIs( @Nullable String remoteName, Project.NameKey projectName, FilterType filterType) { if (config.getDestinations(filterType).isEmpty()) { return Collections.emptySet(); } 
 private boolean createProject( String remoteName, URIish replicateURI, String projectName, String head) { 
 private static final int SSH_REMOTE_TIMEOUT = 120 * 1000; // 2 minutes = 120 * 1000ms 
 getParentNumFromDisplaySide(cm.side()), 
<|del|> 
 private void initKeyExchanges(Config cfg) { List<NamedFactory<KeyExchange>> a = ServerBuilder.setUpDefaultKeyExchanges(true); 
 private void initKeyExchanges(Config cfg) { List<NamedFactory<KeyExchange>> a = ServerBuilder.setUpDefaultKeyExchanges(true); 
 private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception { 
 r2.assertOkStatus(); assertTwoChangesWithSameRevision(r); 
 public void createGroupAlreadyExists() throws Exception { 
 } else if (notes.getChange().getStatus().isClosed()) { 
 // Push draft patch set 
 // Remove draft patch set 
 // Push new draft patch set 
<|del|> 
 assertThat( gApi.changes() .id(r1.getChange().getId().get()).get() .currentRevision) 
<|del|> 
 Optional<Account.Id>> byUsername, 
 for (AccountProjectWatch apw : db.accountProjectWatches().byAccount(who)) { 
 Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class); 
 "duplicate entry for project " + format(info.project, info.filter)); 
 Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class); 
 public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches( 
<|del|> 
<|del|> 
 if (Strings.isNullOrEmpty(commit.getMessage())) { 
 for (String projectName : cfg.getSubsections(PROJECT)) { cfg.unset(PROJECT, projectName, KEY_NOTIFY); } Multimap<String, String> notifyValuesByProject = ArrayListMultimap.create(); for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches 
 checkState(projectWatches != null, "project watches not loaded yet"); 
 public static Map<ProjectWatchKey, Set<NotifyType>> readProjectWatchesFromDb( 
 if (filter() != null) { 
 BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate(); bru.setRefLogIdent(serverUser); bru.setRefLogMessage(MSG, false); 
 for (String queryTerm : result) { if (queryTerm.toLowerCase().contains(s.toLowerCase())) { 
 ChangeAbandonedListener, ChangeRestoredListener { 
<|del|> 
 LOG.warn("Ensuring data directory '{}' for plugin '{}' failed." 
 LOG.warn("Ensuring data directory '{}' for plugin '{}' failed." 
 LOG.error("Ensuring data directory '{}' for plugin '{}' failed.", dataDir, pluginName, e); throw new RuntimeException(e); 
 for (SubscribeSection s : projectStateFactory.create(cfg) .getSubscribeSections(branch)) { 
 createSubmoduleSubscription(topRepo, "master", "mid-project", "master"); createSubmoduleSubscription(midRepo, "master", "bottom-project", "master"); 
 } return newCommit; 
 } return ensured; 
 private static final Logger LOG = LoggerFactory.getLogger(LocalLargeFileRepository.class); 
 LOG.error("Ensuring data directory '{}' for plugin '{}' failed.", dataDir, pluginName, e); throw new RuntimeException(e); 
 gApi.groups().id(largeGroup).addMembers( largeGroupUsernames.toArray(new String[largeGroupSize])); gApi.groups().id(mediumGroup).addMembers( mediumGroupUsernames.toArray(new String[mediumGroupSize])); 
import com.google.gerrit.testutil.ConfigSuite; 
 assertThat(result.error).contains("has too many members to add them all as reviewers"); 
 assertThat(result.reviewer).isEqualTo(mediumGroup); 
 public String input; 
 public Boolean confirm; 
 public RevisionApi revision(String id) { 
<|del|> 
<|del|> 
 assertThat(result.reviewer).isEqualTo(mediumGroup); 
 assertThat(result.reviewer).isEqualTo(mediumGroup); 
 assertThat(result.reviewer).isEqualTo(user.email); 
 List<TestAccount> users = createAccounts(6, "addCcGroup"); new ArrayList<>(6); 
 List<TestAccount> users = createAccounts(6, "addCcGroup"); new ArrayList<>(6); 
 List<TestAccount> users = createAccounts(6, "addCcGroup"); new ArrayList<>(6); 
 public String strategy; 
 ins.setDraft(input.status == ChangeStatus.DRAFT); 
 RevWalk rw, ProjectControl projectControl, RevCommit mergeTip, MergeInput merge, PersonIdent authorIdent, String commitMessage) 
 * Map of labels to values after the review was posted. Null if any 
 ReviewerResource.Factory reviewerFactory, ApprovalsUtil approvalsUtil, 
<|del|>
 class Addition { final AddReviewerResult result; final Op op; 
 throw new ResourceNotFoundException(resource.getRef()); 
<|del|> 
 RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, source); 
<|del|> 
 if (filter.get() == null) { 
 private final boolean h2AutoServer; 
<|del|> 
 private AddReviewerResult addReviewer(String changeId, String reviewer) throws Exception { 
 private AddReviewerResult addReviewer(String changeId, String reviewer) throws Exception { 
 } /** Create an annotation to export based on a cannonical class name. */ 
<|del|> 
 AccountGroup.UUID registeredUsers = 
 commitBuilder.message("New subject " + System.nanoTime()) .author(admin.getIdent()) 
 "new content " + System.nanoTime(), changeId); 
 PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "Other Change", "a" + System.nanoTime() + ".txt", PushOneCommit.FILE_CONTENT); 
<|del|> 
 List<Account.Id> reviewers = Lists.transform(added, 
 List<AccountInfo> transformed = Lists.transform(reviewers, 
 private PatchListKey(int parentNum, AnyObjectId b, Whitespace ws) { this.parentNum = Integer.valueOf(parentNum); 
 PatchListKey newKey = PatchListKey.againstDefaultBase( key.getNewId(), key.getWhitespace()); PatchListKey oldKey = PatchListKey.againstDefaultBase( key.getOldId(), key.getWhitespace()); 
<|del|> 
 * List of accounts CCed on the change. The size of this list may be 
<|del|> 
 @Option(name = "--by-queue", aliases = {"-q"}, usage = "group tasks by queue and print queue info") 
 throw new IllegalStateException("unexpected change kind: " + kind); 
 fail("unexpected change kind: " + changeKind); 
 fail("unexpected change kind: " + changeKind); 
 "do not call rollback; BatchUpdate always manages transactions"); 
import com.google.gerrit.extensions.api.changes.NotifyHandling; 
<|del|> 
 * {@link List} of individual reviewers added to the change. The size of this * list may be greater than one (e.g. when a group is added). Null if no * reviewers were added. 
 public void rejectDoubleInheritance() throws Exception { setApiUser(admin); 
 GitUtil.fetch(childRepo, RefNames.REFS_CONFIG + ":cfg"); 
 PushOneCommit.Result a = push.to(RefNames.REFS_CONFIG) ; a.assertErrorStatus(); a.assertMessage("error: cannot inherit from multiple projects"); // Reset permission to the default for this class setApiUser(user); 
<|del|> 
 // Fetch meta ref 
 PushOneCommit.Result res = push.to(RefNames.REFS_CONFIG); res.assertErrorStatus(); res.assertMessage("error: cannot inherit from multiple projects"); 
 String errorMessage = "someError"; expect(request.getReader()).andThrow(new IOException(errorMessage)); response.sendError(SC_BAD_REQUEST, errorMessage); 
 String errorMessage = "someError"; expect(request.getReader()).andThrow(new IOException(errorMessage)); response.sendError(SC_BAD_REQUEST, errorMessage); 
<|del|> 
<|del|> 
 if (this == o) { return true; } if (o != null && getClass() == o.getClass()) { 
<|del|> 
 if (!votesRemoved) { msg.append(" with the following votes:\n\n"); 
 addMembers.addMembers(group.getId(), ImmutableList.of(account.getId())); 
 log.warn("shutting down " + name + " index with pending Lucene writes"); 
 log.warn("interrupted waiting for pending Lucene writes of " + name + " index", e); 
 public enum NotifyType { // sort by name, except 'ALL' which should stay last 
 * "ID <EMAIL> : PASSWORD", where 'EMAIL' and 'PASSWORD' are optional. E.g.: 
 commit.setMessage("Deleted external IDs configuration\n"); 
Copyright (C) 2016 The Android Open Source Project 
 String uriStr = uri.toString(); if (uri.getHost() != null && uriStr.startsWith(GERRIT_ADMIN_PROTOCOL_PREFIX)) { return new URIish(uriStr.substring(0, GERRIT_ADMIN_PROTOCOL_PREFIX.length())); 
 String uriStr = uri.toString(); if (uri.getHost() != null && uriStr.startsWith(GERRIT_ADMIN_PROTOCOL_PREFIX)) { return new URIish(uriStr.substring(0, GERRIT_ADMIN_PROTOCOL_PREFIX.length())); 
 public static final String CONTENT_PATH = "content/"; 
 super(getContentPath(url), 
 serve("/" + CONTENT_PATH + "/*").with(LfsFsContentServlet.class); 
 public static final String CONTENT_PATH = "content"; 
 super(url + (url.endsWith("/") ? CONTENT_PATH : "/" + CONTENT_PATH) + "/", getOrCreateDataDir(cfg, pluginName, defaultDataDir)); 
 String section = LfsBackend.S3.name(); 
 Config config = configFactory.getGlobalPluginConfig(pluginName); 
 String region = config.getString(section, null, "region"); String bucket = config.getString(section, null, "bucket"); 
 public void pushForMaster() throws Exception { 
 OldReceiveCommitsImpl.Factory oldFactory, 
 OldReceiveCommitsImpl create(ProjectControl projectControl, Repository repository); 
 } return cfg != null ? cfg.getStringList(section, subsection, name) : null; 
<|del|> 
 assertThat(c.reviewerUpdates).isNotNull(); assertThat(c.reviewerUpdates).hasSize(2); Iterator<ReviewerUpdateInfo> it = c.reviewerUpdates.iterator(); ReviewerUpdateInfo reviewerChange = it.next(); 
import com.google.common.collect.ImmutableTable; import com.google.gerrit.server.ReviewerStatusUpdate; 
 abstract ImmutableList<ReviewerStatusUpdate> reviewerChanges(); 
<|del|> 
 public void setReviewerChanges(List<ReviewerStatusUpdate> reviewerChanges) { 
 accountCache.evictAll(); 
 accountCache.evictAll(); 
 /** * Plugin configuration in etc/$PLUGIN.config and etc/$PLUGIN.secure.config. */ 
 } return cfg != null ? cfg.getStringList(section, subsection, name) : null; 
 } return cfg != null ? cfg.getStringList(section, subsection, name) : null; 
 } return cfg != null ? cfg.getStringList(section, subsection, name) : null; 
 public Collection<ReviewerUpdateInfo> reviewerUpdates; 
 private final List<Account.Id> allPastReviewers; private final List<ReviewerStatusUpdate> reviewerChanges; 
 private final Map<String, Config> pluginConfigs; 
/** Change to a reviewer's status. */ @AutoValue public abstract class ReviewerStatusUpdate { public static ReviewerStatusUpdate create( 
 private Collection<ReviewerUpdateInfo> reviewerUpdates(ChangeData cd) throws OrmException { List<ReviewerStatusUpdate> reviewerUpdates = cd.reviewerUpdates(); List<ReviewerUpdateInfo> result = new ArrayList<>(reviewerUpdates.size()); for (ReviewerStatusUpdate c : reviewerUpdates) { 
 public ImmutableList<ReviewerStatusUpdate> getReviewerUpdates() { return state.reviewerUpdates(); 
 private final List<ReviewerStatusUpdate> reviewerUpdates; 
 abstract ImmutableList<ReviewerStatusUpdate> reviewerUpdates(); 
 private List<ReviewerStatusUpdate> reviewerUpdates; 
 public void setReviewerUpdates(List<ReviewerStatusUpdate> reviewerUpdates) { this.reviewerUpdates = reviewerUpdates; 
 public synchronized Config getGlobalPluginConfig(String pluginName) { 
 "Cannot resolve 'fdsafsdf' to a commit"); 
 "do not have read permission for: " + source); 
 "'" + source + "' has already been merged"); 
 * Verbosity level of the commit message for submodule subscriptions. 
 * Verbosity level of the commit message for submodule subscriptions. 
 @Nullable Account account, ChangeHooks changeHooks) { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 /** Only include the commit subjects for the commit history. */ 
 // create two new branches 
 cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege."); 
<|del|> 
<|del|> 
 } Change change = abandon(control, input.message, input.notify); return json.create(ChangeJson.NO_OPTIONS).format(change); } 
 Event event = new Event(change, revision, abandoner, reason, when, notifyHandling); 
 log.debug( String.format("Plugin %s did not define its top-level command", plugin.getName()), err); 
 inserter.setUploader(edit.getUser().getAccountId()); 
 if (git.exactRef(RefNames.REFS_USERS_DEFAULT) != null) { RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT); u.setForceUpdate(true); assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED); } 
 if (git.exactRef(RefNames.REFS_USERS_DEFAULT) != null) { RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT); u.setForceUpdate(true); assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED); } 
 logDebug("Calculated superprojects for " + branch + " are " + ret); 
 //TODO: Should this be done more lazily? //TODO: difficult to do when reader is not available outside of onLoad? try (ByteArrayInputStream input = new ByteArrayInputStream(readFile(path));) { 
 external.putAll(e.getKey(), e.getValue()); 
 String domainGlob = ("\\Q" + domain + "\\E").replace("*", "\\E.*\\Q"); if (userDomain.matches(domainGlob)) { 
 if (event.command.getRefName() .startsWith(RefNames.REFS_HEADS + "protected-") 
<|del|> 
 private void setDomains(List<String> domains) { 
 Splitter.on(',').trimResults().split(values)); 
 return new SingleFileServlet(cache, polyGerritBasePath().resolve("index.html"), getPaths().isDev(), false); 
<|del|> 
<|del|> 
<|del|> 
 if (!canLoadInIFrame()) { 
<|del|> 
 (type.isCopyMinScore() && type.isMaxNegative(psa)) || (type.isCopyMaxScore() && type.isMaxPositive(psa))) { 
 return new RequestId(c.getId().toString()); 
 for (ProblemInfo pi : ImmutableList.of(p, psp)) { 
 public final boolean isHttpPasswordSettingsEnabled() { return isAllowHttpPasswordOverLdapUsingBasic(); } 
 if (Gerrit.info().auth().isHttpPasswordSettingsEnabled()) { linkByGerrit(Util.C.tabHttpAccess(), PageLinks.SETTINGS_HTTP_PASSWORD); } 
 if (passwordMatchesTheUserGeneratedOne(who, username, password) & authConfig.isAllowHttpPasswordOverLdapUsingBasic()) { 
 static class Input { String branchMap; } 
 dsCreator.createMergesAndHandleConflicts(branchMap, change.getKey().get(), change.getProject().get(), change.getTopic(), change.getSubject(), revision, revision); return Response.none(); } 
 private static final Logger log = LoggerFactory.getLogger( ConfigDownstreamAction.class); 
 static class Input { @DefaultInput String subject; } 
 @Override public String apply(RevisionResource rev, Input input) throws RestApiException, IOException { 
 } return new Gson().toJson(downstreamMap); } 
 public void loadConfig() throws IOException, RestApiException { config = new LoadedConfig(gApi, configProject, configProjectBranch, configFilename, configOptionKeys); } 
 String commitMessage) { return config.isSkipMerge(fromBranch, toBranch, commitMessage); } 
 public Set<String> getProjectsInScope(String fromBranch, String toBranch) throws RestApiException, IOException { try { Set<String> projectSet = new HashSet<String>(); 
 private final String manifestString; private final String branch; 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 configLoader.getDownstreamBranches("master", "platform/some/project"); 
import static com.google.common.truth.Truth.assertThat; 
import java.net.URL; import java.util.HashSet; import java.util.Set; import java.io.InputStream; import java.io.InputStreamReader; 
public class ManifestReaderIT { private ManifestReader manifestReader; private String manifestString; 
 public List<String> members; 
Copyright (C) 2016 The Android Open Source Project 
 final Repository repo; 
 delete(VOTE_KIND).to(DeleteVote.class); post(VOTE_KIND, "delete").to(DeleteVote.class); 
public class SubmitPreview implements RestReadView<RevisionResource> { 
 .setAttachmentName("submit-preview-" + change.getChangeId() + ".zip"); 
 String fname = p.get() + ".git"; 
 sb.append(e.getMessage()); 
 public static final long serialVersionUID = 5L; 
 private final TimeZone tz; 
 for (String email : currentIdentifiedUser.getEmailAddresses()) { 
 for (String email : currentIdentifiedUser.getEmailAddresses()) { 
 public PersonIdent newCommitterIdent(Date when, TimeZone tz) { return newCommitterIdent(when, tz, getAccount().getPreferredEmail()); 
 public PersonIdent newCommitterIdent(Date when, TimeZone tz) { return newCommitterIdent(when, tz, getAccount().getPreferredEmail()); 
 boolean cacheOnClient) { this(cache, refresh, cacheOnClient, CACHE_FILE_SIZE_LIMIT_BYTES); 
<|del|> 
 } else if (cacheOnClient && r.etag.equals(req.getHeader(IF_NONE_MATCH))) { 
<|del|> 
 cache, polyGerritBasePath().resolve("index.html"), getPaths().isDev()); 
<|del|> 
 return null; 
 logError("Invalid pack upload; one or more objects weren't sent", ex); 
 logError("Invalid pack upload; one or more objects weren't sent", ex); 
 return domainPattern.matcher(userDomain).matches(); 
<|del|> 
 try (ReviewDb db = schema.open()) { 
 try (ReviewDb db = schema.open()) { 
 copy(db, ctl, ps, Collections.<PatchSetApproval>emptyList()); 
 public Iterable<PatchSetApproval> buildApprovals(ChangeUpdate update, 
 private void setUserIdentified(Account.Id id) { 
<|del|> 
<|del|> 
 // Otherwise load the template as a resource. 
Copyright (C) 2015 The Android Open Source Project 
 "Operation %s on %s branch in project %s is not valid!", 
 reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES); newChanges = Collections.emptyList(); return; 
 final List<ChangeData> destChanges; 
 if (index > 0 && index < userEmail.length() - 1) { 
 /** check if Gerrit is allowed to send from {@code userEmail}. */ 
 return false; 
 return false; 
<|del|> 
<|del|> 
<|del|> 
 if (repo == null) { 
 removedVotesMsg.append("* ").append(a.getLabel()) 
<|del|> 
import java.util.EnumSet; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.List; import java.util.ArrayList; import java.util.UUID; 
import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; 
<|del|> 
 } catch (IOException err) { throw new ProvisionException("Failed to read template file " + tmpl.toAbsolutePath().toString(), err); 
 } catch (IOException err) { throw new ProvisionException("Failed to read template file " + tmpl.toAbsolutePath().toString(), err); 
 } catch (IOException err) { throw new ProvisionException("Failed to read template file " + tmpl.toAbsolutePath().toString(), err); 
 builder.add(Resources.getResource(resourcePath)); 
 yesIAgreeBox.setText(""); super.onFailure(caught); 
 new GerritCallback<NativeString>() { 
 try (Repository repo = 
 "self", new ScreenLoadCallback<JsArray<AgreementInfo>>(this) { 
 available = Gerrit.info().auth().contributorAgreements(); postRPC(); 
Copyright (C) 2013 The Android Open Source Project 
 Pattern allowOriginPattern = Pattern.compile(Joiner.on("|").join(allowOrigin)); 
 } else { 
 allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER)); 
import com.google.gerrit.server.git.MergeUtil; import com.google.gerrit.server.index.change.ChangeField; import com.google.gerrit.server.index.change.ChangeIndexCollection; 
 ChangeKindCache changeKindCache, ChangeIndexCollection indexes, 
 this.changeKindCache = changeKindCache; this.indexes = indexes; 
 assertThat(r.getHeader(ACCESS_CONTROL_ALLOW_ORIGIN)).isNull(); assertThat(r.getHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS)).isNull(); 
 @NoHttpd 
 public Boolean isEnabled() { 
 public Boolean isEnabled() { 
 public boolean isEnabled() { 
 private Multimap<PatchSet.Id, PatchLineComment> buildCommentMap() { 
 private void buildNoteJson(ChangeNoteUtil noteUtil, OutputStream out) throws IOException { 
 private void buildNoteJson(ChangeNoteUtil noteUtil, OutputStream out) throws IOException { 
 private void buildNoteHomebrew(ChangeNoteUtil noteUtil, OutputStream out) throws IOException { 
 private void buildNoteHomebrew(ChangeNoteUtil noteUtil, OutputStream out) throws IOException { 
 * <p>It is intended for (de)serialization to JSON only. 
<|del|> 
 filename = k.getParentKey().getFileName(); patchSetId = k.getParentKey().getParentKey().get(); changeId = k.getParentKey().getParentKey().getParentKey().get(); 
 int startChar; 
<|del|> 
 key.export(), lineNbr, author.export(), parentUuid, writtenOn); 
<|del|> 
 update.setChangeMessage("Testing trailing double newline\n" + "\n"); 
 assertThat(notes.getComments()) .isEqualTo(ImmutableMultimap.of(revId, comment)); 
 private Op(ChangeControl control, String msgTxt, NotifyHandling notifyHandling) { this.control = control; 
 this.msgTxt = msgTxt; this.notifyHandling = notifyHandling; CurrentUser user = control.getUser(); account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null; 
 this.psUtil = psUtil; 
<|del|> 
 if (!options.isEmpty()) { clp.parseOptionMap(options); } 
 * @return an unmodifiable view of pushOptions, or null if pushOptions is null 
 Map<String, String> branchData = new HashMap<>(); 
 HashMap<String, String> branchData = new HashMap<>(); 
 LinkedHashMap<String, String> branchData = new LinkedHashMap<>(); 
<|del|> 
 start = getStart(view.getParameters(), walk.getObjectReader()); } catch (IOException e) { walk.close(); throw e; } if (start == null) { 
 final String changeNumber = patchsetId[0]; final String revisionNumber = patchsetId[1]; 
 final String changeNumber = patchsetId[0]; final String revisionNumber = patchsetId[1]; 
 public boolean getWriteJson() { 
 public Gson getGson() { 
 public String getServerId() { 
 private void buildNoteJson(ChangeNoteUtil noteUtil, OutputStream out) throws IOException { 
 @ConfigSuite.Config public static Config changeNotesJson() { Config cfg = new Config(); cfg.setBoolean("notedb", null, "writeJson", true); return cfg; 
<|del|> 
 void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) { 
<|del|> 
 ObjectReader reader, ObjectId noteId, PatchLineComment.Status status) 
 if (isJson(raw, p)) { 
 public byte[] build(ChangeNoteUtil noteUtil) throws IOException { 
 } 
 } 
<|del|> 
 PatchLineComment.Key export() { 
 startLine, startChar, endLine, endChar); 
 ImmutableList.Builder<PatchLineComment> builder = ImmutableList.builder(); return ImmutableList.copyOf( Lists.transform(comments, new Function<Comment, PatchLineComment>() { @Override public PatchLineComment apply(Comment c) { return c.export(); } })); 
 ImmutableList.Builder<PatchLineComment> builder = ImmutableList.builder(); return ImmutableList.copyOf( Lists.transform(comments, new Function<Comment, PatchLineComment>() { @Override public PatchLineComment apply(Comment c) { return c.export(); } })); 
public abstract class AbstractChangeNotesTest extends GerritBaseTests implements Provider<Config> { 
 comments.entries().asList().get(0).getValue().getTag()).isEqualTo(tag); 
<|del|> 
 void buildNote( Multimap<PatchSet.Id, PatchLineComment> comments,OutputStream out) { 
 if (p.value < raw.length && isJson(raw, p)) { 
 RevisionNoteData data = noteUtil .getGson().fromJson(r, RevisionNoteData.class); 
 private void buildNoteHomebrew(ChangeNoteUtil noteUtil, OutputStream out) throws IOException { 
 new Patch.Key( new PatchSet.Id(new Change.Id(changeId), patchSetId), filename), uuid); 
 jobs.add(v); 
 * Search for name which ends with a dot, 13 digits and the string 
 Map<Project.NameKey, Map<Branch.NameKey, RevTree>> preview = fetchFromBundles(request); 
 public void testSubscriptionUpdateIncludingChangeInSuperproject() throws Exception { 
 allowMatchingSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master"); 
 BinaryResult submitPreview() throws RestApiException; 
 public BinaryResult apply(RevisionResource rsrc) { 
 raw, p.value, raw.length - p.value); Reader r = new InputStreamReader(is)) { 
 notes.getApprovals().get(c.currentPatchSetId()); 
 notes.getApprovals().get(c.currentPatchSetId()); 
 + " more, hence skipping it in clean up", cd, query); 
 + " more, hence skipping it in clean up", cd, query); 
 saveProjectConfig(project, cfg); 
 fetchFromBundles(BinaryResult bundles) throws Exception { 
<|del|> 
 ZipOutputStream zos = new ZipOutputStream(out); zos.setLevel(0); 
 private BinaryResult reject(final String message) { return BinaryResult.create(message + "\n"); 
 addRule = !exclusivePermissionsByProject.get(project) .contains(permission.getName()); 
 Map<String, EmailHeader> headers, String body) throws EmailException; 
 Map<String, EmailHeader> headers, String body) throws EmailException; 
 int minScore, int maxScore) { 
 } return set; 
 enum TagType { 
 public void createTagForExistingCommit() throws Exception { 
 protected String buildMultipartBody(String boundary, String textPart, 
 protected void appendHtml(String html) { 
 return soyTemplate(name, SanitizedContent.ContentKind.HTML); 
 public void createTagForExistingCommit() throws Exception { 
 allowPushOnRefsTags(); pushTagForExistingCommit(tagType, Status.OK); removePushFromRefsTags(); 
 pushTagForNewCommit(tagType, Status.OK); removePushFromRefsTags(); 
 log.debug("Ignoring NoteDb update error after ReviewDb write", e); 
public abstract class AbstractChangeNotesTest extends GerritBaseTests { 
 install(NoteDbModule.forTest(testConfig)); 
<|del|> 
 addRule = !exclusivePermissionsByProject.containsEntry(project, permission.getName()); 
 // The probability of the boundary being valid is approximately 
 // The message is much shorter than 2^64 bytes, so if two tries don't // suffice, something is seriously wrong. 
<|del|> 
 enum TagType { 
import com.google.gerrit.reviewdb.client.PatchSet; import com.google.gerrit.reviewdb.client.Project; 
<|del|> 
 @Nullable public String htmlBody; 
 public static class Publish implements RestModifyView<ChangeResource, PublishChangeEditInput> { 
 if (in == null) { in = new PublishChangeEditInput(); } editUtil.publish(edit.get(), in.notify); 
 public void publish(final ChangeEdit edit, NotifyHandling notify) throws NoSuchChangeException, IOException, OrmException, RestApiException, UpdateException { 
 public void publish(final ChangeEdit edit, NotifyHandling notify) throws NoSuchChangeException, IOException, OrmException, RestApiException, UpdateException { 
 saveProjectConfig(p, cfg); 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
<|del|> 
 return 
 PatchSetInserter inserter = patchSetInserterFactory .create(ctl, psId, squashed) 
public class LfsConfigInfo { public Boolean enabled; public Long maxObjectSize; 
 private static final AtomicBoolean initialized = new AtomicBoolean(false); 
 u.executeRefUpdates(); 
<|del|> 
 protected Map<Branch.NameKey, RevTree> 
 assertThat(bundleName).endsWith(".git"); 
 assertThat(bundleName).endsWith(".git"); 
<|del|> 
 assertThat(preview).hasSize(3); 
 assertThat(preview).containsKey( new Branch.NameKey(p1, "refs/heads/master")); assertRevTrees(p1, preview); 
 get(REVISION_KIND, "preview_submit").to(SubmitPreview.class); 
 .setContentType(f.getMimeType()) 
 } catch (OrmException | IOException e) { throw new RestApiException("Internal IOError"); 
 IdentifiedUser caller = control.getUser().asIdentifiedUser(); Change change = rsrc.getChange(); 
 try (MergeOp op = mergeOpProvider.get()) { 
 ZipOutputStream zos = new ZipOutputStream(out); zos.setLevel(0); 
 bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId())); 
class GetLfsSettings implements RestReadView<ProjectResource> { 
 public final void defaultBaseForMerges(DefaultBase b) { defaultBaseForMergesRaw(b != null ? b.toString() : null); 
 if (base == null && rev.commit().parents().length() > 1) { base = Gerrit.getUserPreferences() .defaultBaseForMerges().getBase(); 
 /** @return name of this field within the metric. */ 
 @Option(name = "--parent", usage = "Uninteresting parent (1-based, default = 1)") private int uninterestingParent = 1; 
 return Response.<List<CommitInfo>> ok(ImmutableList.<CommitInfo> of()); 
 CommitInfo info = changeJson.toCommit(rsrc.getControl(), rw, c, addLinks, true); 
 @Option(name = "--links", usage = "Include weblinks") 
 @Option(name = "--links", usage = "Include weblinks") 
 throw new MethodNotAllowedException(); 
<|del|> 
 if (a.getParent(i) != b.getParent(i)) { 
 if (a.getParent(i) != b.getParent(i)) { 
 this.repoManagerProvider = repoManagerProvider; this.permissionBackend = permissionBackend; queryCache = new HashMap<>(); heads = new HashMap<>(); 
 fail("expected failure"); } catch (RestApiException e) { 
 fail("expected failure"); } catch (RestApiException e) { 
 throw new BadRequestException("format is not specified"); 
 throw new RestApiException("Error generating submit preview"); 
 ArchiveOutputStream aos = getArchiveOutputStream(format, out); 
 this.allowedFormats = allowedFormats; 
<|del|> 
 private final List<ChangeSubIndex> indexes; private final Predicate<ChangeData> predicate; 
<|del|> 
 public ArchiveOutputStream createArchiveOutputStream(OutputStream o) 
<|del|> 
 } if (changeEnt == null) { 
 CommitValidators(List<CommitValidationListener> validators) { this.validators = validators; } public List<CommitValidationMessage> validate( CommitReceivedEvent receiveEvent) throws CommitValidationException { List<CommitValidationMessage> messages = new LinkedList<>(); 
 this.repoManagerProvider = repoManagerProvider; 
<|del|> 
<|del|> 
 PutAssignee(SetAssigneeOp.Factory assigneeFactory, 
 private final AssigneeInput input; private final AccountsCollection accounts; private final ChangeMessagesUtil cmUtil; private final AccountInfoCacheFactory.Factory accountInfosFactory; 
<|del|> 
 SetAssigneeOp(AccountsCollection accounts, 
 SetAssigneeOp(AccountsCollection accounts, 
<|del|> 
 currentAssignee.equals(newAssigneeUser.getAccountId())) { newAssignee = previousAssignee; 
<|del|> 
@Ignore @RunWith(ConfigSuite.class) 
 .toProvider(Providers.of(testConfig)); 
Copyright (C) 2016 The Android Open Source Project 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
<|del|> 
<|del|> 
 private static final int GERRIT_UI_COOKIE_MAX_AGE = 60 * 60 * 24 * 365; 
<|del|> 
<|del|> 
 BatchUpdate.Factory batchUpdateFactory, Provider<ReviewDb> db) { 
 private final NotesMigration notesMigration; private final String anonymousCowardName; 
 NotesMigration notesMigration, ChangeMessagesUtil cmUtil, AccountInfoCacheFactory.Factory accountInfosFactory, @AnonymousCowardName String anonymousCowardName, @Assisted AssigneeInput input) { 
 public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException { 
 ChangeNotes notes = update.getNotes(); Account.Id oldAssigneeId = notes.getAssignee(); if (input.assignee == null) { if (oldAssigneeId != null) { throw new AuthException("Cannot remove Assignee"); 
 ChangeNotes notes = update.getNotes(); Account.Id oldAssigneeId = notes.getAssignee(); if (input.assignee == null) { if (oldAssigneeId != null) { throw new AuthException("Cannot remove Assignee"); 
 Account oldAssignee = null; if (oldAssigneeId != null) { oldAssignee = accountInfosFactory.create().get(oldAssigneeId); 
 private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException { 
 private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException { 
 msg.append(newAssignee.getName(anonymousCowardName)); 
 if (stars == null) { if (!lazyLoad) { return ImmutableMultimap.of(); } 
 if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) { out.assignee = cd.assignee().isPresent() ? accountLoader.get(cd.assignee().get()) : null; } 
 assertThat(contentEntry.b).containsExactlyElementsIn(expectedLines) .inOrder(); 
 public static List<RevCommit> build(RevWalk rw, RevCommit merge, 
 table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME()); 
<|del|> 
<|del|> 
 private ChangeNoteUtil noteUtil; @Inject 
 private ChangeNoteUtil noteUtil; 
 public Set<UiType> webUis; 
 suggestions.add("is:mergeable"); suggestions.add("is:assigned"); suggestions.add("is:unassigned"); 
<|del|> 
 PatchLineComment export(PatchLineComment.Status status) { 
// limitations under the License. 
 private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) { 
 ChangeSet cs = mergeSuperSet.get().completeChangeSet( dbProvider.get(), c, resource.getControl().getUser()); 
 appendEntriesSection(jar, docs, "Documentation", md, prefix, 0); appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length()); 
import static com.google.gerrit.server.PatchLineCommentsUtil.PLC_ORDER; 
 return Maps.transformValues(cells, in -> (Metric) in); 
 return user.getEffectiveGroups() .containsAnyOf( FluentIterable.from(rules) .filter(predicate) .transform(r -> r.getGroup().getUUID())); 
 .filter(Objects::nonNull); 
 msg.append(" to: "); 
 if (cd.assignee().isPresent()) { out.assignee = accountLoader.get(cd.assignee().get()); } 
<|del|> 
 public Response<AccountInfo> apply(ChangeResource rsrc) throws OrmException { 
 Optional<Account.Id> assignee = rsrc.getControl().getNotes().load().getAssignee(); if (assignee.isPresent()) { 
 assignee = Optional.absent(); 
 assignee.orNull(), 
 @DefaultInput 
 private final String anonymousCowardName; 
 throws RestApiException, UpdateException { 
 throws RestApiException, OrmException{ 
 GetAssignee(AccountInfoCacheFactory.Factory accountInfo) { this.accountInfo = accountInfo; 
 throws RestApiException, UpdateException { 
<|del|> 
 throw new AuthException("Cannot set Assignee to empty"); 
<|del|> 
public enum GitBasicAuthPolicy { 
<|del|> 
 .map(c -> c.export(status)) 
 if (o.name().equalsIgnoreCase(option)) { 
 if (o.name().equalsIgnoreCase(option)) { 
 .toArray(String[]::new)); 
 .transform(plc -> plc.getPatchSetId().getParentKey()).toList(); 
 Set<Account.Id> pastAssignees = rsrc.getControl().getNotes().load().getPastAssignees(); if (pastAssignees == null) { 
<|del|> 
 return Response.ok(pastAssignees.stream() .map(accountInfoFactory::get) .map(AccountJson::toAccountInfo) .collect(toSet())); 
 db = reviewDbProvider.open(); 
 public static void deleteAssignee(int id, AsyncCallback<AccountInfo> cb) { change(id).view("assignee").delete(cb); } public static void setAssignee(int id, String user, AsyncCallback<AccountInfo> cb) { 
 final native void assignee(String a) /*-{ if(a)this.assignee=a; }-*/; 
<|del|> 
<|del|> 
 Object element = Iterables.getOnlyElement(values.getValues(), ""); if (!(element instanceof String) || !((String) element).isEmpty()) { builder.field(name, element); 
 Object element = Iterables.getOnlyElement(values.getValues(), ""); if (!(element instanceof String) || !((String) element).isEmpty()) { builder.field(name, element); 
 cd.setCurrentApprovals(decodeProtos(source, ChangeField.APPROVAL.getName(), PatchSetApprovalProtoField.CODEC)); 
 int aId = reviewedBy.get(i).getAsInt(); if (reviewedBy.size() == 1 && aId == ChangeField.NOT_REVIEWED) { 
 // use Lucene to make all tests green and Gerrit server to work 
<|del|> 
 if (value.endsWith("$") && !value.endsWith("\\$") && !value.endsWith("\\\\$")) { 
 .addMapping("open_changes", getMappingProperties("open_changes")) .addMapping("closed_changes", getMappingProperties("closed_changes")) 
 elasticsearchConfig.setString("index", null, "protocol", "http"); elasticsearchConfig.setString("index", null, "hostname", "localhost"); elasticsearchConfig.setString("index", null, "port", port); 
 break; 
<|del|> 
<|del|> 
 public Object apply(ChangeResource rsrc, Input input) 
 factory(FileListLoader.Factory.class); persist(FILE_LIST, PatchListKey.class, FileList.class) .maximumWeight(10 << 20) .weigher(FileListWeigher.class) .diskLimit(1 << 30); 
 PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project)); fileListCache.put(key, toFileList(pl)); return pl; 
 if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) { return failAuthentication(rsp, username); 
 msg.append(previousAssignee.getName(anonymousCowardName)); msg.append(" to: "); msg.append(newAssignee.getName(anonymousCowardName)); 
 * <p> 
 * 
 private final List<Comment> comments; 
 PatchSet.Id psId = new PatchSet.Id(ctx.getChange().getId(), origComment.key.patchSetId); 
Copyright (C) 2016 The Android Open Source Project 
 public static void setAssignee(int id, String user, AsyncCallback<AccountInfo> cb) { 
 ChangeApi .suggestReviewers(changeId.get(), req.getQuery(), req.getLimit(), false) 
 @Option(name = "--exclude-groups", aliases = {"-e"}, usage = "exclude groups from query") 
 @Option(name = "--exclude-groups", aliases = {"-e"}, usage = "exclude groups from query") 
 } else if (fieldType == FieldType.PREFIX || fieldType == FieldType.FULL_TEXT || fieldType == FieldType.STORED_ONLY) { 
 public static void startIndexService() throws InterruptedException, ExecutionException { 
 createIndexes(); 
 String nodes = node.client().admin().cluster() .nodesInfo(new NodesInfoRequest("*")).get().toString(); Gson gson = new GsonBuilder() .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES) .create(); 
 index.select("Transport protocol", "protocol", "http", Sets.newHashSet("http", "https")); 
import static com.google.common.truth.Truth.assertThat; import static com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS; 
 public void requestDefaultSuggestions(Request req, Callback cb) { 
 }); } 
 * Invoked by Gerrit a user who is searching for a reviewer to add to a change. 
 final native void assignee(String a) /*-{ if(a)this.assignee=a; }-*/; 
 public void testGetNoAssignee() throws Exception { 
 private Set<AccountInfo> getPastAssignees(PushOneCommit.Result r) throws Exception { 
 throw new RestApiException("Cannot set assignee", e); 
 throw new RestApiException("Cannot get assignee", e); 
 throw new RestApiException("Cannot get past assignees", e); 
 throw new RestApiException("Cannot delete assignee", e); 
 return r.isNone() ? null : r.value(); 
 public void setComments(List<Comment> comments) throws OrmException { 
 .settings(settings) .node(); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 .maximumWeight(10 << 20) .weigher(PatchListWeigher.class); 
 .maximumWeight(10 << 20) .weigher(IntraLineWeigher.class); 
 get(ACCOUNT_KIND, "external.ids").to(GetExternalIds.class); 
 ChangeQueryBuilder.FIELD_ASSIGNEE, FieldType.INTEGER, false) { 
 * Allows assigning a change to a user. 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 /** * Create a DiffObject that represents the parent of a 1-parent patch set. */ 
<|del|> 
 if (Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) { 
<|del|> 
 if (Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) { 
 @Nullable AccountInfo getOldAssignee(); 
 public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException { change = ctx.getChange(); 
 .to(StreamEventsApiListener.class); 
 Bulk bulk = addActions(new Bulk.Builder(), c).refresh(refresh).build(); 
 .index(indexName) .type(type) .id(id) .build(); 
 .defaultIndex(indexName) .defaultType("changes") .addAction(insert(insertIndex, cd)) .addAction(delete(deleteIndex, cd.getId())) .refresh(refresh) .build(); 
 ImmutableMap<String, ChangeMapping> mappings = ImmutableMap.of("mappings", mappging); 
<|del|> 
<|del|> 
<|del|> 
 .addMapping(OPEN_CHANGES, gson.toJson(mapping.openChanges)) .addMapping(CLOSED_CHANGES, gson.toJson(mapping.closedChanges)) 
 ChangeMapping(Schema<ChangeData> schema) { ElasticMapping.Builder mappingBuilder = new ElasticMapping.Builder(); 
<|del|> 
<|del|> 
 } catch (OrmException | QueryParseException e) { log.error("Failed to validate assignee for change " + change.getId(), e); // Allow assignee. 
 paths = new String[readVarInt32(input)]; 
<|del|> 
 @Assisted @Nullable NotifyHandling notify) 
 throw new IllegalStateException( "Unsupported filed type: " + fieldType.getName()); 
 .settings(settings) .node(); 
public class RobotCommentInfo extends CommentInfo { 
 return sort(Lists.newArrayList(notes.getRobotComments().values())); 
<|del|> 
 return read(accountId).getKeys(); 
 return read(accountId).getKey(seq); 
 * for an edit patch set; {@code null} for the base of a 1-parent * patch set and for the auto-merge of a merge patch set 
 SideBySideTable(SideBySide parent, DiffObject base, DiffObject revision, 
 MappingProperties mapping = mappingBuilder.build(); openChanges = mapping; closedChanges = mapping; 
<|del|> 
 return gson.toJson(ImmutableMap.of("mappings", mapping)); 
 if (!migration.readChanges()) { 
 .append("properties=").append(properties != null ? properties : "") 
 * @return the lines of file content in fileData that are encompassed by range 
 if (sameEmail(change.owner(), person)) { 
 if (sameEmail(change.owner(), person)) { 
 if (sameEmail(change.owner(), person)) { 
 Reviewers reviewers = getReviewers(); if (reviewers != null) { reviewers.updateReviewerList(); } 
 synchronized void format(StringBuilder s) { if (count == 0) { return; } 
 String prefix = getRangedCommentLinePrefix(comment); 
 } lines.add(s); 
 * This comparator is adapted from com.google.gerrit.client.info.FileInfo. 
 this.filename.substring(0, s1).equals(o.filename.substring(0, s2))) { 
 if (cppHeaderSuffixes.contains(suffixA)) { 
<|del|> 
<|del|> 
 private String createChangeFromApi() throws RestApiException{ return createChangeFromApi(project); 
 public void requestDefaultSuggestions(Request req, Callback cb) { 
import com.google.gerrit.client.ui.AccountSuggestOracle; 
import com.google.gwt.core.client.JsArray; import com.google.gwtexpui.safehtml.client.HighlightSuggestOracle; 
 public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, 
 * <p> 
 return Gerrit.info().user().anonymousCowardName(); 
 "Bazel mode: generate multiple output files instead of a single zip file") 
 throws EmailException { send(from, rcpt, callerHeaders, body, null); } 
 if (f == null && format.equals("tgz")) { // Always allow tgz, even when the allowedFormats doesn't contain it. // Then we allow at least one format even if the list of allowed // formats is empty. 
 createRobotCommentUpdateIfNull(); robotCommentUpdate.putComment(c); 
 ChangesCollection changes, 
 ChangesCollection changes, 
 @Option(name = "--delete-caches", usage = "Delete all persistent caches without asking") private boolean deleteCaches; 
 @Option(name = "--delete-caches", usage = "Delete all persistent caches without asking") private boolean deleteCaches; 
 InitCache(final ConsoleUI ui, final SitePaths site, final Section.Factory sections) { this.ui = ui; 
<|del|> 
 if (!cacheFiles.isEmpty() && ui.yesno(false, "Clear persistent caches")) { for (Path entry : cacheFiles) { 
<|del|> 
 PatchLineComment e = drafts.remove(Url.decode(c.id)); 
<|del|> 
 return ChangeMessagesUtil.newMessage(ctx, msg.toString()); 
 .append(realAuthor != null ? realAuthor.getId().get() : "") 
 * Real user that added this comment on behalf of the user recorded in {@link 
 builder.append("realAuthor=") .append(realAuthor != null ? realAuthor.get() : "").append(','); 
 .append(realAuthor != null ? realAuthor.getId().get() : "") 
 + " author of this ChangeDraftUpdate (%s): %s", realAccountId, comment); 
 accountId, realAccountId, authorIdent, when); 
 super(psId, author, when, change.getCreatedOn(), tag); 
 private static int patchSetId() { 
<|del|> 
 currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename); 
 Collections.sort(groups); 
<|del|> 
 throw new IllegalArgumentException( "There is no FileLfsRepository [" + repoId + "] configured"); 
 groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String> of(); 
 } MergeInput merge = in.merge; if (Strings.isNullOrEmpty(merge.source)) { throw new BadRequestException("merge.source must be non-empty"); } 
 throw new AuthException("cannot add patch set"); 
<|del|> 
<|del|> 
 throw new ResourceNotFoundException( "cannot find source commit: " + merge.source + " to merge."); 
 RevCommit currentPsCommit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get())); 
 createMergeCommit(in, projectControl, dest, git, oi, rw, currentPsCommit, sourceCommit, author, ObjectId.fromString(change.getKey().get().substring(1))); 
 createMergeCommit(in, projectControl, dest, git, oi, rw, currentPsCommit, sourceCommit, author, ObjectId.fromString(change.getKey().get().substring(1))); 
 ChangeJson json = jsonFactory.create(EnumSet.of(ListChangesOption.CURRENT_REVISION)); return Response.ok(json.format(psInserter.getChange())); 
 ChangeJson json = jsonFactory.create(EnumSet.of(ListChangesOption.CURRENT_REVISION)); return Response.ok(json.format(psInserter.getChange())); 
<|del|> 
<|del|> 
 String.format("Namespace %s: backend %s does not exist", namespace, info.backend)); 
 private class FileCommentGroup { 
 // Assert that user are ranked by the number of times they have applied a // a label to a change (highest), added comments (medium) or owned a // change (low). 
 private void addReviewer(String changeId, TestAccount reviewer) 
 qterm = escape(qterm); 
 throws OrmException { 
 List<Callable<Set<SuggestedReviewer>>> tasks = new ArrayList<>(reviewerSuggestionPluginMap.plugins().size()); 
 for (PatchSetApproval approval : cd.currentApprovals()) { Account.Id id = approval.getAccountId(); 
 log.error("Exception while suggesting reviewers", e); 
 log.error("Exception while suggesting reviewers", e); 
<|del|> 
<|del|> 
<|del|> 
 public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, 
 // Always add groups at the end as individual accounts are usually // more important reviewer.add(suggestedReviewerInfo); 
 Set<SuggestedReviewer> suggestReviewers( 
<|del|> 
 assertThat(Iterables.getLast(info.messages).message).startsWith( 
<|del|> 
 public static Module module() { 
 // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong // and can be fixed. 
 args.rw.parseBody(toMerge); 
 PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId()); // TODO(tandrii): add extension point to customize commit message while // rebasing. 
 if (rebaseOp != null) { 
<|del|> 
<|del|> 
 final String message, final String ref, final RefControl refControl, int parent) throws NoSuchChangeException, 
 if (parent <= 0 || parent > commitToCherryPick.getParentCount()) { 
 ProjectState projectState = refControl.getProjectControl() .getProjectState(); cherryPickCommit = mergeUtilFactory.create(projectState) .createCherryPickFromCommit(git, oi, mergeTip, 
 parent - 1); 
 private void reviewChange(String changeId) throws RestApiException { 
<|del|> 
<|del|> 
 double baseWeight = config.getInt("addReviewer", "baseWeight", 1); 
 // Get all labels for this project and create a compound OR query to 
 throws IOException, OrmException { 
 List<Account.Id> candidateList = new ArrayList<>(); 
 tokenCache.remove(accountId); accountId = null; 
 public Timestamp date; public Boolean postSubmit; 
<|del|> 
 .setRefSpecs(new RefSpec("HEAD:refs/for/master/" + name("topic-foo"))) .call(); 
 public LfsBackend apply(String input) { return new LfsBackend(input, type); 
<|del|> 
 serve(defRepository.getServletUrlPattern()) .with(new LfsFsContentServlet(defRepository)); 
 serve(repository.getServletUrlPattern()) .with(new LfsFsContentServlet(repository)); 
 serve(repository.getServletUrlPattern()) .with(new LfsFsContentServlet(repository)); 
 this.servletUrlPattern = "/" + getContentPath(backend) + "*"; 
 } for (LfsBackendConfig backendCfg : backends.values()) { if (FS.equals(backendCfg.type)) { LocalLargeFileRepository repository = fsRepoFactory.create(backendCfg); serve(repository.getServletRegexp()) .with(new LfsFsContentServlet(repository)); } } 
 CacheLoader<LfsBackend, LargeFileRepository> { 
 private final LoadingCache<LfsBackendConfig, LocalLargeFileRepository> cache; 
 Set<SuggestedReviewer> suggestReviewers(Project.NameKey project, @Nullable Change.Id changeId, @Nullable String query, Set<Account.Id> candidates); 
 Set<SuggestedReviewer> suggestReviewers(Project.NameKey project, @Nullable Change.Id changeId, @Nullable String query, Set<Account.Id> candidates); 
<|del|> 
 String subject = "Test change\n\n" + "Change-Id: Ideadbeefdeadbeefdeadbeefdeadbeefdeadbeef"; 
 assertThat(gApi.changes() .id(r.getChangeId()) .revision(r.getCommit().name()) .comment(comment.id) .get() .message) .isEqualTo(in.message); 
 * @return the configured LFS backend type. 
 LfsBackendType backendType; 
 LfsBackendType type = cfg.getEnum("storage", null, "backend", LfsBackendType.FS); 
<|del|> 
 this.cache = cache; 
 Optional<Event> submitEvent = Lists.reverse(events).stream() 
 public Manager(DefaultEventWorker defaultEventWorker, PublisherFactory publisherFactory, KafkaProperties properties) { 
 private static final long serialVersionUID = 0L; 
<|del|> 
 return new KafkaProperties(configFactory.getFromGerritConfig(pluginName)); 
 boolean isEnabled(); 
<|del|> 
 LOGGER.debug("Already connected."); 
 return set(req, Optional.ofNullable(f)); 
 String[] formats = cfg.getStringList("archive", null, "format"); if (formats.length == 0) { 
 .map(TimeZone::getTimeZone); 
 LOGGER.debug("Already connected."); 
 result.put(e.getKey(), changeJson.approvalInfo(a.getId(), new Integer(e.getValue()), ts)); 
 out.append(firstLine ? prefix : emptyPrefix) 
 public static class Id extends IntKey<com.google.gwtorm.client.Key<?>> { 
 * @return immutable snapshot of options configured so far. If neither {@link * #getSubmitRule()} nor {@link #getSubmitType()} have been called yet, * state within this instance is still mutable, so may change before 
 out.reviewerChanges = reviewerChanges(cd); 
 * Differently from the normal HttpServletResponse, this class allows multiple * filters to override the response http status code. 
 * Differently from the normal HttpServletResponse, this class allows multiple * filters to override the response http status code. 
 private final boolean rebaseAlways; 
 // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong // and can be fixed. 
<|del|> 
 throw new BadRequestException(e.getMessage(), e); 
 private static FilenameComparator filenameComparator = new FilenameComparator(); 
 String body, @Nullable String tag) throws OrmException { 
 String body, @Nullable String tag) throws OrmException { 
 message, ChangeMessagesUtil.UPLOADED_PATCH_SET); 
 ChangeMessagesUtil.UPLOADED_PATCH_SET); 
 ChangeMessagesUtil.SET_TOPIC); 
 ChangeMessagesUtil.SET_HASHTAGS); 
 orm.openRepo(project, true); 
 ChangeMessagesUtil.MERGED_BY_PUSH); 
 msg = ChangeMessagesUtil.newMessage( patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET); 
import static com.google.gerrit.reviewdb.client.Account.FieldName.USER_NAME; 
 Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes()); 
 gApi.changes().id(changeId).abandon(); 
 "Allow admins and project owners to create refs/meta/config"; 
 public IncludedIn.IncludedInInfo apply(CommitResource rsrc) throws RestApiException, OrmException, IOException { 
 ChangeControl changeControl = rsrc.getControl(); boolean visible = isActionAllowed(changeControl, status) && changeControl.canDelete(db.get(), status); 
 changeDeleted.fire(ctx.getChange(), ctx.getAccount(), ctx.getWhen()); 
<|del|> 
<|del|> 
<|del|> 
 assertThat(res).isEqualTo(PATCH_FILE_ONLY); exception.expect(ResourceNotFoundException.class); exception.expectMessage("File not found: nonexistent-file."); changeApi.revision(r.getCommit().name()).patch("nonexistent-file"); 
 // CherryPick ignores dependencies, thus only change and destination // branch refs are modified. 
 public OwnerPredicateProvider(Provider<ReviewDb> db, AccountResolver resolver) { OwnersStoredValues.initialize(db.get(), resolver); 
<|del|> 
<|del|> 
import com.google.gerrit.server.git.validators.CommitValidationListener; import com.google.gerrit.server.git.validators.CommitValidators; 
import com.google.gerrit.server.notedb.ReviewerStateInternal; 
import com.google.gerrit.server.mail.RecipientType; import com.google.gerrit.server.mail.send.ProjectWatch.Watchers; 
 final ParameterizedString name = a.getName() != null ? new ParameterizedString(a.getName()) : null; 
import com.google.gerrit.server.mail.RecipientType; import com.google.gerrit.server.mail.send.ProjectWatch.Watchers; 
<|del|> 
<|del|> 
 Collections.sort(Natives.asList(list), Comparator.comparing(FileInfo::path, FilenameComparator.INSTANCE)); 
 Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE)); 
 CurrentUser loggedInUserBefore = loggedInBefore ? userProvider.get() : null; 
 newId = ins.insert(OBJ_BLOB, Integer.toString(val).getBytes(UTF_8)); 
 if (err.getCause() != null) { Throwables.throwIfInstanceOf(err.getCause(), OrmException.class); } 
 private final EmailSettings mailSettings; 
 private final EmailSettings mailSettings; 
 break; case NONE: default: 
 log.warn("Failing to commit manifest subscription update:"+ "\n\tProject: " + projectName + "\n\tRef: " + refName); 
 filter = dest -> dest.isCreateMissingRepos(); 
 filter = dest -> dest.isReplicateProjectDeletions(); 
 if (path != null && bin.asString().isEmpty()) { 
 b.append('\n'); 
 SimpleDateFormat df = new SimpleDateFormat( "EEE, dd MMM yyyy HH:mm:ss Z", Locale.US); 
<|del|> 
 Optional<IdentifiedUser> loggedInUserBefore = loggedInUser(); 
 c.setInheritChannel(cfg.getBoolean("httpd", "inheritChannel", false)); 
 "\nrefName: " + refName); } else if (REFS_CONFIG.equals(refName)) { 
 info.tag = psa.getTag(); if (psa.isPostSubmit()) { info.postSubmit = true; } 
 info.tag = psa.getTag(); if (psa.isPostSubmit()) { info.postSubmit = true; } 
<|del|> 
 this.oneOffRequestContext = oneOffRequestContext; 
 try (ManualRequestContext ctx = requestContext.openAs(change.getOwner())) { 
 try (ManualRequestContext ctx = requestContext.openAs(change.getOwner())) { 
 * The user in the request context is {@link InternalUser} or the * {@link IdentifiedUser} associated to the userId passed as parameter. 
<|del|> 
 private final IdentifiedUser.GenericFactory identifiedUserFactory; 
 super.sendRedirect(headers.get(LOCATION_HEADER)); 
<|del|> 
Copyright (C) 2016 The Android Open Source Project 
 + ". Run `" + buildCommand + "`?"); 
 return builder.targetPath( new BuildSystem.Label( "polygerrit-ui", "polygerrit_components", "polygerrit_components.bower_components.zip")); 
 return sourceRoot.resolve("buck-out") .resolve("gen").resolve(label.pkg).resolve(label.name).resolve(label.artifact); 
 "polygerrit-ui", "fonts", "fonts.zip")); 
 BuildSystem.Label label = new BuildSystem.Label(pkg, String.format("__gwt_binary_%s__", target), target + ".zip"); 
 BuildSystem.Label label = new BuildSystem.Label(pkg, String.format("__gwt_binary_%s__", target), target + ".zip"); 
 } 
 public final static String TAG_ABANDON = 
 public final static String TAG_CHERRY_PICK_CHANGE = 
 private final Path sourceRoot; 
 } 
 } 
 private final Path sourceRoot; 
 log.info( String.format("UPDATED %s in %.3fs", label.fullName(), time / 1000.0)); 
 this.builder = builder; this.unpackedWar = unpackedWar; 
 if (subject.length() < 64) { 
 LabelType lt = ctl.getLabelTypes().byLabel(e.getKey()); 
import com.google.gerrit.server.git.MergeTip; import com.google.gerrit.server.git.RebaseSorter; 
 .toArray(String[]::new); 
 .toArray(String[]::new); 
<|del|> 
 Provider provider = Security.getProvider(config.getJCEProvider()); Security.addProvider(provider); 
 return Arrays.stream(sec.getStringList(section, subsection, name)) .map(codec::decode).collect(Collectors.toList()).toArray(new String[0]); 
 values.stream().map(codec::encode).collect(Collectors.toList())); 
 private final ChangeNotes.Factory changeNotesFactory; 
 addChange(id, changes, projectControl, true); 
 ProjectControl projectControl, boolean useIndex) throws UnloggedFailure, OrmException { 
 .collect(toList()); 
 HookResult result = hook.run(projectName, args); 
 HookResult result = hook.run(args); 
<|del|> 
<|del|> 
<|del|> 
 protected MergeTip _run(CodeReviewCommit branchTip, 
<|del|> 
import com.google.gerrit.server.git.MergeTip; import com.google.gerrit.server.git.RebaseSorter; 
 boolean isSkipMerge = config.isSkipMerge(branchName, downstreamBranch, input.subject); 
 } catch (IOException | RestApiException e) { 
 } catch (IOException | RestApiException e) { 
 return new HashSet(); 
<|del|> 
 public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) 
 private static final int MAX_CONFLICT_MESSAGE_LENGTH = 10000; 
 global = Collections.emptyMap(); config = Collections.emptyMap(); defaultManifestInfo = Collections.emptyMap(); 
 private Pattern getConfigPattern(String key) { Set<String> mergeStrings = new HashSet<String>((List<String>) global.get(key)); return Pattern.compile(Joiner.on("|").join(mergeStrings), Pattern.DOTALL); } 
 public Map<String, Object> getMergeConfig(String fromBranch, String toBranch) { 
 return Collections.emptyMap(); 
 } catch (SAXException | ParserConfigurationException | IOException e) { log.error("Exception on manifest for branch {}: {}", branch, e); 
 "missing state string for change %s", changeId); 
 Type collectionType = new TypeToken<Map<String, Boolean>>() {}.getType(); Map<String, Boolean> branchMap = g.fromJson(input.branchMap, collectionType); 
 desc = desc.setLabel("Recreate automerges").setTitle("Recreate automerges downstream"); 
 } catch (RestApiException | IOException e) { log.error("Failed to recreate automerges for {} on {}: {}", project, branch, e); 
 changeRepo, allUsersRepo)); 
 Properties properties = loadBuckProperties( sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties")); 
 // Verify user is added to CC list. 
 // User posting this review isn't currently in the reviewer or CC list, // isn't being explicitly added, and isn't voting on any label. 
 Account.Id id = bu.getUser().getAccountId(); ReviewerSet currentReviewers = approvalsUtil.getReviewers( db.get(), revision.getChangeResource().getNotes()); boolean ccOrReviewer = currentReviewers.all().contains(id); 
 Account.Id id = bu.getUser().getAccountId(); ReviewerSet currentReviewers = approvalsUtil.getReviewers( db.get(), revision.getChangeResource().getNotes()); boolean ccOrReviewer = currentReviewers.all().contains(id); 
 Account.Id id = bu.getUser().getAccountId(); ReviewerSet currentReviewers = approvalsUtil.getReviewers( db.get(), revision.getChangeResource().getNotes()); boolean ccOrReviewer = currentReviewers.all().contains(id); 
<|del|> 
 Map<String, Boolean> downstreamMap = new HashMap<>(); 
 return new HashSet<>(); 
 log.error("Exception on manifest for branch {}", branch, e); 
 private static final int iterationCount = 2048; 
 private static final int iterationCount = 2048; 
 throw new IllegalArgumentException("encode() failed", e); 
 throw new IllegalArgumentException("encode() failed", e); 
 SecureConfigSettings(SitePaths site) throws IOException, 
 Stopwatch sw = Stopwatch.createStarted(); ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr())); 
 ui.message(String.format("\t> Done (%.3f s)", sw.elapsed(TimeUnit.MILLISECONDS) / 1000d)); 
 ui.message(String.format("\t> Done (%.3f s)", sw.elapsed(TimeUnit.MILLISECONDS) / 1000d)); 
 fetchInterval = cfg.getTimeUnit(RECEIVE_EMAL, null, "fetchInterval", TimeUnit.MILLISECONDS.convert(60, TimeUnit.SECONDS), TimeUnit.MILLISECONDS); 
 // Envelope Information 
 abstract ImmutableList.Builder<String> toBuilder(); 
 * requestDeletion will enqueue an email for deletion and delete it the 
 public void requestDeletion(String messageId) { pendingDeletion.add(messageId); 
 */ @Override 
 private Timer timer; private Set<String> pendingDeletion; 
 @Override public void start() { 
 @Override 
 @Override protected synchronized void handleEmails() { 
 @Override protected synchronized void handleEmails() { 
 POP3MessageInfo[] messages = pop3.listMessages(); 
<|del|> 
 return new BuildSystem.Label("gerrit-gwtui", "ui_" + agent, "gerrit-gwtui/__gwt_binary_ui_" + agent + "/ui" + agent +".zip"); 
<|del|> 
 private static final ImmutableSet<String> MAIN_HEADERS = 
 @Test @GerritConfig(name = "gerrit.editGpgKeys", value = "true") @GerritConfig(name = "receive.enableSignedPush", value = "true") 
 public final long fetchInterval; // in milliseconds 
 return new Label("//polygerrit-ui", "polygerrit_components.bower_components.zip"); 
 String t = "ui_" + agent; return new BuildSystem.Label("gerrit-gwtui", t, String.format("gerrit-gwtui/__gwt_binary_%s__/%s.zip", t, t)); 
 String t = "ui_" + agent; return new BuildSystem.Label("gerrit-gwtui", t, String.format("gerrit-gwtui/__gwt_binary_%s__/%s.zip", t, t)); 
 String t = "ui_" + agent; return new BuildSystem.Label("gerrit-gwtui", t, String.format("gerrit-gwtui/__gwt_binary_%s__/%s.zip", t, t)); 
 String t = "ui_" + agent; return new BuildSystem.Label("gerrit-gwtui", t, String.format("gerrit-gwtui/__gwt_binary_%s__/%s.zip", t, t)); 
 "polygerrit-ui/polygerrit_components/" + "polygerrit_components.bower_components.zip"); 
Copyright (C) 2016 The Android Open Source Project 
 FontsServlet(Cache<Path, Resource> cache, @Nullable BuildSystem builder) 
<|del|> 
 ChangeBundle actual = ChangeBundle.fromNotes( commentsUtil, notesFactory.create(dbProvider.get(), project, id)); 
 config.getProject().setCreateNewChangeForAllNotInTarget( InheritableBoolean.TRUE); 
 private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort, RevCommit initialTip) throws IntegrationException { 
 * <p>This extracts the commit messages and the diff texts and calculates string * similarities. Given two string similarities, it puts them into a classifier * built with support vector machine and decides if two commits are similar. 
 public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException { 
Copyright (C) 2016 The Android Open Source Project 
Copyright (C) 2016 The Android Open Source Project 
Copyright (C) 2016 The Android Open Source Project 
import com.google.common.truth.Expect; 
 public GeneralPreferencesInfo loadChangeTableColumns(GeneralPreferencesInfo r, VersionedAccountPreferences v, VersionedAccountPreferences d) { r.changeTable = changeTable(v); 
 return Lists.newArrayList(v.getConfig().getStringList(DASHBOARD, null, "column")); 
 public static void storeMyChangeTableColumns(VersionedAccountPreferences prefs, List<String> changeTable) { 
 if (changeTable != null) { unsetSection(cfg, UserConfigSections.CHANGE_TABLE); cfg.setStringList(UserConfigSections.CHANGE_TABLE, null, CHANGE_TABLE_COLUMN, changeTable); 
 .append(getHttpHost(scheme, project)) 
 private List<CommentSender.FileCommentGroup> getGroupedInlineComments( Repository repo) { 
 * Take a string of comment text that was written using the wiki-Like format 
<|del|> 
<|del|> 
 return p.trim().startsWith("> "); 
 return p.startsWith("- ") || p.startsWith("* ") || p.contains("\n- ") || p.contains("\n* "); 
<|del|> 
<|del|> 
 html.setAttribute( "href", PageLinks.toAccountQuery(String.valueOf(name), Change.Status.NEW) ); 
 db = reviewDbProvider.open(); 
 protected Provider<CurrentUser> userProvider; protected @GerritPersonIdent PersonIdent gerrit; protected GitRepositoryManager repoManager; protected GitReferenceUpdated gitRefUpdated; protected IdentifiedUser user; protected TagCache tagCache; protected AccountCache accountCache; 
 RefUpdater( AccountCache accountCache, Provider<CurrentUser> userProvider, @GerritPersonIdent PersonIdent gerrit, GitRepositoryManager repoManager, TagCache tagCache, GitReferenceUpdated gitRefUpdated) { this.accountCache = accountCache; 
 private boolean ignoreWorkInProgressPatchSet; private boolean ignorePrivatePatchSet; 
 assume().that(HostPlatform.isWin32() || HostPlatform.isMac()).isTrue(); 
<|del|> 
 log.info( String.format("UPDATED %s in %.3fs", label.fullName(), time / 1000.0)); 
 log.info("building [" + name() + "] " + label.fullName()); 
 abstract Label fontZipLabel(); /** Build system name. */ abstract String name(); 
<|del|> 
 private RevCommit getHead(Repository repo, String name) throws IOException { 
 if(cfg.isUpdated()) { repoUpgraded.add(projectName); } 
 ui.message("\tMigration completed: " + repoUpgraded.size() + " repositories updated:"); ui.message("\t" + repoUpgraded.stream().map(n -> n.get()).collect(Collectors.joining(" "))); 
<|del|> 
 ui.message("\tMigration completed: " + repoUpgraded.size() + " repositories updated:"); ui.message("\t" + repoUpgraded.stream().map(n -> n.get()).collect(Collectors.joining(" "))); 
<|del|> 
 .filter(Objects::nonNull); 
 gitRepositoryManager, groupBackend, stateLog, groupIncludeCache, eventDispatcher); 
 " must be java.util.Date or java.lang.String for key " + entry.getKey()); 
 " must be java.util.Date or java.lang.String for key " + entry.getKey()); 
 DateTimeFormatter.ofPattern("EEE, dd MMM yyyy HH:mm:ss ZZZ"); 
 ActionInfo rebase = newActions.get("rebase"); assertThat(rebase).isNotNull(); assertThat(rebase.label).isEqualTo("All Your Base"); 
 DateTimeFormatter.ofPattern("E, dd MMM yyyy HH:mm:ss Z"); 
 public static String toHeaderWithDelimiter(String metadataName) { 
 return changeId != null && patchSet != null && author != null && timestamp != null && messageType != null; 
 return MoreObjects.toStringHelper(this) .add("Change-Id", changeId) .add("Patch-Set", patchSet) .add("Author", author) .add("Timestamp", timestamp) .add("Message-Type", messageType) .toString(); 
 } else if (header.startsWith( toHeaderWithDelimiter(MetadataName.TIMESTAMP))) { String ts = header.substring( toHeaderWithDelimiter(MetadataName.TIMESTAMP).length()); 
 /** Loads configured Guice modules from {@code gerrit.installModule}. */ 
 private static Config getConfig(Injector i) { return i.getInstance(Key.get(Config.class, GerritServerConfig.class)); 
<|del|> 
<|del|> 
<|del|> 
 // String description() throws RestApiException; void description(String description) throws RestApiException; 
 public Response<String> apply(RevisionResource rsrc, Input input) 
 ? Response.none() 
 Op(Input input, PatchSet.Id psId) { 
 summary = "Description set to \"" + newDescription + "\""; 
 public UiAction.Description getDescription(RevisionResource rsrc) { 
import com.google.gerrit.testutil.FakeEmailSender; 
 node.client().admin().indices().prepareDelete(INDEX_NAME).execute(); 
 Provider<CurrentUser> user, ConfigLoader config, DownstreamCreator dsCreator) { 
 log.debug("Branch map is empty for change {}", change.getKey().get()); 
 log.debug("Multiple downstream merge input: {}", mdsMergeInput.dsBranchMap); 
 new InputStreamReader(getClass().getClassLoader().getResourceAsStream( configKeysPath), Charsets.UTF_8)) { 
 log.debug("Project set for {} to {} is {}", fromBranch, toBranch, projectSet); 
 Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create(); 
<|del|> 
 put(REVISION_KIND, "description").to(PutDescription.class); get(REVISION_KIND, "description").to(GetDescription.class); 
<|del|> 
 PutDescription(Provider<ReviewDb> dbProvider, ChangeMessagesUtil cmUtil, BatchUpdate.Factory batchUpdateFactory, PatchSetUtil psUtil) { 
 .setVisible(rsrc.getControl().canEditDescription()); 
<|del|> 
 for (ChangeData change : changes) { if (change.change().getStatus() == Status.MERGED && change.change().getDest().equals(n.change().getDest())) { return true; } } return false; 
 if (isMerged(c, n.change().getDest())) { 
 args.rw, args.alreadyAccepted, args.canMergeFlag, args.internalChangeQuery).sort(toSort); 
 * @param comments Comments previously persisted on the change that caused the * original notification email to be sent out. Ordering must be * the same as in the outbound email 
 Provider<InternalChangeQuery> queryProvider, 
 List<ChangeData> changes = queryProvider.get() .byProjectCommit(getProject().getNameKey(), commit); 
 List<ChangeData> changes = queryProvider.get() .byProjectCommit(getProject().getNameKey(), commit); 
 private boolean canReadCommitFromVisibleRef(ReviewDb db, Repository repo, 
 if (detailedCommitMessage) { newCommitMessage = newMergeUtil().createDetailedCommitMessage(original, ctl, originalPatchSet.getId()); 
 ObjectId base, String commitMessage) throws ResourceConflictException, MergeConflictException, IOException { 
 @TestTime(step=1) 
 public boolean canReadCommit(ReviewDb db, Repository repo, RevCommit commit) { // look for changes associate with the commit. 
 log.error("Cannot look up change for commit " + commit.name() + " in " + getProject().getName(), e); 
 block.text = p.replaceAll("\n\\s?>\\s", "\n").trim(); 
 block.text = p.replaceAll("\n\\s?>\\s", "\n").trim(); 
 private static boolean isQuote(String p) { return p.startsWith("> ") || p.startsWith(" > "); 
 assertThat(block.text).isEqualTo(text); assertThat(block.items).isNull(); 
 assertThat(block.items.get(itemIndex)).isEqualTo(text); assertThat(block.text).isNull(); 
 "#" + PageLinks.toAccountQuery(name, Change.Status.NEW)); 
 /** Whether this comment requires addressing by the change owner. */ 
 /** Whether this comment requires addressing by the change owner. */ 
/** * Add unresolved field to PatchLineComment and ChangeMessage, add parentUuid * field to ChangeMessage. */ 
 if (reporter == null) { reporter = "(unknown)"; } 
<|del|> 
<|del|> 
 assertThat(Iterables.getOnlyElement(infos.values()).reporter).isNull(); 
 assertThat(Iterables.getOnlyElement(infos.values()).reporter).isNull(); 
 if (filter != null) { 
 * This class demonstrates key extraction based on the Gerrit's new URL schema. * It shows, that we can extract a proper sharding key using a single RE2-based regular 
 // - GWT UI Calls // Note that # will not be sent to the server. 
<|del|> 
 public static void storeMyChangeTableColumns(VersionedAccountPreferences prefs, List<String> changeTable) { 
<|del|> 
<|del|> 
import com.google.gerrit.server.CommentsUtil; import com.google.gerrit.server.IdentifiedUser; 
Copyright (C) 2016 The Android Open Source Project 
 static ElasticNodeInfo startElasticsearchNode() throws InterruptedException, ExecutionException { 
 "Seems that port is not included in Elasticsearch http_address"); 
 "Seems that port is not included in Elasticsearch http_address"); 
import java.util.HashMap; 
<|del|> 
 private final SecretKey key; 
<|del|> 
 String now = DATE_TIME.print(now()); if (now.compareTo(dateTime) > 0) { 
package org.eclipse.jgit.lfs.server.fs; // TODO move file back to com.googlesource.gerrit.plugin.lfs.fs package when // https://git.eclipse.org/r/#/c/84933/ is picked up by gerrit 
 ds.setValidationQuery(dst.getValidationQuery()); ds.setValidationQueryTimeout(5); 
 "Unsupported field type: " + fieldType.getName()); 
 (long) configFactory 
 throw new AuthException("not allowed to index account"); 
Copyright (C) 2016 The Android Open Source Project 
 * Allows to modify the commit message for new commits generated by Rebase * Always submit strategy. 
 * Allows to modify the commit message for new commits generated by Rebase * Always submit strategy. 
 String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination); 
<|del|> 
<|del|> 
 final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount(); 
 if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) { 
<|del|> 
 // Look for changes associated with the commit. 
 return fs.contains(ID.getName()) ? fs 
 * @param original the commit of the change being submitted. <b>Note that its * commit message may be different than newCommitMessage argument.</b> 
 * @param original the commit of the change being submitted. <b>Note that its * commit message may be different than newCommitMessage argument.</b> 
 * mergeTip and original commit are guaranteed to have their body parsed, 
 * @param destination the branch onto which the change is being submitted 
 * @param destination the branch onto which the change is being submitted 
 Provider<ReviewDb> db, IdentifiedUser.GenericFactory identifiedUserFactory, @CanonicalWebUrl @Nullable Provider<String> urlProvider, ApprovalsUtil approvalsUtil, PluggableCommitMessageGenerator commitMessageGenerator, @Assisted ProjectState project) { 
 @Option(name = "--continue", required = false, usage = "Display failures and continue to reindex remaining changes") 
package com.google.gerrit.reviewdb.client; 
<|del|>
package com.google.gerrit.server.project; 
<|del|> 
package com.google.gerrit.server.project; 
Copyright (C) 2014 The Android Open Source Project 
 private final TagInfo tagInfo; 
<|del|> 
 "refs/tags/test-1", "refs/tags/test-2", "refs/tags/test-3"); 
 DeleteTagsInput input = new DeleteTagsInput(); 
 DeleteTagsInput input = new DeleteTagsInput(); 
// limitations under the License. 
 } 
 String revision = change.currentRevision; 
 /** * Updates downstream votes for a change each time a comment is made. * @param event Event we are listening to. */ 
 if (downstreamBranches.isEmpty()) { log.debug("Downstream branches of {} on {} are empty", change.branch, change.project); return; } 
 logDebug("One-off insertion of patch set for {}", refName); replace.insertPatchSetWithoutBatchUpdate(); replace.inputCommand.setResult(OK); } catch (IOException | UpdateException | RestApiException err) { 
 public void customCommitFooters() throws Exception { 
 public List<Block> quotedBlocks; // For the contents of quote blocks. 
 tag = new Tag.NameKey(project, "refs/tags/test"); 
 * @return HTTP 200 on success. 
 * * @param resource RevisionResource of the change whose page the button is on. 
 * Swap out the current config for a new, up to date config. * 
 for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) { updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue()); 
<|del|> 
 * @return Description object that contains the right labels, visibility, etc. 
 private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException { 
 * Display all conflicts for a change. Truncate at MAX_CONFLICT_MESSAGE_LENGTH. * 
class LimitedByteArrayOutputStream extends ByteArrayOutputStream { 
<|del|> 
<|del|> 
 public <T extends Closeable> void putEntry(T out, String path, byte[] data) throws IOException { 
 public <T extends Closeable> void putEntry(T out, String path, byte[] data) throws IOException { 
Copyright (C) 2016 The Android Open Source Project 
 private void assertTags(List<String> expected) throws Exception { 
<|del|> 
 public byte[] toByteArray() { 
 checkArgument(initial <= max); 
<|del|> 
<|del|> 
<|del|> 
 throw new LimitExceededException(); 
 public void write(int b) throws IOException{ 
 final List<String> untarredFiles = new LinkedList<>(); 
 public <T extends Closeable> void putEntry(T out, String path, byte[] data) throws IOException { 
 "Output size exceeds maximum of LimitedByteArrayOutputStream"; 
 maxSize = max; if (initial > max) { throw new RuntimeException(); } 
 checkOversize(1); 
 String tag = RefUtil.validateTagRef(input.tags); 
<|del|> 
 DeleteTagCommand deleteTag = git.tagDelete().setTags(tag); for (String tags : input.tags) { 
 DeleteTagCommand deleteTag = git.tagDelete().setTags(tag); for (String tags : input.tags) { 
 RefUpdate update = r.updateRef(tags); 
 postDeletion(resource, command); 
 if (in.notify.compareTo(NotifyHandling.NONE) > 0 || !accountsToNotify.isEmpty()) { email .create( in.notify, accountsToNotify, notes, ps, user, message, comments, in.message, labelDelta) .sendAsync(); 
 } else if (projectControl .controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref) 
<|del|> 
 throw new AuthException(String.format( "label required to post review on behalf of \"%s\"", in.onBehalfOf)); 
Copyright (C) 2016 The Android Open Source Project 
 private void toAnchor(String href, String name) { Anchor a = new Anchor(); a.setHref(href); a.setText(name); webLinkPanel.add(a); } private void setParents(String project, JsArray<CommitInfo> commits) { 
 private FixSuggestion createFixSuggestionFromInput(FixSuggestionInfo fixSuggestionInfo) { List<FixReplacement> fixReplacements = toFixReplacements(fixSuggestionInfo.replacements); String fixId = ChangeUtil.messageUuid(); return new FixSuggestion(fixId, fixSuggestionInfo.description, fixReplacements); 
 private Map<String, Comment> patchSetDrafts(ChangeContext ctx) throws OrmException { 
 public void retrievingRobotCommentsBeforeAddingAnyDoesNotRaiseAnException() throws Exception { 
 * @return List of MailComments parsed from the html part of the email. 
public class GenericHtmlParserTest extends HtmlParserTest { @Override 
<|del|> 
<|del|> 
 private String createChangeWithReview() throws Exception { 
 Account.Id account = accounts.iterator().next(); if (!accountCache.get(account).getAccount().isActive()) { log.warn("Mail: Account {} is inactive. Will delete message.", account); return; } 
 log.warn("Could not parse any comments from {}. Will delete message.", message.id()); 
 changeMsg += "\n\n" + numComments(parsedComments.size()); 
 changeMsg += "\n\n" + numComments(parsedComments.size()); 
 CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment); 
<|del|> 
 Pop3MailReceiver(EmailSettings mailSettings, MailProcessor mailProcessor, 
<|del|> 
 Collection<AccountGroup.UUID> subgroupsOf(AccountGroup.UUID group); 
 // The ListSubjectFactory always returns ListSubjects. // -> Casting is appropriate. 
 // The constructor only accepts lists. // -> Casting is appropriate. @SuppressWarnings("unchecked") 
 public S onlyElement() { 
 // This object is returned which is of type ListSubject. // -> Casting is appropriate. 
 // The constructor of ListSubject only accepts lists. // -> Casting is appropriate. 
 public FixReplacementInfoSubject onlyReplacement() { return replacements().onlyElement(); 
 public FixSuggestionInfoSubject onlyFixSuggestion() { return fixSuggestions().onlyElement(); 
 if (in.notify.compareTo(NotifyHandling.NONE) > 0 || !accountsToNotify.isEmpty()) { email .create( in.notify, accountsToNotify, notes, ps, user, message, comments, in.message, labelDelta) .sendAsync(); 
 } else if (isCommentUrl(line, changeUrl, perspectiveComment)) { 
 public void SERVER_FullyConfiguredUser() { 
 public void USER_FullyConfiguredUser() { 
 // We are in an asynchronously called listener, so there is no user action // to give feedback to. We log the error, but it would be nice if we could surface // these logs somewhere. 
<|del|> 
<|del|> 
 new String(CONTENT_NEW2, UTF_8)); 
Copyright (C) 2016 The Android Open Source Project 
 public static String normalizeTagRef(String tag) throws BadRequestException { 
 name = "supermanifest", 
public class SuperManifestIT extends LightweightPluginDaemonTest { 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
 return Objects.hash(destRepoKey, destBranch); 
<|del|> 
 private static ConfigEntry newConfigEntry(Config cfg, String name) throws ConfigInvalidException { 
 if (!Repository.isValidRefName(REFS_HEADS + destBranch)) { throw new ConfigInvalidException(String.format("destination branch '%s' invalid", destBranch)); } 
<|del|> 
 html.openElement("a") .setAttribute("style", "color: inherit") .setAttribute("href", "#" + PageLinks.toAccountQuery(name, Change.Status.NEW)) .append(name).closeElement("a"); 
 html.openElement("a") .setAttribute("style", "color: inherit") .setAttribute("href", "#" + PageLinks.toAccountQuery(name, Change.Status.NEW)) .append(name).closeElement("a"); 
<|del|> 
<|del|> 
<|del|> 
 builder.append("revId=").append(revId != null ? revId.get() : "") .append(','); builder.append("tag=").append(Objects.toString(tag, "")).append(','); builder.append("unresolved=").append(unresolved); 
 sendForm(req, res, "Invalid username or password."); 
 throw new InvalidTransactionException(); 
<|del|> 
<|del|> 
 } } catch (IllegalArgumentException e) { String error = "Issue:" + issueId + " could not be updated"; log.error(error); 
 } } catch (IllegalArgumentException e) { String error = "Issue:" + issueId + " could not be updated"; log.error(error); 
 private String sanitizeStrIssueId(String issueId) throws IllegalArgumentException { Matcher m = issuePattern.matcher(issueId); if (m.find()) { return m.group(); } else{ throw new IllegalArgumentException(issueId); } 
 /** * Throw a IOException unless function.call can return normally */ 
 /** * Throw a IOException unless function.call can return normally */ 
 bind(ItsFacade.class).to(RedmineFacade.class).asEagerSingleton(); 
 Set<RevCommit> alreadyAccepted, RevFlag canMergeFlag, InternalChangeQuery internalChangeQuery) { 
 .append("unresolved=").append(unresolved) 
 unresolved = parseBooleanField(note, curr, changeId, UNRESOLVED); 
 return parse(id, true); 
 * the calling user 
<|del|>
 config = new LoadedConfig(); 
 Map<String, Object> fromBranchConfig = getBranches().get(fromBranch); 
<|del|> 
 e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message, c.unresolved, parent); 
 if (v.intValue() == approved || val.equals("+2")) { 
 if (v.intValue() == approved || val.equals("+2")) { 
 reviewers = suggestReviewers(changeId, "first"); assertThat(reviewers).hasSize(3); 
 if (visibilityControl.isVisibleTo(id)) { 
 protected void allow(Project.NameKey projectName, String permission, AccountGroup.UUID id, String ref) throws Exception { 
<|del|> 
<|del|> 
 allow(allProjects, "read", ANONYMOUS_USERS, "refs/*"); 
 allow(allProjects, "read", ANONYMOUS_USERS, "refs/*"); 
 remove(allProjects, "read", ANONYMOUS_USERS, "refs/*"); 
 SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException { 
 private static class GerritIncludeReader implements ManifestParser.IncludedFileReader { 
 RefNotFoundException e = new RefNotFoundException(String.format("cannot open %s to read %s", repoName, refName)); 
<|del|> 
<|del|> 
 if (Strings.isNullOrEmpty(expiresAt)) { log.warn("expiresAt not defined, not message will be shown"); 
 log.warn("Interrupted while waiting for project cache to load"); 
 protected void beforeTest(Description description) throws Exception { this.description = description; 
 plugin.stop(env); env.onStopPlugin(plugin); 
 value = value.toUpperCase(); 
 public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message, @Nullable Boolean unresolved, @Nullable String parentUuid) throws OrmException, UnprocessableEntityException { 
 return codec.decode(input); 
 return codec.encode(input); 
<|del|> 
 private GitRepositoryManager gitRepoManager; 
 db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "content") 
 void delete(DeleteCommentInput deleteReason) throws RestApiException; 
 deleteComment.apply(comment, deleteReason); } catch (IOException | ConfigInvalidException | OrmException e) { throw new RestApiException("Cannot delete comment", e); 
 deleteComment.apply(comment, deleteReason); } catch (IOException | ConfigInvalidException | OrmException e) { throw new RestApiException("Cannot delete comment", e); 
import com.google.gerrit.extensions.api.changes.DeleteCommentInput; import com.google.gerrit.extensions.restapi.AuthException; import com.google.gerrit.extensions.restapi.ResourceNotFoundException; 
import java.io.IOException; import java.util.Collections; public class DeleteComment implements RestModifyView<CommentResource, DeleteCommentInput> { private final ChangeCommentUpdate.Factory commentUpdateFactory; 
 public Response<?> apply(CommentResource rsrc, DeleteCommentInput input) throws RestApiException, IOException, ConfigInvalidException, OrmException{ 
<|del|> 
 .from(sec.getStringList(section, subsection, name)) .transform(codec::decode) .toArray(String.class); 
 RestResponse r = adminRestSession.getOK("/config/server/caches/project_list"); 
 private final LoadingCache<AllKey, 
 extIdsByAccount.put(AllKey.ALL, ImmutableMultimap.copyOf(n)); 
 private AllKey() { 
 externalIdCache.onUpdate(id); 
 onLineTooLong(id, messages, "commit subject >" + this.maxSubjectLength + " characters; use shorter first paragraph"); 
 + this.maxLineLength + " characters; manually wrap lines"); 
<|del|> 
 ExternalIdsUpdate.User externalIdsUpdateFactory) { 
 private final ExternalIdsUpdate.User externalIdsUpdateFactory; 
 ExternalId.createWithEmail(scheme, id, user.getAccountId(), email)); 
 private final ExternalIdsUpdate.User externalIdsUpdateFactory; 
 Account account; 
 private final PersonIdent committerIdent; 
 * <p>If the external ID already exists, it is overwritten, otherwise it is inserted. 
 void close(); 
 static class AllKey { static final AllKey ALL = new AllKey(); 
 int bodyLineCnt = nonEmptyCnt - (commit.getFooterLines().size() + subjectLineCnt); 
 onNoMessageBody(id, messages, "Commit message is missing a body"); 
 public RevisionReviewerApi reviewer(String id) throws RestApiException { 
 throw new MethodNotAllowedException( "Cannot delete vote on non-current patch set"); 
 throw new MethodNotAllowedException( "Cannot delete vote on non-current patch set"); 
 throw new MethodNotAllowedException( "Cannot delete vote on non-current patch set"); 
<|del|> 
<|del|> 
<|del|> 
 @Ignore 
 @Mock private PluginConfigFactory cfgFactoryMock; @Mock private PluginConfig configMock; 
 @Mock private PluginConfigFactory cfgFactoryMock; @Mock private PluginConfig configMock; 
 @Mock private WorkQueue.Executor executorMock; 
 @Mock private HttpServletRequest request; @Mock private HttpServletResponse response; @Mock private BufferedReader reader; @Mock private DynamicMap<Cache<?, ?>> cacheMap; 
 @Mock private Configuration config; 
 return getNameParts(name, Collections.emptySet()); 
 private SiteIndexer.Result reindexGroups(GroupIndex index, 
 verboseWriter.println("Reindexed " + desc); 
 public void replace(AccountGroup group) throws IOException { 
 // document (of which there shouldn't be any). 
 private boolean hasQuery2; 
 // The --query2 option is defined in QueryGroups this.hasQuery2 = params.containsKey("query2"); 
 @Singleton 
<|del|> 
 throws OrmException, ResourceNotFoundException, AuthException, MethodNotAllowedException { if (!rsrc.isCurrent()) { throw new MethodNotAllowedException( "Cannot access on non-current patch set"); } 
 throws ResourceNotFoundException, OrmException, AuthException, MethodNotAllowedException { if (!reviewer.getRevisionResource().isCurrent()) { throw new MethodNotAllowedException( "Cannot access on non-current patch set"); } 
 stdout.print(auth.authenticate(user, args)); 
 * Query groups. 
 * Execute query and returns the matched groups as list. 
 JestResult result = client.execute(bulk); 
<|del|> 
 String content; // TODO(davido): Consider using JGit's FileSnapshot to cache based on // mtime. 
Copyright (C) 2017 The Android Open Source Project 
 s, null, "primaryStorageMigrationTimeout", 
<|del|> 
 Stopwatch sw = Stopwatch.createStarted(); 
<|del|> 
 public ProjectTagsScreen(Project.NameKey toShow) { 
 public void onClick(ClickEvent event) { 
<|del|> 
 table.setText(row, 3, k.revision()); 
<|del|> 
 List<AccountExternalId.Key> extIdKeysToRemove = toRemove.stream().map(fp -> toExtIdKey(fp.get())).collect(toList()); 
<|del|> 
<|del|> 
 ImmutableSetMultimap<Account.Id, AccountExternalId>> extIdsByAccount; 
 ImmutableSetMultimap<Account.Id, AccountExternalId>> extIdsByAccount; 
 return new SiteIndexer.Result(sw, false, 0, 0); 
 this.auth = auth; this.user = user; 
 public void starChange(String id) throws RestApiException { 
<|del|> 
 private LfsFsRequestAuthorizer auth = new LfsFsRequestAuthorizer(); 
 assertThat(auth.onTime(DATE_TIME.print(now.plusSeconds(1)), "o", "id")) 
<|del|> 
 private String section; private String key; 
 * @param <P> type of the parent resource. 
 * @param <P> type of the parent resource. For a top level collection this should always be {@link 
 LfsSshAuth(@CanonicalWebUrl Provider<String> canonicalWebUrl) { this.canonicalWebUrl = canonicalWebUrl.get(); 
 throws UnloggedFailure, Failure { 
 if (isActive(cfg) && validatorConfig.isEnabledForRef( 
 if (isActive(cfg) && validatorConfig.isEnabledForRef( 
 private static final String ENV_VAR = "GERRIT_NOTEDB"; private static final String SYS_PROP = "gerrit.notedb"; 
 private static final String ENV_VAR = "GERRIT_USE_SSH"; private static final String SYS_PROP = "gerrit.use.ssh"; 
 // generate already expired token String token = auth.generateToken("o", zeroId(), -1); 
 ImmutableSetMultimap<Account.Id, AccountExternalId>> extIdsByAccount; 
 monitor.update(1); 
<|del|> 
<|del|> 
 * Parses an external ID key from a string in the format "scheme:id". * * @return the parsed external ID key, {@code null} if the given external Id has an invalid * format. 
 public static Set<AccountExternalId.Key> toAccountExternalIdKeys( 
 Hashing.sha1().newHasher().putString(toString(), UTF_8).hash().toString()); 
 * <p>This string representation is used as subsection name in the Git config file that stores * the external ID. 
 private static ConfigInvalidException invalidConfig(String noteId, String message) { return new ConfigInvalidException( String.format("Invalid external id config for note %s: %s", noteId, message)); 
 public static Set<ExternalId> from(Collection<AccountExternalId> externalIds) { if (externalIds == null) { return ImmutableSet.of(); } return externalIds.stream().map(ExternalId::from).collect(toSet()); 
 * Exports this external ID as Git config file text. 
 String externalIdKey = key().get(); externalIdConfig.setInt(EXTERNAL_ID_SECTION, externalIdKey, ACCOUNT_ID_KEY, accountId().get()); 
 private final Set<ExternalId> toAdd = new HashSet<>(); private final Set<ExternalId> toDelete = new HashSet<>(); 
 /** * Adds an external ID replacement to the batch. * * <p>The actual replacement is only done when {@link #commit(ReviewDb, String)} is invoked. */ 
 private ExternalIdsUpdate( GitRepositoryManager repoManager, 
 public synchronized void replace( ReviewDb db, Account.Id accountId, Collection<ExternalId.Key> toDelete, Collection<ExternalId> toAdd) throws IOException, ConfigInvalidException, OrmException { 
 passwordSection.passwordForKey("Enter password", key); 
 passwordSection.passwordForKey("Enter password", key); 
 LfsSshAuth(@CanonicalWebUrl Provider<String> canonicalWebUrl) { this.canonicalWebUrl = canonicalWebUrl.get(); 
 throws UnloggedFailure, Failure { 
 throws UnloggedFailure, Failure { 
 throws UnloggedFailure, Failure; 
 public ValidatorConfig(@PluginName String pluginName, ProjectCache projectCache, 
 public boolean isEnabledForRef(Project.NameKey projectName, String refName) { ProjectState projectState = projectCache.get(projectName); 
 public boolean isEnabledForRef(Project.NameKey projectName, String refName) { ProjectState projectState = projectCache.get(projectName); 
 if (isEnabledForRef(parentState, refName)) { 
import com.google.gwt.core.client.JavaScriptObject; import com.google.gwt.core.client.JsArray; 
import com.google.gwt.core.client.JavaScriptObject; import com.google.gwt.core.client.JsArray; 
import com.google.gerrit.extensions.webui.WebUiPlugin; import com.google.gerrit.reviewdb.client.Account; import com.google.gerrit.reviewdb.client.AuthType; 
import com.google.gerrit.extensions.webui.WebUiPlugin; import com.google.gerrit.reviewdb.client.Account; import com.google.gerrit.reviewdb.client.AuthType; 
 PushOneCommit.Result changeBResult = pushFactory .create(db, admin.getIdent(), testRepo, "change b", parent2FileName, "Content of b") .to("refs/for/" + branchBName); 
public class AccountExternalIdInfo implements Comparable<AccountExternalIdInfo> { 
 info.canDelete = (last != null) && (!last.get().equals(info.identity)); 
<|del|> 
<|del|> 
 if (refPatterns.length == 0) { 
 if (refPatterns.length == 0) { 
 public ValidatorConfig(@PluginName String pluginName, ProjectCache projectCache, 
 public boolean isEnabledForRef(Project.NameKey projectName, String refName) { ProjectState projectState = projectCache.get(projectName); 
 public boolean isEnabledForRef(Project.NameKey projectName, String refName) { ProjectState projectState = projectCache.get(projectName); 
 if (isEnabledForRef(parentState, refName)) { 
 return false; // Branch-specific behavior: ref is not matching 
<|del|> 
 return false; 
<|del|> 
<|del|> 
<|del|> 
 private static Boolean toBoolean(boolean v) { return v ? v : null; 
 * @param <P> type of the parent resource. For a top level collection this should always be {@link 
 * @param <P> type of the parent resource. For a top level collection this should always be {@link 
<|del|> 
 return false; 
 private static boolean match(String refName, String refPattern) { 
<|del|> 
 return isEnabledForRef(projectState, refName); 
 private PropertyKey<ExternalId.Key> lastLoginExternalIdPropertyKey = PropertyKey.create(); 
 private PropertyKey<ExternalId.Key> lastLoginExternalIdPropertyKey = PropertyKey.create(); 
 private CapabilityControl capabilities; private PropertyKey<AccountExternalId.Key> lastLoginExternalIdPropertyKey = PropertyKey.create();; protected CurrentUser(CapabilityControl.Factory capabilityControlFactory) { this.capabilityControlFactory = capabilityControlFactory; } 
 private ListMultimap<String, ?> extractParams(Audit note, GerritCall call) { 
 lfsPluginAuthModule = module; 
 lfsPluginAuthModule = module; 
 public String authenticate(CurrentUser user, List<String> args) 
 public List<DirCacheEditor.PathEdit> getPathEdits(Repository repository) { 
 public List<DirCacheEditor.PathEdit> getPathEdits(Repository repository) { 
 amendChange(admin.getIdent(), changeId); change = getChange(changeId); 
 public Optional<EditInfo> get() { 
 public ChangeEditApiImpl(ChangeEdits.Detail editDetail, 
 throw new RestApiException("Cannot get commit message of change edit", e); 
 // if it doesn't exist. We try to mimic this behavior. 
 ChangeApi changeApi = gApi.changes().id(r.getChangeId()); BinaryResult bin = changeApi.revision(r.getCommit().name()).patch(FILE_NAME); 
 gApi.changes().id(id.get()).current().draft(di.id).delete(); 
 CommentInfo update(DraftInput in) throws RestApiException; void delete() throws RestApiException; 
 private final CurrentUser user; private final Repository repo; private final Change change; private final String metaRefStr; 
 private final CurrentUser user; private final Repository repo; private final Change change; private final String metaRefStr; 
 private final CurrentUser user; private final Repository repo; private final Change change; private final String metaRefStr; 
 this.metaRefStr = RefNames.changeMetaRef(change.getId()); 
<|del|> 
 // return at the parent commit of the target comment return commitDataList; 
 return new ArrayList<>(); 
 Set<RevId> updatedRevs = new HashSet<>(rnm.revisionNotes.size()); 
<|del|> 
<|del|> 
 public List<DirCacheEditor.PathEdit> getPathEdits(Repository repository) { 
 private final RevTree baseTree; // At the moment, a list wouldn't be necessary as only one modification is // applied per created tree. This is going to change in the near future. 
 return writeAndGetId(repository, newTree); 
 List<DirCacheEditor.PathEdit> pathEdits = getPathEdits(repository); 
 private List<DirCacheEditor.PathEdit> getPathEdits(Repository repository) throws IOException { 
 pathEdits.addAll(treeModification.getPathEdits(repository)); 
 private static void applyPathEdits(DirCache tree, 
 private static ObjectId writeAndGetId(Repository repository, DirCache tree) 
 private static ObjectId writeAndGetId(Repository repository, DirCache tree) 
 * Publishes the change edit using default settings. See 
 return fileResponse.isNone() ? Optional.empty() 
 // if it doesn't exist. We mimic this behavior here. 
 // if it doesn't exist. We mimic this behavior here. 
 // if it doesn't exist. We mimic this behavior here. 
 List<AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); 
 throws IntegrationException, IOException { args.onSubmitValidatorsFactory.create().validateBranchUpdate( new OnSubmitValidationListener.Arguments(ctx.getProject(), ctx.getRepository(), getDest(), currentTip, newTip, ctx.getRevWalk())); 
 newTip, ctx.getInserter())); 
<|del|> 
 private final RevTree baseTree; // At the moment, a list wouldn't be necessary as only one modification is // applied per created tree. This is going to change in the near future. 
 private final RevTree baseTree; // At the moment, a list wouldn't be necessary as only one modification is // applied per created tree. This is going to change in the near future. 
 private static void applyPathEdits(DirCache tree, 
import static com.google.gerrit.server.index.SchemaUtil.getNameParts; import static com.google.gerrit.server.index.SchemaUtil.getPersonParts; 
 if (!(user instanceof IdentifiedUser)) { 
 if (!(user instanceof IdentifiedUser)) { 
 if (!(user instanceof IdentifiedUser)) { 
 if (!(user instanceof IdentifiedUser)) { 
 private void deleteVote(boolean onRevisionLevel) throws Exception { 
 private Iterable<Account.Id> getReviewers(Collection<AccountInfo> r) { 
 public Arguments(NameKey project, Repository repository, ObjectReader objectReader, Map<String, ReceiveCommand> commands) { 
 try (RevWalk rw = args.newRevWalk()) { 
 public RevWalk newRevWalk() { return new RevWalk(objectReader); 
 public RevWalk newRevWalk() { return new RevWalk(objectReader); 
 * Called right before branch is updated with new commit or commits as a * result of submit. 
 ObjectReader objectReader, Map<String, ReceiveCommand> commands) throws IntegrationException { 
 Arguments args = new Arguments(project, repo, objectReader, refName, cmd.getOldId(), cmd.getNewId()); 
 Arguments args = new Arguments(project, repo, objectReader, refName, cmd.getOldId(), cmd.getNewId()); 
 newTip, ctx.getInserter())); 
import static com.google.gerrit.server.index.SchemaUtil.getNameParts; import static com.google.gerrit.server.index.SchemaUtil.getPersonParts; 
 if (!self.get().isIdentifiedUser()) { 
 if (!self.get().isIdentifiedUser()) { 
 if (!self.get().isIdentifiedUser()) { 
 if (!self.get().isIdentifiedUser()) { 
<|del|> 
 BatchUpdate create(ReviewDb db, Project.NameKey project, CurrentUser user, Timestamp when); 
 if (onSubmitValidators != null && commands != null && !commands.isEmpty()) { 
 public static final String FIELD_UNRESOLVED_COMMENTS_NUM = "unresolvednum"; 
 } private ValidatorConfig getConfig(String defaultConfig) throws ConfigInvalidException { ValidatorConfig config = new ValidatorConfig(new FakeConfigFactory(projectName, defaultConfig)); return config; } 
 } private ValidatorConfig getConfig(String defaultConfig) throws ConfigInvalidException { ValidatorConfig config = new ValidatorConfig(new FakeConfigFactory(projectName, defaultConfig)); return config; } 
 } private ValidatorConfig getConfig(String defaultConfig) throws ConfigInvalidException { ValidatorConfig config = new ValidatorConfig(new FakeConfigFactory(projectName, defaultConfig)); return config; } 
 .isTrue(); 
 .isTrue(); 
 this.configFactory = configFactory; 
Copyright (C) 2017 The Android Open Source Project 
Copyright (C) 2017 The Android Open Source Project 
<|del|> 
<|del|> 
 public Token generateToken(int expirationSeconds, String...params) { 
 public Token generateToken(int expirationSeconds, String...params) { 
 public Token generateToken(int expirationSeconds, String...params) { 
 public Token generateToken(int expirationSeconds, String...params) { 
 private static final String ALGORITHM = "AES"; private static final int KEY_SIZE = 128; 
 private static final String ALGORITHM = "AES"; private static final int KEY_SIZE = 128; 
 private final SecureRandom random; 
 private final SecureRandom random; 
 timeout(expirationSeconds)).getBytes(UTF_8)))); 
 timeout(expirationSeconds)).getBytes(UTF_8)))); 
 generator.init(KEY_SIZE, random); 
 generator.init(KEY_SIZE, random); 
 + url.getPath() + "/" + args.get(0) + "/info/lfs"; 
 + url.getPath() + "/" + args.get(0) + "/info/lfs"; 
import org.eclipse.jgit.lfs.server.LfsGerritProtocolServlet; import org.eclipse.jgit.lfs.server.LfsObject; 
 import javax.servlet.Filter; 
 import javax.servlet.Filter; 
 import javax.servlet.Filter; 
 AuthInfo(String authToken, DateTime expiresAt) { this.authToken = authToken; 
 AuthInfo(String authToken, DateTime expiresAt) { this.authToken = authToken; 
<|del|> 
 TestAccount u11_at = accounts.create("u11@something", "u11@example.com", "Full Name 11 With At"); TestAccount u11 = accounts.create("u11", "u11.another@example.com", "Full Name 11 Without At"); 
 AuthInfo(String authToken, DateTime expiresAt) { this.authToken = authToken; 
 AuthInfo(String authToken, DateTime expiresAt) { this.authToken = authToken; 
 && schema.accountMemberExpandGroups) { 
 LdapRealm.optional(config, "accountMemberExpandGroups", type.accountMemberExpandGroups()); 
 LdapRealm.optional(config, "accountMemberExpandGroups", type.accountMemberExpandGroups()); 
<|del|> 
 /** Is this user active */ 
/** Add status field to account. */ 
 PRIMARY_STORAGE.toLowerCase(), READ.toLowerCase(), WRITE.toLowerCase(), SEQUENCE.toLowerCase(), PRIMARY_STORAGE.toLowerCase()); 
 if (isActive(cfg) && validatorConfig.isEnabledForRef( 
 if (match(refName, refPattern)) { 
 if (match(refName, refPattern)) { 
 if (match(refName, refPattern)) { 
 if (match(refName, refPattern)) { 
 if (match(refName, refPattern)) { 
 if (match(refName, refPattern)) { 
 if (match(refName, refPattern)) { 
 if (match(refName, refPattern)) { 
 if (match(refName, refPattern)) { 
 String[] refPatterns = pluginConfig.getStringList("ref"); 
 String[] refPatterns = pluginConfig.getStringList("ref"); 
 if (RefConfigSection.isValid(refPattern) && match(refName, refPattern)) { 
 return valid; 
 private boolean matchCriteria(PluginConfig config, String criteria, 
 private boolean matchCriteria(PluginConfig config, String criteria, 
<|del|> 
 h.putString(commitId.name(), UTF_8); 
 * @return {@code true}, if Gerrit should discard the message, {@code false} otherwise. 
 * @return {@code true}, if Gerrit should discard the message, {@code false} otherwise. 
 * @return {@code true}, if Gerrit should process the message, {@code false} * otherwise. 
<|del|> 
<|del|> 
 // if we allow users to resolve a robot comment, then this test should 
 unresolvedCommentsNum = num.intValue(); 
<|del|> 
<|del|> 
 get(ACCOUNT_KIND, "external.ids").to(GetExternalIds.class); 
 get(ACCOUNT_KIND, "external.ids").to(GetExternalIds.class); 
 || !canSkipValidation(conf, validatorOp) || !canSkipRef(conf, refName) || !canSkipGroup(conf)); 
 || !canSkipValidation(conf, validatorOp) || !canSkipRef(conf, refName) || !canSkipGroup(conf)); 
 || !canSkipValidation(conf, validatorOp) || !canSkipRef(conf, refName) || !canSkipGroup(conf)); 
 private boolean matchCriteria(PluginConfig config, String criteria, 
 private boolean matchCriteria(PluginConfig config, String criteria, 
 private boolean matchCriteria(PluginConfig config, String criteria, 
 import javax.servlet.Filter; 
<|del|> 
 public AuthInfo generateAuthInfo(int expirationSeconds, Token input) { 
 public AuthInfo generateAuthInfo(int expirationSeconds, Token input) { 
<|del|> 
<|del|> 
 DateTime now = nowRoundedTo1s(); // test that even 1ms expiration is enough assertThat(auth.onTime(DATE_TIME.print(now.minusMillis(1)), "s")) 
 DateTime now = nowRoundedTo1s(); // test that even 1ms expiration is enough assertThat(auth.onTime(DATE_TIME.print(now.minusMillis(1)), "s")) 
 public void modifyMessage(Repository repository, String newCommitMessage, ChangeEdit changeEdit) throws AuthException, IOException, 
 if (content == null) { return null; 
 // TODO(aliceks): Consider the following: 
 // TODO(aliceks): Consider the following: 
 // TODO(aliceks): Consider the following: 
 // TODO(aliceks): Consider the following: 
 // TODO(aliceks): Consider the following: 
 private static boolean isRestoreFile(Input input) { 
 private static boolean isRenameFile(Input input) { 
 return editBasePatchSet.isPresent() ? editBasePatchSet.get() 
 public void delete(DeleteCommentInput input) { 
 throw new AuthException("not allowed to delete comment"); 
 PatchLineComment patchLineComment = db.patchComments().get(key); 
 if (notesMigration.writeChanges()) { Project.NameKey projectKey = rsrc.getRevisionResource().getProject(); 
 indexer.index(db, change); 
<|del|> 
 boolean removeAllData) throws IOException, ConfigInvalidException, 
<|del|> 
 cb.setCommitter(committer); cb.setMessage(message); 
 public static class ChangeNotesCommitData { public ChangeNotesCommit commit; public Map<String, Comment> commentsMap; 
 String externalIdStr = "username:" + user.username; toDelete.add(externalIdStr); 
 String externalIdStr = "username:" + user.username; toDelete.add(externalIdStr); 
 response.assertConflict(); assertThat(response.getEntityContent()).isEqualTo( String.format("External id %s cannot be deleted", externalIdStr)); 
 response.assertUnprocessableEntity(); assertThat(response.getEntityContent()).isEqualTo( String.format("External id %s does not exist", externalIdStr)); 
 response.assertNoContent(); 
 List<AccountExternalIdInfo> externalIds = gApi.accounts().self().getExternalIds(); 
 toDelete.add(id); } else { throw new ResourceConflictException(String.format( "External id %s cannot be deleted", externalIdStr)); 
 && (activeForRef(conf, refName)) 
 && (activeForRef(conf, refName)) 
 && (activeForRef(conf, refName)) 
 private boolean activeForRef(PluginConfig config, String ref) { 
 private boolean activeForRef(PluginConfig config, String ref) { 
 return matchCriteria(config, "skipValidation", validatorOp, false); 
 return matchCriteria(config, "skipValidation", validatorOp, false); 
 RevWalk rw = testRepo.getRevWalk(); master = rw.parseCommit(getRemoteHead(project, "master")); assertThat(rw.isMergedInto(merge, master)).isTrue(); assertThat(rw.isMergedInto(fix, master)).isTrue(); 
 } // Stop RevWalk because c is either a merged commit or a missing // dependency. Not need to walk further. 
 ChangeIncludedIn(Provider<ReviewDb> db, PatchSetUtil psUtil, 
 public IncludedInInfo apply(Project.NameKey project, String revisionId) 
 Map<String, AccountGroup.UUID> byLowerCaseConfiguredName = new HashMap<>(); 
 throw new IllegalStateException(String.format( 
Copyright 2017 Android Open Source Project. 
 Column column = col.getColumnAnnotation(); StringBuilder r = new StringBuilder(); 
 /** @return GitwebType for gitweb viewer. */ @Nullable 
Copyright (C) 2017 The Android Open Source Project 
Copyright (C) 2017 The Android Open Source Project 
 throw new AuthException("not allowed to set status"); 
 return Strings.isNullOrEmpty(a.getStatus()) 
 throw new RestApiException("Cannot set status", e); 
 public AuthInfo generateToken(String operation, 
 throw new IOException("Path '" + ensured.toAbsolutePath() + "' cannot be accessed"); 
 + invalid 
 + invalid 
public class StartupChecks implements LifecycleListener { public static class Module extends LifecycleModule { @Override protected void configure() { listener().to(StartupChecks.class); } } 
 accountCache.evict(user.getAccountId()); 
 default Set<AccountExternalId> byAccount(Account.Id accountId, 
 public static class Input { @DefaultInput 
 ? Response.none() 
 a.setStatus(Strings.nullToEmpty(input.status)); 
 public String encrypt(String input) { 
 public Optional<String> decrypt(String input) { 
 .isEmpty(); 
 assertThat(getIncludedIn(result.getCommit().getId()).branches).isEmpty(); assertThat(getIncludedIn(result.getCommit().getId()).tags).isEmpty(); 
 assertThat(getIncludedIn(result.getCommit().getId()).branches).isEmpty(); assertThat(getIncludedIn(result.getCommit().getId()).tags).isEmpty(); 
 String.valueOf(changeAttribute.number))); 
 public final native boolean isTrusted() 
 public final native boolean isTrusted() 
 * Scheme used for {@link AuthType#LDAP}, * {@link AuthType#CLIENT_SSL_CERT_LDAP}, 
 * Scheme used for {@link AuthType#LDAP}, * {@link AuthType#CLIENT_SSL_CERT_LDAP}, 
 * <p>The name {@code gerrit:} was a very poor choice. 
 private static String getSchemeRest(String externalId) { 
 int colonIdx = externalId.indexOf(':'); return (colonIdx > 0) ? externalId.substring(0, colonIdx) : null; 
<|del|> 
 Collections.sort(idList); 
<|del|> 
 try { stars = changeData.stars(); } catch (OrmException e) { throw new EmailException("Failed to load stars for change " + change.getChangeId(), e); } 
 log.atSevere().withCause(e).log("Problem checking database connection"); 
 if (Strings.isNullOrEmpty(s)) { 
 String.valueOf(patchSetAttribute.number))); 
import com.google.gerrit.reviewdb.client.AccountGroup; import com.google.gerrit.reviewdb.client.AccountProjectWatch; 
import com.google.common.collect.ListMultimap; 
 import javax.servlet.Filter; 
 filterRegex(LFS_URL_REGEX).through(authFilter); filter("/a/*").through(authFilter); 
 public static abstract class Processor<T extends LfsAuthToken> { 
 Collections.sort(idList); 
 * @deprecated Use {@link EventInfo#date}. 
 public EventInfo.Type type; 
 public enum Type { 
 public enum Type { 
 return Objects.equals(id, e.id) && Objects.equals(tag, e.tag) && Objects.equals(type, e.type) && Objects.equals(date, e.date); 
import com.google.common.annotations.VisibleForTesting; import com.google.gerrit.common.Nullable; 
<|del|> 
 cfg.setStringList(l.get(0), l.get(1), l.get(2), Arrays.asList(c.values())); 
 MoreObjects.firstNonNull(plugin.getMetricsPrefix(), String.format("plugins/%s/", plugin.getName()))); 
<|del|> 
 captor = new Capture(); 
<|del|> 
<|del|> 
 } else if (idB.equals(psId)) { 
 public static abstract class Processor<T extends LfsAuthToken> { 
 public static abstract class Verifier<T extends LfsAuthToken> { 
<|del|> 
 static class Processor extends LfsAuthToken.Processor<LfsFsAuthToken> { 
 private static class Verifier extends LfsAuthToken.Verifier<LfsFsAuthToken> { 
 private class TestTokenProessor extends LfsAuthToken.Processor<TestToken> { 
 private class TestTokenVerifier extends LfsAuthToken.Verifier<TestToken> { 
<|del|> 
<|del|> 
 private static final String SCHEME_GERRIT = "gerrit:"; 
 private static final String SCHEME_MAILTO = "mailto:"; 
 private static final String SCHEME_USERNAME = "username:"; 
 } private String emailOf(final ExternalIdInfo a) { return a.emailAddress() != null ? a.emailAddress() : ""; } protected ExternalIdInfo() {} 
 Collections.sort(idList); 
<|del|> 
<|del|> 
<|del|> 
 identites.display(results); display(); 
 ChangeActions.delete(changeId, deleteChange); 
 if (cfg.getString(InitOAuth.CLIENT_ID) != null) { 
 toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE).length()); 
 metadata.messageType = extractFooter( toFooterWithDelimiter(MetadataName.MESSAGE_TYPE), line); 
<|del|> 
 ChangeCommentUpdate create(CurrentUser user, Change change); 
 ChangeCommentUpdate create(CurrentUser user, Change change); 
 @Assisted Change change) { 
 this.change = change; 
 // Redo commits. ObjectId newHeadId = redoCommitList( repo, commitDataList.get(0), commitDataList.subList(1, commitDataList.size()), target.key.uuid, newMsg); 
 private List<Comment> getUpdatedCommentList( ChangeNotesCommitData cd, Map<String, Comment> preMap, Map<String, Comment> curMap, String targetUUID, String newMsg) { 
 throw new IllegalStateException( String.format( "unexpected that comment %s was removed by commit %s", key, cd.commit.getId())); 
 bind(SystemGroupBackend.class); 
 private boolean isScheme(String scheme) { return identity() != null && identity().startsWith(scheme); 
 public final String describe() { String identity = identity(); 
<|del|> 
 * The decode method decodes a hashed password encoded with {@link #encode}. It throws * DecoderException for malformed input. 
 Preconditions.checkState(cost >= 4 && cost < 32); 
 /** The project watches of the account. */ public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() { return projectWatches; } 
 Preconditions.checkState(fields.length == 4); int cost = Integer.parseInt(fields[1]); return new HashedPassword(codec.decodeBase64(fields[3]), codec.decodeBase64(fields[2]), cost); 
 Preconditions.checkState(fields.length == 4); int cost = Integer.parseInt(fields[1]); return new HashedPassword(codec.decodeBase64(fields[3]), codec.decodeBase64(fields[2]), cost); 
 if (!who.checkPassword(req.getPassword(), username)) { // TODO(hanwen): coverage for this code path. throw new InvalidCredentialsException(); } 
 String password = Strings.repeat("1", 72); // make sure it fits in varchar(255). assertThat(HashedPassword.fromPassword(password).encode().length()).isLessThan(255); 
 if (change != null) { query.append(" cansee:").append(change._number()); 
 if (change != null) { query.append(" cansee:").append(change._number()); 
<|del|> 
<|del|> 
Copyright (C) 2017 The Android Open Source Project 
 * decodes a hashed password encoded with {@link #encode}. * * @throws DecoderException if input is malformed. 
 * decodes a hashed password encoded with {@link #encode}. * * @throws DecoderException if input is malformed. 
 throw new DecoderException("unrecognized algorithm"); 
 throw new DecoderException("want 4 fields in"); 
 int cost = 4; try { cost = Integer.parseInt(fields[1]); } catch (NumberFormatException e) { throw new DecoderException("cost parse failed"); } 
 byte[] salt = Base64.decodeBase64(fields[2]); 
 byte[] salt = Base64.decodeBase64(fields[2]); 
 return new HashedPassword(Base64.decodeBase64(fields[3]), salt, cost); 
 Preconditions.checkState(cost >= 4 && cost < 32); 
 /** @returns one-line string encoding the hash and salt. */ 
Copyright (C) 2017 The Android Open Source Project 
 // Encoded version of the hashed and salted password, to be interpreted by the // {@link HashedPassword} class. 
Copyright (C) 2017 The Android Open Source Project 
<|del|> 
<|del|> 
 * Wrapper for ReviewDb that never calls the underlying change tables. 
 throw new DecoderException("want 4 fields"); 
 byte[] salt = codec.decodeBase64(fields[2]); 
 return new HashedPassword(codec.decodeBase64(fields[3]), salt, cost); 
 /** Serialize the hashed password and its parameters for persistent storage. * * @return one-line string encoding the hash and salt. */ 
Copyright (C) 2017 The Android Open Source Project 
 String content = e.ownText().trim(); 
 this.basePath = sitePaths.data_dir.toFile(); 
<|del|> 
 this(">0"); 
 cd.reviewers(); cd.unresolvedCommentCount(); 
 commentsUtil.deleteComments(db, update, CommentsUtil.toComments(serverId, del)); commentsUtil.putComments(db, update, Status.PUBLISHED, 
 return CommentsUtil.toPatchLineComments(changeId, Status.DRAFT, draftByPatchSetAuthor); 
 private final CommentsUtil commentsUtil; 
 CommentsUtil commentsUtil, 
 public static final String DELETE_OWN_CHANGES = "deleteOwnChanges"; 
 /** @return true if this user can delete their own changes. */ public boolean canDeleteOwnChanges() { return canPerform(Permission.DELETE_OWN_CHANGES); 
 public static final String EDIT_HASHTAGS = "editHashtags"; public static final String EDIT_ASSIGNEE = "editAssignee"; 
 private final boolean now; 
 protected Integer getValueInt(ChangeData changeData) throws OrmException { return ChangeField.UNRESOLVED_COMMENT_COUNT.get(changeData, null); 
 // assert that no new change was created for the commit of the predecessor change 
 private static final SecureRandom secureRandom = new SecureRandom(); private static final Base64 codec = new Base64(-1); 
 byte[] salt = codec.decode(fields[2]); 
 return new HashedPassword(codec.decode(fields[3]), salt, cost); 
<|del|> 
 public final String configProject; public final String configProjectBranch; 
 public final String configProject; public final String configProjectBranch; 
 private ObjectId currentConfigObjectId; 
 public LoadedConfig getCurrentConfig() throws IOException, RestApiException { try { return loadedConfigCache.get(getCurrentRevision()); } catch (ExecutionException e) { throw new IOException("Failed to get automerger config from cache.", e.getCause()); 
 // Push a change to the source branch. We intentionally change the included XML file // (rather than the one mentioned in srcPath), to double check that we don't try to be too // smart about eliding nops. 
 expect(formatters.getFormatterConfig((String) anyObject(), (String) anyObject())).andReturn(cfg); 
 GeneralPreferencesInfo i = new GeneralPreferencesInfo(); 
 // Check that admin has received only plaintext content 
 // Check that admin has received both HTML and plaintext content 
 static final Schema<ChangeData> V40 = schema(V39, ChangeField.PRIVATE); 
 Change.Id changeId = new Change.Id(c.number); PatchSet.Id psId = new PatchSet.Id(changeId, p.number); 
 plcUtil.deleteComments(db, update, del); plcUtil.putComments(db, update, ups); 
 } else if (authConfig.getAuthType() == OAUTH) { 
 if (!Strings.isNullOrEmpty(hashedStr)) { 
 } catch (DecoderException e) { logger.error("DecoderException for user " + username, e); 
 if (!Strings.isNullOrEmpty(want)) { byte wantBytes[] = want.getBytes(); byte gotBytes[] = password.getBytes(); 
 int cost; 
 byte[] pwBytes = password.getBytes(StandardCharsets.UTF_8); 
 return new HashedPassword(hashPassword(password, salt, DEFAULT_COST), salt, DEFAULT_COST); 
<|del|> 
<|del|> 
 List<Comment> del = Lists.newArrayList(); List<Comment> ups = Lists.newArrayList(); 
 ups.add(e); 
 Iterables.addAll(del, drafts.values()); 
 assertQuery(q, change); assertQuery("commit:" + q, change); 
 if (configEntry.destBranch.equals("*")) { if (wildcardDestinations.contains(configEntry.destRepoKey.get())) { 
 gApi.changes().id(r3.getChangeId()).revision(r3.getCommit().name()).rebase(ri); 
 ListMultimap<ObjectId, ChangeData> allById = MultimapBuilder.hashKeys().arrayListValues().build(); 
<|del|> 
 allById.values().stream().map(cd -> cd.getId()).collect(Collectors.toSet()); Set<Change.Id> toDeleteFormIndex = Sets.difference(alreadyPresentInIndex, toReIndex); 
 allById.values().stream().map(cd -> cd.getId()).collect(Collectors.toSet()); Set<Change.Id> toDeleteFormIndex = Sets.difference(alreadyPresentInIndex, toReIndex); 
 // get matchers 
 } oracle.requestSuggestions(request, this); 
<|del|> 
 List<ChangeInfo> results = gApi.changes().query("project:{" + project.get() + "}").withStart(1).get(); assertThat(Iterables.getOnlyElement(results).changeId).isEqualTo(r1.getChangeId()); 
 private final ListMultimap<RecipientType, Account.Id> accountsToNotify; 
<|del|> 
 Timestamp until = notes.getReadOnlyUntil(); 
 public void migrateToReviewDbPrimary(Change.Id id, @Nullable Project.NameKey project) 
<|del|> 
 Optional<CommentInfo> targetCommentInfo = before .get(fileName) .stream() .filter(c -> c.message.equals("My password: abc123")) .findFirst(); 
 "Comment removed by: " + admin.username + "; Reason: " + input.reason + "."; 
 if (input == null || input.reason == null) { 
<|del|> 
 // The committer of the first commit, which puts in the target comment, will be updated. 
 RevisionNoteMap<ChangeRevisionNote> revNotesMap; try (ChangeNotesRevWalk walker = ChangeNotesCommit.newRevWalk(repo)) { 
 RevisionNoteMap<ChangeRevisionNote> revNotesMap; try (ChangeNotesRevWalk walker = ChangeNotesCommit.newRevWalk(repo)) { 
 * @param parMap the comment map of the parent commit. 
 Repository repo, String metaRefStr, ObjectId newTip, ObjectId oldTip) throws IOException { 
 Repository repo, String metaRefStr, ObjectId newTip, ObjectId oldTip) throws IOException { 
 protected final GerritApi gApi; 
 CacheBuilder.newBuilder().maximumSize(1).build(new CacheLoader<String, LoadedConfig>() { 
 ChangeInserter ins = newChange(repo, null, null, null, null); insert(ins); 
 ChangeInserter ins = newChange(repo, null, null, null, null); insert(ins); 
<|del|> 
 LabelType lt = labelTypes.byLabel(ent.getKey()); 
<|del|> 
Copyright (C) 2017 The Android Open Source Project 
Copyright (C) 2017 The Android Open Source Project 
 "zzz", "def/g", "/!xxx", "abc", Patch.MERGE_LIST, "qrx", Patch.COMMIT_MSG, 
 Arrays.sort(patches, 0, patches.length, PATCH_CMP); // Skip magic files int i = 0; for (; i < patches.length; i++) { if (!Patch.isMagic(patches[i].getNewName())) { break; } 
 for (String name : GlobalCapability.getRangeNames()) { if (want(name) && cc.canPerform(name)) { 
Copyright (C) 2017 The Android Open Source Project 
 * @return the parsed external ID key, {@code null} if the given external ID has an invalid 
 return ObjectId.fromRaw(Hashing.sha1().hashString(get(), UTF_8).asBytes()); 
 private static final int MAX_NOTE_SZ = 1 << 19; 
 private final Provider<PersonIdent> serverIdent; 
 private final Provider<PersonIdent> serverIdent; 
 repoManager, allUsersName, createPersonIdent(identifiedUser.get()), serverIdent.get()); 
 public void insert(ReviewDb db, ExternalId extId) throws IOException, ConfigInvalidException, OrmException { 
 public void insert(ReviewDb db, Collection<ExternalId> extIds) throws IOException, ConfigInvalidException, OrmException { 
 noteMap.set(noteId, dataBlob); 
 ChangeInfo info() throws RestApiException; /** Retrieve change edit when exists. */ EditInfo getEdit() throws RestApiException; 
 get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class); 
 "external id %s should be removed, but it's not matching the actual external id %s", 
 "external id %s should be removed, but it's not matching the actual external id %s", 
 PersonIdent committerIdent, PersonIdent authorIdent) 
 cb.setCommitter(committerIdent); 
 if (id.isScheme(SCHEME_MAILTO)) { 
 && tag == null && psDescription == null && !currentPatchSet && readOnlyUntil == null && isPrivate == null; 
 cache(CACHE_NAME, AllKey.class, new TypeLiteral<ImmutableSetMultimap<Account.Id, AccountExternalId>>() {}) .maximumWeight(1).loader(Loader.class); 
 public static final int MAX_NOTE_SZ = 1 << 19; 
 if (rev.equals(ObjectId.zeroId())) { return ImmutableSet.of(); } 
<|del|> 
 String tagCreationDialogTitle(); 
 Grid addGrid = new Grid(2, 2); 
 String tagName = nameTxtBox.getText().trim(); 
 String tagName = nameTxtBox.getText().trim(); 
 String rev = irevTxtBox.getText().trim(); 
 private void setHeadRevision(int row, int column, String rev) { 
 private Widget getHeadRevisionWidget(String headRevision) { 
 Map<Branch.NameKey, RevTree> actual = fetchFromBundles(request); 
 throw new RestApiException("Cannot get submit preview", e); 
 @Deprecated static final Schema<ChangeData> V39 = schema(V38); 
 private static Set<LabelPermission.WithValue> valuesOf(LabelType label) { return label .getValues() .stream() .map((v) -> new LabelPermission.WithValue(label, v)) .collect(toSet()); } 
 } public boolean testOrFalse(GlobalPermission perm) { try { return test(perm); } catch (PermissionBackendException e) { logger.warn("Cannot test " + perm + "; assuming false", e); return false; } } 
 } 
import java.io.IOException; import java.sql.Timestamp; 
 throw new AuthException("not allowed to unmark private"); 
 throw new AuthException("not allowed to mark private"); 
 /** Determines if this change is private. */ 
 public static class Slf4jLogChute implements LogChute { // Logger should be named 'velocity' for consistency with log4j config 
 LoggerFactory.getLogger(LfsSshRequestAuthorizer.class); private static final int DEFAULT_SSH_TIMEOUT = 10; static final String SSH_AUTH_PREFIX = "Ssh: "; 
 int timeout = DEFAULT_SSH_TIMEOUT; try { timeout = configFactory.getGlobalConfig().getInt("auth", 
<|del|> 
 private static final String ALGORITHM_PREFIX = "bcrypt:"; 
<|del|> 
<|del|> 
 Integer cost = Ints.tryParse(fields[1]); if (cost == null) { 
<|del|> 
<|del|> 
 byte[] pwBytes = password.getBytes(StandardCharsets.UTF_8); 
<|del|> 
 byte[] bytes = new byte[16]; 
<|del|> 
 return Arrays.equals(hashPassword(password, salt, cost), hashed); 
 List<AccountExternalId> newIds = db.accountExternalIds().all().toList(); for (AccountExternalId id : newIds) { 
 public Response.Accepted apply(ProjectResource resource, ProjectInput input) { 
 public Response.Accepted apply(ProjectResource resource, ProjectInput input) { 
 public Response.Accepted apply(ProjectResource resource, ProjectInput input) { 
<|del|> 
 if (k.canDelete()) { CheckBox sel = new CheckBox(); sel.addValueChangeHandler(updateDeleteHandler); table.setWidget(row, 1, sel); canDelete = true; } else { table.setText(row, 1, ""); } 
 private PersonIdent createPersonIdent(PersonIdent ident, IdentifiedUser user) { return user.newCommitterIdent(ident.getWhen(), ident.getTimeZone()); 
 @FunctionalInterface 
class SetPrivateOp extends BatchUpdate.Op { private final boolean isPrivate; 
 @Deprecated static final Schema<ChangeData> V39 = schema(V38); 
 void setId(String id) { 
<|del|> 
 static void markPrivate(Change.Id id, Button... buttons) { ChangeApi.markPrivate(id.get(), cs(id, buttons)); 
 table.setText(row, C_STATUS, Util.toLongString(status) + (c.isPrivate() ? " " + Util.C.isPrivate() : "")); 
<|del|> 
<|del|> 
<|del|> 
 throw new AuthException("not allowed to unmark private"); 
<|del|> 
 private boolean isPrivateVisible(ReviewDb db, ChangeData cd) throws OrmException { 
 private boolean isPrivateVisible(ReviewDb db, ChangeData cd) throws OrmException { 
<|del|> 
<|del|> 
class SetPrivateOp extends BatchUpdate.Op { private final boolean isPrivate; 
 // Push a private change. 
 // Push a private change. 
<|del|> 
 table.setText( row, C_STATUS, Util.toLongString(status) + (c.isPrivate() ? (" " + Util.C.isPrivate()) : "")); 
<|del|> 
<|del|>
 ChangeApi cApi = gApi.changes().id(change.getId().get()); 
 lsRemoteCommand.call().stream().map(Ref::getName).collect(toList()); 
 // Stop looking for a parent directory if OWNERS has "set noparent". 
 break; // stop looking through parent directory 
 // Not an error if looking for an OWNERS file // or revision info in the "refs/meta/config" branch. if (!ignoreIOException) { log.error("IOException URL: " + urlString); } 
 public ChangeInfo get(EnumSet<ListChangesOption> options) throws RestApiException { 
 if (cap.hasExplicitRange(BATCH_CHANGES_LIMIT) || cap.canAdministrateServer()) { 
 if (cap.hasExplicitRange(BATCH_CHANGES_LIMIT) || cap.canAdministrateServer()) { 
<|del|> 
 public ReviewerManager(OneOffRequestContext requestContext) { 
 .toByteArray(project)); input .draftRefs() .values() .forEach(r -> result.add(RefState.of(r).toByteArray(args.allUsers))); 
<|del|> 
<|del|> 
 public static GerritCallback<JavaScriptObject> cs(final Change.Id id, Button... draftButtons) { 
 static Predicate<ChangeData> cc(Account.Id id) { 
 throw new IOException("Action " + action + " expects exactly " 
 public ManiphestUpdate maniphestUpdate(int taskId, String comment, Iterable<String> projects, String project_action) throws ConduitException { 
 conduit.maniphestUpdate(taskId, projectPhids, PROJECT_ACTION_ADD); 
 throw new IOException("Unknown action " + action); 
 throw new IOException("Could not parse action " + actionString); 
 public ManiphestUpdate maniphestUpdate(int taskId, Iterable<String> projects, String project_action) throws ConduitException { return maniphestUpdate(taskId, null, projects, project_action); 
 public static final String ACTION_PROJECT_ADD = "projects.add"; public static final String ACTION_PROJECT_REMOVE = "projects.remove"; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 throw new IOException("Failed to get " + pluginName + " config from cache.", e.getCause()); 
 public DownstreamCreator(GerritApi gApi, ConfigLoader config) { 
<|del|> 
 params2.put("type", action); if (action.equals(ACTION_COMMENT) { 
<|del|> 
 if (action.equals(ACTION_COMMENT) && comment == null) { throw new IllegalArgumentException(); } else if (action.equals(ACTION_COMMENT)) { 
 if (projects != null) { String project = "projects.add"; params2.put("type", project); 
 if (comment != null) { String comments = "comment"; params2.put("type", comments); 
 logger.error( String.format("DecoderException for user %s: %s ", username, e.getMessage())); 
 // Review it setApiUser(reviewer); 
 conduit.maniphestUpdate(taskId, projectPhids, Conduit.ACTION_PROJECT_REMOVE); } catch (ConduitException e) { throw new IOException("Error on conduit", e); 
 throw new IllegalArgumentException("The value of comment (null) is invalid for the action ACTION_COMMENT"); 
<|del|>
 log.error(String.format( "invalid value for %s; using default value %d", name, defaultValue)); 
 private final GerritApi gApi; 
<|del|> 
 configLoader = new ConfigLoader(gApiMock, projectCacheMock, allProjectsName, "automerger"); 
 /** * String action * String[] params * init length */ 
 throw new IOException(String.format("Action %s expects exactly %d parameter(s) but %d given", action, length, params.length -1)); 
 /** * String[] chopped * int taskId * String actions */ private void assertManiphest(String[] chopped, int taskId, String actions) { 
 if (!a1.unify(new IntegerTerm(count != null ? count : 0), engine.trail)) { 
<|del|> 
<|del|> 
 public SitePaths(@SitePath Path sitePath, @GerritServerConfig Config cfg) throws IOException { 
<|del|> 
 String pluginsDir = cfg.getString("plugins", null, "directory"); plugins_dir = Strings.isNullOrEmpty(pluginsDir) ? p.resolve("plugins") : Paths.get(pluginsDir); 
 SitePaths sitePaths = new SitePaths(getSitePath()); 
 List<String> keys = new ArrayList<>(weights.keySet()); 
 List<String> keys = new ArrayList<>(weights.keySet()); 
 distances.add(new Integer(distance)); 
 Server s, String key, Repository repository, String url, 
 } return EqualsFilePredicate.create(args, file); 
<|del|> 
<|del|> 
 "query/cla_check_count", new Description("Total number of CLA check requests").setRate().setUnit("requests")); 
 private void maniphestEdit(String[] chopped, int taskId, String actions) throws IOException { 
 public void pushToExternalIdsBranchRejectsExternalIdForNonExistingAccount() throws Exception { 
 public void pushToExternalIdsBranchRejectsExternalIdWithInvalidEmail() throws Exception { 
 ExternalId.create( ExternalId.Key.create(SCHEME_USERNAME, "foo"), admin.id, null, "non-hashed-password-is-not-allowed")); 
 AccountCache accountCache, GitRepositoryManager repoManager, AllUsersName allUsers) { 
 throw new IOException( "Response doesn't contain 'user' field" + jsonObject); 
 username == null || username.isJsonNull() ? null : username.getAsString(), 
 request.addBodyParameter(OAuthConstants.SCOPE, config.getScope()); } 
 FacebookOAuthService.class); } 
<|del|> 
 public Object apply(RevisionResource rev, Input input) throws IOException, RestApiException { 
 throws RestApiException, IOException { 
 private static final String BRANCH_DELIMITER = ":"; 
<|del|> 
<|del|> 
<|del|> 
 public String getAutomergeLabel() throws ConfigInvalidException { 
 if (ignoreSourceManifest) { return toProjects; } Set<String> fromProjects = getProjectsInManifest(getManifestProject(), getManifestFile(), fromBranch); fromProjects.retainAll(toProjects); return fromProjects; 
 private Set<String> applyConfig(String fromBranch, String toBranch, Set<String> inputProjects) 
<|del|> 
<|del|> 
 @Mock private PluginConfigFactory cfgFactory; 
 @Mock private PluginConfigFactory cfgFactory; 
 @Test 
<|del|> 
<|del|> 
 ds = new DownstreamCreator(gApiMock, Mockito.mock(ConfigLoader.class)); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * update the comment's text rather than delete the whole comment. 
 throw new ResourceConflictException("branch not found: " + metaRefStr); 
 * the comment's text rather than delete the whole comment. 
 "Cannot delete comment %s on change %s because the first commit" + " on the change meta branch unexpectedly contains comments.", target.key, change.getChangeId())); 
 throw new IllegalStateException( String.format( "fail to delete comment %s on change %s.", target.key, change.getChangeId())); 
 protected Map<String, Object> soyContextEmailData; protected List<String> footers; 
 .current() 
 FakeEmailSender.Message m = sender.getMessages().get(0); assertThat(m.body()).isNotNull(); assertThat(m.htmlBody()).isNotNull(); assertMailReplyTo(m, admin.email); assertMailReplyTo(m, user.email); 
import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Optional; 
<|del|> 
<|del|> 
<|del|> 
 AnonymousUser au, PermissionBackend permissionBackend, 
 } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | NoSuchProjectException | RuntimeException e) { 
 Sets.immutableEnumSet(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT); 
 Sets.immutableEnumSet(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT); 
 private static final String EXTERNAL_ID_PREFIX = AccountExternalId.SCHEME_EXTERNAL + OAuthWebFilter.GITHUB_EXT_ID; 
 private static final ImmutableList<String> COMMON_PRELOAD = ImmutableList.of( "/accounts/self/detail", "/config/server/info", "/config/server/version" ); // TODO (viktard): experiment with optimal amount of preloading. 
 filterRegex(key).through(new LinkPreloadFilter(key, entry.getValue())); 
 for (String url : urls) { rsp.addHeader(HttpHeaders.LINK, String.format("<%s>;rel=\"preload\";crossorigin", req.getContextPath() + path.replaceAll(key, url))); } 
 HttpClientProvider(Configuration cfg) { 
 out, null, path, FileMode.REGULAR_FILE, new ObjectLoader.SmallObject(FileMode.TYPE_FILE, data)); 
 public void robotCommentsCanBeRetrievedAsList() throws Exception { 
 RelatedChangesInfo related() throws RestApiException; ListMultimap<String, ApprovalInfo> votes() throws RestApiException; 
<|del|> 
import com.google.gerrit.reviewdb.client.PatchSet; import com.google.gerrit.reviewdb.client.Project; 
 return new WebLinkInfo(name, null, String.format("%s/%s/+/%s", baseUrl, projectName, commit), target); 
<|del|> 
 String commitMessage) { return config.isSkipMerge(fromBranch, toBranch, commitMessage); } 
 private static final Pattern LINE_SEPARATOR_PATTERN = Pattern.compile("\\R"); 
 * with indices based on the unmodified string. There is one limitation though: Replacements which 
 ImmutableList.of("/accounts/self/detail", "/config/server/info", "/config/server/version"); 
import com.google.gerrit.extensions.webui.ProjectWebLink; import com.google.gerrit.server.config.CanonicalWebUrl; 
 return new WebLinkInfo(name, null, String.format("%s/%s/+/%s", baseUrl, projectName, commit), target); 
public @interface SharedDirectory { 
 put(REVISION_KIND, "description").to(PutDescription.class); get(REVISION_KIND, "description").to(GetDescription.class); 
<|del|> 
 * Get an update for this change at a given patch set. 
 * IdentifiedUser} or {@link com.google.gerrit.server.InternalUser}. 
 * @return identified user performing the update; throws an unchecked exception if the user is not * an {@link IdentifiedUser} 
<|del|> 
 log.error("Error reading manifest for {}!", fromBranch, e); 
 mockFile("alternate.config", allProjectsName.get(), RefNames.REFS_CONFIG, "automerger.config"); Mockito.when(gApiMock.projects().name("platform/manifest").branch("master")) 
Copyright (C) 2013 The Android Open Source Project 
 * Indicates whether or not the provider allows to set the image URL. 
<|del|> 
 String base_url; 
 // MismatchedStateException. 
 protected String getMappingsFor(String type, MappingProperties properties) { JsonObject mappingType = new JsonObject(); mappingType.add(type, gson.toJsonTree(properties)); 
 protected String getMappingsFor(String type, MappingProperties properties) { JsonObject mappingType = new JsonObject(); mappingType.add(type, gson.toJsonTree(properties)); 
 protected String getMappingsFor(String type, MappingProperties properties) { JsonObject mappingType = new JsonObject(); mappingType.add(type, gson.toJsonTree(properties)); 
 protected String getMappingsFor(String type, MappingProperties properties) { JsonObject mappingType = new JsonObject(); mappingType.add(type, gson.toJsonTree(properties)); 
 protected String getMappingsFor(String type, MappingProperties properties) { JsonObject mappingType = new JsonObject(); mappingType.add(type, gson.toJsonTree(properties)); 
 maxRetries = getInt(remoteConfig, cfg, "replicationMaxRetries", 0); 
 private void parseRewind(ReceiveCommand cmd) { 
 InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0); 
import com.google.gwtorm.jdbc.Database; import com.google.gwtorm.jdbc.JdbcExecutor; 
 } finally { // Reader.close won't consume the rest of the input. Explicitly consume the request body. 
 "Range %s refers to a non-existent offset (start line length: %s," 
 @PluginName String pluginName) 
 "Pushes of commits that contain files or commit messages with " + "blocked keywords will be rejected.")); 
 Patch.COMMIT_MSG, line, l); 
 new ReviewerByEmailSet(ImmutableTable.of()); 
 FooterKey getByEmailFooterKey() { return new FooterKey(footerKey.getName() + "-email"); } 
<|del|> 
<|del|> 
 info.htmlResourcePaths.add(path); 
 int sl = url.indexOf('/'); 
 private final ConfigInfo info; 
 private final ConfigInfo info; 
 .addParameter("filter", "CURRENT") 
 return t; 
 return null; 
 log.info("Connected to JIRA at {}, reported version is {}", info.getBaseUri(), info.getVersion()); 
 return Response.ok(""); 
 return Response.ok(""); 
 "ERROR: blocked keyword(s) found in: " + Patch.COMMIT_MSG + " (Line: 1) (found: foobar)"); 
 * Example of usage: * 
 private PluginConfigFactory pluginConfigFactoryMock; 
 cfg.setEnum("plugin", pluginName, "sortJobsPanel", JobsSorting.valueOf(input.sortJobsPanel)); 
 u.setExpectedOldObjectId(r.exactRef(ref)); 
 * @return identified user performing the update; throws if the user is not an {@link * IdentifiedUser} 
 * @return account of the user performing the update; throws if the user is not an {@link * IdentifiedUser} 
 if (msgs.stream().anyMatch(m -> m.isError())) { 
 if (msgs.stream().anyMatch(m -> m.isError())) { 
 externalIds.get().byEmail(email).stream().map(e -> e.accountId()).forEach(r::add); 
 @Override public void evictAll() throws IOException { byId.invalidateAll(); for (Account.Id accountId : byId.asMap().keySet()) { indexer.get().index(accountId); } } @Override 
 private final DeleteReviewerInput input; 
 static void wrapAndThrowException(Exception e) throws UpdateException, RestApiException { 
 "Foo Bar <foo.bar@gerritcodereview.com> does not identify a registered user or group"); 
Copyright (C) 2017 The Android Open Source Project 
 @Nullable private final IdentifiedUser user; @Nullable private final Address address; 
 @Nullable Change.Id sourceChangeId, @Nullable PatchSet.Id sourcePatchId, @Nullable Branch.NameKey sourceBranch, @Nullable String sourceChangeTopic, 
<|del|> 
 } catch (IntegrationException e) { 
 this.polyGerritBaseUrl = URI(cfg.getString('canonicalWebUrl'); 
<|del|> 
 String password = id.getPassword(); if (password != null) { HashedPassword hashed = HashedPassword.fromPassword(password); id.setPassword(hashed.encode()); 
 + "SET password = ? " 
 private static String toRfcAddressString(AccountInfo info) { 
 log.warn("Cannot update external IDs", e); 
 info.sortJobsPanel = cfg.getEnum(JobsSorting.values(), "sortJobsPanel", JobsSorting.REPORTER); info.sortJobsDropDownPanel = cfg.getEnum(JobsSorting.values(), "sortJobsDropDownPanel", JobsSorting.REPORTER); 
 Loader(SchemaFactory<ReviewDb> schema, ExternalIds externalIds) { 
 dialect.dropIndex(e, "account_external_ids", "account_external_ids_byEmail"); 
 private final AccountByEmailCache byEmailCache; 
 private final URL baseUrl; 
 @Inject 
 private ChangeContextImpl newChangeContext(Change.Id id) throws OrmException { 
 public ObjectLoader open(AnyObjectId objectId) throws IOException { 
 public ObjectLoader open(AnyObjectId objectId, int typeHint) throws IOException { 
 public ObjectId resolve(String revstr) throws IOException { 
 public String simplify(String revstr) throws IOException { 
 public DirCache readDirCache() throws IOException { 
 public DirCache lockDirCache() throws IOException { 
 public ObjectLoader open(AnyObjectId objectId, int typeHint) throws IOException { 
 * <p>The external IDs are replaced regardless of which account they belong to. 
 public String revertChangeDefaultMessage; public String reviewerNotFound; 
 enableReviewerByEmail = newInheritedBooleanBox(); saveEnabler.listenTo(enableReviewerByEmail); grid.addHtml(AdminConstants.I.rejectImplicitMerges(), enableReviewerByEmail); 
 } finally { // Reader.close won't consume the rest of the input. Explicitly consume the request body. 
import com.google.gerrit.server.config.AnonymousCowardNameProvider; import com.google.gerrit.server.git.ChangeAlreadyMergedException; 
 throws UpdateException, RestApiException, OrmException, IOException { 
 } return byEmails.build(); 
<|del|> 
 if (serviceFactory instanceof AbstractIoServiceFactory) { 
<|del|> 
 updateCache( oldNotesRev, 
 && (!onlyFirstParentChanged(prior, next) || prior.getParentCount() == 0)) { 
 if (!projectControl.isOwner() && !refsMetaConfigControl.canUpload()) { throw new PermissionDeniedException("cannot upload to " + RefNames.REFS_CONFIG); 
 if (!projectControl.isOwner() && !refsMetaConfigControl.canUpload()) { throw new PermissionDeniedException("cannot upload to " + RefNames.REFS_CONFIG); 
 if (rw != null) { rw.getObjectReader().close(); 
 public static class ExternalIdUpdateListener implements CommitValidationListener { private final AccountCache accountCache; private final GitRepositoryManager repoManager; 
<|del|> 
 Object term = new PRED_submit_rule_1(null, null); 
<|del|> 
<|del|> 
 String path = u.getJavaScriptResourcePath(); 
Copyright (C) 2017 The Android Open Source Project 
 implements PluginDefinedAttributesFactory { 
<|del|> 
 protected QueryOptions createOptions( IndexConfig indexConfig, int start, int limit, Set<String> requestedFields) { return IndexedChangeQuery.createOptions(indexConfig, start, limit, requestedFields); 
<|del|> 
<|del|> 
<|del|> 
 protected final byte[] indexSource; 
 IndexServlet(final String canonicalURL, @Nullable String cdnPath) throws URISyntaxException { 
 protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException { 
 rsp.setStatus(SC_OK); try (OutputStream w = rsp.getOutputStream()) { 
 protected static SoyMapData getTemplateData(final String canonicalURL, final String cdnPath) throws URISyntaxException { String canonicalPath = computeCanonicalPath(canonicalURL); 
 @CanonicalWebUrl @Nullable final String canonicalUrl, 
 throws URISyntaxException { String cdnPath = cfg.getString("gerrit", null, "cdnPath"); return new IndexServlet(canonicalUrl, cdnPath); 
 public void noPathAndNoCDN() throws URISyntaxException { SoyMapData data = IndexServlet.getTemplateData("http://example.com/", null); 
 static String computeCanonicalPath(String canonicalURL) throws URISyntaxException { 
 HttpServlet getPolyGerritUiIndexServlet(@CanonicalWebUrl @Nullable String canonicalUrl, @GerritServerConfig Config cfg) throws URISyntaxException { 
 private final byte[] indexSource; 
 IndexServlet(String canonicalURL, @Nullable String cdnPath) throws URISyntaxException { 
 static String computeCanonicalPath(String canonicalURL) throws URISyntaxException { 
 static SoyMapData getTemplateData(String canonicalURL, String cdnPath) throws URISyntaxException { 
 HttpServlet getPolyGerritUiIndexServlet(@CanonicalWebUrl @Nullable String canonicalUrl, @GerritServerConfig Config cfg) throws URISyntaxException { 
 return submit(new Callable<Long>() { @Override public Long call() throws IOException, InterruptedException { return writer.addDocument(doc); } }); 
 return submit(new Callable<Long>() { @Override public Long call() throws IOException, InterruptedException { return writer.updateDocument(term, doc); } }); 
 return submit(new Callable<Long>() { @Override public Long call() throws IOException, InterruptedException { return writer.deleteDocuments(term); } }); 
<|del|> 
Copyright (C) 2017 The Android Open Source Project 
// limitations under the License. 
 @VisibleForTesting private Set<String> getMissingDownstreamMerges(ChangeInfo upstreamChange) 
<|del|> 
<|del|> 
 RevisionInfo revision = change.revisions.get(change.currentRevision); 
 throws RestApiException, FailedMergeException, ConfigInvalidException { // Map from branch to error message 
Copyright (C) 2017 The Android Open Source Project 
 assertThat(fme.getDisplayString().split("\\n")) .asList() .containsExactly(branch1String, branch2String, branch3String); 
<|del|> 
 push.to(RefNames.REFS_CONFIG).assertOkStatus(); 
 pushConfig("automerger.config", result.getChange().project().get()); 
 private native void setEnableReviewerByEmailRaw(String v) /*-{ if(v)this.enable_reviewer_by_email=v; }-*/ ; 
 + " agreementUrl = http://www.example.com/agree\n")) // 
Copyright (C) 2017 The Android Open Source Project 
 String projectName = result.getChange().project().get(); 
<|del|> 
 // Force BatchRefUpdate to read newly referenced objects using a new RevWalk, rather than one // that might have access to unflushed objects. 
 Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c); 
 tw.addTree(c.getTree()); 
 try (Revwalk rw = new RevWalk(repo)) { List<CommitValidationMessage> m = validator.performValidation(repo, c1, rw); assertThat(m).isEmpty(); } 
 try (RevWalk rw = new RevWalk(repo)) { 
 .performValidation(repo, rw.parseCommit(c), rw, BLOCKED_EXTENSIONS_LC); 
 throw new CommitValidationException("failed to check on blocked keywords", e); 
<|del|> 
 cfg.setString(RECEIVEEMAIL, null, "fetchInterval", Integer.toString(Integer.MAX_VALUE)); 
 cfg.setString(RECEIVEEMAIL, null, "fetchInterval", Integer.toString(Integer.MAX_VALUE)); 
 private final GitRepositoryManager repos; 
 ChangeData changeData = null; try (ReviewDb reviewDb = reviewDbProvider.open()) { changeData = changeDataFactory.create(reviewDb, change); 
 // TODO(tandrii): add extension point to customize this commit message. 
 if (commit instanceof RevCommit && ((RevCommit) commit).getRawBuffer() != null) { return (RevCommit) commit; } 
 * @param commit name of the commit object. 
 //if (commit instanceof RevCommit) { // return (RevCommit) commit; //} 
 try { RevCommit prior = rw.parseCommit(key.prior); rw.parseBody(prior); RevCommit next = rw.parseCommit(key.next); rw.parseBody(next); 
 psId = ChangeUtil.nextPatchSetId(ctx.getRepository(), toMerge.change().currentPatchSetId()); 
 * @throws OrmDuplicateKeyException if the account already exists 
 if (!projectControl.isOwner() && !refsMetaConfigControl.canUpload()) { throw new PermissionDeniedException("cannot upload to " + RefNames.REFS_CONFIG); 
<|del|> 
 * Find the latest patch set, that is smaller or equals to the given patch set, 
 new JobsSummaryPanel.Factory()); 
 StoredConfig orig = repo.getConfig(); 
 private static void updateRefIfPrefixMatches( 
 repo.close(); 
 return matchesAny(getContentType(ol, pathname), getBinaryTypes(cfg)); 
 if (contentTypeUtil.isBinary(ol, path, cfg)) { 
 Patch.COMMIT_MSG, line, l); 
 List<CommitValidationMessage> m = validator.performValidation(repo, c, rw); 
 ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); cfg.setEnableReviewerByEmail(false); saveProjectConfig(project, cfg); 
 private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException { 
<|del|> 
 Definition<ChangeData, ? extends QueryBuilder<ChangeData>> def, Arguments args) { 
 * Find the latest patch set, that is smaller or equals to the given patch set, 
 try (InputStream in = ol.openStream()) { if (RawText.isBinary(in)) { continue; } 
<|del|> 
 throw new RuntimeException("implement me"); //TODO(dpursehouse) 
<|del|> 
 } if (ctx.deleted) { logDebug("Change {} was deleted", id); handle.manager.deleteChange(id); handle.setResult(id, ChangeResult.DELETED); } else { handle.setResult(id, ChangeResult.UPSERTED); } 
<|del|> 
 listener.afterUpdateRefs(); listener.afterUpdateChanges(); 
<|del|> 
 private final ChangeResource rsrc; private final Map<Id, ChangeControl> reviewers; private final Collection<Address> reviewersByEmail; private final ReviewerState state; private final NotifyHandling notify; private final ListMultimap<RecipientType, Id> accountsToNotify; 
 cm.setNotify(notify); 
 public Result getResult() { checkState(opResult != null, "Batch update wasn't executed yet"); 
 public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws RestApiException { 
 // Description is different to other parameters, null won't result in 
 List<PluginDefinedInfo> plugins = new ArrayList<>(attributeFactories.plugins().size()); 
public abstract class JdbcAccountPatchReviewStore 
 protected JdbcAccountPatchReviewStore(Config cfg, 
 throw new OrmException("Failed to delete user branches for non-existing accounts.", e); 
<|del|> 
 post(CONFIG_KIND, "check").to(CheckConsistency.class); 
 protected boolean equals(PatchSet p, String id) { 
 ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes()); 
 @Option(name = "--sourceUrl", usage = "Url of source database") 
<|del|> 
 } catch (Exception e) { log.error(String.format("Ignoring invalid external ID note %s", note.getName()), e); 
 checkArgument(basePath != null, "gerrit.basePath must be configured"); 
 .map(r -> Account.Id.fromRef(r.getName())) .filter(Objects::nonNull) 
 return readUserRefs().sorted(comparing(id -> id.get())).limit(n).collect(toList()); 
<|del|> 
 .atomicUpdate(dbProvider.get(), user.getAccountId(), a -> a.setFullName(newName)); 
 ? Response.none() 
 : Response.ok(account.getStatus()); 
 @Option(name = "--chunkSize", usage = "chunk size of fetching from source and push to target on each time") private static long chunkSize = 100000; 
 @Option(name = "--chunkSize", usage = "chunk size of fetching from source and push to target on each time") private static long chunkSize = 100000; 
 @Option(name = "--chunkSize", usage = "chunk size of fetching from source and push to target on each time") private static long chunkSize = 100000; 
import static com.google.gerrit.extensions.client.GitBasicAuthPolicy.HTTP; import static com.google.gerrit.extensions.client.GitBasicAuthPolicy.HTTP_LDAP; import static com.google.gerrit.extensions.client.GitBasicAuthPolicy.LDAP; import static com.google.gerrit.extensions.client.GitBasicAuthPolicy.OAUTH; 
 HTTP, EnumSet.of(HTTP, HTTP_LDAP, LDAP)); 
 HTTP, EnumSet.of(HTTP, HTTP_LDAP, LDAP)); 
 "Git/HTTP authentication", "gitBasicAuthPolicy", HTTP, EnumSet.of(HTTP, OAUTH)); 
 "Git/HTTP authentication", "gitBasicAuthPolicy", HTTP, EnumSet.of(HTTP, OAUTH)); 
 if (gitBasicAuth == OAUTH) { 
 public <T extends Enum<?>, E extends EnumSet<? extends T>> T select( final String title, final String name, final T defValue) { 
 public <T extends Enum<?>, E extends EnumSet<? extends T>> T select( final String title, final String name, final T defValue, boolean nullIfDefault) { 
 public <T extends Enum<?>, E extends EnumSet<? extends T>> T select( final String title, final String name, final T defValue, boolean nullIfDefault) { 
 return new Addition(reviewer, rsrc, reviewers, null, state, notify, accountsToNotify); 
 JdbcAccountPatchReviewStore.createAccountPatchReviewStore(cfg, sitePaths); 
 @AutoValue abstract static class Row { abstract int accountId(); abstract int changeId(); abstract int patchSetId(); abstract String fileName(); 
 private static List<Row> selectRows(PreparedStatement stmt, long offset) 
 private static void insertRows(Connection con, PreparedStatement stmt, 
<|del|> 
 public static JdbcAccountPatchReviewStore createAccountPatchReviewStore( Config cfg, SitePaths sitePaths) { 
 private static String getUrl(@GerritServerConfig Config cfg, 
 PatchSet.Id id = new PatchSet.Id(psId.getParentKey(), rs.getInt("PATCH_SET_ID")); ImmutableSet.Builder<String> builder = ImmutableSet.builder(); 
 import java.net.MalformedURLException; import java.net.URL; import java.util.concurrent.TimeUnit; import org.eclipse.jgit.lib.Config; 
 + " Please familiarize yourself with the documentation:\n" 
import io.searchbox.client.http.JestHttpClient; import java.net.MalformedURLException; import java.net.URL; import java.util.concurrent.TimeUnit; import org.eclipse.jgit.lib.Config; 
 DynamicSet<AccountIndexedListener> indexedListener, @Assisted AccountIndex index) { 
<|del|> 
 public static final Class<Schema_151> C = Schema_151.class; 
 public Boolean showAssigneeInChangesTable; public Boolean allowDrafts; 
 if (out.isCurrent && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) { 
<|del|> 
 DraftWorkflowMigrationStrategy strategy = DraftWorkflowMigrationStrategy.PRIVATE; 
 strategy == DraftWorkflowMigrationStrategy.PRIVATE ? "is_private" : "work_in_progress"; 
<|del|> 
 update.setPrivate(isPrivate); update.setWorkInProgress(workInProgress); 
 suggestions.add("is:mergeable"); suggestions.add("is:ignored"); 
 assertThat(validator.isValid("foo@bar.example")).isTrue(); assertThat(validator.isValid("foo@example")).isTrue(); 
<|del|> 
<|del|> 
 .discoveryEnabled(!refresh) 
 versions.add(entry.getKey().replace(name, "")); 
<|del|> 
 * * @param name index name 
 * @param name index name * @return true if index was activated, otherwise false. 
 private boolean isLatestIndexVersion(String name, OnlineReindexer<?, ?, ?> reindexer) { 
<|del|> 
<|del|> 
 Account match; 
 Project.NameKey key = new Project.NameKey(input.project); 
 try { permissionBackend .user(user) .ref(new Branch.NameKey(key, input.ref)) .check(RefPermission.READ); } catch (AuthException | PermissionBackendException e) { 
 throw new RestApiException("Cannot check access", e); 
<|del|> 
<|del|> 
 rs.getInt("patch_set_id")); 
 builder.add(rs.getString("file_name")); 
<|del|> 
<|del|> 
 String serializedEvent = gson.toJson(projectEvent); 
 String serializedEvent = gson.toJson(projectEvent); 
 if (log.isDebugEnabled()){ 
 final boolean successful; final String message; 
 gApi.groups().id(privilegedGroup.getGroupUUID().get()).addMembers(privilegedUser.username); 
 } 
 this.project = project; this.ref = ref; 
<|del|> 
 /** * A default implementation which allows source compatibility when adding new methods to the * interface. */ 
 @Override public AccessCheckInfo checkAccess(AccessCheckInput in) throws RestApiException { throw new NotImplementedException(); } 
 Provider<CheckAccess> checkAccess) { 
<|del|> 
 action.sendError( SC_INTERNAL_SERVER_ERROR, String.format("Unsupported path %s was provided", action.path)); 
 return; 
 public static final String LFS_UNIFIED_PATHS = Joiner.on('|') .join(LFS_OBJECTS_PATH, LFS_LOCKS_PATH, LFS_VERIFICATION_PATH); 
 //TODO: this is just the method stub for lock deletion 
 if (v.version != search.version) { indexes.addWriteIndex(factory.create(v.schema)); } else { indexes.addWriteIndex(searchIndex); 
 extract(site.gerrit_service, getClass(), "gerrit.service"); 
 import org.eclipse.jgit.lib.Config; 
 MariaDBAccountPatchReviewStore(@GerritServerConfig Config cfg, SitePaths sitePaths) { 
<|del|> 
 default: RemoteRefUpdate.Status status = RetryReason.REPOSITORY_MISSING.equals(reason) ? NON_EXISTING : REJECTED_OTHER_REASON; postReplicationFailedEvent(pushOp, status); 
 * @param up the UploadPack instance being processed 
<|del|> 
class ForwardingException extends Exception { 
 ForwardingException(boolean isRecoverable, 
 if (execCnt >= maxTries) { log.error("Failed to {} after {} tries; giving up", name, maxTries); 
 log.error("{} {} was interrupted; giving up", action, key, ie); Thread.currentThread().interrupt(); return false; 
 log.debug("Failed to {} [{}/{}]", name, execCnt, maxTries, e); 
<|del|>
<|del|>
 buf.toString(), 
 buf.toString(), 
 private final Provider<PeerInfo> peerInfo; 
 throw new IllegalArgumentException("Invalid option: \"" + parts[1] + "\""); 
 this.rolePermissions = new ArrayList<>(4); 
 throw new IllegalArgumentException("Invalid option: \"" + rangeString + "\""); 
 return ROLE.length() < varName.length() && varName.startsWith(ROLE); 
 */ @Nullable 
 if (range.matches(RANGE_REGEX)) { 
 private final String name; private final List<RolePermission> rolePermissions; 
 this.rolePermissions = new ArrayList<>(); 
 private final String permissionName; 
<|del|> 
 if (roles != null && roles.containsKey(Permission.getRoleName(p))) { 
 if (isAllProjects && !Permission.canBeOnAllProjects(as.getName(), rolePerm.getPermissionName())) { continue; 
 if (isAllProjects && !Permission.canBeOnAllProjects(as.getName(), rolePerm.getPermissionName())) { continue; 
 private final String rangeString; private final boolean force; 
 implements AccountPatchReviewStore, LifecycleListener { private static final Logger log = LoggerFactory.getLogger(JdbcAccountPatchReviewStore.class); 
 public static final String TAG_SET_WIP = "autogenerated:gerrit:setWorkInProgress"; public static final String TAG_UNSET_PRIVATE = "autogenerated:gerrit:unsetPrivate"; 
 Change change = rsrc.getChange(); if (!rsrc.isUserOwner()) { throw new AuthException("not allowed to set ready for review"); } 
 Change change = rsrc.getChange(); if (!rsrc.isUserOwner()) { throw new AuthException("not allowed to set work in progress"); } 
 Change change = rsrc.getChange(); if (!rsrc.isUserOwner()) { throw new AuthException("not allowed to set ready for review"); } 
 Change change = rsrc.getChange(); if (!rsrc.isUserOwner()) { throw new AuthException("not allowed to set work in progress"); } 
 private static final Pattern PRIVATE_SET_REGEXP = Pattern.compile("^Set private$"); private static final Pattern PRIVATE_UNSET_REGEXP = Pattern.compile("^Unset private$"); 
 private static final Pattern PRIVATE_SET_REGEXP = Pattern.compile("^Set private$"); private static final Pattern PRIVATE_UNSET_REGEXP = Pattern.compile("^Unset private$"); 
 public void testNoRequestWhenPeerInfoUnknown() throws IOException { 
 HttpPost post = new HttpPost(getPeerInfo().getDirectUrl() + endpoint); 
 stars.star( self.get().getAccountId(), rsrc.getProject(), rsrc.getChange().getId(), ImmutableSet.of(StarredChangesUtil.IGNORE_LABEL), ImmutableSet.of()); 
 return stars .byChange(rsrc.getChange().getId(), StarredChangesUtil.IGNORE_LABEL) .contains(self.get().getAccountId()); 
 .setVisible(!rsrc.isUserOwner() && isIgnored(rsrc)); 
 c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen()); 
 final Grid formGrid = new Grid(15 + (flashClippy ? 1 : 0), 2); 
 private final PluginEvent pluginEvent; private final String pluginName; 
 permissionBackend 
 public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException { 
<|del|> 
 public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException { 
<|del|>
 LfsLockResponse createLock(Project.NameKey project, CurrentUser user, LfsCreateLockInput input) throws LfsException { 
 LfsLockResponse deleteLock( Project.NameKey project, CurrentUser user, String lockId, LfsDeleteLockInput input) 
 String isWorkInProgress(); 
 protected boolean createProject(URIish uri, String projectName, String head) { 
 "DeleteProject plugin is not installed on {} will not try to forward this opperation to that host"); withoutDeleteProjectPlugin.add(uri); 
 "DeleteProject plugin is not installed on {} will not try to forward this opperation to that host"); withoutDeleteProjectPlugin.add(uri); 
 String uriStr = uri.toString(); if (uri.getHost() != null && uriStr.startsWith(GERRIT_ADMIN_PROTOCOL_PREFIX)) { return new URIish(uriStr.substring(0, GERRIT_ADMIN_PROTOCOL_PREFIX.length())); 
 sshUri = sshUri.setPort(SshAddressesModule.DEFAULT_PORT); 
 return SSH_COMMAND_FAILED; 
 "Error {} remote repository at {}:\n Exception: {}\n Command: {}\n Output: {}", msg, uri, e, cmd, errStream, 
 "Error {} remote repository at {}:\n Exception: {}\n Command: {}\n Output: {}", msg, uri, e, cmd, errStream, 
 if (replicationQueue.createProject(projectName, head != null ? head.getName() : null)) { 
 GerritSshApi ga, 
 RemoteSession connect(URIish uri) throws TransportException { return sshSessionFactoryProvider.get().getSession(uri, null, FS.DETECTED, SSH_REMOTE_TIMEOUT); 
 private static final String COMMIT_MSG = "Rewrite project.config to get rid of the refs/for/ ACLs"; 
 AccessSection destSection = config.getAccessSection(destinationRef, true); updateRule(destSection, permission, rule); 
 AccessSection destSection, 
<|del|> 
 PermissionRule rule = perm.getRule(roleRule.getGroup(), true); 
 new StringBuilder(c.isWorkInProgress() ? "Set Work In Progress" : "Set Ready For Review"); 
 setWorkInProgress(null); 
 /** * @param msg message to return to the client. * @param cause cause of this exception. */ 
 baseUrl = baseGerritUrl + "plugins/" + pluginName; 
<|del|> 
 ObjectId newTip = revWalk.next(); // The first commit will not be rewritten. 
 postPrivate.apply(change, input); 
 Ref metaRef = repo.exactRef(RefNames.changeMetaRef(changeId)); 
<|del|> 
 private void assertMetaBranchCommitsAfterRewriting( 
 @Inject 
 private final ListMultimap<String, NoteDbRewriter> rewriters; 
 } return defaultName; 
 @Inject private PluginConfigFactory configFactory; 
 // Default project is something like ....FindOwnersIT..._project 
<|del|> 
<|del|> 
 return cd.getAuthor().getEmailAddress().toLowerCase(Locale.US); 
 } return getAuthorOrCommitterPredicate(who, "author", AuthorPredicate::new); 
 // Only email address. 
 /** The exact email address and name of the author. */ public static final FieldDef<ChangeData, Iterable<String>> EXACT_AUTHOR = exact(ChangeQueryBuilder.FIELD_EXACTAUTHOR) .buildRepeatable(ChangeField::getAuthorNameAndEmail); 
 /** The exact email address and name of the author. */ public static final FieldDef<ChangeData, Iterable<String>> EXACT_AUTHOR = exact(ChangeQueryBuilder.FIELD_EXACTAUTHOR) .buildRepeatable(ChangeField::getAuthorNameAndEmail); 
<|del|> 
 } catch (OrmException | IOException | UpdateException e) { 
 } catch (OrmException | IOException | UpdateException | PermissionBackendException e) { 
 } catch (IOException | OrmException e) { 
 } catch (UpdateException | IOException | OrmException | PermissionBackendException e) { 
 } catch (UpdateException | OrmException | PermissionBackendException e) { 
 return ImmutableSet.of(); 
 git().fetch().setRefSpecs(new RefSpec(REFS_CONFIG + ":" + REFS_CONFIG)).call(); 
 .to("refs/for/" + REFS_CONFIG); 
 final Set<PublicKey> keys = new HashSet<>(6); 
 } catch (Exception e) { // continue since older hosts won't be able to generate ed25519 keys. 
 } catch (Exception e) { // continue since older hosts won't be able to generate ed25519 keys. 
 } catch (Exception e) { // continue since older hosts won't be able to generate ed25519 keys. 
 final List<File> stdKeys = new ArrayList<>(4); 
<|del|> 
 return input.owner.name.equals(user.getUserName().get()); 
 String.format("Committing lock to path [%s] in project %s failed", input.path, project); 
 if (!exists(site.ssh_key) // && !exists(site.ssh_rsa) // && !exists(site.ssh_dsa) || !exists(site.ssh_ed25519) || !exists(site.ssh_ecdsa)) { 
 && (!exists(site.ssh_rsa) 
 if (!exists(site.ssh_key) && !exists(site.ssh_rsa) && !exists(site.ssh_dsa) || (!exists(site.ssh_key) && !exists(site.ssh_ed25519)) || (!exists(site.ssh_key) && !exists(site.ssh_ecdsa))) { 
 int prevVersion = Iterables.get(schemas.keySet(), schemas.size() - 2); 
 int prevVersion = Iterables.get(schemas.keySet(), schemas.size() - 2); 
 int prevVersion = Iterables.get(schemas.keySet(), schemas.size() - 2); 
<|del|> 
 .registerTypeAdapter(Supplier.class, new SupplierSerializer()) .create(); 
 RemoteConfig.Factory remoteFactory, PostTask.Factory taskFactory) { 
 RemoteConfig.Factory remoteFactory, PostTask.Factory taskFactory) { 
 log.error("Couldn't post event: " + projectEvent, e); 
 public static final String LFS_LOCKS_PATH_REGEX = "locks(?:/(.*)(?:/unlock))?"; 
 protected void throwUnauthorizedOp(String op, ProjectControl control) 
 protected void throwUnauthorizedOp(String op, ProjectControl control) 
<|del|> 
<|del|> 
 bind(new TypeLiteral<Optional<PeerInfo>>() {}).toProvider(PeerInfoProvider.class); 
 private void init() { files = new StringSet(); countL1 = 0; countL2 = 0; countL3 = 0; 
<|del|> 
 "Cannot delete project because it has children: " + childrenString); 
 "Cannot delete project because of failure in permission backend."); 
 operator != null && (operator.equals("author") || operator.equals("committer"))); 
Copyright (C) 2017 The Android Open Source Project 
Copyright (C) 2017 The Android Open Source Project 
<|del|> 
 } catch (Exception e) { 
 throw asRestApiException("Cannot delete comment", e); 
 checkState(deleteCommentRewriter != null, "cannot update and rewrite ref in one BatchUpdate"); 
 assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get()); 
 assertThat(reviewers.iterator().next()._accountId).isEqualTo(admin.getId().get()); 
 String suffix = getSanitizedMethodName(); 
 String suffix = getSanitizedMethodName(); 
 Schema<AccountState> prevSchema = AccountSchemaDefinitions.INSTANCE.getPrevious(); if (prevSchema != null) { 
 Schema<ChangeData> prevSchema = ChangeSchemaDefinitions.INSTANCE.getPrevious(); if (prevSchema != null) { 
<|del|> 
 abstract boolean isChange(); 
<|del|> 
 name = "automerger", sysModule = "com.googlesource.gerrit.plugins.automerger.AutomergerModule" ) 
 @NoHttpd 
 public void projectChangeNumberReturnsChange() throws Exception { 
 exception.expectMessage("Not found: " + project.get() + "~" + Integer.MAX_VALUE); 
 public Boolean publishCommentsOnPush; 
 // Indicates that this entry only exists because of a rebase (and not because of a real change 
<|del|> 
 c.setReuseAddress(reuseAddress); c.setIdleTimeout( cfg.getTimeUnit("httpd", null, "idleTimeout", 30000L, MILLISECONDS)); 
<|del|>
 if (!refControl.canUpload() || !refControl.isVisible()) { 
 if (minor.contains("-")) { 
 if (expectedState == null || expectedState.getPrimaryStorage() == PrimaryStorage.NOTE_DB) { 
 psForComment = patchSet; 
 @Nullable 
 return Iterables.get(schemas.descendingMap().values(), 1); 
 name = CharMatcher.is('_').trimTrailingFrom(name); 
 SortedMap<Integer, Schema<V>> schemas = schemaDef.getSchemas(); 
 for (String s : Splitter.on(',').trimResults().split(value)) { 
 checkArgument(schemaDef.getPrevious() != null, "previous version does not exist"); 
 for (Map.Entry<String, org.eclipse.jgit.lib.Config> e : configMap.entrySet()) { 
 StringBuilder nameEmailBuilder = new StringBuilder(); PersonIdent.appendSanitized(nameEmailBuilder, name); nameEmailBuilder.append(" <"); PersonIdent.appendSanitized(nameEmailBuilder, email); nameEmailBuilder.append('>'); return ImmutableSet.of(name, email, nameEmailBuilder.toString()); 
 if (args.getSchema().hasField(ChangeField.EXACT_AUTHOR)) { return getAuthorOrCommitterPredicate( who.trim(), ExactAuthorPredicate::new, AuthorPredicate::new); } return getAuthorOrCommitterFullTextPredicate(who.trim(), AuthorPredicate::new); 
 return Predicate.and(predicates); 
 public static final String LFS_UNIFIED_PATHS_REGEX = 
 private final LoadingCache<Project.NameKey, Cache<String, LfsLock>> projects; 
import com.google.gerrit.server.account.GroupCache; import com.google.gerrit.server.change.Abandon; 
import com.google.gerrit.server.change.ChangeResource; import com.google.gerrit.server.change.FileContentUtil; 
 name + "-" + Hashing.sha1().hashString(name, Charsets.UTF_8).toString().substring(0, 7); 
 name + "-" + Hashing.sha1().hashString(name, Charsets.UTF_8).toString().substring(0, 7); 
 String destRefName = destRefControl.getRefName(); Ref destRef = git.getRefDatabase().exactRef(destRefName); if (destRef == null) { 
import com.google.gerrit.acceptance.RestResponse; import com.google.gerrit.acceptance.TestAccount; 
<|del|> 
<|del|> 
 baseUrl = baseGerritUrl + "plugins/" + pluginName; 
 comment.message = expectedMsg; commentsBeforeDelete.set(i, comment); List<CommentInfo> commentsAfterDelete = getChangeSortedComments(changeId); assertThat(commentsAfterDelete).isEqualTo(commentsBeforeDelete); } 
 private static CommentInput newCommentOnParent( String path, int parent, int line, String message) { 
 private DraftInput newDraft(String path, Side side, int line, String message) { 
 private static <C extends Comment> C populate( C c, String path, Side side, Integer parent, int line, String message, Boolean unresolved) { 
 private static final Logger log = LoggerFactory.getLogger(LfsLocksHandler.class); 
 return MoreObjects.firstNonNull(patchListEntry.getOldName(), patchListEntry.getNewName()); 
 String adjustedOldFilePath = MoreObjects.firstNonNull(oldFilePath, newFilePath); 
 final ObjectReader reader = repo.newObjectReader(); try { final RevWalk rw = new RevWalk(reader); 
 return configuredProvider.get(); 
<|del|> 
import static com.google.gerrit.extensions.api.lfs.LfsDefinitions.LFS_URL_WO_AUTH_REGEX; 
import com.google.gerrit.server.permissions.PermissionBackend; import com.google.gerrit.server.project.ProjectCache; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 permissionBackend.user(self).check(ADMINISTRATE_SERVER); 
 if (serviceUser == null || !storage.get().getSubsections(USER) .contains(serviceUser.getUserName())) { 
 return permissionBackend.user(userProvider).testOrFalse( 
 c.message = message; c.unresolved = unresolved; 
 return new PluginPermission(plugin, ID); 
 return new PluginPermission(plugin, ID); 
 permissionBackend.user(userProvider).check(permission(pluginName)); 
 permissionBackend.user(userProvider).check(permission(pluginName)); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
import com.google.gerrit.server.permissions.PermissionBackendException; import com.google.gwtorm.server.OrmException; 
 * @throws AuthException, PermissionBackendException 
 private void checkPermission() throws AuthException, PermissionBackendException { 
 private void checkPermission() throws AuthException, PermissionBackendException, PermissionDeniedException { 
 throws AuthException, BadRequestException, OrmException, PermissionBackendException { 
 throws AuthException, BadRequestException, OrmException, PermissionBackendException { 
 throws AuthException, BadRequestException, OrmException, PermissionBackendException { 
<|del|> 
 new PluginPermission(pluginName, SaveReportCapability.ID)); 
<|del|> 
 protected void run() throws AuthException, PermissionBackendException { // Explicitly check that current user was granted plugin's own capability, 
 new PluginPermission(pluginName, AccessCiDatabaseCapability.ID)); 
 permissionBackend.user(userProvider).check( new PluginPermission(pluginName, SaveReportCapability.ID)); 
 // Explictly check that current user was granted plugin's own capability, // regardless of whether he is administrator or not. permissionBackend.user(userProvider).check( new PluginPermission(pluginName, AccessCiDatabaseCapability.ID)); 
 // Explictly check that current user was granted plugin's own capability, // regardless of whether he is administrator or not. permissionBackend.user(userProvider).check( new PluginPermission(pluginName, AccessCiDatabaseCapability.ID)); 
 permissionBackend.user(userProvider).check(permission(pluginName)); 
<|del|> 
 new PluginPermission(pluginName, AccessCiDatabaseCapability.ID)); 
 permissionBackend.user(userProvider).check(SaveReportCapability.permission(pluginName)); 
<|del|> 
 new PluginPermission(pluginName, CreateServiceUserCapability.ID)) || 
 Streams.stream(customTemplatesFilenames).map(fileUrlMapper()).collect(toList()), 
 Arrays.stream(config.getStringList("gitiles", null, "customTemplates")) 
 this(pluginName, capability, true); 
 final ThreeWayMerger m = newThreeWayMerger(repo, inserter); m.setBase(originalCommit.getParent(0)); if (m.merge(mergeTip, originalCommit)) { ObjectId tree = m.getResultTreeId(); if (tree.equals(mergeTip.getTree())) { 
 assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).files(2).keySet()) .containsExactly(COMMIT_MSG, MERGE_LIST, "foo"); 
 public String destination; // 40-hex digit SHA-1 of the commit which will be the parent commit of the newly created change. public String base; 
 /** Timestamp indicating when this group was created. */ 
 Timestamp createdOn = firstTimeMentioned.orElseGet(() -> Timestamp.from(AUDIT_CREATION_INSTANT)); 
 Timestamp createdOn = firstTimeMentioned.orElseGet(() -> Timestamp.from(AUDIT_CREATION_INSTANT)); 
 MetricRegistry registry) { 
<|del|> 
<|del|> 
Copyright (C) 2017 The Android Open Source Project 
 log.error("Error collecting projects", e); 
 log.error("Error waiting on project futures", e); 
Copyright (C) 2017 The Android Open Source Project 
 IndexGroupTask sameTask = task; assertThat(task.equals(sameTask)).isTrue(); assertThat(task.hashCode()).isEqualTo(sameTask.hashCode()); 
 rsp.setCharacterEncoding(UTF_8.name()); 
<|del|> 
<|del|> 
 assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).files().keySet()) .containsExactly(COMMIT_MSG, MERGE_LIST, "foo", "bar"); 
 private RevCommit getBaseCommit(Ref destRef, String project, RevWalk revWalk, String base) throws RestApiException, IOException, OrmException { 
 private RevCommit getBaseCommit(Ref destRef, String project, RevWalk revWalk, String base) throws RestApiException, IOException, OrmException { 
 final ThreeWayMerger m = newThreeWayMerger(repo, inserter); m.setBase(originalCommit.getParent(0)); if (m.merge(mergeTip, originalCommit)) { ObjectId tree = m.getResultTreeId(); if (tree.equals(mergeTip.getTree())) { 
<|del|> 
 public static void executeChecked(BatchRefUpdate bru, RevWalk rw) throws IOException { 
 * * <p>Does not retry in the case of lock failure; callers may use {@link * com.google.gerrit.server.update.RetryHelper}. * 
 gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).rebase(ri); 
 gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).rebase(ri); 
@Retention(RUNTIME) @Repeatable(GerritPluginConfigs.class) 
 * Runs the API's 'project.search' method to match exactly one project name 
 Map<String, Object> constraints = new HashMap<>(); 
<|del|> 
<|del|> 
<|del|> 
 throw new IOException(String.format("Action %s expects exactly %d parameter(s) but %d given", action, length, params.length -1)); 
 static class GlobalPluginConfigToGerritConfig implements GerritConfig { 
 null, // @GlobalPluginConfig is only valid on methods. null); // @GlobalPluginConfigs is only valid on methods. 
 null, // @GlobalPluginConfig is only valid on methods. null); // @GlobalPluginConfigs is only valid on methods. 
/** Index schema for projects. */ 
 prefix("name_part").buildRepeatable(p -> SchemaUtil.getNameParts(p.getProject().getName())); 
 ProjectField.NAME, ProjectField.DESCRIPTION, ProjectField.PARENT_NAME, ProjectField.NAME_PART, ProjectField.ANCESTOR_NAMES); 
 String testCanonicalUrl = "foo-url"; String testCdnPath = "bar-cdn"; TestIndexServlet servlet = new TestIndexServlet(testCanonicalUrl, testCdnPath); 
 extraReviewer = accountCreator.create("extraReviewer", "extraReviewer@example.com", "extraReviewer"); extraCcer = accountCreator.create("extraCcer", "extraCcer@example.com", "extraCcer"); 
 voter = accountCreator.create("voter", "voter@example.com", "voter"); 
 .notTo(ALL_COMMENTS); // TODO(logan): Why not? 
 other = accountCreator.create("other", "other@example.com", "other"); 
 assignee = accountCreator.create("assignee", "assignee@example.com", "assignee"); 
 if (notify == NotifyHandling.ALL || notify == NotifyHandling.OWNER_REVIEWERS) { 
 private static final Map<String, StagedUsers> stagedUsers = new HashMap<>(); // TestAccount doesn't implement hashCode/equals, so this set is according // to object identity. That's fine for our purposes. 
 Hasher h = Hashing.goodFastHash(32).newHasher(); 
 * @return the external ID that was removed, {@code null} if no external ID with the specified key * exists 
<|del|> 
 import com.google.common.base.Strings; 
 ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException { 
 other = accountCreator.create("other", "other@example.com", "other"); 
 @Mock private HttpSession.Factory sessionFactory; 
<|del|> 
<|del|> 
 throws AuthException, OrmException { 
 throws AuthException, OrmException { 
<|del|> 
<|del|> 
 protected void run() throws AuthException, UnloggedFailure { 
 throws RestApiException, OrmException, IOException { 
 private void verifyOne(PatchSet patchSet) throws UnloggedFailure { 
<|del|> 
 protected void run() throws AuthException { 
<|del|> 
<|del|> 
 throws BadRequestException, OrmException { 
@RequiresCapability(value = SaveReportCapability.ID, fallBackToAdmin = false) 
<|del|> 
 PostVerification(SchemaFactory<CiDb> schemaFactory) { 
 throws BadRequestException, OrmException { 
@RequiresCapability(value = SaveReportCapability.ID, fallBackToAdmin = false) 
<|del|> 
<|del|> 
 protected void run() throws UnloggedFailure { 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public static final FieldDef<ProjectState, Iterable<String>> ANCESTOR_NAME = exact("ancestor_name") .buildRepeatable( p -> Iterables.transform(p.parents(), parent -> parent.getProject().getName())); 
 return gerritId.get().accountId(); 
 public static String toChangeInEditMode(@Nullable Project.NameKey project, Change.Id c) { return toChangeNoSlash(project, c) + ",edit/"; 
 * @return the length of the {@code Change.Id} if no project was parsed from the token. The 
 return "savedReplyComment-" + PageLinks.toChangeId(project, changeId); 
 ChangeApi.blame(rev, Project.NameKey.asStringOrNull(project), path, isBase) 
 // TODO Make a preflight request to obtain project before we deprecate the numeric change id 
<|del|> 
 for (NotifyType watch : NotifyType.values()) { 
<|del|> 
 res.setHeader(ACCESS_CONTROL_ALLOW_HEADERS, Joiner.on(", ").join(ALLOWED_CORS_REQUEST_HEADERS)); 
 stdout.println(localDiskRepositoryManager.getBasePath(nameKey) .resolve(nameKey.get().concat(Constants.DOT_GIT_EXT))); 
 public void crossDomainPutTopic() throws Exception { 
 if (!ALLOWED_CORS_METHODS.contains(method)) { 
 Stream.of(AUTHORIZATION, CONTENT_TYPE, "X-Gerrit-Auth", "X-Requested-With") 
 @Nullable 
 @AutoValue public abstract static class QueryParams { 
<|del|> 
<|del|>
 assertThat(Iterables.all(files.keySet(), f -> f.matches(FILE_NAME + '|' + COMMIT_MSG))) 
<|del|> 
 private final ScheduledExecutorService executor; 
import java.io.OutputStream; import java.util.Collection; import java.util.concurrent.ExecutionException; import java.util.concurrent.ScheduledThreadPoolExecutor; import java.util.concurrent.TimeUnit; 
 @Inject private ChangeRebuilder rebuilder; 
<|del|> 
 NotesMigrationState( 
 /* * AddReviewerSender tests. */ 
 updates.add(getRepo(project).getUpdate().setRefLogMessage("merged")); 
 public static final StoredValue<AccountCache> ACCOUNT_CACHE = create(AccountCache.class); 
 public SubmitRuleEvaluator(ChangeData cd) throws OrmException { 
 OutgoingEmailValidator emailValidator) { this.readFromGit = cfg.getBoolean("user", null, "readAccountsFromGit", false); 
<|del|> 
<|del|> 
<|del|> 
 permissionBackend.user(self).check(GlobalPermission.ACCESS_DATABASE); 
 viewMetadata = permissionBackend.user(user).testOrFalse(GlobalPermission.ACCESS_DATABASE); 
 try { perm.check(GlobalPermission.ACCESS_DATABASE); } catch (AuthException | PermissionBackendException e) { 
<|del|> 
 if (!change.hasReviewStarted() && !workInProgress) { 
 protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException { 
 batchExecutor = queues.createQueue(batchThreads, "SSH-Batch-Worker", Thread.MIN_PRIORITY); 
 Preconditions.checkArgument(plk.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF); 
 accountCache.evictAllNoReindex(); 
 log.error("Sending a message over jgroups channel {} caused an error", channelName, e); 
 log.error("received an exception while trying to join jgroups channel", e); 
 InetAddress ret = null; 
 log.info("left jgroups channel {}", channelName); 
 log.info("left jgroups channel {}", channelName); 
<|del|> 
<|del|> 
import com.google.inject.Singleton; 
 RefPermission.DELETE)) { 
<|del|> 
 * @param threads thread count; if less than 2, all work happens in the calling thread. 
<|del|> 
<|del|> 
 return permissionBackend.user(currentUserProvider).testOrFalse(ADMINISTRATE_SERVER) || permissionBackend.user(currentUserProvider).testOrFalse( new PluginPermission(pluginName, CopyProjectCapability.ID)); 
 return permissionBackend.user(currentUserProvider).testOrFalse(ADMINISTRATE_SERVER) || permissionBackend.user(currentUserProvider).testOrFalse( new PluginPermission(pluginName, CopyProjectCapability.ID)); 
 return permissionBackend.user(currentUserProvider).testOrFalse(ADMINISTRATE_SERVER) || permissionBackend.user(currentUserProvider).testOrFalse( new PluginPermission(pluginName, CopyProjectCapability.ID)); 
<|del|> 
<|del|> 
 @Inject private AllUsersName allUsersName; 
 assertNotesMigrationState(NotesMigrationState.REVIEW_DB); 
 permissionBackend .user(userProvider) .project(new Project.NameKey(projectName)) .check(ProjectPermission.ACCESS); 
 return sortedEventsFromEntries(entries); 
 return sortedEventsFromEntries(entries); 
 } 
 if (revision == Revision.Old || revision == Revision.Both) { 
 if (revision == Revision.Old || revision == Revision.Both) { 
 if (tA != null && tA != Text.EMPTY) { 
 if (tB != null && tB != Text.EMPTY) { 
Copyright (C) 2017 The Android Open Source Project 
 * Returns true if any of the files that match FileNameRegex have edited lines * that match EditRegex in the new revision 
 * Returns true if any of the files that match FileNameRegex have edited lines * that match EditRegex in the new revision 
 * 'commit_new_edit'(+FileNameRegex, +EditRegex) 
Copyright (C) 2017 The Android Open Source Project 
 * Returns true if any of the files that match FileNameRegex have edited lines * that match EditRegex in the old revision 
 * Returns true if any of the files that match FileNameRegex have edited lines * that match EditRegex in the old revision 
 * 'commit_old_edit'(+FileNameRegex, +EditRegex) 
 @Nullable 
 log.atWarning().withCause(e).log("Cannot check project access permission"); 
 if (tA != Text.EMPTY) { 
 if (tB != Text.EMPTY) { 
 } catch (StringIndexOutOfBoundsException e) { 
 ChangeApi changeApi = gApi.changes() .id(r.getChangeId()); BinaryResult bin = changeApi .revision(r.getCommit().name()) .patch(); 
 ChangeApi changeApi = gApi.changes() .id(r.getChangeId()); BinaryResult bin = changeApi .revision(r.getCommit().name()) .patch(); 
 ChangeApi changeApi = gApi.changes() .id(r.getChangeId()); BinaryResult bin = changeApi .revision(r.getCommit().name()) .patch(FILE_NAME); 
 ChangeApi changeApi = gApi.changes() .id(r.getChangeId()); BinaryResult bin = changeApi .revision(r.getCommit().name()) .patch(FILE_NAME); 
 assertThat(current(r).actions().keySet()) .containsExactly("cherrypick"); 
<|del|> 
 @Singleton 
<|del|> 
 db.get(), resource.getChange().getProject(), currentUserProvider.get(), TimeUtil.nowTs())) { 
<|del|> 
<|del|> 
 String.format("Patch Set %s: Commit message was updated.", psId.getId())); inserter.setNotify(input.notify); inserter.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails)); 
 return Response.none(); 
 private boolean trial = true; // TODO(dborowitz): Default to false in 3.0. 
<|del|> 
 executor.remove(this); 
 EmailReviewComments.Factory email, PatchSetUtil psUtil, @Assisted boolean workInProgress, @Assisted Input in) { 
<|del|> 
 public ObjectId sha1() { 
 public static String toChangeId(@Nullable Project.NameKey project, Change.Id c) { if (project == null) { return String.valueOf(c.get()); } return project.get() + PROJECT_CHANGE_DELIMITER + c.get(); 
 return "/c/" + project.get() + PROJECT_CHANGE_DELIMITER + c; 
 DraftActions.publish(changeId, revision); 
 public void onKeyPress(final KeyPressEvent event) { 
 if (rev.isEdit()) { 
 } if (mrA == MatchResult.Fail || mrB == MatchResult.Fail) { break; } 
 ChangeApi.hashtags(null, psId.getParentKey().get()) 
 private void addHashtag(String hashtags) { ChangeApi.hashtags(project.get(), changeId.get()) 
<|del|> 
 call(project, id, commit, "publish").post(in, cb); 
 new ChangeScreen( project, changeId, base, rev, openReplyBox, FileTable.Mode.REVIEW)); 
 // TODO(hiesel) Make a preflight request to obtain project before we deprecate the numeric change id 
 // Provide a message using --message flag 
 } if (changeIdFooters.size() > 1) { throw new ResourceConflictException("multiple Change-Id footers"); } 
 @DefaultInput public String message; public NotifyHandling notify = NotifyHandling.ALL; public Map<RecipientType, NotifyInfo> notifyDetails; 
 protected Response<String> applyImpl( 
 String sanitizedCommitMessage = CommitMessageUtil.checkAndSanitizeCommitMessage(input.message); 
 String sanitizedCommitMessage = CommitMessageUtil.checkAndSanitizeCommitMessage(input.message); 
 throw new ResourceConflictException("new and existing commit message are the same"); 
 createCommit(objectInserter, patchSetCommit, sanitizedCommitMessage, ts); 
 return Response.ok("ok"); 
 private final AccountLimits.Factory limitsFactory; 
 private final class Listener implements ContinuationListener { final Future<?> future; 
 CurrentUser caller = rev.getUser(); PermissionBackend.ForChange perm = rev.permissions().database(db); 
 boolean allOf = isAllOf(arg3.dereference()); 
 /* When using the ALL_OF qualifier, if we had at least one EVALUATE_NEXT, * the predicate is TRUE. */ if (atLeastOneDiff && allOf) { return cont; } 
 if (!term.name().equals(ALL_OF) && !term.name().equals(ANY_OF)) throw new IllegalDomainException(this, 3, String.format("[%s, %s]", ANY_OF, ALL_OF), term); 
 if (!term.name().equals(ALL_OF) && !term.name().equals(ANY_OF)) throw new IllegalDomainException(this, 3, String.format("[%s, %s]", ANY_OF, ALL_OF), term); 
 testEnableSequences(0, 2, "12"); 
 testEnableSequences(-1, 502, "512"); 
 * <p>By default, uses the value from {@code noteDb.changes.initialSequenceGap} in {@code * gerrit.config}, which defaults to 1000. * * @param sequenceGap sequence gap size; if negative, use the default. 
<|del|>
public class ElasticVersionManager extends VersionManager { 
 private final Integer singleVersion; private final int threads; private final String base; 
 public void setActive(Boolean isActive) { 
 who.setActive(false); 
 commentAdded.fire( change, newPatchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen()); 
 protected void assertSubmittedTogether(String chId, String... expected) throws Exception { 
<|del|> 
 public static final Class<Schema_155> C = Schema_155.class; 
 * <p>This is typically a transient failure, such as a required group backend not responding to * membership requests. 
 gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).rebase(ri); 
import com.google.common.collect.ListMultimap; 
 throws ResourceNotFoundException, IOException, PermissionBackendException { 
 * @param tag Tag name 
 tag.replace("project", encode(projectName)).replace("tag", encode(tagName)).toString()); 
 * its url to all channel members. 
 createBranch(new Branch.NameKey(project, "foo")); 
 return ListTags.createTagInfo(perm, result, w, projectName, links); 
 PermissionBackend.ForRef perm, Ref ref, RevWalk rw, Project.NameKey projectName, WebLinks links) 
 tags.add( createTagInfo(perm.ref(ref.getName()), ref, rw, pctl.getProject().getNameKey(), links)); 
 PermissionBackend.ForRef perm, Ref ref, RevWalk rw, Project.NameKey projectName, WebLinks links) throws MissingObjectException, IOException { 
<|del|> 
 return ListTags.createTagInfo(perm, result, w, resource.getNameKey(), links); 
 WebLinks webLinks) { 
 tags.add(createTagInfo(perm.ref(ref.getName()), ref, rw, pctl.getProject().getNameKey(), links)); 
 tags.add(createTagInfo(ref, rw)); 
<|del|> 
 // Check that we populate the label data in the HTTP path. See GetProjectIT#getProject // for more extensive coverage of the LabelTypeInfo. 
 // Check that we populate the label data in the HTTP path. See GetProjectIT#getProject // for more extensive coverage of the LabelTypeInfo. 
 throw new ResourceNotFoundException(p.getName()); 
 if (input.pluginConfigValues != null) { ConfigInput in = new ConfigInput(); in.pluginConfigValues = input.pluginConfigValues; putConfig.get().apply(projectControl, in); } return Response.created(json.format(projectControl)); 
<|del|> 
 // Yes, this is evil. It's not known the input was safe. 
 System.out.println(" reindex " + String.join(" ", reindexArgs)); 
 Collection<Comment> comments = cd.publishedComments() .stream() .filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)) .sorted(CommentsUtil.COMMENT_ORDER) .collect(toList()); 
 Pop3MailReceiver(EmailSettings mailSettings, MailProcessor mailProcessor, 
 private static String getString(Config cfg, String section, String subSection, String name, String defaultValue) { String value=cfg.getString(section, subSection, name); return ((value == null) ? defaultValue : value); } 
 throw new ProvisionException(SHARED_DIRECTORY_KEY + " must be configured"); 
<|del|> 
<|del|> 
 public static final String START_REVIEW_MESSAGE = "This change is ready for review."; 
 + "Content-Transfer-Encoding: " + textTransferEncoding + "\r\n" 
 try (QuotedPrintableOutputStream qp = new QuotedPrintableOutputStream(s, false)) { qp.write(input.getBytes(UTF_8)); } 
 return draftByChange(db, notes).stream().filter(p).findFirst(); 
 comment = new Comment(origComment); 
 "uploadpackLimitExceededMsg", DEFAULT_RATE_LIMIT_EXCEEDED_MSG); 
 this.rw = null; this.reader = null; 
 log.error(String.format("invalid value for %s; using default value %s", STRATEGY_KEY, DEFAULT_PEER_INFO_STRATEGY)); 
 return; } 
 .contains("<h1><a class=\"h\" name=\"page\" href=\"#page\"><span></span></a>page</h1>"); 
 return; } 
 "{} members joined the jgroups channel {}. Only two members are supported. Members: {}", view.getMembers().size(), channel.getName(), view.getMembers()); 
 log.error("Failed to parse codeserver arguments"); 
 ChangeApi.hashtags(screen.getProject().get(), psId.getParentKey().get()) 
 Gerrit.display(PageLinks.toChange(screen.getProject(), psId)); 
 return "savedReplyComment-" + PageLinks.toChangeId(project, changeId); 
 String mutableToken = token; 
 DiffApi.diff(Project.NameKey.asStringOrNull(project), revision, nextPath) 
 @Nullable Project.NameKey project, 
 private final PatchSet.Id revision; @Nullable private final Project.NameKey project; 
 // TODO(hiesel) Make a preflight request to get project before we deprecate the numeric changeId 
 if (accountSeq == null) { @SuppressWarnings("deprecation") RepoSequence.Seed accountSeed = () -> db.nextAccountId(); 
 "gerrit", null, "basePath", tempSiteDirFile.toPath().resolve("git").toString()); 
 "gerrit", null, "basePath", tempSiteDirFile.toPath().resolve("git").toString()); 
 delay = Math.max(0, getInt(remoteConfig, cfg, "replicationdelay", DEFAULT_REPLICATION_DELAY)); rescheduleDelay = Math.max(3, getInt(remoteConfig, cfg, "rescheduledelay", DEFAULT_RESCHEDULE_DELAY)); 
 return sitePaths.resolve(CharMatcher.is('/').trimLeadingFrom( req.getServletPath() + req.getPathInfo())); 
 myUrl = u.setHost(hostName).toString(); 
 "{} members joined the jgroups channel {}. Only two members are supported. Members: {}", view.getMembers().size(), channel.getName(), view.getMembers()); 
 "{} members joined the jgroups channel {}. Only two members are supported. Members: {}", view.getMembers().size(), channel.getName(), view.getMembers()); 
 // channel communication caused an error. Can't do much about it. 
 // channel communication caused an error. Can't do much about it. 
 * whose name matches {@link #skipInterfacePattern} are also ignored. By that it is possible to * skip interfaces which should not be used by jgroups (e.g. 'lo0', 'utun0' on MacOS). 
 * whose name matches {@link #skipInterfacePattern} are also ignored. By that it is possible to * skip interfaces which should not be used by jgroups (e.g. 'lo0', 'utun0' on MacOS). 
 private final String pluginName; 
 "INFO: Assuming default (%d s) for remote.%s.rescheduleDelay\n", 
 "INFO: Assuming default (%d s) for remote.%s.rescheduleDelay\n", 
 } else if (!Strings.isNullOrEmpty(matchRegex)) { 
 private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws BadRequestException, OrmException { 
 private List<AccountGroup> filterGroups(Collection<AccountGroup> groups) throws BadRequestException { 
<|del|> 
<|del|> 
 log.error("Sending a message over jgroups channel {} failed", channelName, e); 
 if (canonicalURL == null) { 
<|del|> 
<|del|> 
<|del|> 
 .build(cd -> cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null); 
 public abstract Account.Id author(); public abstract Timestamp ts(); 
Copyright (C) 2017 The Android Open Source Project 
 if (cd.change().getRevertOf() == null) { return false; } return cd.change().getRevertOf().toString().equals(value); 
<|del|> 
 if (pl instanceof LargeObjectTombstone) { 
 fileCache.put(key, new LargeObjectTombstone()); 
 /** * Invalidate the cached information about the given project, and triggers reindexing for it * * @param p project that is being evicted * @throws IOException thrown if the reindexing fails */ 
<|del|> 
 final String msg = "Cannot reindex project: " + name; 
 return projectState.controlFor(user).canRead(); 
 return projectState.controlFor(user).canRead(); 
 distances.add(new Integer(distance)); 
<|del|> 
 private Account read(Account.Id accountId) throws IOException, ConfigInvalidException { try (Repository repo = repoManager.openRepository(allUsersName)) { AccountConfig accountConfig = new AccountConfig(emailValidator, accountId); accountConfig.load(repo); return accountConfig.getAccount(); } 
 ImmutableSetMultimap<String, ExternalId> byEmails(String... emails) throws IOException; 
<|del|> 
import com.googlesource.gerrit.plugins.quota.AccountLimitsConfig.Type; import java.util.concurrent.atomic.AtomicInteger; 
 @Test public void deleteDraft() throws Exception { PushOneCommit.Result r = createDraftChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).delete(); } @Test 
 assertWithMessage(session.getError()).that(session.hasError()).isFalse(); 
 } else if (!allowDrafts && rsrc.getChange().getStatus() == Change.Status.DRAFT) { // If drafts are disabled, only an administrator can delete a draft. 
 @Option(name = "--draft", usage = "Currently disabled, will be removed: " + "mark new/updated changes as draft") 
 protected static Predicate<ChangeData> create(Arguments args, Predicate<ChangeData> p) { if (!args.allowsDrafts) { return Predicate.and(p, Predicate.not(new ChangeStatusPredicate(Change.Status.DRAFT))); } return p; 
public abstract class MoveDialog extends TextAreaActionDialog { 
 String refsHeads = "refs/heads/"; 
 .user(rsrc.getUser()) 
 MoveAction.call(move, changeInfo, project); 
 MoveAction.call(move, changeInfo, changeId, project); 
 static void call(Button b, ChangeInfo info, Change.Id id, Project.NameKey project) { 
<|del|> 
 protected void allow(Project.NameKey projectName, String permission, AccountGroup.UUID id, String ref) throws Exception { 
import com.google.gerrit.common.data.AccessSection; import com.google.gerrit.common.data.ContributorAgreement; 
<|del|> 
 s = s.skip(start); 
 } 
 String project, 
 assertPlugins(list().start(1).limit(2).get(), PLUGINS.subList(1, 3)); 
 protected PushOneCommit.Result tryPushToDraftsMaster() throws Exception { 
 public void createNewDraftChangeNotAllowed() throws Exception { 
 super(Util.C.moveTitle(), Util.C.moveChangeMessage()); 
 super(Util.C.moveTitle(), Util.C.moveChangeMessage()); 
 NoteDbBatchUpdate.AssistedFactory noteDbBatchUpdateFactory) { 
 enum ToolType { Repo } 
 ToolType toolType; 
class Utils { 
<|del|> 
<|del|> 
 List<ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit); if (!changes.isEmpty()) { 
 return IncludedInResolver.includedInAny(repo, rw, commit, refs.values()); 
 revision = onBehalfOf(revision, labelTypes, input); 
 args.groups.getMembers(db, ig.getId()).forEach(matching.accounts::add); 
 throws OrmException { if (isMember(db, groupId, accountId)) { return; } 
<|del|> 
 private Set<AccountGroup.UUID> parseGroups(List<String> groups) 
 public static class PatchSetDbImpl implements PatchSetDb { 
 private final Provider<CurrentUser> user; private final PermissionBackend permissionBackend; 
 private final Provider<CurrentUser> user; private final PermissionBackend permissionBackend; 
 .user(rsrc.getUser()) 
<|del|> 
 return test(valuesOf(checkNotNull(label, "LabelType"))); 
 if (autoUpdateAccountActiveStatus && who.authProvidesAccountActiveStatus()) { 
 return setInactiveFlag.deactivate(rsrc.getUser()); 
 return setInactiveFlag.activate(rsrc.getUser()); 
 private final WorkQueue queue; private final AccountDeactivator deactivator; private final AccountDeactivatorConfig cfg; private final boolean supportAutomaticAccountActivityUpdate; 
 @Deprecated static final Schema<ChangeData> V45 = schema(V44, ChangeField.REVERT_OF); 
 GroupInfo group = loadGroup(visibleGroups, groupId); 
 private GroupInfo loadGroup( Map<AccountGroup.UUID, GroupInfo> visibleGroups, AccountGroup.UUID id) { 
 static final int DEFAULT_MAX_CONNECTIONS = 8; 
 return getFilePaths(PatchListKey.againstDefaultBase(b, ws), project); 
<|del|> 
 List<String> patterns = new ArrayList<>(DEFAULT_PATTERNS); patterns.addAll(cfg.cache().getPatterns()); 
<|del|> 
<|del|> 
 if (changeSource.cardinality() == n) { 
 public void changeRefReplicated() throws URISyntaxException, OrmException, PermissionBackendException { 
 if (!canRead(ctl)) { 
 && !isDraftVisible(db, null)) { 
 return filePaths(currentPatchSet); 
<|del|> 
 if (requestContext != null) { requestContext.setContext(null); } 
 schema151.migrateData(db, new TestUpdateUI()); 
 public <T> T execute(Action<T> action, Options opts) throws RestApiException, UpdateException { 
<|del|> 
 return new TreeMap<>(s.collect(Collectors.toMap(p -> p.getName(), p -> toPluginInfo(p)))); } 
 return def; 
 * Create an instance for testing only. * <p> * Attempting to lazy load data will fail with NPEs. Callers may consider * manually setting fields that can be set. 
 @Nullable 
 rsp.setStatus(SC_OK); try (OutputStream w = rsp.getOutputStream()) { 
 if (Strings.isNullOrEmpty(canonicalWebUrl)) { 
 } } finally { git.close(); 
<|del|> 
<|del|> 
<|del|> 
 return String.format("%s (%s) => %s", src(), toolType, dest()); 
<|del|> 
 return false; 
 return false; 
 return false; 
 cfg.setBoolean("submodule", path, "shallow", true); 
 * Prompts the user for a string, suggesting a default. 
 /** Prompt the user for a string, suggesting a default, and returning choice. */ String readString(String defaultValue, Set<String> allowedValues, String message); 
 /** Prompt the user for a string, suggesting a default, and returning choice. */ String readString(String defaultValue, Set<String> allowedValues, String message); 
 /** Requests the user to answer a yes/no question. */ 
 /** Prints a message asking the user to let us know when it's safe to continue. */ 
 /** * Prompts the user for a string, suggesting a default, and returning choice. * * @return the chosen string from the list of allowed values. */ 
 /** * Prompts the user for a string, suggesting a default, and returning choice. * * @return the chosen string from the list of allowed values. */ 
<|del|> 
 * @return whether the query could be retried with a higher start/limit to produce more results. * Never true if {@link #entities()} is empty. 
 private static StagedResult create( Change.Id id, NoteDbChangeState.Delta delta, OpenRepo changeRepo, OpenRepo allUsersRepo) { 
<|del|> 
<|del|> 
 private final PermissionBackend permissionBackend; private final ProjectCache projectCache; 
<|del|> 
 url = new StringBuffer(URLDecoder.decode(url.toString(), UTF_8.name())); 
 // Only measure successful queries that actually touched the index. metrics.executionTime.record( schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS); 
<|del|> 
 List<DiffEntry> diffEntries = df.scan(aTree, bTree); 
 return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()])); 
 /** * ID of the note blob in the external IDs branch that stores this external ID. {@code null} if * the external ID was created in code and is not yet stored in Git. */ 
 updatedExtId.checkThatBlobIdIsSet(); 
 PatchListCacheImpl.LargeObjectTombstone tombstone = new PatchListCacheImpl.LargeObjectTombstone(); abstractPatchListCache.put(key, tombstone); assertThat(abstractPatchListCache.getIfPresent(key)).isSameAs(tombstone); 
 // Please keep this method for the moment even though it is unused. 
 protected static DataSource createDataSource(String url) { 
<|del|> 
 changeNotes.add(create(db, project, id)); 
import com.google.gerrit.index.SiteIndexer; 
 assertQuery("name:" + group.name, group); assertQuery("name:" + group.name.toUpperCase(Locale.US), group); 
<|del|> 
 accounts.add(getChange().getOwner()); if (getChange().getAssignee() != null) { accounts.add(getChange().getAssignee()); } 
 byte[] buf = new byte[20]; 
 // Including removed reviewers is a cheap way of making sure that the states of accounts that 
 MoreObjects.firstNonNull(accountState.getAccount().getMetaId(), ZERO_ID_STRING), UTF_8); accountState.getExternalIds().stream().forEach(e -> hashObjectId(h, e.blobId(), buf)); 
 ACTIVE(true, true), READ_ONLY(true, false), HIDDEN(false, false); 
 * than two. But will always pick the first node which sent its url as the peer to be returned by 
 * than two. But will always pick the first node which sent its url as the peer to be returned by 
 assertThat(Iterables.getOnlyElement(values)).isEqualTo(expectedValue); 
 assertThat(values).containsExactly(expectedValue1, expectedValue2); 
 /** Only the HTTP password is accepted when doing Git over HTTP and REST API requests. */ 
 /** Only the `OAUTH` authentication is allowed when doing Git over HTTP and REST API requests. */ 
 Change.Id changeId = checkNotNull(Change.Id.fromRef(cmd.getRefName())); 
 public static final FieldDef<InternalGroup, Iterable<Integer>> MEMBER = integer("member") 
 public static final FieldDef<InternalGroup, Iterable<Integer>> MEMBER = integer("member") 
 public static final FieldDef<InternalGroup, Iterable<String>> SUBGROUP = exact("subgroup") 
 InternalGroup adminGroup = getFromCache("Administrators"); 
 InternalGroup adminGroup = getFromCache("Administrators"); 
 && authType != AuthType.LDAP_BIND) { 
<|del|> 
 * Retrieve edit for a change and the given user. 
 private final Provider<CurrentUser> userProvider; 
 private final PatchSetUtil psUtil; 
<|del|> 
 jgroups = new PeerInfoJGroups(cfg); 
 public static class PeerInfoJGroups { private final ImmutableList<String> skipInterface; private final String clusterName; 
 promptAndSetString("JGroups cluster name", JGROUPS_SECTION, CLUSTER_NAME_KEY, null); 
 log.error("Sending a message over jgroups channel {} failed", channelName, e); 
 log.error("joining jgroups channel {} failed", e); 
 private Optional<InetAddress> findDefaultAddress() throws SocketException { 
 } if (!preferIPv4 && ret instanceof Inet6Address) { return Optional.of(ret); } 
<|del|> 
 private Configuration.PeerInfoJGroups jgroupsConfig; 
 InetAddress a = inetAddresses.nextElement(); if (preferIPv4 && a instanceof Inet4Address) { return Optional.of(a); 
 LOG.warn("NoSuchGroupException; ignoring group " + id, e); 
 private GroupInfo loadGroup(Map<AccountGroup.UUID, GroupInfo> visibleGroups, AccountGroup.UUID id) throws OrmException { 
 } catch (NoSuchGroupException e) { LOG.warn("NoSuchGroupException; ignoring group " + id); 
 private void parseAdditionalOptions(String prefix, Object bean, Set<Object> parsedBeans) { 
 LabelTypes labelTypes = ctl.getProjectControl().getProjectState().getLabelTypes(ctl.getNotes(), ctl.getUser()); 
 } 
 * whose name matches a {@code skipInterface} are also ignored. By that it is possible to skip 
 connection.prepareStatement("DELETE FROM account_groups WHERE group_id = ?"); 
 throw new IOException( String.format("CAS response missing attributes: %s", response.getBody())); 
 public Predicate<InternalGroup> subgroup(String query) throws QueryParseException { if (isFieldAbsentFromIndex(GroupField.SUBGROUP)) { 
public abstract class InternalGroup implements Serializable { private static final long serialVersionUID = 1L; 
 } @Override public void stop() { log.info("closing jgroups channel {}", jgroupsConfig.clusterName()); channel.close(); peerInfo = Optional.absent(); peerAddress = null; } 
 @Singleton 
 } 
 * whose name matches a {@code #skipInterface} are also ignored. By that it is possible to skip 
<|del|> 
 private final Configuration.PeerInfoStrategy strategy; 
 private final PeerInfoStrategy strategy; 
 private final PeerInfoStrategy strategy; 
 IOException, AuthException, BadRequestException, UnprocessableEntityException{ 
 @Singleton 
<|del|> 
 void applyChanges( 
<|del|> 
 * Checks that the removals and additions are logically valid, but doesn't check current user's 
 List<AccessSection> deductions = getAccessSections(input.deductions); List<AccessSection> additions = getAccessSections(input.additions); MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get(); 
 ProjectConfig config; ObjectId base; 
 AccessSection accessSection = new AccessSection(entry.getKey()); 
<|del|> 
<|del|> 
 config.remove(config.getAccessSection(section.getName())); continue; 
<|del|> 
 newParentProjectName.get(), 
 } catch (OrmException e) { throw new RestApiException("Cannot parse reviewer", e); 
 } catch (OrmException e) { throw new RestApiException("Cannot parse reviewer", e); 
 private String claimedOriginal; 
 claimedOriginalCommit = rw.parseCommit(ObjectId.fromString(claimedOriginal)); 
 merger.setBase(claimedRevertCommit.getParent(0)); merger.merge(claimedRevertCommit, claimedOriginalCommit); 
<|del|> 
 private Path sharedDir; 
 private Path sharedDir; 
 "Connection timeout [ms]", HTTP_SECTION, CONNECTION_TIMEOUT_KEY, str(DEFAULT_TIMEOUT_MS)); 
 name = "--claimed-original", 
 private String claimedOriginal; 
 return checkAccess.apply(checkExists(), in); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 } catch (Exception e) { throw asRestApiException("Cannot list branches", e); 
 bu.addPostOp(new Callable<Void>() { 
 public Project project; 
<|del|> 
 * Check if the current patchset of the specified change has dependent unmerged changes. 
 log.info("myUrl not configured; attempting to determine from {}", LISTEN_URL); 
<|del|> 
 ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException { 
 .user(rsrc.getUser()) .project(rsrc.getNameKey()) 
 if (!rsrc.getControl().isOwner()) { 
 md.setMessage("Review access change"); 
 rsrc.getNameKey(), rsrc.getUser(), 
 rsrc.getNameKey(), rsrc.getUser(), 
 return Response.created(jsonFactory.noOptions().format(ins.getChange())); 
 return Response.created(jsonFactory.noOptions().format(ins.getChange())); 
 .containsExactly(problem("Destination repository not found: " + name)); 
 private void assertNoProblems(ChangeNotes notes, @Nullable FixInput fix) throws Exception { 
 private ChangeControl controlForNotes(ChangeNotes notes) throws Exception { 
<|del|> 
<|del|> 
 throws Exception { 
 throws OrmException, AuthException, ResourceNotFoundException { 
<|del|> 
 } ChangeControl ctl; try { ctl = changeControlFactory.controlFor(change, user.get()); } catch (NoSuchChangeException e) { throw new ResourceNotFoundException(String.format("Change %s not found", id)); } 
<|del|> 
<|del|> 
 public Response<AccessCheckInfo> apply(ProjectResource rsrc, AccessCheckInput input) 
 private MergeableFileBasedConfig newConfig() throws Exception { File f = File.createTempFile(getClass().getSimpleName(), ".config"); f.deleteOnExit(); return new MergeableFileBasedConfig(f, FS.detect()); 
 return changeResourceFactory.create(controlFor(change)); 
 RevisionResource rev = rsrc.getRevision(); ObjectId revstr = ObjectId.fromString(rev.getPatchSet().getRevision().get()); return fileContentUtil.downloadContent( projectCache.checkedGet(rev.getProject()), revstr, path, parent); 
<|del|> 
 RevCommit claimedRevertCommit = rw.parseCommit(ObjectId.fromString(currentPatchSet.getRevision().get())); 
import org.scribe.model.OAuthConfig; import org.scribe.model.OAuthConstants; import org.scribe.model.OAuthRequest; import org.scribe.model.Response; import org.scribe.model.Token; import org.scribe.model.Verb; import org.scribe.model.Verifier; 
 rootUrl, config.getApiKey(), OAuthEncoder.encode(config.getCallback()), config.getScope().replaceAll(" ", "+")); 
 // TODO can't use this until updating to newer scribe lib // return new OAuth20ServiceImpl(this,config); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public static final Class<Schema_159> C = Schema_159.class; 
 pushFactory.create( db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId()); 
import com.google.gerrit.server.patch.PatchSetInfoFactory; import com.google.gerrit.server.project.InvalidChangeOperationException; 
<|del|> 
 exception.expect(RestApiException.class); exception.expectMessage("input requires 'account'"); 
 exception.expect(RestApiException.class); exception.expectMessage("doesnotexist@invalid.com"); 
<|del|> 
<|del|> 
 exception.expectMessage("cannot find account doesnotexist@invalid.com"); 
 exception.expect(BadRequestException.class); 
 exception.expect(UnprocessableEntityException.class); 
 new TestCase(user.email, secretProject.get(), null, 403), 
 public AccessCheckInfo apply(ProjectResource rsrc, AccessCheckInput input) 
 System.out.format( "Reindexed %d documents in %s index in %.01fs (%.01f/s)\n", n, def.getName(), t, n / t); 
 public static class InvalidHashtagException extends Exception { 
<|del|> 
<|del|> 
 queue .getDefaultQueue() .scheduleAtFixedRate(deactivator, delay, interval, TimeUnit.MILLISECONDS); 
<|del|> 
 /** @return true if the account is active. * @throws NamingException * @throws LoginException * @throws AccountException */ default boolean isActive(String username) throws LoginException, NamingException, AccountException{ 
<|del|> 
 * cannot be located, is unable to be activated or deactivated, or is inactive, or cannot be 
 supportAutomaticAccountActivityUpdate = 
 default boolean isActive(@SuppressWarnings("unused") String username) 
 for (Account acc : accounts.all()) { if (acc.isActive() && !realm.isActive(acc.getUserName())) { sif.deactivate(genericUserFactory.create(acc.getId())); } } 
 boolean shouldProcess(); 
 public GerritEventProcessor create(ProjectEvent event, Config cfg, String name) { return new GerritEventProcessor(event, cfg, name); 
<|del|> 
 boolean shouldProcess(); 
<|del|> 
 "\nwrong syntax\n#comment\nuser1@google.com\n", 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 .map(ProjectControl::getProjectState) .map(ProjectState::getAllGroups) 
 for (Account.Id id : (Iterable<Account.Id>) Accounts.readUserRefs(repo)::iterator) { 
 // Reload gerrit.config/notedb.config on each migrator invocation, in case a previous // migration in the same process modified the on-disk contents. This ensures the defaults for // trial/autoMigrate get set correctly below. 
 // Removal of draft change workflow requires reindexing static final Schema<ChangeData> V47 = schema(V46); 
 public static final String NEW_CHANGE = "refs/for/"; // TODO: remove after 'repo' supports private/wip changes. public static final String NEW_DRAFT_CHANGE = "refs/drafts/"; 
 ProjectState pe = projectCache.get(branchName.getParentKey()); 
 } catch (IOException e) { // Intent of 'try' function is to ignore these. 
 try (ReviewDb db = schema.open()) { 
 dialect.dropIndex(e, "accounts", "accounts_byFullName"); 
 public static final Class<Schema_160> C = Schema_160.class; 
 .collect(toList())); 
<|del|> 
<|del|> 
<|del|> 
 IdentifiedUser.GenericFactory userFactory) { 
 .setLabel("Mark Reviewed") 
 .setLabel("Mark Unreviewed") 
 setOriginalValue(v); 
 assertThat(notes.getApprovals()) 
 * </pre> 
<|del|> 
<|del|> 
 return info; 
 Pattern p = Pattern.compile("^Error in operator (.*:self|is:watched|is:owner|is:reviewer|has:.*)$"); 
 public QueryRequiresAuthException(String message) { 
 return "<gerrit." + change.getCreatedOn() + "." + change.getKey().get() + "." + this.getGerritHost() + ">"; 
 public QueryRequiresAuthException(String msg, Throwable why) { 
 if (visible) { 
 /** Change builder for helping in tests for dashboard sections. */ 
<|del|> 
 @Override 
<|del|> 
<|del|> 
 private static List union(List... others) { 
 if (magicBranch != null && magicBranch.publish) { addMessage("Pushing to refs/publish/* is deprecated, use refs/for/* instead."); 
 .setChange(u.notes.getChange()) 
 File dir = FileKey.resolve(new File(path, name.get()), FS.DETECTED); 
 "must be either project owner or have %s permission", 
 /** Allow write access to refs/meta/config. */ 
 /** Allow banning commits from Gerrit preventing pushes of these commits. */ 
<|del|> 
 try { permissionBackend .user(rsrc.getUser()) .project(rsrc.getNameKey()) .check(ProjectPermission.WRITE_CONFIG); } catch (AuthException ae) { throw new AuthException("not allowed to see HEAD"); } 
 @Inject 
 taskFactory.create(projectEvent, remote).schedule(); 
 String process(ProjectEvent event, RemoteConfig remote); 
 PostTask create(ProjectEvent event, RemoteConfig remote); 
 HashSet<Account.Id> replyAccounts = new HashSet<>(); 
 HashSet<String> visitedUuids = new HashSet<>(); 
 String listId = String.format("<gerrit-%s.%s>", project.get(), hostname); String unsubscribeLink = String.format("<%ssettings>", canonicalWebUrl.get()); 
 logger.info("No such project: {}", cd.project()); 
 logger.info("No such project: {}", cd.project()); 
 logger.info("No such project: {}", cd.project()); 
<|del|> 
 * sequentially on the local Gerrit instance. 
 */ @ExtensionPoint 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 /* * Copied from https://github.com/eclipse/jgit/blob/e9fb111182b55cc82c530d82f13176c7a85cd958/org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java#L729 */ 
 // Test that first party gerrit repos are represented by relative URLs in supermanifest and // external repos by their absolute URLs. 
 throw new UnloggedFailure(e.getMessage()); 
 protected void grant( Project.NameKey project, String ref, String permission, boolean force, AccountGroup.UUID groupUUID) throws RepositoryNotFoundException, IOException, ConfigInvalidException { 
<|del|> 
 private final RemoteConfig.Factory remoteFactory; 
 // methods were added in order to make configuration // extensible in EvenptProcessor implementations 
 // methods were added in order to make configuration // extensible in EvenptProcessor implementations 
 } catch (IllegalArgumentException e) { 
 if (!inMemoryTest) { 
 public static class Module extends AbstractModule { @Override protected void configure() { DynamicItem.bind(binder(), ProjectNameLockManager.class) .to(DefaultProjectNameLockManager.class); } 
<|del|> 
 import java.io.IOException; import java.util.Optional; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; import javax.net.ssl.SSLException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; 
 HttpResult result = session.post(url, content.get().headers, content.get().body); if (!result.successful && execCnt < cfg.getMaxTries()) { 
<|del|> 
 assertThat(reviewers).doesNotContain(user.id); 
 public void respectTopicsOnAncestors() throws Exception { 
<|del|> 
<|del|> 
<|del|> 
 HttpResult post(String endpoint, EventProcessor.Request request) throws IOException { 
 HttpResult result = session.post(url, content.get()); 
 } 
 ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS); 
 // In jiri if import is pinned to a revision and // we have a corresponding project, jiri would like to // pin that project to same revision. So passing key to match // project to import tag. 
 try { permissionBackend.user(user).change(change).database(db).check(ChangePermission.READ); } catch (AuthException e) { throw new UnprocessableEntityException("Read not permitted for " + baseChange); 
 @ImplementedBy(PatchSetDbImpl.class) 
<|del|> 
 @ImplementedBy(PatchSetDbImpl.class) 
 @XmlAttribute String revision; 
 static class ManifestItem { public ManifestItem( String repoKey, String manifest, String ref, String pKey, boolean revisionPinned) { 
 if (revision != null) { rw.reset(); 
// TODO(aliceks): Add Javadoc descriptions to this file. Mention that this class must only be used // by GroupConfig and that other classes have to use InternalGroupUpdate! 
 checkSameGroup(group, groupControl); 
 fireProjectIndexedEvent(nameKey.get()); } else { for (ProjectIndex i : getWriteIndexes()) { i.delete(nameKey); } 
 public void allTimestampsExceptUpdatedAreEqualDueToBadMigration() throws Exception { 
 !timestampsDiffer(bundleA, aCreated, bundleB, bundleB.getFirstPatchSetTime()); 
 // A bug in data migration might set created_on (and a host of other timestamps) to the time // the dump was imported. The correct timestamps were lost, but we can at least set it so 
 // A bug in data migration might set created_on, along with host of other timestamps, to the // time of the migration. The correct timestamps were lost, but we can at least set it so 
 e.execute("UPDATE changes SET status = 'n', created_on = created_on WHERE status = 's'"); 
 msgbuf.append(" to " + newCommit.getName()); 
 } 
 // returns non-empty content 
 // returns non-empty content 
 .setConnectionManager(create(socketMgr.get())) 
 install( new LifecycleModule() { @Override protected void configure() { listener().to(ProjectCacheWarmer.class); listener().to(ProjectCacheClock.class); } }); 
 assertThat(Version.getVersion()).matches(expected); // Try again in case of caching issues. 
 GerritLauncher.isRunningInEclipse() 
Copyright (C) 2012 The Android Open Source Project 
 private final Provider<CurrentUser> user; private final PermissionBackend permissionBackend; 
 permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER); 
 throws CommitValidationException { // Groups are stored inside 'refs/groups/' refs inside the 'All-Users' repository. 
 throws MergeValidationException { // Groups are stored inside 'refs/groups/' refs inside the 'All-Users' repository. 
 if (isGroupsMutationDisallowed(config.getName()) && section.getName().startsWith(RefNames.REFS_GROUPS)) { 
 protected DefaultHttpClientProvider(Configuration cfg) { super(cfg, socketFactoryProvider()); 
<|del|> 
 private Stream<String> getCommitFootersForMemberModifications( 
 return Stream.concat(removedMembers, addedMembers); 
 if (currentUser == null) { 
 "Permissions on %s are managed by Gerrit and cannot be modified", 
 "Permissions on %s are managed by Gerrit and cannot be modified", 
 if (!refUpdated(result) && result != Result.NO_CHANGE) { 
<|del|> 
 return (o instanceof AccountGroupById) && Objects.equals(key, ((AccountGroupById) o).key); 
 @Deprecated public String ownerId; public Timestamp createdOn; public Boolean _moreGroups; 
 * @param allUsersRepo All-Users repository. * @param metaDataUpdateFactory Factory to create a {@link MetaDataUpdate}, required for updating * the group owner. Can be {@code null} if the group owner is read-only. 
 * @param allUsersRepo All-Users repository. * @param metaDataUpdateFactory Factory to create a {@link MetaDataUpdate}, required for updating * the group owner. Can be {@code null} if the group owner is read-only. 
 for (String permission : ImmutableList.of(Permission.READ, Permission.PUSH)) { accessSection .getPermission(permission, true) .add(new PermissionRule(newOwnerGroupReference)); } 
 // Don't rely on injection to construct Sequences, as it requires ReviewDb. 
 * <p><This class implements a one-way synchronization from the the global {@code CREATE_GROUP} * capability in {@code All-Projects} to a {@code CREATE} permission on {@code refs/groups/*} in * {@code All-Users}. 
<|del|> 
 * refs/groups/*} have diverged and syncs them by applying the {@code CREATE} permission to {@code 
 checkNotNull(allUsersState, "Can't obtain project state for " + allUsers); 
 createGroupsRef.addAll(create.getRules()); 
 private Branch.NameKey testBranch; 
 return !head.equals(ObjectId.fromRaw(Iterables.getOnlyElement(result))); 
 /** Parse an {@link AccountGroup.UUID} out of a ref-name. */ 
 * Parse an {@link AccountGroup.UUID} out of a part of a ref-name. 
<|del|> 
<|del|> 
 if (projectState.getProject().getState() == com.google.gerrit.extensions.client.ProjectState.HIDDEN) { 
 if (projectState.getProject().getState() == com.google.gerrit.extensions.client.ProjectState.HIDDEN) { 
 d2.setIncrement(4000); 
 return load(DEFAULT_REF, expectedValue); 
 groupSeq.increaseTo(groupId + 1); // NoteDb stores next available group ID. 
 .map(ImmutableSet::copyOf) .filter(members -> !originalMembers.equals(members)); if (updatedMembers.isPresent()) { 
 new PersonIdent( GroupsUpdate.getAccountName(accountCache, anonymousCowardName, id), GroupsUpdate.getEmailForAuditLog(id, serverId), ident.getWhen(), ident.getTimeZone()), 
 PersonIdent created = new PersonIdent(nowServerIdent, group.getCreatedOn()); 
 private ListMultimap<Key, Event> toEvents(GroupBundle bundle, PersonIdent nowServerIdent) { ListMultimap<Key, Event> result = MultimapBuilder.treeKeys(Key.COMPARATOR).arrayListValues(1).build(); Event e; 
 .setSubgroupModification(in -> Sets.difference(in, ImmutableSet.of(toRemove))); 
public class GroupRebuilderTest extends GerritBaseTests { private static final String SERVER_NAME = "Gerrit Server"; private static final String SERVER_EMAIL = "noreply@gerritcodereview.com"; 
 PermissionRule rule = Iterables.getOnlyElement(perm.getRules()); 
<|del|> 
 public static final String REFS_GROUPNAMES = "refs/meta/group-names"; 
 addNote(noteMap, newGroupName.get(), groupUuid, inserter); 
 Optional<FieldsBundle> result = i.getRaw(id, IndexedGroupQuery.createOptions(indexConfig, 0, 1, FIELDS)); if (!result.isPresent()) { 
 Optional<FieldsBundle> result = i.getRaw(id, IndexedGroupQuery.createOptions(indexConfig, 0, 1, FIELDS)); if (!result.isPresent()) { 
 return new FilteredRepository(ctl, repoManager.openRepository(name), visibleRefFilterFactory, userProvider, permissionBackend, projectState); 
 /** @return read from the database and return the raw results. */ ResultSet<FieldsBundle> readRaw() throws OrmException; 
<|del|> 
<|del|> 
 } else if (line.matches(GroupConfig.FOOTER_REMOVE_GROUP)) { 
 MoreObjects.firstNonNull(g.getRefState(), ObjectId.zeroId()).copyTo(a, 0); 
 if (results.size() > 1) { throw new IOException("Multiple results found in index for key " + key + ": " + results); 
 protected FieldBundle toFieldBundle(Document doc) { 
 T mapperResult = mapper.apply(doc); if (mapperResult != null) { result.add(mapperResult); } 
<|del|> 
 if (e.getPatchType() == Patch.PatchType.BINARY) { 
import com.google.gerrit.reviewdb.client.Patch.PatchType; import com.google.gerrit.reviewdb.client.PatchSet; 
Copyright (C) 2016 The Android Open Source Project 
Copyright (C) 2016 The Android Open Source Project 
<|del|> 
<|del|> 
import com.google.gerrit.server.diff.PatchListNotAvailableException; import com.google.gerrit.server.notedb.ChangeNotes; import com.google.gerrit.server.patch.PatchListObjectTooLargeException; 
import com.google.gerrit.server.diff.PatchListNotAvailableException; import com.google.gerrit.server.patch.PatchListObjectTooLargeException; 
 //TODO: expected failure 
Copyright (C) 2015 The Android Open Source Project 
Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 // Keep this logic in sync with GroupControl#isOwner(). return isAdmin || (user != null && user.getEffectiveGroups().contains(group.getOwnerGroupUUID())); 
Copyright (C) 2015 The Android Open Source Project 
<|del|> 
 fields.add(GroupField.UUID.getName()); 
 Ref ref = repo.exactRef(RefNames.refsGroups(id)); 
 return created != null ? created : NULL_TIMESTAMP; 
<|del|> 
 fields.containsKey(fieldDef.getName()) || fieldDef.isRepeatable(), 
class EditTransformer { 
<|del|> 
Copyright (C) 2009 The Android Open Source Project 
<|del|> 
 RefNames.refsGroups(admins), RefNames.refsGroups(nonInteractiveUsers), RefNames.refsGroups(users)); 
<|del|> 
 || (group != null && isGroupOwner(group, identifiedUser, isAdmin) && canReadRef(name))) { 
 install(new GerritApiModule()); 
<|del|> 
<|del|> 
 log.info("receive(): Set new peerInfo: {}", url); 
 log.atInfo().log( "Channel %s successfully joined jgroups cluster %s", channel.getName(), jgroupsConfig.clusterName()); 
<|del|> 
 return toBuilder() 
 Timestamp.from(MailProcessingUtil.rfcDateformatter.parse(ts, Instant::from)); 
 private PersonIdent getServerIdent(Map<Key, Collection<Event>> events) { // Created with MultimapBuilder.treeKeys, so the keySet is navigable. 
 return Arrays.hashCode(arr); 
import com.google.gerrit.server.config.ConfigResource; import com.google.gerrit.server.config.rest.CheckConsistency; 
<|del|> 
 problems.add(error("No internal group found for %s (%s)", gr.getName(), gr.getUUID())); 
<|del|> 
<|del|> 
<|del|> 
 || (oldName != null && fileRegex.matcher(oldName).find())) { // This cast still seems to be needed on JDK 8 as workaround for: // https://bugs.openjdk.java.net/browse/JDK-8039214 
 public static final String FIELD_OWNER = "owner"; 
 throws OrmException, RestApiException, PermissionBackendException { 
 long sizeDelta = size - aContent.length; 
 try { if (acc.getUserName() != null && !realm.isActive(acc.getUserName())) { 
 log.error("Failed to complete deactivation of accounts: " + e.getMessage(), e); 
 log.error("Failed to deactivate inactive accounts.", e); 
<|del|> 
 try (Repository repo = repoManager.openRepository(allUsersName)) { 
 // The sequential IDs are not keys in NoteDb, so no need to check them. 
 error("name for group %s is inconsistent (name map %s vs. group ref %s)", uuid, noteName, groupRefName)); 
 g.getId(), before.getName(), before.getGroupUUID(), g.getName(), g.getGroupUUID())); 
 for (Account.Id id : ids) { Account account; try { account = accounts.get(id); } catch (ConfigInvalidException e) { 
 RevWalk rw = new RevWalk(repo)) { 
 RevWalk rw = new RevWalk(repo)) { 
 InternalGroup g = cfg.getLoadedGroup().get(); byUUID.put(uuid, g); 
 * checkCycle walks through root's subgroups recursively, and checks for cycles. 
 Set<InternalGroup> todo = new LinkedHashSet<>(); 
 if (Objects.equals(g, root)) { 
 assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, user.id); 
<|del|> 
 return create(config(), start(), limit(), filter.apply(this)); 
 new Sort(new SortField(ID_SORT_FIELD, SortField.Type.LONG, true))); 
 /** The revision at which the data was loaded. Is null for data yet to be created. */ 
 /** The revision at which the data was loaded. Is null for data is yet to be created. */ 
 private boolean isHttpTransformPatternrUndefined(FilterConfig config) { 
 && config.getInitParameter(HTTP_TRANSFORM_PATTERN) == null; 
 String dollar = "\\$"; 
 "/changes/?q=test_repo~refs/meta/config~Iee4ae093988f8e2a1ad6d413450eec48b67124a2") .replaceAll(dollar); assertThat(result).named("Change ID triplet grouping").isEqualTo("/changes/?q=$"); 
 protected abstract V fromDocument(JsonObject doc, Set<String> fields); 
 if (RefNames.isGroupRef(refEvent.command.getRefName())) { 
 // grouping multiple patterns in one input 
 .add("(?<=files/)[^/]+") //review files part .add("(?<=/projects/)[^/]+") //project name .add("(?<=/accounts/)[^/]+") // account id 
 Pattern.compile( GerritMonitoringFilter.JavamelodyFilter.GERRIT_GROUPING, Pattern.MULTILINE | Pattern.DOTALL); 
 // Check of removing this reviewer (even if there is no vote processed by the loop below) is OK 
// This test creates a new user which doesn't go well with other tests that assume there are only // two users, hence it is sandboxed. @Sandboxed 
import com.google.gerrit.lifecycle.LifecycleModule; import com.google.gerrit.server.config.AccountDeactivatorConfig; 
 AccountDeactivator(OneOffRequestContext oneOffRequestContext, DeactivationUtil deactivationUtil) { this.oneOffRequestContext = oneOffRequestContext; this.deactivationUtil = deactivationUtil; 
 this.healthy = true; rsp.setStatus(SC_NO_CONTENT); 
 this.healthy = false; rsp.setStatus(SC_NO_CONTENT); 
 public ResultSet<AccountGroup> iterateAllEntities() { 
 public ResultSet<AccountGroupName> iterateAllEntities() { throw new UnsupportedOperationException(MSG); 
 // Keep track of when we've started a transaction so that we can avoid calling commit/rollback // on the underlying ReviewDb. This is just a simple arm's-length approach, and may produce 
 if (rule.getAction() != Action.ALLOW || rule.getForce() || rule.getMin() != -2 || rule.getMax() != 2) { // default permission was modified return false; 
 throw new OrmException( "Failed to make default Label-Code-Review permission on user branches exclusive", e); 
 default boolean accountBelongsToRealm( 
Copyright (C) 2017 The Android Open Source Project 
 private final Pattern allowOrigin; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 problems.add(error("group %s does not parse: %s", uuid, e.getMessage())); 
<|del|> 
 @Inject @GerritPersonIdent private PersonIdent serverUser; 
 public void basicSetup() throws Exception { allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); 
 private boolean groupsInNoteDb() { 
<|del|> 
 readGroups(repo, refs, problems, byUUID); readGroupNames(repo, refs, problems, nameMap); 
 readGroups(repo, refs, problems, byUUID); readGroupNames(repo, refs, problems, nameMap); 
<|del|> 
 Map<String, Ref> refs, 
 byUUID.put(uuid, cfg.getLoadedGroup().get()); 
<|del|> 
 private static String BOGUS_UUID = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"; 
 String g1 = createGroup("g1"); String g2 = createGroup("g2"); 
<|del|> 
<|del|> 
<|del|> 
 private void assertError(String msg) throws Exception { assertConsistency(msg, ConsistencyProblemInfo.Status.ERROR); 
 private void assertConsistency(String msg, ConsistencyProblemInfo.Status want) throws Exception { 
 private void updateGroupFile(String refname, String filename, String contents) throws Exception { 
 } 
 async.addAppender(new SocketAppender(hostname, port);); 
 this.groupsMigration = groupsMigration; 
 if (byUUID.get(g.getOwnerGroupUUID()) == null && groupBackend.get(g.getOwnerGroupUUID()) == null) { 
 // We trust SHA1 to have no collisions, so no need to check uniqueness of name. 
<|del|> 
<|del|> 
 void setAllowSaveEmptyName() { this.allowSaveEmptyName = true; 
 } } else { if (lostEventCount++ % 10 == 0) { LOGGER.error("Event queue is full, lost {} event(s)", lostEventCount); } 
<|del|> 
 throw new UnsupportedOperationException( "hashCode is not supported because equals is not supported"); 
 String name = config.getString(SECTION_NAME, null, NAME_PARAM); if (uuid == null || name == null) { throw new ConfigInvalidException( String.format("UUID '%s' and name '%s' must be defined", uuid, name)); 
 private static final String BOGUS_UUID = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"; 
 if (accountId != null) { return "GerritAccount #" + accountId.get(); } return "GerritAccount with undefined id"; 
<|del|> 
 log.atInfo().log( "Channel %s successfully joined jgroups cluster %s", channel.getName(), jgroupsConfig.clusterName()); 
 return jgitConfig; 
 private static final Logger log = LoggerFactory.getLogger(HealthServlet.class); 
 this(l); this.burstPermits = burst; gracePermits.set(burst); 
 RefUpdate.Result result = updateRef.delete(); checkState( result == RefUpdate.Result.FORCED, "deleting branch %s in %s failed", ref.getName(), e.getKey()); 
 try (AutoCloseable ctx = createFailOnLoadContext()) { 
<|del|> 
<|del|> 
 b.append(">"); } else { b.append(" ("); b.append(accountId.get()); b.append(")"); 
 addMember(g, 2, 9, t4), addMember(g, 1, 8, t5)) 
<|del|> 
 rateLimits.put(type, groupName, parseRateLimit(c, groupName, type, 3, 90)); 
 HttpModule(PluginConfigFactory pluginCF, @PluginName String pluginName) { final PluginConfig pc = pluginCF.getFromGerritConfig(pluginName); 
 private int burstPermits; private AtomicInteger gracePermits; 
 public boolean inGracePeriod() { if (gracePermits.get() < 0) return false; return gracePermits.getAndDecrement() > 0; 
 private abstract static class AbstractHolderCacheLoader<Key> extends CacheLoader<Key, Holder> { protected AccountLimitsFinder finder; protected Type limitsConfigType; 
<|del|> 
<|del|> 
 private Multimap<Project.NameKey, String> keptRefsByProject; private Multimap<Project.NameKey, String> restoredRefsByProject; private Multimap<Project.NameKey, String> deletedRefsByProject; 
 accounts.values().removeIf(a -> ids.contains(a.id)); 
 * <li>Resetting group branches doesn't evict the corresponding groups from the group cache. * <li>Changes are not reindexed if change meta refs are reset. 
 .filter(e -> e.getValue().equals(RefNames.REFS_CONFIG)) 
 if (accountCreator != null) { 
 cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true); try { 
 Change c = new Change(c3.change()); PatchSet.Id psId = new PatchSet.Id(c3.getId(), 2); 
 Change c = new Change(c3.change()); PatchSet.Id psId = new PatchSet.Id(c3.getId(), 2); 
 private List<ConsistencyProblemInfo> checkGroup( InternalGroup g, Map<AccountGroup.UUID, InternalGroup> byUUID) throws IOException { 
 Repository repo, Map<String, Ref> refs, Result result, BiMap<AccountGroup.UUID, String> uuidNameBiMap) 
 throw new MethodNotAllowedException("NoteDb writes must be enabled"); 
 throw new MethodNotAllowedException("not an internal group"); 
 restapiLimitExceededMsg = 
 protected AbstractHolderCacheLoader(Type limitsConfigType, AccountLimitsFinder finder) { 
 super(limitsConfigType, finder); 
 super(limitsConfigType, finder); 
 private final Holder createWithBurstyRateLimiter(Account.Id key) throws Exception { return createWithBurstyRateLimiter( finder.firstMatching(limitsConfigType, userFactory.create(key))); 
 @Provides @Named(CACHE_NAME_ACCOUNTID) @Singleton public LoadingCache<Account.Id, Module.Holder> getLoadingCacheByAccountId( GenericFactory userFactory, AccountLimitsFinder finder) { return CacheBuilder.newBuilder() .build(new HolderCacheLoaderByAccountId(Type.UPLOADPACK, userFactory, finder)); 
<|del|> 
 GroupsNoteDbConsistencyChecker(GroupsMigration groupsMigration) { this.groupsMigration = groupsMigration; } 
 public void groupNameNoteDataBlobIsMissing() throws Exception { GroupTestUtil.updateGroupFile(allUsersRepo, serverIdent, RefNames.REFS_GROUPNAMES, "a", "c"); checkConsistency(error("Group with name 'g-1' doesn't exist in the list of all names")); 
 public void groupNameNoteIsConsistent() throws Exception { updateGroupNamesRef("[group]\n\tuuid = uuid-1\n\tname = g-1\n"); checkConsistency(); 
 throws IOException, PermissionBackendException { 
 String basePath = absolutePath("someAbsolutePath", "someDirectory").toString(); 
 configureBasePath(Paths.get("project", "project", "*").toString(), basePath2); configureBasePath(Paths.get("project", "*").toString(), basePath3); 
 configureBasePath(Paths.get("project", "project", "*").toString(), basePath2); configureBasePath(Paths.get("project", "*").toString(), basePath3); 
 String basePath = Paths.get("someAbsolutePath", "someDirectory").toString(); 
 configureBasePath("project" + File.separator + "project/*", basePath2); 
<|del|> 
 GroupBundle noteDbBundle = bundleFactory.fromNoteDb(repo, uuid); 
 if (!hasPreferredEmail()) { return ImmutableList.of(); 
 return hasField(AccountField.PREFERRED_EMAIL_EXACT); 
 log.error(String.format("invalid value for %s; using default value %d", name, defaultValue)); log.debug("Failed to retrieve integer value: " + e.getMessage(), e); 
 protected static final String COMMENT_LINK_SECTION = "commentlink"; 
 public PatchSetReviewDb(GerritApi gApi) { this.gApi = gApi; 
 return ""; 
 if (changeNumber.isEmpty()) { 
<|del|> 
import com.google.gerrit.extensions.annotations.PluginName; import com.google.gerrit.extensions.client.ChangeStatus; import com.google.gerrit.extensions.common.AccountInfo; 
 Lock idLock = getLock(id); idLock.lock(); try { 
 @SuppressWarnings("unused") public RateMsgHelper(Type limitsConfigType, String templateMsg) { messageFormatMsg = templateMsg == null ? getDefaultTemplateMsg(UPLOADPACK_INLINE_NAME) : templateMsg; messageFormatMsg = messageFormatMsg.replace(RATE_LIMIT_TOKEN, FORMAT_REAL); } 
 public boolean isSensitiveParameter(String param) { return this.sensitiveParameters == null ? false : sensitiveParameters.contains(param); 
 public boolean isSensitiveParameter(String param) { return this.sensitiveParameters == null ? false : sensitiveParameters.contains(param); 
 public void addSensitiveParameter(String sensitiveParameter) { 
 public void addSensitiveParameter(String sensitiveParameter) { 
<|del|> 
 * Annotation tagged on a field of an ssh command to indicate the value must be hidden from logs. 
Copyright (C) 2017 The Android Open Source Project 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public void setSensitiveParameters(Set<String> sensitiveParameters) { 
 public Set<String> getSensitiveParameters() { 
 return sensitiveParameters == null ? false : sensitiveParameters.contains(param); 
 public void setSensitiveParamaters(Set<String> sensitiveParameters) { this.sensitiveParameters = sensitiveParameters; 
 return sensitiveParameters; 
 setSensitiveParamaters(((BaseCommand) cmd).getSensitiveParamters()); 
 System.out.printf("Migrated %d rows in %.01fs (%.01f/s)\n", offset, t, offset / t); 
<|del|> 
<|del|> 
 private final LoadingCache<String, Holder> limitsPerRemoteHost; private final String limitExceededMsg; 
<|del|> 
 public void groupNameNoteIsMissing() throws Exception { updateGroupNamesRef("g-2", "[group]\n\tuuid = uuid-2\n\tname = g-2\n"); 
 "group with name 'g-1' has UUID 'uuid-1' in 'group.config' but 'uuid-2' in group " + "name notes")); 
 "group with name 'g-1' has UUID 'uuid-1' in 'group.config' but 'uuid-2' in group " + "name notes"), 
 GroupsNoteDbConsistencyChecker.logFailToLoadFromGroupRefAsWarning(groupReference.getUUID()); 
 return groupControlFactory.controlFor(new InternalGroupDescription(group.get())).isVisible(); 
 .map(this::loadGroup) 
 * @return the loaded account, {@code null} if load didn't find the account because it doesn't * exist 
 * @return the loaded account, {@code null} if load didn't find the account because it doesn't * exist 
 * @return the loaded account, {@link Optional#empty()} if load didn't find the account because it * doesn't exist 
 * @return the loaded account 
 MetaDataUpdateFactory metaDataUpdateFactory) { this.repoManager = checkNotNull(repoManager, "repoManager"); this.gitRefUpdated = checkNotNull(gitRefUpdated, "gitRefUpdated"); 
<|del|> 
/** TODO(gildur): remove when updating to newer scribe lib */ 
 sections.get(PLUGIN_SECTION, pluginName + KeycloakOAuthService.CONFIG_SUFFIX); 
 private static final String AUTHORIZE_URL = "%s/auth/realms/%s/protocol/openid-connect/auth?client_id=%s&response_type=code&redirect_uri=%s&scope=%s"; 
 private static final Logger log = LoggerFactory.getLogger(KeycloakOAuthService.class); 
 private AccountsUpdate( 
 this(rc, section, subsection, ZonedDateTime.now(systemDefault())); 
 boolean hasGracePermits() { if (gracePermits.get() <= 0) return false; 
 limitsConfigType == Type.UPLOADPACK ? UPLOADPACK_INLINE_NAME : RESTAPI_INLINE_NAME; 
 if (isRest((HttpServletRequest) req)) { 
<|del|> 
 if (!rateLimiterHolder.hasGracePermits() 
 AuditLogFormatter.createBackedBy(ImmutableSet.of(), ImmutableSet.of(), "server-id"); 
 private final Optional<Path> protocolStack; 
 private Optional<Path> getProtocolStack(Config cfg, SitePaths site) { 
 public Optional<Path> protocolStack() { 
 if (address.isPresent()) { log.debug("Protocol stack: " + channel.getProtocolStack()); 
 if (channel != null) { log.info( "closing jgroups channel {} (cluster {})", channel.getName(), jgroupsConfig.clusterName()); channel.close(); } 
<|del|> 
 Arrays.stream(BooleanProjectConfig.values()) .forEach(c -> booleanConfigs.put(c, InheritableBoolean.INHERIT)); 
 /** Provides transformations to get and set BooleanProjectConfigs from the API. */ 
 "Plugin name '{}' must match '{}' to use capabilities; rename the plugin", pluginName, PLUGIN_NAME_PATTERN.pattern()); 
 "Parameter name '{}' must match '{}'", v.getKey(), PARAMETER_NAME_PATTERN.pattern()); 
 return join(Lists.transform(consumers, AccountUpdater::fromConsumer)); 
 * updated, {@code Optional#of("")} if the full name is unset, the wrapped value is never * {@code null} 
 r -> r.withBlockStrategy(noSleepBlockStrategy)), 
 AccountInfo accountInfo = gApi.accounts().id(admin.id.get()).get(); assertThat(accountInfo.status).isNull(); assertThat(accountInfo.name).isNotEqualTo(fullName); Account updatedAccount = update.update(admin.id, u -> u.setFullName(fullName)); 
 List<String> status = ImmutableList.of("foo", "bar", "baz"); 
 assertThat(updatedAccount.getStatus()).isEqualTo(Iterables.getLast(status)); 
 () -> { 
 NotesMigration migration, ReviewDbBatchUpdate.AssistedFactory reviewDbBatchUpdateFactory, NoteDbBatchUpdate.AssistedFactory noteDbBatchUpdateFactory, 
 }); 
 protocolStack.isPresent() ? protocolStack.get().toString() : "not configured, using default stack."); 
 protocolStack.isPresent() ? protocolStack.get().toString() : "not configured, using default stack."); 
 protocolStack.isPresent() ? protocolStack.get().toString() : "not configured, using default stack."); 
 : Optional.of(site.etc_dir.resolve(location)); 
 /** * Report whether a commit is reachable from a set of commits. This is used for checking if a user * has read permissions on a commit. */ 
 public boolean fromRefs( 
 Map<String, Ref> filtered = refFilter.create(state, repo).filter(refs, true); return IncludedInResolver.includedInAny(repo, rw, commit, filtered.values()); 
 private enum ChangeIdType { 
 "http/server/rest_api/change_id_type", 
 Field.ofEnum(ChangeIdType.class, "change_id_type")); 
 fieldsDelimiter = ""; log.warn("Only account_id and registered_on fields are migrated for accounts"); 
 try (Repository repo = repoManager.openRepository(project); Stream<Path> paths = Files.walk(((FileRepository) repo).getObjectDatabase().getDirectory().toPath())) { return paths 
 * Gerrit in the first place and only later lose the index connection (making it so that we can't 
 } else if (!itsConfig .getDummyIssuePattern() .map(p -> p.matcher(commitMessage).find()) .orElse(false)) { 
 ident, ident, 
<|del|> 
<|del|> 
 /** Return whether a commit is reachable from a given set of refs. */ 
 /** Return whether a commit is reachable from a repo's branches and tags. */ 
 public static ImmutableSet<ExternalId.Key> from(Collection<ExternalId> extIds) { return extIds.stream().map(ExternalId::key).collect(toImmutableSet()); 
 private ObjectId oldRev; 
 private ObjectId oldRev; 
 HashSet<ExternalId> externalIds = Sets.newHashSetWithExpectedSize(keys.size()); 
 } catch (ConfigInvalidException | RuntimeException e) { 
 cacheUpdates.add(cu -> cu.add(newExtIds)); 
 checkState(!readOnly, "Updating external IDs is disabled"); 
 byte[] raw = readNoteData(rw, noteMap.get(noteId)); 
 byte[] raw = readNoteData(rw, noteMap.get(noteId)); 
 ObjectId noteDataId = noteMap.get(noteId); byte[] raw = readNoteData(rw, noteDataId); ExternalId actualExtId = ExternalId.parse(noteId.name(), raw, noteDataId); 
 throw new BadRequestException("private changes are disabled"); 
 public void createPrivateChangeWithDisablePrivateChangesTrue() throws Exception { 
 @GerritConfig(name = "change.disablePrivateChanges", value = "true") public void createNonPrivateChangeWithDisablePrivateChangesTrue() throws Exception { 
<|del|> 
<|del|> 
 public void addComment(String issueId, String comment) throws IOException { 
 if (modifyAccountCapabilityChecked || permissionBackend.user(self).test(GlobalPermission.MODIFY_ACCOUNT)) { 
<|del|> 
<|del|> 
 /** @return true if a commit is reachable from a given set of refs. */ 
 /** @return true if a commit is reachable from a repo's branches and tags. */ 
 get(key).ifPresent(externalIds::add); 
 * Exception that is thrown if an external ID cannot be inserted because an external ID with the 
 if (isRest(req)) { 
<|del|> 
 if (e.getDuplicateKey().isScheme(SCHEME_USERNAME)) { 
 if (e.getDuplicateKey().isScheme(SCHEME_USERNAME)) { 
 * Recursively enumerate the members of the given group. Should not be used with the 
<|del|> 
<|del|> 
<|del|> 
 // complete account from the cache (or worse, from NoteDb) even though we only need the ID 
Copyright (C) 2017 The Android Open Source Project 
 throws RestApiException, OrmException, PermissionBackendException { 
 throws RestApiException { 
/** Named resource was accessed using a deprecated identifier. */ 
 changeIdCounter.increment(ChangeIdType.NUMERIC_ID); 
 changeIdCounter.increment(ChangeIdType.NUMERIC_ID); 
 if (account.isActive()) { 
 parms.put( parm, secure && dcmd.isSensitiveParameter(parm) ? MASK : arg.substring(eqPos + 1)); 
<|del|> 
 throw new MethodNotAllowedException("private changes are disabled"); 
 throw new MethodNotAllowedException("private changes are disabled"); 
 info.disablePrivateChanges = toBoolean(config.getBoolean("change", null, "disablePrivateChanges", false)); 
 * <p>{@code * -Djgroups.logging.log_factory_class=com.ericsson.gerrit.plugins.highavailability.peers.jgroups.SLF4JLogFactory} 
 log.debug("Issue {} doesn't exit: {}", issueId, e.getMessage(), e); 
 log.error("Action {} not found within available actions", actionName); 
 return getGlobalConfig(); 
 if (projectState.getProject().getState() == com.google.gerrit.extensions.client.ProjectState.HIDDEN) { 
<|del|> 
<|del|> 
<|del|> 
 } private String extractKey(String arg) { int eqPos = arg.indexOf('='); if (eqPos > 0) { return arg.substring(0, eqPos); } return arg; } 
 ExternalId userNameExtId = !Strings.isNullOrEmpty(who.getUserName()) ? createUsername(newId, who.getUserName()) : null; 
<|del|> 
<|del|> 
<|del|> 
 REJECT_EMPTY_COMMIT("submit", "rejectEmptyCommit"); 
 projectControlFactory, 
 .findFirst(); 
 * and properties from the account config file. AccountState maps one-to-one to Account. * * <p>Most callers should not construct AccountStates directly but rather lookup accounts via the * account cache (see {@link AccountCache#get(Account.Id)}). 
<|del|> 
 public static ImmutableMap<ProjectWatchKey, ImmutableSet<NotifyType>> parse( 
 public static ImmutableMap<ProjectWatchKey, ImmutableSet<NotifyType>> parse( 
 @GerritConfig(name = "download.archive", value = "txz") 
 try (InputStream out = adminSshSession.exec2("git-upload-archive " + project.get(), argumentsToInputStream(c))) { 
 private Set<String> sensitiveParameters = new HashSet<>(); 
 return projectControl .controlForRef(MagicBranch.NEW_CHANGE + refName) .canPerform(Permission.ADD_PATCH_SET); 
 private static final String CHANGE_ID_MISMATCH_MSG = 
<|del|> 
 return projectControl .controlForRef(MagicBranch.NEW_CHANGE + refName) .canPerform(Permission.ADD_PATCH_SET); 
 if (!statePermitsWrite()) { throw new ResourceConflictException( "project state " + getProject().getState().name() + " does not permit write"); 
 if (!statePermitsWrite()) { throw new ResourceConflictException( "project state " + getProject().getState().name() + " does not permit write"); 
 + " in commit message footer does not match" 
 * Loads the external ID notes from the current tip of the {@code refs/meta/external-ids} * branch. 
 + " in commit message footer does not match" 
 projectCache.checkedGet(rsrc.getProject()).checkStatePermitsWrite(); 
public class UploadArchiveIT extends AbstractDaemonTest { 
<|del|> 
<|del|> 
 return refControl.canForceEditTopicName(); 
 assertThat(u.controlForRef("refs/heads/master").canForceEditTopicName()) 
 ConfigInvalidException, ResourceConflictException { 
<|del|> 
 String.format( "-f=%s --prefix=%s/ %s %s", format, abbreviated, r.getCommit().name(), PushOneCommit.FILE_NAME); 
 assertThat(accountState).isEmpty(); 
 assertThat(accountState).isPresent(); 
 private AccountState( 
 return Streams.stream(accounts.get(id)).map(a -> id).collect(toImmutableSet()); 
 throws RestApiException, IOException, PermissionBackendException { 
 throws RestApiException, IOException, PermissionBackendException { 
 throws RestApiException, IOException, PermissionBackendException { 
 return Objects.hashCode(message); 
 private void addCreatedMessage(CreateRequest c) { 
 * Definition of an update to a group. 
 * <p><strong>Note: </strong>Passing the empty string unsets the description. 
 * <p><em>Parsable</em> means that we can unambiguously identify the original account when being * presented with a {@code PersonIdent} of a commit. 
 * <p><em>Parsable</em> means that we can unambiguously identify the original account when being * presented with a {@code PersonIdent} of a commit. 
 * A parsable commit message for a NoteDb commit of a group. 
 * showSiteHeader = false 
 throws PermissionBackendException { 
 implements RestModifyView<ServiceUserResource, NameInput> { 
 parent.getProjectState().checkStatePermitsWrite(); 
 req.setAttribute(REQ_ATTR_KEY, who.getUserName().orElseGet(() -> "a/" + who.getAccountId())); 
 remoteUser = user.orElseGet(() -> "account-" + u.getAccountId()); 
 String user = getUserName().orElseGet(() -> "account-" + ua.getId().toString()); 
 + user.getUserName() 
 throw die(e); 
<|del|> 
 * the more precise one. E.g if the following subsections are defined: 
<|del|> 
 ProjectState state = projectCache.checkedGet(psd.data().project()); return state != null && state.statePermitsRead(); 
 req.setAttribute(REQ_ATTR_KEY, user.asIdentifiedUser().getLoggableName()); 
 private static final String OFFICE365_PROVIDER_PREFIX = "office365-oauth:"; 
 OFFICE365_PROVIDER_PREFIX + id.getAsString() /*externalId*/, 
 null); 
 AccessCheckInput in = new AccessCheckInput(); 
<|del|> 
 public <I, O> O execute(I input, Action<I, O> action) throws IOException, ConfigInvalidException, OrmException { 
 null); 
Copyright (C) 2017 The Android Open Source Project 
Copyright (C) 2017 The Android Open Source Project 
 if (!account.map(Account::isActive).orElse(false)) { 
 /** @return the enum constant for a given permission name if present. */ 
 /** @return the enum constant for a given permission name if present. */ 
 /** @return the enum constant for a given permission name if present. */ 
 state = accountCache.get(getAccountId()); 
 return byId.get(r.iterator().next()).getAccount(); 
 return r.size() == 1 ? byId.get(r.iterator().next()).getAccount() : null; 
 la.by = asAccountAttribute(lbl.appliedBy); 
 .orElseThrow(() -> new ResourceNotFoundException(IdString.fromDecoded(id.toString()))); 
 .orElseThrow(() -> new ResourceNotFoundException(IdString.fromDecoded(id.toString()))); 
 .orElseThrow(() -> new ResourceNotFoundException(IdString.fromDecoded(id.toString()))); 
 String.format("Account '%s' is not found or ambiguous", id)); 
 throw new NotImplementedException(); 
 throw new NotImplementedException(); 
 private static final BooleanCondition NO_TRIVIAL_EVALUATION = new BooleanCondition() { @Override public boolean value() { throw new UnsupportedOperationException("value() is not supported"); } 
 @Override public <T> Iterable<T> children(Class<T> type) { throw new UnsupportedOperationException("children(Class<T> type) is not supported"); } 
 * additional information to the evaluation tree, e.g. through checks to a remote service such as 
 return cond.evaluatesTrivially() && (cond.value() == expectedValue); 
 BooleanCondition nonReduced = and(or(NO_TRIVIAL_EVALUATION, NO_TRIVIAL_EVALUATION), or(valueOf(true), valueOf(false))); BooleanCondition reduced = and(or(NO_TRIVIAL_EVALUATION, NO_TRIVIAL_EVALUATION), valueOf(true)); assertEquals(nonReduced.reduce(), reduced); 
 assertThat(RefPermission.fromName("doesnotexist")).isEmpty(); assertThat(RefPermission.fromName("")).isEmpty(); assertThat(RefPermission.fromName(Permission.VIEW_PRIVATE_CHANGES)) .hasValue(RefPermission.READ_PRIVATE_CHANGES); 
<|del|> 
 .flatMap(Streams::stream) 
/** An audit event for groups. */ 
 member -> 
 } db.accountGroupMembers().insert(newMembers); 
 public URL getJiraUrl() throws MalformedURLException { URL serverUrl = new URL(CharMatcher.is('/').trimFrom(jiraUrl) + "/"); return serverUrl; 
<|del|> 
 public List<WebLinkInfo> configWebLinks; 
 projectName.get(), config.getRevision().getName(), ProjectConfig.PROJECT_CONFIG); 
<|del|> 
 String userName = user.getUserName().orElse("anonymous"); 
 String userName = user.getUserName().orElse("anonymous"); 
 * explaining why this method is used. Most callers of {@link AccountCache} should use {@link 
 LabelType label, short value, Account.Id accountId, Optional<Account> account) { 
 author.map(Account::getName).orElse(Account.getName(authorId)), 
 author.map(Account::getName).orElseGet(() -> Account.getName(authorId)), 
 "Failed to create project {}; Cannot retrieve info about parent project {}: {}", name, args.newParent.get(), e.getMessage(), 
 URL url = new URL(baseUrl, spec); 
 public static Optional<Id> tryParse(String str) { 
 Optional<ReviewerStateInternal> reviewerState = Enums.getIfPresent(ReviewerStateInternal.class, v.substring(0, firstIndex)); if (!reviewerState.isPresent()) { 
 Long l = Longs.tryParse(v.substring(lastIndex + 1, v.length())); if (l == null) { 
 Optional<ReviewerStateInternal> reviewerState = Enums.getIfPresent(ReviewerStateInternal.class, v.substring(0, firstIndex)); if (!reviewerState.isPresent()) { 
 Long l = Longs.tryParse(v.substring(lastIndex + 1, v.length())); if (l == null) { 
<|del|> 
 public URL getJiraUrl() { return jiraUrl; 
 factory(JiraRestApi.Factory.class); 
<|del|> 
 this.baseUrl = new URL(url, BASE_PREFIX + "/serverInfo/"); 
 private static String encode(String user, String pass) { 
 URL url = new URL(baseUrl, spec); 
 private void setUpCommonMocks(String serverUrl) throws MalformedURLException { url = new URL(CharMatcher.is('/').trimFrom(serverUrl) + "/"); 
 private void setUpCommonMocks(String serverUrl) throws MalformedURLException { url = new URL(CharMatcher.is('/').trimFrom(serverUrl) + "/"); 
 setUpCommonMocks(nonRootJiraUrl); 
 setUpCommonMocks(nonRootJiraUrl); 
 private static final String URL = "http://jira_example.com"; 
 ImmutableList.Builder<String> builder = ImmutableList.builder(); 
 abstract ImmutableSet<Account.Id> getAddedMembers(); 
 && (!last.isPresent() || (!last.get().equals(id.key())))) { 
 "https://www.gofundme.com/shawn-pearce-memorial-fund", 
<|del|> 
 while (!isConnected() && !canceled) { 
 .setGroupName(group.getNameKey()); 
Copyright (C) 2018 The Android Open Source Project 
 log.debug("Change {} was deleted, aborting reindexing the change.", id.get()); 
 return ImmutableSet.of(); 
 } 
 resource.asInternalGroup().orElseThrow(NotInternalGroupException::new); 
 return ": New merge patch set was added with a new first parent relative to Patch Set " 
 private static String shortestUnambiguousRefName(RefDatabase refdb, Ref ref, boolean strict) 
 branch = RefNames.fullName(branch); 
class ReceiveSlaveMode extends AbstractGitCommand { @Inject private Receive receive; 
<|del|> 
 keys.set(seq - 1, Optional.of(AccountSshKey.createInvalid(key.get()))); 
 log.error( "Failed to mark SSH key " + k.seq() + " of account " + k.accountId() + " invalid", e); 
 this.suggestOnly = c.getBoolean("reviewers", null, "suggestOnly", false); 
 // TODO: this is a copy of the protected RefDatabase.SEARCH_PATH 
 Revision.unpeeled( shortestUnambiguousRefName(refdb, ref, false), ref.getObjectId())) 
 JiraConfig(@GerritServerConfig Config config, @PluginName String pluginName) { jiraUrl = config.getString(pluginName, null, GERRIT_CONFIG_URL); 
 JiraConfig(@GerritServerConfig Config config, @PluginName String pluginName) { jiraUrl = config.getString(pluginName, null, GERRIT_CONFIG_URL); 
 JiraRestApi(JiraConfig jiraConfig, @Assisted Class<T> classOfT, @Assisted String classPrefix) { 
 public JiraRestApi(String url, String user, String pass) throws IOException { 
 doGet("", HTTP_OK); 
 private static final String URL = "http://jira_example.com"; 
<|del|> 
 /** calculates permissions for ALLOW processing. */ 
 // The next 4 members are cached canPerform() permissions. 
 // calculates permissions for ALLOW processing. private List<PermissionRule> calculateAllowRules(String permName) { 
 if (seen.contains(sr)) { 
 // Calculates the inputs for determining BLOCK status. 
 /** True if the user has this permission. */ 
 return 
<|del|> 
 } if (overrideFound) { // Found an exclusive override, nothing further to do in this project. break; } 
 // force on block rule only applies to withForce permission. 
 info( 
 groupIndexer.index(AccountGroup.UUID.fromRefPart(e.getKey())); 
 } catch (Throwable t) { log.error("Failed to reindex groups", t); Throwables.throwIfUnchecked(t); 
 URI uri = new URI(email); return emailDomainWhitelist.contains(uri.getSchemeSpecificPart().split("@")[1]); } catch (NullPointerException | URISyntaxException e) { 
 private Boolean owner; 
 @SuppressWarnings("unused") 
 @SuppressWarnings("unused") 
<|del|> 
 Futures.nonCancellationPropagating(batchExecutor.submit(() -> reindexIfStale(id))), IndexUtils.MAPPER); 
<|del|> 
 for (String pair : Splitter.on(CharMatcher.anyOf("&;")).split(req.getQueryString())) { 
 for (String pair : Splitter.on('&').split(url.substring(q + 1))) { 
Copyright (C) 2018 The Android Open Source Project 
 return perm.filter(repo.getAllRefs(), repo, opts); } catch (PermissionBackendException e) { 
 return perm.filter(repo.getAllRefs(), repo, opts); } catch (PermissionBackendException e) { 
 msg.append("DefaultAdvertiseRefsHook"); 
<|del|> 
 group = INVISIBLE_SENTINEL; if (control.isVisible()) { group = groupJson.format(control.getGroup()); group.id = null; } 
 group = INVISIBLE_SENTINEL; 
 } return group; 
 groups.getAllGroupReferences(db).map(GroupReference::getUUID).collect(toList()); 
<|del|> 
 groupIndexedCounter.clear(); groupsUpdate.updateGroupInDb( db, groupUuid, InternalGroupUpdate.builder().setDescription("bar").build()); 
 * @param issued time at which the token was issued * @param expiresIn expiry duration in seconds 
 public final Long expiresIn; 
 //gApi.changes().id(changeId).index(); 
 //gApi.changes().id(changeId).index(); 
 private void loadGroup(Map<AccountGroup.UUID, GroupInfo> groups, AccountGroup.UUID id) { 
 * @param reviewers Set of reviewer IDs to add 
abstract class AddReviewers implements Runnable { 
 public abstract static class RefFilterOptions { /** Remove all NoteDb refs (refs/changes/*, refs/users/*, edit refs) from the result. */ 
 /** Separately add reachable tags. */ 
 return builder().build(); 
 Map<String, FileInfo> files = gApi.changes() .id(r.getChangeId()) .revision(r.getCommit().name()) .files(); 
 int changeNumber = c._number; 
 public static ScheduleConfig.Builder builder(Config config, String section) { return new AutoValue_ScheduleConfig.Builder() .setNow(ZonedDateTime.now(systemDefault())) .setKeyInterval(KEY_INTERVAL) .setKeyStartTime(KEY_STARTTIME) .setConfig(config) .setSection(section); 
 return computeInterval(config(), section(), subsection(), keyInterval()); 
 assertThat(s.schedule()).hasValue(Schedule.create(ms(1, HOURS), ms(1, HOURS))); 
 static class RemoteCmdFailedException extends IOException { private static final long serialVersionUID = 1L; 
 RemoteCmdFailedException(String cmd, int exitValue) { super(String.format("Cmd %s failed with exit value: %d", cmd, exitValue)); 
<|del|> 
 throw new BadRequestException("username is not set"); 
 throw new BadRequestException("username is not set"); 
 throw new BadRequestException("username is not set"); 
class AddReviewersByBlame extends AddReviewers { 
import com.google.inject.Inject; import com.google.inject.ProvisionException; 
 commandName.append(Joiner.on(".").join(trimmedArgs)); 
<|del|> 
 InboundEmailRejectionSender em = createInboundEmailRejectionSenderFactory.create( message.from(), reason, message.id() ); // @TODO(maximeg): add link to some help content, if such thing exists? 
<|del|> 
 "Message %s has a Precedence header. Will ignore and delete message.", message.id()); 
/** Send an email to inform users that parsing their inbound email failed. */ 
<|del|> 
 ReviewersConfig.ForProject cfg = config.forProject(projectName); if (cfg == null) { 
<|del|> 
 void addReviewers(String filter, String reviewers, String excludedPaths) { 
 void addReviewers(String filter, String reviewers, String excludedPaths) { 
 final native void setExcluded(String e) /*-{ if(r)this.excluded=r; }-*/; 
 public final native JsArrayString excluded() /*-{ return this.excluded; }-*/; 
 * TODO(mduft) Since we override getText() method in the AutoCompleteTexBox we * have to get value directly from the element property This[1] 
 * TODO(mduft) Since we override getText() method in the AutoCompleteTexBox we * have to get value directly from the element property This[1] 
 assertWithMessage("valid character rejected: " + c) .that(GitwebConfig.isValidPathSeparator(c)) .isTrue(); 
 this.emailRejectionSender = emailRejectionSender; 
 warnInboundEmailRejected(message, InboundEmailRejectionSender.Error.UNKNOWN_ACCOUNT); 
 InboundEmailRejectionSender em = emailRejectionSender.create(message.from(), reason, message.id()); 
 warnInboundEmailRejected(message, InboundEmailRejectionSender.Error.INTERNAL_EXCEPTION); 
import org.apache.james.mime4j.dom.field.FieldName; 
 footers.add(MailHeader.ASSIGNEE.withDelimiter() + getNameEmailFor(change.getAssignee())); 
 InboundEmailRejectionSender create(Address to, Error reason, String threadId); 
 "InboundEmailRejection.soy", "InboundEmailRejectionHtml.soy", 
 assertThat(sender.getMessages()).isEmpty(); 
<|del|> 
 // Metadata 
<|del|> 
 private final Address to; private final Error reason; private final String threadId; 
 this.to = checkNotNull(to); this.reason = checkNotNull(reason); this.threadId = checkNotNull(threadId); 
 this.to = checkNotNull(to); this.reason = checkNotNull(reason); this.threadId = checkNotNull(threadId); 
 private static final Pattern UNINTERESTING_FIELDS = 
 @Option(name = "--output-file", usage = "Output file name (default is to write to stdout)") private String outputFile; 
 : currentUser.getUserName().orElse(currentUser.getClass().getSimpleName())); 
 : currentUser.getUserName().orElse(currentUser.getClass().getSimpleName())); 
 List<SuggestedReviewerInfo> suggestedReviewers = loadAccounts(filteredRecommendations); if (!excludeGroups && suggestedReviewers.size() < limit && !Strings.isNullOrEmpty(query)) { 
 for (AccountGroup.UUID groupUuid : newGroupUuids) { if (groupIndexer.reindexIfStale(groupUuid)) { 
 } catch (RestApiException 
 throws OrmException, IOException, RestApiException { 
 throws OrmException, IOException, RestApiException { 
 throws IOException, RestApiException { 
 throws IOException, RestApiException { 
 } catch (RestApiException 
<|del|> 
 AccountGroup.UUID uuid = uuid(s.getUserName().isPresent() ? s.getUserName().get() : uuid(s.getAccount().getId())); 
<|del|> 
 blockFound = true; break; 
 private final Map<String, List<List<Permission>>> blockPerProjectByPermission; 
 private final Map<String, List<List<Permission>>> blockPerProjectByPermission; 
 // We allow owner to delete refs even if they have no force-push rights. We forbid 
 blockAllowMin = Math.max(projectBlockAllowMin, blockAllowMin); blockAllowMax = Math.min(projectBlockAllowMax, blockAllowMax); 
<|del|> 
 permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName); 
 private final IndexTs indexTs; 
<|del|> 
 updateIndexTs(LocalDateTime.now()); 
 private static final Logger log = LoggerFactory.getLogger(AccountReindexRunnable.class); 
 private static final Logger log = LoggerFactory.getLogger(ChangeReindexRunnable.class); 
 private static final Logger log = LoggerFactory.getLogger(ReindexRunnable.class); 
 logger.error("Unable to update {} index", indexName, e); 
 } catch (Exception e) { if (!isCausedByNoSuchChangeException(e)) { throw e; } logger.debug("Change {} was deleted, aborting forwarded indexing the change.", id.get()); 
 throw new CommitValidationException(message); 
 ((HttpServletResponse) response).sendError(SC_SERVICE_UNAVAILABLE, message); 
Copyright (C) 2018 The Android Open Source Project 
 GROUP_DOES_NOT_EXIST, 
 private boolean ignoreUnchangedPatchSet; 
<|del|> 
<|del|> 
 private PatchSetAttribute mockPatchSet = mock(PatchSetAttribute.class); 
 CACHE_SECTION, null, PATTERN_KEY, ImmutableList.of("^my_cache.*", "other")); 
 when(configurationMock.cache().patterns()).thenReturn(ImmutableList.of("^my_cache.*", "other")); 
 install(ItsRulesProjectCache.module()); 
 OrmException e = new OrmException(""); e.initCause(new NoSuchChangeException(id)); doThrow(e).when(schemaFactory).open(); 
 Path itsPath(SitePaths sitePaths) { return sitePaths.etc_dir.normalize().resolve(ITS_FOLDER); 
 "External ID not found. Attempting to create new account for: " 
 "User already has an account, link the account to new external ID- gerrit:" 
 // In case of missing entries in DB, an update is needed in the All-users repo // and an insert in the GerritDB, which is why "insert" operation is changed // to "upsert". 
<|del|> 
 OrmException e = new OrmException("test", new NoSuchChangeException(id)); 
 Map<String, String> extractFrom(AccountAttribute accountAttribute, String prefix) { 
 throw new UnloggedFailure(1, "SSH subsystem is temporarily disabled: " + config.message()); 
 throw new UnloggedFailure(1, "SSH subsystem is temporarily disabled: " + config.message()); 
 return account.isPresent() && Objects.toString(account.get().getAccount().getFullName(), "") .trim() .equalsIgnoreCase(nameOrEmail) 
 private final AbstractIndexRestApiServlet.IndexName indexName; 
 "Author Email Pattern", 
 "Commits with author email not matching one of these pattterns will be rejected.")); 
 "Committer Email Pattern", 
 "Commits with committer email not matching one of these patterns will be rejected.")); 
 public static final String KEY_AUTHOR_EMAIL_PATTERN = "authorEmailPattern"; public static final String KEY_COMMITTER_EMAIL_PATTERN = "committerEmailPattern"; 
 public static final String KEY_AUTHOR_EMAIL_PATTERN = "authorEmailPattern"; public static final String KEY_COMMITTER_EMAIL_PATTERN = "committerEmailPattern"; 
 * Several points should be noted: 
 * Several points should be noted: 
 * Several points should be noted: 
<|del|> 
 if (id == null && who.getUserName() != null) { 
 if (id == null && who.getUserName() != null) { 
 if (id == null && who.getUserName() != null) { 
 log.info("Link another authentication identity to an existing account"); 
 } log.info("Updating existing external id data"); 
 log.info("Linking new external ID for the existing account"); 
<|del|> 
 public List<SubmitRequirement> requirements; 
 * Represents a {@link SubmitRecord} that does not depend on Gerrit internal classes, to be 
 private final String shortReason; private final String fullReason; @Nullable private final String label; 
 /** * Represents a {@link SubmitRecord} that does not depends on Gerrit internal classes, to be * serialized and indexed. */ 
 import com.google.gerrit.common.data.SubmitRequirement; /** * Represents a {@link SubmitRequirement} that does not depends on Gerrit internal classes, to be * serialized and indexed. */ 
 public static boolean allRecordsOK(Collection<SubmitRecord> in) { 
 * Dispatch an event in the local node, event will not be forwarded to the other node. 
 return jiraUrl; 
 try { url = CharMatcher.is('/').trimFrom(url) + "/"; 
<|del|> 
<|del|> 
 private static final String URL = "http://jira_example.com"; 
 private void setUpCommonMocks() { 
 ignorePrivatePatchSet = configFactory.getFromProjectConfigWithInheritance( projectNameKey, CONFIG_NAME).getBoolean( "ignore-private-patch-set", true); 
 * @author James Hartig 
 * @author James Hartig 
 } else if (c.isAbandoned()) { 
 Pattern.compile("\"" + ACCESS_TOKEN + "\"\\s*:\\s*\"(\\S*?)\""); 
<|del|> 
 private static final String RESPONSE = "{\"" + ACCESS_TOKEN + "\":\"" + TOKEN + "\"}'"; 
Copyright (C) 2018 The Android Open Source Project 
 "External ID not found. Attempting to create new account for: {}", who.getUserName()); 
 "External ID not found. Attempting to create new account for: {}", who.getUserName()); 
 public Optional<String> label() { return Optional.ofNullable(label); 
 * Represents a {@link SubmitRecord.Label} that does not depend on Gerrit internal classes, to be * serialized. 
 @Singleton 
 @VisibleForTesting static final String DEFAULT_DRAFT_ITEM = "/q/owner:self+is:draft"; 
<|del|> 
 log.info("External ID not found. Attempting to create new account."); 
 public SubmitRequirement(String shortReason, String fullReason, @Nullable String label) { 
 if (o == null || !(o instanceof SubmitRequirement)) { 
 return MoreObjects.toStringHelper(this) .add("shortReason", shortReason) .add("fullReason", fullReason) .add("label", label) .omitNullValues() .toString(); 
 public ItsFacade getFacade(Project.NameKey project) { return its; 
 exists = its.exists(issueId); 
 ItsFacade its, String issue, ActionRequest actionRequest, Map<String, String> properties) 
<|del|> 
 ItsFacadeFactory itsFactory, 
<|del|> 
 its.addComment(issue, comment); 
 its.addComment(issue, comment); 
 its.addComment(issue, comment); 
 ItsFacade its, String issue, ActionRequest actionRequest, Map<String, String> properties) 
 Map<String, String> properties = ImmutableMap.of(PROJECT_KEY, TEST_PROJECT); 
<|del|> 
<|del|> 
<|del|> 
 sb.append("],["); 
 public SubmitRequirement(String shortReason, String fullReason, @Nullable String label) { 
<|del|> 
 if (o instanceof SubmitRequirement) { SubmitRequirement that = (SubmitRequirement) o; return Objects.equals(shortReason, that.shortReason) && Objects.equals(fullReason, that.fullReason) && Objects.equals(label, that.label); 
 @Inject 
<|del|> 
<|del|> 
 { scanner.useDelimiter("\\A"); 
<|del|> 
 cfgWithInheritance.setStringList( section, null, name, Stream.concat( Arrays.stream(cfg.getStringList(section, null, name)), Arrays.stream(parentValues)) .sorted() .distinct() .collect(Collectors.toList())); 
 cfgWithInheritance.setStringList( section, null, name, Stream.concat( Arrays.stream(cfg.getStringList(section, null, name)), Arrays.stream(parentValues)) .sorted() .distinct() .collect(Collectors.toList())); 
 assertAuditEvent(auditEvents.get(0), Type.REMOVE_USER, admin.id, user.id); 
 assertAuditEvent(auditEvents.get(0), Type.ADD_GROUP, admin.id, otherGroup); 
 return ImmutableList.copyOf(prologRule.evaluate(cd, opts)); 
 private static final SubmitRuleOptions defaults = 
<|del|> 
 OK_RECORD = new SubmitRecord(); OK_RECORD.status = SubmitRecord.Status.OK; NOT_READY_RECORD = new SubmitRecord(); NOT_READY_RECORD.status = SubmitRecord.Status.NOT_READY; 
 "match invoked, but child predicate %s doesn't implement %s", 
 "match invoked, but child predicate %s doesn't implement %s", 
 public void check(ProjectPermission perm) throws PermissionBackendException { throw new PermissionBackendException(message, cause); 
<|del|> 
 // TODO(aliceks): Add more tests. 
 pluginEvent.fire(pluginName, "project-created", replicateURI.toString()); 
 * a private state changed event. 
 * a work-in-progress state changed event. 
 Section elasticsearch = sections.get("elasticsearch", null); elasticsearch.string("Index Prefix", "prefix", "gerrit"); String name = ui.readString("default", "Server Name"); Section defaultServer = sections.get("elasticsearch", name); defaultServer.select( 
<|del|> 
<|del|> 
 List<AccountState> matchedAccountStates = 
 Account.Id accountId, InternalAccountUpdate accountUpdate) 
<|del|> 
 protected static void setHeaders(HttpServletResponse rsp) { 
 LabelFunction(String name, boolean isBlock, boolean isRequired, boolean requiresMaxValue) { 
 private final ProjectCache projectCache; 
 private final ProjectCache projectCache; 
 SubmitRecord submitRecord = new SubmitRecord(); submitRecord.status = SubmitRecord.Status.OK; 
 log.error("Unable to fetch labels and approvals for the change", e); submitRecord.errorMessage = "Unable to fetch labels and approvals for the change"; submitRecord.status = SubmitRecord.Status.RULE_ERROR; return Collections.singletonList(submitRecord); 
 log.error("Unable to fetch labels and approvals for the change", e); submitRecord.errorMessage = "Unable to fetch labels and approvals for the change"; submitRecord.status = SubmitRecord.Status.RULE_ERROR; return Collections.singletonList(submitRecord); 
 Collection<PatchSetApproval> approvalsForLabel = getApprovalsForLabel(approvals, t); SubmitRecord.Label label = labelFunction.check(t, approvalsForLabel); submitRecord.labels.add(label); 
 List<PatchSetApproval> approvals = ImmutableList.of(APPROVAL_1, APPROVAL_M2, APPROVAL_2); 
 .getInt(backend.type.name(), backend.name, "expirationSeconds", DEFAULT_TIMEOUT); 
 String accountName) { 
 @Singleton 
 } catch (IOException e) { 
 HttpResult result = session.post(url, content); if (!result.successful && execCnt < cfg.getMaxTries()) { 
 if (isRecoverable(e) && execCnt < cfg.getMaxTries()) { 
 ANY_WITH_BLOCK("AnyWithBlock", true, false, false), 
 public SubmitRecord.Label check(LabelType labelType, Iterable<PatchSetApproval> approvals) { SubmitRecord.Label submitRecordLabel = new SubmitRecord.Label(); submitRecordLabel.label = labelType.getName(); 
 DefaultSubmitRule(ProjectCache projectCache) { 
 private final PrologRuleEvaluator.Factory factory; 
 fail("should have thrown an IOException"); 
 boolean changeExists, boolean ormException, boolean ioException) 
<|del|> 
 private final IndexTs indexTs; 
 executor.schedule(task, 0L, TimeUnit.SECONDS).get(); 
<|del|> 
 if (key instanceof StringKey) { 
 long gracefulStopTimeout = cfg.getTimeUnit("httpd", null, "gracefulStopTimeout", 0L, TimeUnit.MILLISECONDS); if (gracefulStopTimeout > 0) { 
 httpd.setStopTimeout(gracefulStopTimeout); 
 // to load every account only once from disk. 
 } catch (IOException | ConfigInvalidException ignored) { log.warn( "Failed to load account {}." + " Cannot get account name for group audit log commit messages.", accountId.get(), ignored); 
<|del|> 
<|del|> 
 * <p>Note that the String may be null, if the administrator has not configured the value. Clients 
 private static final String SECTION = "gerrit"; private static final String KEY = "serverId"; 
 "Commits with committer or author email not matching one of these patterns will be rejected.")); 
 if (!rsrc.isUserOwner() && !permissionBackend.user(self).test(GlobalPermission.ADMINISTRATE_SERVER)) { throw new AuthException("not allowed to set ready for review"); 
 if (!rsrc.isUserOwner() && !permissionBackend.user(self).test(GlobalPermission.ADMINISTRATE_SERVER)) { throw new AuthException("not allowed to set work in progress"); 
 log.error("Unable to fetch labels and approvals for change %s: %e", cd.getId(), e); 
 Streams.concat( Streams.stream(getFooterForRename()), getFootersForMemberModifications(), getFootersForSubgroupModifications()) .sorted() .forEach(footerJoiner::add); 
 private Collection<ReviewerUpdateInfo> reviewerUpdates(ChangeData cd) throws OrmException { 
<|del|> 
<|del|> 
 String expectedRequest = 
<|del|> 
Copyright (C) 2017 The Android Open Source Project 
 checkNotNull(projectState, "fail to create project " + args.getProject().get()); 
 checkNotNull(projectState, "failed to create project " + args.getProject().get()); 
 ProjectState projectState = projectCache.get(projectName); checkNotNull(projectState, "Failed to load project %s", projectName); 
 log.error("Unable to fetch labels and approvals for change {}", cd.getId(), e); 
 log.error("Unable to fetch labels and approvals for change {}", cd.getId(), e); 
 "Unable to find the LabelFunction for label {}, change {}", t.getName(), cd.getId()); 
 public static final String PLUGIN_NAME = "simple-submit-rules"; public static final String API_ENDPOINT = PLUGIN_NAME; 
 permissionBackend .user(resource.getUser()) .project(resource.getNameKey()) .check(ProjectPermission.READ_CONFIG); 
 permissionBackend .user(resource.getUser()) .project(resource.getNameKey()) .check(ProjectPermission.READ_CONFIG); 
 public Object apply( ProjectResource resource, com.googlesource.gerrit.plugins.simplesubmitrules.config.SubmitConfig inConfig) throws PermissionBackendException, RestApiException, IOException { 
 public Object apply( ProjectResource resource, com.googlesource.gerrit.plugins.simplesubmitrules.config.SubmitConfig inConfig) throws PermissionBackendException, RestApiException, IOException { 
public final class ConfigTranslator { 
 static void applyCopyScoresTo(Collection<String> copyScores, LabelType labelType) { 
 throw new BadRequestException( 
<|del|> 
 static class CommentsRules { 
 SubmitRecord sr = new SubmitRecord(); sr.status = Status.RULE_ERROR; sr.errorMessage = "Error when counting unresolved comments"; return ImmutableList.of(sr); 
<|del|> 
 refName != null ? "." + refName : "", 
 "The label " + label + " does not exist. You can't change its config."); 
 IdentifiedUser identifiedUser = identifiedUserFactory.create(checkNotNull(user, "user")); return new WithUserImpl(identifiedUser); 
 @VisibleForTesting protected static String getShortProjectName(String projectName) { 
<|del|> 
 public void testPushCommitWithIssueExists() throws Exception { 
<|del|> 
<|del|> 
 if (state == null) { 
<|del|> 
<|del|> 
 setURL("http://jira.mycompany.com/myroot/"); restApi = new JiraRestApi(url, user, password, JiraIssue.class, ISSUE_CLASS_PREFIX); 
<|del|> 
 protected static Path createDirectories(Path path) throws IOException { 
 throws IOException, NoSuchRefException, RepositoryNotFoundException, IntegrationException, BadRequestException { 
 // Not allowed to create a new patch set if the current patch set is locked. 
 // The change can't be restored if its current patch set is locked. 
 value = "<a href=\"" + URL + "/browse/$1\">$1</a>" 
 @GerritConfig(name = PLUGIN_NAME + ".username", value = "user") @GerritConfig(name = PLUGIN_NAME + ".password", value = "pass") public void testIssueExists() throws Exception { createItsRulesConfig(false, false); 
 @GerritConfig(name = PLUGIN_NAME + ".username", value = "user") @GerritConfig(name = PLUGIN_NAME + ".password", value = "pass") public void testIssueExists() throws Exception { createItsRulesConfig(false, false); 
 @GerritConfig(name = PLUGIN_NAME + ".username", value = "user") @GerritConfig(name = PLUGIN_NAME + ".password", value = "pass") public void testIssueExistsWithCommentSuccessful() throws Exception { createItsRulesConfig(true, false); 
 @GerritConfig(name = PLUGIN_NAME + ".username", value = "user") @GerritConfig(name = PLUGIN_NAME + ".password", value = "pass") public void testIssueForbidden() throws Exception { createItsRulesConfig(false, false); 
 if (GlobalCapability.isGlobalCapability(name)) { 
 if (!args.config.getBoolean("index", "enableCanSeeQueries", true)) { 
 if (isConfigRef(rsrc.getBranchKey().get())) { // Never allow to delete the meta config branch. throw new MethodNotAllowedException( "not allowed to delete branch " + rsrc.getBranchKey().get()); 
 if (isConfigRef(rsrc.getBranchKey().get())) { // Never allow to delete the meta config branch. throw new MethodNotAllowedException( "not allowed to delete branch " + rsrc.getBranchKey().get()); 
 if (isConfigRef(tag)) { // Never allow to delete the meta config branch. throw new MethodNotAllowedException("not allowed to delete " + tag); 
<|del|> 
 modules.add(new IndexCommandsModule()); 
 blobs.add( new ByteArrayWrapper(externalIds.get(ExternalId.Key.parse(info.identity)).toByteArray())); 
 if (enableProjectRules) { // This cache is auxiliary to the project cache, so size it the same. machineCache = CacheBuilder.newBuilder().maximumSize(projectCacheSpec.maximumWeight()).build(); } else { machineCache = null; } 
 exception.expectMessage(String.format("change %s is merged", change._number)); 
 checkPatchSetNotLocked( approvalsUtil, projectCache, dbProvider.get(), rsrc.getNotes(), rsrc.getUser()); 
/** Implementation of GroupBackend for tests. */ 
 @Inject private TestGroupBackend backend; @Inject private UniversalGroupBackend universalBackend; 
 @Inject private TestGroupBackend backend; @Inject private UniversalGroupBackend universalBackend; 
<|del|> 
 public void returnsNullWhenNoGroupsExist() throws Exception { 
<|del|> 
 return reqInfos; 
 out.labels = labelsFor(cd, has(LABELS), has(DETAILED_LABELS)); 
 private static class CustomSubmitRule implements SubmitRule { 
 // Doesn't have any custom data value 
 String configKey(); 
 public CacheBinding<K, V> configKey(String name) { 
 return cds.stream().sorted(COMPARATOR).collect(toList()); 
 // Perform more expensive walk-sort. 
 SQLStore( 
<|del|> 
 .currentUser() 
 PermissionBackend permissionBackend) { 
 new ResourceConflictException("email in use by another account"))); return; 
 stderr.println("Cannot activate index, unknown based on this name"); 
<|del|> 
<|del|> 
<|del|> 
 * @throws NoSuchChangeException * @throws NoSuchProjectException 
<|del|> 
<|del|> 
 @VisibleForTesting public static final String PREFIX = "testbackend:"; 
 return id != null && id.startsWith(PREFIX); 
 parent = URLClassLoader.newInstance(extapi.toArray(new URL[extapi.size()]), parent); 
 Optional<GlobalPermission> perm = globalPermission(capability); 
 Optional<GlobalPermission> perm = globalPermission(capability); 
 Optional<GlobalPermission> perm = globalPermission(name); 
 .orElseThrow(() -> new IllegalStateException("no name for " + refPermission)); 
 .orElseThrow(() -> new IllegalStateException("no name for " + changePermission)); 
<|del|> 
<|del|> 
 public ForProject project(Project.NameKey project) { 
 private final List<String> allowSshCommands; 
 public <T> JiraRestApi<T> get(Class<T> classOfT, String classPrefix) { 
 public JiraRestApi<JiraIssue> getIssue() { 
 public JiraRestApi<JiraServerInfo> getServerInfo() { 
 public JiraRestApi<JiraProject[]> getProjects() { 
 public Update accept(Set<ConfigKey> entries) { return createUpdate(entries, UpdateResult.ACCEPTED); 
 .filter(this::isValueUpdated) 
 return updates; 
 if (isValueUpdated(entry.section(), entry.subsection(), entry.name())) { 
 public List<ConfigUpdatedEvent.Update> reloadConfig() { 
 List<ConfigUpdatedEvent.Update> configUpdated(ConfigUpdatedEvent event); 
 synchronized (lock) { gerritConfig = loadConfig(); return gerritConfig; 
 ConfigUpdatedEvent updateEvent; synchronized (lock) { updateEvent = new ConfigUpdatedEvent(configProvider.get(), configProvider.updateConfig()); } 
public class SuggestReviewers { 
 private volatile List<CommentLinkInfo> commentLinks; 
 // throws ClassNotFoundException later 
 return FailedPermissionBackend.project( "project '" + project.get() + "' not found", new RepositoryNotFoundException(project.get())); 
public class JiraModule extends AbstractModule { 
<|del|> 
 private final Gson gson; 
<|del|> 
 synchronized (lock) { if (enabled && async == null) { enableLogging(); } else if (!enabled && async != null) { disableLogging(); } 
 synchronized (lock) { if (enabled && async == null) { enableLogging(); } else if (!enabled && async != null) { disableLogging(); } 
 try (TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree())) { 
 try (TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree())) { 
 } while (jiraUrl != null && (isConnectivityRequested(jiraUrl) && !isJiraConnectSuccessful())); 
 * If not cached yet the accounts are loaded. If an account can't be loaded (e.g. because it is 
 * If not cached yet the accounts are loaded. If an account can't be loaded (e.g. because it is 
 * account IDs, if an account can't be loaded (e.g. because it is missing), the entry will be 
<|del|> 
 return keyPair; 
 bind(LifecycleListener.class) .annotatedWith(UniqueAnnotations.create()) .to(ReplicationQueue.class); 
 rpi.range = rp.getRangeString(); 
 public interface Factory { ProjectAccessor create(ProjectState projectState); 
 boolean serverEnableSignedPush, ProjectAccessor.Factory projectAccessorFactory, // TODO(dborowitz): Replace with Project.NameKey once ProjectAccessor has enough methods to // satisfy all uses of ProjectState in this method. 
 public ExecutorService createFanOutExecutor( 
 * <p><strong>Note:</strong> This interface is not implemented using the REST or extension API. * Hence, it cannot be used for testing those APIs. 
<|del|> 
 public ProjectState getWithCause(Project.NameKey projectName) throws ExecutionException { 
<|del|> 
 AccountState state = accountStates.get(id); if (state != null) { 
 public synchronized Map<Account.Id, AccountState> get(Set<Account.Id> accountIds) { return ImmutableMap.copyOf(Maps.filterKeys(byId, accountIds::contains)); 
<|del|> 
 private static ElasticNodeInfo elasticNodeInfo; 
 private final Class<T> clazz; 
 return new Key<>(clazz, ImmutableList.copyOf(identifiers)); 
 assertThat(PerThreadCache.Key.create(String.class)) .isEqualTo(PerThreadCache.Key.create(String.class)); assertThat(PerThreadCache.Key.create(String.class)) .isNotEqualTo(PerThreadCache.Key.create(Integer.class)); 
 assertThat(cache.get(key1, neverCalled)).isEqualTo("value1"); 
 /** * Returns a unique identifier for this user that is intended to be used as a cache key. Returned * object should to implement {@code equals()} and {@code hashCode()} for effective caching. */ 
 assertAuditEvent(auditEvents.get(0), Type.REMOVE_GROUP, admin.id, otherGroup); 
 ConfigKey sshdRequestLog = ConfigKey.create("sshd", "requestLog"); if (!event.isValueUpdated(sshdRequestLog)) { 
 if (enabled) { stateUpdated = enableLogging(); } else { stateUpdated = disableLogging(); 
 * @throws Exception in case of any error. 
 public ProjectState uncheckedGet(Project.NameKey projectName) throws Exception; 
 public ProjectState uncheckedGet(Project.NameKey projectName) throws Exception; 
 update.deleteChangeMessageByRewritingHistory(targetMessageIdx, newMessage); 
<|del|> 
 private static final FluentLogger logger = FluentLogger.forEnclosingClass(); 
<|del|> 
 return updates .keySet() 
 * @return the cached data; null if no such project exists, projectName is null or an error 
 * @return the cached data; null if no such project exists, projectName is null or an error 
 ProjectState get(@Nullable Project.NameKey projectName); 
 return refName.startsWith("refs/for/") || refName.equals("refs/*"); 
 return refName.startsWith("refs/for/") || refName.equals("refs/*"); 
 private static final String MSG_NOT_SUPPORTED = "This is read-only wrapper. Modifications are not supported"; 
 throws RestApiException, PermissionBackendException { 
 Collectors.groupingBy(m -> m.getClass().getAnnotation(CacheImpl.class) != null)); 
 .filter(o -> o.getClass().getAnnotation(CacheImpl.class).type() == a.type()) 
public class PutActive implements RestModifyView<AccountResource, Input> { 
 public static final String MEMORY_MODULE = "cache-memory"; 
 "You need 'Create Review' rights to upload code review requests.", 
 "This is a read-only wrapper. Modifications are not supported"; 
 log.error("Memory cache for persistent backend {} should be of LoadingCache type", name); 
 log.warn("Invalid object key type [{}] was provided for cache {}", objKey, name); 
 if (e.getCause() instanceof RepositoryNotFoundException) { logger.warn("Could not find repository of the project {} : ", e.getMessage(), e); 
Copyright (C) 2018 The Android Open Source Project 
 public String permission; public Boolean force; public String range; 
 public List<RolePermissionInfo> permissions; 
 log.info("Finishing {} disk cache updates", pending.size()); 
 "Entries cached for {} " + "have an incompatible class and can't be deserialized. " + "Cache is flushed.", name); 
 log.warn("Cannot build BloomFilter for {}: {}", name, e.getMessage()); 
 log.warn("Cannot read cache {} for {}", name, key, e); 
 log.warn("Cannot put into cache {}", name, e); 
 log.warn("Cannot invalidate cache {}", name, e); 
 log.warn("Cannot prune cache {}", name, e); 
 log.warn("Cannot get DiskStats for {}", name, e); 
<|del|> 
 if (e.getCause() instanceof RepositoryNotFoundException) { logger.warn("Could not find repository of the project {} : ", e.getMessage(), e); 
 public void addPermission(Permission permission) { List<Permission> permissions = getPermissions(); for (Permission p : permissions) { if (p.getName().equalsIgnoreCase(permission.getName())) { throw new IllegalArgumentException(); } 
 log.info("Identified user {} was created from {}", user.toString(), who.getUserName()); 
<|del|> 
 log.error( "External id with scheme \"username:\" already exists for the user {}", user.getAccountId()); 
 String function; boolean ignoreSelfApproval; Set<String> copyScores; 
 public void blocksWhenAutorIsOnlyApprover() throws Exception { 
enum ObjectKeyTypeImpl implements KeyType<Object> { INSTANCE; 
 } permissions.add(permission); 
<|del|> 
 public void setKey(PreparedStatement ps, int col, String value) throws SQLException { ps.setString(col, value); 
<|del|> 
<|del|> 
 .user(user) 
 permissionBackend.currentUser().project(nameKey).check(ProjectPermission.ACCESS); 
 Collection<Rule> fromProjectConfig = rulesProjectCache.get(projectName); 
 /** Simple rule: require a non-author approval or block submission */ 
 log.error(E_UNABLE_TO_FETCH_CHANGE_OWNER, e); 
 throw new BadRequestException("change message id is required"); 
 AccountLoader accountLoader = accountLoaderFactory.create(true); 
<|del|> 
<|del|> 
 abstract Builder active(boolean active); 
 /** Serializes the object to a new byte array. */ byte[] serialize(T object) throws IOException; 
 public Funnel<K> funnel() { return new Funnel<K>() { 
 private int version; 
 c.put.setBytes(2, valueSerializer.serialize(holder.value)); c.put.setInt(3, version); c.put.setTimestamp(4, new Timestamp(holder.created)); c.put.setTimestamp(5, TimeUtil.nowTs()); 
 try (Statement s = c.conn.createStatement()) { // Compute size without restricting to version (although obsolete data was just pruned // anyway). 
 checkNotFrozen(); 
 b.setStrategyName(object.getStrategyName()); return ProtoCacheSerializers.toByteArray(b.build()); 
 checkPatchSetNotLocked(approvalsUtil, projectCache, reviewDb.get(), notes, currentUser.get()); 
 return in.stream().map(SubmitRecord::status).allMatch(SubmitRecord.Status::allowsSubmission); 
 PreparedStatement changesForProject = conn.prepareStatement("SELECT change_id FROM changes WHERE dest_project_name = ?"); changesForProject.setString(1, project.getName()); java.sql.ResultSet resultSet = changesForProject.executeQuery(); 
 PreparedStatement changesForProject = conn.prepareStatement("SELECT change_id FROM changes WHERE dest_project_name = ?"); changesForProject.setString(1, project.getName()); java.sql.ResultSet resultSet = changesForProject.executeQuery(); 
 WebhooksConfig whc = webhooksConfig.get(); whc.load(md); whc.deleteRemote(rsrc.getRemoteConfig().getName()); whc.commit(md); 
 private static Clock clock = Clock.systemDefaultZone(); 
<|del|> 
 private int order; 
 commits.sort(comparing((CodeReviewCommit c) -> c.getPatchsetId().get()).reversed()); 
 private int createOneChangeWithMultipleChangeMessagesInHistory() throws Exception { 
 public ChangeMessageInfo get() throws RestApiException { 
<|del|> 
 log.error("Failed to reindex the {} online: {}", name, e.getMessage(), e); 
 log.warn("Error trying to archive {}. Repo is now in trash", repoFile.toPath(), e); 
 .addAll(getRulesFromFile(rulesConfigReader, globalRuleFile)) .addAll(getRulesFromFile(rulesConfigReader, itsSpecificRuleFile)) 
 expect(rulesConfigReader.getRulesFromConfig(isA(Config.class))) 
 log.error("Online reindex of {} schema version {} failed", name, version(index), e); 
 log.error( "Online reindex of {} schema version {} failed", name, version(index), e.getMessage(), e); 
 log.error(ERROR_MSG, url, e); throw new IllegalArgumentException(format(ERROR_MSG, url, e.getLocalizedMessage())); 
 throw new RuntimeException( format( "Missing one or more configuration values - url : '%s'," + " username: '%s'," + " password : '%s'", projectUrl, projectUsername, projectPassword)); 
 log.error(ERROR_MSG, url, e); throw new IllegalArgumentException(format(ERROR_MSG, url, e.getLocalizedMessage())); 
 url = new JiraURL("http://jira.mycompany.com/myroot"); 
 url = new JiraURL("http://jira.mycompany.com"); 
 if (event.getRefName().equals(RefNames.REFS_CONFIG)) { 
 permissionBackend.user(callingUser).check(GlobalPermission.ADMINISTRATE_SERVER); 
 this.perm = permissionBackend.user(user); 
 this.perm = permissionBackend.user(user); 
 permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER); 
 /** Returns the full commit message for the given project at the given patchset revision */ public String getFullCommitMessage(Project.NameKey project, PatchSet patchSet) throws IOException { 
<|del|> 
 public byte[] serialize(Boolean object) { byte[] bytes = checkNotNull(object) ? TRUE : FALSE; 
 b.setSubmitType(SUBMIT_TYPE_CONVERTER.reverse().convert(object.getSubmitType())); 
 SUBMIT_TYPE_CONVERTER.convert(proto.getSubmitType()), 
 assertRoundTrip(MyEnum.FOO); assertRoundTrip(MyEnum.BAR); assertRoundTrip(MyEnum.BAZ); 
<|del|> 
 cout.writeInt32NoTag(checkNotNull(object)); 
<|del|> 
<|del|> 
 public boolean deleteChangeFromIndex(final int changeId, IndexEvent event) { return execute( RequestMethod.DELETE, "delete change", "index/change", buildIndexEndpoint(changeId), event); 
 private static final String PROJECT_NAME = "test/project"; 
 this.defaultQueueSize = defaultThreadPoolSize; 
<|del|> 
 private Map<String, Ref> fastHideRefsMetaConfig(Map<String, Ref> refs) throws PermissionBackendException { 
 .owner(new Account.Id(1000)) 
 newBuilder().columns(cols.toBuilder().owner(new Account.Id(7777)).build()).build(), 
 executeIndexChangeTask("", id, true); 
 RevObject obj = rw.peel(rw.parseAny(newObjectId)); 
 * ListProjects) break the assumption that the data cached in a request is limited. To prevent * this class from accumulating an unbound number of objects, we enforce this limit. 
 try (PerThreadCache cache = PerThreadCache.create()) { 
 PerThreadCache.Key<String> key = PerThreadCache.Key.create(String.class, 1000); String value3 = cache.get(key, () -> "directly served"); 
 for (int i = 0; i < 50; i++) { 
 PerThreadCache.Key<String> key = PerThreadCache.Key.create(String.class, 1000); cache.get(key, () -> "new value"); 
 public void serializeToString() throws Exception { for (MyEnum value : MyEnum.values()) { assertRoundTripToString(value); } 
 json.format(new ReviewerInfo(accountId.get()), perm.absentUser(accountId), cd)); 
 perm.absentUser(psa.getAccountId()), 
<|del|> 
 private final EncryptionConfig config; 
 return base64Encode(ivParameterSpec.getIV()) + DELIMITER + base64Encode(cryptoText); 
<|del|> 
<|del|> 
 public void setUpMocks() { 
 if (!self.get().hasSameAccountId(rsrc.getUser())) { 
 public int iterations() { return gerritConfig.getInt(SECTION, "iterations", ITERATION_COUNT); 
 public static final int KEY_LENGTH = 256; public static final int RESTRICTED_KEY_LENGTH = 128; 
 secureStore.set( SECTION, null, KEY, createSecretKey(randomString().toCharArray(), newSalt())); 
 private String decrypt(String encryptedString, SecretKeySpec key) throws GeneralSecurityException { List<String> encryptedTokens = Splitter.on(DELIMITER).splitToList(encryptedString); 
 public void testDecrypt() throws Exception { String encoded = encryptor.encrypt(PLAINTEXT_PASSWORD); 
 public void testGetJGroupsMyUrlFromListenUrlWhenNoListenUrlSpecified() throws Exception { 
 void run(SitePaths replica, FileBasedConfig pluginConfig) throws Exception { this.replica = replica; 
Copyright (C) 2018 The Android Open Source Project 
<|del|> 
<|del|> 
 "Unable to authenticate user by %s request header." + " Check container or server configuration.", 
 logger.atWarning().withCause(e.getException()).log("Internal error"); 
 "String too long \"%s\" in gerrit.config %s.%s.%s (max %d char)", 
 logger.atWarning().withCause(e).log(error); 
 "%s ms timeout reached for Diff loader in project %s" 
 logger.atSevere().withCause(e).log(err); 
 logger.atSevere().withCause(e).log(err); 
 logger.atFine().logVarargs(submissionId + msg, args); 
 logger.atSevere().log(msg); 
 logger.atFine().withCause(t).log(requestId + "%s", msg); 
 log.error("Error collecting changes for project {}", name, e); 
 return user(identifiedUserFactory.create(id)); 
 return new RefControl(identifiedUserFactory, newCtl, refName, relevant); 
 * @param gerritRuntime current Gerrit runtime (daemon, batch, ...) 
 public static final String BLOCK_MODE = "GCM"; public static final String PADDING = "NoPadding"; 
 log.debug("No implementation for {}", name, e); 
 log.warn("'{}' failed to sign in: {}", username, e.getMessage()); 
 log.warn("'{}' failed to sign in", username, e); 
 error -> log.error("Error parsing file {}: {}", GroupList.FILE_NAME, error.getMessage())); 
 wrongEmail = (ids == null || ids.isEmpty()); 
 for (;;) { 
 Address address = Iterables.getOnlyElement(ccs); 
 synchronized(this) { if (queue == null) { queue = workQueue.createQueue(1, "HookQueue"); } } 
 .setId(ObjectIdConverter.create().toByteString(object.id())) 
 .metaId(ObjectIdConverter.create().fromByteString(proto.getMetaId())) 
 if (!self.get().hasSameAccountId(rsrc.getUser())) { 
 if (!self.get().hasSameAccountId(rsrc.getUser())) { 
 if (!self.get().hasSameAccountId(resource.getUser())) { 
 res.setCharacterEncoding(UTF_8.name()); 
 "Address {} could not be matched to a unique account. It was matched to {}." + " Will delete message.", 
 "Message {} references unique change {}, but there are {} matching changes in the index." + " Will delete message.", 
 JsonObject obj = new JsonParser().parse(content).getAsJsonObject().getAsJsonObject("hits"); 
 JsonObject obj = new JsonParser().parse(content).getAsJsonObject().getAsJsonObject("hits"); 
<|del|> 
 private final String name; 
<|del|> 
 this.urlFormatter = urlFormatter; 
<|del|> 
 "Message {} references unique change {}, but there are {} matching changes in " + "the index. Will delete message.", 
 this.approvalsUtil = approvalsUtil; this.changeControlFactory = changeControlFactory; 
 private static class PredicateModule extends AbstractModule { 
 // There is the concept of LifecycleModule, in Gerrit's own extension to Guice, which has these: 
 protected static Class<? extends Module> load(@Nullable String name, ClassLoader pluginLoader) 
@Ignore @UseLocalDisk 
 try { return new PathOwners(resolver, repository, patchList); } catch (OrmException e) { throw new SystemException(e.getMessage()); } } }; 
 return createAndStart(null); 
 public static ElasticContainer<?> createAndStart(@Nullable String version) { String dockerImageName = String.format("elasticsearch:%s-alpine", version != null ? version : "2.4.6"); 
 return createAndStart(null); 
 container = ElasticContainer.createAndStart(ElasticVersion.V5_6); 
<|del|> 
 super(cfg, null, sitePaths, schema, clientBuilder, ACCOUNTS); 
 Response response = performRequest(HttpPost.METHOD_NAME, bulk, uri, getRefreshParam()); 
 super(cfg, null, sitePaths, schema, clientBuilder, GROUPS); 
 bind(Property.Factory.class).toInstance(propertyFactory); //factory(Property.Factory.class); 
 RuntimeShutdown.manualShutdown(); // Prevent the infinite loop 
 assertAbout(exitCode()).that(exitCode).isEqualTo(128); 
 assertThat(Files.exists(path)).named(site.site_path.getFileName() + " exists").isFalse(); 
 new Init(site.site_path).main(new String[] {"--batch"}); 
 new Init(site.site_path).main(new String[] {"--batch"}); 
 assertAbout(exitCode()).that(exitCode).isSuccessful(); 
 assertAbout(exitCode()).that(exitCode).isSuccessful(); } 
 ElasticConfiguration cfg, 
 String[] propertyValues = property != null ? property.split(" ") : new String[] {}; for (String p : propertyValues) { 
 if (Strings.isNullOrEmpty(propertyId)) { 
public class AddPropertyToFieldTest extends MockingTestCase { 
<|del|> 
<|del|> 
 log.error("Unable to get SSH clone url.", e); 
 log.info("Failed to use clone url type configuration." + " Using default type (prefer SSH, then HTTP, then Git)."); 
class ElasticRestClientProvider implements Provider<RestClient>, LifecycleListener { 
 if (Pattern.compile(value.toString()).matcher(version).matches()) { 
 return searchFilteringName; 
 return searchFilteringName; 
 response = performRequest("PUT", indexName, indexCreationFields); 
 assertThat(ElasticVersion.forVersion("2.4.6")).isEqualTo(ElasticVersion.V2_4); 
 * A static factory for simple "import static" usage. 
 if (value.pattern.matcher(version).matches()) { 
 String keywordFieldType() { return keywordFieldType; 
@Singleton 
 @GerritServerId String serverId) { 
 ChangeNoteJson changeNoteJson = injector.getInstance(ChangeNoteJson.class); 
Copyright (C) 2018 The Android Open Source Project 
 if (fieldType == FieldType.EXACT) { mapping.addExactField(name); } else if (fieldType == FieldType.KEYWORD) { mapping.addKeywordField(name); 
 Builder addExactField(String name) { 
 protected RefUpdater refUpdater; protected IdentifiedUser user; protected BatchStore store; 
 WebhooksConfig wh = webhooksConfig.get(); wh.load(md); wh.deleteRemote(rsrc.getRemoteConfig().getName()); wh.commit(md); 
 logger.atInfo().log( "Configuration reloaded: %d destinations, %d replication events discarded", currentConfig.getDestinations(FilterType.ALL).size(), discarded); 
 protected abstract void doIndex(T id, Optional<Object> maybeBody) throws IOException, OrmException; 
 protected Optional<Object> parseBody(@SuppressWarnings("unused") ServletInputStream bodyIn) { 
import static org.mockito.ArgumentMatchers.any; import static org.mockito.ArgumentMatchers.anyString; import static org.mockito.ArgumentMatchers.eq; 
<|del|> 
<|del|>
 if (isChangeUpToDate(changeTs, indexEvent, changeTsGraceInterval)) { indexer.index(db, change.getChange()); 
 if (retryCount >= maxTries) { 
Copyright (C) 2018 Ericsson // Copyright (C) 2018 GerritForge Ltd 
Copyright (C) 2018 Ericsson // Copyright (C) 2018 GerritForge Ltd 
 CommentsUtil commentsUtil, PatchListCache patchListCache, PatchSetUtil psUtil) { 
 String action, String id, String index, String type, ElasticQueryAdapter adapter) { 
<|del|> 
<|del|> 
 private void doIndex(String id, Optional<?> maybeBody, int retryCount) 
 private void rescheduleIndex(final String id, final Optional<?> maybeBody, int retryCount) { 
 private void rescheduleIndex(final String id, final Optional<?> maybeBody, int retryCount) { 
 private void rescheduleIndex(final String id, final Optional<?> maybeBody, int retryCount) { 
 log.debug("Change {} successfully indexed (retryCount={})", id, retryCount); 
 PackInserter ins = ((FileRepository) repo).getObjectDatabase().newPackInserter(); ins.checkExisting(false); return ins; } 
 ObjectInserter ins = newPackInserter(repo)) { 
<|del|> 
<|del|> 
 readNote(notes, commit); 
import com.sun.xml.internal.messaging.saaj.util.ByteOutputStream; import java.io.ByteArrayOutputStream; 
 public void testNoActionsOrNoIssues() { 
 RestView<P> list() throws RestApiException; 
 private final int changeTsGraceInterval; 
 private void rescheduleIndex(String id, Optional<?> maybeBody, int retryCount) { 
 private class TestModule extends FactoryModule { @Override protected void configure() { parametersExtractor = createMock(AddPropertyToFieldParametersExtractor.class); bind(AddPropertyToFieldParametersExtractor.class).toInstance(parametersExtractor); 
 its = createMock(ItsFacade.class); bind(ItsFacade.class).toInstance(its); } 
 GroupInfo group = createGroup(name("group")); String query = "uuid:" + group.id; assertQuery(query, group); 
 super(cfg, sitePaths, schema, client, ACCOUNTS); 
 private final ChangeData.Factory changeDataFactory; private final FillArgs fillArgs; private final Schema<ChangeData> schema; 
 this.fillArgs = fillArgs; this.schema = schema; this.mapping = new ChangeMapping(schema, client.adapter()); 
 log.error("Cannot retrieve project owner ACL", e); 
 log.error("Cannot retrieve project owner ACL", e); 
 AccountInfo user = newAccountWithFullName("jdoe", "John Doe"); 
 return httpSession.post(buildIndexEndpoint(projectName, changeId), event); 
import static org.mockito.ArgumentMatchers.any; import static org.mockito.ArgumentMatchers.anyString; import static org.mockito.ArgumentMatchers.eq; 
 /** Parameters needed by {@link AddPropertyToField} action */ 
 /** @return The event property's value to add to the ITS field */ 
 /** @return The id of the ITS field to which the property value is added */ 
 this.headless = headless || (!enableGwtUi && !enablePolyGerrit); 
 String uiStr = "polygerrit"; 
 UiType defaultUi = enablePolyGerrit ? UiType.POLYGERRIT : UiType.GWT; 
<|del|> 
 GWT, POLYGERRIT; 
 this.headless = headless; 
 public List<String> branches; /** Maximum number of commits per branch to walk. */ public Integer maxCommits; 
<|del|> 
public class LogEvent extends IssueAction { 
<|del|> 
 assertTrue(itsProjectName.isPresent()); 
 } else if (action.getType() == ActionType.ISSUE) { action.execute(its, issue, actionRequest, properties); 
 action.execute(its, itsProject, actionRequest, properties); 
/** Creates a version in the ITS. The value of the version is extracted from an event property. */ public class CreateVersionFromProperty implements Action { 
 /** Parameters needed by {@link CreateVersionFromProperty} action */ 
class CreateVersionFromPropertyParametersExtractor { 
 /** The properties extracted from a {@link com.google.gerrit.server.events.RefEvent} */ 
 /** * @param projectProperties Properties of the ref event * @param issuesProperties Properties of the ref event added of the properties specific to the * issues. There will be as many set of properties as number of issues */ 
 Optional<String> itsProjectName = itsConfig.getItsProjectName(new Project.NameKey("testProject")); if (!itsProjectName.isPresent()) { fail(); } assertEquals("itsProject", itsProjectName.get()); 
 private long computeLastChangeTs(ReviewDb db, ChangeNotes change) { 
 String username, Provider<CurrentUser> userProvider, PermissionBackend permissionBackend) { 
 forwardedIndexingHandler.index(id, operation, parseBody(req.getInputStream())); 
import java.time.LocalDateTime; import java.time.ZoneOffset; import java.time.format.DateTimeFormatter; 
 protected void doIndex(String id, Optional<?> body) throws IOException, OrmException { 
 protected void doIndex(AccountGroup.UUID uuid, Optional<?> body) 
 protected abstract void doIndex(T id, Optional<?> body) throws IOException, OrmException; 
<|del|> 
 public void index(T id, Operation operation, Optional<?> body) 
 protected void doIndex(Account.Id id, Optional<?> body) throws IOException, OrmException { 
 return httpSession.post(buildIndexEndpoint(projectName, changeId), event); 
 return httpSession.post(buildIndexEndpoint(projectName, changeId), event); 
Copyright (C) 2018 The Android Open Source Project 
Copyright (C) 2015 The Android Open Source Project 
 "Change {} seems too old compared to the event timestamp (event-Ts={} >> change-Ts={})", 
 @DefaultInput public String id; 
 public DeleteChangeMessageInput(String id, String reason) { this.id = Strings.nullToEmpty(id); 
<|del|> 
<|del|> 
 sanitizedInput.topic = sanitizedInput.topic.trim(); 
Copyright (C) 2018 The Android Open Source Project 
 return String.format( "%s <%s>", args.gerritPersonIdent.getName(), args.gerritPersonIdent.getEmailAddress()); 
 return String.format( "%s <%s>", args.gerritPersonIdent.getName(), args.gerritPersonIdent.getEmailAddress()); 
 : Sets.difference( EnumSet.allOf(FillOptions.class), EnumSet.of(FillOptions.SECONDARY_EMAILS)); 
 log.error("Issue {} does not exist", issueKey); 
 return null; 
 protected List<RevCommit> getChangeMetaCommitsInReverseOrder(Change.Id changeId) 
 throws OrmException, IOException { if (PrimaryStorage.of(update.getChange()).equals(PrimaryStorage.REVIEW_DB)) { 
 if (migration.readChanges()) { sanityCheckForChangeMessages(messagesInReviewDb, update.getNotes().getChangeMessages()); } ChangeMessage targetMessage = messagesInReviewDb.get(targetMessageIdx); 
 revWalk.markStart(revWalk.parseCommit(currTip)); revWalk.sort(RevSort.TOPO); 
 checkState(range.isPresent(), "failed to parse commit message"); 
 checkState(range.isPresent(), "failed to parse commit message"); 
 * @param parentCommitId the parent of the new commit. For the first rewritten commit, it's the * parent of 'originalCommit'. For the latter rewritten commits, it's the commit rewritten * just before it. 
 public static String createNewChangeMessage(String deletedBy, @Nullable String deletedReason) { checkNotNull(deletedBy, "user name must not be null"); 
 return String.format("Change message removed by: %s;\nReason: %s", deletedBy, deletedReason); 
 try { deleteOneChangeMessage(changeNum, 0, user, "spam"); fail("expected AuthException"); } catch (AuthException e) { assertThat(e.getMessage()).isEqualTo("administrate server not permitted"); } 
 String deleteReason) { assertThat(messagesAfterDeletion) .named( String.format("after: %s; before: %s", messagesAfterDeletion, messagesBeforeDeletion)) .hasSize(messagesBeforeDeletion.size()); 
 return new File(gitDir, projectName + ".git"); } catch (ResourceConflictException e) { throw new GitDestinationAlreadyExistsException(projectName); 
 public void doImport(ProgressMonitor progress) throws GitCloneFailedException { 
 LOG.info(sourceUri + "| Clone into " + destinationDirectory); fetch.call(); 
import com.google.common.base.CharMatcher; import com.google.common.base.MoreObjects; import com.google.common.base.Preconditions; import com.google.common.base.Strings; 
 "Change {} could not be indexed after {} retries. Change index could be stale.", 
 return (ref.startsWith(REFS_CHANGES) && (ref.endsWith(META_SUFFIX) || ref.endsWith(ROBOT_COMMENTS_SUFFIX))); 
 throw new NoSuchProjectException(nameKey); 
 private static File prepareTargetGitDirectory( 
 execute(ROOT_ENDPOINTS); 
 @Override @Nullable 
 if (checkIfAdmin) { if (allowProjectOwnersToChangeParent) { permissionBackend.user(user).project(project).check(ProjectPermission.WRITE_CONFIG); } else { permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER); } 
 * @param indexEvent the details of the index event. 
 Set<Account.Id> a = emails.getAccountFor(u.getEmail()); 
 static final Schema<ProjectData> V2 = schema(V1, ProjectField.REF_STATE); 
 List<ChangeMessageInfo> messagesAfterDeletion = gApi.changes().id(changeNum).messages(); assertMessagesAfterDeletion( messagesBeforeDeletion, messagesAfterDeletion, deletedMessageIndex, deletedBy, reason); 
 ImmutableSet<Account.Id> ids = emails.getAccountFor(userId.getEmailAddress()); 
 boolean isAdmin = userPermission.testOrFalse(GlobalPermission.ADMINISTRATE_SERVER); boolean canModifyAccount = isAdmin || userPermission.testOrFalse(GlobalPermission.MODIFY_ACCOUNT); 
 if (!id.equals(userProvider.get().getAccountId())) { 
 if (!id.equals(userProvider.get().getAccountId())) { 
<|del|> 
 .putGpgKeys(ImmutableList.of(key.getPublicKeyArmored()), ImmutableList.of()); 
 * A marker for a method that is public solely because it is called from inside a project or an 
 c.get = c.conn.prepareStatement("SELECT v, created FROM data WHERE k=? AND version=?"); 
<|del|> 
 @SuppressWarnings("unused") Future<?> possiblyIgnoredError = 
 @SuppressWarnings("unused") Future<?> possiblyIgnoredError = 
 if (threads <= 0) { threads = config.getInt("index", null, "threads", 0); } if (threads <= 0) { 
 "Failed to check project config for " + parentCtrl.getProject().getName() + ": " + e.getMessage(), 
 name + "-" + Hashing.sha1().hashString(name, Charsets.UTF_8).toString().substring(0, 7); 
 assertThat(p.getPattern()).isEmpty(); assertThat(p.getRawPattern()).isEmpty(); assertThat(p.getParameterNames()).isEmpty(); 
 assertThat(p.bind(a)).isEmpty(); assertThat(p.replace(a)).isEmpty(); 
 assertThat(p.bind(a)).isEmpty(); assertThat(p.replace(a)).isEmpty(); 
 assertThat(p.bind(a)).isNotNull(); 
 } catch (AuthException e) { return false; } catch (IOException | PermissionBackendException e) { 
<|del|> 
 authorId.toString(), authorId.get() + "@" + serverId, when, serverIdent.getTimeZone()); 
 author.toString(), author.getId().get() + "@" + serverId, when, serverIdent.getTimeZone()); 
<|del|> 
 public IntegerSubject totalLineCount() { 
 correctForDifferencesInNewlineAtEnd(); 
 Optional<Edit> lastEdit = getLast(edits); 
 return getUser().equals(user) ? this : forUser(user).asForChange(cd, db); 
<|del|> 
 ProjectMigrationResult progress = migrator.migrateProject(project, repo); 
Copyright (C) 2016 The Android Open Source Project 
Copyright (C) 2016 The Android Open Source Project 
 @Nullable 
 static final int DEFAULT_MAX_CONNECTIONS = 8; 
 public static String createNewChangeMessage(String deletedBy) { checkNotNull(deletedBy, "user name must not be null"); 
 .named("after: %s; before: %s", messagesAfterDeletion, messagesBeforeDeletion) 
 if (!dryRun) { ins.flush(); RefUpdateUtil.executeChecked(bru, rw); } 
 assertThat(progress.refsUpdated).isEqualTo(expectedRefs); 
Copyright (C) 2009 The Android Open Source Project 
 @UsedAt(UsedAt.Project.GOOGLE) 
 return pool; 
 @Mock private ProjectDeletedListener.Event event; 
 Collection<Ref> refs = refdb.getRefs(prefix).values(); 
<|del|> 
 failWithoutActual(fact("expected", "valid")); 
 * Assigning the username external ID to another account 
 private String reassignUsernameExternalIdAccount(ExternalId extId, Integer correctId) throws BadRequestException, IOException, OrmException, ConfigInvalidException { 
 private String reassignUsernameExternalIdAccount(ExternalId extId, Integer correctId) throws BadRequestException, IOException, OrmException, ConfigInvalidException { 
 this.unsafeExternalIdsBatchUpdate.replace(extId, extIdCorrected); this.unsafeExternalIdsBatchUpdate.commit("wmf-fixshadowuser update"); 
 this.unsafeExternalIdsBatchUpdate.replace(extId, extIdCorrected); this.unsafeExternalIdsBatchUpdate.commit("wmf-fixshadowuser update"); 
 this.unsafeExternalIdsBatchUpdate.replace(extId, extIdCorrected); this.unsafeExternalIdsBatchUpdate.commit("wmf-fixshadowuser update"); 
 } 
 } 
 ExternalId extId = this.externalIds.get( ExternalId.Key.create(ExternalId.SCHEME_USERNAME, username) ); 
 } if (input.correctaccountid == null) { throw new BadRequestException("correctaccountid required"); } return reassignUsernameExternalIdAccount(extId, input.correctaccountid); 
 if (walkedCommits >= maxCommits) { break; } walkedCommits++; 
Copyright (C) 2018 The Android Open Source Project 
Copyright (C) 2018 The Android Open Source Project 
 public void listMergeCommitFiles() throws Exception { 
 return fileInfoJson.toFileInfoMap(resource.getProjectState().getNameKey(), key); 
 private final AllUsersName allUsers; private final AllProjectsName allProjects; 
 keyRing.getPublicKey(Iterators.get(keyRing.getPublicKeys(), 1).getKeyID()); 
 PGPPublicKey subKey = keyRing.getPublicKey(ImmutableList.copyOf(keyRing.getPublicKeys()).get(1).getKeyID()); 
 throw new IllegalStateException("Failed to serialize string", e); 
 StringSerializer.serialize(StandardCharsets.US_ASCII, "\u1234"); assert_().fail("expected IllegalStateException"); 
 ObjectId id = get(); return MoreObjects.toStringHelper(this) .addValue(id != null ? id.name() : "null") .add("flag", flag) .toString(); 
 TagSet tags = object.tags; if (tags != null) { b.setTags(tags.toProto()); 
 if (proto.hasTags()) { 
 try { perm.ref(rev).check(RefPermission.READ); } catch (AuthException e) { 
 } catch (AuthException e) { 
 } catch (AuthException e) { 
<|del|> 
 if (!changeIdToMergedSha1.containsKey(changeKey)) { 
<|del|> 
 logger.atFiner().log("findApproval db key = %s", db.key); 
 logger.atSevere().withCause(e).log("Exception for %s", Config.getChangeId(changeData)); 
 logger.atSevere().withCause(e).log("Exception for %s", Config.getChangeId(changeData)); 
 List<String> allowSshCommands() { return allowSshCommands; 
 pushTo("refs/for/master").assertOkStatus(); 
 pushTo("refs/for/master").assertOkStatus(); 
 logger.atFiner().log( "Get from cache %s, key=%s, cache size=%d", dbCache, key, dbCache.size()); 
 logger.atSevere().log("Exception: " + e); 
 logger.atSevere().log("Exception: " + e); 
 pushTo("refs/for/master").assertOkStatus(); 
 private void setReadOnly(boolean readOnly) throws Exception { 
<|del|> 
 if (srcRule.getAction() == PermissionRule.Action.ALLOW) { 
 public static final String ALL_REFS_TAGS = RefNames.REFS_TAGS + "*"; 
 this.exec = workQueue.createQueue(1, "HighAvailability-AutoReindex"); 
 .max(Comparator.naturalOrder()); 
<|del|> 
 Stopwatch stopwatch = Stopwatch.createStarted(); 
 Files.write(indexTsFile, latestTs.format(formatter).getBytes(StandardCharsets.UTF_8)); 
 Files.write(indexTsFile, latestTs.format(formatter).getBytes(StandardCharsets.UTF_8)); 
 ps = psUtil.get(ctx.getDb(), notes, change.currentPatchSetId()); 
 assertThat(parser.parse("master~2..master")).isNull(); 
 // InMemoryRepository doesn't implement a reflog, so we can't test reflog entries. 
 * Marker on a {@link org.eclipse.jgit.lib.PersonIdent} pointing to the identity + timestamp 
 * <p>When injecting this into a singleton class, use {@code Provider<PersonIdent>} so you get a * fresh timestamp for each call to {@code get()}. 
 private final Multimap<String, String> tagMap = MultimapBuilder.hashKeys().hashSetValues().build(); 
 public boolean add(String name, String value) { 
 tagMap.forEach(tagsBuilder::addTag); 
<|del|> 
 addMessage(""); 
 logDebug("Found magic branch %s", cmd.getRefName()); magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration); magicBranch.reviewer.addAll(extraReviewers.get(ReviewerStateInternal.REVIEWER)); magicBranch.cc.addAll(extraReviewers.get(ReviewerStateInternal.CC)); 
 logDebug("Ref %s not found", ref); 
 newChanges.add(new CreateRequest(c, magicBranch.dest.get())); 
 logDebug( 
 ChangeLookup(RevCommit c) throws OrmException { commit = c; destChanges = queryProvider.get().byBranchCommit(magicBranch.dest, c.getName()); changeKey = null; } 
 static boolean parentsEqual(RevCommit a, RevCommit b) { 
 logger.atSevere().log("%s %s", msg, changeId); 
 logger.atWarning().log("Project %s no longer exists, abandoning open changes.", project); 
 logger.atWarning().withCause(e).log( "Cannot abandon changes for deleted project %s", destProject); 
 logger.atWarning().withCause(e).log( "Cannot abandon changes for deleted project %s", destProject); 
 protected static void logDebug(String msg, Throwable t) { 
 if (RequestId.isSet()) { 
 * * @return the tags as Multimap */ public ImmutableMultimap<String, String> asMap() { return ImmutableMultimap.copyOf(tagMap); } /** * Replaces the existing tags with the provided tags. * 
 expect.that(threadTagMap.keySet()).containsExactly("foo"); expect.that(threadTagMap.get("foo")).containsExactly("bar"); 
 String result = adminSshSession.exec("readonly get"); assertThat(result).contains(expectedStatus); 
 String result = adminSshSession.exec("readonly get"); assertThat(result).contains(expectedStatus); 
 private final SetMultimap<String, String> tagMap = 
 if (ret) { buildTags(); } 
 if (tagMap.remove(name, value)) { buildTags(); } 
 return id != null && Enums.getIfPresent(Id.class, id).isPresent(); 
 // Patterns to match trimmed globs and emails in per-file lines. 
 .toInstance(new JavaScriptPlugin("gr-delete-repo.html")); 
 .toInstance(new JavaScriptPlugin("gr-delete-repo.html")); 
 private void insertChangesAndPatchSets(List<CreateRequest> newChanges, Task replaceProgress) { 
 if (!rsrc.getControl().isOwner() && !rsrc.getRefControl().isVisible()) { 
<|del|> 
 ArrayList<Extension> extensions = new ArrayList<>(); 
 public enum Type { 
 Project.NameKey pj = createProject(PROJECT_NAME + "Http"); 
/** Print a change description for use in git command-line progress. */ 
 Task closeProgress = progress.beginSubTask("closed", UNKNOWN); autoCloseChanges(c, closeProgress); closeProgress.end(); 
 Task closeProgress = progress.beginSubTask("closed", UNKNOWN); autoCloseChanges(c, closeProgress); closeProgress.end(); 
 orm.setContext(db, TimeUtil.nowTs(), user); 
 db.changeMessages().delete(db.changeMessages().byChange(id)); db.changes().deleteKeys(Collections.singleton(id)); 
 * Current branch tips, taking into account commits created during the submit process as well as 
 // commit in project X reading branch tips for submodules S1..Sn and updating gitlinks in X. 
 "Load %s for change %s of project %s from %s (%s)", getClass().getSimpleName(), getChangeId(), getProjectName(), getRefName(), primaryStorage); 
 logger.atFine().log("Read star labels from %s", refName)); 
import static org.easymock.EasyMock.expect; import static org.easymock.EasyMock.replay; 
 String archiveDir = cfg.getString("archiveFolder", pluginData.toString()); File newDir = new File(archiveDir); 
 log.info("Archive folder {} does not exist, creating it then now", archiveDir); 
 archiveDir, pluginData); archiveDir = pluginData.toString(); 
<|del|> 
 return archiveDir; 
 private final ForwardedIndexAccountHandler accountIdx; 
 private final ForwardedIndexChangeHandler changeIdx; 
 private final ForwardedIndexGroupHandler indexer; 
<|del|> 
<|del|> 
 @Option(name = "--trace", usage = "enable request tracing") 
 stderr.println(String.format("%s = %s", RequestId.Type.TRACE_ID, traceId)); 
 return AllExternalIds.create(Arrays.asList(externalIds)); 
 private static final String DEFAULT_UPLOADPACK_LIMIT_EXCEEDED_MSG = 
<|del|> 
final class ReplenishCommand extends SshCommand { 
 private static final Logger rateLimitLog = RateLimiterStatsLog.getLogger(); private static final DateTimeFormatter format = DateTimeFormatter.ofPattern("mm 'min' ss 'sec'"); 
 public synchronized boolean acquirePermit() { boolean acquirePermit = delegate.acquirePermit(); if (usedPermits() == warnLimit) { 
 public synchronized boolean acquirePermit() { boolean acquirePermit = delegate.acquirePermit(); if (usedPermits() == warnLimit) { 
 static AllExternalIds create(SetMultimap<Account.Id, ExternalId> byAccount) { return new AutoValue_AllExternalIds( ImmutableSetMultimap.copyOf(byAccount), byEmailCopy(byAccount.values())); 
 */ @Nullable 
 public ImmutableSortedSet<String> plugins() { return items .stream() .map(i -> i.get().pluginName) .collect(toImmutableSortedSet(naturalOrder())); 
<|del|> 
 @UsedAt(UsedAt.Project.GOOGLE) 
 db.patchSets().delete(Collections.singleton(patchSet)); 
<|del|> 
 "Cannot delete project because it has children: " + children.stream().map(info -> info.name).collect(joining(","))); 
 } else { 
 /** The effective value in bytes. Null if not set. */ 
 /** * Whether the value was inherited or overridden from the project's parent hierarchy or global * config. Null if not inherited or overridden. */ @Nullable public String summary; 
 @Test public void testUserCannotDelete() throws Exception { 
 static final String PROJECT_CONFIG_PASSWORD_KEY = "password"; 
<|del|> 
 if (!Strings.isNullOrEmpty(projectName)) { 
Copyright (C) 2013 The Android Open Source Project 
<|del|> 
 projectName.get(), 
Copyright (C) 2018 Open Source Project 
Copyright (C) 2018 Open Source Project 
 if (!Strings.isNullOrEmpty(configValue.value)) { 
import org.junit.runner.RunWith; import org.mockito.Mock; 
<|del|> 
<|del|> 
 public AllUsersCreator setCodeReviewLabel(LabelType labelType) { 
 "Known groups of %s: %s", getLoggableName(), lazy(effectiveGroups::getKnownGroups)); 
 getLoggableName(), lazy(registeredGroups::getKnownGroups)); 
<|del|> 
 return Objects.hashCode(repositoryPath); 
<|del|> 
 static class TrashFolderPredicate { 
<|del|> 
 public void addPublisher( final String pluginName, final Publisher publisher, final String userName) { 
<|del|> 
 * Encrypt a string. 
 * <p>For now, this method is returning the same parameter it receives as the encryption code was * deemed unsuitable to be added to this same plugin. 
 * <p>Instead, work to add encrypting capabilities to Gerrit core is in process [1]; once this is * completed, this method should be modified to integrate the final encryption implementation. 
 * @param value the String to encrypt * @return encrypted text 
<|del|> 
 if (configValue.value != null && !configValue.value.isEmpty()) { 
 if (configValue.value != null && !configValue.value.isEmpty()) { 
 @GwtIncompatible("Unemulated class java.util.regex.Pattern") public static final Pattern USER_NAME_PATTERN_COMPILED = Pattern.compile(USER_NAME_PATTERN); 
 "Username '" + username + "' must comply with [" + USER_NAME_PATTERN + "] pattern."); 
 private static final String E_UNABLE_TO_FETCH_CHANGE_AUTHOR = "Unable to fetch the change author"; 
<|del|> 
 List<String> names = info.labels() .stream() .sorted() .collect(collectingAndThen(toList(), Collections::unmodifiableList)); 
 .collect(collectingAndThen(toList(), Collections::unmodifiableList)); 
 // to NOT_READY and indicate the need for non-author approval as requirement. 
<|del|> 
 return super.invokeAll(tasks.stream().map(LoggingContext::copy).collect(toList())); 
 loggingCtx.setTags(oldTags); loggingCtx.forceLogging(oldForceLogging); loggingCtx.performanceLogging(oldPerformanceLogging); loggingCtx.setPerformanceLogEntries(oldPerformanceLogRecords); 
 static final String CONFIG_SUFFIX = "-airvantage-oauth"; private static final String AV_PROVIDER_PREFIX = "airvantage-oauth:"; 
 static final String CONFIG_SUFFIX = "-airvantage-oauth"; private static final String AV_PROVIDER_PREFIX = "airvantage-oauth:"; 
<|del|> 
<|del|> 
 private static final String PROTECTED_RESOURCE_URL = "https://eu.airvantage.net/api/v1/users/current"; 
 Response response = request.send(); if (log.isDebugEnabled()) { log.debug("Access token response: {}", response.getBody()); } 
 throw new IOException("Response doesn't contain uid field"); 
 if (db.changesTablesEnabled()) { 
 static final String PROJECT_CONFIG_USERNAME_KEY = "username"; 
<|del|> 
<|del|> 
 accountPatchReviewStore.run(s -> s.clearReviewed(psId), OrmException.class); 
 * Calls a plugin and returns the result from the plugin call. 
<|del|> 
 this(elapsedMs -> logger.atFine().log(message + " (%d ms)", elapsedMs)); 
 bind(UrlFormatter.class).to(DefaultBrowseUrls.class); 
 String u = canonicalWebUrlProvider.get(); if (u == null) { u = "/"; } 
 .append(browseUrls.changeViewUrl(c.getProject(), c.getId())) 
 private final Config cfg; private final DynamicItem<UrlFormatter> urlFormatter; 
 this.labels = labels; this.comments = comments; 
 /** Returns the URL for viewing a change. */ default Optional<String> changeViewUrl(@Nullable Project.NameKey project, Change.Id id) { Optional<String> url = webUrl(); if (!url.isPresent()) { return Optional.empty(); } 
 // the /+/ separator unambiguously defines how to parse the path. return Optional.of(url + "c/" + (project != null ? project.get() + "/+/" : "") + id.get()); 
 public Optional<String> webUrl() { String url = canonicalWebUrlProvider.get(); if (url == null) { return Optional.empty(); 
 UrlFormatter urlFormatter, 
 Optional<LocalDateTime> currTs = getUpdateTs(index); 
 * <p>For the default implementations below to work, it must end in "/". 
 private final Provider<String> canonicalWebUrlProvider; 
 Optional.ofNullable(canonicalWebUrlProvider.get()); 
 .append(changeUrl.get()) 
<|del|> 
 static final Schema<ChangeData> V50 = schema(V49); 
 request.setEntity(new StringEntity(jsonEncode(content), StandardCharsets.UTF_8)); 
 trashFolders.getWorkerThread().join(); 
 static class TrashFolderPredicate { 
 static final boolean match(String fName) { 
 static boolean match(Path dir) { return match(dir.getFileName().toString()); 
 LabelType myLabel = projectCache.get(project).getConfig().getLabelSections().get("Code-Review"); 
 changeDeleted.fire(ctx.getChange(), ctx.getAccount(), ctx.getWhen()); 
 Event(ChangeInfo change, AccountInfo deleter, Timestamp when) { super(change, deleter, when, NotifyHandling.ALL); 
 // Possibly return a signing subkey in case it differs from the master public key 
 // If the signature was made using a subkey, return the main public key. // This enables further validity checks, like user ID checks, that can only // be performed using the master public key. 
 // No master public key found, try to retrieve key ring from subkey cache 
<|del|> 
 * found for a given signature, the subkey cache is consulted to lookup for the master key. 
 "No public key found for ID: " + keyIdToString(sig.getKeyID())); 
 // cache. The removal of key ring is not a common operation, though. 
 // Now that all subkey entries were removed from the cache, remove the master key 
 return Optional.ofNullable(canonicalWebUrlProvider.get()); 
 Preconditions.checkState(changeUrl.isPresent()); 
 Preconditions.checkState(changeUrl.isPresent()); 
 urlFormatter.getChangeViewUrl(cd.project(), cd.getId()).orElse("http://gerrit.invalid/"); 
 return ChangeKind.NO_CHANGE; 
<|del|> 
 repLog.error("Error creating local repository {}", uri.getPath(), e); 
 String docUrl = urlFormatter.getDocUrl("user-change-cleanup.html", "auto-abandon").orElse(""); if (!docUrl.isEmpty()) { abandonMessage = abandonMessage.replaceAll("\\$\\{URL\\}", docUrl); } 
 } return Optional.empty(); 
 public PublicKeyStore(Repository repo, SubkeyToMasterKeyCache subkeyCache) { 
 import com.google.common.collect.ImmutableList; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.gerrit.common.Nullable; import com.google.gerrit.common.data.LabelFunction; 
 submitConfig.comments = new CommentsRules( config.getBoolean(SimpleSubmitRulesConfig.KEY_BLOCK_IF_UNRESOLVED_COMMENTS, false)); 
 Throwables.throwIfInstanceOf(e, exceptionClass); Throwables.throwIfUnchecked(e); 
 Throwables.throwIfInstanceOf(e, exceptionClass); Throwables.throwIfUnchecked(e); 
<|del|> 
 lazy(() -> Collections2.transform(e.getValue(), op -> op.getClass().getName()))); 
 return projectPrefix + projectName + " git " + getRepoRoot(projectName); 
<|del|> 
 lazy(() -> e.getValue().stream().map(op -> op.getClass().getName()).collect(toSet()))); 
 ERROR("ERROR: "), WARNING("WARNING: "), HINT("hint: "), OTHER(""); 
 PermissionBackend permissionBackend, CurrentUser user, Change change) 
 PermissionBackend permissionBackend, CurrentUser user, Change change) 
 return; 
 // Re-read change to take into account results of the update. ChangeData cd = changeDataFactory.create(revision.getProject(), revision.getChange().getId()); for (ReviewerAddition reviewerResult : reviewerResults) { 
 .setPrefixes(Collections.singletonList("")); 
 List<ChangeData> changes = queryProvider.get().enforceVisibility(true).byCommit(otherCommit); 
 + " Is the change of this commit not visible or was it deleted?", 
 "Commit %s depends on commit %s of change %d which cannot be merged.", commit, otherCommit, changes.get(0).getId().get()); 
 public final ImmutableSet<Account.Id> reviewers; public final ImmutableSet<Address> reviewersByEmail; 
 public static String redactQueryString(String qs) { StringBuilder b = new StringBuilder(); 
 private final Histogram1<String> changes; 
 Field.ofString("type", "type of push (create/replace, autoclose)")); 
/** * Keeps track of the change IDs thus far updated by ReceiveCommit. * * <p>This class is thread-safe. */ 
 ids = new EnumMap(Key.class); 
 DateTimeFormatter.ofPattern("YYYYMMddHHmmss").withZone(ZoneId.of("UTC")); 
 CherryPickChangeInfo cherryPickAsInfo(CherryPickInput in) throws RestApiException; 
<|del|> 
<|del|> 
 private final Histogram1<ResultChangeIds.Key> changes; private final Timer1<String> latencyPerChange; 
 logError("Invalid pack upload; one or more objects weren't sent", err); 
/** * Keeps track of the change IDs thus far updated by ReceiveCommit. * * <p>This class is thread-safe. */ 
/** * Keeps track of the change IDs thus far updated by ReceiveCommit. * * <p>This class is thread-safe. */ 
 ids = new EnumMap<>(Key.class); 
 : ResultChangeIds.Key.AUTOCLOSED.name(), 
 /** * Select only refs with names matching prefixes per {@link * org.eclipse.jgit.lib.RefDatabase#getRefsByPrefix}. */ public abstract ImmutableList<String> prefixes(); 
 matches("a.1234567890123.%deleted%.git"); matches("aa.1234567890123.%deleted%.git"); matches("a.b.c.1234567890123.%deleted%.git"); 
 return excludeProjectsRegexes; 
 return excludeProjectsRegexes; 
 // Contributor agreements configured with excludeProjects = ExcludedProject // in AbstractDaemonTest.configureContributorAgreement(...) 
 public synchronized void replenishPermits() { semaphore.release(usedPermits()); 
 public List<String> getExcludeProjectsRegexes() { if (excludeProjectsRegexes == null) { excludeProjectsRegexes = new ArrayList<>(); 
<|del|> 
 public enum Status { OK, NOT_READY, CLOSED, FORCED, RULE_ERROR } 
 public static class None { private None() {} public static None INSTANCE = new None(); } 
<|del|> 
 info.status = TestSubmitRuleInfo.Status.NOT_READY; info.need = ImmutableMap.of("Code-Review", TestSubmitRuleInfo.None.INSTANCE); 
<|del|> 
 createGroupsRef.addAll(create.getRules()); 
 } logger.atFine().log( "Invoked %d ChangeMessageModifiers on message with original length %d", count, originalMessage.length()); 
 checkNotNull(projectState, "fail to create project " + args.getProject().get()); 
 requireNonNull(commit, () -> String.format("missing commit for change %s", id)); 
 checkNotNull(regexes); checkArgument(!regexes.isEmpty()); 
 throw new IllegalStateException( "Invalid matchProjects or excludeProjects clause in project.config", e); 
 // (c2a) <= private 
 createChange(repo1, "master", "A fresh change in repo1", "a.txt", "1", "topic-to-submit"); 
 // Verify that user cannot see change2a 
<|del|> 
 PluginSetContext<EventListener> listeners = new PluginSetContext<>(set, mockMetrics); 
 install(SubkeyToMasterKeyCacheImpl.module()); 
 Optional<AccountState> accountState = accountCache.getByUsername(info.labels.get("Code-Review").approved.username); 
 Optional<AccountState> accountState = accountCache.getByUsername(info.labels.get("Code-Review").approved.username); 
 public HideFromNonAdmins(Provider<CurrentUser> user, PermissionBackend permissionBackend) { 
 "Change with id: '{}' on project key: '{}' not found.", changeId.get(), projectName.toString()); 
 log.warn("Patch set {} not found in change {}.", psId.get(), changeId.get()); 
 Branch.NameKey heads = new Branch.NameKey(new Project.NameKey(projectName), RefNames.REFS_HEADS); 
 unitUnderTest = new GoImportFilter( mockAnonProvider, mockPerms, mockProjectCache, "http://gerrit-review.googlesource.com:8080/"); 
<|del|> 
public class NumericChangeIdRedirectServlet extends HttpServlet { private static final long serialVersionUID = 1L; 
 throw new IOException("Unable to lookup change " + id.id, e); 
 // This will be removed with the above config once we reach consensus for the move change 
<|del|> 
 Multimap<UpdateResult, ConfigUpdateEntry> updates = gerritServerConfigReloader.reloadConfig(); 
 "Plugin name '{}' must match '{}' to use capabilities; rename the plugin", pluginName, PLUGIN_NAME_PATTERN.pattern()); 
 b.append(" && (cd ").append(projectName).append(" && ").append(extraCommand).append(")"); 
import com.google.gerrit.server.project.ProjectCache; import com.google.gerrit.server.project.ProjectConfig; 
import com.google.inject.Singleton; import com.googlesource.gerrit.plugins.simplesubmitrules.api.SubmitConfig; 
 ProjectConfig projectConfig = projectConfigFactory.read(md); 
 b.append(" && (cd ").append(projectName).append(" && ").append(extraCommand).append(")"); 
 assertThat(e.who.getLoggableName()).isEqualTo("AnonymousUser"); assertThat(e.what).endsWith("service=git-upload-pack"); 
 public static boolean modified(FileBasedConfig cfg) throws IOException { 
 * #run(PluginContext.ExtensionImplConsumer)}, {@link #run(PluginContext.ExtensionImplConsumer, java.lang.Class)}, {@link * #call(PluginContext.ExtensionImplFunction)} and {@link #call(PluginContext.CheckedExtensionImplFunction, java.lang.Class)}. 
 rejectEmptyCommit = InheritableBoolean.INHERIT; 
 String g = groupOperations.newGroup().name(name).create().get(); 
<|del|> 
 args.createEmptyCommit = projectCreation.createEmptyCommit().orElse(true); projectCreation.parent().ifPresent(p -> args.newParent = new Project.NameKey(p)); 
 args.createEmptyCommit = projectCreation.createEmptyCommit().orElse(true); projectCreation.parent().ifPresent(p -> args.newParent = new Project.NameKey(p)); 
 projectCreation.submitType().ifPresent(st -> args.submitType = st); 
 public abstract Optional<Project.NameKey> parent(); 
 private abstract TestProjectCreation.Builder createEmptyCommit(boolean value); 
 return creation.projectCreator().apply(creation); 
 newProjectName = projectOperations.newProject().name(PROJECT_NAME).withEmptyCommit().create(); 
 @javax.inject.Inject protected ProjectOperations projectOperations; 
 getConsoleUI().message("Init complete, reindexing projects with:"); getConsoleUI().message(" reindex " + reindexArgs.stream().collect(joining(" "))); 
import java.io.ByteArrayOutputStream; import java.io.File; 
import com.google.gerrit.testutil.FakeAuditService; import com.google.gerrit.testutil.FakeEmailSender; import com.google.gerrit.testutil.NoteDbChecker; import com.google.gerrit.testutil.NoteDbMode; import com.google.gerrit.testutil.SshMode; import com.google.gerrit.testutil.TempFileUtil; 
<|del|> 
 @Inject private GroupOperations groupOperations; 
 .replaceAll(""); 
 @Inject private ProjectOperations projectOperations; 
 @Inject private ProjectOperations projectOperations; 
 Project.NameKey name = projectOperations.newProject().create(); // check that the project was created (throws exception if not found.) 
 throw new ResourceConflictException( "base revision is missing from the destination branch: " + str); 
 ConsumerRecords<String, String> records = consumer.poll(KAFKA_POLL_TIMEOUT); 
 e -> e.getKey().name().toLowerCase(), e -> toEntryInfos(e.getValue()))); 
 private static List<ConfigUpdateEntryInfo> toEntryInfos( Collection<ConfigUpdateEntry> updateEntries) { 
 protected TaskConfigFactory(AllProjectsName allProjects, GitRepositoryManager gitMgr) { this.allProjects = allProjects; 
 try (Repository git = gitMgr.openRepository(project)) { cfg.load(project, git); 
 List<TaskAttribute> subTasks = new ArrayList<>(); 
<|del|> 
 logger.atWarning().withCause(e).log( "failed to parse commit %s for success message.", rr.newCommitId.name()); outOfOrderCommits.add(rr.newCommitId.name()); 
 * recommended idiom is to pull out whichever individual fields from the {@code Arguments} are * required by this implementation. 
 // TODO(dborowitz): Migrate delete-project plugin to use this implementation. 
 Iterable<String> names = Iterables.transform(includes, i -> i.name); assertThat(names) .containsExactlyElementsIn(Arrays.asList(expectedNames)); assertThat(names).isOrdered(); 
<|del|>
 // adjacency list for commit => parent 
 // adjacency list for commit => parent 
 String parent = cr.commit.getParentCount() == 0 ? null : cr.commit.getParent(0).name(); adjList.put(cr.commit.name(), parent); 
 String parent = revCommit.getParentCount() == 0 ? null : revCommit.getParent(0).name(); adjList.put(rr.newCommitId.name(), parent); 
 changeFormatter.newChange( ChangeReportFormatter.Input.builder().setChange(c.change).build())); 
 up.setExtraParameters(ImmutableList.copyOf(extraParameters)); 
<|del|> 
<|del|> 
 List<PluginDefinedInfo> plugins = new ArrayList<>(attributeFactories.plugins().size()); 
<|del|> 
 for (Map.Entry<String, ChangeAttributeFactory> e : attributeFactoriesByPlugin.entries()) { 
 private final PluginSetContext<QuotaEnforcer> quotaEnforcers; 
 Provider<CurrentUser> userProvider, PluginSetContext<QuotaEnforcer> quotaEnforcers) { 
 static class WithResource implements QuotaBackend.WithResource { 
 * See {@link #currentUser()}. Use this method only if you can't guarantee that the request is for * the current user (e.g. impersonation). 
 default QuotaResponse.Aggregated requestToken(String quotaGroup) { return requestTokens(quotaGroup, 1); 
 * implementations can deduct the inquired number of tokens from the bucket. 
 return new AutoValue_QuotaRequestContext.Builder().user(new AnonymousUser()); 
 return new AutoValue_QuotaRequestContext.Builder().user(new AnonymousUser()); 
 return this == OK; 
 public abstract QuotaResponse.Builder message(String message); 
 @AutoValue public abstract static class Aggregated { protected abstract ImmutableList<QuotaResponse> responses(); 
 return responses().stream().filter(r -> r.status().isOk()).collect(toImmutableList()); 
 return error() .stream() .map(QuotaResponse::message) .flatMap(Streams::stream) .collect(Collectors.joining(", ")); 
<|del|> 
 assertThat(e).hasMessageThat().contains("NoteDb change migration was not completed"); 
Copyright (C) 2018 The Android Open Source Project 
<|del|> 
/** Data container for test REST requests. */ 
 adjList.put(rr.newCommitId.name(), null); 
 Set<String> leafs = new LinkedHashSet<>(adjList.keySet()); 
public class CreateProjectTask { 
<|del|> 
 return in == null ? in : CharMatcher.is('/').trimTrailingFrom(in); 
 QuotaRequestContext ctx = requestContext.toBuilder().account(account).build(); 
 public boolean hasError() { return responses().stream().anyMatch(r -> r.status().isOk()); 
 public String errorMessage() { 
 return responses().stream().anyMatch(r -> r.status().isError()); 
 // TODO(hanwen): the submodule tests have a similar method; maybe we could share code? 
<|del|> 
<|del|> 
 rejectRemaining(cmds, "internal server error"); 
<|del|> 
 projectCreation.parent().ifPresent(p -> args.newParent = p); // ProjectCreator wants non-null owner IDs. args.ownerIds = new ArrayList<>(); 
 final int NUM = 3; Project.NameKey subKey[] = new NameKey[NUM]; TestRepository<?> sub[] = new TestRepository[NUM]; 
 @Nullable String remoteName, Project.NameKey projectName, FilterType filterType) { 
 public synchronized Multimap<Destination, URIish> getURIs( Optional<String> remoteName, Project.NameKey projectName, FilterType filterType) { 
 repLog.warn("Cannot create new project {} on remote site {}.", projectName, replicateURI); 
<|del|> 
 repLog.warn("Cannot delete project {} on remote site {}.", project, replicateURI); 
 repLog.warn("Cannot update HEAD of project {} on remote site {}.", project, replicateURI); 
<|del|> 
<|del|> 
<|del|> 
 // available in this injector (e.g. during init). This is ok for now since no other ref updates // during init are available to plugins, and there are not any other use cases for listening for // updates to the version ref. 
 private void initSchemaVersion() throws IOException, OrmException { 
 throw new OrmException( String.format("Failed to upgrade to schema version %d", nextVersion), e); 
 // need to be updated upon merging. In any case, this number must not exceed the first NoteDb // schema version (180). 
public class Schema_180 implements NoteDbSchemaVersion { @SuppressWarnings("unused") 
 private static class TestSchema_10 implements NoteDbSchemaVersion { @SuppressWarnings("unused") 
<|del|> 
 private static class TestSchema_10 implements NoteDbSchemaVersion { @SuppressWarnings("unused") 
 private static class TestSchema_11 implements NoteDbSchemaVersion { @SuppressWarnings("unused") 
 // stub implementation, all read operations return no results, and write operations silently // do nothing. This implementation is not a public class and callers couldn't do anything // useful with it even if it were. 
<|del|> 
<|del|> 
 m.add(new InitModule(standalone)); 
public class ThreadLimiter { @SuppressWarnings("unused") 
 public int getResponseStatus() { 
 responseWrapper, 
 responseWrapper, 
 responseWrapper, 
 (HttpServletResponse) responseWrapper, 
 } catch (PermissionBackendException e) { responseWrapper.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); 
 PreUploadHookChain.newChain(ImmutableList.of(up.getPreUploadHook(), uploadValidators))); 
 (HttpServletResponse) responseWrapper, 
 } catch (PermissionBackendException e) { responseWrapper.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); 
 (HttpServletResponse) responseWrapper, 
 responseWrapper.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); 
 } else { log.error("No username for this account found in cache"); 
 // Roll back the quota request for all enforcers that deducted the quota (= the request 
 "Quota request for %s with %s (deduction=%s) for %s token returned %s", 
 * DefaultQuotaBackend} which calls all plugins that implement {@link QuotaEnforcer}. A different * implementation might be bound in tests. Plugins are not supposed to implement this interface, but * bind a {@link QuotaEnforcer} implementation instead. 
 * Exception that was encountered while checking if there is sufficient quota to fulfil the request. * Can be propagated directly to the REST API. 
 * Exception that was encountered while checking if there is sufficient quota to fulfil the request. * Can be propagated directly to the REST API. 
 /** * The requested quota could not be allocated. This status code is not used to indicate * processing failures as these are propagated as {@code RuntimeException}s. */ 
 * <li>GET /a/accounts/self/detail => /restapi/accounts/detail:GET * <li>GET /changes/123/revisions/current/detail => /restapi/changes/revisions/detail:GET * <li>PUT /changes/10/reviewed => /changes/reviewed:PUT 
 // Enrich the quota request we are operating on an interesting collection 
 StringBuilder result = new StringBuilder(parts.length); 
 public void getRestPathWithoutIds_nonEmptyContextPath() { 
 // TODO(davido): This is a workaround for non working plugin loading 
 String parent = this.projectOperations.newProject().create().get(); 
 this.projectOperations.newProject().submitType(getSubmitType()).create(); 
 ElasticConfiguration config, 
 static final int DEFAULT_NUMBER_OF_REPLICAS = 1; static final TimeUnit MAX_RETRY_TIMEOUT_UNIT = TimeUnit.MILLISECONDS; 
 final int numberOfReplicas; final String prefix; 
 cfg.setBoolean("index", null, "onlineUpgrade", false); 
 cfg.setBoolean("index", null, "onlineUpgrade", false); 
<|del|> 
<|del|> 
 modules.add(SchemaVersionCheck.module()); 
 @Override protected void configure() { addExposedPort(ELASTICSEARCH_DEFAULT_PORT); } @Override public Set<Integer> getLivenessCheckPortNumbers() { return ImmutableSet.of(getMappedPort(ELASTICSEARCH_DEFAULT_PORT)); } 
Copyright (C) 2018 The Android Open Source Project 
 public int get() { 
 private final DynamicItem<UrlFormatter> urlFormatter; 
 UrlFormatter uf = urlFormatter.get(); if (uf != null && uf.getWebUrl().isPresent()) { fmt.appendReviewedOn(uf, notes.getChange().getProject(), ps.getId().getParentKey()); 
 DynamicItem<UrlFormatter> urlFormatter, 
 commentLinkSections = new LinkedHashMap<>(subsections.size()); 
 // TODO(dpursehouse): Add "scp" and "suexec" 
 DynamicMap.mapOf(binder(), CustomAction.class); 
 l -> l.onLogin(loggedInUserAfter.get(), httpRequest, wrappedResponse)); 
 // Disable writes to change tables in ReviewDb (ReviewDb access for changes are No-Ops); all 
<|del|> 
Copyright (C) 2018 The Android Open Source Project 
 QuotaRequestContext ctx = QuotaRequestContext.builder().user(user).account(account).build(); return new WithResource(quotaEnforcers, ctx); 
<|del|> 
 /** Drop the database from memory; does nothing if the instance was null. */ @SuppressWarnings("unused") 
 /** * Test-specific setup. * * @throws OrmException if an error occurs. */ 
<|del|> 
<|del|> 
 ref -> 
 /** Ability to view code review metadata refs in repositories. */ 
 String username = user.getUserName().orElse(null); 
 * <p>Guarantees deterministic serialization. No matter whether the use case cares about * determinism or not, always use this method in preference to {@link MessageLite#toByteArray()}, * which is not guaranteed deterministic. 
 * <p>Guarantees deterministic serialization. No matter whether the use case cares about * determinism or not, always use this method in preference to {@link * ProtobufCodec#encodeToByteString(Object)}, which is not guaranteed deterministic. 
 return doc.get(fieldName) 
 private final ProtoConverter<Reviewdb.Change_Id, Change.Id> changeIdConverter = 
 private final ProtoConverter<Reviewdb.PatchSet_Id, PatchSet.Id> patchSetIdConverter = 
 assertThatSerializedClass(Account.Id.class).hasFields(ImmutableMap.of("id", int.class)); 
 assertThatSerializedClass(Change.Id.class).hasFields(ImmutableMap.of("id", int.class)); 
 .map(ref -> new Branch.NameKey(projectNameKey, ref.getName())) 
 // writtenOn may not be null according to the column definition but it's optional for the 
 private final ProtoConverter<Reviewdb.PatchSet_Id, PatchSet.Id> patchSetIdConverter = 
<|del|> 
 public Object apply(ProjectResource rsrc, Input input) throws IOException, RestApiException { 
import com.google.gerrit.reviewdb.client.Account; 
<|del|> 
<|del|> 
 * Returns true if a branch exists. branchName can either be shortened ("HEAD", "master") or a * fully qualified refname ("refs/heads/master"). 
 * Returns true if a branch exists. branchName can either be shortened ("HEAD", "master") or a * fully qualified refname ("refs/heads/master"). 
 static void toGerrit(String target, HttpServletRequest req, HttpServletResponse rsp) 
 toGerrit(target, req, rsp, false); 
 static void toGWT(String target, HttpServletRequest req, HttpServletResponse rsp) 
 url.append('/'); url.append('#'); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 boolean isPrivate = change.isPrivate(); boolean wip = change.isWorkInProgress(); 
<|del|> 
 import static com.google.common.base.Preconditions.checkState; 
 final AllUsersName allUsers; 
import static com.google.common.truth.Truth.assertWithMessage; import static com.google.common.truth.TruthJUnit.assume; 
<|del|> 
<|del|> 
 public void userCanSetNameOfOtherUserWithModifyAccountPermission() throws Exception { 
 @Mock private Configuration configMock; @Mock private Configuration.Index indexMock; 
 @Mock private Configuration configMock; @Mock private Configuration.Index indexMock; 
 when(configMock.index()).thenReturn(indexMock); when(indexMock.numStripedLocks()).thenReturn(10); handler = new ForwardedIndexAccountHandler(indexerMock, configMock); 
class ChangeNotesParser { 
 private void updateCachesOnGroupCreation(InternalGroup createdGroup) throws IOException { groupCache.evict(createdGroup.getGroupUUID()); groupCache.evict(createdGroup.getId()); 
 RevCommit commit2 = 
 ps.getProject() .setBooleanConfig( BooleanProjectConfig.DISABLE_CONFLICTS_QUERIES, InheritableBoolean.TRUE); 
 public InheritableBoolean disableConflictsUi; 
 PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), testRepo).to(ref); 
 static class Site extends GitwebCssServlet { private static final long serialVersionUID = 1L; 
public class AllProjectsName extends Project.NameKey { private static final long serialVersionUID = 1L; 
public class AllUsersName extends Project.NameKey { private static final long serialVersionUID = 1L; 
 extractMailExample(template.fileName()); 
 throw new UnsupportedOperationException("template " + this + " has no HTML variant"); 
<|del|> 
 serve("/event/").with(EventRestApiServlet.class); 
 peers = cfg.peerInfoStatic().urls().stream().map(PeerInfo::new).collect(Collectors.toSet()); 
 private Optional<PeerInfo> peerInfo = Optional.empty(); 
<|del|> 
 return Optional.ofNullable(httpRequest.getHeader(HttpHeaders.AUTHORIZATION)) .map(h -> h.equals("Bearer " + cfg.getString(PROMETHEUS_BEARER_TOKEN))) .orElse(false); 
<|del|> 
 url.append('/'); url.append('#'); 
 } 
 this.prometheusBearerToken = cfgFactory.getFromGerritConfig(pluginName).getString(PROMETHEUS_BEARER_TOKEN); 
 .map(h -> h.equals("Bearer " + prometheusBearerToken)) 
<|del|> 
<|del|> 
<|del|> 
 * Return the Change notes read from ReviewDb or NoteDb. 
 changeNotes = Optional.ofNullable(changeFinder.findOne(changeId)); 
 log.debug("Checking change {} against index event {}", this, indexEvent); 
 return false; 
<|del|> 
Copyright (C) 2019 The Android Open Source Project 
 * This attempts to determine the SQL dialect from the JDBC URL. * If the URL does not match one of the supported dialects, then * H2 will be returned by default. 
 // Lucene index was changed to add additional fields for sorting. 
<|del|> 
 public JiraRestApi<JiraVersion[]> getVersions() { return get(JiraVersion[].class, "/version"); 
 /** Represents a version in JIRA. */ 
<|del|> 
 * @param jdbcUrl The JDBC URL. 
 .append(projectName) .append(" && mkdir -p .git/hooks") 
<|del|> 
 PatchSet.Id lastPsId = getPatchSetId(Iterables.getLast(commitIds)); 
 e.setAdvice( String.format( "use a SHA1 visible to you, or get %s permission on the ref", RefPermission.UPDATE.describeForException())); 
 private static final String END_OF_STREAM = "END-OF-STREAM_$F7;XTSUQ(Dv#N6]g+gd,,uzRp%G-P"; 
 private final Path pluginDataDir; // Use Provider<> instead of injecting the ReplicationQueue because of circular dependency with // ReplicationConfig 
 private final Path pluginDataDir; // Use Provider<> instead of injecting the ReplicationQueue because of circular dependency with // ReplicationConfig 
 LastFailedConfigTs = 0; 
<|del|> 
<|del|> 
 * underlying {@code Provider<InternalFooQuery>}, since the instances are not reusable. 
 private long lastFailedConfigTs; 
 this.user = Preconditions.checkNotNull(user); 
<|del|> 
 // Delta reload: No index access as we expect it to use the NoteDb. 
 // Bootstrap: No NoteDb access as we expect it to use the index. 
 // Delta reload: No index access as we expect it to use NoteDb. 
 * side of the {@link Forwarder} since it will prevent indexed project to be forwarded again causing 
 samlClientConfig.setMaximumAuthenticationLifetime(samlConfig.getMaxAuthLifetimeAttr()); samlClientConfig.setServiceProviderMetadataPath( ensureExists(sitePaths.data_dir).resolve("sp-metadata.xml").toString()); 
 log.debug("Max Authentication Lifetime: " + samlConfig.getMaxAuthLifetimeAttr()); String callbackUrl = String.format( "%s/plugins/gerrit-saml-plugin/saml", CharMatcher.is('/').trimTrailingFrom(urlProvider.get())); 
 stream.add(rule(config, batch)); 
 /** * Disables read and write access to NoteDb and returns the context prior to that modification. */ 
 public Builder addBooleanProjectConfigs( 
 public static Builder builder() { 
Copyright (C) 2019 The Android Open Source Project 
 assertThat(subsections1) .named("section \"%s\"", section) .containsExactlyElementsIn(subsections2); subsections1.forEach(s -> assertSubsectionEquivalent(config1, config2, section, s)); 
 String name = String.format("subsection \"%s\" of section \"%s\"", subsection, section); assertThat(subsectionNames1).named(name).containsExactlyElementsIn(subsectionNames2); 
 n -> assertThat(config1.getStringList(section, subsection, n)) .named(name) .asList() .containsExactlyElementsIn(config2.getStringList(section, subsection, n))); 
 repo.getRefDatabase() .getRefs() .stream() .filter(r -> !r.getName().startsWith(RefNames.REFS_CHANGES)) .collect(toImmutableList()); 
 repo.getRefDatabase() .getRefs() .stream() .filter(r -> !r.getName().startsWith(RefNames.REFS_CHANGES)) .collect(toImmutableList()); 
 "Only rebuild these projects, do no other migration; incompatible with --change" + " and --skip-project; recommended for debugging only") 
 } catch (RestApiException | OrmException | IOException e) { 
 public enum Result { @SerializedName("passed") PASSED, @SerializedName("failed") FAILED, @SerializedName("timeout") TIMEOUT; } public class Status { public final Result result; 
 private static final int PROJECTS_LIST_LIMIT = 100; 
 } catch (TimeoutException e) { 
 beginTask(taskName, UNKNOWN); 
 assertTwoConfigsEquivalent(config, expectedConfig); 
 Repository repo = repoManager.createRepository(allProjectsName); repo.close(); 
 return new BlobBasedConfig(null, repo, configRef.getObjectId(), "project.config"); 
 private static void assertTwoConfigsEquivalent(Config config1, Config config2) { 
 private static void assertSectionEquivalent(Config config1, Config config2, String section) { 
 private static void assertSubsectionEquivalent( 
 post(PROJECT_KIND, "images").to(PostImage.class); 
public class PostImage implements RestModifyView<ProjectResource, Input> { 
<|del|> 
<|del|> 
<|del|> 
 .getStringList("ignoredUsers"); 
 String[] ignoredUsers); 
 .getString("ignoreFileRegEx", ""); ignoredUsers = cfg.getFromProjectConfigWithInheritance(projectName, pluginName) .getStringList("ignoredUsers", null); 
<|del|> 
<|del|> 
 String ignoreFileRegEx, String[] ignoredUsers); 
<|del|> 
<|del|> 
 for (String user : pluginConfig.getStringList("ignoreUser")) { 
 final List<Edit> edits, final BlameResult blameResult) { 
<|del|> 
 public SortedMap<String, ProjectInfo> apply() throws BadRequestException { 
 b = perm.project(name).testOrFalse(ProjectPermission.ACCESS); 
 List<Ref> refs = new ArrayList<>(); refs.addAll(refdb.getRefsByPrefix(Constants.R_HEADS)); 
 TreeMap<Project.NameKey, ProjectNode> treeMap = null; 
<|del|> 
 TreeMap<Project.NameKey, ProjectNode> treeMap, List<ProjectState> projectStates) { 
 TestRepository<?>.CommitBuilder b = repo.commit().message("Change with files"); 
 for (Ref ref : refs) { if (ref != null) { 
<|del|> 
 @Assisted final String ignoreFileRegEx) { 
<|del|> 
 } gApi.changes().id(change.getChangeId()).current().review(in); 
<|del|> 
 this.metricsHandler = new MetricsHandler(name, metricMaker); 
 new JGitHealthCheck(executor, getFailingGitRepositoryManager(), allProjectsName, metricMaker); 
 new ProjectsListHealthCheck(executor, getWorkingProjectList(0), metricMaker); 
 return null; 
 || ref.startsWith(REFS_GROUPNAMES) || ref.startsWith(REFS_USERS) || ref.startsWith(REFS_STARRED_CHANGES); 
 Ref configRef = repo.exactRef(RefNames.REFS_CONFIG); 
 GroupMembership memberShip = user.getEffectiveGroups(); 
 ScheduleConfig.builder(cfg, "plugin") .setSubsection("quota") 
 .filter(Objects::nonNull) .filter(p -> permissionCheck(p, perm)); 
<|del|> 
 * <li>For each recognized format in the order listed in the method Javadoc, check whether the * input matches that format. 
 * includes inactive accounts, with one specific exception noted in method Javadoc. 
<|del|> 
<|del|> 
 public void createChangeOnNonExistingBranchNotPermitted() throws Exception { blockRead("refs/heads/*"); 
 public void createChangeOnNonExistingBranchNotPermitted() throws Exception { blockRead("refs/heads/*"); 
<|del|> 
 @Deprecated 
<|del|> 
 Gson gson = new Gson(); return gson.toJson(this); 
<|del|> 
 public class StatusSummary { public static final StatusSummary INITIAL_STATUS = new StatusSummary(Result.PASSED, System.currentTimeMillis(), 0L); 
 for (RegistrationHandle handle : registeredMetrics) { handle.remove(); 
 for (RegistrationHandle handle : registeredMetrics) { handle.remove(); 
 for (RegistrationHandle handle : registeredMetrics) { handle.remove(); 
 triggers.forEach(Runnable::run); 
<|del|> 
<|del|> 
 @Singleton 
<|del|> 
 .map(f -> Files.getFileExtension(f).toLowerCase(Locale.US)); 
 public static final String FIELD_ONLY_EXTENSIONS = "onlyextensions"; 
 return Splitter.on(',') .splitToList(extList) .stream() .map(FileExtensionPredicate::clean) .distinct() .sorted() .collect(joining(",")); 
import java.io.BufferedReader; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; 
 input.lines().map(logsMapping).filter(Objects::nonNull).forEach(pw::println); 
 String.format("%s/latest_measured_latency", name), 
 String.format("%s/latest_measured_latency", name), 
 public void listProjectsWithLimit() throws Exception { ProjectCacheImpl projectCacheImpl = (ProjectCacheImpl) projectCache; 
 public static Predicate<ProjectData> parent(Project.NameKey parentNameKey) { return new ProjectPredicate(ProjectField.PARENT_NAME, parentNameKey.get()); 
 DynamicSet.bind(binder(), WebUiPlugin.class) .toInstance(new JavaScriptPlugin("zuul-status.html")); 
 throws IOException, OrmException, PermissionBackendException, RestApiException { 
 throws PermissionBackendException, OrmException, ResourceConflictException, BadRequestException, MethodNotAllowedException { 
 logger.atWarning().log( "unexpected tags found when filtering refs/heads/* %s will omit", allVisibleBranches.deferredTags()); 
 private static void checkAndSanitizeChangeInput(ChangeInput input) throws BadRequestException { 
 .create(db, admin.getIdent(), testRepo, JIRA_ISSUE, "a.txt", "test") 
 stderr.print("Invalid 'from' format: " + from + ", expected format <YYYY-MM-DD>"); 
 transformLogs(currentDateString, SSHLog.logFilenameBase(), SSHLog::createFromLog); 
<|del|> 
 /** Reindex all projects at Gerrit daemon startup. */ 
 String.format("Unable to index %s, tests may fail", projectName), e); 
 projectState, accountCache, emails, key, repoManager, configFactory, changeData, branch, files); 
 private static final Map<GitRepositoryManager, Cache> cacheMap = Collections.synchronizedMap(new WeakHashMap<GitRepositoryManager, Cache>()); 
 public String queryValue() { 
 && state != HIDDEN && isNullOrEmpty(matchPrefix) && isNullOrEmpty(matchRegex) && isNullOrEmpty(matchSubstring) 
 && state != HIDDEN && isNullOrEmpty(matchPrefix) && isNullOrEmpty(matchRegex) && isNullOrEmpty(matchSubstring) 
 natural(), 
 logger.atWarning().log("Internal error while processing the query '{}' request", query, e); throw new BadRequestException("Internal error while processing the query request"); 
 .collect(toList()); 
 "Cannot delete project because it has at least one child: " + Iterables.getOnlyElement(children)); 
 throws OrmException, RestApiException { 
<|del|> 
 } catch (OrmException | RestApiException e) { 
 .filter( p -> currentUser .project(new Project.NameKey(p.name)) .testOrFalse(ProjectPermission.ACCESS)) 
 Result result = search("foo", searchers, allVisible()); // Searchers always short-circuit when finding a non-empty result list, and this one didn't // filter out inactive results, so the second searcher never ran. 
 } catch (OrmException | PermissionBackendException | RestApiException e) { 
 + Iterables.getOnlyElement(children).name); 
 + Iterables.getOnlyElement(children).name); 
 throws IOException, OrmException, PermissionBackendException, RestApiException { 
 && showBranch.isEmpty() 
 natural(), p -> p.name, p -> showDescription ? p : nullifyDescription(p))); 
<|del|> 
 * 
 * 
 * <p><strong>Note</strong>: Please use this method with care and consider using {@link * com.google.gerrit.server.ServerInitiated} annotation on the provider of an {@code 
package com.googlesource.gerrit.plugins.imagediff; 
 if (RefNames.isChangeRef(refName)) { 
 // even if the change is not part of the set of most recent changes that 
 checkNotNull(cId, "invalid change id for ref %s", refName); 
 String changeId = createChange().getChangeId(); ListMultimap<String, ApprovalInfo> votes = gApi.changes().id(changeId).current().votes(); 
 gApi.changes().id(changeId).current().review(ReviewInput.dislike()); 
 votes = gApi.changes().id(changeId).current().votes(); 
 /** Returns votes on the revision. */ 
 return ChangeField.getDirectories(cd).stream().anyMatch(pattern::run); 
 public String read() throws ConfigInvalidException, IOException, NoSuchProjectException { Project.NameKey project = branch.getParentKey(); try (Repository repo = repos.openRepository(project)) { 
 assertThat(getType()).isEqualTo(TYPE); 
 private String listProjectsAsJsonToOutputStream(OutputFormat jsonFormat) throws Exception { 
<|del|> 
 @Nullable 
 queries.add(String.format("(state:%s)", state.name())); 
<|del|> 
 NotifyResolver.Result notify) { 
 firstNonNull(input.notify, NotifyHandling.ALL), input.notifyDetails); 
 updates.add(getRepo(project).getUpdate().setNotify(notify).setRefLogMessage("merged")); 
 List<String> versionParts = new ArrayList<>(); 
 private final AllProjectsName allProjectsName; private final AllUsersName allUsersName; 
 private final AllProjectsName allProjectsName; private final AllUsersName allUsersName; 
 ? defaultJgGITProjects() 
 private final Renderer renderer; 
 Renderer renderer, GitilesAccess.Factory accessFactory, GitilesUrls urls, VisibilityCache visibilityCache) { 
 Stream.of(config.getStringList(HEALTHCHECK, healthCheckName, "project")) 
 for (Project.NameKey repoNameKey : repositoryNameKeys) { try (Repository repo = repositoryManager.openRepository(repoNameKey)) { repo.open(repo.resolve("refs/meta/config")).getType(); 
 for (Project.NameKey repoNameKey : repositoryNameKeys) { try (Repository repo = repositoryManager.openRepository(repoNameKey)) { repo.open(repo.resolve("refs/meta/config")).getType(); 
 for (Project.NameKey repoNameKey : repositoryNameKeys) { try (Repository repo = repositoryManager.openRepository(repoNameKey)) { repo.open(repo.resolve("refs/meta/config")).getType(); 
 ensureExists(sitePaths.data_dir).resolve("sp-metadata.xml").toString()); samlClientConfig.setServiceProviderEntityId(callbackUrl + "?client_name=SAML2Client"); 
 /** At least one required check failed; other checks may have passed, or still be running. */ 
 * At least one relevant check is in a non-terminated state ({@link CheckState#NOT_STARTED}, * {@link CheckState#SCHEDULED}, {@link CheckState#RUNNING}), and no required checks failed. Some * optional checks may have failed. 
 * Combines multiple per-check states into a single combined state. 
 * Combines multiple per-check states into a single combined state. 
 private final GlobalChecksConfig globalChecksConfig; 
 GlobalChecksConfig globalChecksConfig, 
 deleteChangeFromIndex(projectName, id); 
 checkerUpdateBuilder.setUrl(CheckerUrl.clean(input.url)); 
 if (isPrivate && !change.getStatus().isOpen()) { throw new BadRequestException("cannot set a non-open change to private"); 
 if (isPrivate && !change.getStatus().isOpen()) { throw new BadRequestException("cannot set a non-open change to private"); 
 private void deleteChangeFromIndex(String projectName, int id) { IndexChangeTask task = new IndexChangeTask(projectName, id, true, new IndexEvent()); 
 private void deleteChangeFromIndex(int id) { IndexChangeTask task = new IndexChangeTask("", id, true, new IndexEvent()); 
 private void deleteChangeFromIndex(int id) { IndexChangeTask task = new IndexChangeTask("", id, true, new IndexEvent()); 
 private void deleteChangeFromIndex(int id) { IndexChangeTask task = new IndexChangeTask("", id, true, new IndexEvent()); 
 private final boolean listProjectsFromIndex; 
 + "), but change status is MERGED")); 
 requireNonNull(changeMessage); 
 private void mergeByOwnerAllSubmitStrategies(boolean advanceBranchBeforeSubmitting) 
 if (replConfig.getMaxRefsToLog() == 0 || todo.size() <= replConfig.getMaxRefsToLog()) { 
 return false; 
 CheckersUpdate provideServerInitiatedCheckersUpdate( 
 /** * Asserts that the commit has the given commit message, up to skew of at most 1 second. * * @param expectedCommitTimestamp expected commit timestamp. */ 
 List<PluginDefinedInfo> plugins = new ArrayList<>(attributeFactories.plugins().size()); 
@UsedAt(UsedAt.Project.PLUGIN_CHECKS) 
<|del|> 
 abandonMessage = readAbandonMessage(); 
<|del|> 
<|del|> 
Copyright (C) 2019 The Android Open Source Project 
 * not test the functionality of the plugin REST endpoints. 
 public ImmutableList<T> getComments() { 
<|del|> 
 if (update.state().isPresent() && !update.state().get().equals(state)) { 
<|del|> 
 newCheck.created = Timestamp.from(personIdent.getWhen().toInstant()); 
 modifiedCheck.updated = Timestamp.from(personIdent.getWhen().toInstant()); 
 return Protos.toByteArray(object); 
 return Protos.parseUnchecked(parser, in); 
<|del|> 
 String trimmed = Strings.nullToEmpty(commitMessage).trim(); if (trimmed.isEmpty()) { 
 if (trimmed.indexOf(0) >= 0) { throw new BadRequestException("Commit message cannot have NUL character"); 
 @Inject private DynamicSet<ChangeMessageModifier> changeMessageModifiers; @Inject private DynamicItem<UrlFormatter> urlFormatter; 
 @Inject private DynamicSet<ChangeMessageModifier> changeMessageModifiers; @Inject private DynamicItem<UrlFormatter> urlFormatter; 
 if (isEnabled) { healthy = doCheck(); } else { healthy = Result.DISABLED; } 
 this.enabled = config.healthCheckEnabled(name); 
 healthy = enabled ? doCheck() : Result.DISABLED; 
 return failingResults.contains(this.result); 
<|del|> 
 buf.close(); // Flush file and close for writes, but leave available for reading. 
 buf.close(); // Flush file and close for writes, but leave available for reading. 
 "added", "after", "age", 
 * <p>Checkers may not have a name, in this case {@link Optional#empty()} is returned. 
 * is not in the proper format. 
 // Callers shouldn't really be providing UUID. If they do, the only legal UUID is exactly the // current UUID. 
 * <p>This pattern requires a plugin declared permission to have a name in the access section of 
 * <p>This pattern requires a plugin declared permission to have a name in the access section of 
 public ImmutableMap<String, String> collectPluginCapabilities() { return collectPermissions(capabilityDefinitions, ""); 
 "Plugin name '%s' must match '%s' to use permissions; rename the plugin", 
 // "-" is allowed for a plugin name. Here "foo-a" should be the name of the plugin. 
 checkArgument( isValidPluginPermissionName(permission), "invalid plugin permission name: " + permission); 
 return MoreObjects.toStringHelper(this) .add("pluginName", pluginName) .add("permission", permission) .toString(); 
 throw new PermissionBackendException(perm.describeForException() + " unsupported"); 
 for (T perm : permSet) { // Allow ProjectPermission.READ, if it was requested in the input permSet. This implies // that permSet has type Collection<ProjectPermission>, otherwise no permission would // compare equal to READ. 
<|del|> 
 private OcPresenceHandle(long nativeHandle) { 
<|del|> 
 private OcRequestHandle(long nativeHandle) { 
 private native void get1(Map<String, String> queryParamsMap, OnGetListener onGetListener, QualityOfService qualityOfService) throws OcException; 
package org.iotivity.base; 
 CALeScanCallback(device, rssi, scanRecord); 
 CALeGattCharacteristicReadCallback(gatt, characteristic, characteristic.getValue(), status); 
 CALeGattCharacteristicWriteCallback(gatt, characteristic, characteristic.getValue(), status); 
 private static final BluetoothGattServerCallback mGattServerCallback = new BluetoothGattServerCallback() { 
 CALeGattServerCharacteristicReadRequestCallback(device, requestId, offset, characteristic, characteristic.getValue()); 
 CALeGattServerDescriptorWriteRequestCallback(device, requestId, descriptor, preparedWrite, responseNeeded, offset, value); 
 } 
 } 
 ConnectivityManager manager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo nwInfo = manager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); 
 if(nwInfo.isConnected()) { CAWiFiStateEnabled(); 
 mMode_tv = (TextView) findViewById(R.id.tv_mode); mNetwork_tv = (TextView) findViewById(R.id.tv_network); 
 mMode_tv = (TextView) findViewById(R.id.tv_mode); mNetwork_tv = (TextView) findViewById(R.id.tv_network); 
 public native void RMSendResponse(String uri, String payload, int selectedNetwork, int isSecured); 
 public native void RMAdvertiseResource(String advertiseResource, int selectedNetwork); 
 public native void RMSendNotification(String uri, String payload, int selectedNetwork, int isSecured); 
 ConnectivityManager manager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo nwInfo = manager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); 
 public static final String GROUP_INTERFACE = "oc.mi.grp"; 
 private static ArrayList<FileObserver> m_observer; private static FelixManager m_felixmgr; private static Context m_context; private static final int TRUE = 1; private static final int FALSE = 0; 
 private static ArrayList<FileObserver> m_observer; private static FelixManager m_felixmgr; private static Context m_context; private static final int TRUE = 1; private static final int FALSE = 0; 
 private static ArrayList<FileObserver> m_observer; private static FelixManager m_felixmgr; private static Context m_context; private static final int TRUE = 1; private static final int FALSE = 0; 
 if (m_felixmgr == null) { m_felixmgr = new FelixManager(ctx); 
 m_context = ctx; m_observer = new ArrayList<FileObserver>(); 
<|del|> 
<|del|> 
 int flag = FALSE; 
 if (flag == TRUE) flag = loadPluginInfoToManager(path); 
<|del|> 
 int flag = TRUE; 
 m_observer.add(observer); 
 int flag = TRUE; 
 FelixManager.printPluginList(); 
// Copyright 2015 Samsung Electronics All Rights Reserved. 
/// @brief This class is OnGetListener for Belkinplug. 
// Copyright 2015 Samsung Electronics All Rights Reserved. 
/// @brief This class is OnGetListener for Gear. 
 final private static String TAG = "OnGetGear"; 
// Copyright 2015 Samsung Electronics All Rights Reserved. 
/// @brief This class is OnGetListener for Huebulb. 
// Copyright 2015 Samsung Electronics All Rights Reserved. 
 final private static String TAG = "OnPutBelkinplug"; 
// Copyright 2015 Samsung Electronics All Rights Reserved. 
/// @brief This class is OnPutListener for Gear. 
 final private static String TAG = "OnPutGear"; 
// Copyright 2015 Samsung Electronics All Rights Reserved. 
/// @brief This class is OnPutListener for Huebulb. 
 final private static String TAG = "OnPutHuebulb"; 
// Copyright 2015 Samsung Electronics All Rights Reserved. 
/// @brief This class provides information of each plugin installed for JAVA. 
// Copyright 2015 Samsung Electronics All Rights Reserved. 
/// @brief After installing a plug-in in a directory, each plug-ins can be managed by this class. 
 * SSMCore received asynchronously on making a query with the SSMCore. * Application should implement the pure virtual function OnQueryEngineEvent. * The Application should call registerQuery() and add a listener. 
 * 
 * 
 * 
 * * @param resources - List of resources discovered in the network 
 * * @param resources - List of resources discovered in the network 
 * * @param resource - URI of resource. 
 * * @param resource - URI of resource. * @param result - error code. 
 * * @param resource - URI of resource. * @param result - error code. 
 * * @param listener - @ref IFindCandidateResourceListener to receive the 
 * * @param listener - @ref ISubscribePresenceListener to receive child 
 * * @param listener - @ref IFindGroupListener to receive group discovery 
 * * @param listener - @ref IConfigurationListener to receive asynchronous 
 * * @param listener - @ref IDiagnosticsListener to receive asynchronous 
 * * @param listener - @ref IActionListener to receive Get, PUT and POST 
 * * @param resourceTypes - required resource types(called "candidate") * 
 * * @param resourceTypes - required resource types(called "candidate") * @param waitTime - Delay time to add in seconds before starting to 
 * 
 * * @param childHandle - child resource handle. It will be filled from 
 * * @param resource - resource representing the target group or the 
 * @param configurations - ConfigurationUnit: a nickname of attribute of 
 * * @param resource - resource representing the target group or the 
 * * @param resource - resource pointer representing the target group * 
 * * @param resource - resource pointer representing the target group * 
 * * @param resource - resource pointer of the group resource * @param actionSet - pointer of ActionSet * 
 * * @param resource - resource pointer of the group resource * @param actionsetName - ActionSet name for removing the ActionSet * @param delay - Wait time for the ActionSet execution * 
 * * @param resource - resource pointer of the group resource * @param actionsetName - ActionSet name for removing the ActionSet * @param delay - Wait time for the ActionSet execution * 
 * * @param resource - resource pointer of the group resource * @param actionsetName - ActionSet name for removing the ActionSet * 
 * * @param resource - resource pointer of the group resource * @param actionsetName - ActionSet name for removing the ActionSet * 
 * * @param resource - resource pointer of the group resource * @param actionsetName - ActionSet name for removing the ActionSet * 
 * * @param resource - resource pointer of the group resource * @param actionsetName - ActionSet name for removing the ActionSet * 
 * 
 * * @param listener - interface for getting notification when resources 
 * * @param listener - interface for getting notification regarding child 
 * 
 * * @param listener - interface for getting notification on configuration 
 * * @param listener - interface for receiving asynchronous response for 
 * * @param listener - interface for receiving the callback for the GET, 
 * * @param resources - List of resources discovered in the network * 
 * * @param listener - interface for getting notification when resources 
 * * @param listener - interface for getting notification regarding child 
 * * @param listener - interface for getting notification on whether the 
 * * @param listener - interface for getting notification on configuration 
 * * @param resourceTypes - resource types of a group to find and join * 
 * * @param resourceType - resource type of a group to create * 
 * * @param resourceType - resource type of a group to join. * @param resourceHandle - resource handle to join a group. * 
 * * @param resourceType - resource type of a group to join. * @param resourceHandle - resource handle to join a group. * 
 * * @param resource - group resource to join. * @param resourceHandle - resource handle to join a group. * 
 * * @param resource - group resource to join. * @param resourceHandle - resource handle to join a group. * 
 * * @param resourceType - resource type of a group to leave. * @param resourceHandle - resource handle to leave a group. * 
 * * @param resource - resource pointer of the group resource * @param actionsetName - ActionSet name for removing the ActionSet * @param delay - Wait time for the ActionSet execution * 
 * Register listener for find group callback. * * @param listener - interface for getting notification on whether the 
 * - Time duration in seconds to find the resources in network * 
 * @param Plugin's name and id Strings. 
 * @param key - key information of the plug-in to be stopped. * @param value - value information of the plug-in to be stopped. 
 * @param key - key information of the plug-in to be stopped. * @param value - value information of the plug-in to be stopped. 
 * @param key - key information of the plug-in to be stopped. * @param value - value information of the plug-in to be stopped. 
 configurationApisList.add("Find All Groups"); configurationApisList.add("Find All Resources"); configurationApisList.add("Get a Configuration Resource"); 
 configurationApisList.add("Find All Groups"); configurationApisList.add("Find All Resources"); configurationApisList.add("Get a Configuration Resource"); 
 * vertical bar(|): URI and a pair of attribute key and value). 
<|del|> 
 } 
 } 
 while (true) { // Put this thread for sleep for 1 sec. // Sleep value can be changed as per the developer convenience. 
 Log.i(LOG_TAG, "setDiagnosticsRepresentation: exit"); 
 } 
 // getters and Setters Methods for FacoryReset Resource 
 * 
 * * OCStackResult result = thingsManagerObj.findCandidateResources(resourceTypes); * if (OCStackResult.OC_STACK_OK != result) { 
 * * @param resourceTypes - required resource types(called "candidate") * @param waitTime - Delay time to add in seconds before starting to 
 * 
 * 
 * 
 * 
 * 
 * * @param resource - resource pointer representing the target group * 
 * 
 * * @param resource - resource pointer representing the target group * 
 * capability.status = "off"; 
 * } 
 * 
 * 
 * 
 * 
public class CAWiFiInterface { 
<|del|> 
 * Return instance of CoreController. 
 * Return instance of CoreController. 
<|del|> 
<|del|> 
<|del|>
 private native static void CaLeRegisterLeScanCallback(BluetoothAdapter.LeScanCallback callback); 
 private static List<UUID> getUuids(final byte[] scanRecord) { 
 private CaEdrInterface(Context context) { 
 private CaEdrInterface(Context context) { 
 private native static void caEdrBondStateChangedCallback(String addr); 
 private native static void caEdrBondStateChangedCallback(String addr); 
 private native static void caLeRegisterLeScanCallback(BluetoothAdapter.LeScanCallback callback); 
 private native static void caLeScanCallback(BluetoothDevice device, 
 private native static void caLeGattConnectionStateChangeCallback( 
 private native static void caLeGattServicesDiscoveredCallback(BluetoothGatt gatt, int status); 
 private native static void caLeGattCharacteristicWriteCallback( 
 private native static void caLeGattCharacteristicChangedCallback( 
 private native static void caLeGattDescriptorReadCallback(BluetoothGatt gatt, 
 private native static void caLeGattDescriptorWriteCallback(BluetoothGatt gatt, 
 private native static void caLeGattReliableWriteCompletedCallback(BluetoothGatt gatt, 
 private native static void caLeGattReadRemoteRssiCallback(BluetoothGatt gatt, int rssi, 
 private native static void caLeStateChangedCallback(int state); 
 private native static void caLeBondStateChangedCallback(String address); 
 private CaLeServerInterface() { 
 private CaLeServerInterface() { 
 private native static void caLeRegisterGattServerCallback(BluetoothGattServerCallback callback); 
 private native static void caLeGattServerConnectionStateChangeCallback( 
 private native static void caLeGattServerServiceAddedCallback(int status, 
 private native static void caLeGattServerCharacteristicReadRequestCallback( 
 private native static void caLeGattServerDescriptorReadRequestCallback( 
 public native static void caLeGattServerDescriptorWriteRequestCallback( 
 private native static void caLeGattServerExecuteWriteCallback(BluetoothDevice device, 
 private native static void caLeGattServerNotificationSentCallback(BluetoothDevice device, 
 private native static void caLeAdvertiseStartSuccessCallback( 
 private native static void caLeAdvertiseStartFailureCallback(int errorCode); 
 public static final String BATCH_INTERFACE = "oic.if.b"; 
 public static final String PRESENCE_URI = "/oic/ad"; 
 public static final String LINK_INTERFACE = "oic.if.ll"; 
 public static final String GROUP_INTERFACE = "oic.mi.grp"; 
<|del|> 
 sampleProviderObj = this; 
<|del|> 
 Button button = (Button) findViewById(R.id.button1); 
 private static String TAG = "Sample_Service : CaLeClientInterface"; 
 list.setAdapter(new ArrayAdapter(activity, 
 private static String TAG = "Sample_Service : CaLeClientInterface"; 
 private static String SERVICE_UUID = "ADE3D529-C784-4F63-A987-EB69F70EE816"; 
 private EnrolleeDevice enrolleeDevice; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 IMessageLogger { private static final String TAG = "SimpleClient: "; 
 } 
<|del|> 
 i.putExtra(NfcAdapter.EXTRA_NDEF_MESSAGES, intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES)); sendBroadcast(i); 
 super.onPostResume(); Log.d(TAG, "onResume"); 
 if (mSelectedItems[i] == 1) { interestedNetwork |= (1 << i); } 
 if (mUnSelectedItems[i] == 1) { uninterestedNetwork |= (1 << i); } 
 if ((null == mActivity) || (null == mContext) || (null == mAdapter)) { Log.e(MYTAG, "CaNfcInitialize failed, invalid parameters"); 
 * Copyright 2015 Samsung Electronics All Rights Reserved. 
 Context context, 
 Context context, 
 private RCSAddress(String addr, DiscoveryType discoveryType) { m_address = addr; m_typeOfDiscovery = discoveryType; 
 m_rcsAddressInstance = new RCSAddress("", DiscoveryType.MULTICAST); return m_rcsAddressInstance; 
 public DiscoveryType getTypeOfDiscovery() { return m_typeOfDiscovery; 
 private IDiscoverResourceListener m_discoverListener; private static RCSDiscoveryManager m_rcsDiscoveryManagerInstacne; 
 private RCSDiscoveryManager() { 
 private RCSDiscoveryManager() { 
 Log.i(LOG_TAG, "discoverResource called"); discoverResourceByType(address, OC_RSRVD_WELL_KNOWN_URI, ""); 
 import org.iotivity.ResourceEncapsulation.client.RCSDiscoveryManager.IDiscoverResourceListener; 
 private String LOG_TAG = this.getClass() 
 m_cacheUpdateListener = listener; 
 Log.i(LOG_TAG, "startMonitoring called"); this.nativeStartMonitoring(m_stateChangedListener); 
 Log.i(LOG_TAG, "getCachedAttribute called"); 
 Log.i(LOG_TAG, "getRemoteAttributes called"); this.nativeGetRemoteAttributes(m_remoteAttributeListener); 
 Log.i(LOG_TAG, "getTypes called"); 
 Log.i(LOG_TAG, "getTypes called"); 
 Log.i(LOG_TAG, "getInterFaces called"); 
 private long m_nativeHandle; private boolean m_nativeNeedsDelete; 
 private String m_resourceUri; private String m_resourceType; private String m_resourceInterface; private boolean m_observableFlag; private boolean m_discovervableFlag; private RCSResourceAttributes m_attributes; 
 return this.nativeBuild(m_resourceUri, m_resourceType, m_resourceInterface, m_observableFlag, m_discovervableFlag, m_attributes); 
 private final static int DEFAULT_RESPONSE = 0; private final static int CREATE_WITH_RESULT = 1; private final static int CREATE_WITH_ATTRIBUTE = 2; private final static int CREATE_WITH_ATTRIBUTE_AND_RESULT = 3; 
 return new RCSGetResponse(); 
 private long m_nativeHandle; private IGetRequestHandler m_getRequestListener; private ISetRequestHandler m_setRequestListener; private IAttributeUpdatedListener m_attributeUpdatedListener; 
 m_setRequestListener = listener; 
 * The thread-safety for attributes is taken care internally. 
 * @return true if observable otherwise false 
 m_attributeUpdatedListener); 
 return new RCSSetResponse(DEFAULT_RESPONSE); 
<|del|> 
 if ((null == mActivity) || (null == mContext) || (null == mAdapter)) { Log.e(MYTAG, "CaNfcInitialize failed, invalid parameters"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Log.i(LOG_TAG, "setAttribute (integer) called"); 
 Log.i(LOG_TAG, "setAttribute (float) called"); 
 Log.i(LOG_TAG, "setAttribute (String) called "); 
 Log.i(LOG_TAG, "getAttributeValue called"); 
 Log.i(LOG_TAG, "removeAttribute called"); 
 Log.i(LOG_TAG, "getAttributes called"); 
 Log.i(LOG_TAG, "isObservable called"); 
 Log.i(LOG_TAG, "isDiscoverable called"); 
 * @return AutoNotifyPolicy 
 * @return SetRequestHandlerPolicy 
<|del|> 
<|del|> 
<|del|> 
 * This Enum defines discovery codes for different discovery types. 
 logMessage += "Recieved Callback for called API (OnPostCallback)" + "\n"; 
 public static List<OcSecureResource> discoverUnownedDevices(int timeout) throws OcException { return Arrays.asList(OcProvisioning.discoverUnownedDevices1(timeout)); } private static native OcSecureResource[] discoverUnownedDevices1(int timeout) throws OcException; 
 public void doOwnershipTransferListener(List<ProvisionResult> provisionResultList, 
 public void removeDeviceListener(List<ProvisionResult> provisionResultList, 
 public void unlinkDevicesListener(List<ProvisionResult> provisionResultList, 
 public void provisionCredentialsListener(List<ProvisionResult> provisionResultList, 
 public void provisionPairwiseDevicesListener(List<ProvisionResult> provisionResultList, 
 public DeviceStatus getDeviceStatus() throws OcException { return DeviceStatus.convertDeviceStatus(this.deviceStatus()); } public native int deviceStatus() throws OcException; 
 public List<String> getOwners() { return Arrays.asList(owners); 
 * {@link DeviceInfo} object holding the device information. 
 * {@link SimulatorResourceModel}. 
 * {@link SimulatorResourceModel}. 
 * {@link SimulatorResourceModel}. 
 * {@link SimulatorResourceModel}. 
 * {@link SimulatorResourceModel} of the resource. 
 * {@link AutomationType} indicating whether the automation is * one-time or recursive. 
 * The activator class controls the plug-in life cycle. 
 public static final String PLUGIN_ID = "ClientControllerPlugin"; 
<|del|> 
<|del|> 
 public OicSecAcl(String subject, List<String> recurrences, List<String> periods, int permission, List<String> resources, List<String> owners) { 
 public void setOwners(List<String> owners) { 
 public List<String> getRecurrences() { return recurrences; 
 public void setPeriods(List<String> periods) { 
 public static native void issueRootCertificate (String notBefore, String notAfter, byte[] certificate) throws OcException; 
 public static native void issueDeviceCertificate (String subject, String notBefore, String notAfter, byte[] subjectPublicKey, byte[] certificate) throws OcException; 
 public static native void revocateCertificate (String currentTime, long revokedNumber, byte[] crl) throws OcException; 
<|del|>
 } 
 private boolean mIsConnected; private String mServiceUUID; 
 Toast.makeText(OnBoardingSelect.this, "Please Select OnBoarding method " + "before Continuing", Toast.LENGTH_SHORT).show(); 
 easySetupManagerNativeInstance.provisionEnrollee(connection.getMacaddress(), wifiProvConfig.getSsId(), wifiProvConfig.getPassword(), ocConnectivityType.getValue()); 
<|del|> 
<|del|> 
 if(!groupFound) { Log.d(LOG_TAG, "Group Found URI : " + resourceURI); 
 }else{ Log.d(LOG_TAG, "Group Already found "); } 
 OcPlatform.bindResource(groupResourceHandle, foundLightHandle); Log.d(LOG_TAG, "Bind resource done"); } catch (OcException e) { // TODO Auto-generated catch block e.printStackTrace(); } 
<|del|> 
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 mWiFiProvConfig = new WiFiProvConfig(mEnrolleeSsidText.getText().toString(), mmEnrolleePasswordPassText.getText().toString()); 
 mBleOnBoardingConfig = new BLEOnBoardingConfig(); /* set the uuid of the OIC-device, so that the Easysetup API can find the device */ 
<|del|> 
 Thread.sleep(15000);//Sleep for allowing thin device to start the services 
 public static native void setCaInfo (long serNum, String rootName) throws OcException; 
 public static native void generateCaKeyPair (byte[] caPrivateKey, byte[] caPublicKey) throws OcException; 
 * Basic BundleResource that should be used as a base class by a bundle * resources. A concrete technology has to override the setAttribute and * getAttribute method and map the according reads and writes to the technology * specific messages. 
 * Basic BundleResource that should be used as a base class by a bundle * resources. A concrete technology has to override the setAttribute and * getAttribute method and map the according reads and writes to the technology * specific messages. 
 for (ResourceConfig config : resourceConfig) { 
 messageCount++; } 
 if (onboardingConfig.getConnType() != OnBoardingConfig.ConnType.WiFi) { throw new IllegalArgumentException("OnBoarding configuration is not supported"); } 
 public static native void generateCaKeyPair (List<Byte> caPrivateKey, List<Byte> caPublicKey) throws OcException; 
 public static final String RESOURCE_TYPENAME = "oic.r.resourcehosting"; 
 // Handled in EasySetupStatusTest 
<|del|>
 public static native void setDisplayPinListener(DisplayPinListener displayPinListener) 
 * CA_IP = (1 << 0) CA_LE = (1 << 1) CA_EDR = (1 << 2) CA_TCP = (1 << 4) 
<|del|>
<|del|> 
<|del|> 
 //hard coded url of sample image editTextUrl.setText("http://theselby.com/media/2_28_11_SupremeCoffee7598.jpg"); 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 private ArrayList<String> getJsonValueList(String key, JsonNode jsonNode){ ArrayList<String> jsonValueList = new ArrayList<>(); 
 jsonValueList.add(value); return jsonValueList; 
 receivedACKList.remove(mid); 
 receivedACKList.remove(mid); 
<|del|>
<|del|>
<|del|>
<|del|>
<|del|> 
 private native static NdefMessage caNativeNfcCreateNdefMessage(byte[] sendData); private native static boolean caNativeNfcInvokeBeam(); 
 public void caNfcInitialize() { Log.d(MYTAG, "caNfcInitialize"); 
***************************************************************** 
 if (null == mAdapter) 
 CT_ADAPTER_REMOTE_ACCESS(1 << 19), 
 NdefMessage msg; 
<|del|> 
 i.putExtra(NfcAdapter.EXTRA_NDEF_MESSAGES, intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES)); 
<|del|> 
 i.putExtra(NfcAdapter.EXTRA_NDEF_MESSAGES, intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES)); 
 if(null == mAdapter) 
<|del|> 
 "Request Setting Fisrt!!", Toast.LENGTH_LONG).show(); 
 public PlatformConfig(Context context, 
***************************************************************** 
 public PlatformConfig(Context context, 
<|del|> 
<|del|>
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private boolean isInvokeBeam; 
<|del|> 
<|del|> 
 private boolean isInvokeBeam; 
 private boolean isInvokeBeam; 
***************************************************************** 
<|del|> 
<|del|> 
<|del|>
<|del|>
 // Returns the already created message 
 private boolean misInvokeBeam; 
 // Returns the already created message 
 CaInterface.initCheckForConnectionManager(); CaInterface.caManagerSetAutoConnectionDeviceInfo(address); 
 CaInterface.initCheckForConnectionManager(); CaInterface.caManagerUnsetAutoConnectionDeviceInfo(address); 
 CaInterface.initCheckForConnectionManager(); CaInterface.caManagerUnsetAutoConnectionDeviceInfo(address); 
 private boolean isSecurityEnabled = false; 
 mWiFiProvConfig.setSecured(isSecurityEnabled); 
 mWiFiProvConfig.setSecured(isSecurityEnabled); 
 mWiFiProvConfig.setSecured(isSecurityEnabled); 
 mWiFiProvConfig.setSecured(isSecurityEnabled); 
 mWiFiProvConfig.setSecured(isSecurityEnabled); 
 mWiFiProvConfig.setSecured(isSecurityEnabled); 
<|del|> 
 private static volatile boolean sIsPlatformInitialized = false; private static QualityOfService sPlatformQualityOfService = QualityOfService.NA; 
<|del|> 
<|del|> 
<|del|> 
 private static final String TAG = "OCF_SIMPLE_BLUETOOTH"; private static final String CA_GATT_SERVICE_UUID = "ADE3D529-C784-4F63-A987-EB69F70EE816"; 
 private static final int REQUEST_ENABLE_BT = 1; private static final long SCAN_PERIOD = 10000; 
 private Button btButton; private Button leButton; 
 PlatformConfig cfg = new PlatformConfig(mActivity, mContext, ServiceType.IN_PROC, ModeType.CLIENT, Common.IP_ADDRESS, Common.IP_PORT, 
 final String msg = getString(R.string.action_onadapterstatechanged) + enabled; 
 final String msg = getString(R.string.action_onconnectionstatechanged) + connected; 
<|del|> 
<|del|> 
 public static final String TCP_PORT = ":8000"; public static final String IP_ADDRESS = "0.0.0.0"; public static final int IP_PORT = 0; 
 DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.getDefault()); SimpleDateFormat format = (SimpleDateFormat) dateFormat; 
<|del|> 
<|del|> 
 private QualityOfService qos = QualityOfService.LOW; 
 private String mLargeData; private boolean mState; private long start_time; private long end_time; 
 private final double MILLI_PER_SEC = 1000.0; 
 private final double MILLI_PER_SEC = 1000.0; 
 resultLog.setText("Created resource" + lineEnd); 
 resultLog.setText("Created resource" + lineEnd); 
 sb.append(lineEnd + "Light State : " + mState); sb.append(lineEnd + "Time : " + Common.getDateCurrentTimeZone()); 
 sb.append(lineEnd + "!! Error occurred during sending the response !!"); 
 sb.append(lineEnd + "!! Error occurred during sending the response !!"); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Button buttonA; Button buttonB; Button buttonC; 
 StringBuilder sb = new StringBuilder(getString(R.string.action_onclick)); 
<|del|> 
 AUTHENTICATION_FAILURE("AUTHENTICATION_FAILURE", "This error is pushed from DTLS interface when handshake failure happens"), 
 AUTHENTICATION_FAILURE("AUTHENTICATION_FAILURE", "This error is pushed from DTLS interface when handshake failure happens"), 
 public static final String DEFAULT_INTERFACE = "oc.mi.def"; public static final String LINK_INTERFACE = "oc.mi.ll"; public static final String BATCH_INTERFACE = "oc.mi.b"; public static final String GROUP_INTERFACE = "oc.mi.c"; 
 public synchronized static void Shutdown() { if (!sIsShutdownPlatform) 
 private static native void shutdown(); private static native void reInit(); 
 sb.append(dateFormat.format(currentTimeZone)); 
 private final String EOL = System.getProperties().getProperty("line.separator"); 
 private final String EOL = System.getProperties().getProperty("line.separator"); 
 private long mStartTime; private long mEndTime; 
 resultLog.append(String.format("%.3f", flightTime) + "sec" + EOL); actionLog.append(foundResource.getHost() + resourceUri + EOL); 
 private ArrayList<String> mItems; 
<|del|> 
<|del|> 
 return String.format("%.2f" + " GB", fileSize/1000000000f); 
<|del|> 
 public boolean setWifiApEnabled(WifiConfiguration wifiConfig, 
<|del|> 
<|del|> 
<|del|> 
 mThrottlingDelay = 0; mIp = "0.0.0.01"; 
 byte[] byteArrV = {1, 2, 3, 4, 0, 5, 6, 7}; 
<|del|> 
public class IoTNotification { 
 * // Copyright 2016 Samsung Electronics All Rights Reserved. 
 * // Copyright 2016 Samsung Electronics All Rights Reserved. 
 * // Copyright 2016 Samsung Electronics All Rights Reserved. 
 public ExpandableListAdapter(List<String> groupList, List<Object> childitemsList, Context context) { 
 public Led() { 
 } catch (OcException e) { Log.d(TAG, "Error in GET calls"); 
 Log.e(TAG, "Exception: stopping presence when configuration step: " + e); 
 // filter exception case : Some notification are generated twice 
 // Temporary protocol code to display ICON on consumer app. // For example, consumer app shows KAKAOTALK Icon when receiving Notification with SOURCE // that is set to KAKAO, otherwise it displays OCF Icon on current sample app. 
 public synchronized static void setLeScanIntervalTime(int intervalTime, int workingCount){ CaInterface.setLeScanIntervalTimeImpl(intervalTime, workingCount); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 * @param intervalTime interval time(Seconds). 
 private List<String> mGroupList; private List<Object> mChilditemsList; private Context mContext; 
 private native int[] getPairingMethods(); 
 public native void doDirectPairing(OcDirectPairDevice peer, 
 public String toString() { return this.mdeviceID; } 
 this.mRecurrences = recurrences; this.mPeriods = periods; this.mPermission = permission; this.mResources = resources; 
 private List<String> mGroupList; private List<Object> mChilditemsList; private Context mContext; 
 private final String mAuthCode; private final String mAuthProvider; private final String mCiServer; 
 * 
 * Copyright 2016 Samsung Electronics All Rights Reserved. 
 private native void nativeInitRemoteEnrollee(); 
<|del|>
 nativeSetCloudProvInfo(cloudInfo.getAuthCode(), cloudInfo.getAuthProvider(), cloudInfo.getCiServer()); } 
 private ESResult mResult; private String mDevUUID; 
 private ESResult mResult; private String mDevUUID; 
 private native void nativeSetDataProvInfo(String ssid, String pwd, int authType, int encType, String language, String country); 
 nativeSetDataProvInfo(dataInfo.getSsid(), dataInfo.getPwd(), dataInfo.getAuthType().getValue(), dataInfo.getEncType().getValue(), dataInfo.getLanguage(), dataInfo.getCountry()); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Log.e(TAG, e.getMessage()); Toast.makeText(this,"provisionInit error: " + e.getMessage(), Toast.LENGTH_LONG).show(); 
 private boolean copyJsonFromAsset() { 
 if(!copyJsonFromAsset()) 
 * @param name Device's human-friendly name like device model name 
 nativeProvisionDeviceProperties(deviceProp.getSsid(), deviceProp.getPwd(), deviceProp.getAuthType().getValue(), deviceProp.getEncType().getValue(), deviceProp.getLanguage(), deviceProp.getCountry(), callback); 
 * This class provides a sample to make .jar that communicates with OAuth2 * provider. 
 server.startServer(tlsInformation); 
<|del|> 
<|del|> 
 // assertion for observer device (resource presence response) 
<|del|> 
 private IRequest PublishTopicRequest(String topicName) { 
<|del|>
<|del|> 
<|del|> 
<|del|> 
 public void setCloudID(String cloudID) { mCloudID = cloudID; } 
 mDiscoverResource.setText("Found"); 
<|del|> 
public final class CrlIssuer { 
 public static byte[] generateCrl(String issuerName, 
 public static byte[] getCrl() throws Exception { 
 private CrlStore() { throw new AssertionError(); //to get rid of security issue, connected with Java Reflection API } 
 public void setGid(Object gid) { this.gid = gid.toString(); 
 "catching DB error in MongoDB or AccountDBManager file"); 
<|del|> 
<|del|> 
 e.printStackTrace(); throw new InternalServerErrorException( "Map to Object casting error"); 
 public int getKafkaSessionTimeout() { 
 // mongoDB.showRecord(tableName); 
 Document selectedDoc = cursor.next(); recordList.add(convertDocumentToHashMap(selectedDoc)); 
 private TypeCastingManager<GroupTable> mTypeGroup = new TypeCastingManager<>(); 
 return MessageBuilder.createResponse(request, ResponseStatus.CHANGED, ContentFormat.APPLICATION_CBOR, mCbor.encodingPayloadToCbor(responsePayload)); 
 if (midList != null) { mGrManager.addGroupMember(gid, new HashSet<String>(midList)); } 
 if (diList != null) { mGrManager.addGroupDevice(gid, new HashSet<String>(diList)); } 
 String authProvider, Object options) { 
 TokenTable tokenInfo = requestAccessToken(authCode, options); 
 if (tokenInfo.getExpiredtime() == Constants.TOKEN_INFINITE) { 
 return true; 
 responsePayload = mAsManager.searchUserAboutUuid(suid.get(0)); 
 mAsManager.deleteDevice(uid, did); 
 "catching DB error in MongoDB or AccountDBManager file"); 
 payloadData.put(Constants.DEVICE_ID, srcDevice.getDeviceId()); payloadData.put(Constants.ACCESS_TOKEN, srcDevice.getAccessToken()); 
 private IRequestChannel mAuthServer = null; 
 if (request.getUriPathSegments().size() > 4) { ; } else { 
 if (mExpiredPolicy == INFINITE_TIME) { 
 throw new BadRequestException("observe type not supported"); 
 throw new BadRequestException("topic name is not included in request uri"); 
 HashMap<String, Object> message = mCbor.parsePayloadFromCbor(payload, 
<|del|>
 public final static int EXPIRES_IN = 3600; // 1hour 
public class ConfigurationXml extends XmlConfigParser { private static ConfigurationXml instance = new ConfigurationXml(); 
<|del|>
<|del|>
 } 
 throw new NotFoundException("main topic doesn't exist"); 
 public Message(String title, String contentText, String sourceName) 
 public Message(String title, String contentText, String sourceName) 
<|del|> 
 public static ProviderService getInstance() { return instance; } public int Start(boolean policy, OnSubscriptionListener subscriptionListener, OnSyncInfoListener syncInfoListener) throws NSException { 
 public void Start(boolean policy) 
 public void SendMessage(Message notiMessage) { 
 public void SendSyncInfo(long messageId, SyncInfo.SyncType syncType) { 
<|del|> 
<|del|> 
<|del|>
 mRDServer.sendRequest(mRequest, mSrcDevice); break; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 // static token type 
 public static final String CREDPROV_URI = "credprov"; 
 public static final String CREDPROV_URI = "credprov"; 
 public static final String CERT_URI = "cert"; 
<|del|> 
 responsePayload = mInviteManager.getInvitationInfo(uid); 
 public AclTable(String aclid, String oid, String di, String rowneruuid, 
 return oid; 
 public boolean deleteAclId(String aclid) { 
 super(Arrays.asList(Constants.PREFIX_OIC, 
 private boolean checkPermission(String sid, String di, String rm, String uri) 
 if (checkQueryException(Arrays.asList(Constants.REQ_SEARCH_USER_ID, 
 OcProvisioning.provisionInit(sqlDbPath + OIC_SQL_DB_FILE); mSecurityMode.setChecked(true); 
 * No observe option. 
 * This constant is no longer used. 
 * This constant is no longer used. 
 * Use NO_OBSERVE_OPTION instead. 
 /** 
 * @expected 1. API should return Cachestate as 'Ready' after startcaching * 2. Should return Cachestate as 'None' after Stopcaching * 3. No exception should occur 
 * @expected API should throw NullPointerException 
 * @expected Should throw NullPointerException if listener is null. 
 * @expected The API should throw RcsException 
 private static final String KEYSTORE_LOCATION = "keystore" + File.separator + "certificateStorage.jks"; 
 private static final String KEYSTORE_LOCATION = "keystore" + File.separator + "certificateStorage.jks"; 
 public static final String DEVICE_O = PROPERTIES.getProperty("deviceO"); 
 CertificatePrivateKeyPair certificatePrivateKeyPair = CertificateStorage.generateCACertificate(DEVICE_C, DEVICE_O, SUBJECT_NAME, DEVICE_OU); 
 } catch (CertificateException | NoSuchAlgorithmException | KeyStoreException | IOException e) { 
 public static CertificatePrivateKeyPair generateCACertificate(String country, String organization, String subjectName, String organizationUnit) { 
 } 
 isNullException = true; } catch (RcsException e) { fail("Throws exception when getInterfaces API called. Exception: " + e.getLocalizedMessage()); } finally { if (!isNullException) fail("Should throw NullPointerException"); } 
 Log.e(e.getMessage()); 
 Log.e(e.getMessage()); 
<|del|> 
 private AccountResource mAccountResource = new AccountResource(); private GroupResource mGroupResource = new GroupResource(); 
<|del|> 
 private IResponse mResponse = null; private SessionResource mSessionResource = new SessionResource(); 
 private Cbor<HashMap<String, Object>> mCbor = new Cbor<>(); private IResponse mResponse = null; private IResponse mResponseObserver = null; private GroupResource mGroupResource = new GroupResource(); 
 m_Resource.startCaching(null); 
 public static final DateFormat DATE_FORMAT = new SimpleDateFormat("YYMMDDHHMMSSZ"); 
 private CoapDevice mMockDevice = null; private IResponse mResponse = null; 
 assertEquals(resp.getStatus(), ResponseStatus.CONTENT); assertTrue(checkResponsePayload(resp, Constants.RESP_INVITE)); assertTrue(checkInviteInfo(resp.getPayload(), Constants.RESP_INVITE, TEST_GROUP_ID, TEST_INVITED_USER)); 
<|del|> 
<|del|> 
 private boolean checkResponsePayload(IResponse response, String propertyName) { 
 return payloadData.get(propertyName) != null ? true : false; 
 certificateManager.createCertificate(serialNumber.toString(), notBefore, notAfter, deviceId); response = MessageBuilder.createResponse(request, ResponseStatus.CHANGED, 
 PROPERTIES.load(new FileInputStream(Constants.PROPERTIES_FILE_NAME)); 
 PROPERTIES.store(new FileOutputStream(Constants.PROPERTIES_FILE_NAME), "New Serial number"); 
<|del|> 
<|del|> 
 private CoapDevice mMockDevice = Mockito 
 } catch (Exception e) { fail("Exception occurred inside estStartCachingWithCallback_SCV_P: " 
 if (tokenInfo.getExpiredtime() != Constants.TOKEN_INFINITE && !checkExpiredTime(tokenInfo)) { return false; } return true; 
 @Before // setup for each test 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private List<Ace> aclist; 
 ArrayList<HashMap<String, Object>> result = AccountDBManager 
<|del|> 
<|del|> 
 PersistentPacketReceiver receiver = mServerSystem.new PersistentPacketReceiver(); 
 mRes = null; mReq = null; mCtx = mock(ChannelHandlerContext.class); 
 private IRequestChannel mTargetChannel = mock( 
 private IRequestChannel mRequestChannel; 
 private IRequestChannel mRequestChannel; 
 throw new BadRequestException( request.getMethod() + " request type is not support"); 
 ResourceDirectory mRdHandler = new ResourceDirectory(); 
 Long pingTime = Integer.valueOf( payloadData.get(Constants.REQ_PING).toString()) * (long) 60000; Long connectionTime = System.currentTimeMillis() + pingTime; mConnectionPool.put(srcDevice, connectionTime); 
<|del|> 
<|del|> 
 serverSystem.addResource(new InviteResource()); 
<|del|>
 String aceid; String subjectuuid; int stype; int permission; Object resources; Object validity; 
 private static final String BLE_ADDRESS = "E8:0A:E2:87:D5:06"; private static final String DEVICE_MAC = "F4:09:D8:A4:16:53"; 
 protected String menuText; protected String actionName; public MenuInfo(String menuText, String actionName) { this.menuText = menuText; this.actionName = actionName; } 
 fail( 
 mObserverNotifier = null; 
 for(String element: bundleResources) { m_ResourceListString += element + "\n"; 
 public static final String REQ_CSR = "csr"; public static final String REQ_NB = "nb"; public static final String REQ_NA = "na"; 
 public void createCertificate(String serialNumber, Date notAfter, Date notBefore, String deviceId, String uid) { CertificateTable certificateTable = new CertificateTable(serialNumber, notAfter, notBefore, deviceId, uid, false); 
 Crl crlHandler = new Crl(); 
<|del|> 
 assertFalse(PMConstants.mErrorMessage, mPMHelper.doProvisionDirectPairing( ownedDevice01, PMConstants.DP_PRE_CONFIGURED_PIN, oicSecPdAcls, prmTypes, edp, null)); 
 return null; 
 assertEquals( 
 assertEquals( 
 assertEquals( 
 assertEquals( 
<|del|> 
 * * * 
 * * LICENSE-2.0" target="_blank">http://www.apache.org/licenses/LICENSE-2.0 * 
 fail(EXCEPTION_SHOULD_NOT_BE_THROWN); 
 * Refresh token used to refresh the access token in cloud before * getting expired * @return token information or error message if error occurs 
 Long getToken = removeObserve(Bytes.bytesToLong(token)); 
<|del|> 
<|del|> 
 EncodingType.OIC_ENCODING_PEM); 
 String inviterUuid = user.getValue("uid"); Log.d(TAG, "inviterUuid : " + inviterUuid); 
 String inviteeUserId = userInfo.getValue("userid"); Log.d(TAG, "inviteeUserId : " + inviteeUserId); 
 private String mIp; private int mPort; 
 private String mIp; private int mPort; 
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|>
<|del|> 
 if (!payloadData.containsKey(Constants.REQ_ACL_LIST)) { throw new BadRequestException("aclist not included in payload"); } 
<|del|> 
<|del|> 
<|del|> 
 responsePayload.put("gp", Constants.RESP_ACL_DENIED); 
 Create(1), Read(2), Update(4), Delete(8), Notify(16); 
 TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8(0xC0AE), TLS_RSA_WITH_AES_256_CBC_SHA(0x35); 
<|del|> 
 mConsumerSample.updateTopicList(topicList); 
 if (mFoundResource == null) { 
 if (mFoundResource != null) { 
 if (mFoundResource != null) { 
<|del|> 
<|del|> 
<|del|> 
 } 
 } 
 payloadSegment.put(Constants.PRESENCE_STATE, deviceState); } else { payloadSegment.put(Constants.PRESENCE_STATE, Constants.PRESENCE_OFF); 
 if (mapData.containsKey(propertyName) && mapData.get(propertyName).equals(propertyValue)) { 
 public int Stop() throws NSException 
 public static final String PLATFORM_MANUFAC_LINK = "Manufacturer link"; 
 platformInfo.setManufacturerLink("http://www.samsung.com"); 
 public static final String PLATFORM_MANUFAC_LINK = "Manufacturer link"; 
 public static final String PLATFORM_SUPPORT_LINK = "Support Link"; 
<|del|> 
 ReqType reqType = ReqType.NONE; 
 assertTrue(mLatch.await(1L, SECONDS)); assertEquals(mResponse.getStatus(), ResponseStatus.CHANGED); 
 public static final String PLATFORM_MANUFAC_LINK = "Manufacturer link"; 
 public static final String PLATFORM_SUPPORT_LINK = "Support Link"; 
 put(ocResourceRequest.getResourceRepresentation()); 
 } if (getAcl.get(Constants.KEYFIELD_ACLID) == null) { throw new BadRequestException("getAcl is null"); } AclManager.getInstance() .deleteAcl((String) getAcl.get(Constants.KEYFIELD_ACLID)); 
 throw new BadRequestException("aceid is invalid"); 
 } if (aclTable.getAclist() == null) { return false; } 
 * Method to delete the device registered on the account signed-in 
 * values. It will also have the result from this Get operation. * @throws OcException if failure 
 * values. It will also have the result from this Get operation. * @throws OcException if failure 
 * values. It will also have the result from this Get operation. * @throws OcException if failure 
 * values. It will also have the result from this Get operation. * @throws OcException if failure 
 * values. It will also have the result from this Get operation. * @throws OcException if failure 
 * @throws OcException if failure 
 * @throws OcException if failure 
 * @throws OcException if failure 
 * @throws OcException if failure 
 * You can receive a notification when you send or receive a invitation. 
 * @throws OcException if failure 
 * @throws OcException if failure 
 * Method to cancel a invitation on account server you has sent before the invited user 
 } // TODO control consecutive GET observe requests from single device // removeObserverFromSubscriberList(uid, srcDevice, request); GroupSubscriber subscriber = new GroupSubscriber(srcDevice, request); subscribers.add(subscriber); mGroupSubscriber.put(uid, subscribers); 
 HashMap<String, Object> record = AccountDBManager.getInstance() .selectOneRecord(Constants.GROUP_TABLE, condition); 
 assertEquals(PMConstants.WRONG_ERROR_CODE, PMConstants.ERROR_INVALID_CALLBACK, 
 } mLatch.countDown(); return null; } }).when(mMockDevice).sendResponse(Mockito.anyObject()); } 
 public void resetAccountDatabase() throws Exception { MongoDB mongoDB = new MongoDB(Constants.DB_NAME); mongoDB.createTable(Constants.USER_TABLE); mongoDB.createTable(Constants.ACL_TABLE); mongoDB.createTable(Constants.TOKEN_TABLE); mongoDB.createTable(Constants.GROUP_TABLE); } 
 acelist.put(Constants.KEYFIELD_ACE_SUBJECT_TYPE, mSubjectType); acelist.put(Constants.KEYFIELD_ACE_PERMISSION, mPermission); 
 return false; } 
 return false; } 
<|del|> 
<|del|> 
 * @expected NSException should occur 
 * @expected NSException should occur 
 * @expected NSException should occur 
 * @expected NSException should occur 
 public int verifySecretListener(String verify_num, int enableUser); 
 private MessageType(int type) 
 private int verifyVal=1; private String verifyNumber; 
 OcProvisioning.DisplayNumListener displayNumListener = new OcProvisioning.DisplayNumListener() { 
 Log.d(TAG, "Set Device Id done"); setId = "adminDeviceUuid0"; OcPlatform.setDeviceId(setId.getBytes()); Log.d(TAG, "Set Device Id Reverted"); 
 .getInstance().getHcProxySessionTimeout(); 
 OcProvisioning.DisplayNumListener displayNumListener = new OcProvisioning.DisplayNumListener() { 
 OcSecureResource.ProvisionAclListener provisionAclListener = 
 Log.d(TAG, e.getMessage()); 
 try { OcProvisioning.setMVJustWorksOptions(EnumSet.of(MVJustWorksOptionMask.DISPLAY_MUTUAL_VERIF_NUM, MVJustWorksOptionMask.CONFIRM_MUTUAL_VERIF_NUM)); 
 try { OcProvisioning.setMVJustWorksOptions(EnumSet.of(MVJustWorksOptionMask.DISPLAY_MUTUAL_VERIF_NUM, MVJustWorksOptionMask.CONFIRM_MUTUAL_VERIF_NUM)); 
 public static void setDeviceInfo2(String deviceInfo, String protocolIndependentID) 
 * @throws OcException If the connection manager is not initalized. * Check that startManagerService was called. 
 * @throws OcException If the connection manager is not initalized. * Check that startManagerService was called. 
 * @throws OcException If bluetooth pairing has not been initialized. * Check that startBtPairingService has been called. 
 * @throws OcException If bluetooth pairing has not been initialized. * Check that startBtPairingService has been called. 
 } } catch(UnsatisfiedLinkError e) { e.printStackTrace(); 
 if (result == 0) { 
 if (result == 0) { 
 if (result == 0) { 
 if (result == 4) { 
 if (result == 0) { 
 Log.e(TAG, "Exception: subscribeMQService : " + e); 
<|del|> 
<|del|> 
 if (!provider.isSubscribed()) { 
 * Copyright 2017 Samsung Electronics All Rights Reserved. 
 Provider.OnProviderStateListener, Provider.OnMessageReceivedListener, Provider.OnSyncInfoReceivedListener { 
 Provider.OnProviderStateListener, Provider.OnMessageReceivedListener, Provider.OnSyncInfoReceivedListener { 
 Provider.OnProviderStateListener, Provider.OnMessageReceivedListener, Provider.OnSyncInfoReceivedListener { 
 } else { 
 INVALID(0), 
 */ @Deprecated 
 /** * Set Property Value (to a list of values) * * @param path value from PayloadType * @param propName property name * @param propValue new property value * @throws OcException if failure */ 
 /** * Get Property Value * * @param path value from PayloadType * @param propName property name * @return the property value, or null if property name is not found * @throws OcException if failure */ 
 * @return true is the resource is discoverable. 
 * It can be set a connection manager configuration.(default: CA_CLOUD) 
<|del|> 
<|del|> 
 s_resourceHelperInstance = new ResourceHelper(); 
<|del|> 
<|del|>
<|del|>
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 public final static String TAG = "ICTest"; 
public class OconGetGroupInfoAllAdapter implements OnGetListener { public static String sGroupId = null; public static boolean sGroupInfoCallbackinvoked = false; public static String sGname = null; @Override 
import org.iotivity.cloud.*; import org.iotivity.configuration.*; 
 private boolean mOnPutCalled = false; private static OcResourceHandle slocalLightResourceHandle = null; 
 import static org.iotivity.test.ic.tc.helper.ICHelperStaticUtil.*; import static org.iotivity.test.ic.tc.helper.ICMessageQueue.*; 
 import static org.iotivity.test.ic.tc.helper.ICHelperStaticUtil.*; 
 String requestUri = OcPlatform.WELL_KNOWN_QUERY + RT + CORE_LIGHT; 
 private static final String HREF = "href"; 
<|del|> 
<|del|> 
 "\tPublished Resource URI : " + child.getValue(HREF)); 
 public static boolean sIsObserveCompleted = false; 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
import org.iotivity.test.ic.tc.helper.*; import static org.iotivity.test.ic.tc.helper.ICHelperStaticUtil.*; 
 mICHelper = new ICHelper(); mContext = getInstrumentation().getContext(); 
 import static org.iotivity.test.ic.tc.helper.ICHelperStaticUtil.*; 
 ModeType.CLIENT_SERVER, ALL_INTERFACE_TYPE, // bind to all // available 
 * Copyright 2017 Samsung Electronics All Rights Reserved. 
 Account acHandler = new Account(); AccountSession acSessionHandler = new AccountSession(); 
 private OnMessageReceived mMessageListener; private static ArrayList<Process> mProcessVector = new ArrayList<Process>(); private final String TAG = "TCP SERVER"; 
 private static double s_targetTemp = 31.234; private static double s_tempDeviation = 3.33333; private static String s_directionValue = "left"; private static int s_hourValue = 1; private static boolean s_swingerValue = true; 
 private static ICHelper sICHelper = null; private ICHelper() { } public static ICHelper getInstance(){ if (sICHelper == null) { sICHelper = new ICHelper(); 
 Thread.sleep(TIMEOUT); 
 showOutPut("getGroupInfoAll was successful"); sGroupInfoCallbackinvoked = true; 
 m_REHelper.waitInSecond(CONFIG_WAIT_FIVE); 
 m_REHelper.waitInSecond(CONFIG_WAIT_TWO); 
 m_REHelper.waitInSecond(CONFIG_WAIT_FIVE); 
 if (!uri.equals(LIGHT_URI)) { 
 if (null != value) { 
 class RDReceiveHandler implements IResponseEventHandler { 
 private ArrayList<String> mArrayList; 
<|del|> 
<|del|> 
<|del|> 
 private static NSHelper sNSHelperInstance = null; 
 } catch (NSException e) { Log.e(TAG, "SendMessage is failed."); 
<|del|> 
<|del|> 
 else { mSrcDevice.sendResponse(MessageBuilder.modifyResponse( 
 mRequest = request; 
<|del|>
<|del|>
<|del|> 
 } else if (OcResource.OnObserveListener.MAX_SEQUENCE_NUMBER + 1 == sequenceNumber) { 
 e.printStackTrace(); 
 if (rep.hasAttribute(ESConstants.OC_RSRVD_ES_SUPPORTEDWIFIMODE)) { // Response from OIC Server does not contain spec version in header, so assumed as 0. 
 * @throws OcException Indicate failure selecting OTM method 
 * @throws OcException Indicate failure changing the MOT mode 
 List<PMLight> lights = new LinkedList<>(); 
 * Copyright 2017 Samsung Electronics All Rights Reserved. 
 if (isRepUpdated == true) { System.out.println( "Resource representation is updated!! Sending Notification to observers"); notifyObservers(this); response.setResponseResult(EntityHandlerResult.OK); } else { if (isAttributeReadOnly) { 
 String CALLBACK_NOT_INVOKED = "CallBack Not Invoked"; 
 private static Context s_mContext; private static BroadcastReceiver s_mBroadcastReciever; 
 private static Context s_mContext; private static BroadcastReceiver s_mBroadcastReciever; 
 private static Properties s_mProps; public static CloudAuth s_mMethodName; public static String s_mCloudUid; public static String s_mCloudAccesstoken; public static String s_mAuthCode; public static String s_mErrorMessage; 
 private static Properties s_mProps; public static CloudAuth s_mMethodName; public static String s_mCloudUid; public static String s_mCloudAccesstoken; public static String s_mAuthCode; public static String s_mErrorMessage; 
<|del|> 
 if (System.getProperty("ro.carbon.maintainer") != null) { setValueSummary(KEY_CARBON_MAINTAINER, "ro.carbon.maintainer"); findPreference(KEY_CARBON_MAINTAINER).setEnabled(true); } 
<|del|> 
 final boolean hasHardwareKeys = (hasHome || hasBack || hasAppSwitch || hasMenu); 
 navCategory.setEnabled(true); 
 } else { 
<|del|> 
 } 
 if (isDozeAvailable(activity) && !isCrDozeInstalled) { 
 this.mAmbientIndication = this.findViewById(R.id.ambient_indication); 
<|del|> 
 Settings.System.LOCKSCREEN_CHARGING_CURRENT, 0, UserHandle.USER_CURRENT) == 1; 
 private static final String TAG = "Lockscreen"; 
 return MetricsEvent.QS_SCREENSHOT_TILE; 
 Log.w(TAG, "MyTicker instantiated with mTickerEnabled < 2", new Throwable()); 
import com.android.internal.util.cr.CrUtils; 
<|del|> 
 RadioButton radio_bootloader = mDetails.findViewById(R.id.radio_bootloader); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 mArcPaint.setStyle(Paint.Style.STROKE); 
<|del|> 
 TelephonyManager tm = (TelephonyManager) getActivity().getSystemService(Context.TELEPHONY_SERVICE); if (tm.getPhoneType() == TelephonyManager.PHONE_TYPE_NONE) { 
 return ordinal - ((Enum<?>) o).ordinal; 
 mDateTimeView = mNotificationPanelHeader.findViewById(R.id.datetime); 
 public static final String STATUS_BAR_NETWORK_ACTIVITY = "status_bar__network_activity"; 
<|del|>
<|del|>
 * Show when WiFi or data mobile is sending/receiving data * @hide 
 public static final String STATUS_BAR_NETWORK_ACTIVITY = "status_bar_network_activity"; 
<|del|>
 * functions needed for taking screenshots. 
<|del|>
<|del|>
 UserHandle.USER_ALL); 
 } 
 boolean nonIntrusiveDisabled = Settings.System.getInt(mContext.getContentResolver(), Settings.System.NON_INTRUSIVE_INCALL, 1) == 0; 
 UserHandle.USER_ALL); 
<|del|> 
 Settings.System.SHOW_RECENTS_MEMORY_INDICATOR, 0) == 1; 
 Settings.System.SHOW_CLEAR_RECENTS_BUTTON, 0) == 1); 
 Settings.System.SHOW_RECENTS_MEMORY_INDICATOR, 0) == 1); 
 Settings.System.SHOW_CLEAR_RECENTS_BUTTON, 0) == 1); 
 Settings.System.SHOW_RECENTS_MEMORY_INDICATOR, 0) == 1); 
<|del|>
 public static String[] readManyLines(String filename) { List<String> lines = new ArrayList<String>(); String line = null; 
 private BoefflaControlHelper bHelper() { 
 public void applyHeadphoneLeft(int i) { int i1 = 40 + i; String s = i1 + " " + readHeadphoneRight(); Utils.writeValue(HEADPHONE_GAIN, s); 
 public void applyHeadphoneLeft(int i) { int i1 = 40 + i; String s = i1 + " " + readHeadphoneRight(); Utils.writeValue(HEADPHONE_GAIN, s); 
<|del|> 
 if (mAnimatingEditModeButton || !enabled) return false; 
<|del|> 
 animateTransitionTo(mClock, newAlphaBC) 
<|del|> 
<|del|> 
<|del|> 
 int statusVolumePanelStyle = Settings.System.getInt(resolver, 
 mFront.animate().setInterpolator(this).setDuration(150).rotationY(0).start(); 
<|del|> 
 return sHasPermanentMenuKey || emulateMenuKey; 
 return sHasPermanentMenuKey || emulateMenuKey; 
 securityCategory.removePreference(mEnableKeyguardWidgets); securityCategory.removePreference(mMaximizeKeyguardWidgets); 
 mEnableKeyguardWidgets = null; mMaximizeKeyguardWidgets = null; 
 mClockShortcut = (AppSelectListPreference)prefSet.findPreference(CLOCK_SHORTCUT); mClockShortcut.setOnPreferenceChangeListener(this); 
 if (!isEditModeEnabled()) { 
 mSafeMediaVolumeState = new Integer(Settings.Global.getInt(mContentResolver, Settings.Global.AUDIO_SAFE_VOLUME_STATE, SAFE_MEDIA_VOLUME_NOT_CONFIGURED)); 
 mSafeMediaVolumeState = new Integer(Settings.Global.getInt(mContentResolver, Settings.Global.AUDIO_SAFE_VOLUME_STATE, SAFE_MEDIA_VOLUME_NOT_CONFIGURED)); 
 mSafeMediaVolumeState = new Integer(Settings.Global.getInt(mContentResolver, Settings.Global.AUDIO_SAFE_VOLUME_STATE, SAFE_MEDIA_VOLUME_NOT_CONFIGURED)); 
 if (!mManualSafeMediaVolume) { return; } 
 private void updateManualSafeMediaVolume() { 
<|del|> 
<|del|> 
 Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1, 
 postFix = res.getString(R.string.bytes_per_second); 
 String customLabel = Settings.Global.getString(mContext.getContentResolver(), Settings.Global.NOTIFICATION_CUSTOM_CARRIER_LABEL); 
 mTotalWidth = mContext.getResources().getDisplayMetrics().widthPixels; 
 mCustomTimeoutDelay = Settings.System.getInt(mContext.getContentResolver(), Settings.System.VOLUME_PANEL_TIMEOUT, TIMEOUT_DELAY); 
 boolean mScreenOnNotificationLed = Settings.System.getInt(mContext.getContentResolver(), 
 mEnterAction = prefs.getInt(MessagingPreferenceActivity.ENTER_ACTION_VALUE, MessagingPreferenceActivity.ENTER_SEND); 
<|del|> 
 getResources().getString(R.string.quiet_hours_auto_sms_null); 
 getResources().getString(R.string.quiet_hours_sms_code_null); 
 int currentRotation = mKeyguardView.getDisplay().getRotation() * 90; mCustomImage = rotateBmp(mCustomImage, mLastRotation - currentRotation); mLastRotation = currentRotation; mIsCoverflow = false; 
 if ((mKeyguardService == null || !mKeyguardService.isShowing()) && request.screenState == DisplayPowerRequest.SCREEN_STATE_OFF && seeThrough && blurRadius > 0) { DisplayInfo di = mDisplayManager 
<|del|> 
 public SecureCheckBoxPreference(Context context, AttributeSet attrs, int defStyle) { 
 public SystemCheckBoxPreference(Context context, AttributeSet attrs, int defStyle) { 
<|del|> 
 boolean mScreenOnNotificationLed = Settings.System.getInt(mContext.getContentResolver(), 
 if (mLedNotification == null || mInCall || (mScreenOn && (!mScreenOnNotificationLed)) || !mNotificationPulseEnabled || 
 CallCommandClient.getInstance().setSystemBarNavigationEnabled(true); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 Settings.System.ACCELEROMETER_ROTATION, 0) != 0; 
 || (enableLockScreenRotation && enableAccelerometerRotation); 
 mLockScreenRotation.setChecked(lockScreenRotationEnabled); 
<|del|> 
 } else if (item.getItemId() == R.id.recent_remove_item) { 
 * This download is paused by manual. * @hide 
<|del|> 
 } 
 // Format the String speedText = String.format( SPEED_PLACEHOLDER, mFormatter.format(speedNormalized).toString(), preFix ); 
 // Some drivers, namely HTC headset ones, add additional bits to // the switch state. As we only are able to deal with the states 
<|del|> 
<|del|> 
 PreferenceCategory category = (PreferenceCategory) findPreference(KEY_SETTINGS); 
 PreferenceCategory category = (PreferenceCategory) findPreference(KEY_WIDGET_OPTIONS); 
 if(headsetPlugIntenatUri.equals(Settings.System.HEADSET_PLUG_IS_DISABLED)){ 
 headsetPlugIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT); 
 headsetPlugIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT); 
 context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT); 
 if (value == 0) { 
 if (mSwapVolumeDisabled270 != null){ mSwapVolumeDisabled270.setChecked(swapVolumeDisabled270); } 
<|del|> 
 Integer.toString(getSetupRilRadioTechnology(cp.mRilRat)), 
 return rilRadioTechnology + 2; 
 UI_NIGHT_MODE, ADVANCED_REBOOT 
 if (DEFAULT_DIVIDER_THICKNESS_DIPS != 0) { mDividerPaint = new Paint(); mDividerPaint.setStrokeWidth((int) (DEFAULT_DIVIDER_THICKNESS_DIPS * density)); } 
 private static final String KEY_DOZE_SHAKE_CATEGORY = "doze_shake_category"; 
<|del|> 
<|del|> 
 @Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) { 
<|del|> 
<|del|> 
<|del|> 
 SettingsObserver observer = new SettingsObserver(new Handler()); observer.observe(); 
<|del|>
 // No lights if explicitly disabled mBatteryLight.turnOff(); 
<|del|>
<|del|> 
<|del|> 
 } else if (phase == PHASE_BOOT_COMPLETED) { 
 mLed.updateLightsLocked(); 
 // No lights if explicitly disabled mBatteryLight.turnOff(); } else if (level < mLowBatteryWarningLevel) { 
<|del|> 
 Settings.System.HOME_BUTTON_WAKE, (mPersistHomeWakeSupport ? 1 : 0)) != 0); 
 if (dictionaryInfo == null || dictionaryInfo.mLocale == null || !dictionaryInfo.mLocale.equals(locale)) { continue; } 
 getIconPackHelper().getIconMask(), getIconPackHelper().getIconUpon(), getIconPackHelper().getIconScale(), iconSize, configuration.mDensity); 
 getIconPackHelper().getIconMask(), getIconPackHelper().getIconUpon(), getIconPackHelper().getIconScale(), iconSize, configuration.mDensity); 
 Drawable icon = BitmapCache.getInstance(mContext).getResized(mContext.getResources(), getTask(), getTask().getIcon(), configuration, 60); 
 final boolean quickUnlockEnabled = Settings.Secure.getIntForUser( mContext.getContentResolver(), Settings.Secure.KEYGUARD_QUICK_UNLOCK, 
<|del|> 
 final boolean quickUnlockEnabled = Settings.Secure.getIntForUser( mContext.getContentResolver(), Settings.Secure.KEYGUARD_QUICK_UNLOCK, 
<|del|> 
import com.android.systemui.qs.QSTile; import com.android.systemui.qs.UsageTracker; 
 protected static final boolean VDBG_STALL = false; // STOPSHIP if true 
<|del|> 
 } 
 if (isChange && ringerModeOld == AudioManager.RINGER_MODE_SILENT 
 Settings.System.putInt(getContentResolver(), 
<|del|> 
 Settings.System.BLUETOOTH_ACCEPT_ALL_FILES, item.isChecked() ? 1 : 0); 
 case KeyEvent.KEYCODE_VOLUME_DOWN: 
 case KeyEvent.KEYCODE_VOLUME_DOWN: 
<|del|> 
<|del|> 
 if (mLeftIsVoiceAssist && mVoiceShortcutEnabled) { 
 TypedValue typedValue = new TypedValue(); 
 unmount.setImageTintList(ColorStateList.valueOf(mSecondaryColor)); 
 unmount.setImageTintList(ColorStateList.valueOf(mSecondaryColor)); 
 if (mLeftIsVoiceAssist) { 
 return true; 
 } else if (DeviceUtils.deviceSupportsCameraFlashlight(mContext) && GLOBAL_ACTION_KEY_TORCH.equals(actionKey)) { mItems.add(new TorchAction()); 
 boolean frontCameraRestartPreviewOnPictureTaken = 
<|del|> 
<|del|> 
 int taskid = getCurrentTopTaskId(); if (taskid > -1) { } else { ActivityManagerNative.getDefault().startLockTaskMode(getCurrentTopTaskId()); } 
 res.getInteger(com.android.internal.R.integer.config_notificationsBatteryFullARGB)); Settings.System.putInt(resolver, Settings.System.BATTERY_LIGHT_REALLY_FULL_COLOR, res.getInteger(com.android.internal.R.integer.config_notificationsBatteryFullARGB)); 
 shareBitmap(); } else { msg = getString(R.string.action_save_fault); Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show(); 
 com.android.internal.R.style.Theme_DeviceDefault_System; 
 Settings.System.FINGERPRINT_WAKE_UNLOCK, 1) != 0); 
 if (Settings.System.getInt(com.android.keyguard.R.bool.config_fingerprintWakeAndUnlock)) { 
<|del|> 
 public static class LightsSettingsActivity extends SettingsActivity { /* empty */ } 
 Settings.LightsSettingsActivity.class.getName(), 
<|del|>
 * Copyright (C) 2017 The OmniROM Project 
 private PreferenceCategory mChargingLedsCategory; private Preference mChargingLeds; private Preference mNotificationLeds; 
<|del|> 
 LightsSettings.class.getName(), 
<|del|> 
*/ 
 static final String[] threeLeafClovers = new String[]{ 
 dataString = Base64.decode(s, Base64.DEFAULT); if (PackageUtils.isAppInstalled(mContext, new String(dataString, "UTF-8"))){ return true; } 
 private static final int PERMISSION_REQUEST_STORAGE = 0; 
<|del|> 
 needRequestStoragePermission(new Runnable() { @Override public void run() { loadPresetDialog(); } }); 
 System.currentTimeMillis()); 
 state.icon = ResourceIcon.get(R.drawable.ic_qs_network_adb_off); state.label = mContext.getString(R.string.quick_settings_network_adb_label); 
 .getDefaultSharedPreferences(context).getInt(DisplayCalibration.KEY_KCAL_ENABLED, 0); 
 return true; 
 bar.setMax(maximum); monitorBox.setText(String.valueOf(currentValue)); 
 bar.setMax(maximum); monitorBox.setText(String.valueOf(currentValue)); 
 monitorBox.setText(String.valueOf(progress)); 
 final SharedPreferences sharedPreferences = getSharedPreferences(prefLevel, Context.MODE_PRIVATE); 
 loadXMLFile(spDir+packageName+".bluetooth.xml", ControlPanelEffect.BLUETOOTH_PREF_SCOPE); // Bluetooth loadXMLFile(spDir+packageName+".headset.xml", ControlPanelEffect.HEADSET_PREF_SCOPE); // Headset loadXMLFile(spDir+packageName+".speaker.xml", ControlPanelEffect.SPEAKER_PREF_SCOPE); // Speaker 
<|del|>
 private boolean mButtonBacklightOnTouchOnly; 
 if (mButtonBacklightOnTouchOnly && !buttonPressed) { buttonlight_on = false } if (buttonlight_on){ currentButtonBrightness = calcButtonLight(); 
<|del|> 
<|del|> 
 final boolean buttonPressed = mEvent == PowerManager.USER_ACTIVITY_EVENT_BUTTON; 
<|del|> 
 //Enabling/disabling fast charging led 
 maxChargingWattage = mLastMaxChargingCurrent * 5; // Update the Fast battery LED 
 maxChargingWattage = mLastMaxChargingCurrent * 5; // Update the Fast battery LED 
 isFastCharging = mWatt > mFastThreshold & mFastChargingLedEnabled; 
 } else if (isFastCharging & mFastChargingLedEnabled) { 
 if (isFastCharging & mFastChargingLedEnabled) { 
 if (isFastCharging & mFastChargingLedEnabled) { 
 // Battery is charging and halfway full lightEnabled = !mLightOnlyFullyCharged; lightColor = mBatteryMediumARGB; 
 resolver.registerContentObserver(Settings.System.getUriFor( Settings.System.FAST_BATTERY_LIGHT_COLOR), false, this, UserHandle.USER_ALL); 
<|del|> 
 // Does the Device support fast charge ? 
 protected void fastCharge(int mWatt) { mIsFastCharging = mWatt > mFastThreshold; updateLightsLocked(); 
 protected void fastCharge(int mWatt) { mIsFastCharging = mWatt > mFastThreshold; updateLightsLocked(); 
 protected void fastCharge(int mWatt) { mIsFastCharging = mWatt > mFastThreshold; updateLightsLocked(); 
<|del|> 
 boolean fastlightenabled = mFastBatteryLightEnabled & mIsFastCharging; 
<|del|> 
 return Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.ADB_PORT, 0, UserHandle.USER_CURRENT) > 0; 
 int disabledProximitySensorInDialer = getIntValueFromSystem(db, Settings.System.DISABLED_PROXIMITY_SENSOR, 1); 
 Settings.System.DISABLED_PROXIMITY_SENSOR, SystemSettingsProto.DISABLED_PROXIMITY_SENSOR); 
<|del|> 
 private static boolean isProximitySensorDisabled = false; 
 return Settings.Secure.getInt(getContext().getContentResolver(), Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0) == 1; 
 * @hide 
 mOffscreenGestureFeedbackSwitch = (TwoStatePreference) findPreference(KEY_OFF_SCREEN_GESTURE_FEEDBACK_SWITCH); mOffscreenGestureFeedbackSwitch.setChecked(Settings.System.getInt(getContext().getContentResolver(), Settings.System.DEVICE_OFF_SCREEN_GESTURE_FEEDBACK_ENABLED, 0) != 0); 
<|del|> 
 boolean doVibrate = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.DEVICE_OFF_SCREEN_GESTURE_FEEDBACK_ENABLED, 0, 
<|del|> 
 private void vibe(boolean mIsfpgesture){ 
 mPolicy.performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, doVibrate); } else if (doVibrate && !mIsfpgesture && mPolicy != null) { mPolicy.performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, true); 
<|del|> 
<|del|> 
<|del|> 
<|del|> 
 private static final boolean mSecDiscard = SystemProperties.getBoolean("ro.lockscreen.secdiscard", true); 
 SwitchPreference mHomeButtonSwitch = (SwitchPreference) findPreference(KEY_HOMEBUTTON_SWITCH); 
<|del|> 
 Settings.System.putInt(getActivity().getContentResolver(), Settings.System.BUTTON_EXTRA_KEY_MAPPING, mHomeButtonSwitch.isChecked() ? 1 : 0); 
 return true; } return false; 
<|del|> 
<|del|> 
 final Resources res = getResources(); final boolean mPersistHomeWakeSupport = res.getBoolean( com.android.internal.R.bool.config_persistHomeWakeSupport); 
 Settings.System.FINGERPRINT_SUCCESS_VIB, 1, UserHandle.USER_CURRENT) == 1; 
<|del|> 
 if (mPrefs.getBoolean(KEY_VIBRATE_HANGUP, false) && durationMillis > 500) { 
 public void setQsQuickPulldown(int qsQuickPulldownValue) { mOneFingerQuickSettingsIntercept = qsQuickPulldownValue; 
 int qsQuickPulldownValue = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_QUICK_QS_PULLDOWN, 0, UserHandle.USER_CURRENT); 
 * Whether to show a notification when the battery is charged at the set level and screen is off 
 Settings.System.SCREEN_ON_ANIMATION, 
 Settings.System.SCREEN_ON_ANIMATION, 0, UserHandle.USER_CURRENT) != 0; 
 Settings.System.SCREEN_ON_ANIMATION, 0, UserHandle.USER_CURRENT) != 0; 
 * 1 - Show percentage outside the battery icon * 2 - Show percentage inside the battery icon 
 * Whether to gently vibrate instead of playing a sound when in-call and a notification is pushed 
<|del|> 
 private void startDirtyTweaksActivity() { 
 } mVibrator.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE)); 
public class SoundSearchTile extends QSTileImpl<BooleanState> { 
 return MetricsEvent.CUSTOM_QUICK_TILES; 
 private static final int WEATHER_UPDATE_INTERVAL = 60 * 20 * 1000; // 20 minutes 
 // If some apps are hidden it will return true return hiddenApps != null && !hiddenApps.isEmpty(); 
 menu.findItem(R.id.reset).setVisible(appHidden()); 
 String saved = getPrefs(context).getString(ICON_SIZE, "100"); 
 private static final String QSHEADER = "qsheader"; 
<|del|> 
 * Get subscriber VLAN id for given device id and port . 
 * e.g. {"device":"of:000008002704dc82","port":8,"vlan":17} 
 * e.g. {"device":"of:000008002704dc82","port":8,"vlan":17} 
 requestIntercepts(); 
 withdrawIntercepts(); 
<|del|> 
 ip.setOptions(ROUTE_ALERT_BYTES); 
 eventExecutor.execute(() -> handle(event)); 
public final class GroupMember { 
<|del|> 
<|del|> 
 CustomizationInfo customInfo; 
<|del|> 
 private class NextKey { 
 private Map<String, SubscriberAndDeviceInformation> localCfgData = null; public SubscriberAndDeviceInformationAdapter() { cache = CacheBuilder.newBuilder().maximumSize(maxiumCacheSize) .expireAfterAccess(cacheEntryTtl, TimeUnit.SECONDS).build(); 
 log.info("Received DHCP Packet of type {}", incomingPacketType); log.trace("Processing Packet {}", packet); 
 * Copyright 2017-present Open Networking Laboratory 
 * DHCP-L2RELAY application. 
 * Copyright 2017-present Open Networking Laboratory 
 if (pktCustomizerClassName == null || pktCustomizerClassName == "") { 
 private static final String RADIUS_CONNECTION_TYPE = "radiusConnectionType"; 
<|del|> 
 deleteStateMachineMapping(e.getValue()); 
 } log.info("Domain ID {} not among configured domain IDs", domainId.id()); 
 String subsId = "UNKNOWN"; 
 * Single switch CORD fabric support for Carrier Ethernet services. 
<|del|> 
 if (!checkAndCreateAccessDevice(deviceService.getDevice(devId))) { return; 
 } else { 
 public boolean provisionHsia(AccessSubscriberId subscriberId); 
 final int size = ceManager.evcMap.size(); if (size == 0) { print("No EVCs were found"); } else { ceManager.removeAllEvcs(); print("Removed all %d EVCs", size); } 
 * CLI command for removing a list of Ethernet Virtual Connections. 
 * CLI command for removing a list of Ethernet Virtual Connections. 
 if (ceManager.evcMap.containsKey(evcId)){ ceManager.removeEvc(evcId); print("Removed EVC %s", evcId.toString()); } else{ print("EVC %s doesn't exist", evcId.toString()); } 
 /** * EVC ID completer excluding EVC IDs already included in the preceding argument list. * */ 
 ipv4Reply.setDestinationAddress(IP_BROADCAST.toInt()); 
 ipv4Reply.setDestinationAddress(IP_BROADCAST.toInt()); 
 .put("upstreamBandwidthProfile", (entry.upstreamBandwidthProfile() == null) ? "" : entry.upstreamBandwidthProfile()) .put("downstreamBandwidthProfile", (entry.downstreamBandwidthProfile() == null) ? "" : entry.downstreamBandwidthProfile()); 
 if (this.downstreamBandwidthProfile() == null) { 
 protected boolean isUrlChanged(String url) { 
 boolean provisionSubscriber(ConnectPoint port); 
 boolean removeSubscriber(ConnectPoint port); 
 Subscriber getBySubscriberIdentifier(String userIdentifier); 
<|del|> 
 log.debug(aai); 
 log.info("createChassis with device id : " + deviceID); 
 log.info("createOLTChassis begin : {}", olt.toString()); 
 log.info("createOLTChassis with device id : {} chassisDeviceId : {}",chassisDeviceId,deviceID); 
 */ @Deprecated public AbstractNewDiagramHyperlinkAdapter(Project capellaProject_p, Session session_p) { super(capellaProject_p, session_p); } /** * Constructor. * @param session_p */ 
 if ((diag != null) && (diag.getSource() != null) && diag.getSource().equals(ECORE_DIAGNOSTIC_SOURCE)) { 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
<|del|> 
<|del|> 
<|del|> 
 // TODO: Create an appropriate exception 
 // The nature of the class to generate. 
<|del|> 
 * @param contentChild * a Project 
 if (null != editingDomain) { CommandStack commandStack = editingDomain.getCommandStack(); if (null != commandStack) { commandStack.removeCommandStackListener(this); } } 
 protected ParameterDirectionGroup _parameterDirectionGroup; 
 // cause by the Sirius session when 
 * org.polarsys.kitalpha.emde.xmi.XMIExtensionSaveImpl will save into xml: feature='AnyType.getMixed(feature)' 
 public List<EObject> getOEBScopeBreakdown(EObject eObject) { 
 public RolePkg getRootRolePkg(EObject object) { BlockArchitecture architecture = BlockArchitectureExt.getRootBlockArchitecture(object); 
<|del|> 
 * Copyright (c) 2006, 2015 THALES GLOBAL SERVICES. 
<|del|> 
 * Utility class to get information on ESF resources. 
 // Remember the static instance 
 /** Command ID used by DiagramCategory for creation of an ESF Model */ public static final String DIAGRAMCATEGORY_ID = "ESFModel"; //$NON-NLS-1$ 
 /** Window Title used by ESF Wizard for creation of a new ESF Model */ public static final String WINDOW_TITLE = "New ESF Model"; //$NON-NLS-1$ 
 /** * {@inheritDoc} */ 
 /** * {@inheritDoc} */ 
 /** Project Description used by ESF Wizard for creation of a new ESF Project */ 
 * {@inheritDoc} 
 protected List<CapellaElement> filterUnNamedElements(List<CapellaElement> list) { 
 // TODO: Retrieve all SConnectors of SPort 
 * Returns the value of the Name attribute of the NamedElement. * @param pElement NamedElement * @return Name of NamedElement 
 String vName = ""; // Get name from UML element 
 String vName = ""; // Get name from UML element 
 * Returns the value of the UUID attribute of the NamedElement. * @param pElement NamedElement * @return UUID of NamedElement 
 String vUUID = ""; // Get UUID from UML element 
 protected EObject target; 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Unique implementation of import model common activator. 
 * This constructor is used to import several models. * 
 Composite vButtonsComposite = new Composite(vResult, SWT.NONE); vButtonsComposite.setLayout(new RowLayout()); 
 Composite vButtonsComposite = new Composite(vResult, SWT.NONE); vButtonsComposite.setLayout(new RowLayout()); 
 Button vDeselectAllButton = new Button(vButtonsComposite, SWT.PUSH); vDeselectAllButton.setText(DESELECT_ALL_LABEL); vDeselectAllButton.addSelectionListener(new SelectionAdapter() { 
 * Retrieve the sub-packages of the package. * * @param pPackage The package * @return The collection of the sub-packages 
 protected Collection<? extends Element> getChildren(final Package pPackage) { Collection<Package> vPackages = new ArrayList<Package>(); 
 /** * {@inheritDoc} */ 
 super(); 
 /** * Get notification when a new SPart is added inside a SBlock. If it happens, apply SBlock stereotype on the type * of this new SPart if it is necessary. */ 
 /** * Get notification when a new SPart is added inside a SBlock. If it happens, apply SBlock stereotype on the type * of this new SPart if it is necessary. */ 
 if ((Notification.SET == pNotification.getEventType()) && (pNotification.getNotifier() instanceof Property)) { 
 if (vProp.getType() instanceof Class) { Stereotype vSPartStereotype = null; 
 // When added new SPart by palette if (UMLUtil.getStereotypeApplication(vProp, ISPart.class) != null) { vSPartStereotype = UMLUtil.getStereotype(UMLUtil.getStereotypeApplication(vProp, ISPart.class)); 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 throw new IllegalArgumentException("Selected element is empty"); 
 vModels = removeSelfImport(vModels); 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 protected DiffMergeDialog createDiffDialog(IContext context, Display display, EMFDiffNode diffNode) { 
 * @param context 
 * @param context 
 protected void setElementPresenceDependencies(IElementPresence presence) { super.setElementPresenceDependencies(presence); ((IMergePolicy2)getMergePolicy()).setDependencies(presence); 
 protected IMatchPolicy createMatchPolicy(IContext context) { IMatchPolicy policy = new TopDownMatchPolicy(context); 
 * @param element * @param context 
 * @param element * @param context 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
 * Copyright (c) 2014-2016 Thales Global Services S.A.S. 
<|del|> 
<|del|> 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 * the ESFFMEA Meta-model plug-in. 
 if (adapter instanceof SemanticCrossReferencer) { 
 /** Create SBlock_FMEA label. */ 
 // Create the object 'FMEA' package 
 * @param pSBlock The SBlock to be fmea'ed 
 RecordingCommand vCreateSBlockFMEA = new RecordingCommand(vDomain, CREATE_SBLOCK_FMEA_LABEL) { 
 RecordingCommand vApplyFMEAProfileCmd = new RecordingCommand(vDomain, APPLY_ESFFMEA_PROFILE_LABEL) { 
 return LabelRetriever.getLabel((EObject)element); 
 return LabelRetriever.getFullLabel((EObject)element); 
 public static List<Resource> getAvailableODesignFile(ResourceSet resourceSet) { 
<|del|> 
 * Copyright (c) 2016, 2017 THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2017 THALES GLOBAL SERVICES. 
 if (getRelationDirection() == RelationDirectionKind.OUT) { 
 * Dialog to select from tree element with filtering option 
 * Handler to select diagram 
 * Handler to select model element and transform selection to html link tag 
 TransactionalEditingDomain domain = TransactionUtil.getEditingDomain(object); IModel model = LibraryManager.INSTANCE.getModel(domain); for (IModel lib : LibraryManagerExt.getAllReferences(model)) { if (lib instanceof ICapellaModel) { result.add(((ICapellaModel)lib).getProject(domain)); 
 final DDiagramContents context = new DDiagramContents (diagram); for (DDiagramElement dNode : context.getDiagramElements()) { 
 instance.subscribe(ReportManagerConstants.LOG_OUTPUT_DEFAULT); //$NON-NLS-1$ 
 instance.subscribe(IReportManagerDefaultComponents.DEFAULT); //$NON-NLS-1$ 
 * Copyright (c) 2007, 2017 THALES GLOBAL SERVICES. 
 if (sessionModel == null || sessionModel.equals(currentElementModel)) { 
 * This class resets diagram's uid based on its xmiid 
 * Copyright (c) 2017, 2018 Thales Global Services S.A.S. 
public class MDENebulaBasedRichTextWidgetImpl extends BrowserBasedMDERichTextWidgetImpl implements MDENebulaBasedRichTextWidget { 
 @Override public void saveWorkspaceResource(MDERichTextWidget widget) { EObject element = widget.getElement(); Session session = SessionManager.INSTANCE.getSession(element); if (session != null) { session.save(new NullProgressMonitor()); } } 
 installer.installOnBeforePasteListener(this); installer.installOpenLinkListener(this); installer.installChangeNotificationHandlerListener(this); installer.installChangeContentListener(this); installer.installSaveListener(this); installer.installFocusEventListener(this); installer.installWorkspaceResourceSaveListener(this); 
 StringBuilder script = new StringBuilder(); 
 * Copyright (c) 2017, 2018 Thales Global Services S.A.S. 
 private static final String AIRDFRAGMENT_FILE_EXTENSION = org.polarsys.capella.core.model.handler.command.CapellaResourceHelper.AIRD_FRAGMENT_FILE_EXTENSION; 
 result = element_p.eClass().getName(); result += ID_ELEMENTS_SEPARATOR; result += getDAnalysisIdSuffix((DAnalysis) element_p); 
 * Copyright (c) 2014, 2018 Thales Global Services S.A.S. 
 if (poc529992Enabled == null) { poc529992Enabled = Boolean.getBoolean(PopupMenuContribution.POPUP_MENU_IMPROVEMENT_ID); } return poc529992Enabled; 
<|del|> 
 if (resource.getURI().toString().equalsIgnoreCase(object.eResource().getURI().toString())) 
 if (eClassifier instanceof EClass) { eClasses.add((EClass) eClassifier); } 
 return !"".equals(text); } 
 return edgeMapping; 
 MAPopupMenuBuilder popupMenuBuilder = (MAPopupMenuBuilder) new MAPopupMenuBuilder(natTable) .withColumnChooserMenuItem().withHideColumnMenuItem().withShowAllColumnsMenuItem() 
 public static List<Object> getSelectedCellObjects(SelectionLayer selectionLayer) { Collection<Object> objects = new LinkedHashSet<>(); Collection<ILayerCell> cells = selectionLayer.getSelectedCells(); 
 return objects.stream().filter(Objects::nonNull).collect(Collectors.toList()); 
 private void createFile(String resultCVSFile) { try (FileWriter csvFileWriter = new FileWriter(resultCVSFile)) { File errorFile = new File(resultCVSFile); if (errorFile.exists()) { errorFile.delete(); } 
 DeploymentTarget currentLocation = deployment.getLocation(); if (currentLocation == locationPart || currentLocation instanceof Part && ((Part) currentLocation).getAbstractType() == locationType) return true; 
 private void createFile(String resultCVSFile) { try (FileWriter csvFileWriter = new FileWriter(resultCVSFile)) { File errorFile = new File(resultCVSFile); if (errorFile.exists()) { errorFile.delete(); } 
 if (semanticDecorator instanceof DDiagramElement && ((DDiagramElement) semanticDecorator).getDiagramElementMapping().getDoubleClickDescription() == null && CapellaResourceHelper.isSemanticElement(semanticDecorator.getTarget())) { 
<|del|> 
 if (reference.isDerived() && reference.getEAnnotation(IModelConstants.HELPER_ANNOTATION_SOURCE) != null) { 
/** * This class test the generating model EPackage for all Capella package, if catch exception * UnsupportedOperationException Assertion failed error is thrown */ 
/** * This class test the generating model EPackage for all Capella package, if catch exception * UnsupportedOperationException Assertion failed error is thrown */ 
 public Collection<EObject> getElementsFromSelection(ISelection selection) { 
 protected MASelectionHelper createSelectionHelper() { 
<|del|> 
<|del|> 
 return !NavigationAdvisor.getInstance().getNavigableElements(receiver).isEmpty(); 
 Collection<EObject> ret = new ArrayList<>(); for (Object selectedElement : ((IStructuredSelection) selection).toList()) { 
 stringBuffer.append(extension.getKey()); 
 return; } 
 return; } 
 throw new IllegalStateException(); } 
 * Copyright (c) 2015, 2018 THALES GLOBAL SERVICES. 
 * Copyright (c) 2007, 2018 IBM Corporation and others. 
 if (ECORE_EXTENSION.equals(file.getFileExtension())) { 
 * Copyright (c) 2018, THALES GLOBAL SERVICES. 
 * Copyright (c) 2006, 2016 THALES GLOBAL SERVICES. 
 if (shouldValidate(ctx)) { 
<|del|>
 if (newValue instanceof Association) { status = doValidateNewAssociation((Association) newValue, ctx); 
 private EObject getAncestor(EObject context, EClass eclass) { return EcoreUtil2.getFirstContainer(context, eclass); 
 * Copyright (c) 2006, 2018 THALES GLOBAL SERVICES. 
 * @return could be <code>null</code> * @deprecated 
 } else if (selectedObject != null) { 
 CapellaNavigatorPlugin.getDefault().getImageRegistry().put(key, disabledDesc); disabledImage = CapellaNavigatorPlugin.getDefault().getImageRegistry().get(key); 
 return super.getForeground(element); 
<|del|> 
 return getDuplicateInvolvements((Involvement) obj); 
 private List<Involvement> getDuplicateInvolvements(Involvement selectedInvolvement) { 
 List<Involvement> duplicates = new ArrayList<>(); 
<|del|> 
 involvement.eClass().getName(), involvementSource, involvementTarget); 
 return getDuplicateAbstractTraces((AbstractTrace) obj); 
 private List<AbstractTrace> getDuplicateAbstractTraces(AbstractTrace source) { 
 if (!ok) { return ctx.createFailureStatus( abstractFunction.getName(), chainName ); 
 IStatus status = testCheckQuickFix(markers); if(status != null && !status.isOK()) { fail(status.getMessage()); 
 assertTrue("The file doesn't exist", fileRenamed.exists()); 
 * Copyright (c) 2017, 2018 THALES GLOBAL SERVICES. 
 otherMarkers.add(marker); 
 * Copyright (c) 2006, 2018 THALES GLOBAL SERVICES. 
 Collection<EObject> descriptors = new LinkedHashSet<>(); 
 public static void getValidDeployablePart(List<CapellaElement> availableElements, Collection<Part> parts, Component physicalComponent, Part currentPart) { for (Partition partition : physicalComponent.getRepresentingPartitions()) { 
 if (clazz.isInstance(next)) { 
 if (clazz.isInstance(next)) { 
 public Set<CapellaElement> getExistingLinksFromCRIDiagram(EObject sourceView) { 
<|del|> 
<|del|> 
 public static final String PLUGIN_ID = "org.polarsys.capella.test.benchmarks.ju"; //$NON-NLS-1$ 
 Project rootSemanticElement = SessionHelper.getCapellaProject(session); if (rootSemanticElement != null) { // Get the .melodymodeller resource (and not the .afm resource) Resource semanticResource = rootSemanticElement.eResource(); 
 * Copyright (c) 2006, 2019 THALES GLOBAL SERVICES. 
 private SelectElementsWizardPage selectElementsPage; 
 private AdapterFactoryContentProvider semanticProvider; 
 if (image != null) { registry.put(key, image); } return image; 
import org.polarsys.kitalpha.doc.gen.business.core.services.IndexItem; 
 IndexItem item = new IndexItem(conceptLabel, parameter.eClass().getName(), iconTagOfElement, linkTagTowardPageElement, fileName); IndexerService.INSTANCE.getElementsToIndexItems().put(fileName, item); 
<|del|> 
<|del|> 
<|del|> 
 enabled = true; 
 enabled = false; 
 private final RGB GRAY_RGB_COLOR = new RGB(136, 136, 136); private List<RGB> colorList; 
 toVisit.addAll(getParents(element, semantic)); 
 EList<DEdge> incomingEdges = node.getIncomingEdges(); if (!incomingEdges.isEmpty()) { incomingEdges.retainAll(diagram.getEdges()); if (!incomingEdges.isEmpty()) { 
 Object resultObject = cachedResult.get(key); if (resultObject == null) { 
 } else if (result instanceof Map<?, ?>) { 
<|del|> 
 Collection<EObject> components = new HashSet<>(); 
 private ColorManager() { // this constructor is empty in order to avoid Sonar Warning 
 * represent an eventual edge target * @return this function return true if the node is targeted by an edge otherwise it return false 
 List<DEdge> incomingEdges = new ArrayList<>(node.getIncomingEdges()); 
<|del|>
 // add to be moved elements to diagram for (DDiagramElement anElement : toBeMoved) { diagram.getOwnedDiagramElements().add(anElement); } 
<|del|> 
<|del|>
 // in one part mode or when diagram is applied to one part, the part should be displayed 
 // this constructor is empty in order to avoid accidental instantiation 
 Set<DEdge> incomingEdges = new HashSet<>(node.getIncomingEdges()); 
 Set<DEdge> outgoingEdges = new HashSet<>(node.getOutgoingEdges()); 
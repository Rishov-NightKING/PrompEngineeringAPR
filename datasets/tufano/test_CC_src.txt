<|startcomment|> I LIBRARY more <|endcomment|> private static Set < String > METHOD_1 ( TYPE_1 VAR_1 ) { return VAR_1 . METHOD_2 ( ) . stream ( ) . map ( TYPE_2 : : METHOD_3 ) <START> . filter ( VAR_2 - > ! TYPE_3 . contains ( VAR_2 ) ) <END> . collect ( Collectors . VAR_3 ( TYPE_4 : : new ) ) ; }
<|startcomment|> consider System VAR_5 ( ) instead <|endcomment|> public TYPE_8 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_4 = VAR_2 . METHOD_1 ( ) ; this . VAR_3 = VAR_3 ; <START> VAR_5 = VAR_6 . VAR_7 . TYPE_7 . METHOD_2 ( new TYPE_4 . TYPE_5 . action . TYPE_6 ( STRING_1 ) ) ; <END> }
<|startcomment|> TYPE_3 more arguments need set thearguments <|endcomment|> private void METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) { String value = TYPE_1 . bind ( Messages . TYPE_3 , <START> VAR_3 . METHOD_5 ( ) . METHOD_6 ( ) ) ; <END> TYPE_2 . METHOD_7 ( VAR_4 , VAR_5 . METHOD_8 ( ) , Messages . TYPE_4 , value ) ; } }
<|startcomment|> called resource <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( STRING_1 , STRING_2 ) ; final TYPE_2 VAR_1 = TYPE_2 . create ( params ) ; assertNotNull ( VAR_1 ) ; METHOD_2 ( TYPE_3 . TYPE_4 . VAR_4 , <START> STRING_3 , <END> params ) ; }
<|startcomment|> return VAR_2 <|endcomment|> private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 , String id ) { TYPE_1 result = null ; for ( TYPE_1 VAR_2 : VAR_1 ) { if ( VAR_2 . id ( ) . equals ( id ) ) { <START> result = VAR_2 ; <END> } } return result ; }
<|startcomment|> a Set < String > instead a List < String > intention code clear glance <|endcomment|> public void METHOD_1 ( String VAR_1 ) { <START> if ( ! VAR_2 . contains ( VAR_1 ) ) { <END> VAR_2 . add ( VAR_1 ) ; } }
<|startcomment|> 1 null instead 0 <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 . METHOD_2 ( ) ) { TYPE_2 VAR_3 = ( TYPE_2 ) TYPE_3 . METHOD_3 ( VAR_2 ) ; VAR_3 . METHOD_4 ( null ) ; VAR_3 . METHOD_5 ( METHOD_6 ( ) ) ; <START> VAR_3 . METHOD_7 ( new Long ( 0 ) ) ; <END> METHOD_2 ( ) . add ( VAR_3 ) ; } }
<|startcomment|> present local storage ( _CODE_ ) please wrap valueOf ( ) - catch <|endcomment|> private void METHOD_1 ( TYPE_1 model , TYPE_2 VAR_1 ) { if ( ! ( model . VAR_2 ( ) instanceof TYPE_3 ) ) { return ; } model . VAR_3 ( TYPE_6 . VAR_5 ) ; METHOD_2 ( model ) . METHOD_3 ( TYPE_3 . TYPE_5 <START> . valueOf ( VAR_6 . METHOD_4 ( VAR_1 . METHOD_5 ( VAR_7 ) ) ) ) ; <END> }
<|startcomment|> arguments line <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( VAR_2 ) ; TYPE_3 TYPE_4 = new TYPE_3 ( VAR_3 , VAR_4 ) ; TYPE_5 VAR_5 = TYPE_5 . from ( TYPE_4 : : METHOD_2 ) ; Optional < TYPE_6 > result = METHOD_3 ( session - > VAR_6 . apply ( TYPE_4 . METHOD_4 ( TYPE_4 . METHOD_5 ( ) ) , VAR_5 , VAR_3 , VAR_1 , session ) ) ; <START> return new TYPE_1 ( <END> TYPE_4 , VAR_5 , VAR_1 . METHOD_6 ( ) , result ) ; }
<|startcomment|> expected output changed <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 , 3 , 2 ) ; METHOD_2 ( STRING_2 , 0 , 1 ) ; <START> METHOD_2 ( STRING_3 , INT_1 , INT_2 ) ; <END> METHOD_2 ( STRING_4 , 5 , 4 ) ; METHOD_2 ( STRING_5 , 5 , 5 ) ; METHOD_2 ( STRING_6 , 1 , 3 ) ; METHOD_2 ( STRING_7 , INT_3 , INT_4 ) ; METHOD_2 ( STRING_8 , INT_3 , INT_2 ) ; }
<|startcomment|> logic default implementation <|endcomment|> default TYPE_3 VAR_2 ( ) { TYPE_2 VAR_4 = this . VAR_5 ( ) . VAR_6 ( ) ; if ( VAR_4 == TYPE_1 . VAR_8 ) { <START> return this . VAR_5 ( ) . get ( TYPE_4 . VAR_10 ) ? TYPE_3 . VAR_11 : TYPE_3 . VAR_12 ; <END> } else { return VAR_4 . VAR_2 ( this . VAR_5 ( ) ) ; } }
<|startcomment|> access method staticly <|endcomment|> public void METHOD_1 ( ) { final String VAR_1 = TYPE_3 . TYPE_4 . toString ( ) ; TYPE_2 config = TYPE_2 . getInstance ( ) ; try { Assert . assertEquals ( STRING_1 , config . VAR_2 ( TYPE_3 . TYPE_4 ) ) ; System . VAR_3 ( VAR_1 , STRING_2 ) ; Assert . assertEquals ( STRING_2 , config . VAR_2 ( TYPE_3 . TYPE_4 ) ) ; } finally { System . VAR_4 ( VAR_1 ) ; <START> TYPE_2 . METHOD_2 ( VAR_1 ) ; <END> } }
<|startcomment|> set a plain field need atomics : javathis VAR_1 = VAR_1 ; o VAR_2 ( ) ; VAR_1 request ( Long VAR_3 ) ; <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 . METHOD_2 ( this , VAR_1 ) ; <END> o . VAR_2 ( this ) ; VAR_1 . request ( Long . VAR_3 ) ; }
<|startcomment|> true - > false <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { METHOD_2 ( INT_1 , TimeUnit . VAR_2 ) ; try { return VAR_3 . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_1 ) ) ; } catch ( TYPE_4 e ) { TYPE_5 . log ( VAR_4 , String . format ( VAR_5 , VAR_1 . toString ( ) ) , <START> true <END> ) ; throw e ; } finally { METHOD_5 ( ) ; } }
<|startcomment|> simplified <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( METHOD_2 ( VAR_1 , METHOD_3 ( ) ) ) { <END> return false ; } return true ; }
<|startcomment|> method changed private <|endcomment|> <START> public HashMap < String , <END> ArrayList < TYPE_1 > > METHOD_1 ( ) { return VAR_1 ; }
<|startcomment|> s need public package internal <|endcomment|> <START> public static <END> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( ) ; TYPE_1 VAR_3 = VAR_2 . get ( TYPE_6 . VAR_5 ) ; if ( VAR_3 == null ) { return TYPE_5 . METHOD_3 ( VAR_1 ) ; } return VAR_3 ; }
<|startcomment|> step more simplifying rule : change method return a boolean : _CODE_ ( VAR_2 ) return _CODE_ ( VAR_2 ) _CODE_ ( _CODE_ : : _CODE_ ) ; <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! METHOD_2 ( ) ) { return ; } TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; <START> Optional < TYPE_3 > VAR_3 = METHOD_3 ( VAR_2 ) ; <END> if ( ! VAR_3 . isPresent ( ) ) { if ( ! METHOD_4 ( VAR_2 ) ) { METHOD_5 ( VAR_2 . METHOD_6 ( ) , STRING_1 ) ; } else if ( METHOD_7 ( VAR_2 ) ) { METHOD_5 ( VAR_2 . METHOD_6 ( ) , STRING_2 ) ; } } }
<|startcomment|> method synchronized chances eventually a race condition setting VAR_1 <|endcomment|> <START> public String METHOD_1 ( ) { <END> if ( VAR_1 . equals ( VAR_2 ) ) { METHOD_2 ( ) ; } return VAR_1 ; }
<|startcomment|> ! [ BLOCKER ] ( severity : BLOCKER ) move start call another method [ ! [ rule ] ( ) ] ( ) <|endcomment|> public TYPE_2 ( final List < TYPE_1 > VAR_2 ) { this . VAR_3 = METHOD_1 ( VAR_2 ) ; this . VAR_4 = METHOD_2 ( VAR_2 ) ; <START> this . VAR_5 . start ( ) ; <END> }
<|startcomment|> style : braces single line blocks <|endcomment|> private void METHOD_1 ( ) { VAR_1 = 0 ; VAR_2 . clear ( ) ; for ( TYPE_1 element : VAR_3 . METHOD_2 ( ) ) { <START> if ( ! element . VAR_4 ( ) ) { <END> VAR_2 . add ( element ) ; } } }
<|startcomment|> a difference _CODE_ ( ) METHOD_2 ( ) METHOD_3 ( ) <|endcomment|> public Collection < Map . Entry < TYPE_1 , TYPE_2 > > METHOD_1 ( TYPE_3 < ? super Map . Entry < TYPE_1 , TYPE_2 > > VAR_1 ) { <START> return VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) <END> . filter ( VAR_1 ) . collect ( Collectors . VAR_3 ( ArrayList : : new ) ) ; }
<|startcomment|> private ? package protected access <|endcomment|> <START> protected boolean METHOD_1 ( final char c ) { <END> return METHOD_1 ( VAR_1 , c ) ; }
<|startcomment|> toni please choose variable names ? equals VAR_2 newcomer codebase avoid storing partial results : javaif ( ! TYPE_2 equals ( VAR_3 event VAR_1 ( ) ) ) { return false ; } ( ! TYPE_2 equals ( METHOD_2 ( ) event VAR_1 ( ) METHOD_3 ( ) ) ) { return false ; } return true ; pleaselet <|endcomment|> public boolean METHOD_1 ( TYPE_1 event ) { boolean equals = TYPE_2 . equals ( METHOD_2 ( ) , event . VAR_1 ( ) . METHOD_3 ( ) ) ; boolean VAR_2 = TYPE_2 . equals ( VAR_3 , event . VAR_1 ( ) ) ; return ( equals && <START> VAR_2 ) ; <END> }
<|startcomment|> s obvious code duplication save new request a modified URI request methods works other classes a <|endcomment|> public void METHOD_1 ( ) throws IOException { this . entry . uri ( ) <START> . path ( TYPE_3 . VAR_2 ) . METHOD_2 ( ) . method ( STRING_1 ) <END> . METHOD_3 ( ) . METHOD_4 ( TYPE_1 . class ) . METHOD_5 ( TYPE_2 . VAR_4 ) ; }
<|startcomment|> need _CODE_ nullable ? easier understand view class required s totally impractical consider a separate view class capture difference <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 ) { <START> this ( VAR_2 , null , null ) ; <END> }
<|startcomment|> 100% breaks binary compatibility <|endcomment|> <START> public TYPE_1 METHOD_1 ( int VAR_1 ) { <END> this . VAR_1 = VAR_1 ; return this ; }
<|startcomment|> Exception thrown <|endcomment|> <START> public void METHOD_1 ( ) throws Exception { <END> final TYPE_1 command = new TYPE_1 ( parent , VAR_1 , index , VAR_2 , VAR_3 ) ; final TYPE_2 < TYPE_3 < TYPE_4 > > VAR_4 = command . VAR_5 ( ) ; final TYPE_3 < TYPE_4 > VAR_6 = VAR_4 . get ( ) ; assertNotNull ( VAR_6 ) ; assertNotNull ( VAR_6 . METHOD_2 ( ) ) ; assertNotNull ( VAR_6 . METHOD_3 ( ) ) ; assertNotNull ( VAR_6 . METHOD_4 ( ) ) ; assertNotNull ( VAR_6 . METHOD_5 ( ) ) ; }
<|startcomment|> instead early assignment overridden line 2355 set else part statement ( line 2356 ) <|endcomment|> public long METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = - INT_1 ; <END> String VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; if ( METHOD_5 ( ) . METHOD_6 ( VAR_2 ) ) { VAR_1 = METHOD_5 ( ) . METHOD_7 ( VAR_2 ) ; } } return VAR_1 ; }
<|startcomment|> allocate write ID a DB / table related event lookup DB / table <|endcomment|> private boolean METHOD_1 ( final TYPE_1 event ) { return ( ( event . VAR_1 ( ) . equals ( TYPE_2 . VAR_3 ) ) || ( event . VAR_1 ( ) . equals ( TYPE_2 . VAR_4 ) ) || ( event . VAR_1 ( ) . equals ( TYPE_2 . VAR_5 ) ) || <START> ( event . VAR_1 ( ) . equals ( TYPE_2 . VAR_6 ) ) <END> ) ; }
<|startcomment|> t static flag FS instead ? wouldn t need _CODE_ public <|endcomment|> public static void METHOD_1 ( boolean VAR_1 ) { VAR_2 = VAR_1 ; <START> } <END>
<|startcomment|> a small _CODE_ 1 more reasonable check : map size ( ) > VAR_1 <|endcomment|> public TYPE_1 put ( ANNOTATION_1 TYPE_2 key , ANNOTATION_1 TYPE_1 value ) { map . put ( key , new Entry < > ( key , value , ++ time ) ) ; <START> if ( map . size ( ) >= VAR_1 ) { <END> METHOD_1 ( ) ; } return value ; }
<|startcomment|> shouldn t line - s handled optionally bit TYPE_4 class <|endcomment|> private static void METHOD_1 ( TYPE_1 . Builder builder , TYPE_2 VAR_1 , String value ) { if ( value != null && value . trim ( ) . length ( ) > 0 ) { boolean VAR_2 = TYPE_2 . TYPE_5 . equals ( VAR_1 ) ; <START> boolean VAR_3 = value . startsWith ( TYPE_4 . VAR_4 ) ; <END> if ( VAR_2 && VAR_3 ) { value = TYPE_4 . METHOD_2 ( value ) ; } builder . set ( VAR_1 , value ) ; } }
<|startcomment|> / test case a - serializable pojo ( user type ) encoded a UTF - 8 byte [ ] some string representation <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 key ) { <START> TYPE_3 VAR_1 = ( TYPE_3 ) VAR_2 . METHOD_2 ( value ) ; <END> return new TYPE_5 . TYPE_6 < > ( VAR_1 , f ) ; }
<|startcomment|> IMHO need public <|endcomment|> <START> public Entry ( Map . Entry < String , String > e ) { <END> this ( e . getKey ( ) , e . getValue ( ) ) ; }
<|startcomment|> VAR_1 [ 1 ] isEmpty <|endcomment|> private String METHOD_1 ( ) throws TYPE_1 { String [ ] VAR_1 = uri . split ( STRING_1 ) [ 0 ] . split ( STRING_2 , 2 ) ; <START> if ( VAR_1 . length < 2 || VAR_1 [ 1 ] . length ( ) < 1 ) throw new TYPE_1 ( uri , STRING_3 ) ; <END> else return VAR_1 [ 1 ] ; }
<|startcomment|> affect sorting webadmin - webadmin support sortable columns please move logic _CODE_ <|endcomment|> public void METHOD_1 ( Collection value ) { METHOD_2 ( value ) ; <START> final List < TYPE_1 > VAR_1 = METHOD_3 ( value ) ; <END> super . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> need line ? table VAR_1 ( new ArrayList < TYPE_2 > ( ) ) ; <|endcomment|> public void METHOD_1 ( TYPE_1 object ) { <START> table . VAR_1 ( new ArrayList < TYPE_2 > ( ) ) ; <END> table . VAR_2 ( object . VAR_3 ( ) ) ; TYPE_3 . VAR_5 . METHOD_1 ( object ) ; }
<|startcomment|> return VAR_1 <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> return this . VAR_1 ; <END> }
<|startcomment|> assertEquals ( VAR_3 VAR_2 METHOD_2 ( ) ) ; <|endcomment|> public void METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> assertEquals ( VAR_3 , VAR_1 ) ; <END> int VAR_4 = VAR_2 . max ( ) ; assertEquals ( VAR_5 , VAR_4 ) ; }
<|startcomment|> redundant <|endcomment|> public String METHOD_1 ( ) { <START> String result = this . VAR_1 . METHOD_2 ( STRING_1 + VAR_2 + STRING_2 , String . VAR_3 ) ; <END> return STRING_3 + result ; }
<|startcomment|> s move _CODE_ METHOD_3 ( ) method <|endcomment|> public boolean METHOD_1 ( ) { if ( VAR_1 != null ) { try { <START> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( new TYPE_1 ( null , new Object ( ) ) ) <END> . equals ( TYPE_3 . VAR_3 ) ; } catch ( TYPE_2 e ) { } } return true ; }
<|startcomment|> null operande <|endcomment|> public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 view , final TYPE_4 VAR_2 ) { <START> if ( VAR_3 != null ) { <END> return VAR_3 ; } VAR_3 = new TYPE_1 ( VAR_1 , view , VAR_2 ) { @Override protected void METHOD_2 ( ) { } } ; return VAR_3 ; }
<|startcomment|> method private <|endcomment|> <START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> long VAR_2 = System . currentTimeMillis ( ) ; VAR_3 = true ; TYPE_2 VAR_4 = new TYPE_3 ( VAR_1 , VAR_2 , false , false , false , METHOD_2 ( ) , METHOD_3 ( ) , METHOD_4 ( ) ) ; VAR_4 . execute ( METHOD_3 ( ) , this , null , null ) ; }
<|startcomment|> private <|endcomment|> <START> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . class ) ; if ( VAR_2 == null ) { throw new IllegalStateException ( STRING_2 ) ; } return VAR_2 ; }
<|startcomment|> VAR_3 log message update session key <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> log . info ( STRING_1 ) ; <END> synchronized ( TYPE_2 . this ) { TYPE_2 . VAR_3 . VAR_1 = VAR_1 . key ( ) ; if ( METHOD_2 ( ) && VAR_4 > 0 ) { TYPE_2 . VAR_3 . VAR_5 = VAR_1 . METHOD_3 ( ) + VAR_4 ; } } }
<|startcomment|> forgotten line code <|endcomment|> public String METHOD_1 ( TYPE_1 config ) { <START> System . out . METHOD_2 ( STRING_1 ) ; <END> String url = String . format ( VAR_1 , TYPE_2 . METHOD_3 ( config . VAR_2 ( ) ) , TYPE_2 . METHOD_3 ( config . VAR_3 ( ) ) , TYPE_2 . METHOD_3 ( config . VAR_4 ( ) ) , TYPE_2 . METHOD_3 ( config . VAR_5 ( ) ) ) ; return url ; }
<|startcomment|> code don t need parameter request VAR_3 <|endcomment|> public Object METHOD_1 ( String name ) { <START> final TYPE_1 VAR_1 = VAR_2 ; <END> if ( VAR_1 == null ) { return null ; } if ( name . equals ( TYPE_2 . VAR_3 ) ) { TYPE_3 VAR_4 = METHOD_2 ( ) ; if ( ( VAR_4 != null ) && ( VAR_4 instanceof TYPE_2 ) ) { TYPE_4 VAR_5 = new TYPE_4 ( VAR_1 , "" , 0 ) ; return VAR_5 ; } return VAR_1 ; } return null ; }
<|startcomment|> METHOD_1 consistency <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> return METHOD_2 ( VAR_1 . toString ( ) , VAR_1 ) ; <END> }
<|startcomment|> remove <|endcomment|> protected TYPE_4 ( TYPE_1 < T > VAR_2 , String url , TYPE_2 VAR_3 , TYPE_3 < T > VAR_4 ) { VAR_5 = super . METHOD_1 ( VAR_4 . METHOD_2 ( ) , url , VAR_3 != null ? VAR_3 . METHOD_3 ( ) : null ) ; <START> METHOD_4 ( ) ; <END> }
<|startcomment|> add VAR_2 <|endcomment|> public < TYPE_1 > TYPE_2 < TYPE_1 > get ( TYPE_3 id , Class < TYPE_1 > VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . get ( id ) ; Class VAR_4 = VAR_2 . METHOD_1 ( ) ; if ( ! VAR_4 . equals ( VAR_1 ) ) { throw new TYPE_4 ( STRING_1 + VAR_1 . getName ( ) + STRING_2 + VAR_4 . getName ( ) <START> ) ; <END> } return ( TYPE_2 < TYPE_1 > ) VAR_2 ; }
<|startcomment|> s init VAR_2 empty collection avoid = = null <|endcomment|> public String METHOD_1 ( String VAR_1 ) { <START> if ( VAR_2 == null ) return null ; <END> for ( TYPE_1 f : VAR_2 ) { if ( f . getName ( ) . equals ( VAR_1 ) ) { return f . getValue ( ) ; } } return null ; }
<|startcomment|> clean ? needed example commands hard check command s wrapped decorators <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 element ) { String VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_2 . equals ( "" ) ) { <END> VAR_2 = element . VAR_3 ( ) ; } return new TYPE_1 ( null , VAR_1 . METHOD_3 ( ) , element , VAR_2 , VAR_1 . METHOD_4 ( ) ) ; }
<|startcomment|> TYPE_3 throwable treated - - combine catch clauses <|endcomment|> public TYPE_1 METHOD_1 ( byte [ ] VAR_1 ) { if ( VAR_2 == null ) VAR_2 = new TYPE_2 ( ) ; try { TYPE_1 message = VAR_3 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( message , VAR_1 ) ; return message ; } catch ( TYPE_3 e ) { METHOD_4 ( STRING_1 , e ) ; return null ; <START> } catch ( Throwable e ) { <END> METHOD_4 ( STRING_1 , e ) ; return null ; } }
<|startcomment|> remove <|endcomment|> public void METHOD_1 ( TYPE_1 page ) { if ( page . VAR_1 ( ) || page . VAR_2 ( ) != this ) { return ; } VAR_3 = page ; page . VAR_4 ( true ) ; METHOD_2 ( true ) ; TYPE_1 [ ] VAR_5 = METHOD_3 ( ) ; for ( TYPE_1 element : VAR_5 ) { <START> TYPE_1 child = element ; <END> if ( child != page && ! child . VAR_1 ( ) ) { child . VAR_4 ( false ) ; } } }
<|startcomment|> info warn <|endcomment|> public void info ( String message , Object ... VAR_1 ) { <START> LOG . warn ( message , VAR_1 ) ; <END> }
<|startcomment|> s avoid null rework empty string <|endcomment|> public String METHOD_1 ( int offset ) { for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { if ( VAR_1 . get ( i ) . METHOD_2 ( offset ) ) { return VAR_2 . get ( i ) ; } } <START> return null ; <END> }
<|startcomment|> change I requested supposed remove need a read METHOD_1 <|endcomment|> public String toString ( ) { VAR_1 . METHOD_1 ( ) ; try { <START> return STRING_1 + METHOD_2 ( ) + STRING_2 ; <END> } finally { VAR_1 . METHOD_3 ( ) ; } }
<|startcomment|> please a standard SWT table <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 parent ) { TYPE_3 config = new TYPE_3 ( parent , TYPE_3 . VAR_1 ) ; config . VAR_2 ( SWT . VAR_3 ) ; config . VAR_4 ( false ) ; config . VAR_5 ( false ) ; config . VAR_6 ( false ) ; config . VAR_7 ( TYPE_3 . VAR_8 ) ; config . VAR_9 ( TYPE_3 . VAR_10 ) ; <START> this . table = new TYPE_4 ( parent , SWT . VAR_11 , config ) ; <END> return this . table . VAR_12 ( ) ; }
<|startcomment|> return true <|endcomment|> public boolean METHOD_1 ( ) { return <START> METHOD_2 ( ) != null ; <END> }
<|startcomment|> need a specific Exception Type <|endcomment|> void METHOD_1 ( TYPE_1 metadata ) throws Exception { if ( metadata . VAR_1 ( ) != TYPE_2 . VAR_3 || metadata . VAR_4 ( ) != VAR_5 ) { log . error ( STRING_1 , metadata , TYPE_2 . VAR_3 , VAR_5 ) ; <START> throw new Exception ( STRING_2 ) ; <END> } }
<|startcomment|> a bug setter <|endcomment|> public void METHOD_1 ( TYPE_1 value ) { <START> VAR_1 = value ; <END> }
<|startcomment|> part ? checking throw statements <|endcomment|> public void METHOD_1 ( int VAR_1 ) { if ( VAR_1 < 0 || VAR_1 > INT_1 ) { <START> throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; <END> } if ( true ) { assert VAR_1 > INT_2 ; } }
<|startcomment|> fail null <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < Object > [ ] args ) { assert args . length == 2 : STRING_1 ; TYPE_3 text = ( String ) args [ 0 ] . value ( ) ; if ( text == null ) { return null ; } <START> TYPE_3 VAR_2 = ( int ) args [ 1 ] . value ( ) ; <END> if ( VAR_2 <= 0 ) { return "" ; } else { return text . VAR_3 ( VAR_2 ) ; } }
<|startcomment|> public <|endcomment|> <START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> METHOD_2 ( ) . METHOD_3 ( new TYPE_2 ( VAR_1 . METHOD_4 ( this ) ) ) ; if ( TYPE_3 . VAR_3 . VAR_4 >= TYPE_3 . VAR_5 . VAR_6 ) { METHOD_5 ( ) . METHOD_6 ( VAR_1 . METHOD_7 ( this ) ) ; } }
<|startcomment|> please { } / else / / block <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 project ) { <START> if ( METHOD_2 ( project ) ) <END> return TYPE_1 . VAR_1 ; TYPE_3 VAR_2 = METHOD_3 ( project ) ; TYPE_4 builder = VAR_2 . METHOD_4 ( ) ; Boolean VAR_3 = builder . VAR_4 ( ) ; if ( VAR_3 ) return TYPE_1 . VAR_5 ; else return TYPE_1 . VAR_6 ; }
<|startcomment|> isn t necessary <|endcomment|> protected long METHOD_1 ( T object , File VAR_1 ) throws IOException { try { VAR_2 . METHOD_2 ( object , VAR_1 ) ; } <START> catch ( IOException e ) { <END> throw new RuntimeException ( e ) ; } return VAR_1 . length ( ) ; }
<|startcomment|> s point catching throwing exception type <|endcomment|> private Collection < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { Collection < TYPE_1 > results = null ; try { results = VAR_1 . METHOD_2 ( ) ; } catch ( TYPE_3 ex ) { <START> throw new TYPE_3 ( ex , STRING_1 ) ; <END> } return results ; }
<|startcomment|> public <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_1 context ) <START> { <END> context = node . VAR_1 ( ) . METHOD_2 ( this , context ) ; METHOD_3 ( context , STRING_1 ) ; TYPE_3 < TYPE_4 , TYPE_5 > TYPE_6 = context . VAR_2 ( ) ; String filter = node . VAR_3 ( ) . METHOD_2 ( VAR_4 , ( VAR_5 ) - > TYPE_6 . get ( VAR_5 ) ) . METHOD_4 ( ) ; return context . VAR_6 ( filter ) . METHOD_5 ( node . VAR_7 ( ) ) ; }
<|startcomment|> _CODE_ method signature match please update _CODE_ <|endcomment|> <START> private TYPE_1 ( String VAR_2 ) { <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> requires fix : VAR_5 METHOD_3 ( ) = = type <|endcomment|> public Guid METHOD_1 ( Guid VAR_1 , TYPE_1 type ) { Guid VAR_2 = Guid . TYPE_4 ; List < TYPE_2 > VAR_4 = METHOD_2 ( VAR_1 ) ; for ( TYPE_2 VAR_5 : VAR_4 ) { <START> if ( VAR_5 . METHOD_3 ( ) == TYPE_1 . TYPE_3 ) { <END> VAR_2 = VAR_5 . getId ( ) ; break ; } } return VAR_2 ; }
<|startcomment|> s : VAR_1 METHOD_2 ( ) ; { / / other stuff } finally { VAR_1 METHOD_4 ( ) ; } exception thrown decrement VAR_1 counter <|endcomment|> public void METHOD_1 ( T id ) throws InterruptedException { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . update ( 1 ) ; METHOD_3 ( id ) ; VAR_1 . METHOD_4 ( ) ; }
<|startcomment|> syntax typo ( add position checks _CODE_ commit ) <|endcomment|> public TYPE_2 ( TYPE_1 value , int VAR_3 ) { VAR_4 ( value , STRING_1 ) ; if ( value . VAR_5 ( ) != 1 ) { throw new IllegalArgumentException ( format ( STRING_2 , value . VAR_5 ( ) ) ) ; } if ( value instanceof TYPE_2 ) { throw new IllegalArgumentException ( format ( STRING_3 , getClass ( ) . getName ( ) ) ) ; } if ( VAR_3 < 0 ) { throw new IllegalArgumentException ( STRING_4 ) ; } <START> this . value = value <END> this . VAR_3 = VAR_3 ; }
<|startcomment|> idea VAR_4 request a retry ( independent a speculative execution executed ? ) <|endcomment|> public TYPE_2 . TYPE_3 request ( ) { <START> TYPE_2 . TYPE_3 request = VAR_1 . request ( ) ; <END> if ( VAR_2 != null && VAR_2 != request . VAR_3 ( ) ) return request . VAR_4 ( VAR_2 ) ; else return request ; }
<|startcomment|> I prefer full words example _CODE_ <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> VAR_2 = Context . VAR_3 ( ) . METHOD_2 ( STRING_1 ) ; <END> }
<|startcomment|> want expected condition <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 ... VAR_3 ) { super ( VAR_2 ) ; <START> METHOD_1 ( VAR_3 . length == 0 , STRING_1 ) ; <END> this . VAR_3 = VAR_3 ; }
<|startcomment|> s tangential IllegalArgumentException more reasonable <|endcomment|> public boolean METHOD_1 ( Object [ ] value , TYPE_1 context ) { if ( value . length != 3 ) { <START> throw new IllegalStateException ( STRING_1 ) ; <END> } if ( value [ 1 ] == null || value [ 2 ] == null ) { return true ; } return ( ( Date ) value [ 1 ] ) . METHOD_2 ( ( Date ) value [ 2 ] ) ; }
<|startcomment|> check start file newline <|endcomment|> <START> private static boolean METHOD_1 ( TYPE_1 < Utils . TYPE_2 > result ) { <END> if ( result == null || ! result . VAR_2 ( ) ) { return true ; } else { Utils . TYPE_2 VAR_3 = result . get ( ) ; return METHOD_1 ( VAR_3 . output ) || METHOD_1 ( VAR_3 . error ) ; } }
<|startcomment|> another extra space plese cleanup similar ? a others some functions spaces parameters some don t _CODE_ ( TYPE_2 TYPE_3 ) VAR_1 METHOD_2 ( TYPE_10 ABM_QUERYPOS ) ; a pest messy inconsistent <|endcomment|> private void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 TYPE_3 = new TYPE_2 . TYPE_9 ( ) ; TYPE_3 . VAR_2 . METHOD_2 ( TYPE_3 . size ( ) ) ; VAR_1 . METHOD_2 ( TYPE_10 . VAR_4 ) ; TYPE_5 result = TYPE_7 . TYPE_8 . METHOD_3 ( VAR_1 , TYPE_3 ) ; <START> assertNotNull ( result ) ; <END> }
<|startcomment|> stray _CODE_ standard METHOD_1 format denizen weird inline <|endcomment|> public boolean METHOD_1 ( TYPE_1 path ) { <START> return ( path . VAR_1 . startsWith ( STRING_1 ) && ( path . VAR_2 ( 2 ) . equals ( STRING_2 ) ) ) ; <END> }
<|startcomment|> resolve controller home ? _CODE_ ? s class called controller agent <|endcomment|> void METHOD_1 ( ) { <START> VAR_1 = METHOD_2 ( ) ; <END> this . METHOD_3 ( ) ; this . METHOD_4 ( ) ; }
<|startcomment|> expected VAR_1 instance TYPE_5 I don t check required <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 session , TYPE_3 VAR_1 , TYPE_4 VAR_2 ) { if ( VAR_1 instanceof TYPE_5 ) { return new TYPE_6 ( session , ( TYPE_5 ) VAR_1 , VAR_2 ) ; } return null ; <START> } <END>
<|startcomment|> TYPE_5 a run time exception required part method signature invalid signature sonar report a _major_ category violation <|endcomment|> <START> public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 ) throws TYPE_4 , TYPE_5 , TYPE_6 { <END> return this . VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> please - static similar done _CODE_ <|endcomment|> public org . VAR_1 . VAR_2 . VAR_3 . model . TYPE_8 update ( org . VAR_1 . VAR_2 . VAR_3 . model . TYPE_8 VAR_5 ) { TYPE_1 VAR_6 = VAR_5 . METHOD_1 ( ) ; <START> VAR_6 . METHOD_2 ( TYPE_2 . get ( VAR_6 . getId ( ) , <END> VAR_6 . getName ( ) , this ) ) ; return METHOD_3 ( VAR_5 , new TYPE_3 < > ( TYPE_6 . TYPE_9 , TYPE_4 . class ) , TYPE_7 . TYPE_10 , new TYPE_5 ( ) ) ; }
<|startcomment|> handle error log returning null instead a viewer ? view won t work incorrect id <|endcomment|> protected ANNOTATION_1 TYPE_1 METHOD_1 ( ANNOTATION_2 TYPE_2 parent ) <START> { String VAR_1 = TYPE_3 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ; <END> return new TYPE_4 ( TYPE_5 . METHOD_5 ( parent ) ) { @Override protected ANNOTATION_2 TYPE_6 METHOD_6 ( TYPE_7 trace ) { TYPE_8 VAR_2 = TYPE_9 . METHOD_7 ( trace , TYPE_8 . class , VAR_1 ) ; if ( VAR_2 instanceof TYPE_6 ) { return ( TYPE_6 ) VAR_2 ; } return null ; } } ; }
<|startcomment|> I more sense omit assert expected exception cases <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 in = TYPE_2 . METHOD_2 ( new byte [ ] { - INT_1 , INT_2 , INT_3 , INT_3 , CHAR_1 , CHAR_2 , CHAR_3 , CHAR_4 , CHAR_4 , CHAR_5 } ) ; <START> METHOD_3 ( channel . VAR_1 ( in ) ) ; <END> }
<|startcomment|> method calls _CODE_ VAR_1 getName ( ) instead field getName ( ) METHOD_3 ( ) key VAR_3 map consistent s discrepancy prefixed / unprefixed <|endcomment|> public void set ( String name , TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 field = getType ( ) . METHOD_1 ( name ) ; if ( field == null ) { TYPE_1 VAR_2 = METHOD_2 ( name ) ; if ( VAR_2 != null ) { VAR_2 . set ( name , VAR_1 ) ; } return ; } <START> VAR_3 . put ( field . getName ( ) . METHOD_3 ( ) , VAR_1 ) ; <END> METHOD_4 ( ) ; }
<|startcomment|> METHOD_1 ( TYPE_1 ) called instead ( TYPE_1 ) VAR_1 ( ) <|endcomment|> public int METHOD_1 ( TYPE_1 x ) { if ( this . METHOD_2 ( ) == 0 ) return 0 ; else if ( x . VAR_1 ( ) == 0 ) return 0 ; else { if ( x instanceof TYPE_2 ) <START> return and ( ( TYPE_2 ) x ) . METHOD_2 ( ) ; <END> else if ( x instanceof TYPE_3 ) return and ( ( TYPE_3 ) x ) . METHOD_2 ( ) ; return and ( ( TYPE_4 ) x ) . METHOD_2 ( ) ; } }
<|startcomment|> ( ) initialize initial capacity number workers <|endcomment|> public Set < TYPE_1 > METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 . METHOD_2 ( ) ) { throw new TYPE_2 ( TYPE_5 . TYPE_6 . getMessage ( ) ) ; } <START> Set < TYPE_1 > VAR_2 = new HashSet < > ( ) ; <END> for ( TYPE_4 VAR_3 : VAR_4 ) { VAR_2 . add ( VAR_3 . METHOD_3 ( ) ) ; } return VAR_2 ; }
<|startcomment|> move VAR_1 declared changes <|endcomment|> public void METHOD_1 ( ) { params . put ( STRING_1 , STRING_2 ) ; params . put ( STRING_3 , STRING_4 ) ; params . put ( STRING_5 , STRING_6 ) ; params . put ( STRING_7 , STRING_4 ) ; params . put ( STRING_8 , STRING_9 ) ; <START> VAR_1 = STRING_10 ; <END> }
<|startcomment|> public ANNOTATION_1 String <|endcomment|> <START> public String METHOD_1 ( ANNOTATION_1 String name ) { <END> return name ; }
<|startcomment|> logic need updated change VAR_3 <|endcomment|> public void METHOD_1 ( TYPE_1 request , TYPE_2 response , TYPE_3 VAR_1 ) { for ( Object VAR_2 : VAR_3 ) { TYPE_4 VAR_4 = null ; <START> if ( VAR_2 instanceof String ) { <END> VAR_4 = new TYPE_4 ( ( String ) VAR_2 , null ) ; String VAR_5 = request . VAR_6 ( ) + STRING_1 ; VAR_4 . METHOD_2 ( VAR_5 ) ; VAR_4 . METHOD_3 ( 0 ) ; } else if ( VAR_2 instanceof TYPE_4 ) { VAR_4 = ( TYPE_4 ) VAR_2 ; } response . VAR_7 ( VAR_4 ) ; } }
<|startcomment|> remove throws TYPE_2 <|endcomment|> <START> private TYPE_3 . TYPE_4 METHOD_1 ( Class < ? > VAR_1 ) throws TYPE_2 <END> { return TYPE_3 . METHOD_2 ( ) . in ( VAR_1 ) ; }
<|startcomment|> won t a double - decrement <|endcomment|> public void METHOD_1 ( TYPE_1 ctx , TYPE_2 e ) throws Exception { if ( VAR_1 > 0 ) { if ( VAR_2 . METHOD_2 ( ) > VAR_1 ) { ctx . VAR_3 ( ) . close ( ) ; <START> VAR_2 . METHOD_3 ( ) ; <END> log . info ( STRING_1 , VAR_1 ) ; } } super . METHOD_1 ( ctx , e ) ; }
<|startcomment|> assumes input sorted test case calls ; test defined - sorted order <|endcomment|> public Builder from ( int ... VAR_1 ) { <START> this . VAR_2 . add ( ( from , to , msg ) - > Arrays . VAR_3 ( VAR_1 , from ) >= 0 ) ; <END> return this ; }
<|startcomment|> merge 2 lines METHOD_1 returns VAR_1 <|endcomment|> public TYPE_1 channel ( Class < ? extends TYPE_2 > VAR_1 ) { TYPE_3 . METHOD_1 ( VAR_1 , STRING_1 ) ; <START> return METHOD_2 ( new TYPE_4 < TYPE_2 > ( VAR_1 ) ) ; <END> }
<|startcomment|> variables place remove actual place <|endcomment|> public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( VAR_3 . METHOD_3 ( 2 ) ) ; TYPE_1 VAR_4 = VAR_1 . get ( 0 ) ; TYPE_1 VAR_5 = VAR_1 . get ( 1 ) ; <START> String VAR_6 = STRING_1 ; <END> String VAR_7 = STRING_2 ; Assert . assertTrue ( VAR_1 . size ( ) == 2 ) ; Assert . assertEquals ( VAR_6 , VAR_4 . METHOD_4 ( ) ) ; Assert . assertEquals ( VAR_7 , VAR_5 . METHOD_4 ( ) ) ; }
<|startcomment|> a METHOD_3 <|endcomment|> public synchronized TYPE_1 < ? > METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) { return null ; } <START> List < TYPE_1 < ? > > VAR_1 = TYPE_2 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <END> return VAR_1 . get ( VAR_1 . size ( ) - 1 ) ; }
<|startcomment|> list stream ( ) forEach <|endcomment|> private static < T > Set < T > METHOD_1 ( Collection < T > list ) { Set < T > VAR_1 = new HashSet < > ( ) ; Set < T > VAR_2 = new HashSet < > ( ) ; <START> for ( T t : list ) { <END> if ( ! VAR_2 . add ( t ) ) { VAR_1 . add ( t ) ; } } return VAR_1 ; }
<|startcomment|> isn t <|endcomment|> public boolean next ( ) throws IOException { for ( ; ; ) { TYPE_1 t = VAR_1 . METHOD_1 ( ) ; if ( t == null ) { return false ; } VAR_2 = t . VAR_3 . METHOD_2 ( ) ; VAR_4 = t . VAR_3 . METHOD_3 ( ) ; entry = t . VAR_3 . METHOD_4 ( ) ; boolean VAR_5 = VAR_6 || entry != null ; METHOD_5 ( VAR_2 , VAR_4 ) ; add ( t ) ; <START> if ( VAR_5 ) { return true ; } return true ; <END> } }
<|startcomment|> s logic method group real problem _CODE_ implementation check presence other logic affected please remove ( ) method protected <|endcomment|> void remove ( TYPE_1 group ) { Object VAR_1 = group . VAR_2 ( ) ; <START> if ( this . VAR_3 . contains ( VAR_1 ) ) { <END> this . VAR_4 . METHOD_1 ( VAR_1 ) ; this . VAR_3 . remove ( VAR_1 ) ; } }
<|startcomment|> hmm feels premature optimization VAR_1 map more a problem I m restrict usage today send VAR_1 multiple groups a good reason restrict doesn t sense streams <|endcomment|> public void METHOD_1 ( Map < TYPE_1 , TYPE_2 > VAR_1 , String VAR_2 ) throws TYPE_3 { <START> if ( ! VAR_3 . METHOD_2 ( ) . equals ( VAR_2 ) ) { <END> log . warn ( STRING_1 , VAR_3 . METHOD_2 ( ) , VAR_2 ) ; VAR_3 = new TYPE_4 ( VAR_2 , TYPE_5 . VAR_5 , TYPE_5 . VAR_6 , Optional . empty ( ) ) ; } METHOD_3 ( VAR_1 , VAR_3 , false ) ; }
<|startcomment|> issue original VAR_2 logged due error toString concern logging _new_ error issue ? stages ? 1 catch logging error log error 2 catch _that_ error log a generic static message <|endcomment|> public boolean METHOD_1 ( final Exception VAR_1 ) { if ( METHOD_2 ( VAR_1 ) ) { final Exception VAR_2 = new TYPE_1 ( VAR_1 ) ; try { METHOD_3 ( VAR_2 ) ; } catch ( Throwable ex ) { <START> LOGGER . warn ( STRING_1 , ex ) ; <END> } METHOD_4 ( ) . METHOD_5 ( VAR_2 ) ; return true ; } return false ; }
<|startcomment|> private <|endcomment|> <START> int METHOD_1 ( ) <END> { return VAR_1 > > > VAR_2 | VAR_3 > > > VAR_4 ; }
<|startcomment|> connection configuration serialized <|endcomment|> <START> protected void METHOD_1 ( TYPE_1 writer , TYPE_2 configuration ) throws TYPE_3 { <END> writer . VAR_1 ( TYPE_5 . VAR_3 ) ; METHOD_2 ( writer , TYPE_4 . VAR_5 , configuration . VAR_6 ( ) ) ; METHOD_2 ( writer , TYPE_4 . VAR_7 , configuration . VAR_8 ( ) ) ; METHOD_2 ( writer , TYPE_4 . VAR_9 , configuration . VAR_10 ( ) ) ; METHOD_2 ( writer , TYPE_4 . VAR_11 , configuration . VAR_12 ( ) ) ; writer . VAR_13 ( ) ; }
<|startcomment|> public private <|endcomment|> <START> static TYPE_1 METHOD_1 ( TYPE_2 list ) { <END> TYPE_1 buf = TYPE_3 . buffer ( list . VAR_1 ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { buf . VAR_2 ( list . VAR_3 ( i ) . METHOD_2 ( ) ) ; } return buf ; }
<|startcomment|> useless <|endcomment|> private String METHOD_1 ( final TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) instanceof TYPE_2 ) { return ( ( TYPE_2 ) VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( VAR_1 ) ; } <START> ; <END> return null ; }
<|startcomment|> format overrides <|endcomment|> <START> @Override public float METHOD_1 ( ) { <END> return 0 ; }
<|startcomment|> I m missing part case ( isn t VAR_2 size ( ) > = 0 invariant ? ) called emphasize setting 0 = > queuing <|endcomment|> private boolean METHOD_1 ( ) { <START> if ( TYPE_2 == 0 ) <END> return true ; if ( VAR_2 . size ( ) >= TYPE_2 ) return true ; boolean VAR_3 = ( TYPE_1 > 0 && VAR_5 . size ( ) > TYPE_1 ) ; if ( VAR_3 ) return true ; return false ; }
<|startcomment|> add ( TYPE_2 ) method instead repeating code <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_11 . TYPE_12 VAR_2 = null ; TYPE_4 VAR_3 = null ; TYPE_9 . TYPE_10 VAR_4 = null ; TYPE_6 VAR_5 = null ; TYPE_7 VAR_6 = null ; List < TYPE_8 > VAR_7 = null ; VAR_8 . put ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) , new TYPE_1 ( VAR_6 , VAR_9 , VAR_10 , VAR_4 , VAR_2 , VAR_3 , VAR_5 , VAR_7 , VAR_1 ) ) ; <END> return VAR_8 . get ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ; }
<|startcomment|> s a - declaration error fixed parent branch needs merged <|endcomment|> public static Collection < TYPE_1 > METHOD_1 ( long VAR_1 ) throws TYPE_2 { String VAR_2 = VAR_3 + STRING_1 + VAR_1 <START> + STRING_2 + TYPE_5 . TYPE_6 . VAR_6 . METHOD_2 ( ) ; <END> TYPE_3 VAR_7 = TYPE_3 . getInstance ( ) ; if ( VAR_7 != null ) { String VAR_2 = VAR_3 + STRING_1 + VAR_1 ; TYPE_4 VAR_8 = new TYPE_4 ( ) ; VAR_7 . METHOD_3 ( VAR_2 , VAR_8 ) ; return VAR_8 . METHOD_4 ( ) ; } return new ArrayList < > ( ) ; }
<|startcomment|> question column supports filtering relates multiple values <|endcomment|> public boolean METHOD_1 ( final String VAR_1 ) { if ( METHOD_2 ( VAR_1 ) ) { return VAR_2 . METHOD_3 ( VAR_1 ) . METHOD_4 ( VAR_1 ) . METHOD_1 ( ) ; } final TYPE_1 column = index . VAR_3 ( VAR_1 ) ; <START> if ( column == null || ! METHOD_5 ( column ) ) { <END> return false ; } else { return column . VAR_4 ( ) . METHOD_1 ( ) ; } }
<|startcomment|> won t work ? wait node powered want resume <|endcomment|> public void METHOD_1 ( String id ) { <START> VAR_1 . apply ( METHOD_2 ( id ) ) ; <END> VAR_2 . METHOD_3 ( ) . METHOD_4 ( id , TYPE_2 . TYPE_3 . create ( TYPE_4 . TYPE_6 . VAR_5 , TYPE_4 . TYPE_5 . VAR_7 ) ) ; }
<|startcomment|> a method returns result a load method unexpected ( method ) <|endcomment|> public TYPE_1 [ ] METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = TYPE_2 . METHOD_2 ( ) ; } return VAR_1 ; }
<|startcomment|> registered ? invokes <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 ) { VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 , new TYPE_2 ( ) ) ; } else { VAR_1 . METHOD_2 ( VAR_4 , TYPE_3 . VAR_6 ) ; <START> VAR_1 . METHOD_2 ( VAR_7 , TYPE_4 . VAR_6 ) ; <END> } }
<|startcomment|> luck ; - ) <|endcomment|> public int METHOD_1 ( ) { <START> int result = VAR_1 . METHOD_1 ( ) ; <END> result = INT_1 * result + VAR_2 . METHOD_1 ( ) ; result = INT_1 * result + VAR_3 . METHOD_1 ( ) ; result = INT_1 * result + VAR_4 . METHOD_1 ( ) ; return result ; }
<|startcomment|> remove synchronized <|endcomment|> <START> public synchronized void METHOD_1 ( final String VAR_1 ) <END> { new Thread ( STRING_1 ) { @Override public void run ( ) { METHOD_2 ( VAR_1 , true ) ; } } . start ( ) ; }
<|startcomment|> braces <|endcomment|> public boolean equals ( Object o ) { if ( ! ( o instanceof Map . Entry ) ) <START> return <END> false ; Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) o ; return ( ( key == null ? e . getKey ( ) == null : key . equals ( e . getKey ( ) ) ) && ( value == null ? e . getValue ( ) == null : value . equals ( e . getValue ( ) ) ) ) ; }
<|startcomment|> protected <|endcomment|> <START> public TYPE_3 ( final TYPE_1 properties , final String VAR_2 ) throws TYPE_2 { <END> super ( VAR_2 , properties , TYPE_4 . VAR_4 ) ; }
<|startcomment|> METHOD_1 synchronized remove volatile keyword class member <|endcomment|> <START> public void METHOD_1 ( ) { <END> METHOD_2 ( ) ; }
<|startcomment|> I m thinking new VAR_1 needed reconnect task VAR_1 dead time a new reconnect needed I timer instance serving purpose VAR_1 <|endcomment|> public void run ( ) { if ( VAR_1 == null || ! Thread . VAR_2 ( ) . equals ( VAR_1 ) ) { <START> VAR_1 = new Thread ( this ) ; <END> VAR_1 . start ( ) ; } else { try { if ( logger . VAR_3 ( ) ) logger . info ( STRING_1 + VAR_4 ) ; VAR_4 . METHOD_1 ( METHOD_2 ( ) . METHOD_3 ( VAR_4 ) ) ; } catch ( TYPE_1 ex ) { logger . error ( STRING_2 , ex ) ; } } }
<|startcomment|> couldn t depend class generate <|endcomment|> public void METHOD_1 ( TYPE_1 properties ) { <START> properties . VAR_1 ( STRING_1 , STRING_2 ) ; <END> properties . VAR_1 ( STRING_3 , STRING_4 ) ; }
<|startcomment|> _CODE_ ( VAR_5 METHOD_8 ( ) VAR_8 VAR_7 ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_4 VAR_5 = METHOD_4 ( VAR_1 , VAR_6 , TYPE_4 . class ) ; METHOD_5 ( VAR_5 . METHOD_6 ( ) , VAR_7 , VAR_7 ) ; <START> METHOD_7 ( VAR_5 . METHOD_8 ( ) , VAR_8 , "" ) ; <END> }
<|startcomment|> handle VAR_4 <|endcomment|> private TYPE_2 ( long VAR_2 , TimeUnit VAR_3 , long VAR_4 , TimeUnit VAR_5 , TYPE_1 version ) { super ( version ) ; this . VAR_2 = VAR_2 < 0 ? VAR_2 : VAR_3 . METHOD_1 ( VAR_2 ) ; <START> this . VAR_4 = VAR_5 . METHOD_1 ( VAR_4 ) ; <END> }
<|startcomment|> consistency ( another slight performance enhancement ) line changed <|endcomment|> protected void METHOD_1 ( String VAR_1 ) { if ( VAR_1 . length ( ) == 0 ) { VAR_2 = null ; } else { TYPE_1 VAR_3 = new TYPE_1 ( ) ; if ( VAR_1 . METHOD_2 ( CHAR_1 ) != 0 && VAR_1 . METHOD_2 ( CHAR_2 ) != 0 && VAR_1 . METHOD_2 ( CHAR_3 ) != 0 ) { <START> VAR_1 = STRING_1 + VAR_1 ; <END> } VAR_3 . METHOD_3 ( VAR_1 ) ; VAR_2 = VAR_3 ; } }
<|startcomment|> yeah s remove : ) <|endcomment|> public TYPE_8 ( final TYPE_1 session , final TYPE_2 < TYPE_3 > VAR_2 , final ANNOTATION_1 TYPE_4 < TYPE_3 > VAR_3 , final ANNOTATION_2 TYPE_4 < TYPE_3 > VAR_4 , final TYPE_5 < org . VAR_5 . VAR_6 . VAR_7 . VAR_8 . VAR_9 . command . TYPE_7 < TYPE_3 , TYPE_6 > > VAR_11 ) { this . session = session ; <START> this . VAR_12 = VAR_11 . METHOD_1 ( session ) ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_2 = VAR_2 ; }
<|startcomment|> consistency project please remove final keyword <|endcomment|> private String METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> final StringBuilder sb = new StringBuilder ( ) ; <END> for ( int i = 0 ; i < VAR_1 . length - 1 ; i ++ ) { sb . append ( VAR_1 [ i ] . VAR_2 ) . append ( STRING_1 ) ; } sb . append ( VAR_1 [ VAR_1 . length - 1 ] . VAR_2 ) ; return sb . toString ( ) ; }
<|startcomment|> üêú de - facto process errors logging handler E g logging constructs string VAR_2 _CODE_ suppresses original I d vote errors rethrown processing <|endcomment|> private static void METHOD_1 ( final TYPE_4 . TYPE_5 VAR_1 , final Throwable VAR_2 ) { for ( TYPE_2 VAR_3 : TYPE_2 . METHOD_2 ( ) ) { try { VAR_3 . METHOD_3 ( VAR_1 , VAR_2 ) ; } catch ( Throwable e ) { LOGGER . log ( Level . VAR_4 , STRING_1 + STRING_2 + VAR_3 + STRING_3 + VAR_1 . VAR_5 , e ) ; <START> if ( e instanceof TYPE_3 ) { <END> throw e ; } } } }
<|startcomment|> logs Logger ( ) s good <|endcomment|> public synchronized boolean METHOD_1 ( ) { long VAR_1 = INT_1 * INT_2 ; long VAR_2 = VAR_3 . METHOD_2 ( METHOD_3 ( ) + VAR_4 , - VAR_1 ) + VAR_1 ; if ( VAR_2 < TYPE_1 . getInstance ( ) . METHOD_4 ( ) ) { Logger . d ( TAG , STRING_1 , METHOD_3 ( ) ) ; return true ; } else { <START> Logger . d ( TAG , STRING_2 , METHOD_3 ( ) ) ; <END> return false ; } }
<|startcomment|> ditto input ! = null <|endcomment|> public TYPE_1 apply ( org . VAR_1 . VAR_2 . entity . TYPE_1 input ) { if ( input instanceof org . VAR_1 . VAR_2 . entity . TYPE_3 ) { return METHOD_1 ( ( org . VAR_1 . VAR_2 . entity . TYPE_3 ) input ) ; <START> } else if ( TYPE_2 . METHOD_2 ( input ) ) { <END> return METHOD_3 ( input ) ; } else { return null ; } }
<|startcomment|> want assert close cases ? i e s empty <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 s = new TYPE_1 ( ) ; s . VAR_1 ( server . VAR_2 ( ) ) ; s . close ( ) ; assertEquals ( Collections . VAR_3 , <START> VAR_4 . METHOD_2 ( ) ) ; <END> }
<|startcomment|> METHOD_2 needed METHOD_1 checks nullability <|endcomment|> public TYPE_3 ( Map < String , Integer > VAR_2 , Optional < Integer > VAR_3 , Optional < List < List < TYPE_1 > > > VAR_4 ) { <START> this . VAR_2 = TYPE_2 . METHOD_1 ( METHOD_2 ( VAR_2 , STRING_1 ) ) ; <END> this . VAR_3 = METHOD_2 ( VAR_3 , STRING_2 ) ; this . VAR_4 = METHOD_2 ( VAR_4 , STRING_3 ) ; }
<|startcomment|> pass id java autoboxing care <|endcomment|> protected TYPE_1 METHOD_1 ( int id ) { <START> return VAR_1 . get ( new Integer ( id ) ) ; <END> }
<|startcomment|> Map <|endcomment|> public void METHOD_1 ( TYPE_1 config , String VAR_1 , Object data ) { if ( data instanceof <START> TYPE_2 ) { <END> TYPE_2 < ? , ? > table = ( TYPE_2 < ? , ? > ) data ; VAR_2 = ( String ) table . get ( STRING_1 ) ; } }
<|startcomment|> VAR_1 ‚Äî > e please <|endcomment|> public void METHOD_1 ( TYPE_1 request ) { TYPE_2 . METHOD_2 ( request ) . METHOD_1 ( new TYPE_3 ( ) { @Override public void METHOD_3 ( TYPE_1 req ) { try { close ( ) ; } catch ( TYPE_4 VAR_1 ) { <START> throw new TYPE_5 ( VAR_1 ) ; <END> } } } ) ; }
<|startcomment|> move logic TYPE_2 VAR_3 METHOD_2 <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( METHOD_2 ( VAR_1 ) && ! VAR_1 . parent ( ) . is ( TYPE_2 . VAR_3 ) ) { <END> VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) ; super . METHOD_1 ( VAR_1 ) ; VAR_4 . METHOD_3 ( ) . METHOD_5 ( ) ; } else { super . METHOD_1 ( VAR_1 ) ; } }
<|startcomment|> need add message METHOD_8 location <|endcomment|> private static void METHOD_1 ( TYPE_1 ctx ) { TYPE_2 VAR_1 = ( TYPE_2 ) ctx . VAR_2 ( ) ; if ( METHOD_2 ( VAR_1 , VAR_3 ) ) { TYPE_2 VAR_4 = METHOD_3 ( METHOD_4 ( TYPE_3 . METHOD_5 ( 1 , STRING_1 , VAR_1 . METHOD_6 ( ) ) ) ) ; if ( VAR_4 != null && METHOD_7 ( VAR_4 ) ) { <START> ctx . VAR_5 ( VAR_4 , VAR_6 ) . METHOD_8 ( VAR_1 , VAR_6 ) ; <END> } } }
<|startcomment|> error reported <|endcomment|> public int METHOD_1 ( TYPE_1 VAR_1 ) { try { TYPE_2 VAR_2 = new TYPE_2 ( METHOD_2 ( ) , record + VAR_3 ) ; return VAR_2 . METHOD_3 ( VAR_1 ) ; } catch ( TYPE_3 e ) { TYPE_4 . log ( e ) ; <START> throw new IllegalArgumentException ( VAR_1 . getName ( ) + STRING_1 + getName ( ) ) ; <END> } }
<|startcomment|> nitpick : s generally safer include curly brackets _all_ statements protect a future developer accidentally introducing a bug another line added statement alternatively a more succinct writing method : return ( VAR_1 = = null ) ? Collections < String Object > METHOD_2 ( ) : VAR_1 ; <|endcomment|> public Map < String , Object > METHOD_1 ( ) { if ( VAR_1 == null ) <START> return TYPE_1 < String , Object > METHOD_2 ( ) ; <END> return VAR_1 ; }
<|startcomment|> I m public modifier version field represents reference s implementation details I doubt consumers interested I leave private ( remove ) a real usecase requires access making private hard ( due API breakage ) public problems <|endcomment|> <START> public String METHOD_1 ( ) { <END> return version ; }
<|startcomment|> drop VAR_3 check other methods file please <|endcomment|> public List < TYPE_1 > METHOD_1 ( TYPE_2 sess ) throws TYPE_3 , TYPE_4 { Utils . VAR_1 ( sess ) ; if ( ! TYPE_5 . METHOD_2 ( sess , TYPE_6 . VAR_3 ) && <START> ! TYPE_5 . METHOD_2 ( sess , TYPE_6 . VAR_4 ) ) { <END> throw new TYPE_4 ( sess , STRING_1 ) ; } return METHOD_3 ( ) . METHOD_1 ( sess ) ; }
<|startcomment|> negation missing ? ( ! cluster VAR_1 ( ) ) { <|endcomment|> protected void METHOD_1 ( ) { TYPE_1 cluster = METHOD_2 ( ) ; <START> if ( cluster . VAR_1 ( ) ) { <END> TYPE_2 VAR_2 = TYPE_3 . METHOD_3 ( cluster . VAR_3 ( ) ) ; cluster . VAR_4 ( VAR_2 ) ; } }
<|startcomment|> removed <|endcomment|> public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) <START> throws IOException <END> { throw new TYPE_3 ( STRING_1 ) ; }
<|startcomment|> ctor call ( null ) <|endcomment|> public TYPE_1 ( ) { super ( ) ; <START> METHOD_1 ( Messages . TYPE_2 ) ; <END> }
<|startcomment|> don t change necessary <|endcomment|> <START> protected TYPE_1 < TYPE_2 > METHOD_1 ( String name ) { <END> TYPE_1 < TYPE_2 > p = METHOD_2 ( TYPE_1 . class ) ; when ( p . getName ( ) ) . METHOD_3 ( name ) ; return p ; }
<|startcomment|> change INT_17 case a default case remove <|endcomment|> public static int METHOD_1 ( int VAR_1 ) { if ( VAR_1 < INT_1 ) { return VAR_2 ; } switch ( VAR_1 ) { case INT_1 : case INT_2 : return INT_3 ; case INT_4 : return INT_5 ; case INT_6 : return INT_7 ; case INT_8 : return INT_9 ; case INT_10 : case INT_11 : return INT_12 ; case INT_13 : return INT_14 ; case INT_15 : return INT_16 ; case INT_17 : return INT_18 ; } <START> return INT_19 ; <END> }
<|startcomment|> move context _CODE_ ( ) METHOD_8 ( true ) ; METHOD_5 move METHOD_3 ( VAR_4 ) METHOD_8 ( true ) ; METHOD_5 test <|endcomment|> public void METHOD_1 ( ) { TYPE_1 event = new TYPE_1 ( VAR_1 ) ; VAR_2 . METHOD_2 ( event ) ; METHOD_3 ( VAR_2 , METHOD_4 ( 1 ) ) . METHOD_5 ( METHOD_6 ( VAR_3 ) , METHOD_7 ( TYPE_2 . class ) ) ; <START> METHOD_3 ( VAR_4 ) . METHOD_8 ( true ) ; <END> }
<|startcomment|> METHOD_4 ( ) a generic interface need type cast anymore <|endcomment|> public static < T extends TYPE_1 > T METHOD_1 ( T instance ) throws Exception { byte [ ] VAR_1 = METHOD_2 ( instance ) ; T result = ( T ) METHOD_3 ( VAR_1 ) ; <START> Object VAR_2 = result . VAR_3 ( ) . METHOD_4 ( TYPE_2 . class ) ; <END> TYPE_2 VAR_4 = ( TYPE_2 ) VAR_2 ; VAR_4 . METHOD_5 ( ) ; return result ; }
<|startcomment|> line wrap <|endcomment|> <START> public void METHOD_1 ( TYPE_1 VAR_1 , Collection < TYPE_2 > VAR_2 ) { <END> for ( TYPE_3 VAR_3 : VAR_4 ) { VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; } }
<|startcomment|> checks parameter null update version takes a List check entries null s update line call version <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_2 ... VAR_2 ) { if ( VAR_1 == null ) { throw new TYPE_3 ( STRING_1 ) ; } VAR_3 . add ( VAR_1 ) ; <START> VAR_3 . addAll ( Arrays . asList ( VAR_2 ) ) ; <END> return this ; }
<|startcomment|> instanceof <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; try { VAR_2 = ( TYPE_2 ) VAR_1 ; <START> } catch ( final TYPE_3 e ) { <END> TYPE_4 . e ( VAR_1 . getClass ( ) . getName ( ) , STRING_1 , TYPE_2 . class . getName ( ) ) ; } }
<|startcomment|> need careful t assume classification problems - 1 ( dimension ) instead <|endcomment|> private void METHOD_1 ( ) { VAR_1 = METHOD_2 ( VAR_2 . next ( ) ) ; VAR_3 = VAR_1 . METHOD_3 ( ) . size ( 1 ) ; VAR_4 = VAR_1 . METHOD_4 ( ) . size ( 1 ) ; <START> VAR_5 = VAR_1 . METHOD_5 ( ) ; <END> }
<|startcomment|> log info ( ) VAR_2 info ( ) <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 . METHOD_2 ( VAR_3 ) ; TYPE_3 . METHOD_3 ( VAR_3 ) ; VAR_4 = TYPE_4 . METHOD_4 ( VAR_3 ) ; VAR_5 = TYPE_5 . METHOD_4 ( VAR_6 ) ; VAR_7 = TYPE_6 . create ( VAR_4 , VAR_5 ) ; VAR_8 = VAR_1 . METHOD_5 ( ) ; <START> log . info ( String . format ( STRING_1 , VAR_6 , VAR_3 ) ) ; <END> }
<|startcomment|> I don t need change similar structure _CODE_ don t override METHOD_1 ( ) logic <|endcomment|> protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( this . VAR_1 == null ) { <START> this . VAR_1 = new TYPE_1 ( super . METHOD_2 ( ) ) ; <END> this . VAR_1 . METHOD_3 ( new TYPE_2 ( ) ) ; this . VAR_1 . METHOD_4 ( METHOD_5 ( ) ) ; if ( this . VAR_2 != null ) { this . VAR_1 . METHOD_6 ( this . VAR_2 ) ; } this . VAR_1 . METHOD_7 ( ) ; } this . VAR_1 . METHOD_8 ( this ) ; }
<|startcomment|> some unit tests ? handle extraneous whitespaces <|endcomment|> <START> public static Pair < Integer , Integer > METHOD_1 ( String type ) { <END> String VAR_1 = type . substring ( INT_1 , type . length ( ) - 1 ) ; String [ ] params = VAR_1 . split ( STRING_1 ) ; return new Pair < > ( Integer . parseInt ( params [ 0 ] . trim ( ) ) , Integer . parseInt ( params [ 1 ] . trim ( ) ) ) ; }
<|startcomment|> don t extensions public remain <|endcomment|> <START> static String METHOD_1 ( String VAR_1 , String VAR_2 ) <END> { return TYPE_1 . METHOD_2 ( VAR_1 . isEmpty ( ) ? null : VAR_1 , VAR_2 ) + STRING_1 ; }
<|startcomment|> I find strange constructor some work catch surprise especially wants concatenate iterators I d hasNext ( ) ( ) advanced s more predictable similar logic _CODE_ similar TYPE_4 < Path _CODE_ > <|endcomment|> <START> <END> public <END> TYPE_4 <END> ( <END> Collection <END> < <END> TYPE_1 <END> > <END> source , <END> TYPE_2 <END> < <END> TYPE_1 <END> , TYPE_3 > <END> VAR_2 <END> ) <END> { <END> <END> this . VAR_3 <END> =
<|startcomment|> remove ( a b ) equals TYPE_1 remove ( a ) ! = b instead <|endcomment|> public boolean METHOD_1 ( Collection < ? > c ) { boolean VAR_1 = false ; for ( TYPE_1 x : ( Collection < ? extends TYPE_1 > ) c ) { <START> if ( map . remove ( x . VAR_2 ( ) , x ) ) { <END> VAR_1 = true ; } } if ( VAR_1 ) { METHOD_2 ( ) ; } return VAR_1 ; }
<|startcomment|> s remove system outs <|endcomment|> public void run ( String ... VAR_1 ) throws Exception { <START> System . out . println ( STRING_1 ) ; <END> }
<|startcomment|> initialized super class <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> VAR_3 = new HashMap < > ( ) ; VAR_4 = new HashMap < > ( ) ; <END> METHOD_1 ( ) ; }
<|startcomment|> else unnecessary <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; <START> } else { <END> this . VAR_1 = VAR_1 ; logger . trace ( STRING_2 , VAR_1 . getClass ( ) ) ; } }
<|startcomment|> I don t hurts line 96 sets window tbr false I property changed <|endcomment|> public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . remove ( VAR_2 ) ; VAR_3 . METHOD_1 ( ) ; VAR_4 . METHOD_1 ( ) ; VAR_5 . METHOD_1 ( ) ; <START> VAR_2 . METHOD_3 ( false ) ; <END> VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ; VAR_2 . METHOD_4 ( ) . METHOD_1 ( ) ; ( ( TYPE_1 ) VAR_2 . METHOD_6 ( ) ) . METHOD_1 ( ) ; }
<|startcomment|> executor shouldn t needed <|endcomment|> public void METHOD_1 ( ) { n = new TYPE_1 ( ) ; VAR_1 = new TYPE_2 ( ) ; <START> TYPE_3 . METHOD_2 ( n , TYPE_3 . METHOD_3 ( TYPE_5 . VAR_3 , new TYPE_4 ( ) ) ) ; <END> n . start ( ) ; n . VAR_4 ( VAR_1 ) ; }
<|startcomment|> final char VAR_1 ; <|endcomment|> public char METHOD_1 ( ) { <START> char VAR_1 ; <END> switch ( getType ( ) ) { case VAR_2 : VAR_1 = VAR_3 . VAR_4 ; break ; case VAR_5 : VAR_1 = VAR_3 . VAR_6 ; break ; case VAR_7 : VAR_1 = VAR_3 . VAR_8 ; break ; default : VAR_1 = CHAR_1 ; } return VAR_1 ; }
<|startcomment|> I prefer move call private TYPE_1 constructor <|endcomment|> public TYPE_1 METHOD_1 ( int from , int length ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( from , length ) ; <START> VAR_3 . METHOD_3 ( ) ; <END> return new TYPE_1 ( VAR_1 , VAR_3 ) ; }
<|startcomment|> set races dereference L101 NPE besides set VAR_1 essentially ( a transparent _CODE_ layer ) don t need field call unsubscribe ( ) L101 <|endcomment|> public static < T > TYPE_1 < T > METHOD_1 ( final TYPE_2 < ? extends T > source ) { return new TYPE_1 < T > ( ) { @Override public Iterator < T > iterator ( ) { TYPE_3 < T > VAR_1 = new TYPE_3 < T > ( ) ; <START> VAR_1 . VAR_2 = source . VAR_3 ( ) . METHOD_2 ( VAR_1 ) ; <END> return VAR_1 ; } } ; }
<|startcomment|> discussion : sense return enum entry I guess exists method ? other alternatives return null Optional <|endcomment|> public static TYPE_1 METHOD_1 ( String id ) { for ( TYPE_1 VAR_1 : values ( ) ) { if ( VAR_1 . getId ( ) . equals ( id ) ) { return VAR_1 ; } } <START> return VAR_2 ; <END> }
<|startcomment|> please remove unnecessary brackets : return VAR_1 getStatus ( ) = = TYPE_3 down|| VAR_1 getStatus ( ) = = TYPE_3 reboot|| ( VAR_1 getStatus ( ) = = TYPE_3 _CODE_ VAR_1 METHOD_2 ( ) = = TYPE_5 VAR_8 ) ; remaining brackets necessary code more readable <|endcomment|> private boolean METHOD_1 ( TYPE_1 vds ) { TYPE_2 VAR_1 = vds . VAR_2 ( ) ; return ( ( VAR_1 . getStatus ( ) == TYPE_3 . TYPE_4 ) || ( VAR_1 . getStatus ( ) == TYPE_3 . TYPE_7 ) || ( VAR_1 . getStatus ( ) == TYPE_3 . TYPE_6 <START> && VAR_1 . METHOD_2 ( ) == TYPE_5 . VAR_8 ) ) ; <END> }
<|startcomment|> java config style d class public <|endcomment|> <START> TYPE_2 ( TYPE_1 < ? > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> needs a substring <|endcomment|> public void METHOD_1 ( String content , int length ) { METHOD_2 ( VAR_1 ) ; <START> VAR_1 . METHOD_3 ( content . substring ( 0 , length ) ) ; <END> TYPE_1 . log ( STRING_1 , STRING_2 + content . substring ( 0 , length ) + STRING_3 , true ) ; }
<|startcomment|> inline <|endcomment|> public TYPE_1 < TYPE_2 > read ( TYPE_3 configuration ) throws IOException { TYPE_4 < TYPE_2 > reader = view . VAR_1 ( ) ; <START> return reader ; <END> }
<|startcomment|> constant please convert case <|endcomment|> public void METHOD_1 ( final long VAR_1 ) { <START> VAR_2 = VAR_1 ; <END> }
<|startcomment|> copy - paste sections starting clutter presenter please extract a common denominator ( e g a function ) reduce repeating code snippets <|endcomment|> public void METHOD_1 ( ) { <START> if ( VAR_1 . METHOD_2 ( ) && ! VAR_1 . METHOD_3 ( TYPE_1 . VAR_3 . VAR_4 ) ) { <END> VAR_1 . METHOD_4 ( new String [ ] { TYPE_1 . VAR_3 . VAR_4 } , VAR_5 ) ; } else { VAR_6 . METHOD_5 ( this , VAR_7 , null ) ; } }
<|startcomment|> please overloaded constructors constructor signature wont change existing test <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( 1 , STRING_1 , <START> 10 , true , false , true ) ; <END> TYPE_1 VAR_2 = new TYPE_1 ( 1 , STRING_1 , 10 , true , false , true ) ; assertEquals ( VAR_1 , VAR_2 ) ; TYPE_1 VAR_3 = new TYPE_1 ( 1 , STRING_1 , 10 , false , false , true ) ; METHOD_2 ( VAR_1 . equals ( VAR_3 ) ) ; }
<|startcomment|> don t need a private variable storing link preview line METHOD_3 ( ) function finds dialog tag ( ) cast return function a TYPE_2 call dismiss ( ) <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { final String VAR_3 = STRING_1 ; if ( METHOD_2 ( ) . METHOD_3 ( VAR_3 ) == null ) { <START> VAR_4 = TYPE_2 . METHOD_4 ( VAR_1 , VAR_2 ) ; <END> VAR_4 . METHOD_5 ( METHOD_2 ( ) , VAR_3 ) ; } }
<|startcomment|> IMO ( ) { } code easy read I meant { } missing : ) edit : s <|endcomment|> public void clear ( ) { <START> if ( VAR_1 instanceof TYPE_1 ) <END> try { ( ( TYPE_1 ) VAR_1 ) . clear ( ) ; } catch ( TYPE_2 e ) { throw METHOD_1 ( e ) ; } }
<|startcomment|> file needs some work ensure works client <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> return VAR_1 ; }
<|startcomment|> private <|endcomment|> <START> TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < ? , ? > cache ) { <END> if ( ! VAR_1 . METHOD_2 ( ) ) return VAR_1 ; TYPE_1 VAR_2 = cache . VAR_3 ( ) . METHOD_3 ( ) ; if ( VAR_2 == null ) return VAR_1 ; if ( VAR_2 . equals ( TYPE_1 . VAR_4 ) ) return VAR_5 ; if ( VAR_2 . METHOD_4 ( TYPE_1 . VAR_6 ) ) return VAR_7 ; return VAR_1 ; }
<|startcomment|> removed <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = new TYPE_2 ( VAR_1 , SWT . VAR_3 ) ; VAR_2 . setText ( METHOD_2 ( ) ) ; <START> VAR_2 . METHOD_3 ( METHOD_4 ( e - > { <END> } ) ) ; }
<|startcomment|> additional check other instructions needed <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 || ! name . isEmpty ( ) ) <END> return getName ( ) ; return VAR_1 . METHOD_2 ( STRING_1 ) ; }
<|startcomment|> catch <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( VAR_3 . METHOD_3 ( ) ) ; try { VAR_4 = TYPE_3 . run ( VAR_1 , VAR_2 , true ) ; } catch ( Exception e ) { <START> throw e ; <END> } }
<|startcomment|> a log error statement needs space <|endcomment|> public String toString ( ) { TYPE_1 writer = new TYPE_1 ( ) ; try { new TYPE_2 ( ) . METHOD_1 ( writer , VAR_1 ) ; } catch ( Exception e ) { log . debug ( STRING_1 , e ) ; <START> } <END> return writer . toString ( ) ; }
<|startcomment|> replacing lines : ( VAR_2 objects _CODE_ ( task ) VAR_4 ( ) task task ( ) VAR_3 ) ; removing TODO line <|endcomment|> public TYPE_2 ( String VAR_2 , TYPE_1 task , long VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_4 = task . VAR_4 ( ) ; this . task = task . task ( ) ; <START> this . VAR_3 = VAR_3 ; <END> }
<|startcomment|> add envelope section METHOD_5 method file <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 input , TYPE_3 VAR_1 , TYPE_4 type , int length ) { switch ( type ) { case VAR_2 : return METHOD_2 ( input ) ; case VAR_3 : case VAR_4 : case VAR_5 : case VAR_6 : case VAR_7 : return METHOD_3 ( input , VAR_1 , type , length ) ; case VAR_8 : return METHOD_4 ( input , VAR_1 ) ; case VAR_9 : <START> return TYPE_1 . METHOD_5 ( METHOD_6 ( input ) , null ) ; <END> default : throw new IllegalArgumentException ( STRING_1 + type ) ; } }
<|startcomment|> set null values field <|endcomment|> public void close ( ) { <START> VAR_1 = null ; <END> }
<|startcomment|> need account probe batch size processing a spilled partition account _CODE_ late prefetched probe side batch <|endcomment|> public boolean METHOD_1 ( ) { long VAR_1 = ( VAR_2 . METHOD_2 ( VAR_3 ) . METHOD_3 ( ) + 4 ) * VAR_4 ; long VAR_5 = VAR_2 . METHOD_4 ( ) ; <START> long VAR_6 = VAR_7 . METHOD_5 ( ) - VAR_7 . METHOD_6 ( ) - VAR_5 ; <END> boolean VAR_8 = VAR_9 * VAR_1 > VAR_6 ; if ( VAR_8 ) { logger . debug ( STRING_1 , VAR_1 , VAR_6 , VAR_5 ) ; } return VAR_8 ; }
<|startcomment|> shouldn t throwing run - time exceptions close called <|endcomment|> public void close ( ) { try { TYPE_1 . result ( VAR_1 . close ( ) ) ; } catch ( Exception e ) { final String VAR_2 = STRING_1 ; LOG . error ( VAR_2 , e ) ; <START> throw new RuntimeException ( VAR_2 ) ; <END> } }
<|startcomment|> bug 517068 targeting 0 INT_1 1 0 INT_1 100 backported 0 INT_1 1 <|endcomment|> private boolean METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 ) ; TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) ; <START> TYPE_3 VAR_3 = new TYPE_3 ( 0 , INT_1 , 100 ) ; <END> return VAR_2 . METHOD_4 ( VAR_3 ) >= 0 ; }
<|startcomment|> return StringUtils equals ( VAR_1 METHOD_2 ( ) VAR_2 METHOD_2 ( ) ) && StringUtils equals ( VAR_1 METHOD_3 ( ) VAR_2 METHOD_3 ( ) ) ; <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> if ( StringUtils . equals ( VAR_1 . METHOD_2 ( ) , VAR_2 . METHOD_2 ( ) ) <END> && StringUtils . equals ( VAR_1 . METHOD_3 ( ) , VAR_2 . METHOD_3 ( ) ) ) { return true ; } return false ; }
<|startcomment|> I tuple size 3 I ll fix <|endcomment|> public < TYPE_1 > TYPE_2 < T > METHOD_1 ( TYPE_3 type , TYPE_1 value ) { <START> List < Object > VAR_1 = new ArrayList < > ( parameters . size ( ) + 3 ) ; <END> VAR_1 . addAll ( parameters ) ; VAR_1 . add ( type ) ; VAR_1 . add ( value ) ; return new TYPE_2 < T > ( VAR_2 , VAR_3 , VAR_4 , VAR_1 ) ; }
<|startcomment|> < 0 ? want import a 0 nanosecond range <|endcomment|> private boolean METHOD_1 ( ) { boolean isEmpty = VAR_1 . METHOD_2 ( ) . isEmpty ( ) || VAR_2 . METHOD_2 ( ) . isEmpty ( ) ; return ! isEmpty && METHOD_3 ( ) && VAR_3 . METHOD_4 ( VAR_4 ) <= 0 ; <START> } <END>
<|startcomment|> move VAR_3 declaration line final <|endcomment|> public static String METHOD_1 ( final String VAR_1 , final TYPE_1 VAR_2 ) { String VAR_3 = "" ; StringBuilder VAR_4 = new StringBuilder ( ) ; VAR_4 . append ( VAR_2 . METHOD_2 ( ) ) ; VAR_4 . append ( File . VAR_5 ) ; VAR_4 . append ( TYPE_2 . METHOD_3 ( VAR_1 ) ) ; <START> VAR_3 = VAR_4 . toString ( ) ; <END> return VAR_3 ; }
<|startcomment|> line removed <|endcomment|> protected void METHOD_1 ( final TYPE_1 map , final TYPE_2 status ) { METHOD_2 ( new TYPE_3 < TYPE_1 > ( ) { ANNOTATION_1 ( STRING_1 ) @Override public TYPE_1 METHOD_3 ( ) { <START> TYPE_4 context = METHOD_4 ( ) ; <END> context . VAR_1 ( map , map . VAR_2 ( ) ) ; map . VAR_3 ( status ) ; METHOD_5 ( ) . METHOD_6 ( map . getId ( ) , map . VAR_2 ( ) ) ; METHOD_4 ( ) . METHOD_7 ( ) ; return null ; } } ) ; }
<|startcomment|> remove final modifier <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) . is ( TYPE_5 . TYPE_4 . VAR_4 ) ) { TYPE_2 VAR_5 = ( TYPE_2 ) VAR_1 . METHOD_2 ( ) ; <START> final TYPE_3 VAR_6 = VAR_5 . METHOD_3 ( ) . METHOD_4 ( ) ; <END> if ( VAR_6 != null && VAR_6 . METHOD_5 ( ) ) { return ; } } if ( VAR_1 . METHOD_2 ( ) . METHOD_6 ( ) . METHOD_7 ( STRING_1 ) ) { return ; } super . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> need a fallback mechanism server a fallback mechanism greater scope lets METHOD_5 implementation client optimisation client addressed <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 key , TYPE_3 < ? super TYPE_2 , ? super TYPE_1 , ? extends TYPE_1 > VAR_1 ) { METHOD_2 ( key , VAR_2 ) ; METHOD_2 ( key , VAR_3 ) ; <START> if ( TYPE_4 . METHOD_3 ( VAR_1 ) ) { <END> TYPE_5 < TYPE_2 , TYPE_1 > VAR_4 = new TYPE_5 < > ( VAR_1 ) ; return METHOD_4 ( key , VAR_4 ) ; } else { return METHOD_5 ( key , VAR_1 ) ; } }
<|startcomment|> don t need check loop won t enter VAR_4 empty avoid multiple returns <|endcomment|> public void METHOD_1 ( TYPE_1 task , String stream , List < Object > values , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = task . VAR_3 ( stream , values ) ; List < Integer > VAR_4 = task . VAR_5 ( stream , values ) ; <START> if ( VAR_4 . size ( ) == 0 ) { <END> return ; } for ( Integer t : VAR_4 ) { VAR_1 . METHOD_2 ( t , VAR_2 ) ; } }
<|startcomment|> I m mistaken don t need reload server restart services parent resource leverage _CODE_ <|endcomment|> TYPE_5 ( TYPE_1 path ) { <START> super ( path , TYPE_2 . METHOD_1 ( Constants . VAR_2 , Constants . VAR_3 , path . getValue ( ) ) , new TYPE_3 ( ) , new TYPE_4 ( ) ) ; <END> }
<|startcomment|> throws <|endcomment|> @Override public TYPE_1 METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; try { if ( VAR_2 . isEmpty ( ) ) { return null ; } TYPE_1 VAR_3 = VAR_2 . METHOD_3 ( ) ; VAR_2 . remove ( ) ; return VAR_3 ; } catch ( IOException e ) { TYPE_3 < TYPE_2 > METHOD_4 ( e ) ; <START> return null ; <END> } finally { VAR_1 . METHOD_5 ( ) ; } }
<|startcomment|> log tracef <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { <START> log . info ( STRING_1 ) ; <END> TYPE_3 VAR_1 ; VAR_1 = VAR_2 . METHOD_2 ( ) ; TYPE_4 . METHOD_3 ( VAR_1 ) ; TYPE_4 . METHOD_3 ( VAR_1 ) ; try { TYPE_4 . METHOD_4 ( VAR_2 ) ; } catch ( InterruptedException VAR_3 ) { Thread . VAR_4 ( ) . METHOD_5 ( ) ; throw new TYPE_2 ( STRING_2 , VAR_3 ) ; } }
<|startcomment|> doesn t need public <|endcomment|> <START> public TYPE_1 ( boolean VAR_2 ) { <END> this . VAR_3 = VAR_2 ; }
<|startcomment|> add boolean expression line #1377 <|endcomment|> public boolean METHOD_1 ( TYPE_1 vm , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 VAR_3 = VAR_1 . METHOD_2 ( ) . get ( 0 ) ; String VAR_4 = METHOD_3 ( vm , VAR_1 , VAR_2 ) ; boolean VAR_5 = ! STRING_1 . equals ( VAR_4 ) || ( VAR_3 == TYPE_4 . VAR_6 && TYPE_5 . METHOD_4 ( vm . VAR_7 ( ) ) ) ; if <START> ( VAR_2 . METHOD_5 ( ) != null ) { <END> VAR_5 = false ; } return VAR_5 ; }
<|startcomment|> lines 316 - 319 rewritten asreturn execute ( request ! METHOD_1 ( ) monitor ) ; <|endcomment|> public < T > T execute ( TYPE_1 < T > request , TYPE_2 monitor ) throws IOException , TYPE_3 { if ( ! METHOD_1 ( ) ) { return execute ( request , true , monitor ) ; } <START> return execute ( request , false , monitor ) ; <END> }
<|startcomment|> METHOD_1 called setText instead ? text changed construction highlighted <|endcomment|> public TYPE_1 ( final String text , final String token , final String VAR_2 ) { super ( text , token ) ; <START> METHOD_1 ( text , VAR_2 ) ; <END> }
<|startcomment|> guideline I prefer protected visibility package protected <|endcomment|> <START> String METHOD_1 ( Collection < String > VAR_1 ) { <END> if ( VAR_1 . isEmpty ( ) ) { return "" ; } else { return TYPE_1 . VAR_3 + STRING_1 + String . VAR_4 ( STRING_1 , VAR_1 ) ; } }
<|startcomment|> I prefer IOException thrown METHOD_1 catching test fail harder debug <|endcomment|> private List METHOD_1 ( List VAR_1 , Map conf ) { List VAR_2 = null ; try { VAR_2 = METHOD_2 ( METHOD_3 ( VAR_1 , conf ) , conf ) ; <START> } catch ( IOException e ) { <END> LOG . error ( STRING_1 , e ) ; } return VAR_2 ; }
<|startcomment|> VAR_6 ? AFAICT I add boot service installed immediately d redeploy app module doesn t require a reload a process restart <|endcomment|> public TYPE_8 ( ) { super ( new TYPE_4 . TYPE_5 ( TYPE_2 . METHOD_1 ( TYPE_6 . VAR_3 ) , TYPE_3 . METHOD_2 ( TYPE_6 . VAR_3 ) ) <START> . METHOD_3 ( TYPE_7 . TYPE_9 . VAR_6 ) <END> . METHOD_4 ( TYPE_7 . TYPE_9 . VAR_6 ) . METHOD_5 ( TYPE_8 . VAR_7 ) . METHOD_6 ( TYPE_8 . VAR_8 ) . METHOD_7 ( VAR_9 ) ) ; }
<|startcomment|> remove <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 ) ; <START> this . VAR_4 <END> = VAR_3 ; }
<|startcomment|> I confused supposed <|endcomment|> public String METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( "" ) <END> . add ( STRING_1 , METHOD_3 ( VAR_1 ) ) . add ( STRING_2 , VAR_2 ) . add ( STRING_3 , VAR_3 ) . add ( STRING_4 , VAR_4 ) . METHOD_4 ( ) . toString ( ) ; }
<|startcomment|> boolean parameter useful enums more clear means <|endcomment|> public TYPE_2 ( ) { <START> this ( null , false , null , new TYPE_1 < > ( ) , new TYPE_1 < > ( ) , null ) ; <END> }
<|startcomment|> cast needed <|endcomment|> public void METHOD_1 ( String VAR_1 ) { TYPE_1 command = METHOD_2 ( ) ; <START> description = ( String ) command . VAR_2 ( VAR_3 ) ; <END> }
<|startcomment|> shouldn t VAR_1 validated existence prior accessing <|endcomment|> protected void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . get ( getParameters ( ) . getId ( ) ) ; <END> TYPE_2 client = METHOD_4 ( ) . create ( VAR_1 ) ; METHOD_5 ( ) . METHOD_6 ( client . VAR_2 ( ) ) ; }
<|startcomment|> some tests VAR_1 clear ( ) some don t I guess s tests assume tests executed a random order start a clean state a [ method ( _CODE_ ) ] ( ) clear TYPE_5 a good idea create a static util method others benefit <|endcomment|> public void METHOD_1 ( ) { Context context = TYPE_1 . METHOD_2 ( ) ; TYPE_5 . TYPE_6 VAR_1 = TYPE_3 . METHOD_3 ( context ) . METHOD_4 ( ) ; VAR_1 . METHOD_5 ( TYPE_7 . VAR_3 , false ) ; <START> VAR_1 . clear ( ) ; <END> VAR_1 . commit ( ) ; TYPE_4 VAR_4 = new TYPE_4 ( context ) ; METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; }
<|startcomment|> simplified a single return statementprotected boolean METHOD_1 ( List < TYPE_1 > VAR_1 ) { return TYPE_2 METHOD_2 ( VAR_1 METHOD_3 ( ) METHOD_4 ( ) METHOD_5 ( ) ) ; } <|endcomment|> <START> protected boolean METHOD_1 ( List < TYPE_1 > VAR_1 ) { <END> if ( ! TYPE_2 . METHOD_2 ( VAR_1 , METHOD_3 ( ) , METHOD_4 ( ) . METHOD_5 ( ) ) ) { return false ; } else { return true ; } }
<|startcomment|> typo - - > ; ; <|endcomment|> private TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) throws InterruptedException { log . info ( STRING_1 ) ; TYPE_1 < TYPE_2 > VAR_2 = new TYPE_1 < > ( ) ; this . VAR_3 = METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; VAR_4 = new TYPE_4 ( VAR_1 , <START> VAR_3 , VAR_2 ) ; ; <END> return VAR_2 ; }
<|startcomment|> I change order : assertTrue ( VAR_1 < VAR_5 ) ; assertTrue ( VAR_5 < VAR_4 ) ; assertTrue ( VAR_4 < VAR_3 ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { long VAR_1 = METHOD_2 ( 4 ) ; long VAR_2 = METHOD_2 ( 4 ) ; long VAR_3 = METHOD_2 ( 2 ) ; METHOD_3 ( VAR_2 ) ; long VAR_4 = METHOD_2 ( 1 ) ; long VAR_5 = METHOD_2 ( 1 ) ; <START> assertTrue ( STRING_1 , VAR_4 > VAR_5 ) ; assertTrue ( STRING_2 , VAR_4 < VAR_3 ) ; assertTrue ( STRING_3 , VAR_5 > VAR_1 ) ; <END> }
<|startcomment|> add System println ( ) call ? a logger a solution <|endcomment|> public void METHOD_1 ( ) { TYPE_1 path = TYPE_1 . create ( STRING_1 ) ; TYPE_2 . METHOD_2 ( TYPE_1 . create ( STRING_1 ) ) ; <START> System . out . println ( TYPE_2 . METHOD_3 ( ) ) ; <END> assertEquals ( STRING_2 , path , TYPE_1 . create ( STRING_1 ) ) ; }
<|startcomment|> please move check assigning variables <|endcomment|> public TYPE_5 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 child , ANNOTATION_1 ( STRING_2 ) TYPE_2 context , ANNOTATION_1 ( STRING_3 ) TYPE_3 VAR_2 ) { super ( child , VAR_2 , context . VAR_3 ( ) , Collections . VAR_4 ( ) , FLOAT_1 ) ; <START> this . context = context ; <END> this . VAR_2 = VAR_2 ; TYPE_4 . METHOD_1 ( context . VAR_5 ( ) , STRING_4 ) ; }
<|startcomment|> please log error inform user <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { try { VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; } catch ( TYPE_2 e ) { <START> TYPE_3 . METHOD_4 ( VAR_3 , STRING_1 + VAR_1 . METHOD_5 ( ) , e ) ; <END> logger . error ( VAR_3 + STRING_1 + VAR_1 . METHOD_5 ( ) , e ) ; } }
<|startcomment|> private static <|endcomment|> <START> private String METHOD_1 ( TYPE_1 VAR_1 ) <END> { return new TYPE_2 ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) . toString ( ) . METHOD_4 ( STRING_1 , STRING_2 ) ; }
<|startcomment|> private method <|endcomment|> <START> public String METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> sense check duplicated email ? IMO I sense hardcoded username email users ? I delete line completely delete methods METHOD_5 _CODE_ instead implement method _CODE_ _CODE_ throw error case username email configured user model attribute <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 user , TYPE_3 VAR_2 , boolean VAR_3 ) { String VAR_4 = METHOD_2 ( ) ; String VAR_5 = METHOD_3 ( ) ; TYPE_4 < Object > VAR_6 = VAR_7 . get ( VAR_4 . METHOD_4 ( ) ) ; if ( VAR_6 != null ) { <START> METHOD_5 ( VAR_4 , VAR_5 , VAR_2 , VAR_8 . METHOD_6 ( ) , user ) ; <END> METHOD_7 ( VAR_6 , user , VAR_5 ) ; } else { user . VAR_9 ( VAR_4 , Arrays . asList ( VAR_5 ) ) ; } }
<|startcomment|> boolean instead Boolean <|endcomment|> <START> public Boolean METHOD_1 ( TYPE_1 VAR_1 ) <END> { return METHOD_2 ( ( ) - > { final Boolean result = METHOD_3 ( VAR_1 ) ; LOG . info ( STRING_1 + VAR_1 ) ; return result ; } ) ; }
<|startcomment|> isn t needed anymore <|endcomment|> public static void METHOD_1 ( File VAR_1 , TYPE_1 factory , String VAR_2 ) throws IOException , <START> InterruptedException , TYPE_5 . TYPE_6 { <END> final int VAR_3 = METHOD_2 ( VAR_2 ) ; LOG . info ( STRING_1 , VAR_3 ) ; TYPE_3 VAR_4 = new TYPE_3 ( VAR_1 , VAR_1 , INT_1 ) ; factory . VAR_5 ( VAR_4 ) ; Assert . assertTrue ( STRING_2 , TYPE_4 . METHOD_3 ( STRING_3 + VAR_3 , VAR_6 , factory . VAR_7 ( ) ) ) ; }
<|startcomment|> want change hamcrest method matchers compare objects equals <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_2 = new TYPE_2 ( VAR_3 , VAR_4 , VAR_1 , VAR_5 , VAR_6 ) ; when ( VAR_3 . METHOD_2 ( ) ) . METHOD_3 ( Arrays . asList ( VAR_7 ) ) ; VAR_2 . METHOD_4 ( ) ; assertEquals ( STRING_1 + Arrays . asList ( VAR_7 ) . toString ( ) + STRING_2 , VAR_1 . METHOD_5 ( ) ) ; <START> } <END>
<|startcomment|> wouldn t want conditions check prior assignments <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , String VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; TYPE_2 . METHOD_2 ( VAR_3 , STRING_2 ) ; <END> }
<|startcomment|> wrap a simple long <|endcomment|> public TYPE_2 ( Object source , long VAR_2 , ANNOTATION_1 String id , String ... VAR_3 ) { super ( source ) ; <START> this . VAR_2 = TYPE_1 . METHOD_1 ( VAR_2 ) ; <END> this . VAR_4 = id ; this . VAR_3 = Arrays . asList ( VAR_3 ) ; }
<|startcomment|> break loop early finding target module <|endcomment|> public static TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( ) ; TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( ) ; if ( VAR_3 != null ) { TYPE_4 VAR_4 = VAR_3 . METHOD_4 ( ) ; while ( VAR_4 . METHOD_5 ( ) ) { TYPE_5 m = ( TYPE_5 ) VAR_4 . METHOD_6 ( ) ; if ( m instanceof TYPE_1 ) { <START> VAR_1 = ( TYPE_1 ) m ; <END> } } } } return VAR_1 ; }
<|startcomment|> NPE <|endcomment|> public String METHOD_1 ( ) { <START> return TYPE_1 . getInstance ( ) . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; <END> }
<|startcomment|> please move METHOD_5 final statement done case please delete e VAR_5 ( ) ; - doesn t bring please delete METHOD_6 ( e getMessage ( ) ) ; - unexpected exceptions thrown test method _CODE_ handle a failing test printing exception stacktrace log <|endcomment|> public void METHOD_1 ( ) throws Exception { Long VAR_1 = VAR_2 . METHOD_2 ( VAR_3 , VAR_4 ) ; assertNotNull ( VAR_1 ) ; assertTrue ( VAR_1 . METHOD_3 ( ) > 0 ) ; try { <START> METHOD_4 ( VAR_3 , VAR_1 ) ; <END> } catch ( Exception e ) { VAR_2 . METHOD_5 ( VAR_3 , VAR_1 ) ; e . VAR_5 ( ) ; METHOD_6 ( e . getMessage ( ) ) ; } }
<|startcomment|> calling METHOD_3 ( VAR_1 ) app installed dropins location configured <|endcomment|> private void METHOD_1 ( String VAR_1 ) throws Exception { String VAR_2 = METHOD_2 ( ) ; if ( VAR_2 . equalsIgnoreCase ( STRING_1 ) && ! METHOD_3 ( VAR_1 ) ) { VAR_3 . METHOD_4 ( VAR_1 ) ; } <START> else if ( VAR_2 . equalsIgnoreCase ( STRING_2 ) && METHOD_5 ( ) ) <END> throw new TYPE_1 ( VAR_4 . getString ( STRING_3 ) ) ; }
<|startcomment|> please add private modifier <|endcomment|> <START> static TYPE_1 METHOD_1 ( Context ctx ) { <END> return ctx . VAR_1 ( VAR_2 , null ) ; }
<|startcomment|> I d inline conform rest class <|endcomment|> public long METHOD_1 ( Guid VAR_1 ) { <START> TYPE_1 params = METHOD_2 ( ) . METHOD_3 ( STRING_1 , VAR_1 ) ; <END> return METHOD_4 ( ) . METHOD_5 ( STRING_2 , METHOD_6 ( ) , params ) ; }
<|startcomment|> necessary wait 100 milliseconds ? Thread VAR_2 ( 1 ) Thread yield ( ) <|endcomment|> public TYPE_1 ( ) { try { <START> Thread . VAR_2 ( 100 ) ; <END> Thread . VAR_2 ( 100 ) ; VAR_3 = 1 ; } catch ( InterruptedException VAR_4 ) { throw new RuntimeException ( VAR_4 ) ; } }
<|startcomment|> _CODE_ METHOD_3 ( ) VAR_3 ( Optional VAR_4 ) length > 0 checked calling METHOD_2 ? method METHOD_2 modifies field reflection optionally recursively calls costly <|endcomment|> private static boolean METHOD_1 ( Class VAR_1 , TYPE_1 VAR_2 ) { TYPE_2 field = METHOD_2 ( VAR_1 , VAR_2 . getName ( ) ) ; return field != null ? field . VAR_3 ( Optional . VAR_4 ) . length > 0 <START> || VAR_2 . METHOD_3 ( ) . METHOD_4 ( Optional . VAR_4 ) . length > 0 <END> : VAR_2 . METHOD_3 ( ) . METHOD_4 ( Optional . VAR_4 ) . length > 0 ; }
<|startcomment|> method required ? didn t code <|endcomment|> public int METHOD_1 ( ) { return VAR_1 ; <START> } <END>
<|startcomment|> I don t want pass TYPE_4 TYPE_3 call ( ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 entry ) throws IOException { if ( entry == null ) { return null ; } TYPE_1 VAR_1 = METHOD_2 ( entry ) . METHOD_1 ( ) ; if ( entry . VAR_2 ( ) == TYPE_5 . VAR_4 ) { <START> VAR_1 = new TYPE_3 ( VAR_1 , new TYPE_4 ( true ) , <END> ( int ) entry . VAR_5 ( ) ) ; } return VAR_1 ; }
<|startcomment|> explain idea storing transformation else ( beginning repaint ( ) ) ? worth information compare _CODE_ ( ) - - date _CODE_ transformation a - atomar opration betwenn METHOD_2 ( ) _CODE_ ( ) calls <|endcomment|> private org . VAR_1 . VAR_2 . VAR_3 . TYPE_1 METHOD_1 ( ) { org . VAR_1 . VAR_2 . VAR_3 . TYPE_1 VAR_4 ; TYPE_2 VAR_5 = VAR_6 . METHOD_2 ( ) ; <START> this . VAR_7 = VAR_6 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; <END> if ( VAR_5 != null ) VAR_4 = TYPE_3 . METHOD_6 ( VAR_5 , false ) ; else { VAR_4 = new TYPE_1 ( METHOD_7 ( ) , METHOD_8 ( ) , METHOD_9 ( ) ) ; } return VAR_4 ; }
<|startcomment|> nullable <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 event ) { TYPE_1 VAR_1 = METHOD_2 ( event ) ; if ( VAR_1 == null ) { synchronized ( VAR_2 ) { String VAR_3 = event . VAR_4 ( ) . METHOD_3 ( ) ; <START> VAR_1 = METHOD_4 ( VAR_2 , event . VAR_5 ( ) . METHOD_5 ( ) , VAR_3 , event . VAR_4 ( ) . getName ( ) ) ; <END> VAR_6 . put ( VAR_3 , VAR_1 ) ; } } return VAR_1 ; }
<|startcomment|> need <|endcomment|> public static TYPE_1 < TYPE_2 > METHOD_1 ( ) { return VAR_1 - > { VAR_1 = METHOD_2 ( VAR_1 ) ; if ( VAR_1 instanceof TYPE_3 && METHOD_3 ( VAR_1 ) && ! METHOD_4 ( VAR_1 ) && <START> ! METHOD_5 ( VAR_1 ) ) { <END> TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; if ( VAR_2 . getType ( ) == TYPE_4 . VAR_4 ) { return ! VAR_2 . METHOD_6 ( ) . equals ( VAR_2 . METHOD_7 ( ) ) ; } } return false ; } ; }
<|startcomment|> instanceof <|endcomment|> private void METHOD_1 ( final TYPE_1 VAR_1 , final int row , final Object [ ] VAR_2 ) throws TYPE_2 { for ( int VAR_3 = 0 ; VAR_3 < VAR_4 . length ; ++ VAR_3 ) { if ( ! ( VAR_4 [ VAR_3 ] . getClass ( ) . getName ( ) <START> . equals ( TYPE_3 . class . getName ( ) ) ) ) { <END> VAR_4 [ VAR_3 ] . METHOD_2 ( VAR_1 , row , VAR_2 [ VAR_3 ] ) ; } } }
<|startcomment|> please apply changes requested review <|endcomment|> protected void update ( float VAR_1 ) { int VAR_2 ; try { <START> VAR_2 = length == null ? 0 : length . VAR_3 ( VAR_4 ) ; <END> } catch ( TYPE_1 VAR_5 ) { VAR_2 = 0 ; Log . d ( getClass ( ) . METHOD_1 ( ) , STRING_1 , VAR_5 ) ; } this . VAR_4 . VAR_6 . METHOD_2 ( VAR_4 , new TYPE_2 ( VAR_4 , VAR_2 ) ) ; }
<|startcomment|> remove line <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 , Map < String , String [ ] > VAR_2 ) { long VAR_3 = 0 ; for ( String VAR_4 : VAR_5 ) { final Long VAR_6 = METHOD_2 ( METHOD_3 ( VAR_4 , VAR_2 ) ) ; if ( VAR_6 == null ) { <START> METHOD_4 ( VAR_1 ) ; <END> return ; } else { VAR_3 += VAR_6 ; } } VAR_1 . METHOD_5 ( VAR_7 , VAR_3 ) ; }
<|startcomment|> map ( TYPE_3 METHOD_2 ( p - > p ) ) unnecessary <|endcomment|> private void close ( Path path ) throws IOException { Path VAR_1 = path . VAR_2 ( ) ; try ( TYPE_1 < Path > s = TYPE_2 . list ( VAR_1 ) ) { <START> s . filter ( p - > ! TYPE_2 . METHOD_1 ( p ) ) . map ( TYPE_3 . METHOD_2 ( p - > p ) ) <END> . forEach ( TYPE_4 . METHOD_2 ( TYPE_2 : : METHOD_3 ) ) ; } }
<|startcomment|> a general rule : unsure METHOD_3 a warning don t ! discovered principal problem mutable objects easy fix [ immutable objects ] ( ) TYPE_2 easily immutable instead suppressing warning <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( TYPE_2 . class ) . METHOD_3 ( TYPE_3 . VAR_2 ) . METHOD_4 ( ) ; <END> }
<|startcomment|> merge lines METHOD_2 return argument <|endcomment|> public TYPE_1 METHOD_1 ( String uri ) { TYPE_2 . METHOD_2 ( uri , STRING_1 ) ; <START> this . uri = uri ; <END> return this ; }
<|startcomment|> guice constructors package private removing method modifier : _CODE_ ( ANNOTATION_1 TYPE_1 < TYPE_2 > VAR_2 ) { <|endcomment|> <START> protected TYPE_3 ( ANNOTATION_1 TYPE_1 < TYPE_2 > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> rename child <|endcomment|> protected int METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( VAR_1 . getType ( ) == TYPE_1 . VAR_2 ) { return 1 ; } int count = 0 ; if ( VAR_1 . METHOD_2 ( ) ) { for ( TYPE_1 <START> resource : <END> ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) ) { count += METHOD_1 ( resource ) ; } } return count ; }
<|startcomment|> null t null ? disable VAR_1 watching interested _CODE_ method checks return method null I guess null default <|endcomment|> public String METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> File f = new File ( STRING_1 ) ; VAR_1 = f . VAR_2 ( ) ; } return VAR_1 ; }
<|startcomment|> I don t need <|endcomment|> private static void count ( Object VAR_1 , long VAR_2 , int VAR_3 , int [ ] VAR_4 ) { long input = VAR_2 ; Arrays . VAR_5 ( VAR_4 , 0 ) ; <START> if ( VAR_3 != 0 ) { <END> for ( int i = 0 ; i < VAR_3 ; i ++ ) { int VAR_6 = TYPE_1 . METHOD_1 ( VAR_1 , input ) & INT_1 ; input ++ ; VAR_4 [ VAR_6 ] ++ ; } } }
<|startcomment|> s VAR_5 want return stuck another METHOD_4 <|endcomment|> public void METHOD_1 ( List < TYPE_1 > VAR_1 , TYPE_2 monitor ) { TYPE_3 VAR_2 = new TYPE_3 ( VAR_1 , Thread . VAR_3 ( ) , monitor ) ; VAR_4 . add ( VAR_2 ) ; METHOD_2 ( ) ; boolean VAR_5 = false ; while ( ! VAR_2 . METHOD_3 ( ) ) { TYPE_4 . METHOD_4 ( ) ; if ( Thread . VAR_5 ( ) ) { <START> VAR_5 = true ; <END> } } if ( VAR_5 ) { Thread . VAR_3 ( ) . METHOD_5 ( ) ; } }
<|startcomment|> reduce debug level <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> logger . info ( STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; }
<|startcomment|> TYPE_1 qualified another TYPE_1 I s a safe assumption : - ) <|endcomment|> public boolean METHOD_1 ( ) { return METHOD_2 ( ) . filter ( parent - > parent instanceof TYPE_1 ) . map ( parent - > ( TYPE_1 ) parent ) . METHOD_3 ( TYPE_1 : : METHOD_4 ) <START> . map ( VAR_1 - > VAR_1 == this ) <END> . METHOD_5 ( false ) ; }
<|startcomment|> valueOf more ( _CODE_ ) <|endcomment|> private void METHOD_1 ( ) { log ( 3 , STRING_1 + VAR_1 + STRING_2 + VAR_2 . size ( ) + STRING_3 + STRING_4 <START> + STRING_5 + TYPE_1 . METHOD_2 ( VAR_3 . METHOD_3 ( ) ) <END> + STRING_6 + TYPE_1 . METHOD_2 ( VAR_3 . METHOD_4 ( ) ) + STRING_7 ) ; if ( METHOD_5 ( ) >= 3 ) { for ( TYPE_2 VAR_4 : VAR_2 . values ( ) ) { ( ( TYPE_3 ) VAR_4 ) . METHOD_6 ( ) ; } } }
<|startcomment|> job named STRING_1 <|endcomment|> public TYPE_1 ( TYPE_2 conf ) throws IOException { <START> super ( conf , STRING_1 ) ; <END> }
<|startcomment|> _CODE_ getProperty _CODE_ service <|endcomment|> private void METHOD_1 ( ) { if <START> ( System . getProperty ( VAR_1 ) != <END> null ) return ; String VAR_2 = METHOD_2 ( ) ; if ( VAR_2 == null ) { VAR_2 = TYPE_1 . METHOD_3 ( ) . toString ( ) ; METHOD_4 ( VAR_2 ) ; } TYPE_2 VAR_3 = VAR_4 . METHOD_5 ( ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_6 ( VAR_1 , VAR_2 ) ; } else { System . VAR_5 ( VAR_1 , VAR_2 ) ; } }
<|startcomment|> _CODE_ rid synchronized keyword ? a side note I noticed haven t enabled parallel attribute annotation completely rid need ensuring Thread safety <|endcomment|> public synchronized boolean METHOD_1 ( TYPE_1 result ) { if ( VAR_1 < VAR_2 ) { <START> ++ VAR_1 ; <END> return true ; } return false ; }
<|startcomment|> nicer explicitly cast ( TYPE_1 < T > ) please consider - working part changes <|endcomment|> public TYPE_1 < T > METHOD_1 ( TYPE_4 . TYPE_5 VAR_1 , TYPE_3 value ) throws RuntimeException { <START> return ( TYPE_1 < T > ) METHOD_2 ( VAR_1 . getInt ( ) ) ; <END> }
<|startcomment|> more readable export symbolic constants class instead null fine clearer debugging logging <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 == VAR_2 ? null : VAR_1 ; <END> }
<|startcomment|> public <|endcomment|> <START> public boolean <END> METHOD_1 ( ) { return token != null && VAR_1 != null ; }
<|startcomment|> complete method stripped : { VAR_1 = TYPE_1 valueOf ( VAR_1 ) ; } catch ( Exception e ) { / / ignore unknown null values } <|endcomment|> <START> public void METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = null ; try { VAR_2 = TYPE_1 . valueOf ( VAR_1 ) ; } catch ( Exception e ) { } this . VAR_1 = VAR_2 ; }
<|startcomment|> put config preinit please <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_2 , TYPE_10 . VAR_2 ) ; TYPE_3 . METHOD_1 ( ) ; TYPE_4 . METHOD_1 ( ) ; TYPE_5 . METHOD_1 ( ) ; <START> TYPE_3 . METHOD_3 ( TYPE_11 . VAR_5 ) ; <END> TYPE_8 . TYPE_9 . METHOD_4 ( VAR_6 , TYPE_7 . METHOD_5 ( ) ) ; TYPE_7 . METHOD_5 ( ) . METHOD_6 ( ) ; }
<|startcomment|> recycling a VAR_2 references ( member variable VAR_2 ) bound give problems some point : another thread obtain means TYPE_1 ( ) ! insist recycling digests I guess done finalizer TYPE_2 note semantics finally don t finalizers <|endcomment|> public TYPE_2 ( TYPE_1 type ) { this . type = type ; try { VAR_2 = type . get ( ) ; } finally { <START> type . VAR_3 ( VAR_2 ) ; <END> } }
<|startcomment|> mapping performed validation <|endcomment|> private boolean METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) , getParameters ( ) . METHOD_4 ( ) ) ; <END> final TYPE_1 VAR_3 = VAR_4 . METHOD_1 ( getParameters ( ) . METHOD_4 ( ) , getParameters ( ) . METHOD_5 ( ) ) ; return METHOD_6 ( VAR_3 ) ; }
<|startcomment|> need a null case <|endcomment|> public void METHOD_1 ( ) { <START> METHOD_2 ( Collections . VAR_1 ( ) ) ; <END> METHOD_2 ( Arrays . asList ( STRING_1 , STRING_2 , STRING_3 ) ) ; }
<|startcomment|> String valueOf ( vm VAR_6 ( ) ) instead <|endcomment|> protected void METHOD_1 ( ) { VAR_1 . add ( TYPE_1 . VAR_3 , vm . VAR_4 ( ) . toString ( ) ) ; VAR_1 . add ( TYPE_1 . VAR_5 , <START> ( new Integer ( vm . VAR_6 ( ) ) ) . toString ( ) ) ; <END> }
<|startcomment|> [ optional ] method static moved class <|endcomment|> <START> String METHOD_1 ( String VAR_1 ) { <END> return TYPE_1 . METHOD_2 ( type . VAR_2 ( VAR_1 ) ) ; }
<|startcomment|> code duplicate repeated add operations necessary : return Arrays asList ( TYPE_5 TYPE_4 TYPE_1 TYPE_3 TYPE_2 ) ; <|endcomment|> public List < String > METHOD_1 ( ) { List < String > VAR_1 = new ArrayList < > ( ) ; <START> VAR_1 . add ( TYPE_5 ) ; <END> VAR_1 . add ( TYPE_4 ) ; VAR_1 . add ( TYPE_1 ) ; VAR_1 . add ( TYPE_3 ) ; VAR_1 . add ( TYPE_2 ) ; return VAR_1 ; }
<|startcomment|> METHOD_1 true ? I guess supposed false generic extractors I wrong <|endcomment|> boolean METHOD_1 ( ) { <START> return true ; <END> }
<|startcomment|> sense expose a protected method mark beginning remove annotation package - private <|endcomment|> <START> protected static TYPE_1 METHOD_1 ( File VAR_1 , <END> String VAR_2 , File VAR_3 , String VAR_4 , TYPE_1 VAR_5 , String VAR_6 ) throws TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , IOException , TYPE_7 , TYPE_8 , TYPE_9 { return METHOD_1 ( METHOD_2 ( VAR_1 ) , VAR_2 , METHOD_3 ( VAR_3 , VAR_4 ) , VAR_4 , VAR_5 , VAR_6 ) ; }
<|startcomment|> s a bad idea checking exception messages place <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 channel = new TYPE_2 ( VAR_1 , VAR_2 + 1 , new TYPE_3 ( ) , INT_1 , INT_1 , INT_1 , INT_2 , VAR_3 , VAR_4 ) ; try { channel . VAR_5 ( ) ; METHOD_2 ( STRING_1 ) ; } catch ( IOException e ) { <START> assertTrue ( e . getMessage ( ) . contains ( STRING_2 ) ) ; <END> } }
<|startcomment|> ( ) synchronized block <|endcomment|> public void METHOD_1 ( String name ) { if ( ! VAR_1 . contains ( name ) ) { throw new RuntimeException ( String . format ( Messages . TYPE_1 , name , getName ( ) ) ) ; } <START> synchronized ( VAR_3 ) { <END> Object VAR_4 = VAR_3 . get ( name ) ; Object value = METHOD_2 ( name ) ; if ( ( value != null ) && ! ( value . equals ( VAR_4 ) ) ) { METHOD_3 ( name ) ; } } }
<|startcomment|> idiomatic ? fact expect won t true s interrupted assertTrue returns ? clearer omit assertTrue <|endcomment|> public void METHOD_1 ( ) { when ( VAR_1 . METHOD_2 ( ) . get ( METHOD_3 ( String . VAR_2 ) ) ) . METHOD_4 ( STRING_1 ) ; VAR_3 . METHOD_5 ( STRING_2 ) ; <START> assertTrue ( this . VAR_3 . METHOD_6 ( this . VAR_4 ) ) ; <END> }
<|startcomment|> claim return TYPE_1 ? doesn t matter : ) <|endcomment|> <START> public static TYPE_1 METHOD_1 ( TYPE_2 connection , TYPE_1 VAR_1 ) <END> throws TYPE_3 { final String VAR_2 = STRING_1 ; try ( final TYPE_4 VAR_3 = connection . VAR_4 ( VAR_2 ) ) { VAR_3 . METHOD_2 ( 1 , VAR_1 . config ) ; VAR_3 . METHOD_3 ( 2 , VAR_1 . VAR_1 ) ; VAR_3 . METHOD_3 ( 3 , VAR_1 . view ) ; VAR_3 . execute ( ) ; } return null ; }
<|startcomment|> Integer parseInt <|endcomment|> protected int METHOD_1 ( ) { <START> return Integer . valueOf ( TYPE_1 . getProperty ( VAR_1 , VAR_2 ) ) ; <END> }
<|startcomment|> please move super METHOD_1 method <|endcomment|> protected void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> VAR_1 . METHOD_2 ( null ) ; }
<|startcomment|> part test calls _CODE_ close ( ) <|endcomment|> <START> public void METHOD_1 ( ) { <END> TYPE_1 request = METHOD_2 ( TYPE_6 . VAR_2 , TYPE_4 . TYPE_5 . toString ( ) ) ; TYPE_3 channel = METHOD_3 ( ) ; channel . VAR_3 ( request ) ; while ( channel . VAR_4 ( ) != null ) { ; } METHOD_4 ( STRING_1 , channel . VAR_5 ( ) ) ; }
<|startcomment|> please consider adding overridden version TYPE_1 ( String int Logger ) constructor accepts duration encapsulate type conversion <|endcomment|> public String METHOD_1 ( ) { <START> final TYPE_1 cmd = new TYPE_1 ( VAR_1 , VAR_2 . METHOD_2 ( ) , VAR_3 ) ; <END> cmd . add ( STRING_1 ) ; final TYPE_3 . TYPE_4 parser = new TYPE_3 . TYPE_4 ( ) ; final String result = cmd . execute ( parser ) ; if ( result == null ) { return parser . VAR_4 ( ) ; } return null ; }
<|startcomment|> avoid instance creation reporter exist <|endcomment|> private void METHOD_1 ( Class < ? extends TYPE_1 > r ) { <START> VAR_1 . put ( r , TYPE_2 . METHOD_2 ( r ) ) ; <END> }
<|startcomment|> don t mark methods final <|endcomment|> <START> public final synchronized void METHOD_1 ( List < ? extends TYPE_1 > VAR_1 ) <END> { METHOD_1 ( VAR_2 , VAR_1 ) ; }
<|startcomment|> join ifs s a content assist s awesome <|endcomment|> public synchronized void METHOD_1 ( TYPE_1 VAR_1 , Object VAR_2 , Object VAR_3 ) { <START> if ( VAR_2 != VAR_3 ) { <END> if ( VAR_3 != null ) { TYPE_2 input = ( TYPE_2 ) VAR_3 ; METHOD_2 ( ) ; VAR_4 . METHOD_3 ( input . VAR_4 ) ; VAR_5 . METHOD_3 ( VAR_5 ) ; } } }
<|startcomment|> please set a modifier - protected suitable <|endcomment|> <START> boolean METHOD_1 ( ) { <END> return METHOD_2 ( getParameters ( ) . METHOD_3 ( ) , METHOD_4 ( ) . METHOD_5 ( ) . toString ( ) ) ; }
<|startcomment|> avoid System tests instead write log4j <|endcomment|> public void info ( String message ) { <START> System . out . println ( message ) ; <END> info . add ( message ) ; }
<|startcomment|> crash bad format string <|endcomment|> public static File METHOD_1 ( File VAR_1 , String VAR_2 , TYPE_1 VAR_3 ) { <START> return new File ( VAR_1 , StringUtils . VAR_4 ( STRING_1 , VAR_2 , VAR_3 ) ) ; <END> }
<|startcomment|> longer a need VM ID <|endcomment|> private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> VAR_2 . METHOD_4 ( STRING_1 , VAR_1 . METHOD_5 ( ) ) ; VAR_2 . METHOD_4 ( STRING_2 , VAR_1 . getName ( ) ) ; return VAR_2 ; }
<|startcomment|> redundant <|endcomment|> public boolean equals ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 == null || ! ( VAR_1 instanceof TYPE_2 ) ) <END> { return false ; } TYPE_2 that = ( TYPE_2 ) VAR_1 ; return size ( ) == that . size ( ) && Arrays . equals ( VAR_2 , that . VAR_2 ) && Arrays . equals ( values , that . values ) ; }
<|startcomment|> formatting <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { final List < TYPE_2 > VAR_2 = new ArrayList < > ( METHOD_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_6 ( ) ) ) ; TYPE_3 . METHOD_7 ( VAR_2 ) ; VAR_2 . forEach ( this : : METHOD_8 ) ; <START> METHOD_9 ( TYPE_4 . TYPE_5 , VAR_2 , METHOD_10 ( ) . METHOD_11 ( ) ) ; <END> }
<|startcomment|> [ minor ] static <|endcomment|> <START> private void METHOD_1 ( TYPE_1 connection , long length ) { <END> try { TYPE_1 . class . METHOD_2 ( STRING_1 , long . class ) . METHOD_3 ( connection , length ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING_2 + STRING_3 + STRING_4 ) ; } }
<|startcomment|> method protected writing - classing <|endcomment|> <START> String METHOD_1 ( TYPE_1 VAR_1 ) { <END> String response = VAR_1 . METHOD_2 ( String . VAR_2 ) ; try { TYPE_2 error = METHOD_3 ( ) . METHOD_4 ( response , TYPE_2 . VAR_2 ) ; return error . getMessage ( ) ; } catch ( IOException e ) { int VAR_3 = VAR_1 . getStatus ( ) ; TYPE_1 . Status status = VAR_1 . METHOD_5 ( ) ; String VAR_4 = VAR_1 . METHOD_2 ( String . VAR_2 ) ; return STRING_1 + status + STRING_2 + VAR_3 + STRING_3 + VAR_4 ; } }
<|startcomment|> b ^ ( b > > INT_1 ) missed <|endcomment|> public int METHOD_1 ( ) { int VAR_1 = 1 ; VAR_1 = INT_1 * VAR_1 + this . type . VAR_2 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_2 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_3 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_4 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_5 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_6 ( ) ; VAR_1 = INT_1 * VAR_1 + METHOD_7 ( ) ; <START> return VAR_1 ; <END> }
<|startcomment|> call alljavareturn METHOD_1 ( params ( TYPE_8 ) null ) ; <|endcomment|> public static TYPE_1 METHOD_1 ( Map < String , Object > params ) throws TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 { <START> return request ( TYPE_9 . VAR_2 , METHOD_2 ( TYPE_7 . class ) , params , TYPE_1 . class , ( TYPE_8 ) null ) ; <END> }
<|startcomment|> a fragment a lifecycle consider holding a reference call < ? > canceling _CODE_ ( ) call < ? > nonnull <|endcomment|> public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( true ) ; TYPE_1 client = new TYPE_1 ( ) ; <START> client . VAR_2 ( VAR_3 , VAR_1 . METHOD_3 ( ) , <END> new TYPE_1 . TYPE_4 ( ) { @Override public void METHOD_4 ( ) { VAR_1 . METHOD_2 ( false ) ; TYPE_3 . i ( STRING_1 ) ; } @Override public void METHOD_5 ( ANNOTATION_1 Throwable VAR_4 ) { VAR_1 . METHOD_2 ( false ) ; TYPE_3 . e ( STRING_2 , VAR_4 ) ; } } ) ; }
<|startcomment|> passed VAR_1 <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> final TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( METHOD_3 ( ) , null ) ; <END> return TYPE_5 . METHOD_4 ( VAR_2 , METHOD_5 ( ) ) ; }
<|startcomment|> declared exception isn t thrown <|endcomment|> TYPE_2 . TYPE_3 METHOD_1 ( ) <START> throws IOException { <END> return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> changes default behaviour ? <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 ) { VAR_2 = new TYPE_2 ( ) . METHOD_2 ( VAR_3 , VAR_4 , new File ( VAR_1 ) , <START> METHOD_3 ( true ) , VAR_5 , METHOD_4 ( ) ) ; <END> return this ; }
<|startcomment|> return ! ( METHOD_2 ( ) || METHOD_3 ( ) ) || METHOD_4 ( ) ; <|endcomment|> private boolean METHOD_1 ( ) { if ( METHOD_2 ( ) || METHOD_3 ( ) ) { return METHOD_4 ( ) ; } else { return true ; <START> } <END> }
<|startcomment|> set VAR_1 false ? I don t <|endcomment|> public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 trace ) throws TYPE_2 { boolean VAR_1 = super . METHOD_1 ( trace ) ; if ( ! VAR_1 ) { return VAR_1 ; } VAR_1 = VAR_2 . METHOD_1 ( trace ) ; <START> VAR_2 . METHOD_2 ( TYPE_3 . VAR_4 , getId ( ) ) ; <END> return VAR_1 ; }
<|startcomment|> _CODE_ case InterruptedException change ? test difference <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; final TYPE_2 VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 . isEmpty ( ) ) { return ; } try { TYPE_3 . METHOD_4 ( ) . METHOD_5 ( TYPE_5 . VAR_4 , new TYPE_4 ( ) ) ; } catch ( InterruptedException e ) { <START> throw new RuntimeException ( e ) ; <END> } VAR_5 . METHOD_1 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> cast operation ? asking a service interface cast a concrete implementation instanceof check perform check tracker added a TYPE_2 <|endcomment|> public void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( this ) ; TYPE_1 . METHOD_5 ( ) . METHOD_6 ( this ) ; TYPE_2 VAR_1 = <START> ( TYPE_2 ) METHOD_2 ( ) . METHOD_7 ( TYPE_3 . class ) ; <END> if ( VAR_1 != null ) { VAR_1 . METHOD_8 ( VAR_2 ) ; } VAR_3 = null ; VAR_4 = null ; VAR_5 = null ; }
<|startcomment|> String format ( ) longer necessary <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( ) ; VAR_3 . setText ( VAR_1 . VAR_3 ) ; VAR_4 . setText ( String . format ( VAR_2 , STRING_1 , VAR_1 . VAR_4 ) ) ; <START> VAR_5 . setText ( String . format ( VAR_2 , STRING_2 , VAR_1 . VAR_5 ) ) ; <END> VAR_6 . setText ( VAR_1 . VAR_7 ) ; }
<|startcomment|> static <|endcomment|> <START> private String METHOD_1 ( String VAR_1 ) { <END> return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( 0 ) ) + VAR_1 . substring ( 1 ) ; }
<|startcomment|> instead ( callsite TYPE_2 ) _CODE_ type = context getType ( VAR_1 ) ; return type ! = null && type _CODE_ ( TYPE_2 TYPE_STRING ) ; <|endcomment|> <START> private static boolean METHOD_1 ( <END> ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 TYPE_2 context ) { if ( VAR_1 instanceof TYPE_3 ) { return true ; } else { TYPE_8 . TYPE_6 VAR_2 = context . VAR_3 ( VAR_1 ) ; if ( VAR_2 instanceof TYPE_8 . TYPE_7 ) { if ( ( ( TYPE_8 . TYPE_7 ) VAR_2 ) . getValue ( ) instanceof String ) { return true ; } } } return false ; }
<|startcomment|> inline avoid unnecessary object creation <|endcomment|> protected double METHOD_1 ( double VAR_1 , double VAR_2 , Map < String , Double > VAR_3 ) { <START> TYPE_1 VAR_4 = METHOD_2 ( ) ; <END> return METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; }
<|startcomment|> I reverted account additions pre - TYPE_3 implementations <|endcomment|> public < T extends TYPE_1 > List < T > METHOD_1 ( Class < T > type ) { <START> List < T > VAR_1 = TYPE_2 . filter ( METHOD_2 ( ) , type ) ; <END> for ( TYPE_3 < ? > VAR_2 : TYPE_3 . METHOD_3 ( getClass ( ) , type ) ) { VAR_1 . addAll ( TYPE_2 . filter ( METHOD_4 ( VAR_2 ) , type ) ) ; } return Collections . VAR_3 ( VAR_1 ) ; }
<|startcomment|> TYPE_1 current image needs updated array <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) { if ( VAR_1 == null ) SWT . error ( SWT . VAR_3 ) ; int VAR_4 = TYPE_2 . METHOD_2 ( VAR_2 ) ; if ( VAR_4 == VAR_5 . METHOD_3 ( ) ) { METHOD_4 ( VAR_1 ) ; <START> METHOD_4 ( ) ; <END> } else { data [ VAR_4 ] = VAR_1 ; } }
<|startcomment|> don t need calling _CODE_ public constructor <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ; <START> VAR_2 . METHOD_2 ( ) ; <END> return VAR_2 ; }
<|startcomment|> style - : hard read : ( METHOD_2 ( ) ! = null ) return METHOD_2 ( ) METHOD_1 ( ) ; return System VAR_1 ( ) ; <|endcomment|> public int METHOD_1 ( ) { <START> return METHOD_2 ( ) != null ? METHOD_2 ( ) . METHOD_1 ( ) : <END> System . VAR_1 ( this ) ; }
<|startcomment|> removed return VAR_1 assigning logic <|endcomment|> public List < String > METHOD_1 ( ) { <START> return VAR_1 == null ? VAR_2 : VAR_1 ; <END> }
<|startcomment|> final <|endcomment|> public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = METHOD_2 ( ) ; METHOD_3 ( VAR_2 , VAR_1 ) ; <START> List < TYPE_1 > result = ( List < TYPE_1 > ) VAR_2 . list ( ) ; <END> return result == null ? new ArrayList < TYPE_1 > ( ) : result ; }
<|startcomment|> variable useless cases I pass new Object [ ] { } log method <|endcomment|> public TYPE_1 METHOD_1 ( Class < ? extends TYPE_2 > ... VAR_1 ) { <START> Object [ ] VAR_2 = new Object [ ] { } ; <END> for ( Class < ? extends TYPE_2 > VAR_3 : VAR_1 ) { try { TYPE_2 VAR_4 = TYPE_3 . METHOD_2 ( VAR_3 ) ; METHOD_3 ( VAR_4 ) ; } catch ( Exception ex ) { TYPE_4 . LOG . METHOD_4 ( VAR_3 , VAR_2 , ex ) ; } } return this ; }
<|startcomment|> parameter true need overwrite _CODE_ <|endcomment|> public TYPE_1 ( ) { super ( Messages . VAR_2 ( ) , Messages . VAR_3 ( ) , Messages . VAR_4 ( ) , <START> VAR_5 , true ) ; <END> }
<|startcomment|> ternary : return METHOD_2 ( ) = = null ? new TYPE_1 ( TYPE_2 VAR_2 ) : TYPE_1 VAR_3 ; <|endcomment|> private TYPE_1 METHOD_1 ( ) { <START> if ( METHOD_2 ( ) == null ) { <END> return new TYPE_1 ( TYPE_2 . VAR_2 ) ; } return TYPE_1 . VAR_3 ; }
<|startcomment|> remove METHOD_2 due I m surprised allowed explicit null check a compilation error <|endcomment|> public static TYPE_1 METHOD_1 ( String text ) { <START> TYPE_2 . METHOD_2 ( text , STRING_1 ) ; <END> return new TYPE_1 ( text , METHOD_3 ( text ) ) ; }
<|startcomment|> ( VAR_1 isEmpty ( ) ) <|endcomment|> public TYPE_1 METHOD_1 ( String id ) { <START> if ( VAR_1 . size ( ) == 0 ) <END> return null ; for ( int i = 0 ; i < VAR_1 . size ( ) - 1 ; i ++ ) { if ( VAR_1 . get ( i ) . VAR_2 . equals ( id ) ) { return VAR_1 . get ( i + 1 ) ; } } return VAR_1 . get ( 0 ) ; }
<|startcomment|> please add { } - liner <|endcomment|> public static void METHOD_1 ( boolean VAR_1 ) { try { if ( VAR_1 ) { VAR_2 = TYPE_1 . class . METHOD_2 ( STRING_1 ) ; } else <START> VAR_2 = TYPE_1 . class . METHOD_2 ( STRING_2 ) ; <END> } catch ( TYPE_2 e ) { throw new RuntimeException ( e ) ; } }
<|startcomment|> I change future release s s easier update <|endcomment|> public String VAR_1 ( ) { return STRING_1 + STRING_2 + STRING_3 + STRING_2 + STRING_4 + STRING_5 <START> + STRING_6 <END> }
<|startcomment|> handling nulls ? some methods null acceptable return null s add a lombok a TYPE_1 _CODE_ ( present nulls give a - useful NPE <|endcomment|> <START> public static void METHOD_1 ( int [ ] data , String VAR_1 ) { <END> boolean VAR_2 = true ; for ( int value : data ) { if ( value < 0 ) { VAR_2 = false ; } } TYPE_1 . METHOD_2 ( VAR_2 , STRING_1 , VAR_1 , data ) ; }
<|startcomment|> ( i realize crappy code ) a configuration error files fail METHOD_1 don t want eating putting log remove block constructor throw IOException rethrow exception a extra context ? prefer <|endcomment|> <START> public TYPE_3 ( ) { <END> try { VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_1 ( new TYPE_2 ( this . getClass ( ) . METHOD_2 ( STRING_1 ) ) ) ; VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_1 ( new TYPE_2 ( this . getClass ( ) . METHOD_2 ( STRING_2 ) ) ) ; } catch ( IOException e ) { log . error ( STRING_3 , e ) ; } }
<|startcomment|> instead passing null remove check call method a new TYPE_2 object <|endcomment|> private TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) throws IOException { if ( VAR_2 == null ) { VAR_2 = new TYPE_2 ( ) ; <START> } <END> VAR_2 . METHOD_2 ( VAR_3 , STRING_1 ) ; return TYPE_3 . METHOD_3 ( new TYPE_4 ( ) ) . METHOD_4 ( STRING_2 , STRING_3 ) . METHOD_5 ( VAR_1 ) . METHOD_6 ( VAR_2 ) . METHOD_7 ( TYPE_5 . of ( new TYPE_6 ( METHOD_8 ( ) ) ) ) . METHOD_9 ( TYPE_1 . class ) ; }
<|startcomment|> add null check <|endcomment|> public void METHOD_1 ( Collection < TYPE_1 > values ) { VAR_1 . clear ( ) ; VAR_2 . clear ( ) ; VAR_3 . clear ( ) ; <START> for ( final TYPE_1 value : values ) { <END> METHOD_2 ( value ) ; } METHOD_3 ( ) ; }
<|startcomment|> TYPE_3 a runtime exception need catch rethrow ( occurrences ) <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 ) { try { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { log . debug ( String . format ( STRING_1 , VAR_1 ) ) ; return VAR_3 . create ( TYPE_2 . of ( VAR_1 ) ) ; } return VAR_2 ; } catch ( TYPE_3 e ) { <START> throw new TYPE_4 ( e ) ; <END> } }
<|startcomment|> need mind sentence construction other languages query string doesn t show %1$s string values / strings xml pass query term extra argument getString ( ) <|endcomment|> private void METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( METHOD_2 ( ) , VAR_2 ) ; METHOD_3 ( VAR_1 ) ; } VAR_1 . METHOD_4 ( ) ; METHOD_5 ( true ) ; String query = METHOD_6 ( ) . getString ( VAR_3 ) ; <START> METHOD_7 ( getString ( R . string . VAR_4 ) + STRING_1 + query + STRING_2 ) ; <END> }
<|startcomment|> thanks marking resolved <|endcomment|> private TYPE_1 < TYPE_2 > METHOD_1 ( ) throws Exception { List < TYPE_2 > VAR_1 = db . VAR_2 ( ) . METHOD_2 ( VAR_3 ) ; <START> if ( VAR_1 instanceof TYPE_3 <END> || ( VAR_1 instanceof TYPE_4 && ( ( TYPE_4 ) VAR_1 ) . METHOD_3 ( ) == null ) ) { return VAR_1 ; } return TYPE_5 . METHOD_4 ( VAR_1 ) ; }
<|startcomment|> I don t understand need create a new ArrayList a collection coming a query - necessarily else cast s coming backend ArrayList ? means committing a specific implementation I a cast Collection more s important result specifically ArrayList ( other kind collection ) I create a new ArrayList cast result backend Collection <|endcomment|> private static void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . VAR_2 = new TYPE_2 ( ) { @Override public Object METHOD_2 ( Object source , TYPE_1 VAR_3 ) { List < String > results = new ArrayList < String > ( ) ; <START> for ( TYPE_3 VAR_4 : source != null ? new ArrayList < TYPE_3 > ( ( ArrayList < TYPE_3 > ) source ) <END> : new ArrayList < TYPE_3 > ( ) ) { results . add ( VAR_4 . METHOD_3 ( ) ) ; } return results ; } } ; }
<|startcomment|> class _package_ protected access constructor _package_ protection <|endcomment|> <START> public TYPE_9 ( final TYPE_1 < TYPE_2 > VAR_2 , <END> final TYPE_6 . TYPE_7 VAR_3 , final TYPE_8 . TYPE_7 VAR_4 , final Optional < String > VAR_5 , final TYPE_5 VAR_6 ) { super ( VAR_3 , VAR_4 , VAR_5 ) ; this . VAR_2 = VAR_2 ; this . VAR_6 = VAR_6 ; }
<|startcomment|> wouldn t starts more sense <|endcomment|> public List < TYPE_1 > METHOD_1 ( String VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_1 VAR_3 : this . METHOD_2 ( ) ) { String VAR_4 = VAR_3 . getName ( ) ; if ( VAR_1 . equalsIgnoreCase ( VAR_4 ) ) { VAR_2 . add ( VAR_3 ) ; break ; } <START> if ( VAR_4 . METHOD_3 ( ) . contains ( VAR_1 . METHOD_3 ( ) ) ) { <END> VAR_2 . add ( VAR_3 ) ; } } return VAR_2 ; }
<|startcomment|> I notice unzigzag method unsigned shift operator ( > > > ) signed ( > > ) intentional <|endcomment|> private int METHOD_1 ( int input ) { <START> return ( input > > 1 ) ^ ( - ( input & 1 ) ) ; <END> }
<|startcomment|> please create method METHOD_2 ( ) { METHOD_2 ( TYPE_1 VAR_2 ) ; } method _CODE_ ( ) <|endcomment|> <START> public void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . VAR_2 ) ; } <END>
<|startcomment|> need / catch ? METHOD_9 fails junit care stack <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( 0 , VAR_1 ) ; TYPE_3 VAR_3 = new TYPE_3 ( VAR_4 , VAR_2 , SWT . NONE ) ; VAR_1 . METHOD_3 ( ) . METHOD_4 ( 10 , 10 ) ; VAR_3 . METHOD_5 ( ) . METHOD_6 ( ) ; try { VAR_1 . METHOD_7 ( ) ; } <START> catch ( Exception <END> VAR_5 ) { VAR_5 . METHOD_8 ( ) ; METHOD_9 ( ) ; } }
<|startcomment|> please consider adding overridden version TYPE_2 ( String int Logger ) constructor accepts duration encapsulate type conversion <|endcomment|> public boolean METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 ) { if ( ! VAR_3 ) { return false ; } <START> final TYPE_2 cmd = new TYPE_2 ( VAR_4 , VAR_5 . METHOD_2 ( ) , VAR_6 ) ; <END> cmd . add ( STRING_1 ) ; cmd . add ( STRING_2 , VAR_2 ) ; cmd . add ( STRING_3 , VAR_7 ) ; final String result = cmd . execute ( ) ; if ( result != null ) { return false ; } return true ; }
<|startcomment|> shouldn t > 1 <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( STRING_1 ) ; METHOD_2 ( STRING_2 ) ; <START> assertTrue ( METHOD_2 ( STRING_3 ) . METHOD_3 ( ) > 0 ) ; <END> assertTrue ( METHOD_2 ( STRING_4 ) . METHOD_3 ( ) > 0 ) ; }
<|startcomment|> debug level <|endcomment|> public TYPE_1 get ( ) { TYPE_2 logger = new TYPE_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <START> log . info ( new Exception ( STRING_1 ) , STRING_2 , logger ) ; <END> return logger ; }
<|startcomment|> shouldn t wrap original e <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_1 e ) { String VAR_1 = VAR_2 . toString ( ) ; if ( TYPE_2 . METHOD_2 ( VAR_1 ) ) { return e ; } <START> return new TYPE_3 ( e . getMessage ( ) , VAR_1 ) ; <END> }
<|startcomment|> new flag VAR_3 passed ( ) _CODE_ <|endcomment|> public List < TYPE_1 > METHOD_1 ( final TYPE_2 VAR_1 , final boolean VAR_2 , final boolean VAR_3 , final TYPE_3 < TYPE_4 > properties , final TYPE_5 VAR_4 ) throws TYPE_6 { <START> return VAR_5 . METHOD_1 ( VAR_1 , VAR_2 , VAR_4 , VAR_6 . METHOD_2 ( VAR_1 , VAR_4 ) ) ; <END> }
<|startcomment|> need cast String VAR_3 a generic method public < T > T VAR_3 ( String key ) <|endcomment|> public void METHOD_1 ( String VAR_1 ) { TYPE_1 command = METHOD_2 ( ) ; TYPE_2 VAR_2 = command . VAR_3 ( TYPE_5 . VAR_5 ) ; VAR_6 = VAR_2 != null && Boolean . VAR_7 ( VAR_2 . toString ( ) ) ; VAR_8 = TYPE_3 . METHOD_3 ( TYPE_4 . class ) ; <START> VAR_9 = ( String ) command . VAR_3 ( VAR_10 ) ; <END> }
<|startcomment|> check queue 0 ? acquire a connection waiting exchanges <|endcomment|> public boolean remove ( TYPE_1 connection ) { boolean VAR_1 = VAR_2 . remove ( connection ) ; if ( METHOD_1 ( ) . isEmpty ( ) ) { METHOD_2 ( ) ; } else { if ( VAR_1 ) <START> METHOD_3 ( true ) ; <END> } return VAR_2 . remove ( connection ) ; }
<|startcomment|> return null ? I meant false <|endcomment|> public boolean METHOD_1 ( ) { final String VAR_1 = super . VAR_2 . getProperty ( VAR_3 ) ; <START> return VAR_1 == null ? null : Boolean . valueOf ( VAR_1 ) ; <END> }
<|startcomment|> I wary coz existing schedulers setting removed immediately ideally want position rolling don t want unexpected behaviors <|endcomment|> public static TYPE_1 METHOD_1 ( int VAR_1 , String VAR_2 , boolean VAR_3 ) { TYPE_2 VAR_4 = new TYPE_2 ( VAR_1 , new TYPE_3 ( VAR_2 , VAR_3 ) ) ; VAR_4 . METHOD_2 ( false ) ; VAR_4 . METHOD_3 ( false ) ; <START> VAR_4 . METHOD_4 ( true ) ; <END> return VAR_4 ; }
<|startcomment|> ah s meant = ) isn t good : s generic wouldn t debug a failure VAR_2 log a warning return false warning specific wrong i e new maximum allowed <|endcomment|> public boolean METHOD_1 ( T VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( VAR_1 ) ) { <START> LOGGER . warn ( STRING_1 , VAR_1 ) ; <END> return false ; } TYPE_1 event = new TYPE_1 ( this , id . toString ( ) , this . value , VAR_1 ) ; this . value = VAR_1 ; METHOD_3 ( event ) ; return true ; }
<|startcomment|> want move trace debug <|endcomment|> public void METHOD_1 ( TYPE_1 message ) { try { <START> logger . debug ( STRING_1 ) ; <END> VAR_1 . METHOD_2 ( message ) ; } catch ( TYPE_2 e ) { throw e ; } catch ( Exception e ) { logger . error ( STRING_2 , e ) ; } }
<|startcomment|> return result addAll ( VAR_1 keySet ( ) ) ; <|endcomment|> private Collection < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > result = new ArrayList < TYPE_1 > ( ) ; <START> for ( Iterator < TYPE_1 > i = VAR_1 . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { result . add ( i . next ( ) ) ; } return result ; <END> }
<|startcomment|> I constructor protected instantiate abstract classes answers a discussion <|endcomment|> <START> public TYPE_2 ( String VAR_2 , String VAR_3 , T VAR_4 , TYPE_1 VAR_5 ) { <END> name = VAR_2 ; type = VAR_3 ; value = VAR_4 ; VAR_6 = VAR_5 ; }
<|startcomment|> shouldn t line _CODE_ ( VAR_1 METHOD_3 ( VAR_1 ( ) ) ) ; <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( METHOD_2 ( ) ) ; <END> }
<|startcomment|> open a stream object closing - - resources statement avoid / handle unhandled IOException <|endcomment|> private static String METHOD_1 ( ) throws IOException , TYPE_1 { TYPE_2 parser = new TYPE_2 ( ) ; TYPE_3 VAR_1 = Thread . VAR_2 ( ) . METHOD_2 ( ) ; <START> TYPE_4 VAR_3 = VAR_1 . METHOD_3 ( STRING_1 ) ; <END> String VAR_4 = TYPE_5 . toString ( VAR_3 , STRING_2 ) ; Object object = parser . parse ( VAR_4 ) ; TYPE_6 VAR_5 = ( TYPE_6 ) object ; return VAR_5 . METHOD_4 ( ) ; }
<|startcomment|> I bug fault I suggested clearing VAR_4 a bad VAR_4 shared transactions immutable set I ll open issue <|endcomment|> public synchronized void commit ( ) throws TYPE_1 { TYPE_2 VAR_1 = null ; try { VAR_1 = new TYPE_2 ( ) ; METHOD_1 ( VAR_1 ) ; VAR_1 . METHOD_2 ( ) ; } finally { VAR_2 . clear ( ) ; VAR_3 = null ; <START> VAR_4 . clear ( ) ; <END> VAR_5 . clear ( ) ; } }
<|startcomment|> I simplify return METHOD_2 ( buf VAR_1 ) && ( buf [ VAR_1 ] & VAR_3 ! = 0 ) && ( buf [ VAR_1 + 1 ] & VAR_4 ) ! = 0 ) <|endcomment|> public static boolean METHOD_1 ( byte [ ] buf , int VAR_1 , int VAR_2 ) { if ( ! METHOD_2 ( buf , VAR_1 ) ) return false ; if ( ( buf [ VAR_1 ] & VAR_3 ) == 0 || ( buf [ VAR_1 + 1 ] & VAR_4 ) == 0 ) <START> return false ; <END> return true ; }
<|startcomment|> remove println <|endcomment|> public void METHOD_1 ( boolean VAR_1 ) { this . VAR_2 = VAR_1 ; <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> METHOD_2 ( ) ; }
<|startcomment|> I dont throwing exceptions instead empty implementations <|endcomment|> <START> default void VAR_1 ( TYPE_3 VAR_3 , TYPE_2 method , TYPE_1 VAR_6 ) { <END> throw new TYPE_4 ( STRING_1 ) ; }
<|startcomment|> isn t needed - conditions added outer <|endcomment|> private void METHOD_1 ( ) { if ( ! METHOD_2 ( ) || METHOD_3 ( ) == METHOD_4 ( ) . size ( ) - 1 ) { <START> if ( ! METHOD_5 ( ) || METHOD_6 ( ) . METHOD_7 ( ) == TYPE_2 . TYPE_1 ) { <END> METHOD_8 ( ) ; } } }
<|startcomment|> change a loop caller scan state equal state a private method safe assume caller checked ( lock ) METHOD_3 a state change <|endcomment|> private boolean METHOD_1 ( TYPE_1 state ) { try { <START> while ( ! METHOD_2 ( ) . equals ( state ) ) { <END> VAR_1 . METHOD_3 ( ) ; } return true ; } catch ( InterruptedException e ) { VAR_2 . logger . warn ( STRING_1 + state . name ( ) , e ) ; return false ; } }
<|startcomment|> merge VAR_1 VAR_5 <|endcomment|> private void METHOD_1 ( ) { switch ( state ( ) ) { <START> case VAR_1 : <END> this . VAR_2 = METHOD_2 ( ) ; break ; case VAR_3 : if ( ! VAR_4 ) { this . VAR_2 = METHOD_2 ( ) ; } break ; case VAR_5 : this . VAR_2 = METHOD_2 ( ) ; break ; case VAR_6 : case VAR_7 : throw new IllegalStateException ( STRING_1 + state ( ) + STRING_2 + id ) ; default : throw new IllegalStateException ( STRING_3 + state ( ) + STRING_2 + id ) ; } }
<|startcomment|> cast TYPE_2 <|endcomment|> protected void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> TYPE_2 VAR_2 = ( ( TYPE_2 ) TYPE_3 . getInstance ( ) . create ( VAR_1 ) ) ; <END> METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( VAR_2 . METHOD_6 ( ) ) ) ; }
<|startcomment|> leveraged _CODE_ [ ] ( ) <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 . add ( new Object ( ) { } . getClass ( ) . METHOD_2 ( ) . getName ( ) ) ; <END> }
<|startcomment|> currently test fails error stacktrace original failure I pinpointing culprit easier ? preference feel free ignore : ) <|endcomment|> public void METHOD_1 ( ) { TYPE_1 metadata = METHOD_2 ( 5 , 10 , STRING_1 ) . metadata ; try { <START> METHOD_3 ( metadata . VAR_1 ( ) , ( TYPE_2 ) metadata . VAR_2 ( ) . get ( TYPE_2 . VAR_3 ) ) ; <END> } catch ( Exception e ) { METHOD_4 ( STRING_2 + e . getMessage ( ) ) ; } }
<|startcomment|> I dont check needed ( throw index bounds exception ) <|endcomment|> public TYPE_1 METHOD_1 ( int n ) { <START> if ( n >= VAR_1 . length ) <END> throw new TYPE_2 ( STRING_1 + n + STRING_2 + getClass ( ) . getName ( ) ) ; return VAR_1 [ n ] ; }
<|startcomment|> METHOD_3 ( ) –Ω—É–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –≥–¥–µ —Å–µ—Å—Å–∏—è –∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è –≤–æ–æ–±—â–µ –∞ –Ω–µ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —é–∑–µ—Ä–∞ <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , Integer VAR_2 ) { METHOD_2 ( VAR_2 , getString ( R . string . VAR_3 ) ) ; <START> METHOD_3 ( ) ; <END> }
<|startcomment|> run checks constructor reconciler null create actual list - null reconcilers dereferenced <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_3 ) { <START> if ( VAR_2 != null ) { <END> VAR_2 . METHOD_1 ( VAR_1 ) ; } } }
<|startcomment|> –∞ –º—ã —Ä–∞–∑–≤–µ –º–æ–∂–µ–º —Ö–æ—Ç—å –∫–æ–≥–¥–∞ - —Ç–æ –Ω–µ –∑–∞—Ö–æ—Ç–µ—Ç—å –¥–æ–±–∞–≤–ª—è—Ç—å listener - —è –±—ã —ç—Ç–æ —É–Ω–µ—Å –ø—Ä—è–º –≤ –æ—Å–Ω–æ–≤–Ω–æ–π _CODE_ <|endcomment|> public TYPE_1 run ( TYPE_2 VAR_1 , boolean VAR_2 , TYPE_3 < TYPE_3 < Integer , TYPE_1 > , TYPE_1 > VAR_3 , boolean VAR_4 ) { try { METHOD_1 ( ) ; METHOD_2 ( VAR_1 ) ; TYPE_1 VAR_5 = METHOD_3 ( VAR_1 , VAR_2 , VAR_3 , <START> v - > v . VAR_6 ( new TYPE_4 ( VAR_1 ) ) ) ; <END> VAR_5 . start ( ) ; METHOD_4 ( VAR_1 ) ; return VAR_5 ; } catch ( Exception e ) { return METHOD_5 ( e , VAR_4 ) ; } }
<|startcomment|> AFAIK redundant <|endcomment|> public TYPE_1 ( String id , String VAR_2 ) { <START> super ( ) ; <END> this . id = id ; this . VAR_2 = VAR_2 ; }
<|startcomment|> _CODE_ class return VAR_1 ( ) <|endcomment|> public int METHOD_1 ( ) { <START> return name . VAR_1 ( ) ; <END> }
<|startcomment|> LOG debug please avoid overhead operations <|endcomment|> protected boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { try { <START> LOG . info ( STRING_1 , VAR_1 , VAR_2 ) ; <END> VAR_3 . METHOD_1 ( VAR_4 , VAR_1 , VAR_4 , VAR_2 ) ; return true ; } catch ( TYPE_1 e ) { LOG . error ( STRING_2 , VAR_1 , VAR_2 , e ) ; return false ; } }
<|startcomment|> logic switch true ( behavior ) <|endcomment|> public TYPE_1 ( Collection < String > VAR_2 ) { this ( VAR_2 , false , <START> false ) ; <END> }
<|startcomment|> aren t description properties added super class <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 description = super . METHOD_1 ( ) ; <START> description . VAR_1 ( STRING_1 ) ; <END> description . VAR_1 ( STRING_2 ) ; description . VAR_1 ( STRING_3 ) ; return description ; }
<|startcomment|> TYPE_2 ( int ) returning a char ( primitive type ) = = test works I returning TYPE_2 ( object wrapper char ) need equals <|endcomment|> private TYPE_1 METHOD_1 ( String data ) throws IOException { <START> TYPE_2 VAR_1 = data . VAR_2 ( 0 ) ; <END> if ( VAR_1 == CHAR_1 || VAR_1 == CHAR_2 ) { return this . VAR_3 . METHOD_2 ( data ) ; } else { return this . VAR_4 . METHOD_2 ( data ) ; } }
<|startcomment|> redundant cast <|endcomment|> public void METHOD_1 ( ) { TYPE_1 config = new TYPE_1 ( ) ; assertThat ( config . VAR_1 ( ) ) . METHOD_2 ( ) ; config . VAR_2 ( true ) ; <START> assertThat ( ( boolean ) config . VAR_1 ( ) ) . METHOD_3 ( ) ; <END> config . VAR_2 ( Boolean . VAR_3 ) ; assertThat ( ( boolean ) config . VAR_1 ( ) ) . METHOD_4 ( ) ; config . VAR_2 ( null ) ; assertThat ( config . VAR_1 ( ) ) . METHOD_2 ( ) ; }
<|startcomment|> style - : curly brackets wrap return line <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 id , TYPE_3 repo ) throws IOException { <START> if ( id . equals ( TYPE_2 . METHOD_2 ( ) ) ) return new TYPE_1 ( new byte [ ] { } ) ; <END> return new TYPE_1 ( repo . VAR_1 ( id ) . METHOD_3 ( ) ) ; }
<|startcomment|> inline suggestionreturn STRING_1 + VAR_2 ; <|endcomment|> private static String METHOD_1 ( ) { String VAR_1 = STRING_1 + VAR_2 ; <START> return VAR_1 ; <END> }
<|startcomment|> don t validate other builders method ( don t ) <|endcomment|> public Builder METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_1 = METHOD_2 ( VAR_1 , STRING_1 ) ; <END> return this ; }
<|startcomment|> statement rewritten inline <|endcomment|> public boolean METHOD_1 ( Date VAR_1 ) { if ( METHOD_2 ( ) != null ) { Date VAR_2 = VAR_1 == null ? new Date ( ) : VAR_1 ; <START> return METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <END> } return false ; }
<|startcomment|> needed <|endcomment|> public void METHOD_1 ( ) { if ( METHOD_2 ( ) ) { VAR_1 . METHOD_3 ( ) ; try { if ( VAR_2 != null ) { <START> VAR_2 . close ( ) ; <END> } if ( VAR_3 != null ) { VAR_3 . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } finally { VAR_4 . set ( false ) ; } } }
<|startcomment|> TYPE_1 supposed extended replace a ( ! ( object instanceof TYPE_1 ) ) t null s instance TYPE_1 I put ( object = = ) test instead <|endcomment|> public boolean equals ( Object object ) { <START> if ( object == null || object . getClass ( ) != getClass ( ) ) { <END> return false ; } if ( object == this ) { return true ; } TYPE_1 VAR_1 = ( TYPE_1 ) object ; return new TYPE_2 ( ) . append ( getId ( ) , VAR_1 . getId ( ) ) . append ( METHOD_1 ( ) , VAR_1 . METHOD_1 ( ) ) . METHOD_2 ( ) ; }
<|startcomment|> public API t visibility deprecating <|endcomment|> <START> Map < String , Object > METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> neat <|endcomment|> public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; <END> }
<|startcomment|> list empty adds - xfriend - paths = option <|endcomment|> private String METHOD_1 ( TYPE_1 VAR_1 , ImmutableList < TYPE_2 > VAR_2 ) { TYPE_3 < String > VAR_3 = TYPE_3 . METHOD_2 ( VAR_2 . stream ( ) . map ( path - > VAR_1 . METHOD_3 ( path ) . toString ( ) ) . collect ( Collectors . VAR_4 ( ) ) ) ; return STRING_1 <START> + VAR_3 . stream ( ) . METHOD_4 ( "" , ( VAR_5 , VAR_6 ) - > VAR_5 + STRING_2 + VAR_6 ) ; <END> }
<|startcomment|> need super ( ) class inheriting a super class <|endcomment|> public TYPE_2 ( String VAR_2 ) { <START> super ( ) ; <END> Assert . VAR_3 ( VAR_2 , STRING_1 ) ; this . VAR_4 = TYPE_1 . create ( VAR_2 ) ; }
<|startcomment|> minor duplicating lines 44 - 51 put a private method invoked constructors constructor invoke other <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; final String VAR_3 = VAR_2 . METHOD_1 ( ) ; String VAR_4 = TYPE_2 . getProperty ( VAR_3 , "" ) ; if ( StringUtils . VAR_5 ( VAR_4 ) ) { logger . error ( STRING_1 + STRING_2 , VAR_3 , VAR_2 . METHOD_2 ( ) ) ; } METHOD_3 ( VAR_4 ) ; <START> } <END>
<|startcomment|> bad I fixed work branch : states overcomplicated s place wicket core needing test flag <|endcomment|> public final boolean METHOD_1 ( ) { if ( VAR_1 == null ) { <START> throw new IllegalStateException ( STRING_1 ) ; <END> } return METHOD_2 ( ) . METHOD_1 ( ) ; }
<|startcomment|> doesn t thread - safe <|endcomment|> private TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> VAR_1 = new TYPE_1 ( VAR_2 . METHOD_2 ( ) ) ; } return VAR_1 ; }
<|startcomment|> s remove behavior METHOD_1 affect indicators <|endcomment|> ANNOTATION_1 ( STRING_1 ) ANNOTATION_2 public void METHOD_1 ( boolean VAR_1 ) { METHOD_2 ( VAR_1 ) ; <START> METHOD_3 ( VAR_1 ) ; <END> }
<|startcomment|> I guess longer need VAR_1 _CODE_ implementation fully locking <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { synchronized ( VAR_1 ) { return VAR_1 . values ( ) . stream ( ) . map ( e - > METHOD_2 ( e ) ) . collect ( Collectors . VAR_2 ( ) ) ; <START> } <END> }
<|startcomment|> VAR_1 null ll a NPE VAR_1 VAR_4 METHOD_3 ( ) <|endcomment|> public String METHOD_1 ( ) { TYPE_3 . TYPE_4 VAR_1 = VAR_2 . METHOD_2 ( ) ; TYPE_2 VAR_3 = VAR_1 . VAR_4 . METHOD_3 ( ) ; <START> if ( VAR_1 == null || VAR_3 == null ) { <END> return STRING_1 ; } return VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) + STRING_2 + VAR_3 . METHOD_6 ( ) ; }
<|startcomment|> I drop redundant TYPE_1 suffix task types e g : STRING_3 - > VAR_8 _CODE_ - > _CODE_ _CODE_ - > timeout _CODE_ - > _CODE_ <|endcomment|> default < R > TYPE_1 < R > VAR_2 ( final String VAR_3 , final TYPE_3 < ? super T , TYPE_1 < R > > VAR_5 ) { TYPE_2 . VAR_7 ( VAR_5 , STRING_1 ) ; final TYPE_1 < TYPE_1 < R > > VAR_8 = map ( STRING_2 + VAR_3 , VAR_5 ) ; VAR_8 . VAR_9 ( ) . VAR_10 ( true ) ; <START> VAR_8 . VAR_9 ( ) . VAR_11 ( STRING_3 ) ; <END> return VAR_12 ( VAR_3 , VAR_8 ) ; }
<|startcomment|> stated I don t need method throw exception <|endcomment|> protected List < String > METHOD_1 ( String VAR_1 , boolean VAR_2 , int VAR_3 , File VAR_4 ) <START> throws Exception { <END> return METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , TYPE_1 . VAR_6 ) ; }
<|startcomment|> pass null status I refactored similar code status part event <|endcomment|> public void METHOD_1 ( String id ) { Long VAR_1 = Long . VAR_2 ( id ) ; VAR_3 . METHOD_2 ( new TYPE_1 ( VAR_4 , VAR_5 , VAR_1 , VAR_6 , VAR_7 , <START> 1 ) ) ; <END> final String message = Constants . VAR_8 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; VAR_9 . METHOD_2 ( new TYPE_2 ( message , TYPE_2 . TYPE_3 . VAR_11 ) ) ; close ( ) ; }
<|startcomment|> I don t understand check METHOD_6 check checking rights <|endcomment|> protected void METHOD_1 ( final TYPE_1 source , final TYPE_1 VAR_1 ) { METHOD_2 ( source , new TYPE_2 < TYPE_3 > ( ) { @Override public void METHOD_3 ( TYPE_3 VAR_2 ) { TYPE_3 VAR_3 = VAR_2 . METHOD_4 ( source , VAR_1 ) ; <START> if ( TYPE_5 . this . METHOD_5 ( TYPE_4 . VAR_6 , VAR_3 ) ) { <END> METHOD_6 ( VAR_2 , VAR_3 ) ; } } } ) ; }
<|startcomment|> delete TYPE_2 java file <|endcomment|> <START> public void METHOD_1 ( TYPE_1 event ) throws TYPE_2 { <END> log . info ( STRING_1 , event . getType ( ) ) ; switch ( event . type ) { case VAR_1 : METHOD_2 ( ) ; break ; case VAR_2 : METHOD_3 ( ) ; break ; case VAR_3 : METHOD_4 ( ) ; break ; case VAR_4 : METHOD_5 ( event ) ; break ; case VAR_5 : METHOD_6 ( event ) ; break ; default : log . error ( STRING_2 , event . type ) ; } }
<|startcomment|> don t firing events holding locks receives a TYPE_2 access _CODE_ ( altogether unreasonable ! ) ll a nasty deadlock VAR_1 a _CODE_ drop synchronization <|endcomment|> public void METHOD_1 ( final TYPE_1 error ) { synchronized ( VAR_1 ) { VAR_1 . remove ( error ) ; <START> VAR_2 . METHOD_2 ( new TYPE_2 ( error ) ) ; <END> } }
<|startcomment|> remove METHOD_1 external annotation Collections VAR_3 ( ) <|endcomment|> public TYPE_1 ( ) { VAR_2 = <START> METHOD_1 ( Collections . VAR_3 ( ) ) ; <END> }
<|startcomment|> case switching opinion s etry / finnally : METHOD_2 ( ) ; { METHOD_3 ( VAR_1 ) ; / / opens new tab template _CODE_ METHOD_4 ( ) ; return new TYPE_1 ( VAR_2 ) ; } finally { METHOD_5 ( ) ; } s clearer reading <|endcomment|> public TYPE_1 METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( VAR_1 ) ; VAR_1 . METHOD_4 ( ) ; METHOD_5 ( ) ; <START> return new TYPE_1 ( VAR_2 ) ; <END> }
<|startcomment|> work ? ( removing import ) suggestion METHOD_5 ( VAR_3 - > VAR_3 [ 0 ] instanceof TYPE_3 ) ; <|endcomment|> ANNOTATION_1 public void METHOD_1 ( ) { TYPE_1 factory = new TYPE_1 ( ) ; factory . VAR_1 ( new TYPE_2 ( ) ) ; assertThat ( VAR_2 . METHOD_2 ( factory ) . METHOD_3 ( ) ) . METHOD_4 ( 2 ) <START> . METHOD_5 ( VAR_3 - > asList ( VAR_3 ) . get ( 0 ) instanceof TYPE_3 ) ; <END> }
<|startcomment|> ArrayList < > <|endcomment|> private static List < TYPE_1 > METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; <END> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { TYPE_1 resource = VAR_1 [ i ] ; TYPE_2 VAR_3 = resource . VAR_4 ( ) ; if ( resource . getType ( ) == TYPE_1 . VAR_5 && VAR_3 != null && VAR_3 . METHOD_2 ( ) ) VAR_2 . add ( resource ) ; } return VAR_2 ; }
<|startcomment|> I necessary GC remove soon more reference Object <|endcomment|> void METHOD_1 ( TYPE_1 key ) { List < TYPE_2 > data = METHOD_2 ( ) . get ( key ) ; if ( data != null ) { <START> data . clear ( ) ; <END> } METHOD_2 ( ) . remove ( key ) ; }
<|startcomment|> IllegalArgumentException sounds <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! METHOD_2 ( VAR_1 ) ) { <START> throw new RuntimeException ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } return METHOD_3 ( VAR_1 , VAR_2 ) . isPresent ( ) && METHOD_3 ( VAR_1 , VAR_3 ) . isPresent ( ) ; }
<|startcomment|> nice add exception text unable METHOD_2 list connector configurations <|endcomment|> public boolean METHOD_1 ( String id ) { try { List < TYPE_1 > list = VAR_1 . METHOD_2 ( TYPE_2 . of ( Constants . VAR_2 , id ) ) ; if ( list . isEmpty ( ) ) { return false ; } return true ; } catch ( TYPE_3 e ) { <START> throw new RuntimeException ( e ) ; <END> } }
<|startcomment|> separate test cases returning clause <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( STRING_1 ) ; METHOD_2 ( STRING_2 ) ; METHOD_2 ( STRING_3 ) ; METHOD_2 ( STRING_4 ) ; METHOD_2 ( STRING_5 ) ; METHOD_2 ( STRING_6 ) ; METHOD_2 ( STRING_7 ) ; METHOD_2 ( STRING_8 ) ; METHOD_2 ( STRING_9 ) ; METHOD_2 ( STRING_10 ) ; METHOD_2 ( STRING_11 ) ; <START> } <END>
<|startcomment|> I other parts class put METHOD_2 calls another method call s sake slightly readability : METHOD_2 ( path STRING_1 ) ; VAR_1 set ( path ) ; <|endcomment|> public void METHOD_1 ( String path ) { <START> VAR_1 . set ( METHOD_2 ( path , STRING_1 ) ) ; <END> }
<|startcomment|> public TYPE_1 METHOD_1 ( ) throws IOException InterruptedException { TYPE_1 VAR_1 = VAR_1 ; ( VAR_1 ! = null ) { return VAR_1 ; VAR_1 = TYPE_1 METHOD_2 ( METHOD_3 ( ) ) ; / / - null values equivalent a race doesn t matter winsthis VAR_1 = VAR_1 ; return VAR_1 ; } <|endcomment|> public TYPE_1 METHOD_1 ( ) throws IOException , InterruptedException { if ( VAR_1 != null ) { <START> return VAR_1 ; <END> } VAR_1 = TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) ; return VAR_1 ; }
<|startcomment|> add METHOD_2 <|endcomment|> public int METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> try { return VAR_2 ; } finally { VAR_1 . METHOD_3 ( ) ; } }
<|startcomment|> isEmpty ( ) <|endcomment|> public void METHOD_1 ( ) { List < TYPE_1 > result = VAR_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) , VAR_3 , true ) ; assertNotNull ( result ) ; <START> assertTrue ( result . size ( ) == 0 ) ; <END> }
<|startcomment|> –Ø –µ—â–µ –ª—é–±–ª—é –≤ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Å—Ç–∞–≤–ª—è—Ç—å –∏–∑–Ω–∞—á–∞–ª—å–Ω—ã–π exception n–∏–ø–∞ failed check data source + e toString ( ) e ) <|endcomment|> private static TYPE_1 METHOD_1 ( String name , Map < Object , Object > properties ) { TYPE_2 VAR_1 = new TYPE_2 ( false ) ; VAR_1 . METHOD_2 ( name ) ; VAR_1 . METHOD_3 ( name ) ; new TYPE_3 ( VAR_1 ) . METHOD_4 ( properties ) ; TYPE_4 . METHOD_5 ( VAR_1 ) ; try { METHOD_6 ( VAR_1 , name ) ; } catch ( TYPE_5 e ) { <START> throw new RuntimeException ( STRING_1 , e ) ; <END> } return VAR_1 ; }
<|startcomment|> need center give SWT <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 parent ) { METHOD_2 ( Messages . TYPE_5 ) ; <START> TYPE_3 VAR_2 = new TYPE_3 ( parent , SWT . VAR_3 ) ; <END> VAR_2 . setText ( TYPE_4 . bind ( Messages . TYPE_6 , VAR_5 . METHOD_3 ( ) ) ) ; return parent ; }
<|startcomment|> I need call super loose permissions need check default <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > list = new ArrayList < TYPE_1 > ( ) ; Guid VAR_1 = METHOD_2 ( ) == null || METHOD_2 ( ) . METHOD_3 ( ) == null ? null : METHOD_2 ( ) . METHOD_3 ( ) . getValue ( ) ; list . add ( new TYPE_1 ( VAR_1 , TYPE_4 . TYPE_3 , METHOD_4 ( ) . METHOD_5 ( ) ) ) ; TYPE_2 . METHOD_6 ( list , METHOD_7 ( ) , METHOD_8 ( ) ) ; return list ; <START> } <END>
<|startcomment|> wrong error propagated drivers init struct size 2 size 1 saved ignoring struct size read init message <|endcomment|> public void METHOD_1 ( String VAR_1 , Map < String , Object > VAR_2 ) throws IOException { <START> VAR_3 . METHOD_2 ( 1 , TYPE_1 . METHOD_3 ( ) ) ; <END> VAR_3 . METHOD_4 ( VAR_1 ) ; VAR_3 . METHOD_4 ( TYPE_2 . METHOD_5 ( VAR_2 ) ) ; VAR_4 . METHOD_6 ( ) ; }
<|startcomment|> remove public modifier <|endcomment|> <START> public TYPE_3 ( TYPE_1 VAR_2 , <END> TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; }
<|startcomment|> elena need block <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_3 . TYPE_4 VAR_2 ) { TYPE_1 VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; if ( VAR_3 == null ) { VAR_3 = METHOD_3 ( VAR_1 , VAR_2 ) ; if ( VAR_3 == null ) { VAR_3 = METHOD_4 ( VAR_1 , VAR_2 ) ; <START> if ( VAR_3 == null ) { <END> return null ; } } } return VAR_3 ; }
<|startcomment|> ( TYPE_2 ) needed <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 . METHOD_2 ( ) ) { return ; } <START> VAR_2 . METHOD_3 ( ( TYPE_2 ) this : : METHOD_4 , VAR_1 . METHOD_5 ( ) , TimeUnit . VAR_3 ) ; <END> }
<|startcomment|> technically VAR_1 close ( ) ( t - w - r ) ensure proper cleanup temp files ( whatevers ) created <|endcomment|> public static void METHOD_1 ( String [ ] args ) { <START> TYPE_1 VAR_1 = METHOD_2 ( TYPE_2 . of ( STRING_1 , STRING_2 ) ) ; <END> new TYPE_3 ( VAR_1 ) . METHOD_3 ( new TYPE_4 ( System . out ) ) ; }
<|startcomment|> shouldn t protected public <|endcomment|> <START> public void METHOD_1 ( TYPE_1 options ) { <END> }
<|startcomment|> ah I guess lack a guice context ( ) reason system properties ? solve jclouds ? inject some kind factory object guice <|endcomment|> public Builder METHOD_1 ( String VAR_1 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; METHOD_3 ( VAR_1 . METHOD_4 ( ) . length <= METHOD_5 ( VAR_2 ) , <START> STRING_2 , METHOD_5 ( VAR_2 ) ) ; <END> this . VAR_3 = new TYPE_1 ( VAR_1 ) . toString ( ) ; return METHOD_6 ( ) ; }
<|startcomment|> s / STRING_1 / TYPE_2 <|endcomment|> private String METHOD_1 ( TYPE_1 request ) { String token = null ; String VAR_1 = request . VAR_2 ( TYPE_3 . VAR_4 ) ; if ( VAR_1 != null && VAR_1 . startsWith ( TYPE_2 ) ) { token = <START> VAR_1 . substring ( STRING_1 . length ( ) ) . trim ( ) ; <END> } return token ; }
<|startcomment|> method public s point <|endcomment|> <START> public static TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 != null ) { return VAR_1 ; } else { if ( VAR_2 == null ) { synchronized ( VAR_3 ) { if ( VAR_2 == null ) { METHOD_2 ( ) ; } } } VAR_1 = VAR_2 . stream ( ) . filter ( c - > c . VAR_4 ( ) != null ) . METHOD_3 ( ) . METHOD_4 ( ( ) - > new IllegalStateException ( STRING_1 ) ) ; return VAR_1 ; } }
<|startcomment|> Exception thrown <|endcomment|> <START> public void METHOD_1 ( ) throws Exception { <END> METHOD_2 ( TYPE_1 . class , TYPE_2 . class , true ) ; }
<|startcomment|> container exists method return false [ container exists call returns a 404 ] ( ) worth removing catch caused other errors acount <|endcomment|> public static boolean METHOD_1 ( String VAR_1 , String key ) { final TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( STRING_1 ) . METHOD_3 ( VAR_1 , key ) . METHOD_4 ( TYPE_1 . class ) ; try { return VAR_2 . METHOD_5 ( STRING_2 ) ; } catch ( Exception e ) { e . VAR_3 ( ) ; return false ; <START> } <END> finally { TYPE_3 . METHOD_6 ( VAR_2 ) ; } }
<|startcomment|> convention called s a explicit reason needs happen ( a code smell ) <|endcomment|> public void METHOD_1 ( ) { VAR_1 = ( TYPE_1 . VAR_3 == VAR_4 . METHOD_2 ( ) . VAR_5 ) ; <START> super . METHOD_1 ( ) ; <END> }
<|startcomment|> static import functions <|endcomment|> public static TYPE_1 < TYPE_2 > METHOD_1 ( ) { return VAR_1 - > { VAR_1 = METHOD_2 ( VAR_1 ) ; if ( VAR_1 instanceof TYPE_3 && TYPE_4 . METHOD_3 ( VAR_1 ) && <START> ! TYPE_5 . METHOD_4 ( VAR_1 ) && <END> ! METHOD_5 ( VAR_1 ) ) { TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; if ( VAR_2 . getType ( ) == TYPE_6 . VAR_4 ) { return ! VAR_2 . METHOD_6 ( ) . equals ( VAR_2 . METHOD_7 ( ) ) ; } } return false ; } ; }
<|startcomment|> needed <|endcomment|> public void METHOD_1 ( ) throws Exception { VAR_1 = TYPE_1 . create ( VAR_2 , true ) ; VAR_1 . start ( ) ; <START> TYPE_3 . TYPE_4 . set ( TYPE_3 . TYPE_5 . VAR_5 ) ; <END> }
<|startcomment|> mind code style <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 == null ) return null ; <END> TYPE_1 . Type type = null ; switch ( VAR_2 ) { case VAR_3 : type = TYPE_1 . Type . VAR_4 ; break ; case VAR_5 : type = TYPE_1 . Type . VAR_6 ; break ; } return new TYPE_1 ( type , new TYPE_2 ( VAR_1 , VAR_7 ) ) ; }
<|startcomment|> merge lines METHOD_2 return argument <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 method ) { TYPE_3 . METHOD_2 ( method , STRING_1 ) ; <START> this . method = method ; <END> return this ; }
<|startcomment|> a matter taste - VAR_2 avoided sake return statements - else block <|endcomment|> public Set < TYPE_1 > METHOD_1 ( TYPE_2 version ) { if ( ! TYPE_3 . METHOD_2 ( version ) ) { return Collections . VAR_1 ( ) ; } <START> Set < TYPE_1 > VAR_2 ; <END> TYPE_4 < TYPE_1 , Map < String , TYPE_5 > > map = VAR_3 . get ( version ) ; if ( map . isEmpty ( ) ) { VAR_2 = Collections . VAR_1 ( ) ; } else { VAR_2 = Collections . VAR_4 ( map . keySet ( ) ) ; } return VAR_2 ; }
<|startcomment|> generic mars code won t compile previous platform <|endcomment|> public TYPE_10 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 ) throws TYPE_3 { super ( VAR_2 , VAR_3 ) ; TYPE_4 VAR_4 = TYPE_5 . METHOD_1 ( new TYPE_6 < TYPE_4 > ( ) { @Override public TYPE_4 run ( ) { final TYPE_7 VAR_5 = VAR_6 . METHOD_2 ( true ) ; <START> return VAR_5 . METHOD_3 ( TYPE_4 . class ) ; <END> } } ) ; TYPE_8 . METHOD_4 ( this , STRING_1 , new TYPE_9 ( VAR_4 ) , this . getClass ( ) . METHOD_5 ( ) ) ; }
<|startcomment|> I d prefer handled ( snapshot type ) a separate change <|endcomment|> public TYPE_2 ( ) { VAR_2 = true ; <START> VAR_3 = TYPE_1 . VAR_5 ; <END> VAR_6 = true ; VAR_7 = Collections . VAR_8 ( ) ; }
<|startcomment|> afacit vvv noise <|endcomment|> public TYPE_1 < ? > METHOD_1 ( String VAR_1 ) throws IllegalArgumentException <START> { <END> try { return METHOD_2 ( VAR_1 ) ; } catch ( TYPE_2 e ) { this . logger . debug ( STRING_1 + VAR_1 , e ) ; throw new IllegalArgumentException ( STRING_2 + VAR_1 , e ) ; } }
<|startcomment|> worries a bit imagine _each_ decorator start service ( means I m familiar papyrus services ) check a common services ? share a common instance decorators <|endcomment|> public TYPE_6 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> VAR_3 = new TYPE_2 ( ) ; <END> try { VAR_3 . METHOD_1 ( ) ; } catch ( TYPE_3 ex ) { TYPE_4 . METHOD_2 ( ) . METHOD_3 ( ) . log ( new Status ( TYPE_5 . VAR_5 , TYPE_4 . VAR_6 , STRING_1 , ex ) ) ; } }
<|startcomment|> rely Optional introducing another method lead _CODE_ <|endcomment|> <START> default TYPE_1 VAR_2 ( ) { <END> return null ; }
<|startcomment|> create empty directory tests extend class ? I guess need create tests need <|endcomment|> public static void METHOD_1 ( ) throws Exception { config = TYPE_1 . create ( METHOD_2 ( ) ) ; VAR_1 = TYPE_2 . METHOD_3 ( config ) ; METHOD_4 ( ) ; METHOD_5 ( STRING_1 ) ; <START> METHOD_6 ( ) ; <END> }
<|startcomment|> I code necessary wrong throw new RuntimeException ( ) method s prefer <|endcomment|> private static String METHOD_1 ( final TYPE_1 < Class < ? > > VAR_1 , final String VAR_2 ) { try { VAR_1 . get ( ) ; <START> throw new RuntimeException ( VAR_2 ) ; <END> } catch ( TYPE_2 VAR_3 ) { return VAR_3 . METHOD_2 ( ) . toString ( ) ; } }
<|startcomment|> return null instead priority <|endcomment|> default TYPE_1 VAR_2 ( ) { <START> return TYPE_1 . VAR_3 ; <END> }
<|startcomment|> ? ? pourquoi cette ligne TYPE_3 est d√©j√† une classe concr√®te <|endcomment|> protected void METHOD_1 ( ) { bind ( TYPE_1 . class ) . to ( TYPE_2 . class ) . METHOD_2 ( ) ; <START> bind ( TYPE_3 . class ) ; <END> }
<|startcomment|> VAR_1 check necessary <|endcomment|> public static void METHOD_1 ( TYPE_1 event ) { <START> if ( VAR_1 && event . VAR_2 ( ) . METHOD_2 ( ) != null && event . VAR_2 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ) <END> { logger . info ( STRING_1 , event . VAR_3 ( ) . METHOD_4 ( ) , event . VAR_2 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; } }
<|startcomment|> s TYPE_2 create avoid / catch <|endcomment|> public TYPE_4 ( ) { try { TYPE_1 VAR_2 = new TYPE_1 ( new TYPE_2 ( STRING_1 ) ) ; <START> VAR_3 . add ( VAR_2 ) ; <END> } catch ( TYPE_3 e ) { throw new IllegalStateException ( e ) ; } }
<|startcomment|> need content constructor <|endcomment|> public TYPE_1 ( ) { <START> this . VAR_2 = null ; <END> this . VAR_3 = false ; }
<|startcomment|> return <|endcomment|> public void METHOD_1 ( TYPE_1 stream ) { <START> if ( ! stream . VAR_1 ( ) ) { <END> TYPE_2 listener = new TYPE_2 ( ) ; TYPE_3 props = stream . VAR_2 ( ) ; synchronized ( props ) { props . VAR_3 ( VAR_4 , listener ) ; } stream . VAR_5 ( listener ) ; } }
<|startcomment|> result - > size <|endcomment|> public long METHOD_1 ( ) { <START> int result = VAR_1 ; <END> result += METHOD_2 ( VAR_2 ) ; result += VAR_3 . METHOD_2 ( ) ; for ( T item : VAR_4 ) { result += item . VAR_5 ( ) ; } return result ; }
<|startcomment|> = = instead equals ( instances ) null - safe <|endcomment|> public boolean METHOD_1 ( TYPE_1 event ) { TYPE_2 r = event . VAR_1 ( ) ; <START> if ( event . VAR_2 ( ) . equals ( TYPE_4 . VAR_4 ) && r . VAR_5 ( ) . equals ( TYPE_5 . TYPE_3 ) ) { <END> log . info ( STRING_1 + r . VAR_8 ( ) + STRING_2 + event . VAR_9 ( ) ) ; return true ; } return false ; }
<|startcomment|> en profiter pour enlever cette variable interm√©diaire <|endcomment|> public boolean METHOD_1 ( ) { <START> final boolean res = super . METHOD_1 ( ) || METHOD_2 ( ) ; <END> return res ; }
<|startcomment|> I understand change correctly shouldn t needed anymore <|endcomment|> private void METHOD_1 ( boolean value ) { TYPE_1 VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) ; try { <START> VAR_1 . METHOD_3 ( ) ; <END> METHOD_4 ( VAR_1 , value ) ; } catch ( IOException | TYPE_3 e ) { LOG . error ( TYPE_4 . format ( TYPE_5 . get ( ) . VAR_2 , VAR_1 , e ) ) ; } }
<|startcomment|> method static i guess ? more relevant : method necessary ? i usage <|endcomment|> <START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_1 instanceof TYPE_2 ; }
<|startcomment|> please check fragment exists lead a null - pointer exception <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = ( ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( TYPE_1 . VAR_3 ) ) ; <START> VAR_2 . METHOD_4 ( VAR_1 . VAR_4 ) ; <END> return VAR_2 ; }
<|startcomment|> shouldn t return TYPE_1 ? TYPE_1 null means <|endcomment|> public final TYPE_1 METHOD_1 ( ) { String s = METHOD_2 ( ) ; return s != null ? TYPE_1 . valueOf ( s ) : <START> null ; <END> }
<|startcomment|> VAR_1 nullable <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return ImmutableList . of ( new TYPE_3 ( name , METHOD_2 ( ) , Optional . of ( VAR_1 ) ) ) ; <END> }
<|startcomment|> apply saveaction <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( INT_1 ) ; <END> assertEquals ( INT_1 , VAR_2 . METHOD_3 ( STRING_1 ) ) ; }
<|startcomment|> I I 20 exercise key migration code more <|endcomment|> protected void METHOD_1 ( ) throws Throwable { TYPE_1 builder = METHOD_2 ( METHOD_3 ( ) , true ) ; <START> builder . VAR_1 ( ) . METHOD_4 ( ) . METHOD_5 ( INT_1 ) . METHOD_6 ( ) . METHOD_7 ( INT_2 , TimeUnit . VAR_2 ) ; <END> METHOD_8 ( 4 , METHOD_9 ( ) , builder ) ; }
<|startcomment|> METHOD_3 ( ) <|endcomment|> private String METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 != null && VAR_2 . METHOD_3 ( ) != null ) { return STRING_1 + <START> VAR_2 . METHOD_4 ( ) ; <END> } return "" ; }
<|startcomment|> I auth system remain method <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> context . VAR_1 ( ) ; <END> METHOD_2 ( ) . METHOD_3 ( get ( STRING_1 ) . METHOD_4 ( STRING_2 , STRING_3 ) ) . METHOD_5 ( status ( ) . METHOD_6 ( ) ) . METHOD_5 ( content ( ) . METHOD_7 ( VAR_2 ) ) . METHOD_5 ( METHOD_8 ( STRING_4 , is ( INT_1 ) ) ) . METHOD_5 ( METHOD_8 ( STRING_5 , is ( 0 ) ) ) ; }
<|startcomment|> private static <|endcomment|> <START> private void addAll ( TYPE_1 VAR_1 , long ... values ) <END> { METHOD_1 ( values , STRING_1 ) ; for ( long value : values ) { VAR_1 . add ( value ) ; } }
<|startcomment|> move default <|endcomment|> protected Object METHOD_1 ( TYPE_1 command ) { METHOD_2 ( command , TYPE_2 . VAR_2 ) ; switch ( command . getType ( ) ) { case TYPE_1 . VAR_3 : return METHOD_3 ( command , STRING_1 , TYPE_1 . VAR_4 ) ; case TYPE_1 . VAR_5 : return METHOD_3 ( command , STRING_2 , TYPE_1 . VAR_6 ) ; case TYPE_1 . VAR_7 : return METHOD_3 ( command , STRING_3 , TYPE_1 . VAR_8 , TYPE_1 . VAR_6 ) ; default : break ; } <START> return null ; <END> }
<|startcomment|> shouldn t need check clear fields _CODE_ a closeable guarantees close ( ) idempotent : > stream closed invoking method effect <|endcomment|> public void close ( ) throws IOException { <START> if ( VAR_1 != null ) { <END> VAR_1 . close ( ) ; VAR_1 = null ; VAR_2 = null ; } }
<|startcomment|> ( ) ( btw VAR_1 plain check hoisted d turning null ) <|endcomment|> @Override public boolean METHOD_1 ( ) { <START> return VAR_1 == null ; <END> }
<|startcomment|> I need super close ( ) <|endcomment|> public void close ( ) throws IOException { if ( VAR_1 != null ) { <START> VAR_1 . close ( ) ; <END> } }
<|startcomment|> ( VAR_1 VAR_1 ) doesn t <|endcomment|> public void METHOD_1 ( int x , int VAR_1 ) { <START> VAR_2 . METHOD_1 ( VAR_1 , VAR_1 ) ; <END> }
<|startcomment|> rm public <|endcomment|> <START> public TYPE_3 ( TYPE_1 VAR_2 , <END> Logger logger , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; this . logger = logger ; this . VAR_3 = VAR_3 ; }
<|startcomment|> replace equals = = enums <|endcomment|> protected boolean METHOD_1 ( ) { if <START> ( TYPE_1 . VAR_1 . equals ( TYPE_1 . METHOD_2 ( getParameters ( ) . METHOD_3 ( ) . getType ( ) ) ) ) <END> { METHOD_4 ( TYPE_2 . VAR_3 ) ; return true ; } return false ; }
<|startcomment|> great map generics <|endcomment|> <START> public List < Map > METHOD_1 ( Context context ) throws TYPE_1 { <END> return VAR_1 . METHOD_1 ( context ) ; }
<|startcomment|> ) { line <|endcomment|> TYPE_3 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , <START> final long VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; }
<|startcomment|> need throw exception ? remove TODO <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) <START> throws IOException { <END> VAR_4 = VAR_2 ; VAR_5 = VAR_3 ; VAR_6 = ( int ) TYPE_3 . METHOD_1 ( TYPE_5 . VAR_8 ) ; VAR_9 = System . currentTimeMillis ( ) - VAR_6 ; }
<|startcomment|> alisteners forEach ( listener - > VAR_3 ( VAR_1 ) ) ; time more compact readable faster ( streams slow ) <|endcomment|> public void METHOD_1 ( String VAR_1 ) { <START> VAR_2 . stream ( ) . METHOD_2 ( listener - > { <END> listener . VAR_3 ( VAR_1 ) ; } ) ; }
<|startcomment|> please immutable collection <|endcomment|> public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 options ) { <START> List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; <END> VAR_2 . add ( new TYPE_1 ( options . getString ( TYPE_4 . VAR_4 ) , TYPE_5 . VAR_6 ) ) ; VAR_2 . add ( new TYPE_1 ( options . getString ( TYPE_4 . VAR_7 ) , TYPE_5 . VAR_6 ) ) ; return VAR_2 ; }
<|startcomment|> _CODE_ constructor _CODE_ instead TYPE_4 <|endcomment|> protected TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <START> super ( ( TYPE_4 ) VAR_2 , VAR_3 , VAR_4 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; }
<|startcomment|> VAR_2 t null constructor throw a NPE <|endcomment|> public int METHOD_1 ( ) { int result = name != null ? name . VAR_1 ( ) : 0 ; <START> result = INT_1 * result + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) ; <END> result = INT_1 * result + VAR_3 ; return result ; }
<|startcomment|> VAR_2 <|endcomment|> public TYPE_4 ( Object VAR_2 , String VAR_3 ) { if ( VAR_2 instanceof TYPE_1 ) { this . VAR_2 = ( TYPE_1 ) VAR_2 ; } else { this . VAR_2 = new TYPE_2 ( VAR_2 , VAR_3 ) ; } this . VAR_4 = <START> TYPE_3 . METHOD_1 ( this . VAR_2 . METHOD_2 ( ) ) ; <END> }
<|startcomment|> extract VAR_3 - stream extraction method <|endcomment|> public List < String > METHOD_1 ( String input ) { <START> return TYPE_1 . getInstance ( ) . METHOD_2 ( ) <END> . METHOD_3 ( TYPE_3 . VAR_2 ) . METHOD_4 ( ) . stream ( ) . map ( TYPE_2 : : getId ) . filter ( VAR_3 - > VAR_3 . startsWith ( input ) ) . collect ( Collectors . VAR_4 ( ) ) ; }
<|startcomment|> I don t understand - perform command host connection removed db perform disconnect other hosts ? load connection return null ? care i guess <|endcomment|> <START> protected void METHOD_1 ( ) { <END> boolean VAR_1 = METHOD_2 ( ) ; if ( VAR_1 ) { String VAR_2 = METHOD_3 ( ) . METHOD_4 ( ) ; if ( StringUtils . VAR_3 ( VAR_2 ) ) { METHOD_5 ( ) . METHOD_6 ( ) . remove ( VAR_2 ) ; METHOD_7 ( true ) ; } } }
<|startcomment|> curious : remove METHOD_2 <|endcomment|> public void METHOD_1 ( ) { ANNOTATION_1 ( STRING_1 ) String VAR_1 = STRING_2 ; TYPE_1 VAR_2 = METHOD_2 ( METHOD_3 ( <START> METHOD_4 ( VAR_3 - > VAR_3 <END> . METHOD_5 ( VAR_4 ) . METHOD_6 ( METHOD_7 ( STRING_3 , Optional . empty ( ) , ImmutableList . of ( ) ) ) , METHOD_2 ( VAR_5 ) ) ) ) ; METHOD_8 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> perform operation custom TYPE_3 METHOD_3 ( ) method instead <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { String VAR_2 = METHOD_2 ( VAR_1 ) ; TYPE_1 VAR_3 = <START> TYPE_3 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <END> if ( VAR_3 == null ) { throw new TYPE_4 ( STRING_1 , VAR_2 ) ; } return VAR_3 ; }
<|startcomment|> please replace occurrences TYPE_3 code style recommend add a prefix a function call function current object <|endcomment|> public final TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return ( ) - > TYPE_3 . this . METHOD_2 ( ) ; <END> }
<|startcomment|> a leftover removed <|endcomment|> void put ( final TYPE_1 key , final TYPE_2 value ) { VAR_1 . put ( VAR_2 , key , value ) ; <START> System . out . println ( STRING_1 + key + STRING_2 + Thread . VAR_3 ( ) . getName ( ) ) ; <END> METHOD_1 ( key , value ) ; }
<|startcomment|> missed a space ) { <|endcomment|> <START> public static String METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = "" ; if ( METHOD_2 ( VAR_1 ) . length ( ) == 0 && VAR_1 . length ( ) > 0 ) { if ( ! VAR_1 . METHOD_3 ( STRING_1 ) ) { String VAR_3 = TYPE_1 . METHOD_4 ( ) ; VAR_1 = VAR_1 . METHOD_5 ( STRING_2 , STRING_3 ) . METHOD_6 ( STRING_3 , STRING_4 ) ; VAR_2 = VAR_3 + STRING_5 + VAR_1 + STRING_6 ; } } return VAR_2 ; }
<|startcomment|> doesn t change <|endcomment|> public ANNOTATION_1 TYPE_1 [ ] METHOD_1 ( ) { List < TYPE_2 > VAR_1 = METHOD_2 ( TYPE_3 . class ) ; if ( VAR_1 . size ( ) > 0 ) { TYPE_3 group = ( TYPE_3 ) VAR_1 . get ( 0 ) ; List < TYPE_2 > VAR_2 = group . VAR_3 ( TYPE_1 . class ) ; return VAR_2 . METHOD_3 ( new ANNOTATION_1 TYPE_1 [ VAR_2 . size ( ) ] ) ; } return new <START> ANNOTATION_1 TYPE_1 [ 0 ] ; <END> }
<|startcomment|> minor : move declaration block <|endcomment|> private static void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) ; VAR_3 = TYPE_2 . METHOD_4 ( VAR_1 ) . METHOD_3 ( ) ; TYPE_3 VAR_4 = TYPE_2 . METHOD_5 ( VAR_1 ) ; <START> TYPE_3 VAR_5 = TYPE_2 . METHOD_6 ( VAR_1 ) ; <END> if ( VAR_4 != null ) { VAR_6 = VAR_4 . METHOD_3 ( ) ; } if ( VAR_5 != null ) { VAR_7 = VAR_5 . METHOD_3 ( ) ; } }
<|startcomment|> _CODE_ _CODE_ ( getClass ( ) _CODE_ class ) ; check type parameter <|endcomment|> private TYPE_1 < T > METHOD_1 ( TYPE_2 f ) { if ( f instanceof TYPE_1 ) { <START> return ( TYPE_1 < T > ) f ; <END> } else if ( f instanceof TYPE_3 ) { for ( TYPE_2 VAR_1 : ( ( TYPE_3 ) f ) . METHOD_2 ( ) ) { TYPE_1 < T > b = METHOD_1 ( VAR_1 ) ; if ( b != null ) { return b ; } } } return null ; }
<|startcomment|> fix <|endcomment|> public void METHOD_1 ( ) throws Exception { final String VAR_1 = STRING_1 + STRING_2 <START> + STRING_3 <END> + STRING_4 + STRING_5 + STRING_6 + STRING_7 ; VAR_2 . METHOD_2 ( ( ) - > { assertEquals ( STRING_8 , VAR_1 , VAR_3 . METHOD_3 ( ) ) ; assertEquals ( STRING_9 , "" , VAR_4 . METHOD_3 ( ) ) ; } ) ; TYPE_1 . METHOD_4 ( STRING_10 , getPath ( STRING_11 ) , STRING_12 , getPath ( STRING_13 ) ) ; }
<|startcomment|> method return null ? return empty string <|endcomment|> public String METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) != null ) { return VAR_1 . METHOD_2 ( ) . getName ( ) ; } <START> return null ; <END> }
<|startcomment|> java lang String <|endcomment|> public void METHOD_1 ( ) { Set < TYPE_1 > VAR_1 = METHOD_2 ( TYPE_1 . class , VAR_2 ) ; TYPE_1 VAR_3 = VAR_1 . iterator ( ) . next ( ) ; assertTrue ( VAR_3 . METHOD_3 ( ) ) ; <START> assertEquals ( STRING_1 , VAR_3 . METHOD_4 ( ) ) ; <END> }
<|startcomment|> formatting weird <|endcomment|> public TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( final TYPE_4 < TYPE_2 > VAR_1 ) { TYPE_1 . Builder builder = TYPE_1 . builder ( ) ; for ( TYPE_2 key : VAR_1 <START> ) { <END> TYPE_3 value = METHOD_2 ( key ) ; if ( value != null ) { builder . put ( key , value ) ; } } return builder . build ( ) ; }
<|startcomment|> please protected avoid exposing methods consumers API care <|endcomment|> <START> public void METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_2 VAR_2 = METHOD_2 ( ) ; TYPE_3 VAR_3 = METHOD_3 ( ) ; TYPE_4 filter = new TYPE_4 ( VAR_2 ) ; filter . VAR_4 ( new TYPE_5 ( VAR_3 ) ) ; VAR_1 . METHOD_4 ( filter , TYPE_6 . VAR_6 ) ; }
<|startcomment|> obtain session ? approach s pluggable <|endcomment|> public void action ( TYPE_1 context ) { if ( TYPE_2 . METHOD_1 ( context ) ) { <START> TYPE_4 . TYPE_5 . action ( context ) ; <END> return ; } METHOD_2 ( context ) ; }
<|startcomment|> A null check needed NPE thrown reopening a large project java lang _CODE_ org eclipse egit core synchronize _CODE_ METHOD_1 ( _CODE_ java : 141 ) org eclipse egit core synchronize _CODE_ access$1 ( _CODE_ java : 137 ) org eclipse egit core synchronize _CODE_ _CODE_ ( _CODE_ java : 69 ) org eclipse egit core internal indexdiff _CODE_ _CODE_ ( _CODE_ java : 94 ) org eclipse egit core internal indexdiff _CODE_ access$0 ( _CODE_ java : 86 ) org eclipse egit core internal indexdiff _CODE_ _CODE_ ( _CODE_ java : 81 ) org eclipse egit core internal indexdiff _CODE_ _CODE_ ( _CODE_ java : 313 ) org eclipse egit core internal indexdiff _CODE_ access$6 ( _CODE_ java : 306 ) org eclipse egit core internal indexdiff _CODE_ run ( _CODE_ java : 171 ) org eclipse core internal jobs worker run ( worker java : 54 ) <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , Collection < TYPE_3 > VAR_3 ) { for ( TYPE_4 VAR_4 : VAR_5 ) { if ( VAR_2 . equals ( VAR_4 . METHOD_2 ( ) ) ) { <START> if ( ! VAR_3 . isEmpty ( ) ) <END> METHOD_3 ( VAR_1 , VAR_3 ) ; else METHOD_4 ( VAR_1 ) ; } } }
<|startcomment|> don t necessarily need type info hand assignment anymore mention ways <|endcomment|> public static Set < Path > METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> Set < Path > VAR_3 = new HashSet < Path > ( ) ; <END> if ( VAR_2 != null ) { TYPE_3 [ ] VAR_4 = TYPE_3 . METHOD_2 ( VAR_2 , VAR_1 . METHOD_3 ( ) ) ; for ( TYPE_3 VAR_5 : VAR_4 ) VAR_3 . add ( VAR_5 . getName ( ) ) ; } return VAR_3 ; }
<|startcomment|> remove unused level remove <|endcomment|> public TYPE_3 ( String VAR_2 , int VAR_3 , int VAR_4 , int VAR_5 , int VAR_6 , TYPE_1 target , TYPE_2 VAR_7 , boolean debug , boolean VAR_8 , Map < String , String > VAR_9 ) { <START> this ( null , null , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , target , VAR_7 , debug , VAR_9 ) ; <END> }
<|startcomment|> I prefer move logic TYPE_1 <|endcomment|> public void execute ( String VAR_1 ) { TYPE_1 VAR_2 = VAR_3 ; TYPE_2 VAR_4 = METHOD_1 ( VAR_1 ) ; if ( VAR_2 == null ) { return ; } <START> TYPE_2 VAR_5 = VAR_3 . METHOD_2 ( ) ; <END> if ( ( VAR_5 != null && ! VAR_5 . equals ( VAR_4 ) ) || ( VAR_5 == null && VAR_4 != null ) ) { VAR_2 . METHOD_3 ( VAR_4 ) ; } METHOD_4 ( ) ; }
<|startcomment|> VAR_2 ‚Äì > separator <|endcomment|> @Override public TYPE_1 write ( TYPE_1 VAR_1 , Context context ) throws IOException { <START> String VAR_2 = "" ; <END> for ( TYPE_2 VAR_3 : VAR_4 ) { VAR_1 . append ( VAR_2 ) ; VAR_3 . write ( VAR_1 , context ) ; VAR_2 = STRING_1 ; } return VAR_1 ; }
<|startcomment|> single - log manager METHOD_1 rotated logs flushing current logs rotates files checkpoint I prefer keeping existing logic unchanged reduce risks besides provide METHOD_1 method _CODE_ ? entry log manager implementation implement flushing logic exposing knowledge _CODE_ provide METHOD_1 method don t need expose METHOD_2 METHOD_3 <|endcomment|> public void METHOD_1 ( ) throws IOException { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( ) ; }
<|startcomment|> notice _CODE_ java needs treatment <|endcomment|> public void METHOD_1 ( ) { boolean VAR_1 = false ; TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> if ( ! METHOD_2 ( ) . contains ( VAR_2 ) ) { <END> METHOD_3 ( VAR_2 ) ; VAR_1 = true ; } if ( METHOD_2 ( ) . contains ( VAR_3 ) ) { METHOD_4 ( VAR_3 ) ; VAR_1 = true ; } if ( VAR_1 ) { VAR_4 . METHOD_5 ( ) ; } }
<|startcomment|> s point return s true <|endcomment|> public boolean METHOD_1 ( TYPE_1 parameters , List < TYPE_2 > VAR_1 ) { List < TYPE_2 > res = METHOD_2 ( VAR_1 , parameters . VAR_2 ( ) . getId ( ) ) ; VAR_1 . clear ( ) ; VAR_1 . addAll ( res ) ; <START> return true ; <END> }
<|startcomment|> I converter part DAO save single entity I suggest i move code service layer <|endcomment|> public TYPE_2 ( ) { <START> this . VAR_2 = new TYPE_1 ( ) ; <END> }
<|startcomment|> ternary operator Optional java8 Optional _CODE_ ( VAR_1 ) _CODE_ ( ( ) - > new TYPE_2 ( ) ) ; <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 != null ) <END> { return VAR_1 ; } else { return new TYPE_2 ( ) ; } }
<|startcomment|> allow field null <|endcomment|> public void METHOD_1 ( final Integer VAR_1 ) { <START> VAR_2 = TYPE_1 . assertNotNull ( VAR_1 , STRING_1 ) ; <END> }
<|startcomment|> change private <|endcomment|> <START> public String METHOD_1 ( ) { <END> String VAR_1 = METHOD_2 ( ) ; return VAR_1 . substring ( 0 , VAR_1 . METHOD_3 ( CHAR_1 ) - 1 ) ; }
<|startcomment|> METHOD_2 ( ) return a list blob ids avoid VAR_1 clear ( ) call VAR_1 = VAR_2 METHOD_2 ( ) everytime <|endcomment|> private List < TYPE_1 > METHOD_1 ( ) { VAR_1 . clear ( ) ; <START> VAR_2 . METHOD_2 ( VAR_1 ) ; <END> for ( String VAR_3 : VAR_1 ) { VAR_4 . METHOD_3 ( VAR_5 . METHOD_4 ( ) , VAR_3 , new TYPE_2 < TYPE_3 > ( ) , null ) ; } List < TYPE_1 > VAR_6 = new ArrayList < TYPE_1 > ( ) ; VAR_2 . METHOD_5 ( VAR_6 ) ; VAR_7 . METHOD_5 ( VAR_6 ) ; VAR_4 . METHOD_5 ( VAR_6 ) ; return VAR_6 ; }
<|startcomment|> static import METHOD_5 <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) { Type type = VAR_1 . METHOD_2 ( STRING_1 ) ; TYPE_5 VAR_5 = VAR_4 . METHOD_3 ( <START> VAR_4 . METHOD_4 ( VAR_6 , TYPE_6 . METHOD_5 ( ImmutableList . of ( type , type ) ) ) ) . METHOD_6 ( ) ; <END> return METHOD_7 ( type , VAR_5 ) ; }
<|startcomment|> easier read surround entire method type / catch : TYPE_1 METHOD_1 ( ) throws IOException { { TYPE_2 VAR_1 = METHOD_2 ( ) ; return TYPE_5 METHOD_4 ( VAR_1 VAR_2 METHOD_5 ( ) METHOD_6 ( ) ) ; } catch ( TYPE_3 e ) { throw TYPE_4 METHOD_3 ( e ) ; } } please apply hint methods type catch <|endcomment|> public TYPE_1 METHOD_1 ( ) throws IOException { TYPE_2 VAR_1 ; try { VAR_1 = METHOD_2 ( ) ; } catch ( TYPE_3 e ) { throw TYPE_4 . METHOD_3 ( e ) ; } return TYPE_5 . METHOD_4 ( VAR_1 , VAR_2 . METHOD_5 ( ) . METHOD_6 ( ) ) ; <START> } <END>
<|startcomment|> Map < TYPE_2 TYPE_3 > result = new TYPE_1 < > ( ) ; <|endcomment|> public TYPE_1 < TYPE_2 , TYPE_3 > METHOD_1 ( TYPE_4 node , TYPE_3 context ) { <START> TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = new TYPE_1 < > ( ) ; <END> node . VAR_2 ( ) . forEach ( source - > VAR_1 . METHOD_2 ( source . VAR_3 ( this , context ) ) ) ; return VAR_1 ; }
<|startcomment|> handle exceptions multi - catch : } catch ( TYPE_5 | TYPE_6 | TYPE_7 | IOException e ) { <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 repo ) { try ( TYPE_3 VAR_1 = new TYPE_3 ( repo ) ) { try { TYPE_4 VAR_2 = repo . VAR_3 ( VAR_4 ) ; return VAR_1 . METHOD_2 ( VAR_2 ) ; <START> } catch ( TYPE_5 e ) { <END> throw new RuntimeException ( e ) ; } catch ( TYPE_6 e ) { throw new RuntimeException ( e ) ; } catch ( TYPE_7 e ) { throw new RuntimeException ( e ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }
<|startcomment|> passing message a marker throw weird _CODE_ <|endcomment|> public void METHOD_1 ( TYPE_1 message ) throws TYPE_2 { TYPE_3 VAR_1 = message . VAR_2 ( ) . getId ( ) ; <START> log . debug ( STRING_1 , <END> VAR_1 , METHOD_2 ( message ) ) ; TYPE_4 . Context time = VAR_3 . time ( ) ; try { TYPE_5 content = METHOD_3 ( VAR_1 ) ; VAR_4 . METHOD_4 ( content ) ; time . VAR_5 ( ) ; } catch ( Exception e ) { VAR_6 . METHOD_5 ( ) ; throw TYPE_6 . METHOD_6 ( e ) ; } }
<|startcomment|> internally druid treats nulls empty strings similar values I workaround _CODE_ = = null ? : _CODE_ s handling nulls empty strings <|endcomment|> public String apply ( String VAR_1 ) { <START> if ( VAR_1 == null ) return null ; <END> TYPE_1 matcher = VAR_2 . matcher ( VAR_1 ) ; return matcher . VAR_3 ( ) ? VAR_1 : null ; }
<|startcomment|> default : throw new IllegalArgumentException <|endcomment|> private void METHOD_1 ( String VAR_1 , List < TYPE_1 > VAR_2 ) throws IOException { write ( STRING_1 + VAR_1 ) ; for ( TYPE_1 cmd : VAR_2 ) { switch ( cmd . VAR_3 ( ) ) { case VAR_4 : write ( STRING_2 + cmd . VAR_5 ( ) ) ; break ; case VAR_6 : write ( STRING_3 + cmd . VAR_5 ( ) ) ; break ; <START> } <END> } }
<|startcomment|> consider ! _CODE_ isEmpty ( ) <|endcomment|> private Set < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , List < TYPE_2 > VAR_2 ) { Set < TYPE_1 > VAR_3 = null ; <START> while ( VAR_3 == null && VAR_2 . size ( ) > 0 ) { <END> VAR_3 = METHOD_1 ( VAR_1 ) ; if ( VAR_3 == null ) { METHOD_2 ( VAR_1 , TYPE_3 . VAR_5 ) ; METHOD_3 ( VAR_1 ) ; VAR_2 . remove ( VAR_1 ) ; VAR_1 = METHOD_4 ( VAR_2 , VAR_1 ) ; } } return VAR_3 ; }
<|startcomment|> ! [ MINOR ] ( severity : MINOR ) remove redundant ! _CODE_ ! thrown exception declaration ( s ) [ ! [ rule ] ( ) ] ( ) <|endcomment|> public static String METHOD_1 ( final TYPE_1 VAR_1 ) <START> throws TYPE_2 , TYPE_3 , TYPE_4 { <END> TYPE_5 host = VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( TYPE_7 . VAR_4 ) , TYPE_6 . METHOD_4 ( ) , false ) ; return METHOD_5 ( host . VAR_5 ( ) , VAR_1 . METHOD_6 ( ) ) ; }
<|startcomment|> please body line <|endcomment|> void remove ( TYPE_1 key ) { Integer VAR_1 = this . VAR_2 . remove ( key ) ; <START> if ( VAR_1 != null ) this . VAR_3 . set ( VAR_1 , null ) ; <END> }
<|startcomment|> FALSE static final <|endcomment|> public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof TYPE_1 ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> if ( ! name . equals ( that . name ) ) { <END> return false ; } return true ; }
<|startcomment|> private <|endcomment|> <START> protected long METHOD_1 ( ) { <END> return VAR_1 ++ ; }
<|startcomment|> I m INFO message helpful users <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 . info ( STRING_1 + VAR_2 + STRING_2 + VAR_3 + STRING_3 ) ; <END> VAR_4 = true ; }
<|startcomment|> results conversion applyed subclass TYPE_5 applied exact TYPE_5 <|endcomment|> private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 v ) { return VAR_1 instanceof TYPE_3 && ! ( VAR_1 instanceof TYPE_4 ) && v instanceof TYPE_5 ; <START> } <END>
<|startcomment|> TYPE_1 ? filtering <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> VAR_2 = new TYPE_2 ( ) ; VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_2 ( true ) ; VAR_3 . METHOD_3 ( true ) ; VAR_3 . METHOD_4 ( true ) ; VAR_3 . METHOD_5 ( true ) ; VAR_3 . METHOD_6 ( true ) ; VAR_3 . METHOD_7 ( true ) ; VAR_3 . METHOD_8 ( 10 ) ; VAR_3 . METHOD_9 ( 10 ) ; }
<|startcomment|> connector setup fail exception occurs <|endcomment|> public void METHOD_1 ( String url , String VAR_1 ) { TYPE_1 in = null ; try { in = new TYPE_2 ( url ) . METHOD_2 ( ) ; TYPE_3 . METHOD_3 ( new File ( VAR_1 ) , TYPE_4 . METHOD_4 ( in ) ) ; System . out . println ( TYPE_4 . toString ( in ) ) ; } catch ( IOException e ) { <START> log . error ( e ) ; <END> } finally { TYPE_4 . METHOD_5 ( in ) ; } }
<|startcomment|> simpler : VAR_1 ! = && VAR_1 METHOD_2 ( ) <|endcomment|> private boolean METHOD_1 ( TYPE_1 child ) { Boolean VAR_1 = VAR_2 . get ( child ) ; boolean VAR_3 = <START> VAR_1 == null ? false : VAR_1 . METHOD_2 ( ) ; <END> return VAR_3 ; }
<|startcomment|> add tooltip <|endcomment|> public void METHOD_1 ( ANNOTATION_1 final TYPE_1 project , final TYPE_2 VAR_1 , TYPE_3 file , TYPE_4 VAR_2 ) { if ( ! TYPE_5 . METHOD_2 ( file ) ) return ; if ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) { final TYPE_6 VAR_3 = TYPE_7 . METHOD_5 ( VAR_1 ) ; <START> if ( VAR_3 != null && ! VAR_3 . METHOD_6 ( ) ) return ; <END> } METHOD_7 ( new TYPE_8 ( project , VAR_1 , file ) ) ; }
<|startcomment|> removed static <|endcomment|> <START> private List < String > METHOD_1 ( File VAR_1 , TYPE_1 info ) { <END> List < String > VAR_2 = new ArrayList < String > ( ) ; File [ ] VAR_3 = METHOD_2 ( VAR_1 , METHOD_3 ( info ) ) ; for ( File file : VAR_3 ) { VAR_2 . add ( file . getName ( ) ) ; } return VAR_2 ; }
<|startcomment|> jgit spells ( ; ; ) <|endcomment|> TYPE_1 METHOD_1 ( ) { Object r = VAR_1 ; if ( r instanceof TYPE_1 ) return ( TYPE_1 ) r ; TYPE_2 VAR_2 = ( TYPE_2 ) r ; TYPE_1 out = VAR_2 . VAR_3 ; <START> while ( true ) { <END> r = VAR_2 . VAR_4 . VAR_1 ; if ( r instanceof TYPE_1 ) { VAR_1 = out = out . VAR_5 ( ( TYPE_1 ) r ) ; return out ; } VAR_2 = ( TYPE_2 ) r ; out = out . VAR_5 ( VAR_2 . VAR_3 ) ; } }
<|startcomment|> ? ? ? s I revert changes VAR_10 PR clear <|endcomment|> public TYPE_8 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 ) { Assert . VAR_6 ( VAR_2 ) ; Assert . VAR_6 ( VAR_3 ) ; METHOD_1 ( VAR_3 ) ; this . VAR_7 = VAR_2 ; this . VAR_4 = VAR_4 == null ? new TYPE_5 ( TYPE_7 . VAR_9 ) : VAR_4 ; this . VAR_5 = VAR_5 == null ? new TYPE_6 ( ) : VAR_5 ; <START> super . VAR_10 . METHOD_2 ( VAR_11 ) ; <END> VAR_12 = this . VAR_5 instanceof TYPE_6 ; }
<|startcomment|> hmmm wrong ? methods passing null other passing VAR_1 <|endcomment|> public TYPE_1 METHOD_1 ( String group , ANNOTATION_1 String VAR_1 ) { <START> return VAR_2 . apply ( group , null ) ; <END> }
<|startcomment|> need result variable <|endcomment|> public boolean create ( TYPE_1 VAR_1 ) { LOG . trace ( STRING_1 ) ; <START> boolean result = true ; <END> if ( VAR_1 != null ) { result = super . create ( VAR_1 ) ; } LOG . trace ( STRING_2 ) ; return result ; }
<|startcomment|> please log debug trace <|endcomment|> public void METHOD_1 ( TYPE_1 context ) throws Exception { <START> log . info ( STRING_1 + this . getClass ( ) . getName ( ) + STRING_2 + context . VAR_1 ( ) + STRING_2 + context . VAR_2 ( ) ) ; <END> context . VAR_3 ( ) . put ( STRING_3 , this . getClass ( ) . getName ( ) + STRING_2 + context . VAR_1 ( ) + STRING_2 + context . VAR_2 ( ) ) ; context . VAR_4 ( ) ; }
<|startcomment|> I m mistaken shouldn t VAR_1 METHOD_2 ( ) null drop check <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 ) { VAR_2 . METHOD_1 ( VAR_1 ) ; <START> if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) != null ) { <END> VAR_3 . METHOD_4 ( ) . METHOD_5 ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . getName ( ) ) ; } }
<|startcomment|> simple enough inlined <|endcomment|> protected TYPE_1 < TYPE_2 > METHOD_1 ( ) { METHOD_2 ( ) ; TYPE_2 <START> VAR_1 = <END> new TYPE_2 ( vm ) ; return new TYPE_1 < > ( VAR_1 , null ) ; }
<|startcomment|> please split test testing case separately <|endcomment|> public void METHOD_1 ( ) { <START> String VAR_1 = STRING_1 ; <END> String VAR_2 = STRING_2 ; String VAR_3 = "" ; String VAR_4 = null ; String VAR_5 = STRING_3 ; assertEquals ( TYPE_1 . METHOD_2 ( VAR_1 ) , STRING_4 ) ; assertEquals ( TYPE_1 . METHOD_2 ( VAR_2 ) , STRING_5 ) ; assertEquals ( TYPE_1 . METHOD_2 ( VAR_3 ) , "" ) ; METHOD_3 ( TYPE_1 . METHOD_2 ( VAR_4 ) ) ; assertEquals ( TYPE_1 . METHOD_2 ( VAR_5 ) , "" ) ; }
<|startcomment|> coding conventions : s @Override line please <|endcomment|> <START> @Override public <END> TYPE_1 METHOD_1 ( ) { TYPE_2 request = new TYPE_3 ( STRING_1 ) . build ( ) ; Map < String , Object > response = new TYPE_4 ( this . client , request ) . METHOD_2 ( ) ; return new TYPE_1 ( response ) ; }
<|startcomment|> needs @Override <|endcomment|> <START> public String toString ( ) { <END> return STRING_1 + length ( ) + STRING_2 ; }
<|startcomment|> issue rewritten asjavaif ( entity VAR_1 ( ) ) { / / stuff } avoid multiple points return method ( save a line code ) <|endcomment|> public void METHOD_1 ( TYPE_1 entity ) { <START> if ( ! entity . VAR_1 ( ) ) { <END> return ; } VAR_2 . remove ( entity . getId ( ) ) ; VAR_3 . add ( entity . getId ( ) ) ; }
<|startcomment|> isn t Optional returning null contradictory ? surely checking isPresent ( ) _CODE_ ( ) <|endcomment|> private TYPE_1 METHOD_1 ( String VAR_1 , Collection < TYPE_1 > VAR_2 ) { Optional < TYPE_1 > VAR_3 = VAR_2 . stream ( ) . filter ( p - > p . VAR_4 ( ) . equalsIgnoreCase ( VAR_1 ) ) . METHOD_2 ( ) ; <START> if ( VAR_3 . isPresent ( ) ) { <END> return VAR_3 . get ( ) ; } return null ; }
<|startcomment|> code consistency METHOD_3 ( STRING_3 ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 < String > f = c . VAR_1 ( STRING_1 , STRING_2 ) ; METHOD_2 ( f , null ) ; METHOD_3 ( STRING_2 ) ; f = c . VAR_1 ( STRING_1 , STRING_3 ) ; METHOD_2 ( f , STRING_2 ) ; <START> assertEquals ( STRING_3 , c . get ( STRING_1 ) ) ; <END> }
<|startcomment|> return true instead <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { <START> return false ; <END> }
<|startcomment|> public <|endcomment|> <START> static Map < String , TYPE_1 > METHOD_1 ( Object VAR_1 ) { <END> Map < String , Object > VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; return TYPE_3 . METHOD_3 ( VAR_2 , new TYPE_4 ( ) ) ; }
<|startcomment|> replace ( new TYPE_2 ( VAR_2 VAR_3 ) VAR_3 ) consolidates c tor logic place <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , short VAR_3 ) { this . data = new TYPE_2 ( VAR_2 , VAR_3 ) ; <START> this . VAR_3 = VAR_3 ; <END> }
<|startcomment|> please add braces conditionals ( { } ) <|endcomment|> public void METHOD_1 ( String VAR_1 , String VAR_2 ) throws TYPE_1 { <START> if ( VAR_1 == null || VAR_2 == null ) <END> throw new TYPE_1 ( INT_1 , STRING_1 ) ; this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; VAR_3 = true ; }
<|startcomment|> ( ! VAR_5 ) { <|endcomment|> public void METHOD_1 ( String VAR_1 ) { VAR_2 = VAR_1 ; if ( VAR_3 . METHOD_2 ( ) . equals ( VAR_4 ) ) { VAR_5 = false ; } <START> if ( VAR_5 == false ) { <END> VAR_3 . setText ( METHOD_3 ( ) ) ; } }
<|startcomment|> unreachable remove <|endcomment|> public void METHOD_1 ( ) { assertNotNull ( VAR_1 ) ; assertNotNull ( VAR_2 ) ; assertNotNull ( VAR_3 ) ; ( ( TYPE_1 ) VAR_2 ) . METHOD_2 ( VAR_3 ) ; <START> assertEquals ( Collections . VAR_4 ( VAR_3 ) , VAR_2 . METHOD_3 ( ) ) ; <END> }
<|startcomment|> I condition needs top start VAR_1 length ( ) > 1 instead VAR_1 length ( ) > 2 I generated code getters / setters rules fields * * _CODE_ * * * * _CODE_ * * I wrong <|endcomment|> private char METHOD_1 ( final String VAR_1 ) { <START> if ( VAR_1 . length ( ) > 2 && TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( 0 ) ) && TYPE_1 . METHOD_4 ( VAR_1 . METHOD_3 ( 1 ) ) ) { <END> return VAR_1 . METHOD_3 ( 0 ) ; } else { return TYPE_1 . METHOD_5 ( VAR_1 . METHOD_3 ( 0 ) ) ; } }
<|startcomment|> logging statements needed <|endcomment|> public void start ( ) { <START> logger . debug ( STRING_1 ) ; <END> for ( final Class < ? > VAR_1 : VAR_2 . keySet ( ) ) { VAR_2 . put ( VAR_1 , METHOD_1 ( VAR_1 ) ) ; } }
<|startcomment|> I don t code contract od sselection return null METHOD_3 ( ) sselection empty code changed simply return element <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; TYPE_1 VAR_3 = null ; if ( ! VAR_1 . isEmpty ( ) ) { VAR_3 = ( TYPE_1 ) <START> VAR_1 . METHOD_3 ( ) ; <END> } return VAR_3 ; }
<|startcomment|> reasonable caller pass a null VAR_1 constructor ? constructor throw a _CODE_ null <|endcomment|> public void METHOD_1 ( ) throws Throwable { <START> if ( null != VAR_1 ) { <END> VAR_1 . METHOD_1 ( ) ; } for ( TYPE_1 VAR_2 : VAR_3 ) { VAR_2 . METHOD_2 ( target ) ; } next . VAR_4 ( ) ; }
<|startcomment|> a bit weird create empty TYPE_2 storage pool t pass null backend case <|endcomment|> public Response add ( TYPE_1 VAR_1 ) { METHOD_1 ( VAR_1 , STRING_1 ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ? <START> METHOD_3 ( VAR_1 . METHOD_4 ( ) ) : new TYPE_2 ( ) ; <END> VAR_1 . METHOD_5 ( TYPE_3 . map ( VAR_2 , null ) ) ; return METHOD_6 ( TYPE_8 . TYPE_9 , new TYPE_4 ( map ( VAR_1 ) ) , new TYPE_5 < Guid > ( TYPE_7 . TYPE_10 , TYPE_6 . class ) ) ; }
<|startcomment|> private <|endcomment|> <START> protected void METHOD_1 ( ) <END> { try { VAR_1 . METHOD_2 ( new TYPE_1 ( new HashSet < > ( VAR_2 . values ( ) ) ) ) ; } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } }
<|startcomment|> needed <|endcomment|> <START> public void METHOD_1 ( ) throws IOException , TYPE_1 { <END> try { VAR_1 . METHOD_2 ( ) ; } catch ( Exception e ) { } METHOD_3 ( ) ; METHOD_4 ( ) ; }
<|startcomment|> shouldn t call METHOD_9 ( ) config passed lose local values passed obtain ( ) method agree <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 config ) { String VAR_1 = config . get ( TYPE_5 . VAR_3 ) ; if ( VAR_1 != null ) { try { return ( TYPE_1 ) METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_1 ) . METHOD_6 ( TYPE_2 . class ) . METHOD_7 ( config ) ; } catch ( Exception e ) { throw TYPE_3 . METHOD_8 ( e ) ; } } else { <START> return new TYPE_4 ( METHOD_9 ( ) ) ; <END> } }
<|startcomment|> missing _CODE_ <|endcomment|> <START> public TYPE_1 ( Object value , String VAR_2 , String VAR_3 ) { <END> super ( value , VAR_2 ) ; this . VAR_3 = VAR_3 ; }
<|startcomment|> lines squashed : return STRING_1 equalsIgnoreCase ( VAR_1 ) || STRING_2 equalsIgnoreCase ( VAR_1 ) ; <|endcomment|> private boolean METHOD_1 ( ) { TYPE_1 request = TYPE_3 . TYPE_4 . get ( ) ; if ( request == null ) { return false ; } final String VAR_1 = request . VAR_2 ( ) ; boolean VAR_3 = STRING_1 . equalsIgnoreCase ( VAR_1 ) || STRING_2 . equalsIgnoreCase ( VAR_1 ) ; if ( ! VAR_3 ) { return false ; } <START> return true ; <END> }
<|startcomment|> I instead : METHOD_1 ( VAR_2 VAR_3 ( VAR_4 ! = null && TYPE_1 METHOD_2 ( VAR_2 ) ) ? VAR_4 : null ) ; IOW point spending time checking cache s VAR_4 provided <|endcomment|> public TYPE_2 ( final String VAR_2 , final String VAR_3 , final TYPE_1 VAR_4 ) { <START> METHOD_1 ( VAR_2 , VAR_3 , TYPE_1 . METHOD_2 ( VAR_2 ) ? VAR_4 : null ) ; <END> }
<|startcomment|> fact postfix operators return modification shouldn t change order CFG loading happen operation i e order <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . is ( TYPE_3 . TYPE_2 . VAR_4 , TYPE_3 . TYPE_2 . VAR_5 ) ) { <END> build ( VAR_1 . METHOD_2 ( ) ) ; VAR_6 . VAR_7 . add ( VAR_1 ) ; } else { VAR_6 . VAR_7 . add ( VAR_1 ) ; build ( VAR_1 . METHOD_2 ( ) ) ; } }
<|startcomment|> Class < ? > <|endcomment|> <START> public Class METHOD_1 ( ) { <END> return VAR_1 . METHOD_1 ( ) ; }
<|startcomment|> good <|endcomment|> private TYPE_1 METHOD_1 ( ) { final File VAR_1 = METHOD_2 ( ) ; try { final TYPE_1 VAR_2 = TYPE_1 . getInstance ( VAR_3 ) ; <START> try ( TYPE_2 VAR_4 = TYPE_3 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ) { <END> VAR_2 . METHOD_5 ( VAR_4 , METHOD_6 ( ) ) ; } return VAR_2 ; } catch ( Exception e ) { Logger . warn ( this . getClass ( ) , STRING_1 + VAR_5 + STRING_2 + e ) ; throw new TYPE_4 ( e ) ; } }
<|startcomment|> ROLE_ANONYMOUS defaults TYPE_1 delete <|endcomment|> public TYPE_1 METHOD_1 ( ) { if ( this . VAR_1 == null ) { this . VAR_1 = new TYPE_1 ( ) ; } <START> return this . VAR_1 . METHOD_2 ( STRING_1 ) ; <END> }
<|startcomment|> suggestionreturn VAR_1 METHOD_1 ( ) ; <|endcomment|> public int METHOD_1 ( ) { <START> return this . VAR_1 . METHOD_2 ( ) ; <END> }
<|startcomment|> atomically <|endcomment|> private void METHOD_1 ( ) throws IOException { byte [ ] VAR_1 = state . VAR_2 ( ) . METHOD_2 ( ) ; System . out . println ( STRING_1 + VAR_1 . length + STRING_2 + VAR_3 ) ; TYPE_1 . write ( VAR_3 , VAR_1 , <START> TYPE_2 . VAR_5 ) ; <END> }
<|startcomment|> please add curlies <|endcomment|> private static void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { if ( VAR_1 == null ) return ; <START> for ( TYPE_2 VAR_2 : VAR_1 . VAR_3 ) <END> VAR_2 . METHOD_2 ( VAR_1 ) ; }
<|startcomment|> clarity s preferable : Map Entry <|endcomment|> public Map < TYPE_1 , TYPE_2 > METHOD_1 ( ) { Map < TYPE_1 , TYPE_2 > map = new TYPE_3 < > ( ) ; synchronized ( VAR_1 ) { for <START> ( Entry < TYPE_1 , <END> TYPE_2 > entry : METHOD_2 ( VAR_1 . entrySet ( ) ) ) { TYPE_2 VAR_2 = entry . getValue ( ) ; if ( VAR_2 . METHOD_3 ( ) ) { TYPE_2 VAR_3 = new TYPE_2 ( VAR_2 ) ; map . put ( entry . getKey ( ) , VAR_3 ) ; } } } return map ; }
<|startcomment|> I m concerned METHOD_2 doesn t necessary operation invoking private method guarded a thread needs acquire locks I alarm bell ringing head <|endcomment|> private TYPE_1 METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> try { TYPE_1 VAR_2 = ( TYPE_1 ) cache . get ( VAR_3 ) ; if ( VAR_2 == null ) { VAR_2 = new TYPE_1 ( ) ; TYPE_1 VAR_4 = ( TYPE_1 ) cache . VAR_5 ( VAR_3 , VAR_2 ) ; if ( VAR_4 != null ) { VAR_2 = VAR_4 ; } } if ( trace ) log . trace ( STRING_1 ) ; return VAR_2 ; } finally { VAR_1 . METHOD_3 ( ) ; } }
<|startcomment|> _CODE_ instances return - 1 don t length <|endcomment|> public long size ( ) { build ( ) ; <START> return VAR_1 . length ( ) + VAR_2 . length + VAR_3 . length ; <END> }
<|startcomment|> performance gezien het natuurlijk handiger eerst een boolean check te hebben en dan extra logica <|endcomment|> public boolean METHOD_1 ( ) { <START> return super . METHOD_1 ( ) && ! METHOD_2 ( ) ; <END> }
<|startcomment|> handle <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { String VAR_3 = VAR_1 . name ( ) ; TYPE_1 VAR_4 = ( TYPE_1 ) VAR_5 . get ( VAR_3 ) ; if ( VAR_4 == null ) { VAR_4 = METHOD_2 ( VAR_1 , VAR_2 ) ; <START> VAR_5 . put ( VAR_3 , VAR_4 ) ; <END> } return VAR_4 ; }
<|startcomment|> finally needed close throws test fail won t care VAR_1 null <|endcomment|> public void METHOD_1 ( ) { try { VAR_1 . close ( ) ; } <START> finally { <END> VAR_1 = null ; } }
<|startcomment|> throws exception ? mapped a _CODE_ caller report error <|endcomment|> private TYPE_4 ( TYPE_1 VAR_2 ) { VAR_3 = VAR_2 . getString ( TYPE_3 . VAR_5 , null , TYPE_3 . VAR_6 ) ; String VAR_7 = VAR_2 . getString ( TYPE_3 . VAR_8 , null , TYPE_3 . VAR_9 ) ; if ( VAR_7 != null ) { <START> VAR_10 = TYPE_2 . METHOD_1 ( VAR_7 ) ; <END> } }
<|startcomment|> s broken ( add some details commit message ) ? obvious <|endcomment|> public int METHOD_1 ( byte [ ] input , int VAR_1 , int VAR_2 , byte [ ] output , int VAR_3 , int VAR_4 ) throws TYPE_1 { <START> try { <END> TYPE_2 VAR_5 = new TYPE_2 ( true ) ; VAR_5 . METHOD_2 ( input , VAR_1 , VAR_2 ) ; int VAR_6 = VAR_5 . METHOD_3 ( output , VAR_3 , VAR_4 ) ; VAR_5 . METHOD_4 ( ) ; return VAR_6 ; } catch ( TYPE_3 e ) { throw TYPE_4 . METHOD_5 ( e ) ; } }
<|startcomment|> return ImmutableList don t intend users method edit list <|endcomment|> <START> public List < TYPE_1 > METHOD_1 ( ) { <END> return this . log ; }
<|startcomment|> ! VAR_3 || VAR_4 <|endcomment|> protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( ! this . VAR_1 ) { this . VAR_2 = TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) ; } <START> Assert . state ( this . VAR_3 ? this . VAR_4 : true , <END> STRING_1 ) ; }
<|startcomment|> I m reworking code context class avoid potential NPE VAR_3 field initialized - args constructor <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , List < TYPE_2 > VAR_3 ) { super ( VAR_2 ) ; this . VAR_3 = new ArrayList < TYPE_2 > ( ) ; if ( VAR_3 != null && VAR_3 . size ( ) > 0 ) <START> this . VAR_3 . addAll ( VAR_3 ) ; <END> }
<|startcomment|> move body won t execute batch <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> log . VAR_2 ( STRING_1 ) ; <END> try { if ( TYPE_2 . METHOD_2 ( METHOD_3 ( ) , TYPE_3 . class ) || TYPE_2 . METHOD_2 ( METHOD_3 ( ) , TYPE_4 . class ) ) { super . METHOD_1 ( VAR_1 ) ; } } catch ( TYPE_5 VAR_3 ) { throw log . VAR_4 ( VAR_3 . getMessage ( ) , VAR_3 ) ; } }
<|startcomment|> pick : VAR_1 METHOD_1 xored / added distributed <|endcomment|> public int METHOD_1 ( ) { <START> return ( ( ( VAR_1 . METHOD_1 ( ) * INT_1 ) + VAR_2 . length ) * INT_1 ) <END> + METHOD_2 ( ) ; }
<|startcomment|> function throw TYPE_1 <|endcomment|> <START> private void METHOD_1 ( ) throws TYPE_1 { <END> TYPE_3 . TYPE_4 . METHOD_2 ( true ) ; }
<|startcomment|> I woudl remove else VAR_2 a wrapper false VAR_1 _CODE_ want fall METHOD_2 check <|endcomment|> public boolean METHOD_1 ( Class < ? > VAR_1 ) { if ( VAR_2 instanceof TYPE_1 ) return ( ( TYPE_1 ) VAR_2 ) . METHOD_1 ( VAR_1 ) ; <START> else if ( VAR_1 . METHOD_2 ( VAR_2 ) ) return true ; <END> else return false ; }
<|startcomment|> change log level debug ? doesn t worth info level <|endcomment|> TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , final int VAR_2 , final long size , final File VAR_3 , final String VAR_4 ) throws TYPE_2 , IOException , TYPE_3 { VAR_5 . METHOD_2 ( VAR_3 , config . VAR_6 ( ) , VAR_4 ) ; final TYPE_1 VAR_7 = VAR_1 . METHOD_3 ( size ) . METHOD_4 ( this . METHOD_5 ( new TYPE_4 ( VAR_4 ) ) ) . METHOD_6 ( VAR_2 ) ; <START> log . info ( STRING_1 , VAR_3 ) ; <END> VAR_3 . METHOD_7 ( ) ; return VAR_7 ; }
<|startcomment|> done <|endcomment|> public TYPE_5 ( TYPE_1 description , TYPE_2 VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) { <START> super ( description , VAR_2 , <END> VAR_3 , VAR_4 ) ; this . description = description ; }
<|startcomment|> useless parenthesis <|endcomment|> private static boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . type ( ) . is ( VAR_3 ) && <START> ( ! VAR_2 . contains ( STRING_1 ) && VAR_2 . contains ( STRING_2 ) ) ; <END> }
<|startcomment|> TYPE_4 TYPE_5 <|endcomment|> void METHOD_1 ( TYPE_1 VAR_1 , int length ) { this . VAR_1 = VAR_1 ; VAR_2 = length ; if ( METHOD_2 ( ) ) { VAR_3 . METHOD_3 ( TYPE_4 . TYPE_5 . METHOD_4 ( VAR_4 ) ) ; VAR_5 . METHOD_3 ( TYPE_4 . TYPE_5 . METHOD_5 ( VAR_4 ) ) ; } <START> VAR_6 . setText ( TYPE_4 . TYPE_6 . METHOD_6 ( Integer <END> . toString ( length ) ) ) ; }
<|startcomment|> wouldn t call new constructor ? easier maintenance future <|endcomment|> public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 < ? , ? > build , TYPE_3 VAR_3 , TYPE_4 listener ) { this . VAR_2 = VAR_2 ; this . run = build ; this . VAR_4 = build . VAR_5 ( ) ; this . VAR_3 = VAR_3 ; <START> this . listener = listener ; <END> }
<|startcomment|> obsolete _CODE_ implemented <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 ; VAR_1 = new TYPE_1 ( VAR_2 , Integer . VAR_3 ) ; VAR_1 . METHOD_2 ( STRING_1 ) ; VAR_1 . getValue ( ) ; METHOD_3 ( VAR_1 . getValue ( ) ) ; VAR_1 . METHOD_2 ( STRING_2 ) ; <START> VAR_1 . getValue ( ) ; <END> METHOD_3 ( VAR_1 . getValue ( ) ) ; }
<|startcomment|> else line <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( METHOD_2 ( VAR_2 ) ) { VAR_3 = true ; <START> } else { if ( VAR_3 <END> && METHOD_2 ( VAR_1 ) ) { VAR_3 = false ; } } }
<|startcomment|> Class < ? > <|endcomment|> <START> public Class METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> I suppose close ( ) done TYPE_2 read ( ) <|endcomment|> private String read ( String VAR_1 ) throws IOException { TYPE_1 is = getClass ( ) . METHOD_1 ( VAR_1 ) ; try { return TYPE_2 . read ( is ) ; } finally { if ( is != null ) { <START> is . close ( ) ; <END> } } }
<|startcomment|> I don t I need cast group artifact _CODE_ accessible interface level version accessible I don t add : multimodule project compilaton afaik modules GA version project <|endcomment|> public static String METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; <END> return TYPE_3 . get ( VAR_3 , VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) , VAR_2 . METHOD_4 ( ) , VAR_4 ) . toString ( ) ; }
<|startcomment|> operation O ( n ) size list small making sense a set instead <|endcomment|> void METHOD_1 ( String VAR_1 ) { <START> if ( VAR_2 . remove ( VAR_1 ) ) { <END> VAR_3 -- ; } VAR_4 -- ; }
<|startcomment|> return instantiating map <|endcomment|> private Map < Long , TYPE_1 > METHOD_1 ( List < Long > VAR_1 ) { Map < Long , TYPE_1 > VAR_2 = new TYPE_2 < > ( ) ; if <START> ( ! VAR_1 . isEmpty ( ) ) <END> { for ( Long VAR_3 : VAR_1 ) { TYPE_1 VAR_4 = VAR_5 . get ( VAR_3 ) ; if ( VAR_4 != null ) { VAR_2 . put ( VAR_3 , VAR_4 ) ; } } return VAR_2 ; } return VAR_5 ; }
<|startcomment|> TYPE_2 METHOD_2 instead ! = null <|endcomment|> static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return TYPE_2 . METHOD_2 ( VAR_1 ) && VAR_1 . METHOD_3 ( ) != null && ! VAR_1 . METHOD_3 ( ) . isEmpty ( ) ; <END> }
<|startcomment|> 1 more correct AFAIC skip <|endcomment|> public void METHOD_1 ( TYPE_1 page ) { METHOD_2 ( VAR_1 == null ) ; VAR_1 = page ; VAR_2 = 0 ; VAR_3 = null ; <START> VAR_4 = 0 ; <END> }
<|startcomment|> simpler rename field _CODE_ discard data automatically <|endcomment|> public TYPE_3 ( ) { super ( TYPE_1 . class ) ; synchronized ( VAR_2 ) { METHOD_1 ( ) ; if ( ! VAR_3 . isEmpty ( ) ) { VAR_3 = new HashMap < String , Map < TYPE_1 , TYPE_2 > > ( ) ; METHOD_2 ( ) ; } <START> } <END> }
<|startcomment|> don t need + operator <|endcomment|> public String toString ( ) { String VAR_1 = VAR_2 . getName ( ) == null ? STRING_1 : VAR_2 . getName ( ) ; <START> String VAR_3 = VAR_2 . getId ( ) == null ? STRING_1 : VAR_2 . getId ( ) . toString ( ) ; <END> return STRING_2 + VAR_1 + STRING_3 + VAR_3 + STRING_4 ; }
<|startcomment|> simplified : javareturn input - > VAR_1 = = null || VAR_1 ( input getKey ( ) ) ; <|endcomment|> TYPE_1 < Entry < TYPE_2 , TYPE_3 > > METHOD_1 ( ) { final TYPE_4 VAR_1 = METHOD_2 ( ) ; <START> return input - > { if ( VAR_1 != null && ! VAR_1 . contains ( input . getKey ( ) ) ) return false ; return true ; } ; <END> }
<|startcomment|> nitjavathis client = METHOD_1 ( client STRING_1 ) ; <|endcomment|> public TYPE_2 ( TYPE_1 client ) { <START> METHOD_1 ( client , STRING_1 ) ; <END> this . client = client ; }
<|startcomment|> METHOD_5 ? example line #755 <|endcomment|> private void METHOD_1 ( ) { if ( METHOD_2 ( ) ) { TYPE_1 VAR_1 = VAR_2 . METHOD_3 ( ) . METHOD_4 ( VAR_3 ) ; if ( METHOD_5 ( VAR_1 ) ) { <START> if ( VAR_1 . METHOD_6 ( ) ) <END> { METHOD_7 ( TYPE_3 . TYPE_2 , VAR_1 . METHOD_8 ( ) ) ; } } } }
<|startcomment|> member variable VAR_4 shouldnt parameter VAR_1 <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws IOException { byte [ ] VAR_3 = ( STRING_1 + VAR_2 . trim ( ) . METHOD_2 ( STRING_2 , STRING_3 ) + STRING_4 ) . METHOD_3 ( ) ; <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( VAR_4 . METHOD_4 ( ) . METHOD_6 ( ) ) ; <END> VAR_1 . METHOD_7 ( ) . write ( VAR_3 ) ; VAR_1 . METHOD_7 ( ) . METHOD_8 ( ) ; TYPE_2 . instance . METHOD_9 ( this , STRING_5 + VAR_2 ) ; }
<|startcomment|> explain necessary <|endcomment|> public int METHOD_1 ( ) { <START> return getClass ( ) . METHOD_1 ( ) ; <END> }
<|startcomment|> i need save line more readable <|endcomment|> private void METHOD_1 ( ) { <START> METHOD_2 ( next = VAR_1 ) ; <END> }
<|startcomment|> drop toString ( ) <|endcomment|> public String METHOD_1 ( ) { <START> return ( VAR_1 == null ) ? STRING_1 : VAR_1 . toString ( ) + STRING_2 ; <END> }
<|startcomment|> missing return statement breaking compiling code <|endcomment|> String METHOD_1 ( final Context context , final TYPE_1 writer , final TYPE_2 params , final String VAR_1 ) { if ( VAR_1 . contains ( STRING_1 ) ) { <START> <END> } else { return ( params . VAR_2 ) ? STRING_2 + VAR_1 + STRING_3 + VAR_3 : STRING_4 + VAR_1 + STRING_3 + VAR_3 ; } }
<|startcomment|> METHOD_5 - needed undesired incase changes <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_3 config = <END> METHOD_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) . METHOD_5 ( STRING_1 ) . METHOD_6 ( ) . METHOD_7 ( ) ; if ( config == null ) { TYPE_4 . METHOD_8 ( ) ; } return TYPE_4 . METHOD_9 ( new TYPE_5 ( config ) ) ; }
<|startcomment|> wrong entry getValue ( ) <|endcomment|> public boolean METHOD_1 ( String name , TYPE_1 VAR_1 ) { for ( Entry < TYPE_2 , Set < String > > entry : VAR_2 . entrySet ( ) ) { if ( VAR_1 . METHOD_2 ( entry . getKey ( ) ) ) { <START> if ( VAR_2 . get ( entry . getKey ( ) ) . contains ( name ) ) { <END> return true ; } } } return false ; }
<|startcomment|> methods public part public API class want restrict access class class package private <|endcomment|> <START> TYPE_2 ( TYPE_1 VAR_2 ) <END> { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; }
<|startcomment|> abstract I choose operation controller case future wish choose loaded compared others <|endcomment|> protected TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . get ( TYPE_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 . size ( ) ) ) ; <END> }
<|startcomment|> I null a configuration saved < VAR_1 > entry reloaded I don t happen - some version jenkins done sense modify a _CODE_ ( ) set empty list remove check theoretical possibility <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> if ( VAR_1 == null ) <END> VAR_1 = new ArrayList < TYPE_1 > ( ) ; return VAR_1 ; }
<|startcomment|> please pass original exception retain stacktrace message <|endcomment|> public boolean addAll ( int index , Collection < ? extends T > c ) { Collection < T > VAR_1 = METHOD_1 ( c ) ; if ( VAR_1 . isEmpty ( ) ) { return false ; } try { return super . addAll ( index , VAR_1 ) ; } catch ( TYPE_1 VAR_2 ) { VAR_3 . METHOD_2 ( VAR_1 ) ; <START> throw new TYPE_1 ( ) ; <END> } }
<|startcomment|> sdk version hardcoded <|endcomment|> public Context METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = this . getClass ( ) . METHOD_2 ( ) . getName ( ) ; } return new Context ( STRING_1 , VAR_1 ) <START> . METHOD_3 ( STRING_2 , VAR_2 ) ; <END> }
<|startcomment|> protected I assume _CODE_ <|endcomment|> <START> public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <END> METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; }
<|startcomment|> VAR_9 <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TimeUnit VAR_2 , TimeUnit VAR_3 ) { TYPE_3 VAR_4 = VAR_1 . METHOD_2 ( ) ; TYPE_1 VAR_5 = new TYPE_1 ( ) ; METHOD_3 ( VAR_5 , VAR_1 , VAR_2 ) ; double VAR_6 = FLOAT_1 / VAR_3 . METHOD_4 ( 1 ) ; METHOD_5 ( VAR_5 , VAR_4 , VAR_6 ) ; <START> String VAR_7 = VAR_3 . toString ( ) . METHOD_6 ( TYPE_4 . VAR_9 ) ; <END> VAR_5 . METHOD_7 ( STRING_1 , VAR_7 ) ; return VAR_5 ; }
<|startcomment|> TYPE_3 <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , TYPE_2 context ) throws TYPE_3 { <START> throw new TYPE_4 ( STRING_1 ) ; <END> }
<|startcomment|> protected ? detect option internally ( handler ) method signature <|endcomment|> <START> protected void METHOD_1 ( boolean VAR_1 ) { <END> this . VAR_1 = VAR_1 ; }
<|startcomment|> code level STRING_1 ? causing failure METHOD_1 ( ) calls compared _CODE_ _CODE_ <|endcomment|> public int METHOD_1 ( ) { <START> return data . VAR_1 ( STRING_1 ) ; <END> }
<|startcomment|> METHOD_4 ( ) instead METHOD_4 ( ) <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) != null ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 . METHOD_2 ( ) , VAR_1 . METHOD_3 ( ) , true , ( TYPE_3 ) <START> this . METHOD_4 ( ) ) ; <END> VAR_2 . METHOD_5 ( new TYPE_4 ( ) ) ; VAR_3 . METHOD_6 ( VAR_2 ) ; } else { VAR_3 . METHOD_7 ( VAR_4 ) ; } }
<|startcomment|> add a _CODE_ ( TYPE_1 ) method avoid duplication <|endcomment|> public String METHOD_1 ( String VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_3 ) { String VAR_4 = ( ( TYPE_2 ) VAR_2 . METHOD_2 ( ) ) . METHOD_3 ( ) ; if ( VAR_4 != null && VAR_4 . equals ( VAR_1 ) ) { return <START> VAR_2 . METHOD_4 ( VAR_5 ) + STRING_1 + VAR_2 . METHOD_5 ( ) ; <END> } } return STRING_2 ; }
<|startcomment|> I METHOD_2 function parmeters add a parameter <|endcomment|> public void METHOD_1 ( ) { if ( server instanceof TYPE_1 ) { <START> ( ( TYPE_1 ) server ) . METHOD_2 ( ) ; <END> } server . VAR_1 ( ) ; }
<|startcomment|> _CODE_ implement TYPE_1 method create a lamda return instead <|endcomment|> protected TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return ( ) - > new TYPE_3 ( parameters . VAR_1 , parameters . name ) ; <END> }
<|startcomment|> model change listener called single modification ? I explain good <|endcomment|> public < TYPE_1 extends TYPE_2 > TYPE_1 METHOD_1 ( TYPE_3 < T > type ) { if ( type != null ) { type . VAR_1 ( this ) ; } <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( this , VAR_2 , type , METHOD_6 ( ) . getType ( ) ) ; <END> if ( METHOD_6 ( ) != null ) { METHOD_6 ( ) . METHOD_1 ( type ) ; } return ( TYPE_1 ) this ; }
<|startcomment|> I understand ut hell <|endcomment|> public static TYPE_1 getInstance ( ) { return instance ; <START> } <END>
<|startcomment|> suggestion <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_1 request ) throws TYPE_2 { request = METHOD_2 ( request ) ; String VAR_1 = METHOD_3 ( METHOD_4 ( request ) ) ; <START> request = METHOD_5 ( request , VAR_1 ) ; <END> return request ; }
<|startcomment|> return null <|endcomment|> public TYPE_1 get ( ) { <START> if ( config . VAR_1 ( ) == TYPE_1 . VAR_2 ) { <END> return TYPE_1 . VAR_2 ; } else if ( config . VAR_1 ( ) == TYPE_1 . VAR_3 ) { return TYPE_1 . VAR_3 ; } else if ( config . VAR_1 ( ) == TYPE_1 . VAR_4 ) { return TYPE_1 . VAR_4 ; } else if ( config . VAR_1 ( ) == TYPE_1 . VAR_5 ) { return TYPE_1 . VAR_5 ; } else { return TYPE_1 . VAR_3 ; } }
<|startcomment|> final ? important method serialization / internal representation s pretty important overridden <|endcomment|> <START> public String METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> close implicit METHOD_1 <|endcomment|> protected void close ( ) { try { <START> VAR_1 . METHOD_1 ( ) ; <END> VAR_1 . close ( ) ; } catch ( IOException ex ) { } }
<|startcomment|> need parentheses <|endcomment|> protected boolean METHOD_1 ( TYPE_1 VAR_1 , long offset ) { long VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> return ( VAR_2 > 0 ) && ( VAR_2 >= offset ) ; <END> }
<|startcomment|> please don t create a new list call METHOD_1 ( ) create list e g call return instance want _CODE_ instead fail early modify <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> return new TYPE_3 < TYPE_2 > ( this . VAR_1 ) ; <END> }
<|startcomment|> need expose TYPE_2 TYPE_3 ? completely unnecessary <|endcomment|> <START> public TYPE_2 . TYPE_3 METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> super METHOD_1 ( ) forEach ( res : : add ) ; <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { List < TYPE_2 > result = new ArrayList < > ( ) ; if ( VAR_1 != null ) { result . add ( VAR_1 ) ; } <START> for ( TYPE_2 VAR_2 : super . METHOD_1 ( ) ) { <END> result . add ( VAR_2 ) ; } if ( VAR_3 != null ) { result . add ( VAR_3 ) ; } return result ; }
<|startcomment|> METHOD_2 line affectation <|endcomment|> public void METHOD_1 ( String name ) { TYPE_1 . METHOD_2 ( name ) ; <START> this . name = name ; <END> }
<|startcomment|> I METHOD_3 ( ) || _CODE_ ( ) ! = _CODE_ <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 context ) { if ( METHOD_2 ( ) ) { return new TYPE_3 ( name ( ) ) ; <START> } else if ( METHOD_3 ( ) ) { <END> return new TYPE_4 ( new TYPE_5 ( TYPE_7 . VAR_2 , name ( ) ) ) ; } else { return new TYPE_6 ( name ( ) ) ; } }
<|startcomment|> method static <|endcomment|> <START> private void METHOD_1 ( TYPE_1 ctx , TYPE_2 VAR_1 ) { <END> if ( VAR_1 . METHOD_2 ( ) == null && VAR_1 . METHOD_3 ( ) . size ( ) == 1 ) { VAR_1 . METHOD_3 ( ) . forEach ( e - > METHOD_4 ( e , ctx , STRING_1 ) ) ; } }
<|startcomment|> need declare throws TYPE_2 <|endcomment|> <START> private void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> if ( StringUtils . VAR_2 ( this . VAR_3 ) ) { try { TYPE_3 resource = METHOD_2 ( ) ; try ( TYPE_4 VAR_4 = resource . VAR_5 ( ) ) { VAR_1 . METHOD_3 ( false , new TYPE_5 ( VAR_4 ) ) ; } } catch ( Exception ex ) { throw new IllegalStateException ( STRING_1 + this . VAR_3 , ex ) ; } } }
<|startcomment|> I insist methods a CT * parameter annotated private <|endcomment|> <START> public TYPE_3 ( TYPE_1 table , TYPE_2 VAR_2 ) { <END> this . table = table ; this . VAR_2 = VAR_2 ; }
<|startcomment|> d { } fold conditional a single return statement <|endcomment|> private boolean METHOD_1 ( Date VAR_1 ) { <START> if ( VAR_2 && ! METHOD_2 ( VAR_3 , VAR_1 ) ) return false ; <END> return VAR_4 == null || VAR_4 . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> static <|endcomment|> <START> public void METHOD_1 ( List < TYPE_1 > <END> VAR_1 , TYPE_2 node , TYPE_2 VAR_2 ) { final int VAR_3 = VAR_2 . METHOD_2 ( ) ; for ( final TYPE_1 VAR_4 : VAR_1 ) if ( VAR_4 . getPath ( ) . METHOD_3 ( VAR_3 ) . equals ( VAR_2 . METHOD_4 ( ) ) ) { final TYPE_2 VAR_5 = VAR_4 . getPath ( ) ; final int count = VAR_2 . METHOD_2 ( ) ; VAR_4 . METHOD_5 ( METHOD_6 ( VAR_5 , node , count ) ) ; } }
<|startcomment|> necessary <|endcomment|> private TYPE_2 ( String VAR_2 , int VAR_3 , TYPE_1 < T > VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; <START> logger . info ( STRING_1 + this . VAR_2 ) ; <END> }
<|startcomment|> done <|endcomment|> <START> public TYPE_7 ( TYPE_1 context ) { <END> this . VAR_2 = context ; VAR_3 = new ArrayList < TYPE_5 . TYPE_6 . Collection < Map < TYPE_3 , TYPE_4 > > > ( ) ; }
<|startcomment|> result = VAR_1 * result + METHOD_3 ( ) METHOD_1 ( ) ; _CODE_ s METHOD_1 method _CODE_ allowed null work id valid <|endcomment|> public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = 1 ; result = VAR_1 * result + ( ( METHOD_2 ( ) == null ) ? 0 : METHOD_2 ( ) . METHOD_1 ( ) ) ; <START> result = VAR_1 * result + ( ( METHOD_3 ( ) . METHOD_4 ( ) ) ? 0 : METHOD_3 ( ) . METHOD_1 ( ) ) ; <END> return result ; }
<|startcomment|> private <|endcomment|> <START> protected void <END> METHOD_1 ( boolean VAR_1 ) { METHOD_2 ( TYPE_3 . TYPE_2 , TYPE_1 . class , new String [ ] { STRING_1 , STRING_2 } , new Object [ ] { VAR_4 , VAR_5 } , VAR_1 ? null : METHOD_3 ( 1 ) ) ; }
<|startcomment|> purpose _CODE_ abstract implementation details querying device list caller - moving changes done _CODE_ _CODE_ <|endcomment|> <START> public boolean METHOD_1 ( Guid VAR_1 ) { <END> return TYPE_1 . METHOD_2 ( METHOD_3 ( VAR_1 ) . METHOD_4 ( ) ) ; }
<|startcomment|> please add { } blocks statement <|endcomment|> public void METHOD_1 ( TYPE_1 e ) { <START> if ( e . VAR_1 ( ) ) <END> METHOD_2 ( e ) ; }
<|startcomment|> _CODE_ element page <|endcomment|> public boolean METHOD_1 ( ) { try { <START> METHOD_2 ( VAR_1 . get ( 0 ) ) ; <END> return VAR_1 . get ( 0 ) . METHOD_3 ( ) ; } catch ( TYPE_1 | TYPE_2 e ) { } return false ; }
<|startcomment|> need String format parameter provide throw new IllegalArgumentException ( STRING_1 ) ; improve message somethign : throw new IllegalArgumentException ( String format ( port greater 0 ( provided { 0 } ) VAR_2 ) ) ; <|endcomment|> public TYPE_2 ( final String host , final int VAR_2 , final String VAR_3 ) { TYPE_1 . METHOD_1 ( host ) ; if ( VAR_2 <= 0 ) { <START> throw new IllegalArgumentException ( String . format ( STRING_1 ) ) ; <END> } this . host = host ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; }
<|startcomment|> static import <|endcomment|> public TYPE_2 ( String message ) { <START> super ( TYPE_1 . METHOD_1 ( message ) ) ; <END> }
<|startcomment|> public <|endcomment|> <START> public Map < String , TYPE_1 > METHOD_1 ( ) { <END> VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; List < TYPE_2 > VAR_2 = METHOD_4 ( ) . METHOD_5 ( STRING_1 , VAR_1 ) ; if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { return METHOD_6 ( ) ; } else { return METHOD_7 ( VAR_2 ) ; } }
<|startcomment|> inline variable <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( INT_1 * INT_2 ) ; boolean <START> VAR_1 = <END> Thread . VAR_1 ( ) ; if ( VAR_1 ) { METHOD_3 ( STRING_1 ) ; } }
<|startcomment|> instead creating a new object time more sense store constants predefined granularity string <|endcomment|> public static TYPE_1 METHOD_1 ( String VAR_1 ) { String name = VAR_1 . METHOD_2 ( ) ; if ( name . equals ( STRING_1 ) ) { return TYPE_1 . VAR_2 ; } else if ( name . equals ( STRING_2 ) ) { return TYPE_1 . NONE ; } else if ( TYPE_2 . containsKey ( name ) ) { <START> return new TYPE_3 ( TYPE_2 . get ( name ) , null , null ) ; <END> } return new TYPE_4 ( METHOD_3 ( VAR_1 ) , 0 ) ; }
<|startcomment|> style : don t braces single line blocks <|endcomment|> public Object [ ] METHOD_1 ( Object element ) { <START> if ( element instanceof Object [ ] ) { <END> return ( Object [ ] ) element ; } if ( element instanceof Collection ) { return ( ( Collection ) element ) . METHOD_2 ( ) ; } return new Object [ 0 ] ; }
<|startcomment|> create a common utility function build _CODE_ duplicate kind code <|endcomment|> public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> if ( TYPE_4 . VAR_2 ) { <END> try { VAR_3 = new TYPE_1 ( ) ; } catch ( Throwable t ) { LOG . warn ( STRING_1 , t . getMessage ( ) ) ; VAR_3 = new TYPE_2 ( ) ; } } else { VAR_3 = new TYPE_2 ( ) ; } VAR_4 = TYPE_3 . METHOD_2 ( ) . name ( STRING_2 ) . METHOD_3 ( 2 ) . build ( ) ; }
<|startcomment|> don t need toString call <|endcomment|> private void METHOD_1 ( long position , byte [ ] buffer , int VAR_1 , int VAR_2 ) { try { long VAR_3 = System . VAR_4 ( ) ; VAR_5 . METHOD_2 ( position , buffer , VAR_1 , VAR_2 ) ; VAR_6 . METHOD_3 ( VAR_2 , System . VAR_4 ( ) - VAR_3 ) ; } catch ( TYPE_1 e ) { throw e ; } catch ( Exception e ) { <START> throw new TYPE_1 ( VAR_7 , format ( STRING_1 , id . toString ( ) , position ) , e ) ; <END> } }
<|startcomment|> don t prefer assertEquals <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_6 . VAR_3 ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; TYPE_2 VAR_4 = METHOD_4 ( ) ; List < TYPE_3 > VAR_5 = VAR_4 . METHOD_5 ( TYPE_5 . VAR_7 , VAR_1 ) ; METHOD_6 ( VAR_5 . isEmpty ( ) ) ; <START> assertTrue ( VAR_5 . get ( 0 ) . METHOD_7 ( ) == TYPE_4 . VAR_9 ) ; <END> }
<|startcomment|> VAR_2 constant want define a instead String : privates static final VAR_2 = _CODE_ _CODE_ ( mandatory ) ; compare easily : return VAR_1 METHOD_2 ( ) equals ( VAR_2 ) ; <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . get ( 0 ) . equals ( VAR_2 ) ? true : false ; <END> }
<|startcomment|> good change making instance member thanks <|endcomment|> <START> private TYPE_1 next ( ) { <END> if ( parent != null && parent . VAR_1 == null ) { parent . data = null ; parent = parent . parent ; } if ( VAR_1 != null ) return new TYPE_1 ( this ) ; if ( parent != null ) return new TYPE_1 ( parent ) ; return null ; }
<|startcomment|> VAR_2 = + + VAR_2 % VAR_3 ; return VAR_2 = = 0 ; remove _CODE_ ? properly verified merge change master - <|endcomment|> boolean METHOD_1 ( Date VAR_1 ) { this . VAR_1 = VAR_1 ; <START> return ++ VAR_2 < VAR_3 ; <END> }
<|startcomment|> STRING_2 class errors I 53300 transient <|endcomment|> protected boolean METHOD_1 ( Throwable e ) { if ( e instanceof TYPE_1 ) { final String VAR_1 = ( ( TYPE_1 ) e ) . METHOD_2 ( ) ; <START> return VAR_1 . startsWith ( STRING_1 ) || VAR_1 . startsWith ( STRING_2 ) ; <END> } return false ; }
<|startcomment|> pointed line problem ? problem _CODE_ called done method <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 source , TYPE_4 VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( this . VAR_4 , VAR_1 , source , VAR_2 ) ; <START> if ( ! ( VAR_1 instanceof TYPE_5 ) ) { <END> this . VAR_5 . add ( new TYPE_6 ( VAR_1 , this . VAR_4 . METHOD_2 ( ) ) ) ; } this . VAR_4 = this . VAR_4 . METHOD_3 ( ) ; return VAR_3 ; }
<|startcomment|> VAR_3 ( 1 VAR_1 METHOD_6 ( ) ) ? 1 a - existent executor <|endcomment|> public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 , STRING_2 ) ; this . VAR_2 . METHOD_3 ( VAR_1 ) ; METHOD_4 ( <START> ( ) - > this . VAR_3 . METHOD_5 ( VAR_1 . METHOD_6 ( ) , 1 ) ) <END> . METHOD_7 ( TYPE_3 . class ) . METHOD_8 ( STRING_3 ) ; }
<|startcomment|> Exception thrown <|endcomment|> private static TYPE_1 METHOD_1 ( ) <START> throws Exception <END> { TYPE_2 VAR_1 = new TYPE_3 ( new TYPE_4 ( new TYPE_5 ( ) . METHOD_2 ( new TYPE_6 ( FLOAT_1 , VAR_2 ) ) ) . METHOD_3 ( ) ) ; return new TYPE_1 ( VAR_3 , METHOD_4 ( ) , TYPE_7 . METHOD_5 ( ) , METHOD_6 ( Optional . empty ( ) , ImmutableList . of ( ) ) , VAR_1 , new TYPE_8 ( ) , new TYPE_9 ( ) , new TYPE_10 ( VAR_4 ) , METHOD_7 ( ) , 2 , false ) ; }
<|startcomment|> VAR_1 toString ( ) redundant <|endcomment|> public String toString ( ) { <START> return VAR_1 . toString ( ) ; <END> }
<|startcomment|> TCM optional android system service check null <|endcomment|> private void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { TYPE_2 . view . VAR_2 . TYPE_4 <START> VAR_4 = <END> ( TYPE_2 . view . VAR_2 . TYPE_4 ) VAR_5 . METHOD_2 ( Context . VAR_6 ) ; TYPE_2 . view . VAR_2 . TYPE_1 VAR_8 = VAR_1 == null ? null : new TYPE_3 ( VAR_5 , VAR_1 ) ; VAR_4 . METHOD_3 ( VAR_8 ) ; }
<|startcomment|> mime type mandatory <|endcomment|> Object METHOD_1 ( String VAR_1 ) throws IOException { TYPE_1 request = new TYPE_1 ( VAR_1 ) ; request . VAR_2 ( new TYPE_2 ( TYPE_6 . VAR_4 , VAR_5 ) ) ; TYPE_3 VAR_6 = execute ( request , VAR_1 , STRING_1 ) ; METHOD_2 ( VAR_6 , VAR_1 ) ; TYPE_4 VAR_7 = VAR_6 . METHOD_3 ( ) ; TYPE_5 VAR_8 = TYPE_5 . METHOD_4 ( VAR_7 ) ; <START> if ( STRING_2 . equals ( VAR_8 . METHOD_5 ( ) ) ) { <END> return METHOD_6 ( VAR_7 ) ; } return METHOD_7 ( VAR_7 ) ; }
<|startcomment|> I VAR_1 shut ( ! VAR_2 ) <|endcomment|> protected void METHOD_1 ( ) { log . info ( STRING_1 ) ; VAR_1 . METHOD_2 ( ) ; if ( ! VAR_2 ) { <START> VAR_3 . METHOD_2 ( ) ; <END> } try { VAR_4 . channel ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; } catch ( InterruptedException e ) { log . warn ( STRING_2 ) ; Thread . VAR_5 ( ) . METHOD_5 ( ) ; } log . info ( STRING_3 ) ; METHOD_6 ( ) ; }
<|startcomment|> pass VAR_4 VAR_2 a param adapter <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 parent , int VAR_1 ) { <START> TYPE_3 VAR_2 = TYPE_3 . from ( parent . VAR_3 ( ) ) ; <END> return new TYPE_1 ( ( TYPE_4 ) VAR_2 . METHOD_2 ( R . VAR_4 . VAR_5 , parent , false ) ) ; }
<|startcomment|> a reason displayed everytime ? shown project selected <|endcomment|> public void METHOD_1 ( int VAR_1 ) { int VAR_2 = VAR_3 . VAR_2 ; if ( VAR_3 . VAR_4 && VAR_1 >= VAR_2 ) { <START> TYPE_1 . METHOD_2 ( METHOD_3 ( ) , STRING_1 + VAR_2 + STRING_2 ) ; <END> } METHOD_4 ( VAR_5 . METHOD_5 ( ) . METHOD_6 ( R . id . VAR_6 ) ) ; VAR_5 . METHOD_7 ( METHOD_8 ( ) . METHOD_9 ( METHOD_10 ( VAR_7 ) , VAR_1 , VAR_1 ) ) ; }
<|startcomment|> method grow ( i wanted add ) putting a more lengthy more readable ? ( note I changed TYPE_4 s condition ) ( VAR_1 instanceof TYPE_3 ) { return true ; } ( VAR_1 instanceof TYPE_2 ) { return true ; / / differentiate partial / } ( VAR_1 instanceof TYPE_4 ) { return ( ( TYPE_4 ) VAR_1 ) METHOD_2 ( ) ! = TYPE_4 TYPE_5 FINAL ; } return false ; <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { return VAR_1 instanceof TYPE_2 || VAR_1 instanceof TYPE_3 || <START> ( VAR_1 instanceof TYPE_4 && ( ( TYPE_4 ) VAR_1 ) . METHOD_2 ( ) . equals ( TYPE_4 . TYPE_5 . VAR_3 ) ) ; <END> }
<|startcomment|> _CODE_ ( response ) ; <|endcomment|> public void METHOD_1 ( ) { final TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; METHOD_3 ( STRING_1 , VAR_1 ) ; Thread VAR_4 = new Thread ( ( ) - > METHOD_4 ( ) ) ; VAR_4 . start ( ) ; String response = METHOD_3 ( STRING_1 , VAR_1 ) ; <START> LOGGER . info ( response ) ; <END> }
<|startcomment|> suggestionbuilder append ( Integer toString ( node getValue ( ) ) ) ; cheaper String format <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 node , Integer VAR_1 ) { <START> builder . append ( String . format ( TYPE_3 . VAR_3 , STRING_1 , node . getValue ( ) ) ) ; <END> return null ; }
<|startcomment|> essentially line code I d prefer inline <|endcomment|> <START> private List < TYPE_1 > METHOD_1 ( String query ) throws TYPE_2 { <END> List < TYPE_1 > results = null ; results = client . VAR_1 ( new TYPE_3 ( ) , query ) ; return results ; }
<|startcomment|> avoid redundant pattern check : suggestionthis ( query VAR_2 null ) ; <|endcomment|> public TYPE_1 ( ANNOTATION_1 ( STRING_1 ) String query , ANNOTATION_1 ( STRING_2 ) String VAR_2 ) { <START> this ( query , VAR_2 , "" ) ; <END> }
<|startcomment|> return ImmutableList ( VAR_2 ) ; instead <|endcomment|> private List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; VAR_1 . add ( VAR_2 ) ; return ImmutableList . VAR_3 ( VAR_1 ) ; <END> }
<|startcomment|> standard jclouds pattern METHOD_3 ( VAR_1 VAR_1 ) case s expected a varargs argument null empty array instead want enforce check : _CODE_ ( VAR_1 length > 0 VAR_1 empty ) ; return VAR_1 ( TYPE_2 METHOD_2 ( VAR_1 ) ) ; VAR_1 ( iterable < String > VAR_1 ) checks I don t need check <|endcomment|> public TYPE_1 METHOD_1 ( String ... VAR_1 ) { <START> return METHOD_1 ( TYPE_2 . METHOD_2 ( METHOD_3 ( VAR_1 , STRING_1 ) ) ) ; <END> }
<|startcomment|> style - : don t put ( ) ? : a return <|endcomment|> private static TYPE_1 id ( TYPE_2 VAR_1 ) { <START> return ( VAR_1 . VAR_2 == TYPE_3 . VAR_4 ? VAR_1 . VAR_5 : VAR_1 . VAR_6 ) ; <END> }
<|startcomment|> private <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 instanceof TYPE_1 ) { return ( ( TYPE_1 ) VAR_1 ) ; } else { <START> throw new TYPE_3 ( VAR_2 , Optional . empty ( ) , STRING_1 + VAR_1 ) ; <END> } }
<|startcomment|> simpler return = = VAR_1 <|endcomment|> public boolean METHOD_1 ( ) { <START> switch ( this ) { <END> case VAR_1 : return true ; default : return false ; } }
<|startcomment|> done <|endcomment|> protected void METHOD_1 ( String VAR_1 , TYPE_1 query ) { TYPE_2 . getInstance ( ) . METHOD_2 ( TYPE_6 . TYPE_7 , <START> new TYPE_3 ( STRING_1 + ( ( TYPE_4 ) METHOD_3 ( ) . METHOD_4 ( ) ) . METHOD_5 ( ) + STRING_2 + VAR_1 , TYPE_8 . TYPE_5 , ( String ) METHOD_6 ( ) . METHOD_4 ( ) ) , query ) ; <END> }
<|startcomment|> s v2 older hosts won t work HEAD <|endcomment|> public String METHOD_1 ( String id ) { return METHOD_2 ( ) . METHOD_3 ( ) + VAR_1 + STRING_1 + id + <START> STRING_2 ; <END> }
<|startcomment|> I recommend Collections _CODE_ ( ) instead <|endcomment|> public TYPE_1 ( ANNOTATION_1 String VAR_2 , ANNOTATION_1 String VAR_3 ) { this ( VAR_2 , VAR_3 , <START> new HashMap < String , Integer > ( ) , null ) ; <END> }
<|startcomment|> relative : frontend / webadmin / modules / uicommonweb / src / main / java / org / ovirt / engine / ui / uicommonweb / _CODE_ java <|endcomment|> public final String METHOD_1 ( ) { String url = getString ( TYPE_5 . VAR_2 ) ; boolean VAR_3 = url . contains ( STRING_1 ) ; return VAR_3 ? url : TYPE_3 . TYPE_4 . METHOD_2 ( ) + STRING_2 + TYPE_3 . TYPE_4 . METHOD_3 ( ) + <START> STRING_3 + TYPE_2 . getInstance ( ) . METHOD_4 ( ) + url ; <END> }
<|startcomment|> don t need refer entry getName ( ) places <|endcomment|> private boolean METHOD_1 ( TYPE_1 entry ) { <START> String VAR_1 = entry . getName ( ) ; <END> return TYPE_2 . METHOD_2 ( entry . getName ( ) ) && METHOD_3 ( VAR_1 ) ; }
<|startcomment|> I d assert created VM <|endcomment|> public void METHOD_1 ( ) { List < TYPE_1 > list = METHOD_2 ( ) . list ( ) ; <START> for ( TYPE_1 VAR_1 : list ) { <END> assertTrue ( ! VAR_1 . name ( ) . isEmpty ( ) ) ; } }
<|startcomment|> package - private <|endcomment|> <START> void METHOD_1 ( String id , TYPE_1 VAR_1 ) { <END> VAR_2 . put ( id , VAR_1 ) ; }
<|startcomment|> idem <|endcomment|> public void METHOD_1 ( TYPE_1 trace ) { synchronized ( VAR_1 ) { <START> if ( VAR_2 != null && VAR_2 . METHOD_2 ( ) ) { <END> return ; } } VAR_3 = trace ; VAR_4 . METHOD_3 ( trace , false ) ; METHOD_4 ( ) ; }
<|startcomment|> constructor i e reflection <|endcomment|> private TYPE_1 METHOD_1 ( String name , int VAR_1 , String VAR_2 , String ... VAR_3 ) { try { <START> return TYPE_2 . METHOD_2 ( TYPE_1 . class , String . VAR_4 , int . class , String . VAR_4 , TYPE_3 . VAR_4 , TYPE_5 . TYPE_6 . getClass ( ) ) <END> . METHOD_3 ( name , VAR_1 , VAR_2 , VAR_5 , VAR_3 ) ; } catch ( Exception e ) { throw TYPE_7 . LOG . METHOD_4 ( name , e . VAR_7 ( ) ) ; } }
<|startcomment|> change return type METHOD_2 implementation avoid cast <|endcomment|> public boolean METHOD_1 ( String type , long id , TYPE_1 VAR_1 ) { <START> final TYPE_2 VAR_2 = ( ( TYPE_2 ) METHOD_2 ( type , id ) ) ; <END> return VAR_2 . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> JDT compact assignement e g i = 3 ; <|endcomment|> public static final void METHOD_1 ( String id ) { if ( VAR_1 == null ) { <START> VAR_1 = <END> id ; } }
<|startcomment|> please remove due incorrect / / hosts file test environment <|endcomment|> private void METHOD_1 ( ) { try { VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <START> VAR_1 = STRING_1 ; <END> } catch ( TYPE_2 e ) { logger . warn ( STRING_2 + STRING_3 , e ) ; } }
<|startcomment|> package private removing protected modifier <|endcomment|> <START> protected TYPE_2 ( TYPE_1 VAR_2 ) { <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> return immediately need store a local var <|endcomment|> private Optional < TYPE_1 > METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) { <START> Optional < TYPE_1 > VAR_3 = <END> Arrays . stream ( VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ) . filter ( c - > VAR_1 . equals ( c . getName ( ) ) ) . METHOD_4 ( ) ; return VAR_3 ; }
<|startcomment|> class effectively a provider instead export bind JMX export bind IO VAR_2 export happen normal <|endcomment|> public void METHOD_1 ( ) { for ( TYPE_1 client : VAR_1 ) { client . close ( ) ; } if ( VAR_2 != null ) { VAR_2 . close ( ) ; VAR_2 = null ; <START> if ( VAR_3 . METHOD_2 ( TYPE_2 . get ( TYPE_3 . class ) ) != null ) { <END> VAR_3 . getInstance ( TYPE_3 . class ) . METHOD_3 ( METHOD_4 ( TYPE_4 . class ) + STRING_1 + name ) ; } } VAR_4 . set ( true ) ; }
<|startcomment|> METHOD_2 return save 2 checks <|endcomment|> private Set < String > METHOD_1 ( String VAR_1 ) { Set < String > VAR_2 = null ; if ( TYPE_1 . contains ( VAR_1 ) ) { VAR_2 = TYPE_1 ; } if ( TYPE_2 . contains ( VAR_1 ) ) { VAR_2 = TYPE_2 ; } <START> return VAR_2 == null ? null : TYPE_3 . METHOD_2 ( VAR_2 , TYPE_4 . of ( VAR_1 ) ) ; <END> }
<|startcomment|> planner enable_hashagg set * * false * * ? planner enable_streamagg defaults * * true * * <|endcomment|> public void METHOD_1 ( ) throws Exception { String VAR_1 = STRING_1 + STRING_2 + STRING_3 ; METHOD_2 ( ) . METHOD_3 ( STRING_4 , <START> TYPE_2 . TYPE_3 . METHOD_4 ( ) ) <END> . METHOD_5 ( VAR_1 ) . METHOD_6 ( ) . METHOD_7 ( STRING_5 ) . METHOD_8 ( INT_1 ) . METHOD_8 ( INT_2 ) . METHOD_8 ( INT_3 ) . METHOD_8 ( INT_4 ) . METHOD_8 ( INT_5 ) . METHOD_8 ( INT_6 ) . build ( ) . run ( ) ; }
<|startcomment|> throw IllegalArgumentException case doesn t match enum constant s easier compare ( ) enum constants : ( TYPE_1 status : values ) { ( status ( ) equals ( ) ) { return true ; } } return false ; <|endcomment|> public boolean METHOD_1 ( String value ) { TYPE_1 VAR_1 = <START> TYPE_1 . valueOf ( value ) ; <END> for ( TYPE_1 status : values ) { if ( status . equals ( VAR_1 ) ) { return true ; } } return false ; }
<|startcomment|> ctx close ( ) <|endcomment|> public void METHOD_1 ( TYPE_1 ctx , Throwable VAR_1 ) throws Exception { VAR_1 . METHOD_2 ( ) ; <START> ctx . channel ( ) . close ( ) ; <END> }
<|startcomment|> remove public <|endcomment|> <START> public TYPE_1 ( String VAR_2 ) { <END> super ( VAR_2 , null , false ) ; }
<|startcomment|> forcing orientation a good idea super METHOD_1 ( ) instead override METHOD_1 ( ) method print a log throw exception mess <|endcomment|> public TYPE_2 ( Context context , TYPE_1 VAR_2 ) { super ( context , VAR_2 ) ; <START> METHOD_1 ( VAR_3 ) ; <END> }
<|startcomment|> shouldn t a part _CODE_ method <|endcomment|> public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) { VAR_1 . METHOD_3 ( TYPE_3 . METHOD_4 ( ) ) ; } <START> VAR_1 . METHOD_5 ( ) . METHOD_3 ( VAR_1 . METHOD_2 ( ) ) ; <END> METHOD_6 ( ) . add ( VAR_1 . METHOD_5 ( ) ) ; return this ; }
<|startcomment|> don t need give string ( other similar ) s default message METHOD_2 ( key ) <|endcomment|> public boolean METHOD_1 ( final String key ) throws TYPE_1 { <START> final String VAR_1 = STRING_1 + key + STRING_2 ; <END> final String val = METHOD_2 ( key , VAR_1 ) ; try { return Boolean . VAR_2 ( val ) ; } catch ( Exception e ) { throw new TYPE_1 ( VAR_1 ) ; } }
<|startcomment|> annotation annotation a event handler / event handlers class a server client don t need check mode VAR_1 <|endcomment|> public void METHOD_1 ( TYPE_1 event , TYPE_2 entity ) { <START> if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) { <END> TYPE_3 VAR_2 = TYPE_3 . METHOD_4 ( ) ; VAR_3 . put ( entity , VAR_2 ) ; METHOD_5 ( entity ) ; } }
<|startcomment|> block useless <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 == null ^ VAR_2 == null ) { return false ; <START> } else if ( VAR_1 == VAR_2 ) { <END> return true ; } else { return VAR_1 . id . equals ( VAR_2 . id ) ; } }
<|startcomment|> TYPE_2 constructor takes care <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 ) { Assert . VAR_3 ( VAR_2 , STRING_1 ) ; this . VAR_4 = new TYPE_2 ( VAR_2 ) ; <START> this . VAR_4 . METHOD_1 ( ) ; <END> }
<|startcomment|> inherited m_isleadertoreplica instead adding a new VAR_15 ? message leader replica MPI leader <|endcomment|> public TYPE_1 ( long VAR_2 , long VAR_3 , long VAR_4 , boolean VAR_5 , int VAR_6 , boolean VAR_7 , boolean VAR_8 , boolean VAR_9 , boolean VAR_10 ) { super ( VAR_2 , VAR_3 , VAR_4 , 0 , VAR_5 , VAR_10 ) ; VAR_11 = VAR_6 ; METHOD_1 ( VAR_12 , VAR_7 ) ; METHOD_1 ( VAR_13 , VAR_8 ) ; METHOD_1 ( VAR_14 , VAR_9 ) ; <START> VAR_15 = false ; <END> VAR_16 = true ; }
<|startcomment|> return true want VAR_1 instead null <|endcomment|> private TYPE_1 METHOD_1 ( ) { <START> if ( TYPE_2 . METHOD_2 ( null ) ) { <END> VAR_1 = TYPE_3 . METHOD_3 ( TYPE_4 . class ) ; } return VAR_1 ; }
<|startcomment|> method private <|endcomment|> <START> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <END> TYPE_4 < TYPE_2 > VAR_3 = new TYPE_5 ( Collections . VAR_4 ( VAR_1 ) , Collections . VAR_5 ( ) ) ; return METHOD_1 ( VAR_3 , VAR_2 ) ; }
<|startcomment|> return null instead throwing exception ? wrong wouldn t need empty catch block <|endcomment|> private static TYPE_1 METHOD_1 ( ) throws IOException { Collection < ? extends TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) ; if ( ! VAR_1 . isEmpty ( ) ) { VAR_2 = VAR_1 . iterator ( ) . next ( ) ; return VAR_2 ; } <START> throw new IOException ( STRING_1 ) ; <END> }
<|startcomment|> please put brackets easier read <|endcomment|> public void METHOD_1 ( ) { if ( METHOD_2 ( VAR_1 ) ) <START> throw new TYPE_1 ( STRING_1 ) ; <END> else TYPE_2 . log ( STRING_2 , STRING_3 , true , VAR_2 ) ; }
<|startcomment|> save assign a new subscription unsubscribing a potentially existing previous subscription ? ask : guarantee called times a row activity lifecycle VAR_1 = = true <|endcomment|> private void METHOD_1 ( ) { if ( VAR_1 ) { <START> VAR_2 = VAR_3 . start ( TYPE_1 . VAR_5 ) ; <END> } else { VAR_2 . METHOD_2 ( ) ; } }
<|startcomment|> needed <|endcomment|> TYPE_4 ( <START> TYPE_1 VAR_2 , <END> TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_5 = VAR_3 ; this . VAR_4 = VAR_4 ; }
<|startcomment|> I I multiple VAR_3 types enum : VAR_3 ppc64 ppcle ppc64le <|endcomment|> private boolean METHOD_1 ( ) { TYPE_1 cluster = METHOD_2 ( ) . METHOD_3 ( ) ; return cluster != null && cluster . VAR_1 ( ) != null <START> && TYPE_2 . VAR_3 . METHOD_4 ( ) == cluster . VAR_1 ( ) . METHOD_4 ( ) ; <END> }
<|startcomment|> private <|endcomment|> <START> protected void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , String VAR_3 ) throws TYPE_2 { <END> if ( VAR_4 . METHOD_2 ( ) ) return ; boolean VAR_5 = METHOD_3 ( METHOD_4 ( false , VAR_2 ) , VAR_1 ) ; if ( ! VAR_5 ) { String VAR_6 = String . format ( STRING_1 , METHOD_4 ( true , VAR_2 ) , METHOD_5 ( ) , VAR_3 ) ; if ( log . VAR_7 ( ) ) { log . VAR_8 ( STRING_2 , VAR_6 ) ; } METHOD_6 ( VAR_1 , VAR_6 ) ; } }
<|startcomment|> simplified : > return ; <|endcomment|> public Object getValue ( ) { <START> if ( value == null ) { <END> return null ; } else { return value ; } }
<|startcomment|> false = = a peculiar express ! BTW peculiar a polite wrong <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( false == VAR_1 . METHOD_2 ( ) ) { <END> return false ; } if ( VAR_2 . METHOD_3 ( ) || VAR_2 . METHOD_4 ( ) ) { return false ; } if ( VAR_1 instanceof TYPE_2 && VAR_2 . METHOD_5 ( ) ) { return false ; } return true ; }
<|startcomment|> cell please <|endcomment|> public void METHOD_1 ( ) { when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( Collections . VAR_2 ( ) ) ; <START> when ( VAR_1 . METHOD_4 ( ) ) . METHOD_3 ( TYPE_1 . create ( VAR_3 , VAR_4 ) ) ; <END> assertTrue ( VAR_5 . METHOD_5 ( VAR_6 ) ) ; }
<|startcomment|> relevant IMO s data rules internal helper practice true s a singleton component <|endcomment|> public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof TYPE_1 ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) object ; return new TYPE_2 ( ) . append ( this . VAR_2 , VAR_1 . VAR_2 ) . append ( this . VAR_3 , VAR_1 . VAR_3 ) <START> . append ( this . VAR_4 , VAR_1 . VAR_4 ) <END> . METHOD_1 ( ) ; }
<|startcomment|> reason added TYPE_2 ? remove s a method class <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> List < TYPE_1 > VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; <END> for ( TYPE_1 VAR_3 : VAR_2 ) { if ( METHOD_3 ( VAR_3 ) ) { return true ; } } return false ; }
<|startcomment|> Math max ( VAR_4 VAR_3 ) a bit clearer <|endcomment|> private static int METHOD_1 ( int VAR_1 , int VAR_2 , int VAR_3 ) { int VAR_4 = TYPE_1 . METHOD_2 ( VAR_1 + VAR_2 ) ; assert VAR_4 >= 0 ; <START> return VAR_4 <= VAR_3 ? VAR_3 : VAR_4 ; <END> }
<|startcomment|> doesn t I suspect loss logs logback solved problem enabled <|endcomment|> private static void METHOD_1 ( ) { log . info ( STRING_1 ) ; VAR_1 = true ; try { TYPE_1 VAR_2 = VAR_3 ; if ( VAR_2 != null ) { VAR_3 . close ( ) ; } } catch ( Throwable VAR_4 ) { log . error ( STRING_2 , VAR_4 ) ; } <START> TYPE_2 VAR_5 = ( TYPE_2 ) TYPE_3 . METHOD_2 ( ) ; <END> VAR_5 . METHOD_3 ( ) ; }
<|startcomment|> I PR ( ) _CODE_ _CODE_ ( ) honestly _CODE_ changed tojavaprivate static final Logger LOGGER = _CODE_ _CODE_ ( _CODE_ ID ) ; <|endcomment|> public void METHOD_1 ( TYPE_1 event ) { <START> Log . VAR_1 ( event . VAR_2 ( ) ) ; <END> VAR_3 = new File ( event . VAR_4 ( ) , STRING_1 ) ; VAR_3 . METHOD_2 ( ) ; VAR_5 = TYPE_2 . instance ( ) ; VAR_6 = new TYPE_3 ( new File ( VAR_3 , STRING_2 ) ) ; VAR_6 . METHOD_3 ( VAR_5 ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; }
<|startcomment|> checkstyle violation : [ ant : checkstyle ] [ ERROR ] / home / travis / build / spring - projects / spring - integration / spring - integration - ftp / src / main / java / org / springframework / integration / ftp / session / _CODE_ java : 157 : construct { } s [ _CODE_ ] verify locally gradlew clean : spring - integration - ftp : check <|endcomment|> public void close ( ) { try { if ( this . VAR_1 . get ( ) && ! METHOD_1 ( ) && LOGGER . VAR_2 ( ) ) { LOGGER . warn ( STRING_1 + this ) ; } <START> if ( this . client . VAR_3 ( ) ) <END> this . client . VAR_4 ( ) ; this . client . VAR_5 ( ) ; } catch ( Exception e ) { LOGGER . warn ( STRING_2 , e ) ; } }
<|startcomment|> extra ( clutter ) please <|endcomment|> protected TYPE_1 METHOD_1 ( ) throws Exception { <START> return ( this . VAR_1 == null ) ? TYPE_1 . VAR_2 : TYPE_1 . VAR_3 ; <END> }
<|startcomment|> VAR_6 * VAR_3 <|endcomment|> public TYPE_5 ( int VAR_2 , float VAR_3 , TYPE_1 < TYPE_2 > VAR_4 , TYPE_1 < TYPE_3 > VAR_5 ) { int VAR_6 = 1 ; while ( VAR_6 < VAR_2 ) VAR_6 <<= 1 ; this . VAR_3 = VAR_3 ; <START> VAR_7 = ( int ) ( VAR_6 * VAR_8 ) ; <END> table = new TYPE_4 [ VAR_6 ] ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; }
<|startcomment|> throw exception <|endcomment|> <START> private void METHOD_1 ( ) { <END> try { METHOD_2 ( ) . when ( VAR_1 ) . METHOD_3 ( ) ; METHOD_2 ( ) . when ( VAR_1 ) . METHOD_4 ( ) ; } catch ( Exception e ) { } }
<|startcomment|> ! [ MINOR ] ( severity : MINOR ) remove redundant ! _CODE_ ! thrown exception declaration ( s ) [ ! [ rule ] ( ) ] ( ) <|endcomment|> public static String METHOD_1 ( final TYPE_1 VAR_1 ) <START> throws TYPE_2 , TYPE_3 , TYPE_4 { <END> TYPE_5 host = VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( TYPE_7 . VAR_4 ) , TYPE_6 . METHOD_4 ( ) , false ) ; return METHOD_1 ( host . VAR_5 ( ) , METHOD_5 ( VAR_1 . METHOD_3 ( TYPE_7 . VAR_6 ) ) , VAR_1 . METHOD_6 ( ) ) ; }
<|startcomment|> revert change <|endcomment|> protected void METHOD_1 ( Object data , TYPE_1 VAR_1 , TYPE_2 VAR_2 , boolean VAR_3 ) throws IOException { if ( VAR_3 ) { TYPE_3 VAR_4 = new TYPE_4 ( VAR_1 , VAR_2 ) ; TYPE_5 . METHOD_2 ( data , VAR_4 ) ; } else { <START> METHOD_3 ( data , VAR_2 , false ) ; <END> } }
<|startcomment|> exceptions unacceptable ( intended pun miserably failed ) listing clusters resource - allocation - change related exception occur a entity kind <|endcomment|> <START> public void execute ( ) throws TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 { <END> TYPE_7 < TYPE_8 > response = VAR_1 . METHOD_1 ( this ) ; response . VAR_2 ( METHOD_2 ( ) ) ; METHOD_3 ( response ) ; }
<|startcomment|> _CODE_ needed <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> context . VAR_1 ( ) ; <END> VAR_2 . METHOD_2 ( STRING_1 , false ) ; context . VAR_3 ( ) ; String token = METHOD_3 ( VAR_4 . METHOD_4 ( ) , VAR_5 ) ; METHOD_5 ( token ) . METHOD_6 ( get ( STRING_2 ) . METHOD_7 ( STRING_3 , VAR_6 . METHOD_8 ( ) ) ) . METHOD_9 ( status ( ) . METHOD_10 ( ) ) ; context . VAR_1 ( ) ; VAR_2 . METHOD_2 ( STRING_1 , true ) ; context . VAR_3 ( ) ; }
<|startcomment|> entrySet <|endcomment|> protected void METHOD_1 ( Builder VAR_1 ) { if ( VAR_2 != null ) { <START> for ( String key : VAR_2 . keySet ( ) ) { <END> VAR_1 . METHOD_2 ( key , VAR_2 . get ( key ) ) ; } } }
<|startcomment|> I thinkreturn ( VAR_2 size ( ) > VAR_1 size ( ) ) sufficient <|endcomment|> private boolean METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 , List < TYPE_2 > VAR_2 ) { <START> boolean VAR_3 = false ; if ( VAR_2 . size ( ) > VAR_1 . size ( ) ) { VAR_3 = true ; } return VAR_3 ; <END> }
<|startcomment|> unnecessary VAR_2 added VAR_1 created <|endcomment|> void METHOD_1 ( ) throws TYPE_1 { METHOD_1 ( VAR_1 ) ; <START> <END> if ( VAR_2 != null && ! VAR_2 . METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( ) ; } VAR_2 = null ; }
<|startcomment|> scope block broader necessary needs line <|endcomment|> public boolean METHOD_1 ( String view , TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { if ( TYPE_4 . isPresent ( STRING_1 , VAR_2 ) ) { try { String VAR_4 = METHOD_2 ( view , VAR_1 ) ; if ( VAR_3 . METHOD_3 ( VAR_4 ) . exists ( ) ) { return true ; } <START> return new File ( STRING_2 , VAR_4 ) . exists ( ) ; <END> } catch ( TYPE_5 ex ) { return false ; } } return false ; }
<|startcomment|> return Object instead T <|endcomment|> <START> public Object METHOD_1 ( final TYPE_1 node ) { <END> return node . VAR_1 ( this ) ; }
<|startcomment|> please remove alias setting ( encapsulated METHOD_4 <|endcomment|> public static void METHOD_1 ( TYPE_1 VAR_1 , Guid VAR_2 ) { TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; TYPE_3 . METHOD_4 ( new TYPE_4 ( VAR_1 . getId ( ) , VAR_2 ) , TYPE_5 . VAR_4 , TYPE_5 . VAR_4 , null , true , false , <START> "" ) ; <END> }
<|startcomment|> return <|endcomment|> private static Throwable METHOD_1 ( TYPE_1 context ) { Throwable t = null ; for ( TYPE_2 method : context . VAR_1 ( ) . METHOD_2 ( ) ) { TYPE_3 m = method . VAR_2 ( ) ; if ( m . VAR_3 ( ) && ( ! method . VAR_4 ( ) . METHOD_3 ( ) ) ) { <START> t = method . VAR_4 ( ) . METHOD_4 ( ) ; <END> break ; } } return t ; }
<|startcomment|> I recommend adding { } <|endcomment|> protected String toString ( TYPE_1 VAR_1 ) { <START> if ( TYPE_1 . TYPE_3 . equals ( VAR_1 ) ) return VAR_2 ; <END> return VAR_1 . toString ( ) ; }
<|startcomment|> a leftover hasn t usage remove <|endcomment|> <START> static TYPE_1 METHOD_1 ( final Object object ) { <END> if ( object == null ) { return null ; } if ( object instanceof TYPE_1 ) { return ( TYPE_1 ) object ; } if ( object instanceof TYPE_2 ) { } else if ( object instanceof Map ) { } throw new IllegalArgumentException ( STRING_1 + object . getClass ( ) ) ; }
<|startcomment|> point exposing constructor a single public method methods private ( static require a constructor ) <|endcomment|> <START> public TYPE_1 ( String VAR_2 ) { <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> please improve error handling accordance : introduce _CODE_ implements _CODE_ catch METHOD_5 done methods implement generic interfaces * raw methods throw _CODE_ <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; try { VAR_1 = this . VAR_2 . METHOD_1 ( VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) , VAR_3 . METHOD_4 ( ) ) ; <START> } catch ( TYPE_2 e ) { <END> TYPE_3 . METHOD_5 ( e ) ; } return VAR_1 ; }
<|startcomment|> need prepend blank space TYPE_4 format ( ) ? able simplify a <|endcomment|> protected void METHOD_1 ( T VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { try { TYPE_3 VAR_4 = VAR_5 . METHOD_2 ( VAR_1 , VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_4 ) ; } catch ( IOException e ) { LOG . error ( STRING_1 + e . getMessage ( ) ) ; String message = TYPE_4 . format ( VAR_6 . METHOD_4 ( TYPE_6 . VAR_8 ) , <START> TYPE_7 . VAR_10 + VAR_2 . METHOD_5 ( ) ) ; <END> throw new TYPE_5 ( message ) ; } }
<|startcomment|> effectively final class throw new TYPE_2 ( ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> throw new TYPE_2 ( getClass ( ) . getName ( ) ) ; <END> }
<|startcomment|> please add actual type case fails <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( VAR_3 - > { <START> METHOD_3 ( VAR_3 instanceof TYPE_4 , STRING_1 ) ; <END> return node . VAR_4 ( ) . contains ( VAR_3 ) ? Optional . of ( VAR_3 ) : Optional . empty ( ) ; } ) ; return METHOD_4 ( node , METHOD_5 ( node , VAR_2 ) ) ; }
<|startcomment|> please put correct status <|endcomment|> public TYPE_1 METHOD_1 ( ) { List < TYPE_2 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( VAR_2 . getId ( ) ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { if ( VAR_3 . getStatus ( ) != null && VAR_3 . getStatus ( ) . METHOD_4 ( ) ) { return new TYPE_1 ( TYPE_4 . VAR_5 , <START> String . format ( STRING_1 , TYPE_5 . TYPE_3 ) ) ; <END> } } return TYPE_1 . VAR_8 ; }
<|startcomment|> static <|endcomment|> <START> private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) <END> { if ( METHOD_2 ( VAR_1 ) instanceof TYPE_2 ) { return ( ( TYPE_2 ) METHOD_2 ( VAR_1 ) ) . getName ( ) . toString ( ) . equalsIgnoreCase ( VAR_2 ) ; } return false ; }
<|startcomment|> slightly simplify : javareturn result ! = null && objects equals ( TYPE_1 Type VAR_2 result getType ( ) ) ; <|endcomment|> public boolean METHOD_1 ( ) { <START> return result != null && result . getType ( ) != null && TYPE_1 . Type . VAR_2 . equals ( result . getType ( ) ) ; <END> }
<|startcomment|> change order lines <|endcomment|> private void METHOD_1 ( ) { when ( METHOD_2 ( ) . METHOD_3 ( ) ) . METHOD_4 ( VAR_1 ) ; List < TYPE_1 > VAR_2 = Collections . VAR_3 ( VAR_4 ) ; when ( VAR_1 . METHOD_5 ( VAR_5 ) ) . METHOD_4 ( <START> VAR_2 ) ; <END> }
<|startcomment|> need method public ? place s package protected / default work <|endcomment|> <START> public void METHOD_1 ( TYPE_1 project ) { <END> this . project = project ; }
<|startcomment|> I VAR_1 ( ) <|endcomment|> public List < String > values ( String name ) { <START> return VAR_1 == null ? null : VAR_1 . get ( STRING_1 ) ; <END> }
<|startcomment|> dude <|endcomment|> <START> @Override protected Pair < TYPE_1 , Boolean > METHOD_1 ( TYPE_1 ... VAR_1 ) { <END> TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( context , VAR_1 [ 0 ] ) . METHOD_3 ( ) ; return new Pair < > ( VAR_1 [ 0 ] , VAR_2 == TYPE_2 . VAR_3 ) ; }
<|startcomment|> generally speaking s need null fields object hold reference object GC job don t need : ) <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 = <END> null ; VAR_2 . METHOD_1 ( ) ; VAR_2 = null ; VAR_3 = null ; VAR_4 = null ; }
<|startcomment|> public <|endcomment|> <START> public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <END> TYPE_1 VAR_3 = VAR_1 ; final TYPE_1 VAR_4 = new TYPE_1 ( ) ; if ( VAR_3 == null || VAR_3 . METHOD_2 ( VAR_4 ) ) { VAR_3 = VAR_4 ; } if ( VAR_3 . METHOD_2 ( VAR_2 ) ) { if ( VAR_2 . METHOD_2 ( VAR_4 ) ) { VAR_3 = VAR_4 ; } } else { VAR_3 = VAR_2 ; } return VAR_3 ; }
<|startcomment|> synchronized protection function protect _CODE_ function I need add a note remind caller future remember protect <|endcomment|> private void <START> METHOD_1 ( ) <END> { final TYPE_1 res = METHOD_2 ( VAR_1 , VAR_2 ) ; final String VAR_3 = res . getString ( R . string . VAR_4 ) ; final String message = res . getString ( R . string . VAR_5 ) ; METHOD_3 ( R . VAR_6 . VAR_7 , VAR_3 , message , "" ) ; }
<|startcomment|> specific reason method static anymore <|endcomment|> <START> private File METHOD_1 ( <END> File VAR_1 , String VAR_2 , String VAR_3 ) { return new File ( VAR_1 , METHOD_2 ( VAR_2 , VAR_3 ) ) ; }
<|startcomment|> a note consistency : sense find free port set system property setting org uberfire nio git daemon enabled = false lines <|endcomment|> public static void METHOD_1 ( ) { <START> int VAR_1 = TYPE_1 . METHOD_2 ( ) ; <END> System . VAR_2 ( STRING_1 , String . valueOf ( VAR_1 ) ) ; logger . info ( STRING_2 , VAR_1 ) ; System . VAR_2 ( STRING_3 , STRING_4 ) ; System . VAR_2 ( STRING_5 , STRING_4 ) ; System . VAR_2 ( STRING_6 , STRING_7 ) ; }
<|startcomment|> method useful deprecated future <|endcomment|> public void METHOD_1 ( String s ) { if ( s != null && ! s . equals ( "" ) ) <START> VAR_1 = TYPE_1 . METHOD_2 ( s . split ( STRING_1 ) ) ; <END> }
<|startcomment|> thanks PR ! I noticed log messages completely redundant ; remove combine a single log <|endcomment|> synchronized void METHOD_1 ( final Set < String > VAR_1 , final String VAR_2 ) { <START> log . debug ( STRING_1 , VAR_2 , VAR_1 . size ( ) ) ; <END> VAR_3 . clear ( ) ; VAR_3 . addAll ( VAR_1 ) ; log . debug ( STRING_2 , VAR_2 , VAR_3 . size ( ) ) ; METHOD_2 ( ) ; METHOD_3 ( ) ; }
<|startcomment|> put && previous <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { try { VAR_1 . METHOD_2 ( ) ; if ( VAR_2 . remove ( VAR_1 ) ) { <START> if ( VAR_3 . METHOD_3 ( ) && VAR_2 . isEmpty ( ) ) { <END> METHOD_4 ( ) ; } } } catch ( Exception e ) { LOGGER . warn ( STRING_1 , e ) ; } finally { VAR_4 . METHOD_5 ( ) ; } }
<|startcomment|> check null missing <|endcomment|> protected void METHOD_1 ( ) { <START> VAR_1 . close ( ) ; <END> super . METHOD_1 ( ) ; TYPE_1 . clear ( ) ; }
<|startcomment|> constructor package private instead private avoid a generated synthetic constructor <|endcomment|> <START> private TYPE_2 ( TYPE_1 a ) { <END> this . a = a ; }
<|startcomment|> I METHOD_5 ( ) preferred toString ( ) TYPE_1 toString ( ) separator / platforms need docs METHOD_5 ( ) matched _CODE_ ( ) converting Path METHOD_5 ( ) doubles : belongs device part ( windows ) example c : \one\two : x transformed c : / / / : : x segments : symbols difference toString ( ) a segment : symbol _CODE_ ( ) necessary restore original path linux <|endcomment|> private String METHOD_1 ( String VAR_1 ) { if ( org . VAR_2 . VAR_3 . VAR_4 . StringUtils . VAR_5 ( VAR_1 ) || VAR_1 . contains ( STRING_1 ) ) { return VAR_1 ; } TYPE_1 VAR_6 = new Path ( VAR_1 ) ; TYPE_2 container = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_6 ) ; if ( container != null ) { <START> return container . VAR_7 ( ) . METHOD_5 ( ) ; <END> } return null ; }
<|startcomment|> VAR_4 wrong ? VAR_4 ( ) <|endcomment|> private void METHOD_1 ( ) { VAR_1 . clear ( ) ; VAR_2 = new TYPE_1 ( ) ; VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_2 ( VAR_4 . METHOD_3 ( ) ) ; TYPE_3 VAR_5 = new TYPE_3 ( ) ; VAR_5 . METHOD_2 ( VAR_4 . METHOD_4 ( ) ) ; VAR_5 . add ( VAR_3 ) ; VAR_1 . add ( VAR_5 ) ; <START> VAR_1 . METHOD_2 ( STRING_1 ) ; <END> VAR_1 . add ( VAR_2 ) ; }
<|startcomment|> METHOD_4 mutable caller <|endcomment|> public List < String > METHOD_1 ( String VAR_1 ) { int i = VAR_2 . METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; if ( 0 <= i ) { <START> return VAR_2 . METHOD_4 ( i + 1 , VAR_2 . size ( ) ) ; <END> } else { return Collections . VAR_3 ( ) ; } }
<|startcomment|> a check viewer ? shouldn t VAR_3 ? table <|endcomment|> public void METHOD_1 ( int VAR_1 , TYPE_1 event ) { if <START> ( this . VAR_2 != <END> null && ! this . VAR_3 . METHOD_2 ( ) ) this . VAR_3 . METHOD_1 ( VAR_1 , event ) ; }
<|startcomment|> t move check _CODE_ extend some common hive test class <|endcomment|> public static void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( STRING_1 , TYPE_1 . METHOD_3 ( ) ) ; <END> METHOD_4 ( TYPE_2 . class . METHOD_5 ( ) ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; METHOD_8 ( ) ; METHOD_9 ( true ) ; METHOD_10 ( METHOD_11 ( ) ) ; METHOD_12 ( new HashMap < > ( ) ) ; METHOD_13 ( ) ; }
<|startcomment|> fields set AOP _CODE_ needs delegate METHOD_4 instead calling DAO case extra logic save method don t want pass <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { VAR_1 . METHOD_2 ( true ) ; <START> VAR_1 . METHOD_3 ( VAR_2 ) ; <END> return VAR_3 . METHOD_4 ( VAR_1 ) ; }
<|startcomment|> rename child <|endcomment|> private void METHOD_1 ( ) { Object [ ] VAR_1 = VAR_2 . METHOD_2 ( METHOD_3 ( ) ) ; TYPE_1 VAR_3 ; TYPE_2 VAR_4 = METHOD_3 ( ) . METHOD_4 ( ) ; for ( Object <START> element : <END> VAR_1 ) { VAR_3 = ( TYPE_1 ) element ; if ( VAR_4 . METHOD_5 ( VAR_3 . getId ( ) ) ) { METHOD_6 ( ) . METHOD_7 ( element , true ) ; METHOD_8 ( ) . add ( element ) ; } else { METHOD_6 ( ) . METHOD_7 ( element , false ) ; } } }
<|startcomment|> return null layer visibility = false <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , Double VAR_2 , Double VAR_3 ) { <START> TYPE_1 VAR_4 = METHOD_1 ( VAR_1 ) ; <END> for ( TYPE_3 VAR_5 : VAR_4 . METHOD_2 ( ) ) { if ( VAR_2 != null ) { VAR_5 . METHOD_3 ( VAR_2 ) ; } if ( VAR_3 != null ) { VAR_5 . METHOD_4 ( VAR_3 ) ; } } return VAR_4 ; }
<|startcomment|> reason _CODE_ supports reusing existing _CODE_ ( instead maintaining ) save object parsing I s flexible set - caller setting want <|endcomment|> public Optional < TYPE_1 > METHOD_1 ( Collection < TYPE_1 > VAR_1 , Collection < TYPE_1 > VAR_2 ) throws TYPE_2 , TYPE_3 , IOException { VAR_3 . METHOD_2 ( ) ; <START> VAR_3 . METHOD_3 ( false ) ; <END> if ( VAR_4 ) { VAR_3 . METHOD_4 ( TYPE_4 . VAR_6 ) ; } for ( TYPE_1 target : VAR_1 ) { VAR_3 . METHOD_5 ( target ) ; } for ( TYPE_1 VAR_7 : VAR_2 ) { VAR_3 . METHOD_6 ( VAR_7 ) ; } return Optional . VAR_8 ( VAR_3 . next ( ) ) ; }
<|startcomment|> shouldn t VAR_1 Optional ? me‚Ä¶ I don t need introduce Optional caller careful calling a null <|endcomment|> <START> public Optional < TYPE_1 < TYPE_2 > > METHOD_1 ( final TYPE_2 context , final Object VAR_1 ) { <END> return VAR_1 == null ? Optional . empty ( ) : Optional . of ( new TYPE_3 ( ( TYPE_4 ) VAR_1 ) ) ; }
<|startcomment|> I don t advantage METHOD_2 ( ) <|endcomment|> public Response METHOD_1 ( ) throws Exception { <START> return TYPE_1 . METHOD_2 ( VAR_1 ) . get ( ) ; <END> }
<|startcomment|> STRING_1 equals ( ) null safe consistent check method <|endcomment|> static boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> if ( ! VAR_1 . name . equals ( STRING_1 ) ) { <END> return false ; } final Type [ ] VAR_2 = Type . VAR_3 ( VAR_1 . VAR_4 ) . METHOD_2 ( ) ; if ( VAR_2 . length < 2 ) { return false ; } return STRING_2 . equals ( VAR_2 [ VAR_2 . length - 1 ] . METHOD_3 ( ) ) ; }
<|startcomment|> VAR_4 updated <|endcomment|> public void METHOD_1 ( long VAR_1 ) { long VAR_2 = VAR_3 . METHOD_2 ( ) / INT_1 ; <START> if ( VAR_2 != VAR_4 . get ( ) ) { <END> VAR_5 . set ( 0 ) ; } long count = VAR_5 . METHOD_3 ( VAR_1 ) ; METHOD_4 ( count ) ; }
<|startcomment|> ack <|endcomment|> public static void METHOD_1 ( String path ) throws TYPE_1 { if ( path . startsWith ( STRING_1 ) ) { throw new TYPE_1 ( TYPE_2 . format ( TYPE_3 . get ( ) . VAR_1 , path ) , <START> TYPE_4 . TYPE_5 . VAR_4 ) ; <END> } }
<|startcomment|> VAR_1 - > message <|endcomment|> public String getMessage ( ) { <START> String VAR_1 = super . getMessage ( ) ; <END> if ( VAR_2 . isPresent ( ) ) { VAR_1 += STRING_1 + VAR_2 . get ( ) + STRING_2 ; } return VAR_1 ; }
<|startcomment|> minor suggestion change exception : throw new IllegalArgumentException ( STRING_1 ) ; <|endcomment|> protected TYPE_3 ( TYPE_1 VAR_2 ) { if ( VAR_2 == null ) { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } this . VAR_3 = VAR_2 ; }
<|startcomment|> return METHOD_2 ( ) ! = null && ( STRING_1 ( METHOD_2 ( ) ) || STRING_2 ( METHOD_2 ( ) ) ) ; <|endcomment|> public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) != null && ( METHOD_2 ( ) . startsWith ( STRING_1 ) || STRING_2 . equals ( METHOD_2 ( ) ) || STRING_3 . equals ( METHOD_2 ( ) ) ) ; <END> }
<|startcomment|> shouldn t public <|endcomment|> <START> public TYPE_1 < TYPE_2 > values ( TYPE_3 < TYPE_4 > VAR_1 , TYPE_5 VAR_2 ) { <END> return new TYPE_6 < > ( this , METHOD_1 ( VAR_1 , VAR_2 ) ) ; }
<|startcomment|> please change discussed <|endcomment|> public synchronized void METHOD_1 ( float VAR_1 ) { if ( VAR_1 < FLOAT_1 ) { VAR_1 = FLOAT_1 ; } else if ( VAR_1 > FLOAT_2 ) { VAR_1 = FLOAT_2 ; } VAR_2 = VAR_1 / FLOAT_3 ; <START> VAR_3 = true ; <END> METHOD_2 ( ) ; }
<|startcomment|> a incompatible change merged <|endcomment|> <START> public TYPE_1 METHOD_1 ( boolean VAR_1 ) { <END> this . VAR_1 = VAR_1 ; return this ; }
<|startcomment|> remove obsolete class casts <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 < ? , ? > build ) { if ( TYPE_3 . getInstance ( ) . METHOD_2 ( STRING_1 ) != null ) { if ( build instanceof TYPE_4 ) { TYPE_4 VAR_1 = ( TYPE_4 ) build ; return new TYPE_5 ( ( TYPE_2 < ? , ? > ) VAR_1 . METHOD_3 ( ) ) ; } } <START> return new TYPE_5 ( ( TYPE_2 ) build ) ; <END> }
<|startcomment|> wouldn t check instance Date delegate METHOD_2 ( Date Date ) <|endcomment|> public static < TYPE_1 , TYPE_2 extends TYPE_1 > boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 == null ) { return VAR_2 == null ; } else if ( VAR_2 == null ) { return false ; } <START> return ( VAR_1 instanceof TYPE_3 || VAR_2 instanceof TYPE_3 ) ? METHOD_2 ( ( Date ) VAR_1 , ( Date ) VAR_2 ) == 0 : VAR_1 . equals ( VAR_2 ) ; <END> }
<|startcomment|> don t need else clause clause a return <|endcomment|> public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( node == null ) { return VAR_1 . node == null ; } <START> else return node . equals ( VAR_1 . node ) ; <END> }
<|startcomment|> I class <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; VAR_2 = METHOD_3 ( VAR_1 ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( STRING_2 , STRING_3 ) ; TYPE_2 VAR_3 = VAR_2 . METHOD_4 ( STRING_4 , params ) ; <START> TYPE_3 . assertThat ( VAR_3 . METHOD_5 ( ) ) . METHOD_6 ( TYPE_2 . VAR_4 ) ; <END> }
<|startcomment|> VAR_4 values ( ) stream ( ) forEach ( : : METHOD_2 ) <|endcomment|> public TYPE_3 ( int VAR_2 , int VAR_3 , TYPE_1 < TYPE_2 > VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = METHOD_1 ( VAR_4 , STRING_1 ) ; VAR_5 = 0 ; VAR_6 = 0 ; <START> for ( TYPE_2 VAR_7 : VAR_4 . values ( ) ) { <END> METHOD_2 ( VAR_7 ) ; } }
<|startcomment|> dumb add a TYPE_7 id form _CODE_ _CODE_ _CODE_ factory perform 1 cache lookup 2 <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 user ) throws TYPE_4 { <START> final TYPE_7 . TYPE_8 VAR_2 = VAR_3 . get ( VAR_1 . METHOD_2 ( ) ) . METHOD_2 ( ) . METHOD_3 ( ) ; <END> try { return VAR_4 . METHOD_1 ( VAR_2 , user ) . METHOD_1 ( VAR_1 ) ; } catch ( TYPE_6 e ) { throw new TYPE_4 ( VAR_1 . getId ( ) , e ) ; } }
<|startcomment|> throw IllegalStateException similar <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; try { VAR_2 = ( TYPE_2 ) VAR_1 ; } catch ( TYPE_3 e ) { <START> throw new TYPE_3 ( VAR_1 . toString ( ) <END> + STRING_1 ) ; } }
<|startcomment|> I don t emit event case another I case ( JMS ) update _CODE_ database currently don t update case normal JPA _CODE_ tasks isn t a bit index persist VAR_1 <|endcomment|> <START> public void METHOD_1 ( TYPE_1 event , Map < String , Object > VAR_1 ) { <END> if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return ; } TYPE_2 task = event . VAR_2 ( ) ; List < TYPE_3 > VAR_3 = METHOD_2 ( task , VAR_1 , TYPE_6 . VAR_5 ) ; TYPE_4 VAR_6 = METHOD_3 ( task , event . VAR_7 ( ) ) ; METHOD_4 ( new TYPE_5 ( VAR_6 , null , VAR_3 , null ) , 2 ) ; }
<|startcomment|> remember put { } / else / / <|endcomment|> public TYPE_3 ( TYPE_1 file ) throws IOException , TYPE_2 { VAR_2 = new HashMap < String , ArrayList < Object > > ( ) ; VAR_3 = new HashMap < String , ArrayList < Object > > ( ) ; <START> if ( file . VAR_4 ( ) . METHOD_1 ( ) <= 0 ) <END> return ; this . file = file ; VAR_5 = "" ; parse ( ) ; }
<|startcomment|> I turn && A simple _CODE_ check a lot cheaper full parameter assignment verification <|endcomment|> public boolean METHOD_1 ( TYPE_1 < ? > message ) { <START> return super . METHOD_1 ( message ) && METHOD_2 ( ( TYPE_2 ) message ) ; <END> }
<|startcomment|> approach won t work classes a project a single root package : package org ; import org B ; class A { org B b ; / / noncompliant } package org ; class B { } rely type VAR_1 identifier parent member select parent a member select ( parent ( TYPE_5 VAR_4 ) ) { _CODE_ METHOD_3 = ( ( TYPE_4 ) parent ) METHOD_3 ( ) ; ( METHOD_3 ( TYPE_5 VAR_4 ) && ! ( ( TYPE_4 ) METHOD_3 ) identifier ( ) VAR_1 ( ) _CODE_ ( ) ) { return ; } METHOD_4 ( parent String format ( VAR_5 VAR_1 ( ) ) ) ; VAR_6 add ( parent ) ; } <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 . METHOD_2 ( ) ) { TYPE_3 parent = VAR_2 . parent ( ) ; <START> if ( parent . is ( TYPE_5 . VAR_4 ) && ( ( TYPE_4 ) parent ) . METHOD_3 ( ) . is ( TYPE_5 . VAR_4 ) ) { <END> METHOD_4 ( parent , String . format ( VAR_5 , VAR_1 . name ( ) ) ) ; VAR_6 . add ( parent ) ; } } }
<|startcomment|> doesn t work create a method _CODE_ ? code lines beginning test class <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> if ( ! VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( STRING_1 ) ) ) { <END> VAR_1 . METHOD_4 ( STRING_2 ) ; } TYPE_1 VAR_2 = TYPE_2 . METHOD_5 ( ) . METHOD_6 ( TYPE_1 . class , STRING_3 , INT_1 ) ; assertNotNull ( VAR_2 ) ; }
<|startcomment|> lambdas <|endcomment|> private TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = <START> new TYPE_1 ( ) { <END> @Override public void METHOD_2 ( TYPE_2 event ) { METHOD_3 ( event ) ; } } ; } return VAR_1 ; }
<|startcomment|> super VAR_2 field protected remove ? a protected _CODE_ ( ) method <|endcomment|> public TYPE_3 ( ANNOTATION_1 TYPE_1 VAR_2 , ANNOTATION_1 TYPE_2 in ) { <START> super ( VAR_2 , in ) ; this . VAR_2 = VAR_2 ; <END> }
<|startcomment|> pass null instead new HashMap < String TYPE_4 > ( ) <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { TYPE_2 VAR_3 = new TYPE_3 ( VAR_1 ) ; <START> VAR_3 = METHOD_2 ( VAR_2 , VAR_3 , new HashMap < String , TYPE_4 > ( ) ) ; <END> if ( VAR_3 == null ) { return null ; } TYPE_1 result = VAR_3 . METHOD_3 ( ) ; return result ; }
<|startcomment|> i don t redeclaring type side needed <|endcomment|> private Set < TYPE_1 > METHOD_1 ( ) { Set < TYPE_1 > VAR_1 = <START> new HashSet < TYPE_1 > ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> VAR_1 . METHOD_4 ( VAR_2 . METHOD_5 ( METHOD_2 ( ) . getId ( ) ) ) ; return VAR_1 ; }
<|startcomment|> eeek eatin exceptions <|endcomment|> static void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 ) throws TYPE_2 { try { TYPE_3 . METHOD_1 ( new TYPE_4 ( ) . getClass ( ) . METHOD_2 ( VAR_1 ) , VAR_2 ) ; } catch ( IOException e ) { <START> <END> } }
<|startcomment|> stream ? entrySet iterable <|endcomment|> public void METHOD_1 ( long VAR_1 ) { <START> VAR_2 . entrySet ( ) . stream ( ) . forEach ( e <END> - > { TYPE_1 . METHOD_2 ( e . getKey ( ) ) . METHOD_3 ( e . getValue ( ) , VAR_1 ) ; } ) ; }
<|startcomment|> please invert condition <|endcomment|> public boolean hasNext ( ) { <START> if ( next == null ) { <END> METHOD_1 ( ) ; if ( iterator . VAR_1 ( ) ) { next = new TYPE_3 . TYPE_4 ( VAR_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( iterator . key ( ) ) , VAR_3 ) , VAR_2 . METHOD_2 ( TYPE_2 . METHOD_3 ( iterator . value ( ) ) , VAR_3 ) ) ; iterator . next ( ) ; } else { iterator . close ( ) ; } } return next != null ; }
<|startcomment|> missing braces <|endcomment|> public int run ( ) throws IOException { int b ; if ( in != null ) { <START> while ( ( b = in . read ( ) ) != - 1 ) out . write ( b ) ; <END> in . close ( ) ; } out . close ( ) ; return - 1 ; }
<|startcomment|> a voided field cohort_member table ? theory members don t removed set need update TYPE_1 _CODE_ ( ) set stop date instead removing means METHOD_1 ( ) return cohorts patient current date i e members stop date _CODE_ current date date current date <|endcomment|> public List < TYPE_1 > METHOD_1 ( Integer VAR_1 ) throws TYPE_2 { return ( List < TYPE_1 > ) VAR_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) <START> . add ( TYPE_3 . METHOD_4 ( STRING_1 , false ) ) <END> . METHOD_5 ( STRING_2 , STRING_3 ) . METHOD_5 ( STRING_4 , STRING_5 ) . add ( TYPE_3 . METHOD_4 ( STRING_6 , VAR_1 ) ) . list ( ) ; }
<|startcomment|> succeed VAR_3 METHOD_2 ( ) isn t called ( VAR_2 null ) <|endcomment|> protected void METHOD_1 ( final TYPE_1 < String , Object > VAR_1 ) throws TYPE_2 { try { if ( VAR_2 != null ) { VAR_3 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; } <START> VAR_3 . METHOD_4 ( METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) ) ; <END> } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } }
<|startcomment|> VAR_4 length consistency _CODE_ long METHOD_1 ( ) { long VAR_1 = 0 ; ( int i = 0 ; i < VAR_4 length ; i + + ) { VAR_1 + = VAR_4 [ i ] METHOD_1 ( ) ; } return VAR_1 ; } <|endcomment|> public long METHOD_1 ( ) { long VAR_1 = 0 ; <START> int VAR_2 = VAR_3 . METHOD_2 ( ) ; <END> for ( int i = 0 ; i < VAR_2 ; i ++ ) { VAR_1 += VAR_4 [ i ] . METHOD_1 ( ) ; } return VAR_1 ; }
<|startcomment|> replace ( model ) ; <|endcomment|> public TYPE_2 ( String name , double value , TYPE_1 model ) { <START> super ( name , model ) ; this . VAR_2 = value ; this . VAR_3 = value ; <END> }
<|startcomment|> I d expect other version a WAN version I m thinking subclassing version create _CODE_ _CODE_ - compare / sort versions properly - validate set a cluster version t replaced a WAN version ( checking sign bit ) vice - versa WDYT <|endcomment|> public void METHOD_1 ( ) { assertTrue ( TYPE_1 . METHOD_1 ( of ( 2 , 0 ) ) ) ; METHOD_2 ( TYPE_1 . METHOD_1 ( of ( 3 , 0 ) ) ) ; METHOD_2 ( TYPE_1 . METHOD_1 ( of ( 4 , 0 ) ) ) ; assertTrue ( TYPE_1 . METHOD_1 ( TYPE_2 ) ) ; <START> assertTrue ( TYPE_2 . METHOD_1 ( VAR_1 ) ) ; <END> }
<|startcomment|> I I I feel including STRING_1 <|endcomment|> private String METHOD_1 ( String VAR_1 ) { String VAR_2 = "" ; String [ ] VAR_3 = VAR_1 . split ( STRING_1 ) ; for ( String line : VAR_3 ) { VAR_2 = VAR_2 + STRING_1 + line ; if ( line . contains ( STRING_2 ) ) { break ; } } return VAR_2 ; <START> } <END>
<|startcomment|> stackable armo ( u ) r <|endcomment|> public TYPE_5 ( TYPE_1 VAR_2 , int VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 ) { super ( VAR_2 , VAR_3 , VAR_4 ) ; METHOD_1 ( true ) ; <START> this . VAR_6 = INT_1 ; <END> this . VAR_5 = VAR_5 ; TYPE_4 . VAR_8 . put ( VAR_5 , this ) ; }
<|startcomment|> I don t understand VAR_1 ( ) higher equal config VAR_2 won t store shutting / shut <|endcomment|> private void METHOD_1 ( ) { <START> if ( VAR_1 . METHOD_2 ( 0 ) >= config . VAR_2 ) { <END> logger . info ( STRING_1 , VAR_3 ) ; } }
<|startcomment|> INT_1 a constant <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 context ) { <START> TYPE_3 VAR_1 = new TYPE_3 ( context ) ; <END> TYPE_1 VAR_2 = VAR_1 . create ( ) ; VAR_2 . METHOD_2 ( INT_1 ) ; VAR_2 . METHOD_3 ( STRING_1 ) ; VAR_2 . METHOD_4 ( VAR_3 ) ; VAR_2 . METHOD_5 ( TYPE_4 . VAR_5 ) ; VAR_2 . METHOD_6 ( Boolean . VAR_6 ) ; VAR_2 . METHOD_7 ( VAR_7 ) ; return VAR_2 ; }
<|startcomment|> WARN some exception thrown ? instead logging ip incorrect validation done _CODE_ method validated earlier <|endcomment|> private void METHOD_1 ( ) throws TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 { if ( client == null ) { LOG . info ( STRING_1 + configuration . VAR_1 ( ) ) ; if ( configuration . VAR_2 ( ) != null && ! configuration . VAR_2 ( ) . isEmpty ( ) ) { client = METHOD_2 ( ) ; } else { <START> LOG . info ( STRING_2 ) ; <END> } } }
<|startcomment|> shouldn t message size <|endcomment|> protected String METHOD_1 ( int size ) { <START> return TYPE_1 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; <END> }
<|startcomment|> VAR_1 forEach <|endcomment|> public static Map < Guid , List < TYPE_1 > > METHOD_1 ( List < TYPE_1 > VAR_1 ) { Map < Guid , List < TYPE_1 > > VAR_2 = new HashMap < > ( ) ; <START> VAR_1 . stream ( ) . forEach ( VAR_3 <END> - > TYPE_2 . METHOD_2 ( VAR_3 . getId ( ) , VAR_3 , VAR_2 ) ) ; VAR_2 . values ( ) . forEach ( TYPE_3 : : METHOD_3 ) ; return VAR_2 ; }
<|startcomment|> contract return method ? state move METHOD_1 successful ( i e true ) <|endcomment|> protected boolean METHOD_1 ( TYPE_1 to ) { if ( state . get ( ) == to ) { <START> return false ; <END> } return METHOD_1 ( state . get ( ) , to ) ; }
<|startcomment|> - resources <|endcomment|> public void METHOD_1 ( TYPE_1 file ) throws TYPE_2 , IOException { TYPE_3 out = path . out ( ) ; try { TYPE_4 . write ( VAR_1 , out ) ; } finally { out . close ( ) ; <START> } <END> }
<|startcomment|> class abstract constructor protected <|endcomment|> <START> public TYPE_2 ( String VAR_2 , TYPE_1 VAR_3 ) { <END> super ( ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; }
<|startcomment|> approach root collections VAR_9 - collections / resources NPE ll need inject runtime resource <|endcomment|> private void METHOD_1 ( final TYPE_1 resource ) { resource . VAR_1 ( VAR_2 ) ; resource . VAR_3 ( VAR_4 ) ; resource . VAR_5 ( VAR_6 ) ; if ( resource instanceof TYPE_2 ) { ( ( TYPE_2 ) resource ) . METHOD_2 ( VAR_7 ) ; } else if ( resource instanceof TYPE_3 ) { ( ( TYPE_4 ) resource ) . METHOD_2 ( VAR_7 ) ; } <START> resource . VAR_8 ( VAR_9 ) ; <END> VAR_10 . add ( resource ) ; }
<|startcomment|> VAR_1 atomic <|endcomment|> public boolean isEmpty ( ) { <START> synchronized ( VAR_1 ) <END> { return VAR_1 . size ( ) == 0 ; } }
<|startcomment|> need sequence number wrap account alternatively unconditionally set VAR_2 prevent VAR_2 set VAR_1 set I don t adding kind logic setters d a _CODE_ ( ) method <|endcomment|> void METHOD_1 ( int VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( this . VAR_1 > this . VAR_2 ) <END> { this . VAR_2 = this . VAR_1 ; } }
<|startcomment|> VAR_1 METHOD_2 ( null ) instead done patch set 2 <|endcomment|> public void METHOD_1 ( ) { <START> this . VAR_1 . METHOD_2 ( null ) ; <END> this . VAR_1 = null ; this . VAR_2 = null ; }
<|startcomment|> a couple questions : - t return true ? - configure multiple directory providers <|endcomment|> public boolean METHOD_1 ( ) { TYPE_1 properties = properties ( ) ; boolean VAR_1 = false ; boolean VAR_2 = false ; for ( Object VAR_3 : properties . keySet ( ) ) { String key = ( String ) VAR_3 ; if ( key . VAR_4 ( VAR_5 ) ) { if ( properties . get ( key ) . equals ( VAR_6 ) ) { VAR_1 = true ; } else { <START> VAR_2 = true ; <END> } } } boolean VAR_7 = VAR_1 && ! VAR_2 ; return ! VAR_7 ; }
<|startcomment|> move line method optimization <|endcomment|> public boolean METHOD_1 ( final TYPE_1 resource , final TYPE_2 VAR_1 ) throws TYPE_3 { final TYPE_4 item = METHOD_2 ( resource ) ; if ( ! resource . VAR_2 ( ) ) { throw new TYPE_3 ( STRING_1 , resource ) ; <START> } <END> return METHOD_3 ( item , VAR_1 ) ; }
<|startcomment|> < 0 ? isnt Integer null ? ( other fields vm dynamic ) <|endcomment|> public String METHOD_1 ( ) { <START> if ( VAR_1 < 0 ) { <END> return TYPE_1 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; } else { return String . valueOf ( VAR_1 ) ; } }
<|startcomment|> I slightly darker manually page subtle I didn t <|endcomment|> public void METHOD_1 ( int i , float v , int VAR_1 ) { if ( VAR_2 . METHOD_2 ( ) != 0 ) { VAR_3 . METHOD_3 ( ) ; } if ( VAR_2 . METHOD_2 ( ) == VAR_4 ) { VAR_5 . METHOD_4 ( View . VAR_6 ) ; <START> METHOD_5 ( ) . METHOD_6 ( R . id . VAR_7 ) . METHOD_7 ( VAR_8 . METHOD_8 ( ) <END> . METHOD_9 ( ) . METHOD_10 ( R . VAR_9 . VAR_10 ) ) ; } }
<|startcomment|> exception thrown wrap VAR_1 close ( ) a - finally block guarantee resources properly closed <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( url ) ; boolean VAR_2 = false ; while ( ! VAR_2 ) { TYPE_2 VAR_3 = VAR_1 . METHOD_2 ( 0 ) ; VAR_2 = VAR_3 . METHOD_3 ( ) ; } <START> VAR_1 . close ( ) ; <END> }
<|startcomment|> aren t set logging properties <|endcomment|> private static void METHOD_1 ( Map < String , Object > args ) throws IOException { String VAR_1 = ( String ) args . get ( STRING_1 ) ; Logger logger = Logger . VAR_2 ( "" ) ; logger . VAR_3 ( ( Level ) args . get ( STRING_2 ) ) ; logger . VAR_4 ( new TYPE_1 ( ) ) ; if ( VAR_1 != null ) { TYPE_2 VAR_5 = new TYPE_2 ( VAR_1 ) ; VAR_5 . METHOD_2 ( new TYPE_3 ( ) ) ; logger . VAR_4 ( VAR_5 ) ; <START> } <END> }
<|startcomment|> I = = instead equals TYPE_1 don t implement equals super slow ( compare big files contents ) need put = = null anymore input null <|endcomment|> public TYPE_1 set ( TYPE_1 VAR_1 ) { TYPE_1 put = map . put ( VAR_1 . METHOD_1 ( ) , VAR_1 ) ; <START> if ( put == null || ! put . equals ( VAR_1 ) ) { <END> METHOD_2 ( VAR_1 ) ; METHOD_3 ( ) ; } return put ; }
<|startcomment|> final <|endcomment|> <START> public boolean equals ( Object obj ) { <END> if ( obj instanceof TYPE_1 ) { TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return VAR_1 . name . equals ( name ) && VAR_1 . VAR_2 . equals ( VAR_2 ) ; } return false ; }
<|startcomment|> copy a new set user able modify set builder <|endcomment|> TYPE_1 ( Builder builder ) { VAR_2 = builder . VAR_2 ; VAR_3 = builder . VAR_3 ; <START> VAR_4 = Collections . VAR_5 ( builder . VAR_4 ) ; <END> }
<|startcomment|> sense synchronizing a new object meaningless I VAR_2 null want synchronize object final null instead simply clear ( ) dispose <|endcomment|> public void METHOD_1 ( ) { <START> Object VAR_1 = VAR_2 != null ? VAR_2 : new Object ( ) ; <END> synchronized ( VAR_1 ) { VAR_3 = null ; VAR_2 = null ; try { VAR_4 . close ( ) ; } catch ( IOException e ) { } } }
<|startcomment|> VAR_3 isEmpty ( ) <|endcomment|> private void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , String path ) { <START> System . out . println ( VAR_3 . equals ( "" ) <END> ? String . format ( VAR_4 , VAR_1 , VAR_2 , path ) : String . format ( VAR_5 , VAR_1 , VAR_2 , VAR_3 , path ) ) ; }
<|startcomment|> I alternatively move construction service test cases a factory method sets a METHOD_3 function object field call METHOD_1 prevent some other unwanted potential side - effects approach construct services METHOD_3 example service submits a scheduled task I fine safer function proposed <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , ( ) - > VAR_3 ) ; <END> VAR_1 . METHOD_2 ( VAR_2 , new TYPE_2 ( ) ) ; VAR_1 . METHOD_3 ( true ) ; TYPE_3 . METHOD_4 ( ) ; if ( VAR_4 != null ) { VAR_4 . METHOD_3 ( ) ; } }
<|startcomment|> swap left equals avoid _CODE_ equalsIgnoreCase insteadstring_1 equalsIgnoreCase ( VAR_2 ) ; <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { TYPE_2 element = METHOD_2 ( VAR_1 ) ; <START> boolean VAR_4 = VAR_2 . METHOD_3 ( ) . equals ( STRING_1 ) ; <END> TYPE_3 . assertTrue ( new TYPE_4 ( ) . METHOD_4 ( VAR_3 , element , VAR_5 , VAR_4 ) ) ; TYPE_5 . log ( STRING_2 , STRING_3 , true , VAR_5 ) ; return this ; }
<|startcomment|> missing synchronization <|endcomment|> <START> public Set < String > METHOD_1 ( ) { <END> return Collections . VAR_1 ( VAR_2 ) ; }
<|startcomment|> shouldn t necessary anymore _CODE_ METHOD_2 ( ) trigger event listener more VAR_1 detected modified means drop METHOD_3 ( ) call <|endcomment|> public void METHOD_1 ( ) throws IOException { VAR_1 . METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> if ( ! METHOD_4 ( ) ) METHOD_5 ( ) ; }
<|startcomment|> LB impls ( base version ) deprecating METHOD_2 ( boolean ) preferable move code logic _CODE_ ( ) _CODE_ ( ) defer METHOD_2 ( boolean ) call METHOD_1 _CODE_ based boolean <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> return METHOD_2 ( true ) ; <END> }
<|startcomment|> throw _CODE_ storage domain attached storage pool <|endcomment|> protected Guid METHOD_1 ( ) { <START> return METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( ) ) . get ( 0 ) . getId ( ) ; <END> }
<|startcomment|> returning Integer instead plain int <|endcomment|> <START> private Integer METHOD_1 ( String group ) { <END> if ( group . equalsIgnoreCase ( TYPE_3 . TYPE_5 . toString ( ) ) ) { return R . VAR_1 . VAR_2 ; } else if ( group . equalsIgnoreCase ( TYPE_3 . TYPE_4 . toString ( ) ) ) { return R . VAR_1 . VAR_3 ; } else { return R . VAR_1 . empty ; } }
<|startcomment|> TODO changed line reason a multi list change return multiple values <|endcomment|> public Iterator < TYPE_1 > METHOD_1 ( int VAR_1 ) throws IOException { METHOD_2 ( VAR_1 ) ; <START> return Collections . VAR_2 ( METHOD_3 ( VAR_1 ) ) . iterator ( ) ; <END> }
<|startcomment|> readability i sort methods METHOD_1 - > _CODE_ - > _CODE_ - > flush please order private methods : method a private method - > private method <|endcomment|> <START> public void METHOD_1 ( int VAR_1 ) <END> { VAR_2 = METHOD_2 ( VAR_2 , VAR_1 ) ; this . VAR_1 = 0 ; }
<|startcomment|> VAR_1 substring ( 0 1 ) <|endcomment|> public static TYPE_1 METHOD_1 ( final String VAR_1 ) { if ( ! VAR_1 . isEmpty ( ) ) <START> for ( final Entry < String , TYPE_1 > VAR_2 : VAR_3 . METHOD_2 ( VAR_1 , true , VAR_1 . substring ( 0 , 1 ) , true ) . entrySet ( ) ) <END> if ( VAR_1 . startsWith ( VAR_2 . getKey ( ) ) ) return VAR_2 . getValue ( ) ; return VAR_4 ; }
<|startcomment|> redundant question : _CODE_ warning s ? turn <|endcomment|> public synchronized void close ( ) { if ( VAR_1 ) { return ; } VAR_1 = true ; <START> if ( VAR_2 != null ) { <END> VAR_2 . METHOD_1 ( - VAR_3 ) ; } VAR_3 = 0 ; }
<|startcomment|> change unneeded unchecked removed <|endcomment|> <START> public Map < TYPE_1 , TYPE_2 > METHOD_1 ( ) { <END> return ( Map < TYPE_1 , TYPE_2 > ) VAR_1 ; }
<|startcomment|> changing expectation related production code changed ? events ( modification modification 2 ) please note test platform dependent targetting linux CI reports issues flakes test OS running tests ? CI build : <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 . write ( VAR_1 . METHOD_2 ( ) , STRING_1 . METHOD_3 ( ) , TYPE_3 . VAR_3 ) ; Thread . VAR_4 ( INT_1 ) ; TYPE_1 . write ( VAR_1 . METHOD_2 ( ) , STRING_2 . METHOD_3 ( ) , TYPE_3 . VAR_3 ) ; TYPE_2 VAR_5 = METHOD_4 ( STRING_3 ) ; <START> VAR_5 . METHOD_5 ( 1 ) ; <END> VAR_5 . METHOD_6 ( INT_2 ) ; VAR_5 . METHOD_7 ( ) ; }
<|startcomment|> isn t VAR_2 checking null <|endcomment|> private boolean METHOD_1 ( String value ) { boolean VAR_1 = false ; <START> if ( value != null && StringUtils . VAR_2 ( value ) ) { <END> int VAR_3 = value . length ( ) - 1 ; if ( TYPE_1 . METHOD_2 ( value . VAR_4 ( 0 ) ) ) { VAR_1 = true ; } else if ( TYPE_1 . METHOD_2 ( value . VAR_4 ( VAR_3 ) ) ) { VAR_1 = true ; } } else { VAR_1 = false ; } return VAR_1 ; }
<|startcomment|> block shortened VAR_1 METHOD_4 ( VAR_2 METHOD_3 ( TYPE_3 VAR_4 ) ) <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( VAR_2 ) ; <START> if ( VAR_2 . METHOD_3 ( TYPE_3 . VAR_4 ) ) { <END> VAR_1 . METHOD_4 ( true ) ; } else { VAR_1 . METHOD_4 ( false ) ; } VAR_1 . METHOD_5 ( VAR_5 ) ; METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; TYPE_2 file = METHOD_6 ( ) . METHOD_8 ( VAR_2 ) ; if ( file != null ) { file . VAR_6 ( true ) ; METHOD_6 ( ) . METHOD_9 ( file ) ; } }
<|startcomment|> propagated exception logged ? result logging <|endcomment|> protected void METHOD_1 ( boolean VAR_1 ) { try { METHOD_2 ( ) ; VAR_2 . start ( VAR_1 ) ; } catch ( IOException e ) { <START> LOG . error ( STRING_1 , e ) ; <END> throw TYPE_1 . METHOD_3 ( e ) ; } }
<|startcomment|> default constructor assign null VAR_2 <|endcomment|> <START> public TYPE_2 ( ) { <END> VAR_2 = TYPE_1 . METHOD_1 ( ) == null ? new TYPE_1 ( ) : TYPE_1 . METHOD_1 ( ) ; }
<|startcomment|> helper setting common options <|endcomment|> public static TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = <END> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_3 . METHOD_5 ( TYPE_7 . VAR_3 ) ) . METHOD_6 ( TYPE_4 . METHOD_7 ( TYPE_3 . METHOD_8 ( TYPE_7 . VAR_4 , TYPE_5 . class ) ) ) . build ( ) ; return TYPE_1 . METHOD_9 ( ) . METHOD_10 ( VAR_1 ) . METHOD_11 ( TYPE_4 . METHOD_7 ( TYPE_3 . METHOD_8 ( TYPE_7 . VAR_5 , TYPE_6 . class ) ) ) . build ( ) ; }
<|startcomment|> small typo - I supposed VAR_3 <|endcomment|> TYPE_3 ( final String name , final TYPE_1 VAR_2 , final TYPE_2 VAR_3 ) { METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_2 = VAR_2 ; METHOD_1 ( name , STRING_2 ) ; this . name = name ; <START> METHOD_1 ( name , STRING_3 ) ; <END> this . VAR_3 = VAR_3 ; }
<|startcomment|> s state class s invalid s parameter relevant exception a case _CODE_ <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 ; switch ( VAR_1 ) { case VAR_3 : VAR_2 = TYPE_2 . getString ( STRING_1 ) ; break ; case VAR_4 : VAR_2 = TYPE_2 . getString ( STRING_2 ) ; break ; case VAR_5 : VAR_2 = TYPE_2 . getString ( STRING_3 ) ; break ; case VAR_6 : VAR_2 = TYPE_2 . getString ( STRING_4 ) ; break ; default : <START> throw new IllegalStateException ( ) ; <END> } return VAR_2 ; }
<|startcomment|> please add overloaded constructor comparibility ( _CODE_ ( boolean ) ) <|endcomment|> <START> public TYPE_2 ( boolean VAR_2 , TYPE_1 VAR_3 , boolean VAR_4 ) { <END> this . VAR_2 = VAR_2 ? Boolean . VAR_5 : null ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ? Boolean . VAR_5 : null ; }
<|startcomment|> ÏÇ¨ÏÜåÌïú Í±∞Í∏¥ ÌïòÏßÄÎßåif ( a ) { } a { } Í∞Ä ÎêòÏßÄ ÏïäÎèÑÎ°ù ÏàúÏÑúÎ•º Î≥ÄÍ≤ΩÌï¥ Ï£ºÏÑ∏Ïöî <|endcomment|> public static TYPE_1 METHOD_1 ( Long VAR_1 ) { if ( TYPE_2 . METHOD_2 ( session ( ) . get ( STRING_1 ) ) . METHOD_3 ( ) ) { <START> if ( ! TYPE_3 . METHOD_4 ( VAR_1 ) ) { <END> TYPE_2 . VAR_2 . METHOD_5 ( VAR_1 ) . METHOD_6 ( ) ; } else { METHOD_7 ( Constants . VAR_3 , STRING_2 ) ; } } else { METHOD_7 ( Constants . VAR_3 , STRING_3 ) ; } return METHOD_8 ( TYPE_5 . TYPE_6 . METHOD_9 ( 0 , null ) ) ; }
<|startcomment|> I annotated nonnull assertion s leave <|endcomment|> public TYPE_3 ( ANNOTATION_1 TYPE_1 uri , ANNOTATION_1 String VAR_2 , long VAR_3 , ANNOTATION_2 String VAR_4 ) { <START> if ( VAR_3 < 0 ) { <END> throw new TYPE_2 ( STRING_1 ) ; } this . uri = uri ; this . VAR_4 = VAR_4 ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; }
<|startcomment|> work : VAR_1 add ( new TYPE_2 ( config VAR_3 ) ) ; save a line declaring a VAR_2 object <|endcomment|> private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; TYPE_2 VAR_2 = new TYPE_2 ( config , VAR_3 ) ; <START> VAR_1 . add ( VAR_2 ) ; <END> if ( config . VAR_4 ( ) ) { VAR_1 . add ( new TYPE_3 ( config , VAR_3 ) ) ; } return ImmutableList . VAR_5 ( VAR_1 ) ; }
<|startcomment|> log trace <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { <START> log . info ( STRING_1 ) ; <END> VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> a part java spec I m familiar ( ( VAR_2 ? 1 : 0 ) ^ ) < 0 VAR_2 ^ ( < 0 ) <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { for ( Integer value : VAR_1 . METHOD_2 ( ) . values ( ) ) { <START> if ( VAR_2 ^ value < 0 ) { <END> return false ; } } return VAR_1 . METHOD_3 ( ) >= 0 ; }
<|startcomment|> unroll new configurable method instead <|endcomment|> private void METHOD_1 ( TYPE_1 db ) { <START> db . VAR_1 ( TYPE_2 . of ( TYPE_3 . class , STRING_1 , TYPE_3 : : getId ) ) ; <END> db . VAR_2 ( new TYPE_4 ( ) ) ; }
<|startcomment|> shouldn t return false VAR_2 = false ? parameter sounds message needed give correct return <|endcomment|> protected boolean METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { TYPE_2 server = METHOD_2 ( ) . get ( VAR_1 . METHOD_3 ( ) ) ; <START> if ( ( server == null || ! server . VAR_3 ( ) . equals ( METHOD_4 ( ) ) ) && VAR_2 ) { <END> METHOD_5 ( TYPE_3 . VAR_5 ) ; return false ; } VAR_1 . METHOD_6 ( server . VAR_6 ( ) ) ; return true ; }
<|startcomment|> private <|endcomment|> <START> public static <END> ANNOTATION_1 String METHOD_1 ( String VAR_1 ) { return VAR_1 . substring ( 0 , VAR_1 . METHOD_2 ( CHAR_1 ) ) ; }
<|startcomment|> need type parameter <|endcomment|> private static boolean METHOD_1 ( String text , final Collection < String > VAR_1 ) { final String VAR_2 = text . VAR_3 ( ) ; return VAR_1 . stream ( ) <START> . METHOD_2 ( ( String it ) - > { <END> return VAR_2 . contains ( it ) ; } ) ; }
<|startcomment|> doesn t need else clause more readable invert logic block i e : ( e ! = null ) { throw e ; } TYPE_1 METHOD_4 ( VAR_3 ) ; return TYPE_3 VAR_2 ; <|endcomment|> private void METHOD_1 ( Path file ) throws IOException { TYPE_1 . METHOD_2 ( file , new TYPE_2 < Path > ( ) { @Override public TYPE_3 METHOD_3 ( Path file , TYPE_4 VAR_1 ) throws IOException { TYPE_1 . METHOD_4 ( file ) ; return TYPE_3 . VAR_2 ; } @Override public TYPE_3 METHOD_5 ( Path VAR_3 , IOException e ) throws IOException { if ( e == null ) { TYPE_1 . METHOD_4 ( VAR_3 ) ; return TYPE_3 . VAR_2 ; <START> } else { throw e ; } <END> } } ) ; }
<|startcomment|> VAR_4 start 1 0 ? starts conditional wrong : VAR_4 = 1 VAR_1 = 7 VAR_2 = 5 return false a page <|endcomment|> public Optional < Object > METHOD_1 ( ) { if ( VAR_1 < VAR_2 ) return Optional . VAR_3 ( ) ; <START> if ( VAR_4 < ( VAR_1 / VAR_2 ) ) { <END> return Optional . of ( METHOD_2 ( VAR_4 + 1 ) ) ; } return Optional . VAR_3 ( ) ; }
<|startcomment|> necessary add check ? doesn t _CODE_ prevent login request reaching point <|endcomment|> public void METHOD_1 ( TYPE_1 context , TYPE_2 user ) { <START> if ( user == null || user . VAR_1 ( ) != null ) { <END> METHOD_2 ( context ) ; context . VAR_2 ( ) . error ( TYPE_3 . VAR_4 ) ; Response VAR_5 = METHOD_3 ( context , METHOD_4 ( context ) ) ; context . VAR_6 ( TYPE_4 . VAR_8 , VAR_5 ) ; } }
<|startcomment|> missing argument view actual exception message / stack trace : file : + VAR_3 e ) <|endcomment|> public boolean METHOD_1 ( ) { if ( StringUtils . VAR_1 ( VAR_2 ) ) { try { return TYPE_1 . METHOD_2 ( VAR_2 , new TYPE_2 ( VAR_3 ) ) ; } catch ( IOException e ) { <START> throw new TYPE_3 ( STRING_1 + VAR_3 ) ; <END> } catch ( TYPE_4 e ) { throw new TYPE_3 ( STRING_2 + VAR_2 , e ) ; } } return true ; }
<|startcomment|> avoid VAR_5 cluster manager trust list modified <|endcomment|> public TYPE_2 ( String VAR_2 , List < TYPE_1 > VAR_3 ) { this . VAR_2 = VAR_2 ; if ( VAR_3 == null || VAR_3 . isEmpty ( ) ) { this . VAR_3 = Collections . VAR_4 ( ) ; } else { <START> this . VAR_3 = Collections . VAR_5 ( VAR_3 ) ; <END> } }
<|startcomment|> I remove variables return new TYPE_2 ( true VAR_3 ) ; applied other methods <|endcomment|> public TYPE_1 METHOD_1 ( boolean VAR_1 , int VAR_2 ) { if ( VAR_2 == 1 ) { <START> TYPE_2 result = <END> new TYPE_2 ( true , VAR_3 ) ; return result ; } else if ( VAR_2 > 0 ) { TYPE_3 ctx = new TYPE_3 ( VAR_2 , true , VAR_3 ) ; return ctx ; } return METHOD_1 ( null ) ; }
<|startcomment|> remove unnecessary final modifier local variables modified classes <|endcomment|> private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { boolean VAR_2 = true ; if ( VAR_3 != null ) { <START> for ( final TYPE_2 VAR_4 : VAR_3 ) { <END> final boolean VAR_5 = VAR_4 . matcher ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( ) ; if ( VAR_5 ) { VAR_2 = false ; break ; } } } return VAR_2 ; }
<|startcomment|> remove instead <|endcomment|> public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { TYPE_2 VAR_3 = VAR_4 . get ( VAR_2 ) ; if ( VAR_3 != null ) { List < TYPE_3 > VAR_5 = VAR_3 . METHOD_2 ( ) ; for ( TYPE_3 VAR_6 : VAR_5 ) { VAR_7 . remove ( VAR_6 . getId ( ) ) ; } } <START> VAR_4 . put ( VAR_2 , <END> null ) ; } }
<|startcomment|> needs VAR_1 + 1 parameter _length_ VAR_1 _index_ <|endcomment|> public void METHOD_1 ( int VAR_1 ) { if ( VAR_1 >= VAR_2 . length ) { <START> VAR_2 = Arrays . VAR_3 ( VAR_2 , max ( VAR_2 . length * 2 , VAR_1 ) ) ; <END> } VAR_2 [ VAR_1 ] ++ ; if ( VAR_1 > VAR_4 ) { VAR_4 = VAR_1 ; } }
<|startcomment|> s / n / / n index <|endcomment|> private static void METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 ) { for ( TYPE_1 c : VAR_2 ) { TYPE_2 id = c . VAR_3 ( ) ; String <START> n = <END> c . VAR_4 ( ) ; VAR_1 . add ( new TYPE_1 ( id , TYPE_2 . METHOD_2 ( ) , n ) ) ; } }
<|startcomment|> argument version METHOD_1 argument passed <|endcomment|> public TYPE_7 ( TYPE_1 monitor ) { this . monitor = <START> TYPE_2 . METHOD_1 ( monitor , <END> VAR_2 ) ; VAR_3 = ( TYPE_3 ) TYPE_4 . METHOD_2 ( ) ; VAR_4 = false ; String msg = Messages . VAR_5 ; VAR_6 = new TYPE_5 ( TYPE_4 . VAR_7 , TYPE_6 . VAR_9 , msg , null ) ; }
<|startcomment|> default ? I agree nice ( surely BV 1 2 ) spec [ describes ] ( ) arg0 arg1 default names I feel stick <|endcomment|> private TYPE_9 ( ) { this . VAR_2 = new TYPE_1 ( ) ; this . VAR_3 = new TYPE_2 ( TYPE_3 . VAR_4 ) ; this . VAR_5 = new TYPE_4 ( ) ; this . VAR_6 = new TYPE_5 ( ) ; if ( TYPE_6 . METHOD_1 ( ) >= INT_1 ) { <START> this . VAR_7 = new TYPE_7 ( ) ; <END> } else { this . VAR_7 = new TYPE_8 ( ) ; } this . VAR_8 = new TYPE_3 ( VAR_3 ) ; }
<|startcomment|> need declare object assign null ? remove <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> TYPE_2 VAR_2 = new TYPE_2 ( ) ; <END> VAR_1 = null ; VAR_2 = null ; METHOD_2 ( VAR_3 . METHOD_3 ( VAR_1 ) ) ; METHOD_2 ( VAR_3 . METHOD_4 ( VAR_2 ) ) ; }
<|startcomment|> cruft doesn t matter unused variable <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> boolean VAR_1 = false ; <END> Context ctx = METHOD_2 ( VAR_2 , VAR_3 ) ; TYPE_1 VAR_4 = ( TYPE_1 ) ctx . VAR_5 ( STRING_1 ) ; Assert . assertNotNull ( STRING_2 , VAR_4 ) ; Assert . assertTrue ( STRING_3 , TYPE_2 . METHOD_3 ( VAR_6 , VAR_7 , STRING_1 ) ) ; }
<|startcomment|> remove <|endcomment|> public TYPE_2 ( final T VAR_2 , final TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_4 = true ; this . VAR_5 = true ; this . VAR_6 = true ; this . VAR_7 = true ; this . VAR_3 = VAR_3 ; this . VAR_8 = 0 ; <START> ; <END> }
<|startcomment|> please change ternary <|endcomment|> public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { if <START> ( VAR_2 ) <END> { return TYPE_1 . TYPE_3 ; } return TYPE_1 . TYPE_2 ; } return VAR_1 ; }
<|startcomment|> need METHOD_6 METHOD_7 ( String VAR_5 ) implicit METHOD_8 ( STRING_1 ) <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) ) ; try ( TYPE_2 VAR_2 = TYPE_2 . builder ( VAR_1 ) . build ( ) ) { VAR_2 . METHOD_3 ( STRING_1 ) ; TYPE_3 VAR_3 = METHOD_4 ( VAR_2 ) ; assertThat ( VAR_3 . METHOD_5 ( VAR_4 ) . get ( ) ) . METHOD_6 ( ) . METHOD_7 ( String . VAR_5 ) <START> . METHOD_8 ( STRING_1 ) ; <END> } }
<|startcomment|> null pointer <|endcomment|> public String [ ] METHOD_1 ( ANNOTATION_1 TYPE_1 entry ) { String [ ] VAR_1 = new <START> String [ VAR_2 . length ] ; <END> for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { VAR_1 [ i ] = VAR_3 . METHOD_2 ( entry , i ) ; } return VAR_1 ; }
<|startcomment|> private <|endcomment|> protected TYPE_1 ( ) { <START> } <END>
<|startcomment|> import class Messages <|endcomment|> public TYPE_6 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final List < TYPE_3 > VAR_4 , final List < TYPE_4 > VAR_5 ) { super ( VAR_2 ) ; this . VAR_6 = TYPE_5 . METHOD_1 ( VAR_3 ) ; this . VAR_7 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> METHOD_2 ( org . VAR_8 . VAR_9 . VAR_10 . VAR_11 . VAR_12 . Messages . TYPE_7 ) ; <END> }
<|startcomment|> VAR_4 redundant VAR_2 <|endcomment|> public void execute ( final TYPE_1 VAR_1 ) throws IOException { int VAR_2 = this . index ( VAR_1 ) ; for ( final TYPE_2 VAR_3 : VAR_1 . METHOD_1 ( ) ) { <START> final int VAR_4 = VAR_2 + 1 ; <END> VAR_3 . METHOD_2 ( new TYPE_3 ( ) . METHOD_3 ( STRING_1 ) . METHOD_4 ( STRING_2 , Integer . toString ( VAR_4 ) ) ) ; VAR_2 = VAR_4 ; } }
<|startcomment|> good worth protect _CODE_ ( ) _CODE_ ( ) ll throw _CODE_ VAR_1 empty <|endcomment|> public long METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> assert ( ! VAR_1 . isEmpty ( ) ) ; return METHOD_2 ( VAR_1 . METHOD_3 ( ) . iterator ( ) . next ( ) ) ; } }
<|startcomment|> necessary set ? wouldnt sufficient done layout test <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( VAR_1 ) ; VAR_2 . METHOD_3 ( 0 ) ; VAR_3 = 0 ; VAR_4 = 1 ; VAR_5 = 2 ; VAR_6 . METHOD_4 ( null ) ; <START> METHOD_5 ( R . id . VAR_7 , VAR_4 , VAR_8 ) ; <END> METHOD_5 ( R . id . VAR_7 , VAR_5 , VAR_9 ) ; }
<|startcomment|> I don t TYPE_4 necessary necessary method call ( ) conflicts method anonymous class <|endcomment|> public TYPE_1 list ( ) { return new TYPE_1 ( ) { @Override public List < TYPE_2 > get ( ) throws TYPE_3 { <START> return TYPE_4 . this . list ( this ) ; <END> } } ; }
<|startcomment|> potential NPE entity NULL <|endcomment|> <START> public void METHOD_1 ( TYPE_1 entity ) { <END> TYPE_2 . METHOD_2 ( TYPE_3 . class , entity . VAR_1 ( ) , true ) ; TYPE_2 . METHOD_2 ( TYPE_4 . class , entity . VAR_2 ( ) , false ) ; }
<|startcomment|> preference remove e _CODE_ ( ) altogether error filters determine want log error <|endcomment|> void error ( TYPE_1 e ) { TYPE_2 . METHOD_1 ( ) . METHOD_2 ( e ) ; VAR_1 . error ( ) ; <START> LOG . error ( e . getMessage ( ) , e ) ; <END> }
<|startcomment|> rename element <|endcomment|> private List < String > METHOD_1 ( ) { if ( VAR_1 != null ) { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_2 <START> VAR_3 : <END> VAR_1 ) { if ( VAR_3 instanceof TYPE_1 ) { VAR_2 . add ( ( TYPE_1 ) VAR_3 ) ; } } return TYPE_3 . METHOD_2 ( VAR_2 ) ; } return Collections . VAR_4 ( ) ; }
<|startcomment|> ( _CODE_ NO_RESPONSE ) void return _CODE_ / enable <|endcomment|> <START> public TYPE_1 < ? > METHOD_1 ( ANNOTATION_1 List < Long > VAR_1 ) throws IOException { <END> return METHOD_2 ( VAR_1 , false ) ; }
<|startcomment|> option validators typed : public static final _CODE_ TYPE_1 change line : return options VAR_1 ( TYPE_1 ) ; other option <|endcomment|> public double METHOD_1 ( ) { <START> return options . VAR_1 ( TYPE_1 . METHOD_2 ( ) ) . VAR_2 ; <END> }
<|startcomment|> need copy env ? accessible _CODE_ ( ) _CODE_ ( ) <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_2 . METHOD_1 ( ) ; }
<|startcomment|> IllegalArgumentException <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 session , TYPE_4 VAR_2 , List < Type > VAR_3 , int VAR_4 ) { TYPE_5 VAR_5 = ( TYPE_5 ) VAR_2 ; TYPE_6 VAR_6 = VAR_5 . METHOD_2 ( ) ; switch ( VAR_6 ) { case VAR_7 : return METHOD_3 ( VAR_4 , VAR_5 . METHOD_4 ( ) . get ( ) ) ; case VAR_8 : return METHOD_5 ( VAR_4 , VAR_5 . METHOD_6 ( ) . get ( ) ) ; default : <START> throw new IllegalStateException ( STRING_1 + VAR_6 ) ; <END> } }
<|startcomment|> required render _CODE_ a TESR <|endcomment|> public void METHOD_1 ( TYPE_1 data ) throws IOException { super . METHOD_1 ( data ) ; <START> VAR_1 . METHOD_1 ( data ) ; <END> data . VAR_2 ( VAR_3 . METHOD_2 ( ) ) ; }
<|startcomment|> _smells_ bad reasoning catch TYPE_2 <|endcomment|> protected void METHOD_1 ( final int VAR_1 , final int VAR_2 , final Date value ) { TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( ) . get ( VAR_1 ) . get ( VAR_2 ) ; VAR_3 . METHOD_3 ( value ) ; try { VAR_5 . update ( VAR_4 , METHOD_4 ( VAR_1 , VAR_2 ) ) ; <START> } catch ( TYPE_2 e ) { <END> e . VAR_6 ( ) ; } }
<|startcomment|> suggestion ( ) - > new TYPE_1 < > ( TYPE_4 METHOD_3 ( TYPE_2 : : METHOD_6 ) METHOD_5 ( TYPE_2 : : METHOD_4 ) ) Collectors VAR_3 ( ) ) ) ; <|endcomment|> private TYPE_1 < TYPE_2 , List < TYPE_3 > > METHOD_1 ( List < TYPE_3 > VAR_1 ) { return VAR_1 . stream ( ) . collect ( Collectors . VAR_2 ( TYPE_3 : : METHOD_2 , <START> ( ) - > new TYPE_1 < > ( TYPE_4 . METHOD_3 ( TYPE_2 : : METHOD_4 ) . METHOD_5 ( TYPE_2 : : METHOD_6 ) ) , Collectors . VAR_3 ( ) ) ) ; <END> }
<|startcomment|> 1 set method private 2 create helpers property <|endcomment|> <START> public void METHOD_1 ( String VAR_1 , int VAR_2 ) { <END> METHOD_2 ( table ) ; TYPE_1 . assertEquals ( table . VAR_3 ( VAR_1 ) , Integer . toString ( VAR_2 ) ) ; TYPE_2 . log ( STRING_1 , STRING_2 + VAR_1 + STRING_3 , true ) ; }
<|startcomment|> please post examples content new metadata cache files jira description <|endcomment|> public TYPE_4 ( String [ ] name , TYPE_2 . TYPE_3 VAR_2 , Object VAR_3 , Object VAR_4 , Long VAR_5 ) { <START> this . name = name ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_2 = VAR_2 ; }
<|startcomment|> @Override a line _CODE_ ( ) <|endcomment|> <START> @Override public <END> TYPE_1 METHOD_1 ( int VAR_1 ) throws IOException { VAR_2 . METHOD_2 ( ) ; try { TYPE_2 VAR_3 = VAR_4 . METHOD_3 ( VAR_5 ) ; while ( true ) { if ( ! VAR_3 . next ( ) || VAR_1 < 0 ) { return null ; } if ( VAR_1 == 0 ) { return VAR_3 . METHOD_4 ( ) ; } VAR_1 -- ; } } finally { VAR_2 . METHOD_5 ( ) ; } }
<|startcomment|> bagit folder hidden bagit incubating version bagit spec ; solves a lot problems originial spec <|endcomment|> public void METHOD_1 ( ) throws Exception { VAR_1 = TYPE_1 . get ( getClass ( ) . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) . METHOD_4 ( ) ) ; if ( System . getProperty ( STRING_2 ) . contains ( STRING_3 ) ) { <START> Path VAR_2 = VAR_1 . METHOD_5 ( STRING_4 ) ; <END> TYPE_2 . METHOD_6 ( VAR_2 , STRING_5 , Boolean . VAR_3 ) ; } TYPE_3 VAR_4 = reader . read ( VAR_1 ) ; VAR_5 . METHOD_7 ( VAR_4 , true ) ; }
<|startcomment|> remove final modifiers <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 context , TYPE_3 VAR_1 ) { <START> final TYPE_4 VAR_2 = new TYPE_5 ( context ) ; <END> VAR_1 . METHOD_2 ( VAR_2 ) ; return VAR_2 . VAR_3 ; }
<|startcomment|> breaks compatibility <|endcomment|> <START> TYPE_1 METHOD_1 ( TYPE_2 event ) <END> { return METHOD_2 ( event , TYPE_3 . VAR_2 ) ; }
<|startcomment|> a copy constructor case <|endcomment|> public TYPE_1 ( TYPE_1 m ) { m . VAR_1 ( ) ; this . row = m . row ; this . data = m . data ; <START> this . size = new TYPE_2 ( m . size . VAR_2 , m . size . VAR_3 ) ; <END> this . values = m . values ; this . VAR_4 = m . VAR_4 ; }
<|startcomment|> null interpreted a null flag a null flag [ ] causing some _CODE_ test suite : <|endcomment|> public TYPE_5 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_2 , TYPE_4 VAR_3 ) { <START> this ( VAR_2 , VAR_3 , null , null ) ; <END> }
<|startcomment|> ternary ? true : false ; ) <|endcomment|> default TYPE_1 VAR_2 ( ) { <START> if ( VAR_3 ( ) ) { <END> return VAR_4 ( ) ; } return VAR_5 ( ) ; }
<|startcomment|> a lot calls method resulting VAR_2 reference BPMN element a quick element id reference <|endcomment|> <START> public void METHOD_1 ( String VAR_1 , TYPE_1 element ) { <END> VAR_2 . add ( new TYPE_2 ( VAR_1 , name , element ) ) ; }
<|startcomment|> suggestion : else - provide missing braces instead length ( ) = = 0 I d isEmpty ( ) <|endcomment|> private void METHOD_1 ( ) { String message = null ; if ( VAR_1 . METHOD_2 ( ) . trim ( ) . length ( ) == 0 ) message = Messages . TYPE_1 ; <START> if ( message == null && VAR_3 . METHOD_2 ( ) . trim ( ) . length ( ) == 0 ) <END> message = Messages . TYPE_2 ; METHOD_3 ( message ) ; METHOD_4 ( message == null ) ; }
<|startcomment|> don t want pick _CODE_ chrome chromium ? match : { _CODE_ : chrome STRING_2 : { } } isn t want <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { return TYPE_3 . TYPE_4 . equals ( VAR_1 . METHOD_2 ( ) ) || VAR_1 . METHOD_3 ( STRING_1 ) != null || <START> VAR_1 . METHOD_3 ( STRING_2 ) != null ; <END> }
<|startcomment|> METHOD_3 ( ) null annotate <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return ( TYPE_1 ) TYPE_2 . METHOD_2 ( super . METHOD_3 ( ) ) ; <END> }
<|startcomment|> METHOD_2 ? TYPE_5 filter returns iterable <|endcomment|> public static TYPE_1 < TYPE_2 < ? > > METHOD_1 ( TYPE_3 trace , Class < ? extends TYPE_2 < ? > > VAR_1 ) { return <START> TYPE_4 . METHOD_2 ( TYPE_5 . filter ( TYPE_5 . METHOD_3 ( trace . VAR_2 ( ) , <END> VAR_3 ) , VAR_4 - > VAR_1 . METHOD_4 ( VAR_4 . getClass ( ) ) ) ) ; }
<|startcomment|> _CODE_ a blocked call reason - - I asking general convention presto _CODE_ < TYPE_1 > cases <|endcomment|> public TYPE_1 get ( ) throws InterruptedException { TYPE_1 row ; synchronized ( monitor ) { while ( ! VAR_1 && buffer . isEmpty ( ) ) { <START> monitor . VAR_2 ( ) ; <END> } if ( VAR_1 ) { return null ; } row = buffer . VAR_3 ( ) ; } VAR_4 . METHOD_1 ( - row . VAR_5 ( ) ) ; return row ; }
<|startcomment|> useless clear ( ) resets position zero <|endcomment|> private ByteBuffer METHOD_1 ( int VAR_1 ) throws IOException { ByteBuffer VAR_2 ; VAR_2 = ByteBuffer . VAR_3 ( VAR_1 - TYPE_3 . VAR_5 ) ; <START> VAR_2 . position ( TYPE_3 . VAR_5 ) ; <END> VAR_2 . clear ( ) ; TYPE_1 VAR_6 ; try { VAR_6 = METHOD_2 ( ) ; VAR_6 . read ( VAR_2 ) ; } catch ( TYPE_2 VAR_7 ) { } VAR_2 . METHOD_3 ( ) ; return VAR_2 ; }
<|startcomment|> merge line <|endcomment|> public TYPE_1 METHOD_1 ( ) { VAR_1 . METHOD_2 ( VAR_2 ) ; TYPE_2 VAR_3 = VAR_4 . get ( 0 ) ; TYPE_3 . log ( STRING_1 , VAR_3 . METHOD_3 ( ) , true ) ; TYPE_4 VAR_5 = ( TYPE_4 ) VAR_6 ; TYPE_2 VAR_7 = VAR_3 . METHOD_4 ( TYPE_5 . METHOD_5 ( VAR_8 ) ) ; <START> TYPE_6 VAR_9 = new TYPE_6 ( VAR_6 ) ; <END> VAR_9 . METHOD_6 ( VAR_7 ) . METHOD_7 ( ) ; VAR_5 . METHOD_8 ( STRING_2 , VAR_3 , VAR_8 ) ; return new TYPE_1 ( VAR_6 ) ; }
<|startcomment|> entitlement mode included ? a mode list set owner include ? valid set list entitlements option list empty means set entitlement <|endcomment|> public String METHOD_1 ( ) { String [ ] VAR_1 = VAR_2 == null ? new String [ 0 ] : VAR_2 . split ( STRING_1 ) ; String VAR_3 = "" ; <START> if ( ! TYPE_1 . contains ( VAR_1 , TYPE_2 . VAR_5 ) ) { <END> VAR_3 = VAR_1 . length > 0 ? STRING_1 : "" ; VAR_3 += TYPE_2 . VAR_5 ; } return VAR_1 . length > 0 ? this . VAR_2 + VAR_3 : VAR_3 ; }
<|startcomment|> I remembered failed testing querydls - sql module s <|endcomment|> public void METHOD_1 ( ) { <START> System . VAR_1 ( STRING_1 , STRING_2 ) ; <END> TYPE_1 . METHOD_2 ( null ) ; configuration = TYPE_2 . VAR_3 ; }
<|startcomment|> _CODE_ METHOD_3 ( ) ; _CODE_ = null ; „ÅßËß£Ê±∫„Åô„Çã„Å®ÊÄù„ÅÑ„Åæ„Åô <|endcomment|> public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; try { METHOD_2 ( VAR_1 ) ; <START> VAR_2 . METHOD_3 ( ) ; <END> } catch ( Exception VAR_3 ) { Log . VAR_4 ( TAG , VAR_3 . getMessage ( ) + "" , VAR_3 ) ; } super . METHOD_1 ( ) ; }
<|startcomment|> declare logger top class : javaprivate static final Logger log = Logger ( TYPE_3 class ) ; ( inline Logger ( ) pattern some tests s normal ) <|endcomment|> private static void METHOD_1 ( TYPE_1 context , TYPE_2 VAR_1 , Path path , boolean VAR_2 ) { try { VAR_1 . METHOD_2 ( context , path ) . METHOD_3 ( path , VAR_2 ) ; } catch ( Exception e ) { <START> Logger . get ( TYPE_3 . class ) . warn ( e , STRING_1 + path . toString ( ) ) ; <END> } }
<|startcomment|> private static <|endcomment|> <START> private boolean METHOD_1 ( String s ) <END> { return TYPE_1 . matcher ( s ) . METHOD_2 ( ) ; }
<|startcomment|> readability i prefer a method called _CODE_ determine METHOD_2 <|endcomment|> public long METHOD_1 ( long n ) throws IOException { if ( n <= 0 ) { return 0 ; } if ( n > VAR_1 ) { VAR_2 = 0 ; } else { <START> ( ( TYPE_1 ) in ) . METHOD_2 ( VAR_3 + n ) ; <END> } VAR_3 += n ; return n ; }
<|startcomment|> missing assertNotNull _CODE_ <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = METHOD_2 ( VAR_2 , VAR_3 ) ; <END> METHOD_3 ( VAR_1 , VAR_4 ) ; TYPE_4 VAR_5 = METHOD_4 ( VAR_1 , VAR_6 , TYPE_4 . class ) ; METHOD_5 ( VAR_5 . METHOD_6 ( ) , VAR_7 , VAR_7 ) ; METHOD_7 ( VAR_5 . METHOD_8 ( ) , VAR_7 ) ; }
<|startcomment|> remove reversal JDK 8 implementation return METHOD_4 JDK 9 implementation * * reversed <|endcomment|> private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = TYPE_2 . METHOD_2 ( METHOD_3 ( ) ) ; <START> return ImmutableList . VAR_2 ( TYPE_2 . METHOD_4 ( VAR_1 ) ) ; <END> }
<|startcomment|> point catching exception <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> try { VAR_1 . METHOD_2 ( resource , new TYPE_3 ( "" , VAR_2 ) ) ; } catch ( TYPE_2 e ) { throw e ; } <END> }
<|startcomment|> method private <|endcomment|> <START> void METHOD_1 ( ) <END> { reader . VAR_1 ( VAR_2 <= VAR_3 ? VAR_4 : VAR_5 ) ; }
<|startcomment|> imperative template : shouldn t deprecate methods introduce TYPE_3 < TYPE_1 < T > > search ( ‚Ä¶ ) <|endcomment|> <START> default < T > TYPE_3 < TYPE_1 < T > > VAR_3 ( TYPE_2 query , Class < T > VAR_5 ) { <END> return VAR_3 ( query , VAR_5 , VAR_5 ) ; }
<|startcomment|> true <|endcomment|> public Object execute ( TYPE_1 event ) throws TYPE_2 { TYPE_3 VAR_1 = new TYPE_3 ( VAR_2 . METHOD_1 ( ) , <START> false ) ; <END> TYPE_4 VAR_3 = new TYPE_4 ( METHOD_2 ( event ) , VAR_1 ) ; if ( VAR_3 . METHOD_3 ( ) == TYPE_6 . VAR_5 ) { for ( String VAR_6 : VAR_1 . METHOD_4 ( ) ) { File VAR_7 = TYPE_5 . METHOD_5 ( new File ( VAR_6 ) ) ; METHOD_6 ( VAR_7 ) ; } } return null ; }
<|startcomment|> check null set - null IDK code handles null differently <|endcomment|> public Map < String , String > METHOD_1 ( ) { final Map < String , String > VAR_1 = new HashMap < String , String > ( ) ; <START> final String VAR_2 = System . getProperty ( TYPE_1 . VAR_4 ) ; <END> log . info ( STRING_1 + TYPE_1 . VAR_4 + STRING_2 + VAR_2 + STRING_3 ) ; VAR_1 . put ( TYPE_1 . VAR_4 , VAR_2 ) ; return VAR_1 ; }
<|startcomment|> I need return VAR_4 b / c max degree ! = VAR_7 return 1 40 <|endcomment|> protected int METHOD_1 ( TYPE_1 ctx , int VAR_1 ) { if ( VAR_2 . VAR_3 != null ) { int VAR_4 = VAR_2 . VAR_3 . VAR_5 ; if ( VAR_4 == TYPE_2 . VAR_7 ) { <START> VAR_4 = ctx . VAR_8 ( ) ; <END> } } return VAR_1 ; }
<|startcomment|> synchronized <|endcomment|> <START> public static boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <END> if ( VAR_2 . isPresent ( ) && VAR_2 . get ( ) . METHOD_2 ( ) . equals ( VAR_1 ) ) { VAR_2 . get ( ) . METHOD_3 ( ) ; return true ; } else { return false ; } }
<|startcomment|> line breaked ) <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { return VAR_1 . stream ( ) . map ( input - > new TYPE_2 ( input . VAR_2 ( ) , null , Collections . VAR_3 ( input ) , VAR_4 , VAR_5 ) <START> ) . collect ( Collectors . VAR_6 ( ) ) ; <END> }
<|startcomment|> add type parameter s object <|endcomment|> <START> public Optional METHOD_1 ( final String name ) { <END> return Optional . VAR_1 ( this . request . VAR_2 ( name ) ) ; }
<|startcomment|> method doesn t need public <|endcomment|> <START> public static String METHOD_1 ( List < TYPE_1 > VAR_1 ) { <END> TYPE_2 b = new TYPE_2 ( ) ; for ( TYPE_1 e : VAR_1 ) { b . append ( e . VAR_2 ( ) ) . append ( STRING_1 ) ; } return b . toString ( ) ; }
<|startcomment|> return <|endcomment|> private static boolean METHOD_1 ( String value ) throws TYPE_1 { TYPE_2 name ; try { name = new TYPE_3 ( value ) ; } catch ( Exception e ) { LOG . info ( STRING_1 , e . VAR_1 ( ) , e ) ; throw new TYPE_1 ( TYPE_4 . VAR_3 , STRING_2 ) ; } <START> return name != null ; <END> }
<|startcomment|> move close ( ) a finally - block <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 in , TYPE_3 VAR_1 ) throws IOException { Map < String , Object > VAR_2 = TYPE_4 . METHOD_2 ( in , VAR_3 ) ; <START> in . close ( ) ; <END> TYPE_5 VAR_4 = TYPE_6 . METHOD_3 ( VAR_2 , VAR_1 ) ; return TYPE_7 . METHOD_4 ( VAR_2 , VAR_4 ) ; }
<|startcomment|> worth checking need method patch Boolean VAR_6 a primitive false <|endcomment|> private void METHOD_1 ( Guid VAR_1 ) { METHOD_2 ( TYPE_3 . TYPE_4 , new TYPE_1 ( VAR_1 , TYPE_2 . VAR_5 , Boolean . VAR_6 ) ) ; <START> } <END>
<|startcomment|> create new TYPE_3 syncexec <|endcomment|> public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ( ) - > { for ( int i = 1 ; i <= VAR_1 ; i ++ ) { String VAR_2 = STRING_1 + i ; TYPE_2 . METHOD_3 ( VAR_2 ) ; <START> VAR_3 . add ( new TYPE_3 ( VAR_2 ) ) ; <END> } } ) ; }
<|startcomment|> I public IMO called Builder <|endcomment|> <START> public TYPE_2 ( <END> Optional < Object > VAR_2 , Optional < Object > VAR_3 , TYPE_1 VAR_4 , TYPE_1 VAR_5 , TYPE_1 VAR_6 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_2 ) ; METHOD_1 ( VAR_4 , STRING_3 ) ; METHOD_1 ( VAR_5 , STRING_4 ) ; METHOD_1 ( VAR_6 , STRING_5 ) ; this . VAR_7 = METHOD_2 ( VAR_5 , VAR_4 , VAR_6 ) ; }
<|startcomment|> sounds reasonable <|endcomment|> public void close ( ) { log . debug ( STRING_1 ) ; if ( VAR_1 ) { VAR_2 . METHOD_1 ( ) ; } <START> VAR_2 . METHOD_2 ( ) ; <END> METHOD_3 ( ) ; }
<|startcomment|> set _CODE_ instead <|endcomment|> public static TYPE_1 create ( TYPE_2 VAR_1 ) { TYPE_1 ctx = new TYPE_1 ( ) ; ctx . VAR_2 ( VAR_1 , TYPE_4 . TYPE_5 . create ( VAR_1 . METHOD_1 ( ) ) ) ; <START> ctx . VAR_3 = VAR_1 . METHOD_2 ( ) ; <END> return ctx ; }
<|startcomment|> replace VAR_1 s URL s wrap s long : javareturn VAR_2 METHOD_2 ( ) VAR_1 ( VAR_1 ) METHOD_3 ( STRING_1 ) path ( VAR_3 toString ( ) ) path ( String valueOf ( VAR_4 METHOD_4 ( ) ) ) METHOD_5 ( ) build ( ) ; <|endcomment|> private synchronized TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 VAR_2 ) { <START> return VAR_2 . METHOD_2 ( ) . METHOD_3 ( STRING_1 ) . path ( VAR_3 . toString ( ) ) . path ( String . valueOf ( VAR_4 . METHOD_4 ( ) ) ) . METHOD_5 ( "" ) . METHOD_6 ( VAR_1 ) . build ( ) ; <END> }
<|startcomment|> _CODE_ ( VAR_2 length ( ) TYPE_1 size ( VAR_3 METHOD_2 ( ) ) ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { VAR_1 . write ( VAR_2 , 0 , VAR_2 . length ( ) ) ; VAR_1 . commit ( ) ; <START> assertTrue ( TYPE_1 . size ( VAR_3 . METHOD_2 ( ) ) == VAR_2 . length ( ) ) ; <END> }
<|startcomment|> add { } <|endcomment|> public void METHOD_1 ( int VAR_1 , int VAR_2 , boolean VAR_3 ) { this . VAR_4 . METHOD_2 ( VAR_1 , VAR_2 ) ; if <START> ( VAR_3 ) <END> METHOD_3 ( new TYPE_1 ( this , VAR_1 ) ) ; }
<|startcomment|> don t method throw IOException rid <|endcomment|> <START> protected void METHOD_1 ( ) throws IOException <END> { VAR_1 = null ; VAR_2 = null ; VAR_3 = TYPE_6 . instance ; VAR_5 = TYPE_1 . instance ( ) ; VAR_6 = TYPE_7 . instance ; VAR_8 = TYPE_10 . instance ; VAR_10 = ( TYPE_2 ) TYPE_9 . instance ; VAR_12 = TYPE_12 . instance ; VAR_14 = TYPE_5 . instance ; VAR_16 = TYPE_11 . instance ; VAR_18 = new TYPE_3 ( ) ; VAR_19 = TYPE_8 . instance ; VAR_21 = TYPE_4 . METHOD_2 ( ) ; VAR_22 = TYPE_4 . METHOD_3 ( ) ; }
<|startcomment|> clarify catch TYPE_2 thrown _CODE_ ? wan include thrown e new TYPE_2 created <|endcomment|> private void METHOD_1 ( int VAR_1 , TYPE_1 < Integer > VAR_2 ) { List < Integer > list = VAR_3 . METHOD_2 ( 0 , VAR_1 ) ; try { list . VAR_4 ( VAR_2 ) ; } catch ( IllegalArgumentException e ) { <START> throw new TYPE_2 ( VAR_5 , STRING_1 ) ; <END> } }
<|startcomment|> debug <|endcomment|> public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( VAR_2 + VAR_3 ) ; } catch ( IllegalArgumentException e ) { <START> logger . info ( STRING_1 , VAR_2 + VAR_3 ) ; <END> } finally { logger . info ( STRING_2 ) ; } }
<|startcomment|> METHOD_8 ( 1 ) default METHOD_7 <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 , TYPE_3 { long VAR_2 = 1 ; TYPE_4 VAR_3 = TYPE_5 . METHOD_2 ( ) ; TYPE_6 node = VAR_3 . METHOD_3 ( TYPE_9 . VAR_5 ) ; node . add ( VAR_2 ) ; when ( VAR_6 . METHOD_4 ( ) ) . METHOD_5 ( VAR_3 ) ; TYPE_7 result = VAR_7 . METHOD_6 ( ) ; assertEquals ( TYPE_8 . VAR_8 , TYPE_8 . status ( result ) ) ; <START> METHOD_7 ( VAR_1 , METHOD_8 ( 1 ) ) . METHOD_9 ( VAR_2 ) ; <END> }
<|startcomment|> done _CODE_ instead ? method called more want ensure set environment config time task _CODE_ methods a good place a reason <|endcomment|> private static < TYPE_1 > View < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 conf = TYPE_5 . TYPE_2 . VAR_4 . METHOD_2 ( VAR_1 ) ; Class < TYPE_1 > type = getType ( VAR_1 ) ; String VAR_5 = conf . get ( VAR_6 ) ; <START> TYPE_4 . set ( conf ) ; <END> return TYPE_6 < TYPE_1 , View < TYPE_1 > > METHOD_1 ( VAR_5 , type ) ; }
<|startcomment|> principal login test print root need print <|endcomment|> public boolean METHOD_1 ( Map < String , String > VAR_1 ) { if ( METHOD_2 ( ) ) { return true ; } if ( ! super . METHOD_1 ( VAR_1 ) ) { return false ; } if ( ! METHOD_3 ( ) ) { <START> System . err . format ( STRING_1 ) ; <END> return false ; } return true ; }
<|startcomment|> done <|endcomment|> <START> public void METHOD_1 ( ) { <END> TYPE_1 VAR_1 = METHOD_2 ( VAR_2 , VAR_3 , VAR_4 , true ) ; VAR_5 . METHOD_3 ( ) ; }
<|startcomment|> call read ( String line TYPE_1 reuse ) pass null reuse duplicate method <|endcomment|> <START> public TYPE_1 read ( String line ) { <END> try { return builder . VAR_1 ( parser . VAR_2 ( line ) , null ) ; } catch ( IOException e ) { throw new TYPE_2 ( STRING_1 + line , e ) ; } }
<|startcomment|> a part METHOD_4 method ? instead a wrapper ? call METHOD_3 <|endcomment|> public void METHOD_1 ( ) { VAR_1 = true ; <START> if ( METHOD_2 ( ) . METHOD_3 ( ) != null ) { <END> METHOD_4 ( ) ; } }
<|startcomment|> TYPE_4 necessary <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 , final TYPE_3 VAR_3 ) <START> throws IOException , TYPE_4 <END> { VAR_2 . METHOD_2 ( VAR_1 . METHOD_3 ( true ) ) ; }
<|startcomment|> please loop style reduce GC <|endcomment|> public String toString ( ) { StringBuilder builder = new StringBuilder ( TYPE_1 . METHOD_1 ( this ) ) . append ( CHAR_1 ) ; <START> for ( TYPE_2 VAR_1 : VAR_2 ) { <END> builder . append ( VAR_1 ) . append ( STRING_1 ) ; } if ( ! VAR_2 . isEmpty ( ) ) { builder . VAR_3 ( builder . length ( ) - 2 ) ; } return builder . append ( CHAR_2 ) . toString ( ) ; }
<|startcomment|> change ( VAR_1 ! = null ) { } avoid outer clause <|endcomment|> private TYPE_1 [ ] METHOD_1 ( Class < ? > VAR_1 ) { final List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; <START> if ( VAR_1 != null ) { do { <END> VAR_2 . addAll ( Arrays . asList ( VAR_1 . METHOD_2 ( ) ) ) ; VAR_1 = VAR_1 . METHOD_3 ( ) ; } while ( VAR_1 . METHOD_3 ( ) != null ) ; } return VAR_2 . METHOD_4 ( new TYPE_1 [ 0 ] ) ; }
<|startcomment|> merge lines METHOD_2 return argument <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> this . VAR_1 = VAR_1 ; <END> }
<|startcomment|> _CODE_ = request ; <|endcomment|> protected String METHOD_1 ( TYPE_1 context , TYPE_2 request , TYPE_3 VAR_1 ) { <START> VAR_2 = request ; <END> return METHOD_2 ( context ) . METHOD_3 ( ) ; }
<|startcomment|> high requests rate discussing 1mln / s ? coordinator balancing process choke halt amount long discussed queue show a mere slight latency I m a single queue manage current request rate coordinator besides threads don t need call * _CODE_ ( ) * perfectly consume calling * queue ( ) * <|endcomment|> public void start ( ) { for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_2 . METHOD_1 ( new TYPE_1 ( VAR_3 [ i ] ) , 0 , <START> config . VAR_4 ( ) . METHOD_2 ( ) , <END> TimeUnit . VAR_5 ) ; } }
<|startcomment|> indentation crazy ! I m thinking some mismatch ( IDE github ) number spaces a tab worth <|endcomment|> <START> protected void METHOD_1 ( Class c ) throws IOException { <END> METHOD_2 ( STRING_1 ) ; METHOD_2 ( STRING_2 ) ; METHOD_3 ( STRING_3 , METHOD_4 ( c ) ) ; close ( STRING_2 ) ; METHOD_2 ( STRING_2 ) ; METHOD_5 ( c . getType ( ) ) ; METHOD_6 ( STRING_4 ) ; METHOD_3 ( STRING_5 , METHOD_7 ( c ) ) ; close ( STRING_2 ) ; close ( STRING_6 ) ; }
<|startcomment|> internal cache return null <|endcomment|> public ArrayList < Pair < TYPE_1 [ ] , TYPE_2 > > METHOD_1 ( TYPE_3 i ) { if ( VAR_1 . get ( i ) != null ) return VAR_1 . get ( i ) ; <START> return new ArrayList < Pair < TYPE_1 [ ] , TYPE_2 > > ( ) ; <END> }
<|startcomment|> some point need a variant exists ( ) accepts TYPE_2 parameter case existence VAR_2 needs a path special properties scope some package type critical <|endcomment|> public boolean exists ( ) { TYPE_1 VAR_1 = null ; if ( VAR_2 != null ) { <START> VAR_1 = VAR_2 . METHOD_1 ( this , new TYPE_2 ( ) ) ; <END> } if ( ( VAR_1 != null ) && VAR_1 . METHOD_2 ( ) ) { return VAR_1 . METHOD_3 ( ) ; } else { return VAR_3 . exists ( resource ) ; } }
<|startcomment|> I a race _CODE_ _CODE_ shutdown population jobs added _CODE_ stop called result leak population jobs guarded higher stack I guarded explicitly _CODE_ <|endcomment|> public void METHOD_1 ( TYPE_1 job ) { VAR_1 . add ( job ) ; <START> VAR_2 . METHOD_2 ( VAR_3 , new TYPE_2 ( job , this ) ) ; <END> }
<|startcomment|> Integer parseInt <|endcomment|> public static int METHOD_1 ( Map < String , String > options , String VAR_1 , int VAR_2 ) { String value = options . get ( VAR_1 ) ; <START> return value == null ? VAR_2 : Integer . valueOf ( value ) ; <END> }
<|startcomment|> thread safe <|endcomment|> public void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_1 . METHOD_3 ( ) == 0 ) { <END> VAR_1 = null ; } } }
<|startcomment|> good idea üëç checking IMO moved _CODE_ os < X > classes generally expose os interface mapping upper layer i e _CODE_ <|endcomment|> public TYPE_3 . TYPE_4 METHOD_1 ( ) { String VAR_1 = METHOD_2 ( VAR_2 ) ; String id = VAR_3 . getId ( ) ; if ( VAR_1 . equals ( id ) ) { return VAR_3 ; } else { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } }
<|startcomment|> minor : rely interface full type <|endcomment|> private static Set < TYPE_1 > METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { return Collections . VAR_2 ( ) ; } <START> HashSet < TYPE_1 > result = new HashSet < > ( ) ; <END> result . add ( VAR_1 ) ; VAR_1 . METHOD_1 ( ) . forEach ( VAR_3 - > result . addAll ( METHOD_1 ( VAR_3 ) ) ) ; return result ; }
<|startcomment|> method recursively calls result stackoverflow <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return this . METHOD_1 ( ) ; <END> }
<|startcomment|> shouldn t throw exception instead <|endcomment|> public Integer add ( TYPE_1 < TYPE_2 > VAR_1 ) { return METHOD_1 ( ) . add ( VAR_1 . filter ( entity - > { <START> boolean VAR_2 = METHOD_2 ( entity , TYPE_3 . VAR_4 ) ; <END> if ( VAR_2 ) { METHOD_3 ( entity ) ; } return VAR_2 ; } ) ) ; }
<|startcomment|> szewc I d _CODE_ METHOD_4 ( ) ; METHOD_5 ( VAR_3 METHOD_6 ( INT_1 ) ) METHOD_7 ( CHAR_1 ) ; VAR_2 METHOD_4 ( ) ; METHOD_5 ( VAR_3 METHOD_6 ( INT_1 ) ) METHOD_7 ( CHAR_2 ) ; I agree test wrong <|endcomment|> public void METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_1 VAR_2 = METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ) ; <START> VAR_2 . METHOD_4 ( ) ; <END> METHOD_5 ( VAR_3 , METHOD_6 ( INT_1 ) ) . METHOD_7 ( CHAR_1 ) ; METHOD_5 ( VAR_3 , METHOD_6 ( INT_1 ) ) . METHOD_7 ( CHAR_2 ) ; }
<|startcomment|> else { [ ] ( start = 10 length = 6 ) don t need else block <|endcomment|> public final boolean METHOD_1 ( ) { if ( VAR_1 != null && ! TYPE_1 . METHOD_2 ( VAR_2 ) ) { return ! METHOD_3 ( VAR_1 ) ; <START> } else { <END> return false ; } }
<|startcomment|> redundant String constructor <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 message = METHOD_2 ( VAR_1 ) ; try { VAR_2 . METHOD_3 ( message , false ) ; } catch ( Exception e ) { <START> String VAR_3 = new String ( STRING_1 + VAR_1 . METHOD_4 ( ) ) ; <END> LOG . error ( VAR_3 , e ) ; } }
<|startcomment|> minor : package private <|endcomment|> <START> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_6 . TYPE_7 listener ) { <END> VAR_2 . METHOD_2 ( VAR_1 , VAR_3 - > new TYPE_3 ( VAR_1 , VAR_4 . METHOD_2 ( VAR_3 , ( TYPE_4 < TYPE_1 , List < TYPE_5 > > ) VAR_5 - > new ArrayList < > ( ) ) , VAR_6 . METHOD_2 ( VAR_3 , ( TYPE_4 < TYPE_1 , List < ByteBuffer > > ) VAR_7 - > new ArrayList < > ( ) ) , listener ) ) ; }
<|startcomment|> add clarifying parenthesis s easy forget precedence rules ^ & code easier reason <|endcomment|> private static long METHOD_1 ( double value ) { long VAR_1 = Double . VAR_2 ( value ) ; <START> return VAR_1 ^ ( VAR_1 > > INT_1 ) & Long . VAR_3 ; <END> }
<|startcomment|> s a bit I doubt _CODE_ memory easily increase a bit default ( 100 ) need check nodes created a jobs run _CODE_ standard extension side root extension node 1 namespace ( practice 1 par wiki ) s potentially a lot more refactoring module root refactoring node node element _CODE_ manipulated <|endcomment|> default int VAR_1 ( ) { <START> return 10 ; <END> }
<|startcomment|> minor : qualifiers required <|endcomment|> public TYPE_5 ( ) throws InterruptedException { Pair < TYPE_1 , TYPE_2 > VAR_2 = TYPE_3 . METHOD_1 ( properties , time , - 1 , - 1 , VAR_3 ) ; <START> this . config = VAR_2 . METHOD_2 ( ) ; <END> this . VAR_4 = VAR_2 . METHOD_3 ( ) ; this . VAR_5 = VAR_4 . METHOD_4 ( ) ; this . VAR_6 = config . VAR_7 * TYPE_8 . TYPE_6 * TYPE_8 . TYPE_9 * TYPE_8 . TYPE_7 ; this . VAR_12 = new TYPE_4 ( config , time ) ; }
<|startcomment|> simply iterate array chars check VAR_1 ( character ) <|endcomment|> private boolean METHOD_1 ( String VAR_1 ) { <START> String VAR_2 = STRING_1 <END> + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 ; String VAR_3 = VAR_1 . METHOD_2 ( VAR_2 , "" ) ; if ( VAR_3 . equals ( VAR_1 ) ) { return true ; } return false ; }
<|startcomment|> s a pity change public API I guess s reasonable case s hope folks wrote custom migrations commands <|endcomment|> <START> public TYPE_6 ( String VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 ) throws TYPE_4 , TYPE_5 { <END> super ( VAR_2 , VAR_3 , VAR_4 ) ; this . VAR_5 = VAR_5 ; }
<|startcomment|> remove fields call other constructor : ( VAR_2 ( 0 ) METHOD_1 ( ) ) ; <|endcomment|> public TYPE_4 ( ArrayList < TYPE_1 > VAR_2 , TYPE_2 < TYPE_1 > VAR_3 ) { VAR_4 = VAR_2 ; <START> VAR_5 = VAR_3 ; <END> VAR_6 = VAR_2 . get ( 0 ) . METHOD_1 ( ) ; VAR_7 = new TYPE_3 ( ( Long ) null ) ; VAR_8 = 0 ; }
<|startcomment|> Exception thrown <|endcomment|> <START> public void METHOD_1 ( ) throws Exception { <END> String id = TYPE_1 . METHOD_2 ( ) . toString ( ) ; TYPE_2 VAR_1 = VAR_2 . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( id ) ; TYPE_4 . VAR_4 . of ( VAR_1 ) . set ( Boolean . VAR_5 ) ; VAR_6 = new TYPE_3 ( VAR_1 , VAR_7 . METHOD_5 ( ) , VAR_7 ) ; assertTrue ( VAR_6 . METHOD_6 ( ) ) ; }
<|startcomment|> remove parameter completely other constructor initiate publisher null <|endcomment|> private TYPE_1 METHOD_1 ( ) { return new TYPE_2 ( <START> null , <END> VAR_1 , VAR_2 , VAR_3 ) ; }
<|startcomment|> clear VAR_1 list loop <|endcomment|> public void METHOD_1 ( ) throws IOException { if ( VAR_1 != null ) { for ( TYPE_1 VAR_2 : VAR_1 ) { try { VAR_2 . close ( ) ; } catch ( IOException e ) { log . warn ( STRING_1 , e ) ; } <START> } <END> } VAR_3 . METHOD_1 ( ) ; super . METHOD_1 ( ) ; }
<|startcomment|> a plain decrement ( ) <|endcomment|> public void close ( ) { super . close ( ) ; if ( VAR_1 != null ) { <START> VAR_1 . METHOD_1 ( ) ; <END> } }
<|startcomment|> logger instead VAR_1 ( ) calls <|endcomment|> public static String METHOD_1 ( String key ) { try { return METHOD_2 ( ) . getString ( key ) ; } catch ( TYPE_1 e ) { <START> e . VAR_1 ( ) ; <END> throw new TYPE_1 ( STRING_1 + VAR_2 + STRING_2 + key + STRING_3 ) ; } }
<|startcomment|> class immutable wrap collection constructor time returned caller <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> return METHOD_2 ( options ) ; <END> }
<|startcomment|> need set input position initial offset <|endcomment|> public TYPE_2 ( TYPE_1 input , int VAR_2 ) { this . input = input ; this . VAR_2 = VAR_2 ; <START> } <END>
<|startcomment|> means VAR_2 unknown type considered serializable ? consider making unknown check METHOD_4 provide behavior rules ? I m other rule ( S2118 ) METHOD_4 reporting arguable issue a similar message run unknown type > ! unknown ! class serializable don t write <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . get ( 1 ) ; Type type = VAR_2 . METHOD_3 ( ) ; <START> if ( type . VAR_3 ( ) ) { <END> return ; } if ( TYPE_3 . METHOD_4 ( VAR_2 ) ) { String VAR_4 = TYPE_4 . METHOD_5 ( type ) ? STRING_1 : "" ; METHOD_6 ( VAR_2 , STRING_2 + type + STRING_3 + VAR_4 + STRING_4 ) ; } }
<|startcomment|> cast necessary <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 < T > VAR_2 ) { TYPE_3 VAR_3 = new TYPE_3 ( new TYPE_4 ( VAR_1 ) ) ; TYPE_5 parser = new TYPE_5 ( new TYPE_6 ( VAR_3 ) ) ; parser . VAR_4 ( new TYPE_7 ( ) ) ; TYPE_8 VAR_5 = parser . parse ( ) ; TYPE_9 < T > VAR_6 = new TYPE_9 < > ( this , VAR_2 ) ; <START> return ( TYPE_1 ) VAR_6 . METHOD_2 ( VAR_5 ) ; <END> }
<|startcomment|> remove exceptions thrown method <|endcomment|> <START> public TYPE_1 [ ] METHOD_1 ( String path ) throws TYPE_2 , TYPE_3 { <END> return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> I d thought preserving Optional class s implementation nicer Optional constructor reverting null _inside_ class <|endcomment|> <START> <END> protected <END> <END> <END> TYPE_8 <END> <END> ( <END> <END> final <END> <END> TYPE_1 VAR_2 <END> <END> , <END> final TYPE_2 <END> . <END> <END> View <END> view <END> , final Optional < <END> ? <END> <END> <END> extends TYPE_3 <END> < <END> TYPE_4 <END> > <END> <END> > <END> VAR_3 <END> , <END> final <END> Optional < <END> <END> TYPE_5 <END> < <END> TYPE_6 <END> , <END> ? > <END> > <END> VAR_4 <END> , <END> final <END> TYPE_7 <END> VAR_5 <END> ) <END> { <END> this <END> . <END> VAR_2 <END> = VAR_2
<|startcomment|> czy musi byc publiczne <|endcomment|> <START> public void METHOD_1 ( ) { <END> VAR_1 . METHOD_2 ( ) ; METHOD_3 ( true ) ; METHOD_4 ( ) ; }
<|startcomment|> VAR_3 parameter isn t <|endcomment|> <START> private TYPE_1 METHOD_1 ( TYPE_2 ctx , Object key , TYPE_3 VAR_1 , TYPE_4 VAR_2 , boolean VAR_3 ) { <END> if ( VAR_1 instanceof TYPE_1 ) { TYPE_1 VAR_4 = ( TYPE_1 ) VAR_1 ; METHOD_2 ( VAR_4 , VAR_2 ) ; return VAR_4 ; } return METHOD_3 ( ctx , key , ( TYPE_5 ) VAR_1 , VAR_2 , true ) ; }
<|startcomment|> read ( ) call part TYPE_1 ( TYPE_2 ) constructor <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_2 buffer = METHOD_2 ( TYPE_3 . VAR_2 ) ; TYPE_1 result = new TYPE_1 ( buffer ) ; <START> result . read ( ) ; <END> return result ; }
<|startcomment|> I add other VAR_7 method enforce fact explicitly target <|endcomment|> void METHOD_1 ( String VAR_1 , String TYPE_4 , String TYPE_5 , String VAR_4 , String VAR_5 , TYPE_2 . TYPE_3 . VAR_6 uri ) throws Exception { new File ( VAR_1 ) ; new File ( TYPE_4 , TYPE_5 ) ; File parent = new File ( uri ) ; new File ( parent , TYPE_5 ) ; <START> File . VAR_7 ( VAR_4 , VAR_5 ) ; <END> }
<|startcomment|> I _CODE_ included error message include message set <|endcomment|> public TYPE_1 METHOD_1 ( ) { for ( TYPE_2 vm : VAR_1 ) { if ( METHOD_2 ( ) . METHOD_3 ( vm . getId ( ) ) ) { return new TYPE_1 ( TYPE_3 . VAR_3 , <START> String . format ( STRING_1 , vm . getName ( ) ) ) ; <END> } } return TYPE_1 . VAR_4 ; }
<|startcomment|> want log exception <|endcomment|> public void METHOD_1 ( Throwable e ) { <START> e . VAR_1 ( ) ; <END> try { TYPE_1 . METHOD_2 ( response , TYPE_2 . VAR_3 , e . getMessage ( ) ) ; context . VAR_4 ( ) ; in . close ( ) ; } catch ( IOException ex ) { LOG . log ( Level . VAR_5 , ex . getMessage ( ) , ex ) ; } }
<|startcomment|> return simplified : return VAR_1 remove ( VAR_1 METHOD_2 ( ) ) ; : ) <|endcomment|> public String METHOD_1 ( ) { <START> String value = VAR_1 . remove ( VAR_1 . METHOD_2 ( ) ) ; <END> return value ; }
<|startcomment|> shouldn t METHOD_2 <|endcomment|> public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; VAR_2 = null ; VAR_3 . METHOD_3 ( ) ; VAR_3 = null ; <START> TYPE_1 . getInstance ( ) . METHOD_4 ( ) . METHOD_5 ( this ) ; <END> super . METHOD_1 ( ) ; }
<|startcomment|> getClass comparison required dtos inheritance works ( analyte a tissue identity purpose including parent data ) instanceof ( typically - VAR_1 models ) check interfaces flexibility e g add another implementation TYPE_4 method work subclass TYPE_3 ( ) <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 from ) { TYPE_1 VAR_1 = null ; <START> if ( from . getClass ( ) == TYPE_3 . class ) { <END> VAR_1 = METHOD_2 ( ( TYPE_4 ) from ) ; } else if ( from . getClass ( ) == TYPE_5 . class ) { VAR_1 = METHOD_3 ( ( TYPE_6 ) from ) ; } else { VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ; }
<|startcomment|> unnecessary new line : leave line blank ? ( s a wrap signature case differentiate signature body ) <|endcomment|> public void METHOD_1 ( ) throws IOException { <START> <END> int [ ] [ ] VAR_1 = { } ; int [ ] [ ] VAR_2 = { } ; try { METHOD_2 ( VAR_1 , VAR_2 ) ; METHOD_3 ( STRING_1 ) ; } catch ( IllegalStateException VAR_3 ) { } }
<|startcomment|> constructor package private guice injector able call remove null checks injector fail parameter missing <|endcomment|> TYPE_9 ( ANNOTATION_1 TYPE_1 < Set < ? extends TYPE_2 > > VAR_2 , TYPE_7 . TYPE_8 VAR_3 , TYPE_4 VAR_4 , TYPE_5 VAR_5 , Map < String , TYPE_6 > VAR_6 ) { this . VAR_7 = METHOD_1 ( VAR_3 , STRING_1 ) . METHOD_2 ( ) ; this . VAR_2 = METHOD_1 ( VAR_2 , STRING_2 ) ; this . VAR_4 = METHOD_1 ( VAR_4 , STRING_3 ) ; this . VAR_5 = METHOD_1 ( VAR_5 , STRING_4 ) ; <START> this . VAR_6 = METHOD_1 ( VAR_6 , STRING_5 ) ; <END> }
<|startcomment|> I shouldn t constructor extra boolean argument <|endcomment|> public TYPE_1 METHOD_1 ( ) throws IllegalStateException { if ( VAR_1 != null ) throw new IllegalStateException ( STRING_1 + VAR_1 ) ; TYPE_2 state = METHOD_2 ( ) ; if ( VAR_2 == null ) VAR_2 = new TYPE_3 ( state ) ; <START> TYPE_4 event = new TYPE_4 ( VAR_3 , VAR_2 , state , this , this , METHOD_3 ( ) , false ) ; <END> state . VAR_4 ( event ) ; return VAR_2 ; }
<|startcomment|> throws Exception dropped METHOD_3 code : _CODE_ < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { return METHOD_3 ( VAR_1 ) ; } <|endcomment|> TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { <START> return TYPE_1 . METHOD_2 ( ( ) - > { <END> try { METHOD_3 ( VAR_1 ) ; } catch ( Exception e ) { throw new TYPE_4 ( e ) ; } return null ; } , VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) ; }
<|startcomment|> VAR_1 ( ) called 3 times ? worth a dedicated variable <|endcomment|> private boolean METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { return VAR_1 . METHOD_2 ( ) . type ( ) . is ( STRING_1 ) <START> && ( STRING_2 . equals ( VAR_1 . name ( ) ) || STRING_3 . equals ( VAR_1 . name ( ) ) || STRING_4 . equals ( VAR_1 . name ( ) ) ) ; <END> }
<|startcomment|> METHOD_2 ( ) beginning _CODE_ ( ) _CODE_ doesn t cancelled _CODE_ _CODE_ ( ) _CODE_ _CODE_ ( ) <|endcomment|> public void METHOD_1 ( TYPE_1 trace ) { <START> METHOD_2 ( ) ; <END> super . METHOD_1 ( trace ) ; METHOD_3 ( ) ; }
<|startcomment|> TYPE_4 parser options aren t file - oriented ( streams ) isn t a good place put imo replace reset ( ) called places reset ( ) currently called ( _CODE_ ) addition : needs called file <|endcomment|> public TYPE_4 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_2 ) String VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_4 = new TYPE_2 ( VAR_2 ) ; this . parser = VAR_2 . METHOD_1 ( ) ; <START> parser . VAR_5 ( ) ; <END> if ( VAR_3 != null ) { this . VAR_6 = TYPE_3 . METHOD_2 ( VAR_3 ) ; } else { this . VAR_6 = VAR_7 ; } }
<|startcomment|> superclass repeats METHOD_2 ( ) call I don t PR adds <|endcomment|> public Object METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) ; switch ( VAR_1 ) { case TYPE_1 . VAR_3 : return VAR_4 . getName ( ) ; case TYPE_1 . VAR_5 : return Integer . toString ( VAR_6 != 0 ? VAR_6 : VAR_7 ) ; case TYPE_1 . VAR_8 : return Integer . toString ( VAR_9 ) ; } <START> return super . METHOD_1 ( VAR_1 ) ; <END> }
<|startcomment|> TYPE_2 METHOD_1 ( METHOD_2 ( ) ) others <|endcomment|> public static TYPE_1 METHOD_1 ( boolean value ) { <START> return METHOD_1 ( TYPE_2 . METHOD_2 ( value ) ) ; <END> }
<|startcomment|> : METHOD_7 callable more efficient lambda form <|endcomment|> public void METHOD_1 ( ) throws IOException { if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) { VAR_1 . METHOD_2 ( ) . debug ( STRING_1 + VAR_2 + STRING_2 + VAR_1 . METHOD_4 ( ) ) ; } VAR_3 = VAR_1 . METHOD_5 ( VAR_4 ) ; <START> METHOD_6 ( VAR_1 . METHOD_4 ( ) , ( ) - > METHOD_7 ( ) , 0 ) ; <END> }
<|startcomment|> need guard null <|endcomment|> public void METHOD_1 ( ) throws Exception { if ( VAR_1 . METHOD_2 ( ) ) { TYPE_1 record = VAR_1 . METHOD_3 ( key ) ; if ( record != null ) { METHOD_4 ( key , record ) ; <START> } else { <END> METHOD_5 ( key ) ; } } super . METHOD_1 ( ) ; }
<|startcomment|> VAR_3 <|endcomment|> protected String METHOD_1 ( ) { <START> return TYPE_1 . VAR_2 . name . VAR_3 ( ) ; <END> }
<|startcomment|> method synchronized considering VAR_1 final <|endcomment|> <START> public synchronized int METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> add null VAR_1 <|endcomment|> private Set < TYPE_1 > METHOD_1 ( ) { Set < TYPE_1 > VAR_1 = new HashSet < > ( ) ; if ( VAR_2 == null || ! VAR_2 . isEmpty ( ) ) { <START> VAR_1 . addAll ( VAR_2 ) ; <END> } else { METHOD_2 ( ) ; } return VAR_1 ; }
<|startcomment|> moved block <|endcomment|> public void METHOD_1 ( ) throws Exception { try ( TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( TYPE_2 . class ) ) { VAR_1 . METHOD_3 ( ) ; Assert . assertTrue ( STRING_1 , VAR_1 . METHOD_4 ( ) ) ; Assert . assertTrue ( STRING_2 , listener . VAR_3 ( ) ) ; VAR_1 . execute ( ) ; <START> Assert . VAR_4 ( STRING_3 , listener . VAR_3 ( ) ) ; <END> } }
<|startcomment|> package private <|endcomment|> <START> private TYPE_4 ( TYPE_1 < TYPE_2 > VAR_2 ) { <END> this . VAR_3 = TYPE_3 . METHOD_1 ( VAR_2 ) ; }
<|startcomment|> codacy flagged method avoid a branching statement a loop I a reasonable call codacy code easier read VAR_1 set true loop a break a single method return VAR_1 currently line 136 alternatively VAR_1 a return true statement loop I alternative a easier read codacy content <|endcomment|> private boolean METHOD_1 ( ) { boolean VAR_1 = false ; Collection < ? extends TYPE_1 > VAR_2 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) ; Iterator < ? extends TYPE_1 > VAR_3 = VAR_2 . iterator ( ) ; while ( VAR_3 . hasNext ( ) ) { TYPE_1 VAR_4 = VAR_3 . next ( ) ; if ( ! ( VAR_4 instanceof TYPE_3 ) ) { continue ; } VAR_1 = ( ( TYPE_3 ) VAR_4 ) . METHOD_4 ( ) ; return VAR_1 ; } return false ; <START> } <END>
<|startcomment|> want tri - state Boolean boolean I don t need tristate boolean <|endcomment|> <START> public Boolean METHOD_1 ( TYPE_1 view , TYPE_2 VAR_1 , String host , String VAR_2 ) { <END> for ( TYPE_3 VAR_3 : this . VAR_4 . values ( ) ) { if ( VAR_3 != null && VAR_3 . METHOD_1 ( view , VAR_1 , host , VAR_2 ) ) { return true ; } } return false ; }
<|startcomment|> VAR_2 String <|endcomment|> private String METHOD_1 ( ) throws InterruptedException , TYPE_1 { <START> if ( VAR_1 . exists ( VAR_2 . toString ( ) , false ) == null ) { <END> try { TYPE_2 . METHOD_2 ( VAR_1 , VAR_2 . toString ( ) , TYPE_5 . TYPE_4 . VAR_5 ) ; } catch ( TYPE_3 e ) { log . log ( VAR_6 . VAR_7 . VAR_8 . Level . VAR_9 , STRING_1 + VAR_10 , e ) ; } } return VAR_2 + STRING_2 + VAR_11 ; }
<|startcomment|> I dialect implement _CODE_ items put operations queue <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 key , TYPE_3 VAR_1 ) { TYPE_4 entity = METHOD_2 ( key , VAR_1 . METHOD_3 ( ) ) ; if ( entity != null ) { return new TYPE_1 ( new TYPE_5 ( entity . VAR_2 ( ) ) ) ; } <START> else if ( METHOD_4 ( key , VAR_1 ) ) { <END> return new TYPE_1 ( new TYPE_5 ( entity . VAR_2 ( ) ) ) ; } else { return null ; } }
<|startcomment|> isn t enough throw logging exception instead logging locally <|endcomment|> public void METHOD_1 ( TYPE_1 event ) { try { method . VAR_1 ( listener , event ) ; } catch ( TYPE_2 e ) { log . VAR_2 ( method , listener , e . VAR_3 ( ) ) ; throw log . VAR_4 ( e . getClass ( ) . getName ( ) , method , listener , e . VAR_3 ( ) ) ; } catch ( Exception e ) { throw log . VAR_4 ( <START> e . getClass ( ) . getName ( ) , method , listener , e ) ; <END> } }
<|startcomment|> METHOD_1 ( ) VAR_2 location argument remove global variable VAR_2 needed reducing global state good general <|endcomment|> TYPE_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_2 ) { this . VAR_2 = VAR_2 ; <START> METHOD_1 ( ) ; <END> }
<|startcomment|> println s please <|endcomment|> public void METHOD_1 ( long VAR_1 ) throws TYPE_1 { <START> System . out . println ( STRING_1 + VAR_1 ) ; <END> }
<|startcomment|> I don t put method temp table considered staging directories <|endcomment|> private void METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { <START> Path path = VAR_2 . METHOD_2 ( ) ; <END> if ( VAR_2 . METHOD_3 ( ) ) { METHOD_4 ( VAR_2 . METHOD_5 ( ) , VAR_3 , path ) ; continue ; } if ( VAR_2 . METHOD_6 ( ) != TYPE_2 . VAR_5 ) { continue ; } METHOD_7 ( VAR_2 . METHOD_5 ( ) , path , ImmutableList . of ( ) , true , STRING_1 ) ; } }
<|startcomment|> format <|endcomment|> public void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { return ; } <START> TYPE_1 model = <END> new TYPE_1 ( this , METHOD_3 ( ) , ( TYPE_2 ) METHOD_4 ( ) , METHOD_5 ( ) . METHOD_6 ( ) ) ; METHOD_7 ( model ) ; METHOD_8 ( model ) ; }
<|startcomment|> please remove line changes tests <|endcomment|> public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; VAR_1 = new File ( project . VAR_2 ( ) . METHOD_2 ( ) . getPath ( ) , Constants . VAR_3 ) ; VAR_4 = new TYPE_1 ( VAR_1 ) ; VAR_4 . METHOD_3 ( project . VAR_2 ( ) ) ; <START> VAR_4 . commit ( STRING_1 ) ; <END> }
<|startcomment|> declaration - linesuggestionlong VAR_1 = METHOD_2 ( ) METHOD_3 ( ) METHOD_4 ( ) ; <|endcomment|> protected long METHOD_1 ( ) { long VAR_1 ; <START> VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <END> return VAR_1 ; }
<|startcomment|> part throw Exception remove throws Exception good beware spaces tabs prefer spaces indentation please <|endcomment|> public static String METHOD_1 ( File file ) throws Exception { <START> return TYPE_1 . METHOD_2 ( file . VAR_1 ( ) ) . METHOD_3 ( ) ; <END> }
<|startcomment|> need call Integer parseInt ( METHOD_3 ( ) ) more a method <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> assertNotNull ( VAR_1 . METHOD_2 ( Integer . parseInt ( METHOD_3 ( ) ) ) ) ; <END> TYPE_1 req = request ( TYPE_2 . VAR_3 , METHOD_4 ( ) + STRING_1 + METHOD_3 ( ) ) ; req . VAR_4 ( STRING_2 , "" ) ; METHOD_5 ( req ) ; METHOD_6 ( VAR_1 . METHOD_2 ( Integer . parseInt ( METHOD_3 ( ) ) ) ) ; }
<|startcomment|> chance test ? test 35 perspectives test case evil alternatively ( I m sniffing potential problems annotation arquillian ) looped code function put some logging test failed ? a method perspectives - cleanest solution situation I sort overkill <|endcomment|> <START> private void METHOD_1 ( String VAR_1 , boolean VAR_2 ) { <END> String VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; VAR_4 . get ( VAR_3 ) ; TYPE_1 . METHOD_3 ( ) ; TYPE_2 . METHOD_3 ( VAR_5 ) ; }
<|startcomment|> _CODE_ return empty array <|endcomment|> public default TYPE_1 [ ] VAR_2 ( ) { return <START> null ; <END> }
<|startcomment|> initialized failures <|endcomment|> protected void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( getParameters ( ) . METHOD_3 ( ) ) ; if ( VAR_1 == null ) { METHOD_4 ( false ) ; } else { VAR_3 = getParameters ( ) . METHOD_3 ( ) ; <START> VAR_4 = VAR_2 . METHOD_5 ( getParameters ( ) . METHOD_3 ( ) ) ; <END> VAR_2 . METHOD_6 ( getParameters ( ) . METHOD_3 ( ) , false ) ; METHOD_4 ( true ) ; } }
<|startcomment|> shouldn t thread visible ? notification disappear thread visible some reason <|endcomment|> public static void METHOD_1 ( Context context , TYPE_1 VAR_1 , long VAR_2 ) { if ( TYPE_2 . METHOD_2 ( context ) ) { if ( VAR_3 == VAR_2 ) { TYPE_3 . METHOD_3 ( context ) . METHOD_4 ( VAR_2 ) ; METHOD_5 ( context ) ; } else { <START> METHOD_1 ( context , VAR_1 , true ) ; <END> } } METHOD_6 ( context ) ; }
<|startcomment|> sense instead putting toString ( ) values I TYPE_1 s ( ) method toString ( ) overridden <|endcomment|> protected void METHOD_1 ( Map < TYPE_1 , String > options ) { options . put ( TYPE_6 . TYPE_9 , <START> TYPE_6 . TYPE_9 . toString ( ) ) ; <END> options . put ( TYPE_6 . TYPE_10 , TYPE_6 . TYPE_10 . toString ( ) ) ; options . put ( TYPE_6 . TYPE_7 , TYPE_6 . TYPE_7 . toString ( ) ) ; options . put ( TYPE_6 . TYPE_8 , TYPE_6 . TYPE_8 . toString ( ) ) ; }
<|startcomment|> Arrays stream ( ) applied <|endcomment|> public boolean METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> METHOD_1 ( Arrays . asList ( VAR_1 ) <END> . stream ( ) . map ( TYPE_1 : : getName ) ) ; return super . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> String valueOf ( ) <|endcomment|> private static Object METHOD_1 ( int value , Type type ) { if ( type == VAR_1 || type == VAR_2 || type == VAR_3 ) { return ( long ) value ; } if ( type == VAR_4 ) { <START> return value + "" ; <END> } if ( type == VAR_5 ) { return ( double ) value ; } throw new TYPE_1 ( ) ; }
<|startcomment|> METHOD_4 ( ) a finally block _CODE_ _CODE_ ( ) <|endcomment|> public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_2 ( STRING_1 ) ; TYPE_3 < String , TYPE_4 > VAR_2 = VAR_1 . METHOD_2 ( STRING_2 ) ; METHOD_3 ( VAR_2 ) ; TYPE_4 entity = new TYPE_4 ( STRING_3 , STRING_4 ) ; VAR_2 . put ( entity . VAR_3 ( ) , entity ) ; <START> VAR_1 . METHOD_4 ( ) ; <END> }
<|startcomment|> shouldn t TYPE_2 ? equals ( ) return true instances subclasses TYPE_1 point URI I checked happen aird opened time a - sirius editor <|endcomment|> public boolean equals ( Object o ) { boolean equals = this == o || o instanceof <START> TYPE_1 && <END> METHOD_1 ( ) . equals ( ( ( TYPE_1 ) o ) . METHOD_1 ( ) ) ; if ( equals && o instanceof TYPE_2 ) { TYPE_3 input = METHOD_2 ( false ) ; if ( input != null ) { TYPE_2 VAR_1 = ( TYPE_2 ) o ; return input . equals ( VAR_1 . METHOD_2 ( false ) ) ; } } return equals ; }
<|startcomment|> creator change update <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { if ( VAR_1 . METHOD_2 ( ) != null ) { VAR_1 . METHOD_3 ( VAR_2 . get ( VAR_1 . METHOD_2 ( ) . getId ( ) ) ) ; } if ( VAR_1 . METHOD_4 ( ) != null ) { VAR_1 . METHOD_5 ( VAR_3 . get ( VAR_1 . METHOD_4 ( ) . getId ( ) ) ) ; } <START> VAR_1 . METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; <END> }
<|startcomment|> need VAR_8 variable <|endcomment|> TYPE_1 METHOD_1 ( ) { long VAR_1 = METHOD_2 ( ) ; long context = OS . VAR_2 ( VAR_1 ) ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; if ( OS . VAR_4 < OS . VAR_5 ( 3 , INT_1 , 0 ) ) { VAR_3 = VAR_6 . METHOD_3 ( context , OS . VAR_7 , VAR_3 ) ; } else { <START> int VAR_8 = OS . VAR_9 ( VAR_10 ) ; <END> VAR_3 = VAR_6 . METHOD_3 ( context , VAR_8 , VAR_3 ) ; } return VAR_6 . METHOD_4 ( VAR_3 ) ; }
<|startcomment|> 2 called <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 , Object ... values ) { if ( values == null || values . length == 0 || values [ 0 ] == null ) { return this ; } VAR_2 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_1 , values ) ; <START> return this ; <END> }
<|startcomment|> minor : parentheses needed <|endcomment|> public int METHOD_1 ( ) { <START> int result = ( key ? 1 : 0 ) ; <END> result = INT_1 * result + ( path != null ? path . VAR_1 ( ) : 0 ) ; return result ; }
<|startcomment|> logging <|endcomment|> public boolean METHOD_1 ( ) { TYPE_1 . d ( STRING_1 + VAR_1 ) ; try { <START> int VAR_2 = VAR_3 . from ( VAR_1 ) ; <END> TYPE_1 . d ( STRING_2 + VAR_2 ) ; } catch ( TYPE_2 e ) { if ( e . VAR_4 ( ) ) { return false ; } throw e ; } return true ; }
<|startcomment|> bug reported ? VAR_4 track s fixed ensure bug fix done a separate commit new feature work _CODE_ ( I didn t check ) <|endcomment|> public T METHOD_1 ( final Object val ) { Assert . VAR_1 ( STRING_1 , val ) ; <START> return METHOD_2 ( TYPE_1 . VAR_3 , val , VAR_4 ) ; <END> }
<|startcomment|> class overrides equals method needs override _CODE_ method questions <|endcomment|> public Builder METHOD_1 ( final File VAR_1 ) { this . VAR_1 = VAR_1 ; <START> return this ; <END> }
<|startcomment|> I want add result VAR_4 list required VAR_4 passed VAR_1 overlap ? gather set returning list <|endcomment|> public List < TYPE_1 > METHOD_1 ( TYPE_2 sess , List < TYPE_3 > VAR_1 , TYPE_4 VAR_2 , TYPE_5 resource , TYPE_6 user , TYPE_7 VAR_3 ) throws TYPE_8 , TYPE_9 { List < TYPE_1 > VAR_4 = new ArrayList < > ( ) ; for ( TYPE_3 VAR_5 : VAR_1 ) { <START> METHOD_1 ( sess , VAR_5 , VAR_2 , resource , user , VAR_3 ) ; <END> } return VAR_4 ; }
<|startcomment|> parameter sequence swapped : max VAR_1 correct <|endcomment|> public void METHOD_1 ( final byte [ ] key , final double max , final double VAR_1 , final int offset , final int count ) { <START> METHOD_2 ( VAR_2 , key , METHOD_3 ( VAR_1 ) , METHOD_3 ( max ) , VAR_3 . VAR_4 , METHOD_3 ( offset ) , <END> METHOD_3 ( count ) , VAR_5 . VAR_4 ) ; }
<|startcomment|> write ( VAR_1 ) <|endcomment|> public void write ( int b ) throws IOException { VAR_1 [ 0 ] = ( byte ) b ; <START> write ( VAR_1 , 0 , 1 ) ; <END> }
<|startcomment|> method expects VAR_1 VAR_2 parameters careful order <|endcomment|> public void METHOD_1 ( String VAR_1 ) throws TYPE_1 , TYPE_2 { try { String VAR_2 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <START> METHOD_4 ( ) . METHOD_1 ( VAR_2 , VAR_1 ) ; <END> } catch ( Exception e ) { throw new TYPE_2 ( e ) ; } }
<|startcomment|> case rethrow exception a RuntimeException <|endcomment|> private String METHOD_1 ( String VAR_1 ) { try { return TYPE_1 . METHOD_2 ( VAR_1 , TYPE_4 . TYPE_5 . toString ( ) ) ; } catch ( TYPE_3 e ) { <START> return e . getMessage ( ) ; <END> } }
<|startcomment|> o null return false <|endcomment|> public boolean contains ( Object o ) { <START> boolean contains = super . contains ( o ) ; <END> if ( ! contains && o != null ) { TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 = VAR_2 . METHOD_1 ( o , true ) ; contains = VAR_1 != null ; } return contains ; }
<|startcomment|> cast removed avoid compilation errors eclipse versions generified METHOD_3 <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! ( VAR_1 instanceof TYPE_2 ) ) { return false ; } TYPE_3 VAR_2 = ( ( TYPE_2 ) VAR_1 ) . METHOD_2 ( ) ; <START> View view = VAR_2 . METHOD_3 ( View . VAR_3 ) ; <END> return view != null && TYPE_6 . TYPE_7 . equals ( TYPE_5 . METHOD_4 ( view ) ) ; }
<|startcomment|> remove extra line <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_3 = VAR_4 . METHOD_2 ( TYPE_4 . VAR_6 ) ; VAR_1 . METHOD_3 ( VAR_3 , TYPE_5 . VAR_8 ) ; TYPE_2 VAR_9 = new TYPE_2 ( VAR_2 , TYPE_6 . TYPE_7 . VAR_12 ) ; <START> <END> String VAR_13 = VAR_2 . METHOD_4 ( ) ; VAR_1 . METHOD_5 ( 2 ) ; TYPE_3 . assertTrue ( VAR_9 . METHOD_6 ( ) ) ; VAR_1 . METHOD_7 ( ) ; TYPE_3 . METHOD_8 ( VAR_2 , VAR_13 ) ; }
<|startcomment|> I a couple assert equals give output case failure ( remember expected ) <|endcomment|> private void METHOD_1 ( Guid VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; VAR_2 . METHOD_2 ( VAR_2 . getName ( ) . METHOD_3 ( ) ) ; VAR_2 . METHOD_4 ( VAR_4 ) ; VAR_3 . METHOD_5 ( VAR_2 ) ; TYPE_1 VAR_5 = VAR_3 . get ( VAR_1 ) ; <START> assertTrue ( VAR_5 . getName ( ) . equals ( VAR_2 . getName ( ) ) && VAR_5 . METHOD_6 ( ) . equals ( VAR_2 . METHOD_6 ( ) ) ) ; <END> }
<|startcomment|> shouldn t done VAR_1 saved instead <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( VAR_1 . METHOD_2 ( ) == null ) { VAR_2 . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; } else { VAR_2 . METHOD_3 ( ) . METHOD_5 ( VAR_1 ) ; } <START> TYPE_3 . METHOD_6 ( VAR_1 ) ; <END> return VAR_1 ; }
<|startcomment|> _CODE_ work some reason ? curious a nice example new call s I ask <|endcomment|> public TYPE_7 ( String VAR_2 , String VAR_3 ) { TYPE_1 < TYPE_2 > VAR_4 = TYPE_8 < TYPE_2 > of ( new TYPE_3 ( ) ) ; TYPE_4 context = TYPE_5 . METHOD_1 ( VAR_6 ) . METHOD_2 ( VAR_2 , VAR_3 ) . METHOD_3 ( VAR_4 ) . METHOD_4 ( TYPE_4 . class ) ; VAR_7 = context . VAR_8 ( ) ; <START> VAR_9 = context . VAR_10 ( TYPE_6 . VAR_12 ) . METHOD_5 ( ) ; <END> }
<|startcomment|> VAR_2 = = false flow wrong null passed TYPE_3 throw ( want VAR_3 null case ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_2 ) { <END> METHOD_2 ( VAR_1 , STRING_1 ) ; } this . VAR_3 = new TYPE_3 ( VAR_1 ) ; VAR_4 = null ; key = null ; VAR_5 = null ; return this ; }
<|startcomment|> protected want allow call VAR_2 <|endcomment|> <START> public boolean METHOD_1 ( Class < T > VAR_1 ) { <END> if ( String . VAR_2 . METHOD_2 ( VAR_1 ) || Integer . VAR_2 . METHOD_2 ( VAR_1 ) || Boolean . VAR_2 . METHOD_2 ( VAR_1 ) ) { return true ; } return false ; }
<|startcomment|> replace boris <|endcomment|> private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( 4 ) ; VAR_1 . add ( new TYPE_1 ( STRING_1 , STRING_2 , STRING_3 ) ) ; VAR_1 . add ( new TYPE_1 ( STRING_4 , STRING_5 , <START> STRING_6 ) ) ; <END> VAR_1 . add ( new TYPE_1 ( STRING_7 , STRING_8 , STRING_9 ) ) ; VAR_1 . add ( new TYPE_1 ( STRING_10 , STRING_11 , STRING_12 ) ) ; return VAR_1 ; }
<|startcomment|> separate incerement check <|endcomment|> protected void METHOD_1 ( ) { <START> VAR_1 = VAR_1 ++ % VAR_2 ; <END> }
<|startcomment|> VAR_2 forEach ( ) Collections <|endcomment|> public void add ( TYPE_1 VAR_1 ) { super . add ( VAR_1 ) ; <START> VAR_2 . stream ( ) . forEach ( VAR_3 - > VAR_3 . METHOD_1 ( this , VAR_1 ) ) ; <END> }
<|startcomment|> new ArrayList < String > ( ) ; - > new ArrayList < > ( ) ; <|endcomment|> public TYPE_3 ( Map < String , Set < String > > VAR_2 ) { this . VAR_2 = VAR_2 ; <START> List < String > VAR_3 = new ArrayList < String > ( ) ; <END> VAR_3 . addAll ( VAR_2 . keySet ( ) ) ; METHOD_1 ( TYPE_1 . METHOD_2 ( TYPE_2 . class ) . METHOD_3 ( ) , VAR_3 ) ; }
<|startcomment|> VAR_2 variable redundant <|endcomment|> private static String METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = TYPE_3 . VAR_4 ; <START> if ( VAR_1 != null ) { <END> VAR_2 = ! VAR_1 . METHOD_2 ( ) ? TYPE_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , TYPE_3 . VAR_4 ) : "" ; } return VAR_2 ; }
<|startcomment|> super ( source ) ; instead METHOD_1 method ( I _CODE_ wrong ) <|endcomment|> public TYPE_1 ( TYPE_1 source ) { <START> this . METHOD_1 ( source ) ; <END> }
<|startcomment|> create a new map - operation call moving VAR_3 doesn t difference <|endcomment|> public TYPE_7 ( ) { final TYPE_1 logger = this . logger ( ) ; final int VAR_2 = METHOD_1 ( ) ; VAR_3 = new TYPE_2 [ ] { new TYPE_3 ( VAR_2 , logger , this ) , new TYPE_4 ( VAR_2 , logger , this ) , new TYPE_5 ( logger , this ) , <START> new TYPE_6 ( logger , this ) <END> } ; }
<|startcomment|> single line - statements project s a nitty point I d prefer change curly braces <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Object VAR_2 = VAR_1 . get ( VAR_3 ) ; <START> if ( VAR_2 instanceof String ) return TYPE_1 . parse ( VAR_2 . toString ( ) ) ; <END> return TYPE_1 . METHOD_2 ( ( long ) VAR_2 ) ; }
<|startcomment|> getters need public ? I _CODE_ ( ) others default package access <|endcomment|> <START> public TYPE_1 [ ] METHOD_1 ( ) <END> { return VAR_1 ; }
<|startcomment|> _CODE_ don t add tables wastes CPU cycles <|endcomment|> public void METHOD_1 ( ) throws IOException { e = TYPE_1 . builder ( VAR_1 ) <START> . METHOD_2 ( ) <END> . METHOD_3 ( STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 ) . build ( ) ; VAR_2 = e . VAR_3 ( VAR_1 . state ( ) ) ; }
<|startcomment|> _CODE_ - style tests assign variables defined ( final want : - ) _CODE_ won t create instance class run eligible garbage collection run <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> VAR_2 = new TYPE_2 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; }
<|startcomment|> I tend agree I VAR_3 other places times extended validators approach simplify instantiation <|endcomment|> protected boolean METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) { return false ; } if ( ! METHOD_3 ( ) && ! TYPE_1 . METHOD_4 ( METHOD_5 ( ) , STRING_1 , METHOD_5 ( ) . getStatus ( ) ) ) { METHOD_6 ( TYPE_4 . VAR_2 ) ; return false ; } <START> TYPE_2 VAR_3 = TYPE_3 . METHOD_7 ( new TYPE_2 ( this , <END> getParameters ( ) . METHOD_8 ( ) , getParameters ( ) . METHOD_9 ( ) , METHOD_10 ( ) ) ) ; return VAR_3 . METHOD_1 ( ) ; }
<|startcomment|> I prefer code done _CODE_ constructor a Map < String TYPE_1 > detected moment SNI key manager mapping <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 ) { try { <START> TYPE_2 VAR_2 = VAR_3 . get ( VAR_1 ) ; <END> if ( VAR_2 != null ) { TYPE_1 VAR_4 = TYPE_1 . getInstance ( TYPE_1 . METHOD_2 ( ) ) ; VAR_4 . METHOD_3 ( VAR_2 ) ; return VAR_4 ; } return null ; } catch ( TYPE_3 | TYPE_4 e ) { throw new RuntimeException ( e ) ; } }
<|startcomment|> I suggest putting a finally block <|endcomment|> public TYPE_1 METHOD_1 ( int VAR_1 , String source , int offset , int length , int VAR_2 , String VAR_3 ) { boolean VAR_4 = this . VAR_5 ; this . VAR_5 = true ; TYPE_1 VAR_6 = format ( VAR_1 , source , new TYPE_2 [ ] { new TYPE_3 ( offset , length ) } , VAR_2 , VAR_3 ) ; <START> this . VAR_5 = VAR_4 ; <END> return VAR_6 ; }
<|startcomment|> a property <|endcomment|> public < TYPE_1 , TYPE_2 > TYPE_3 < TYPE_1 , TYPE_2 > METHOD_1 ( String VAR_1 ) { <START> TYPE_3 < TYPE_1 , TYPE_2 > cache = VAR_2 . METHOD_1 ( VAR_1 , TYPE_4 . NONE ) ; <END> if ( cache == null ) { throw log . VAR_4 ( Collections . VAR_5 ( VAR_1 ) ) ; } return cache ; }
<|startcomment|> allow type = = null ? doesn t sense a type info add a precondition check forbid <|endcomment|> public static Object METHOD_1 ( String value , TYPE_1 type ) { <START> if ( type == null || type == TYPE_1 . VAR_1 ) { <END> return null ; } Object VAR_2 = TYPE_2 . METHOD_2 ( type . VAR_3 ( ) , value ) ; assert ( TYPE_2 . METHOD_3 ( VAR_2 , type . VAR_3 ( ) ) ) ; return VAR_2 ; }
<|startcomment|> doppelt <|endcomment|> public void METHOD_1 ( ) throws IOException { String VAR_1 = STRING_1 ; TYPE_1 VAR_2 = TYPE_1 . from ( VAR_1 ) ; assertEquals ( VAR_2 . getClass ( ) , TYPE_2 . class ) ; <START> assertEquals ( VAR_2 . getClass ( ) , TYPE_2 . class ) ; <END> }
<|startcomment|> please user assertEquals <|endcomment|> public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = VAR_2 . METHOD_2 ( TYPE_3 . VAR_4 , TYPE_2 . VAR_6 ) ; assertNotNull ( VAR_1 ) ; assertEquals ( 1 , VAR_1 . size ( ) ) ; for ( TYPE_1 VAR_7 : VAR_1 ) { <START> assertTrue ( VAR_7 . METHOD_3 ( ) == TYPE_2 . VAR_6 ) ; <END> } }
<|startcomment|> path <|endcomment|> public static void METHOD_1 ( String ... path ) { VAR_1 = <START> ( path == null ) ? null : path ; <END> VAR_2 = true ; }
<|startcomment|> small style : don t braces simple statements <|endcomment|> void METHOD_1 ( Collection < String > VAR_1 , Collection < TYPE_1 > VAR_2 ) { synchronized ( VAR_3 ) { VAR_4 . addAll ( VAR_1 ) ; VAR_5 . addAll ( VAR_2 ) ; } <START> if ( ! VAR_1 . isEmpty ( ) ) { <END> METHOD_2 ( VAR_6 ) ; } }
<|startcomment|> key TYPE_1 <|endcomment|> public static synchronized String METHOD_1 ( String name ) { <START> final String VAR_1 = METHOD_2 ( name ) ; <END> if ( TYPE_1 . get ( VAR_1 ) == null ) { METHOD_3 ( VAR_1 ) ; } return TYPE_1 . get ( VAR_1 ) ; }
<|startcomment|> case page loading fail exception removed TYPE_5 METHOD_6 ( ) instead <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 input ) { super . METHOD_1 ( VAR_1 , input ) ; TYPE_3 VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 != null ) { TYPE_4 VAR_3 = TYPE_5 . METHOD_4 ( VAR_2 ) ; final TYPE_6 VAR_4 = VAR_3 . METHOD_5 ( ) ; try { VAR_5 = TYPE_5 . METHOD_6 ( VAR_4 ) ; } catch ( TYPE_7 e ) { <START> throw new RuntimeException ( e ) ; <END> } } }
<|startcomment|> create a new object time method called wanted ? d store object return ( static field ) <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 , TYPE_2 monitor ) throws TYPE_3 { <START> return new TYPE_4 ( VAR_2 ) ; <END> }
<|startcomment|> METHOD_2 ( Object boolean ) a java 6 API need define VAR_2 super METHOD_1 ( ) - 1 instead <|endcomment|> public long METHOD_1 ( ) { if ( VAR_1 == null ) return 0 ; Long VAR_2 = Long . valueOf ( super . METHOD_1 ( ) ) ; <START> TYPE_1 < Long > VAR_3 = VAR_1 . METHOD_2 ( VAR_2 , true ) ; <END> return VAR_3 . isEmpty ( ) ? 0 : VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) ; }
<|startcomment|> initialization list generics case empty generic - type placeholder compiler able auto - detect type <|endcomment|> public TYPE_1 ( String VAR_2 ) { VAR_3 = new StringBuilder ( VAR_2 ) ; <START> parameters = new ArrayList ( ) ; <END> }
<|startcomment|> needed ? throws TYPE_4 <|endcomment|> public long METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = METHOD_2 ( VAR_1 ) ; Path VAR_3 = new Path ( VAR_4 , VAR_2 ) ; try { try { TYPE_2 VAR_5 = VAR_6 . METHOD_3 ( VAR_3 ) ; return VAR_5 . METHOD_4 ( ) ; } catch ( final TYPE_3 ex ) { } return - 1 ; <START> } catch ( TYPE_4 e ) { <END> throw new TYPE_5 ( STRING_1 + VAR_3 , e ) ; } catch ( IOException e ) { throw new TYPE_6 ( STRING_2 + VAR_3 , e ) ; } }
<|startcomment|> equals instead = = ( 2 other conditions ) : TYPE_2 VAR_3 equals ( VAR_1 ) ; <|endcomment|> private boolean METHOD_1 ( ) { TYPE_1 cluster = METHOD_2 ( ) . METHOD_3 ( ) ; if ( cluster == null ) { return false ; } TYPE_2 VAR_1 = cluster . VAR_2 ( ) ; return <START> ( VAR_1 == TYPE_2 . VAR_3 ) || <END> ( VAR_1 == TYPE_2 . VAR_4 ) || ( VAR_1 == TYPE_2 . VAR_5 ) ; }
<|startcomment|> substring ( VAR_1 ) equivalent shorter write <|endcomment|> private static String METHOD_1 ( String name ) { int VAR_1 = name . VAR_2 ( CHAR_1 ) ; return 0 < VAR_1 ? <START> name . substring ( VAR_1 , name . length ( ) ) : <END> "" ; }
<|startcomment|> more consistent a - op other methods <|endcomment|> public void METHOD_1 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> }
<|startcomment|> METHOD_8 returns long <|endcomment|> private void METHOD_1 ( ) { if ( ! METHOD_2 ( ) ) { METHOD_3 ( - 1 ) ; return ; } if ( VAR_1 . METHOD_4 ( ) == null ) { String from = METHOD_5 ( ) . METHOD_6 ( ) ; String to = METHOD_7 ( ) . METHOD_6 ( ) ; <START> Long count <END> = TYPE_1 . METHOD_8 ( to ) - TYPE_1 . METHOD_8 ( from ) + 1 ; METHOD_3 ( count . VAR_2 ( ) ) ; } }
<|startcomment|> cast necessary <|endcomment|> public void METHOD_1 ( ) { <START> buffer = ( TYPE_1 ) new TYPE_1 ( VAR_1 , VAR_2 ) ; <END> }
<|startcomment|> sense check minimum values <|endcomment|> private boolean METHOD_1 ( TYPE_1 position ) { <START> return VAR_1 && ! position . VAR_2 ( ) || position . VAR_3 ( ) > INT_1 || position . VAR_4 ( ) > INT_2 ; <END> }
<|startcomment|> understood _CODE_ suggest small change : return new HashSet < TYPE_1 > ( asList ( TYPE_1 VAR_2 TYPE_1 VAR_3 TYPE_1 VAR_4 TYPE_1 VAR_5 TYPE_1 VAR_6 TYPE_1 VAR_7 ) ) ; <|endcomment|> public Set < TYPE_1 > METHOD_1 ( ) { Set < TYPE_1 > VAR_1 = new HashSet < TYPE_1 > ( ) ; VAR_1 . addAll ( Arrays . asList ( TYPE_1 . VAR_2 , TYPE_1 . VAR_3 , TYPE_1 . VAR_4 , TYPE_1 . VAR_5 , TYPE_1 . VAR_6 , TYPE_1 . VAR_7 ) ) ; <START> return VAR_1 ; <END> }
<|startcomment|> METHOD_2 ( ) ÊòØÂê¶ÂèØ‰ª•ÊîπÊàê static method <|endcomment|> public String METHOD_1 ( long VAR_1 ) throws TYPE_1 { TYPE_2 task = TYPE_2 . get ( VAR_1 ) ; <START> return new TYPE_3 ( ) . METHOD_2 ( task ) ; <END> }
<|startcomment|> need explicitly open transaction METHOD_7 DB transaction open automaticly <|endcomment|> <START> private void METHOD_1 ( final TYPE_1 VAR_1 ) { <END> TYPE_2 . METHOD_2 ( new TYPE_3 < TYPE_4 > ( ) { @Override public TYPE_4 METHOD_3 ( ) { VAR_1 . METHOD_4 ( METHOD_5 ( ) ) ; TYPE_5 . getInstance ( ) . METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; return null ; } } ) ; }
<|startcomment|> added a new import : org jfree util Log log object line 204 ? log error ( TYPE_4 creation exception e ) ; ? a reason 2 ways logging errors <|endcomment|> public TYPE_1 METHOD_1 ( File file ) { stream = new TYPE_2 ( new TYPE_3 ( file ) ) ; TYPE_4 VAR_1 = null ; try { VAR_1 = TYPE_5 . create ( stream ) ; } catch ( Exception e ) { <START> Log . error ( STRING_1 + e ) ; <END> } return VAR_1 . METHOD_2 ( 0 ) ; }
<|startcomment|> s current METHOD_3 ( int VAR_3 ) optional null ( API fixed t change ) s problem I m discussing problem writing new TYPE_2 ( 1234 ) a process object throw exception throw _CODE_ example require handle a _CODE_ return a class pid essentially zero data I thought dilemma suggesting feature <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null ) { TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( this . VAR_3 ) ; if ( VAR_2 != null ) { METHOD_4 ( VAR_2 ) ; } else { <START> LOG . error ( STRING_1 , this . VAR_3 ) ; <END> } } else { LOG . error ( STRING_2 ) ; } }
<|startcomment|> avoid cases <|endcomment|> public boolean METHOD_1 ( ) { <START> return ( this . VAR_1 & TYPE_1 . getValue ( ) ) == TYPE_1 . getValue ( ) ; <END> }
<|startcomment|> pref eliminate unneeded elses ( 117 120 ) returns <|endcomment|> public Map < TYPE_4 . TYPE_6 , TYPE_2 > METHOD_1 ( final boolean VAR_1 ) { if ( ! VAR_1 ) { if ( METHOD_2 ( ) ) { return Collections . VAR_2 ( ) ; <START> } else { <END> return Collections . VAR_3 ( METHOD_3 ( ) . METHOD_4 ( ) , this ) ; } } else { return METHOD_5 ( new HashSet < TYPE_4 . TYPE_5 > ( ) ) ; } }
<|startcomment|> parser _CODE_ ( ) detect JSON type <|endcomment|> public boolean METHOD_1 ( ) throws IOException { METHOD_2 ( ) ; boolean value ; try { <START> value = parser . VAR_1 ( ) ; <END> } catch ( TYPE_1 e ) { value = Boolean . VAR_2 ( parser . VAR_3 ( ) ) ; } METHOD_3 ( ) ; return value ; }
<|startcomment|> methods public <|endcomment|> <START> boolean METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> done _CODE_ example _CODE_ - > _CODE_ ( ) addition add values _CODE_ java _CODE_ properties <|endcomment|> <START> public String METHOD_1 ( ) { <END> if ( VAR_1 == null ) { } else if ( VAR_1 . equals ( TYPE_1 . VAR_3 ) ) { return VAR_4 . METHOD_2 ( ) ; } else if ( VAR_1 . equals ( TYPE_1 . VAR_5 ) ) { return VAR_4 . METHOD_3 ( ) ; } else if ( VAR_1 . equals ( TYPE_1 . VAR_6 ) ) { return VAR_4 . METHOD_4 ( ) ; } return VAR_4 . METHOD_5 ( ) ; }
<|startcomment|> sounds forgot remove <|endcomment|> public void METHOD_1 ( ) { <START> if ( ! this . VAR_1 ) { <END> synchronized ( this ) { if ( ! this . VAR_1 ) { int VAR_2 = this . configuration . getProperty ( STRING_1 , 1 ) ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { METHOD_2 ( ) ; } this . VAR_1 = true ; } } } }
<|startcomment|> perform test TYPE_4 s class ? strange I relates goal commit <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { List < TYPE_3 > VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 , VAR_1 ) ; for ( final TYPE_3 VAR_5 : VAR_3 ) { <START> if ( ! VAR_4 . getClass ( ) . equals ( TYPE_4 . class ) || METHOD_4 ( VAR_5 ) ) { <END> METHOD_5 ( VAR_5 ) ; } } this . METHOD_6 ( ) ; }
<|startcomment|> I return Arrays asList ( ) need create wrap ArrayList <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { return new ArrayList < TYPE_1 > ( <START> Arrays . asList ( new org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_2 ( ) { <END> @Override public Class < ? extends TYPE_1 > METHOD_2 ( ) { return org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_2 . class ; } } ) ) ; }
<|startcomment|> necessary crate TYPE_6 a _CODE_ GSSAPI mech requires a TYPE_1 METHOD_1 SASL client passed configuration <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { final TYPE_3 config = METHOD_2 ( VAR_1 ) ; <START> TYPE_1 . METHOD_3 ( VAR_1 , new TYPE_4 < TYPE_5 > ( ) { <END> public TYPE_5 run ( ) throws Exception { VAR_2 = new TYPE_6 ( config , true ) ; return null ; } } ) ; VAR_3 = VAR_2 . METHOD_4 ( VAR_4 ) ; }
<|startcomment|> shouldn t copy VAR_3 ? I currently empty code implies want add another selector base VAR_2 <|endcomment|> <START> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> List < TYPE_3 > VAR_2 = new ArrayList < > ( VAR_3 . size ( ) + 1 ) ; VAR_2 . add ( TYPE_4 . METHOD_2 ( VAR_1 ) ) ; return TYPE_5 . request ( ) . METHOD_3 ( TYPE_6 . VAR_5 , VAR_6 ) . METHOD_4 ( VAR_2 ) . build ( ) ; }
<|startcomment|> some concerns file I some defensive code possibly ways code example blocks defense delegation methods need <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { super . METHOD_1 ( VAR_1 , VAR_2 ) ; <START> try { <END> METHOD_2 ( VAR_1 , VAR_2 ) ; } catch ( Exception e ) { } }
<|startcomment|> merge lines <|endcomment|> public static TYPE_1 METHOD_1 ( Throwable VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> return new TYPE_1 ( VAR_1 ) ; <END> }
<|startcomment|> 5 ? default s a good reason <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws Exception { <START> TYPE_3 VAR_3 = TYPE_4 . get ( ) . METHOD_2 ( new TYPE_5 ( 5 ) , null ) ; <END> TYPE_6 < TYPE_8 . TYPE_9 > VAR_4 = new TYPE_6 < TYPE_8 . TYPE_9 > ( VAR_1 ) ; VAR_4 . write ( VAR_1 , VAR_2 , VAR_3 ) ; }
<|startcomment|> - I meant build return collection _every_ invocation storing a field s place calling method caching doesn t buy <|endcomment|> public Collection < String > METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = new HashSet < > ( VAR_2 . keySet ( ) ) ; <END> VAR_3 . forEach ( args - > VAR_1 . addAll ( args . VAR_4 ( ) ) ) ; } return Collections . VAR_5 ( VAR_1 ) ; }
<|startcomment|> hmmm I m thinking want turn a logger warning instead I d error program proceed case consumer code responsible reacting a null return : piece code cope perfectly <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { <START> logger . error ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } return VAR_2 ; }
<|startcomment|> technically API violation I t find usages IDE recommendation ? I don t needed swap remain compliance ( clarify surrounding diff preview confused ) <|endcomment|> <START> void METHOD_1 ( TYPE_1 VAR_1 , char VAR_2 ) { <END> this . input = VAR_1 ; this . VAR_3 = VAR_2 ; }
<|startcomment|> doesn t call org infinispan configuration cache _CODE_ ( org infinispan eviction TYPE_5 ) missing completely default VAR_1 <|endcomment|> public Builder < TYPE_1 > METHOD_1 ( TYPE_2 context , TYPE_3 model ) throws TYPE_4 { TYPE_5 VAR_1 = TYPE_6 . METHOD_2 ( TYPE_7 . METHOD_3 ( ) . METHOD_4 ( context , model ) , TYPE_5 . class ) ; if ( VAR_1 . METHOD_5 ( ) ) { this . builder . type ( TYPE_9 . VAR_3 ) . size ( TYPE_8 . METHOD_3 ( ) . METHOD_4 ( context , model ) . METHOD_6 ( ) ) ; <START> } <END> return this ; }
<|startcomment|> TYPE_2 < Boolean > avoid raw types <|endcomment|> public void METHOD_1 ( TYPE_1 connection ) { String id = connection . id ( ) ; try { <START> TYPE_2 VAR_1 = VAR_2 . remove ( id ) ; <END> if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( true ) ; } } finally { VAR_3 . remove ( id ) ; } }
<|startcomment|> other words : throw exception fail test parsing XML fails <|endcomment|> public void METHOD_1 ( ) throws IOException { try { TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) ) ; METHOD_3 ( STRING_1 , TYPE_2 . METHOD_4 ( VAR_1 ) ) ; <START> } catch ( Exception e ) { e . VAR_2 ( ) ; } <END> }
<|startcomment|> fix formatting run formatter phase maven VAR_3 = = null doesnt VAR_1 METHOD_2 checked METHOD_3 returns null File a directory return empty directory doesn t files <|endcomment|> public static boolean METHOD_1 ( File VAR_1 , String VAR_2 ) { if ( VAR_1 == null ) { return false ; } if ( ! VAR_1 . METHOD_2 ( ) ) { return false ; } <START> File [ ] VAR_3 = VAR_1 . METHOD_3 ( ) ; <END> if ( VAR_3 == null ) { return false ; } for ( File f : VAR_3 ) { if ( f . getName ( ) . equals ( VAR_2 ) ) { return true ; } } return false ; }
<|startcomment|> Collections addAll ( VAR_2 VAR_1 ) <|endcomment|> public void METHOD_1 ( String ... VAR_1 ) { <START> this . VAR_2 . addAll ( Arrays . asList ( VAR_1 ) ) ; <END> }
<|startcomment|> I check avoided check VAR_2 ! = null <|endcomment|> private Long METHOD_1 ( String VAR_1 ) { <START> if ( ! METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) { <END> return null ; } TYPE_1 VAR_2 = VAR_3 . METHOD_4 ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_2 = VAR_4 . METHOD_4 ( VAR_1 ) ; } if ( VAR_2 != null ) { return VAR_2 . METHOD_5 ( ) ; } return null ; }
<|startcomment|> typo : VAR_1 instead VAR_2 <|endcomment|> public TYPE_1 METHOD_1 ( float VAR_1 ) { <START> if ( VAR_2 < 0 ) throw new IllegalArgumentException ( STRING_1 ) ; <END> this . VAR_1 = VAR_1 ; return this ; }
<|startcomment|> needed <|endcomment|> public synchronized void METHOD_1 ( Response response ) { long length = response . VAR_1 ( ) . METHOD_2 ( TYPE_3 . TYPE_4 . METHOD_3 ( ) ) ; if ( length > VAR_2 ) { response . VAR_3 ( new TYPE_2 ( ) ) ; } <START> METHOD_4 ( ) ; <END> }
<|startcomment|> return statement throw exception please remove - catch block <|endcomment|> public TYPE_1 build ( ) { try { return VAR_1 ; <START> } catch ( Exception e ) { <END> return METHOD_1 ( e ) ; } }
<|startcomment|> sorted map ? _CODE_ sorted ? <|endcomment|> <START> public static TYPE_1 < String , TYPE_2 > METHOD_1 ( ) { <END> return Collections . VAR_1 ( VAR_2 ) ; }
<|startcomment|> [ minor ] split asserts add a message showing offending <|endcomment|> protected void METHOD_1 ( TYPE_1 project ) { assertNotNull ( project . getId ( ) ) ; assertEquals ( project . toString ( ) , client . VAR_1 ( ) . METHOD_2 ( project . getId ( ) ) . toString ( ) ) ; <START> assertTrue ( project . VAR_2 ( ) != null && project . VAR_2 ( ) != TYPE_1 . TYPE_2 . VAR_4 ) ; <END> }
<|startcomment|> please call _CODE_ constructors guid <|endcomment|> public TYPE_3 ( Long id , String name , TYPE_1 VAR_2 ) { <START> super ( id , TYPE_2 . create ( ) , name , TYPE_4 . VAR_4 , VAR_2 ) ; <END> }
<|startcomment|> I deprecate sufficient log a VAR_2 <|endcomment|> public void METHOD_1 ( final boolean VAR_1 ) { <START> LOG . VAR_2 ( STRING_1 ) ; <END> }
<|startcomment|> false <|endcomment|> public void METHOD_1 ( String message ) { boolean VAR_1 = message != null ; if <START> ( VAR_1 ) { <END> VAR_2 . setText ( message ) ; } VAR_2 . METHOD_2 ( VAR_1 ) ; }
<|startcomment|> parameter removed <|endcomment|> public void close ( ) throws InterruptedException { <START> close ( false , false ) ; <END> }
<|startcomment|> class a member variable called VAR_1 incur a data race METHOD_1 easily fixable making VAR_1 a parameter METHOD_1 I realize s debug - code <|endcomment|> protected void METHOD_1 ( TYPE_1 node , StringBuilder sb ) { for ( int i = 0 ; i < VAR_1 ; i ++ ) { sb . append ( STRING_1 ) ; } sb . append ( node . VAR_2 ( ) + STRING_2 ) ; VAR_1 ++ ; if ( node . VAR_3 ( ) > 0 ) { METHOD_1 ( node . VAR_4 ( 0 ) , sb ) ; } <START> } <END>
<|startcomment|> condition needed <|endcomment|> public void update ( int VAR_1 ) { status . VAR_2 ( super . update ( VAR_1 , status . VAR_3 ( ) ) ) ; <START> if ( logger . VAR_4 ( ) ) { <END> logger . debug ( STRING_1 , VAR_1 == 0 ? STRING_2 : STRING_3 , METHOD_1 ( VAR_1 ) ) ; } }
<|startcomment|> VAR_1 < 0 <|endcomment|> private int METHOD_1 ( ) throws TYPE_1 { <START> if ( VAR_1 == - 1 ) { <END> VAR_1 = 0 ; while ( VAR_1 < VAR_2 && METHOD_2 ( VAR_1 ) != 0 ) { VAR_1 ++ ; } } return VAR_1 ; }
<|startcomment|> VAR_1 METHOD_2 ( ) a supplier called trace logging enabled suggestionlogger trace ( STRING_1 ( ) - > VAR_2 ( ) - > VAR_1 METHOD_2 ( ) ) ; <|endcomment|> public TYPE_1 METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) == 0 ) { return null ; } <START> logger . trace ( STRING_1 , VAR_2 , VAR_1 . METHOD_2 ( ) ) ; <END> TYPE_1 VAR_3 = VAR_4 . METHOD_3 ( VAR_1 , VAR_2 , VAR_5 , msg - > VAR_6 . METHOD_4 ( VAR_2 , STRING_2 + msg ) ) ; VAR_1 = new TYPE_2 ( TYPE_3 . VAR_8 ) ; return VAR_3 ; }
<|startcomment|> isn t iterator ( ) excluding expired tombstones <|endcomment|> public int size ( ) { int size = 0 ; for ( Iterator < TYPE_1 < TYPE_2 , TYPE_3 > > VAR_1 = iterator ( ) ; VAR_1 . hasNext ( ) ; ) { <START> if ( VAR_1 . next ( ) . getValue ( ) == null ) continue ; <END> if ( ++ size == Integer . VAR_2 ) return Integer . VAR_2 ; } return size ; }
<|startcomment|> I d prefer order TYPE_1 METHOD_2 ( ) return null don t NPE <|endcomment|> public static File METHOD_1 ( Context context , String VAR_1 ) { final String VAR_2 ; <START> if ( TYPE_1 . METHOD_2 ( ) . equals ( TYPE_1 . TYPE_3 ) <END> && context . VAR_3 ( ) != null ) { VAR_2 = context . VAR_3 ( ) . getPath ( ) ; } else { VAR_2 = context . VAR_4 ( ) . getPath ( ) ; } return new File ( VAR_2 + File . VAR_5 + VAR_1 ) ; }
<|startcomment|> mark method private class <|endcomment|> <START> String METHOD_1 ( TYPE_1 uri ) <END> { if ( uri . VAR_1 ( ) != null ) { return uri . VAR_1 ( ) ; } else if ( uri . VAR_2 ( ) == null ) { return uri . VAR_3 ( ) ; } throw new IllegalArgumentException ( STRING_1 ) ; }
<|startcomment|> I initialization more terse initialize _CODE_ ternary operator pass TYPE_2 javanew TYPE_2 ( VAR_1 isPresent ( ) ? new TYPE_3 ( VAR_1 ( ) ) : new TYPE_4 ( key ) ) <|endcomment|> private TYPE_1 METHOD_1 ( Class < ? extends View > key ) { <START> return ( VAR_1 != null ) ? new TYPE_2 ( new TYPE_3 ( VAR_1 ) ) <END> : new TYPE_2 ( new TYPE_4 ( key ) ) ; }
<|startcomment|> agreed letting users choose system protocols browser I suppose condition <|endcomment|> public boolean METHOD_1 ( final Object element ) { boolean result = super . METHOD_1 ( element ) ; if ( result ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( element ) ; result = ( TYPE_3 . METHOD_3 ( VAR_1 ) && <START> ! TYPE_4 . METHOD_4 ( ( TYPE_5 ) VAR_1 ) && <END> ! TYPE_4 . METHOD_5 ( ( TYPE_5 ) VAR_1 ) ) ; } return result ; }
<|startcomment|> minor : consider another helper method METHOD_3 ( ) focus interesting bit ( VAR_1 execute ( ) ) a side note executing main thread doesn t a requirement _CODE_ reason more proper call execute main thread [ 0 ] a normal _CODE_ I [ 0 ] ( params ) <|endcomment|> public void METHOD_1 ( ) throws Throwable { <START> TYPE_1 . METHOD_2 ( ) . METHOD_3 ( new TYPE_2 ( ) { <END> @Override public void run ( ) { VAR_1 . execute ( ) ; } } ) ; assertThat ( VAR_2 . METHOD_4 ( ) , is ( true ) ) ; }
<|startcomment|> don t need call toString ( ) <|endcomment|> public static void METHOD_1 ( TYPE_1 config ) { String VAR_1 = config . getString ( VAR_2 ) ; if ( VAR_1 . equals ( TYPE_3 . TYPE_4 . toString ( ) ) ) log . warn ( STRING_1 + STRING_2 , <START> VAR_2 , TYPE_3 . TYPE_4 . toString ( ) , <END> TYPE_3 . VAR_4 ) ; }
<|startcomment|> I remove method METHOD_2 VAR_13 static <|endcomment|> public TYPE_3 ( String source , File VAR_2 , boolean VAR_3 , int VAR_4 , boolean VAR_5 , TYPE_1 VAR_6 ) { this . VAR_7 = source ; this . VAR_8 = INT_1 ; this . VAR_9 = INT_1 ; this . VAR_6 = VAR_6 ; this . VAR_10 = System . VAR_11 ( ) ; this . VAR_12 = System . currentTimeMillis ( ) ; METHOD_1 ( VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; <START> VAR_13 = TYPE_2 . METHOD_2 ( ) ; <END> }
<|startcomment|> toString ( ) needed AFAIK <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { writer . VAR_2 ( STRING_1 ) ; writer . VAR_3 ( STRING_2 , String . format ( STRING_3 , <START> VAR_1 . getId ( ) . METHOD_2 ( ) . toString ( ) ) ) ; <END> writer . VAR_4 ( ) ; }
<|startcomment|> shouldn t need METHOD_1 <|endcomment|> public TYPE_3 ( TYPE_1 < ? > VAR_2 , List < TYPE_2 > VAR_3 ) { VAR_4 = VAR_2 ; <START> VAR_5 = METHOD_1 ( ImmutableList . VAR_6 ( VAR_3 ) ) ; <END> }
<|startcomment|> case ? I entry VAR_1 registrations <|endcomment|> protected boolean METHOD_1 ( final String VAR_1 ) { <START> return VAR_2 . containsKey ( VAR_1 ) && ! VAR_2 . get ( VAR_1 ) . isEmpty ( ) ; <END> }
<|startcomment|> synchronized removed ? method calling METHOD_1 overload sync ed <|endcomment|> <START> public synchronized Class < ? > METHOD_1 ( String name , byte [ ] VAR_1 ) { <END> return METHOD_1 ( name , METHOD_2 ( name ) , VAR_1 ) ; }
<|startcomment|> brackets { } <|endcomment|> public boolean METHOD_1 ( TYPE_1 item ) { if ( item . VAR_1 ( ) == VAR_2 . R . id . VAR_3 ) { METHOD_2 ( ) ; <START> if ( METHOD_3 ( ) . METHOD_4 ( ) && VAR_4 . METHOD_5 ( ) ) <END> METHOD_6 ( ( ( TYPE_2 ) VAR_4 ) . METHOD_7 ( ) ) ; return true ; } return false ; }
<|startcomment|> super ( ignore ) : : consistency consider e typically nested catch blocks e enclosing block <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; try { return VAR_2 != null ? TYPE_1 . METHOD_3 ( VAR_2 ) : null ; } catch ( IOException <START> ex ) { <END> throw new TYPE_4 ( ex ) ; } }
<|startcomment|> check trailing Path VAR_5 necessary ? TYPE_1 VAR_4 property supposed a trailing Path VAR_5 <|endcomment|> private String METHOD_1 ( String path ) { String VAR_1 = VAR_2 != null ? VAR_2 . get ( TYPE_1 . VAR_4 ) : null ; VAR_1 = VAR_1 == null ? "" : VAR_1 . trim ( ) ; if ( VAR_1 . length ( ) == 0 ) { return null ; } <START> return VAR_1 . METHOD_2 ( VAR_1 . length ( ) - 1 ) == Path . VAR_5 ? VAR_1 + path : VAR_1 + Path . VAR_5 + path ; <END> }
<|startcomment|> null case <|endcomment|> protected void METHOD_1 ( int VAR_1 , byte [ ] VAR_2 ) throws IOException { int VAR_3 = ( VAR_2 == null ) ? 0 : VAR_2 . length ; METHOD_2 ( VAR_1 , VAR_3 ) ; <START> VAR_4 . write ( VAR_2 ) ; <END> }
<|startcomment|> extra else statement please remove <|endcomment|> private void METHOD_1 ( long VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_2 == null || VAR_2 . getType ( ) == TYPE_3 . VAR_4 ) { throw new RuntimeException ( STRING_1 + VAR_1 + STRING_2 ) ; } else if ( VAR_2 . METHOD_2 ( ) ) { throw new TYPE_2 ( ) ; } <START> } <END>
<|startcomment|> space comma - need pass source duration <|endcomment|> private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 source ) { long VAR_2 = source . VAR_3 ( ) ; long VAR_4 = source . VAR_5 ( ) ; VAR_1 . METHOD_2 ( VAR_2 ) ; VAR_1 . METHOD_3 ( VAR_4 ) ; <START> VAR_1 . VAR_6 . update ( source . VAR_6 . METHOD_4 ( ) , source . VAR_6 . METHOD_5 ( ) , <END> VAR_4 ) ; METHOD_6 ( VAR_1 , source ) ; }
<|startcomment|> needs line 91 METHOD_5 return null ( line 133 ) future complete <|endcomment|> @Override protected void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( ( response , t ) - > { if ( t != null ) { VAR_1 . METHOD_4 ( t ) ; } else { TYPE_2 value = null ; try { value = METHOD_5 ( response , VAR_2 ) ; } catch ( Throwable VAR_3 ) { METHOD_6 ( VAR_3 ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; } <START> if ( value != null ) VAR_1 . METHOD_7 ( value ) ; <END> } return null ; } ) ; }
<|startcomment|> ( ! VAR_1 ) { / / <|endcomment|> public TYPE_1 METHOD_1 ( boolean VAR_1 , int VAR_2 ) { TYPE_1 t = VAR_3 . METHOD_2 ( VAR_1 , VAR_2 ) ; <START> try { <END> VAR_4 . set ( t ) ; } catch ( TYPE_2 VAR_5 ) { t . VAR_6 ( ) ; throw VAR_5 ; } return t ; }
<|startcomment|> thread safety ? I mistaken code snippet more thread check condition receive false ( ) method execute code block reason blocking _CODE_ method <|endcomment|> TYPE_1 METHOD_1 ( ) { final TYPE_2 < String , String > t = new TYPE_2 < String , String > ( METHOD_2 ( ) ) ; if ( ! VAR_1 . contains ( t ) ) { TYPE_1 child = METHOD_3 ( ) ; VAR_1 . put ( t , child ) ; <START> return child ; <END> } else return VAR_1 . get ( t ) ; }
<|startcomment|> i d METHOD_1 VAR_4 instead <|endcomment|> public void METHOD_1 ( String message ) { VAR_1 . METHOD_2 ( getString ( R . string . VAR_2 ) ) ; VAR_3 . METHOD_3 ( 1 ) ; <START> VAR_4 . METHOD_4 ( ) ; <END> }
<|startcomment|> yup incorrect I failed logic public ByteBuffer [ ] METHOD_1 ( ) gonna change <|endcomment|> public ByteBuffer [ ] METHOD_1 ( int index , int length ) { if ( VAR_1 . METHOD_2 ( ) == 1 && VAR_2 . METHOD_2 ( ) == 1 ) { return new ByteBuffer [ ] { VAR_1 . METHOD_3 ( ) , VAR_2 . METHOD_3 ( ) } ; } <START> return TYPE_1 . METHOD_4 ( VAR_1 . METHOD_1 ( ) , VAR_2 . METHOD_1 ( ) , ByteBuffer . VAR_3 ) ; <END> }
<|startcomment|> instance - level lock suggestion s implemented overkill <|endcomment|> <START> public void METHOD_1 ( Set < String > VAR_1 ) { <END> this . VAR_1 = new TYPE_1 < > ( VAR_1 ) ; }
<|startcomment|> method overridden a subclass provide a behavior ? method protected supposed overridden package <|endcomment|> <START> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return true ; }
<|startcomment|> casting ArrayList brittle return List < > instead <|endcomment|> private ArrayList < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <START> return ( ArrayList < TYPE_1 > ) VAR_2 . METHOD_2 ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ; <END> }
<|startcomment|> missed previous review needs updating <|endcomment|> <START> public String METHOD_1 ( ) { <END> StringBuilder VAR_1 = new StringBuilder ( ) ; VAR_1 . append ( STRING_1 ) ; if ( METHOD_2 ( TYPE_1 . VAR_3 ) ) { VAR_1 . append ( STRING_2 ) ; VAR_1 . append ( STRING_3 ) ; VAR_1 . append ( STRING_4 ) ; } else { VAR_1 . append ( STRING_5 ) ; VAR_1 . append ( STRING_6 ) ; VAR_1 . append ( STRING_7 ) ; } return VAR_1 . toString ( ) ; }
<|startcomment|> a race corruption time ? change fine I understand actual issue current code corruption happening <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 msg , TYPE_3 VAR_1 ) { int size = msg . VAR_2 ( ) ; TYPE_1 buf = VAR_1 . METHOD_2 ( size , size ) ; try { <START> msg . VAR_3 ( new TYPE_4 ( buf ) ) ; <END> } catch ( IOException e ) { throw new RuntimeException ( e ) ; } buf . VAR_4 ( buf . VAR_5 ( ) ) ; return buf ; }
<|startcomment|> other protocols <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; TYPE_2 command = new TYPE_2 ( ) ; command . VAR_2 ( 1 ) ; command . VAR_3 ( TYPE_2 . VAR_4 ) ; command . set ( TYPE_2 . VAR_5 , 0 ) ; <START> command . set ( TYPE_2 . VAR_6 , STRING_1 ) ; <END> assertEquals ( STRING_2 , VAR_1 . METHOD_2 ( command ) ) ; }
<|startcomment|> check needed set reference null <|endcomment|> void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) { <END> VAR_1 = null ; } }
<|startcomment|> new TYPE_4 - > new RuntimeException <|endcomment|> public void METHOD_1 ( ) { try { TYPE_1 field = TYPE_2 . class . METHOD_2 ( STRING_1 ) ; field . VAR_1 ( true ) ; field . set ( this , true ) ; } catch ( TYPE_3 VAR_2 ) { <START> throw new TYPE_4 ( STRING_2 , VAR_2 ) ; <END> } }
<|startcomment|> minor : s cleaner initialized TYPE_2 Arrays asList <|endcomment|> public static boolean METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { return <START> Arrays . asList ( TYPE_2 ) . contains ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> }
<|startcomment|> hardcoded ? 1 0 <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { byte [ ] VAR_2 = VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( ) ; <START> int VAR_3 = 1 ; <END> TYPE_3 format = new TYPE_3 ( VAR_3 , VAR_2 ) ; format . VAR_4 ( VAR_1 ) ; return new TYPE_4 ( VAR_1 . METHOD_2 ( ) ) ; }
<|startcomment|> wasn t necessary I constructor I added defaults battlefield activated abilities battlefield doesn t matter I figured I d mention <|endcomment|> public TYPE_11 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , VAR_3 , new TYPE_3 [ ] { TYPE_3 . VAR_4 } , STRING_1 ) ; <START> TYPE_4 VAR_5 = new TYPE_5 ( TYPE_12 . VAR_7 , new TYPE_6 ( ) , new TYPE_7 ( ) ) ; <END> VAR_5 . METHOD_1 ( new TYPE_8 ( ) ) ; this . METHOD_2 ( ) . METHOD_3 ( new TYPE_9 ( VAR_5 , TYPE_14 . TYPE_13 , new TYPE_10 ( ) ) . setText ( STRING_2 ) ) ; }
<|startcomment|> assertEquals <|endcomment|> public void METHOD_1 ( ) { <START> assertTrue ( METHOD_2 ( STRING_1 . METHOD_3 ( ) , 0 , 10 , STRING_1 . METHOD_3 ( ) , 0 , 10 ) == 0 ) ; <END> assertTrue ( METHOD_2 ( STRING_2 . METHOD_3 ( ) , 3 , 10 , STRING_1 . METHOD_3 ( ) , 0 , 10 ) == 0 ) ; }
<|startcomment|> verificar necessidade desse else <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , Integer VAR_3 , Boolean build ) { this . VAR_1 = VAR_1 ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; if ( build ) { this . build = build ; } else { <START> this . VAR_4 = build ; <END> } }
<|startcomment|> unnecessary throws ( constructor ) <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 ) <START> throws Exception <END> { super ( ( ) - > METHOD_1 ( VAR_2 , TYPE_2 . METHOD_2 ( ) ) ) ; this . VAR_2 = VAR_2 ; }
<|startcomment|> print VAR_2 time ? command > server isn t valid <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_2 ) { <END> VAR_1 . println ( VAR_1 . METHOD_2 ( ) ) ; } return TYPE_1 . VAR_3 ; }
<|startcomment|> ( ) returns ( ) VAR_3 ( ) <|endcomment|> for ( TYPE_1 type : TYPE_1 . values ( ) ) { <START> VAR_2 . add ( type . value ( ) . VAR_3 ( ) ) ; <END> }
<|startcomment|> don t change _CODE_ ( ) return a Collection < _CODE_ > <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_1 m ) { for ( TYPE_2 action : METHOD_2 ( ) ) { TYPE_3 item ; String VAR_1 = action . VAR_2 ( ) ; if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { item = new TYPE_4 ( ) ; } else { item = new TYPE_5 ( action ) ; <START> } <END> item . VAR_3 ( m , - 1 ) ; } return m ; }
<|startcomment|> assert method argument expected actual swap file match definition <|endcomment|> public void METHOD_1 ( ) { <START> Assert . assertEquals ( TYPE_1 . METHOD_2 ( VAR_1 , false ) . <END> METHOD_3 ( VAR_2 ) . getName ( ) , VAR_1 ) ; }
<|startcomment|> suggestionreturn ( TYPE_1 < ? super T > ) VAR_2 ( VAR_1 ) ; <|endcomment|> public < T > TYPE_1 < ? super T > METHOD_1 ( Class < T > VAR_1 ) { <START> return ( TYPE_1 < T > ) VAR_2 . get ( VAR_1 ) ; <END> }
<|startcomment|> override VAR_3 _CODE_ automatically a member needs include VAR_4 <|endcomment|> public TYPE_2 . TYPE_3 . VAR_1 . client . TYPE_4 < ? > [ ] METHOD_1 ( ) { <START> return new TYPE_2 . TYPE_3 . VAR_1 . client . TYPE_4 < ? > [ ] { VAR_3 , VAR_4 } ; <END> }
<|startcomment|> ? don t want need ( ) block <|endcomment|> public void METHOD_1 ( final TYPE_1 page ) { this . page = page ; if ( page . VAR_1 ( ) instanceof TYPE_2 ) { <START> <END> } }
<|startcomment|> override line <|endcomment|> <START> @Override public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 . start ( ) ; }
<|startcomment|> drop ImmutableList VAR_3 wrapper reduces clarity expect random - access lists <|endcomment|> static < T > List < T > METHOD_1 ( List < T > list , Collection < Integer > VAR_1 ) { Set < Integer > VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; return TYPE_2 . METHOD_3 ( 0 , list . size ( ) ) . filter ( index - > ! VAR_2 . contains ( index ) ) <START> . METHOD_4 ( ImmutableList . VAR_3 ( list ) : : get ) <END> . collect ( METHOD_5 ( ) ) ; }
<|startcomment|> TYPE_1 _CODE_ RuntimeException I guess simplify <|endcomment|> private Throwable METHOD_1 ( Throwable VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) return VAR_1 ; Throwable VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_2 instanceof TYPE_1 || VAR_2 instanceof RuntimeException || VAR_2 instanceof TYPE_2 ) <END> return METHOD_1 ( VAR_2 ) ; else return VAR_1 ; }
<|startcomment|> change <|endcomment|> public void METHOD_1 ( ) { if ( VAR_1 != null && VAR_2 != null && VAR_2 instanceof TYPE_1 ) { if ( VAR_2 . METHOD_2 ( ) . equals ( VAR_1 ) ) { <START> ( ( TYPE_1 ) VAR_2 ) . METHOD_3 ( ) ; <END> VAR_3 = false ; } } VAR_1 = null ; }
<|startcomment|> ususally don t put logic entity class confusing setter side effects : _CODE_ ( blah ) METHOD_2 ( true ) METHOD_1 ( true ) <|endcomment|> public TYPE_1 METHOD_1 ( Boolean VAR_1 ) { set ( VAR_2 , VAR_1 ) ; <START> if ( VAR_1 != null && VAR_1 ) <END> { METHOD_2 ( false ) ; } return this ; }
<|startcomment|> remove code ? mind I remember : rely system - wide conversion service endpoint <|endcomment|> public Object METHOD_1 ( Object VAR_1 , String VAR_2 ) throws TYPE_1 { if ( VAR_1 instanceof TYPE_2 ) { TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( VAR_4 ) ; if ( VAR_1 instanceof TYPE_5 ) { TYPE_6 VAR_5 = ( ( TYPE_5 ) VAR_1 ) . METHOD_3 ( ) ; <START> if ( VAR_5 != null ) { <END> VAR_3 . METHOD_4 ( new TYPE_7 ( VAR_5 ) ) ; } } ( ( TYPE_2 ) VAR_1 ) . METHOD_5 ( VAR_3 ) ; } return VAR_1 ; }
<|startcomment|> I shouldn t close handle closed _CODE_ method I handle binded active transaction <|endcomment|> public < R , TYPE_1 extends Exception > R METHOD_1 ( TYPE_2 < R , TYPE_1 > VAR_1 ) throws TYPE_1 { TYPE_3 VAR_2 = TYPE_4 . METHOD_2 ( VAR_3 ) ; R result = VAR_1 . METHOD_1 ( VAR_2 ) ; <START> TYPE_4 . METHOD_3 ( VAR_2 ) ; <END> return result ; }
<|startcomment|> case shouldn t getrid project parameter ( project shouldn t extra initial path explicitly initial path <|endcomment|> <START> public TYPE_4 ( ANNOTATION_1 TYPE_1 project , ANNOTATION_2 TYPE_2 VAR_2 , <END> ANNOTATION_1 TYPE_3 VAR_3 ) { this . VAR_4 = project ; this . VAR_3 = VAR_3 ; this . VAR_5 = new HashSet < > ( ) ; this . VAR_2 = VAR_2 ; this . VAR_6 = new HashMap < > ( ) ; }
<|startcomment|> minor : prefer TYPE_2 mount path order path granular <|endcomment|> public String METHOD_1 ( ) { <START> return METHOD_2 ( ) + File . VAR_1 + TYPE_1 . TYPE_2 + File . VAR_1 <END> + VAR_4 . METHOD_3 ( ) ; }
<|startcomment|> t add parent - > VAR_1 listing cache parent status other map <|endcomment|> public void METHOD_1 ( TYPE_1 path , Collection < TYPE_2 > VAR_1 ) { TYPE_2 status = VAR_2 . get ( path ) ; <START> if ( status != null ) { <END> VAR_3 . METHOD_2 ( path , VAR_4 - > new TYPE_3 < > ( ) ) . addAll ( VAR_1 ) ; } VAR_1 . forEach ( child - > { TYPE_1 VAR_5 = path . VAR_6 ( child . getName ( ) ) ; METHOD_3 ( VAR_5 , child ) ; } ) ; }
<|startcomment|> pointless level submission METHOD_5 ( ) submits callback another time ( means s valuable annotate method class executor s supposed run executors external client code execution context ( kind shouldn t runs ) <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { switch ( VAR_1 . getType ( ) ) { case VAR_2 : VAR_3 . remove ( VAR_1 . METHOD_2 ( ) ) ; VAR_4 . METHOD_3 ( - VAR_1 . METHOD_4 ( ) ) ; break ; case VAR_5 : VAR_6 . remove ( VAR_1 . METHOD_2 ( ) ) ; break ; default : throw new TYPE_2 ( ) ; } VAR_7 . execute ( <START> ( ) - > METHOD_5 ( VAR_1 ) <END> ) ; }
<|startcomment|> needed ? consider dropping <|endcomment|> public TYPE_1 build ( TYPE_2 VAR_1 ) { TYPE_3 . Builder builder = builder ( VAR_1 ) ; <START> if ( STRING_1 . equalsIgnoreCase ( this . VAR_2 ) ) { <END> return builder . build ( new TYPE_4 ( host , VAR_3 ) ) ; } else { return builder . build ( new TYPE_5 ( host , VAR_3 ) ) ; } }
<|startcomment|> –æ–ø—è—Ç—å –∫–æ–ø–∏–ø–∞—Å—Ç ) —É —Ç–µ–±—è –∂ —Å–≤–µ—Ä—Ö—É –≤ _CODE_ —Ç–æ—á–Ω–æ —Ç–∞–∫–æ–π –∫–æ–¥ –ò –≤–æ–æ–±—â–µ –µ—Å–ª–∏ –º—ã —É–¥–∞–ª—è–µ–º –≤ _CODE_ —Ç–æ –∑–∞—á–µ–º –µ—â–µ –∑–¥–µ—Å—å ? _CODE_ –≤ –ª—é–±–æ–º —Å–ª—É—á–∞–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–≥–¥–∞ —Å —é–∑–µ—Ä–æ–º —Å–≤—è–∑—å –æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–∞–∫—Ä—ã–ª–∞—Å—å <|endcomment|> public void METHOD_1 ( TYPE_1 session , Integer VAR_1 ) { METHOD_2 ( VAR_1 , getString ( R . string . VAR_2 ) ) ; Log . d ( TAG , STRING_1 + VAR_1 ) ; if ( ! VAR_3 ) { if ( VAR_1 == VAR_4 ) { Log . d ( TAG , STRING_2 + VAR_1 ) ; METHOD_3 ( ) ; } <START> if ( VAR_5 != null && VAR_5 . containsKey ( VAR_1 ) ) { <END> Log . d ( TAG , STRING_3 + VAR_1 ) ; VAR_5 . remove ( VAR_1 ) ; } } }
<|startcomment|> useless parentheses <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_1 VAR_2 = ( TYPE_2 . METHOD_2 ( VAR_1 ) ) ; <END> if ( VAR_2 . is ( TYPE_5 . TYPE_4 . VAR_5 ) ) { String VAR_6 = ( ( TYPE_3 ) VAR_2 ) . name ( ) ; return STRING_1 . equals ( VAR_6 ) ; } return false ; }
<|startcomment|> TYPE_1 : : METHOD_2 <|endcomment|> protected Map < String , TYPE_1 > METHOD_1 ( ) { return this . VAR_1 . stream ( ) <START> . collect ( Collectors . VAR_2 ( VAR_3 - > VAR_3 . METHOD_2 ( ) , VAR_3 - > VAR_3 ) ) ; <END> }
<|startcomment|> String valueOf ( VAR_1 METHOD_3 ( ) ) more sense valueOf toString <|endcomment|> public String toString ( ) { TYPE_1 VAR_1 = METHOD_1 ( ) ; if ( VAR_1 == null ) return "" ; String name = VAR_1 . METHOD_2 ( ) ; <START> return name == null ? Long . valueOf ( VAR_1 . METHOD_3 ( ) ) . toString ( ) : name ; <END> }
<|startcomment|> test else case isn t needed - - s a TYPE_3 text set emprty string <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { Object o = TYPE_2 . METHOD_2 ( VAR_1 ) ; if ( o instanceof TYPE_3 ) { String text = ( ( TYPE_3 ) o ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( text ) ; <START> } else if ( o == null ) { <END> VAR_2 . METHOD_4 ( "" ) ; } }
<|startcomment|> private move field creation holder i suggested <|endcomment|> <START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { METHOD_2 ( ) ; } return VAR_1 ; }
<|startcomment|> isEmpty ( ) check collection empty <|endcomment|> public boolean METHOD_1 ( Object element ) { <START> return ( ( TYPE_1 ) element ) . VAR_1 . size ( ) > 0 ; <END> }
<|startcomment|> I remove / catch wrappers checked exceptions thrown a Exception anticipating <|endcomment|> public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> try { <END> boolean VAR_2 = true ; long VAR_3 = System . currentTimeMillis ( ) ; VAR_1 = new TYPE_1 ( VAR_4 , VAR_5 , VAR_6 , VAR_2 ) ; log . debug ( STRING_1 + VAR_2 + STRING_2 + ( System . currentTimeMillis ( ) - VAR_3 ) + STRING_3 ) ; } catch ( Exception e ) { e . VAR_7 ( ) ; } } return VAR_1 ; }
<|startcomment|> remove <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { String s = TYPE_2 . METHOD_2 ( VAR_1 ) ; TYPE_1 VAR_2 = TYPE_2 . METHOD_3 ( s ) ; <START> System . out . println ( VAR_1 ) ; <END> System . out . println ( VAR_2 ) ; System . out . println ( s ) ; assertTrue ( VAR_1 . equals ( VAR_2 ) ) ; }
<|startcomment|> benefit ( proposed ) TYPE_1 EMPTY enumeration item <|endcomment|> String METHOD_1 ( ) { final TYPE_1 VAR_1 = VAR_2 . METHOD_1 ( ) ; <START> if ( VAR_1 == null ) { <END> return VAR_2 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) . value ( ) ; } else { return VAR_1 . toString ( ) ; } }
<|startcomment|> TYPE_1 getInstance ( ) instead <|endcomment|> private TYPE_1 METHOD_1 ( ) { <START> return ( TYPE_1 ) METHOD_2 ( ) . METHOD_1 ( ) ; <END> }
<|startcomment|> public private ? validator <|endcomment|> <START> public boolean METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) == TYPE_4 . VAR_3 && TYPE_2 . TYPE_3 . equals ( VAR_1 . METHOD_3 ( ) ) ; }
<|startcomment|> _CODE_ method please <|endcomment|> <START> public TYPE_1 METHOD_1 ( ANNOTATION_1 TYPE_2 VAR_1 , <END> TYPE_3 VAR_2 , ANNOTATION_1 TYPE_4 VAR_3 , TYPE_5 VAR_4 ) { try { Context context = METHOD_2 ( ) ; Collection VAR_5 = VAR_6 . METHOD_3 ( context , VAR_2 ) ; TYPE_6 VAR_7 = ( TYPE_6 ) VAR_6 . METHOD_4 ( context , VAR_5 ) ; if ( VAR_5 == null ) { throw new TYPE_7 ( STRING_1 + VAR_2 ) ; } return VAR_8 . METHOD_5 ( VAR_7 , VAR_4 ) ; } catch ( TYPE_8 e ) { throw new RuntimeException ( e ) ; } }
<|startcomment|> immutable <|endcomment|> public List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 , TYPE_3 user ) throws TYPE_4 , TYPE_5 { <START> List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; <END> for ( TYPE_2 VAR_3 : VAR_1 ) { VAR_2 . addAll ( VAR_4 . METHOD_1 ( VAR_3 ) ) ; } VAR_2 = TYPE_6 . METHOD_2 ( ) . METHOD_3 ( VAR_2 , TYPE_7 . VAR_6 , true , user ) ; return VAR_2 ; }
<|startcomment|> code raises more ( previously existing ) concerns : 1 VAR_4 higher priority descriptor VAR_1 ? 2 VAR_4 descriptor changed <|endcomment|> private String METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <START> String VAR_4 = VAR_2 != null && VAR_2 . METHOD_4 ( ) != null ? VAR_2 . METHOD_4 ( ) : VAR_1 . METHOD_4 ( ) ; <END> VAR_1 . METHOD_5 ( ) . put ( VAR_5 , VAR_4 ) ; return VAR_4 ; }
<|startcomment|> throw redundancy warnings _CODE_ <|endcomment|> private Map < String , Pair < Class , Object > > METHOD_1 ( ) { Map < String , Pair < Class , Object > > map = new HashMap < > ( ) ; <START> return map ; <END> }
<|startcomment|> public <|endcomment|> <START> public String METHOD_1 ( String VAR_1 ) { <END> return ( String ) METHOD_2 ( ) . METHOD_3 ( STRING_1 , VAR_1 , VAR_2 ) . get ( 0 ) ; }
<|startcomment|> t return VAR_1 ? I m mistaken TYPE_2 return null lists empty <|endcomment|> protected void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) , getParameters ( ) . METHOD_5 ( ) , METHOD_6 ( ) , getParameters ( ) . METHOD_7 ( ) ) ; if ( TYPE_3 . isEmpty ( VAR_1 ) ) { <START> METHOD_8 ( new ArrayList < > ( ) ) ; <END> return ; } METHOD_8 ( METHOD_9 ( VAR_1 ) ) ; }
<|startcomment|> don t need thread - safety filter hashcode methods i guess ? kind a funny prime cached values I supplier memoize pattern a cleaner necessary <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 filter , List < TYPE_3 > VAR_1 , TYPE_4 VAR_2 ) { synchronized ( VAR_3 ) { if ( filter != null ) { <START> filter . VAR_4 ( ) ; <END> } } TYPE_5 key = new TYPE_5 ( filter , VAR_1 , VAR_2 ) ; return VAR_3 . METHOD_2 ( key , ( VAR_5 ) - > { return TYPE_6 . METHOD_3 ( TYPE_7 . METHOD_4 ( VAR_1 ) , VAR_2 , filter , VAR_6 ) ; } ) ; }
<|startcomment|> a constr takes ( id _CODE_ resource VAR_3 VAR_4 ) _CODE_ instead adding a new <|endcomment|> protected TYPE_3 ( String id , <START> TYPE_1 VAR_2 , <END> String VAR_3 , TYPE_2 VAR_4 ) { this ( id , id , VAR_2 , VAR_3 , VAR_4 ) ; }
<|startcomment|> _CODE_ _CODE_ attributes annotation <|endcomment|> private Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] <START> { <END> { TYPE_1 . class } , { TYPE_2 . class } , { TYPE_3 . class } } ; }
<|startcomment|> don t need line test check else <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 , TYPE_4 . VAR_3 , STRING_2 , STRING_3 ) ; VAR_1 . METHOD_3 ( Guid . VAR_4 ( ) . toString ( ) ) ; parameters . VAR_5 ( VAR_1 ) ; parameters . VAR_6 ( Guid . TYPE_3 ) ; <START> METHOD_4 ( VAR_1 . getId ( ) ) . when ( command ) . METHOD_5 ( VAR_1 , null ) ; <END> TYPE_2 . METHOD_6 ( command , TYPE_5 . VAR_9 ) ; }
<|startcomment|> I s visible click fail assertion needed <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_2 ( ) . METHOD_2 ( TYPE_4 . VAR_3 ) . METHOD_3 ( ) ; <START> TYPE_3 . assertTrue ( VAR_1 . METHOD_4 ( ) ) ; <END> VAR_1 . METHOD_5 ( ) ; TYPE_3 . assertTrue ( VAR_1 . METHOD_6 ( ) . contains ( STRING_1 ) ) ; }
<|startcomment|> initialized a static / thread - safe context <|endcomment|> private TYPE_1 METHOD_1 ( ) throws TYPE_2 , TYPE_3 { String url = VAR_1 . METHOD_2 ( TYPE_5 . VAR_3 ) ; if ( VAR_4 == null ) { <START> VAR_4 = new TYPE_1 ( new TYPE_4 ( url + STRING_1 ) ) ; <END> } return VAR_4 ; }
<|startcomment|> a minor detail _CODE_ methods work _CODE_ ( expected actual ) valid test files please format file some space <|endcomment|> void METHOD_1 ( ) { TYPE_1 reader = new TYPE_1 ( ) ; TYPE_2 < TYPE_3 > VAR_1 = new TYPE_2 < TYPE_3 > ( ) { } ; List < TYPE_3 > VAR_2 = null ; try { VAR_2 = reader . VAR_3 ( VAR_4 , VAR_1 ) ; } catch ( IOException e ) { } METHOD_2 ( VAR_2 , null ) ; assertEquals ( VAR_2 . size ( ) , 1 ) ; <START> assertEquals ( VAR_2 . get ( 0 ) . getName ( ) , STRING_1 ) ; <END> }
<|startcomment|> replace null VAR_1 all_columns verification exception changed initial order statements <|endcomment|> public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { <START> TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 ) ; <END> TYPE_4 VAR_3 = new TYPE_4 ( this ) ; VAR_3 . VAR_1 = VAR_1 == null ? VAR_4 : VAR_1 ; return VAR_3 ; }
<|startcomment|> private method <|endcomment|> <START> static < T , TYPE_1 > TYPE_2 < T , TYPE_3 < TYPE_1 > > METHOD_1 ( Class < ? > VAR_1 ) { <END> return t - > TYPE_3 . METHOD_2 ( STRING_1 + Optional . VAR_2 ( t ) . map ( o - > o . getClass ( ) . METHOD_3 ( ) ) . METHOD_4 ( STRING_2 + VAR_1 . METHOD_3 ( ) ) ) ; }
<|startcomment|> hmm I don t build pass <|endcomment|> private void METHOD_1 ( ) { final long VAR_1 = TYPE_1 . METHOD_2 ( ) ; final TYPE_2 VAR_2 = METHOD_3 ( ) ; if ( VAR_3 || VAR_4 ) log ( VAR_2 . toString ( ) ) ; METHOD_4 ( VAR_2 , <START> VAR_5 , VAR_1 ) ; <END> }
<|startcomment|> wdyt replace return objects _CODE_ ( VAR_1 VAR_2 ) agree some adaptation 10 10 ( java 8 ) <|endcomment|> public String METHOD_1 ( ) { <START> return VAR_1 == null ? VAR_2 : VAR_1 ; <END> }
<|startcomment|> unnecessary <|endcomment|> public String getMessage ( ) { <START> return this . message ; <END> }
<|startcomment|> need toString ( ) <|endcomment|> public Type METHOD_1 ( String VAR_1 ) { Type VAR_2 = METHOD_2 ( VAR_1 ) ; for ( TYPE_1 VAR_3 : METHOD_3 ( ) ) { logger . debug ( STRING_1 , METHOD_4 ( ) , <START> VAR_3 . METHOD_5 ( ) , VAR_2 . toString ( ) ) ; <END> VAR_2 = VAR_3 . METHOD_6 ( VAR_2 ) ; logger . debug ( STRING_2 , METHOD_4 ( ) , VAR_3 . METHOD_5 ( ) , VAR_2 . toString ( ) ) ; } return VAR_2 ; }
<|startcomment|> synchronized <|endcomment|> <START> public void clear ( ) { <END> this . VAR_1 . clear ( ) ; }
<|startcomment|> please change long primitive type ? : ) <|endcomment|> public static TYPE_1 METHOD_1 ( long VAR_1 , int VAR_2 , String VAR_3 ) { TYPE_2 VAR_4 = TYPE_2 . METHOD_2 ( ) ; <START> Long id = Long . VAR_5 ( VAR_1 + STRING_1 + VAR_2 ) ; <END> TYPE_3 VAR_6 = TYPE_3 . create ( VAR_7 + STRING_2 + VAR_1 + STRING_3 ) ; return new TYPE_1 ( VAR_6 , VAR_3 , null , null , VAR_4 , null , null , id ) ; }
<|startcomment|> I don t works swapping context a instance a constant a monitor <|endcomment|> private void METHOD_1 ( TYPE_1 context ) { do { <START> synchronized ( context ) { <END> context . VAR_1 ( ) . METHOD_2 ( VAR_2 , new TYPE_2 ( ) ) ; context = ( TYPE_1 ) context . VAR_3 ( ) ; } } while ( context != null ) ; }
<|startcomment|> line return a substring length VAR_1 + 1 substring needs longer VAR_1 replace VAR_1 + 1 VAR_1 <|endcomment|> private String METHOD_1 ( String message , int VAR_1 ) { if ( message . length ( ) > VAR_1 ) { <START> message = message . substring ( 0 , VAR_1 + 1 ) ; <END> } return message ; }
<|startcomment|> double ; <|endcomment|> public void METHOD_1 ( ) { TYPE_1 < Object > VAR_1 = new TYPE_1 < Object > ( ) ; TYPE_2 ex = new TYPE_2 ( STRING_1 ) ; TYPE_3 . error ( ex ) . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; VAR_1 . METHOD_4 ( ) ; <START> VAR_1 . METHOD_5 ( ) ; ; <END> VAR_1 . METHOD_6 ( TYPE_2 . class ) ; VAR_1 . METHOD_7 ( STRING_1 ) ; }
<|startcomment|> unnecessary linebreak <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 , Object VAR_2 , <START> Object element ) { <END> if ( ! ( element instanceof TYPE_2 ) ) { return false ; } if ( VAR_3 == null ) { return false ; } return TYPE_3 . METHOD_2 ( ( TYPE_2 ) element , VAR_3 ) ; }
<|startcomment|> bump INT_1 board <|endcomment|> public static void METHOD_1 ( ) throws InterruptedException { int VAR_1 = TYPE_2 . VAR_3 [ 0 ] . contains ( STRING_1 ) ? INT_1 : INT_2 ; <START> TYPE_1 . METHOD_1 ( VAR_4 , data ( ) , VAR_1 ) ; <END> }
<|startcomment|> declare Map <|endcomment|> public Map < String , String > METHOD_1 ( TYPE_1 context ) { <START> HashMap < String , String > VAR_1 = new HashMap < > ( ) ; <END> for ( TYPE_2 VAR_2 : VAR_3 ) { VAR_1 . METHOD_2 ( VAR_2 . METHOD_3 ( context ) ) ; } return TYPE_3 . METHOD_4 ( VAR_1 ) ; }
<|startcomment|> I thought _CODE_ info ( STRING_1 VAR_1 VAR_2 VAR_3 VAR_4 ) ; TYPE_3 log <|endcomment|> public static void METHOD_1 ( Integer VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , String VAR_4 ) { new TYPE_3 ( ) . log ( String . format ( STRING_1 , VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ) ; <START> } <END>
<|startcomment|> METHOD_2 deprecated please good getInstance <|endcomment|> public static List < String > METHOD_1 ( ) { final ArrayList < String > VAR_1 = new ArrayList < String > ( ) ; <START> for ( TYPE_1 c : TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ) { <END> if ( ! c . getName ( ) . isEmpty ( ) ) { VAR_1 . add ( c . getName ( ) ) ; } } return VAR_1 ; }
<|startcomment|> perform read write critical section s guarantee consistency <|endcomment|> public void METHOD_1 ( final String VAR_1 , final TYPE_1 listener ) { METHOD_2 ( VAR_1 , listener ) ; <START> final Set < TYPE_1 > VAR_2 = VAR_3 . get ( VAR_1 ) ; <END> synchronized ( VAR_4 ) { if ( VAR_2 != null ) { VAR_2 . remove ( listener ) ; if ( VAR_2 . isEmpty ( ) ) { VAR_3 . remove ( VAR_1 ) ; } } } }
<|startcomment|> list ( TYPE_6 VAR_4 ) returns a reasonable upper bounds size I ArrayList faster <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <START> final List < TYPE_2 > VAR_1 = new TYPE_3 < TYPE_2 > ( ) ; <END> for ( final TYPE_2 . TYPE_5 VAR_2 : list . get ( TYPE_6 . VAR_4 ) ) { final TYPE_2 group = get ( VAR_2 ) ; if ( group != null ) { VAR_1 . add ( group ) ; } } return Collections . VAR_5 ( VAR_1 ) ; }
<|startcomment|> a large number tests don t _CODE_ call hazelcast _CODE_ ( ) ( combination hazelcast _CODE_ ( ) / _CODE_ _CODE_ ( ) / _CODE_ _CODE_ ( ) ) shouldn t checked <|endcomment|> public void METHOD_1 ( TYPE_1 instance ) { try { TYPE_2 VAR_1 = METHOD_2 ( instance ) . VAR_1 ; METHOD_3 ( instance ) ; if ( VAR_2 ) { VAR_3 . METHOD_4 ( VAR_1 ) ; } } finally { <START> TYPE_3 . METHOD_5 ( instance . getName ( ) ) ; <END> } }
<|startcomment|> please change METHOD_7 <|endcomment|> public void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( getParameters ( ) . METHOD_2 ( ) ) { Guid VAR_1 = METHOD_3 ( ) ; if ( VAR_1 != null ) { METHOD_4 ( VAR_1 ) ; } } METHOD_5 ( TYPE_1 . VAR_3 ) ; <START> METHOD_6 ( ) . METHOD_7 ( true ) ; <END> }
<|startcomment|> interesting wrapping style : ) <|endcomment|> <START> void METHOD_1 ( ) { <END> }
<|startcomment|> _CODE_ handle interruptions essentially a - op VAR_3 executing <|endcomment|> private void METHOD_1 ( ) { METHOD_2 ( ) ; while ( state == TYPE_2 . VAR_2 ) { TYPE_1 VAR_3 = VAR_4 . get ( ) ; if ( VAR_3 != null && ! VAR_3 . METHOD_3 ( ) ) <START> VAR_3 . METHOD_4 ( ) ; <END> TYPE_1 VAR_5 = new TYPE_1 ( ) ; if ( VAR_4 . METHOD_5 ( VAR_3 , VAR_5 ) ) { VAR_5 . METHOD_6 ( ) ; return ; } } }
<|startcomment|> gauges timestamp <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = TYPE_4 . instance . METHOD_2 ( ) ; <START> VAR_2 . put ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ; <END> TYPE_3 VAR_4 = VAR_1 . METHOD_4 ( ) ; VAR_2 . put ( STRING_2 , VAR_4 . METHOD_5 ( ) == ( TYPE_3 . Type . VAR_5 ) ? VAR_4 . getValue ( ) . METHOD_6 ( ) : VAR_4 . getValue ( ) . METHOD_7 ( ) ) ; return METHOD_8 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> doesn t need ability effect optional ability fine <|endcomment|> public TYPE_9 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , VAR_3 , new TYPE_3 [ ] { TYPE_3 . VAR_4 } , STRING_1 ) ; this . VAR_5 . add ( TYPE_8 . VAR_7 ) ; this . VAR_8 = new TYPE_4 ( 3 ) ; this . VAR_9 = new TYPE_4 ( 5 ) ; this . METHOD_1 ( TYPE_5 . getInstance ( ) ) ; <START> this . METHOD_1 ( new TYPE_6 ( new TYPE_7 ( filter , false , true ) , true ) ) ; <END> }
<|startcomment|> METHOD_4 doesn t need a VAR_3 caller call _CODE_ ( ) receiving prevent METHOD_4 effect called <|endcomment|> private void METHOD_1 ( long VAR_1 , TYPE_1 VAR_2 ) { VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) ; try { if ( VAR_2 . METHOD_4 ( ) ) { <START> try { <END> VAR_2 . VAR_4 . close ( ) ; } catch ( IOException e ) { LOG . warn ( STRING_1 + STRING_2 , VAR_2 ) ; } finally { TYPE_2 . close ( LOG , VAR_2 . VAR_4 ) ; } VAR_5 . remove ( VAR_1 , VAR_2 ) ; } } finally { VAR_3 . METHOD_2 ( ) . METHOD_5 ( ) ; } }
<|startcomment|> need declare instead declare type line 141 <|endcomment|> private static File METHOD_1 ( ) { <START> File VAR_1 ; <END> File VAR_2 = new File ( System . getProperty ( STRING_1 ) ) ; VAR_1 = new File ( VAR_2 , STRING_2 ) ; if ( VAR_1 . exists ( ) ) return VAR_1 ; VAR_1 = new File ( VAR_2 , STRING_3 ) ; if ( VAR_1 . exists ( ) ) return VAR_1 ; return null ; }
<|startcomment|> I method body synchronised instead remove outer ( VAR_1 = = null ) ? i duplicated block <|endcomment|> <START> static synchronized TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { synchronized ( Context . VAR_2 ) { if ( VAR_1 == null ) { log . error ( STRING_1 ) ; VAR_1 = TYPE_1 . getInstance ( ) ; } } } log . trace ( STRING_2 , VAR_1 ) ; return TYPE_1 . getInstance ( ) ; }
<|startcomment|> remove line <|endcomment|> public synchronized void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( STRING_1 ) . debug ( STRING_2 ) ; <END> listener = new TYPE_2 ( ) ; VAR_1 . METHOD_3 ( listener ) ; }
<|startcomment|> I don t understand need test tests serialization deserialization I wrong tests more <|endcomment|> <START> public void METHOD_1 ( ) throws Exception { <END> for ( TYPE_1 version : VAR_1 ) { METHOD_2 ( version ) ; } }
<|startcomment|> return need variable <|endcomment|> private List < TYPE_1 > METHOD_1 ( Guid id ) { <START> List < TYPE_1 > VAR_1 = <END> METHOD_2 ( ) . METHOD_3 ( STRING_1 , TYPE_2 . instance , METHOD_4 ( ) . METHOD_5 ( STRING_2 , id ) ) ; return VAR_1 ; }
<|startcomment|> handling selecting db constructor _CODE_ authentication takes place <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( this ) ; <END> try { VAR_1 . METHOD_2 ( db ) ; } catch ( TYPE_2 e ) { log . log ( Level . VAR_2 , STRING_1 , e ) ; } return VAR_1 ; }
<|startcomment|> please initialization code activator class <|endcomment|> public TYPE_7 ( TYPE_1 VAR_2 ) { VAR_3 = ( TYPE_2 ) VAR_2 . METHOD_1 ( ) ; <START> VAR_3 . METHOD_2 ( new TYPE_3 ( ) { <END> @Override public TYPE_4 METHOD_3 ( TYPE_5 VAR_4 ) { return new TYPE_6 ( VAR_4 ) ; } } ) ; }
<|startcomment|> I METHOD_2 a - op conf empty don t need check <|endcomment|> public TYPE_1 METHOD_1 ( Map < String , Object > conf ) { <START> if ( conf != null && ! conf . isEmpty ( ) ) { <END> VAR_1 . VAR_2 . METHOD_2 ( conf ) ; } return this ; }
<|startcomment|> a heavy read bug ! check breakpointapplicable reverse instanceof checkand call instanceof cheaper <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 VAR_2 ) { final TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( VAR_1 , TYPE_3 . class ) ; TYPE_5 [ ] VAR_4 = TYPE_6 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_5 ) ; for ( TYPE_5 VAR_6 : VAR_4 ) { <START> if ( METHOD_6 ( VAR_6 ) && VAR_6 instanceof TYPE_7 ) { <END> METHOD_7 ( ( TYPE_7 ) VAR_6 , VAR_1 ) ; } } METHOD_8 ( VAR_3 , VAR_2 ) ; }
<|startcomment|> put logic _CODE_ METHOD_4 discussed <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; <START> while ( VAR_1 . METHOD_2 ( ) . METHOD_5 ( ) . size ( ) > 0 ) { VAR_1 . METHOD_2 ( ) . METHOD_6 ( ) ; } <END> VAR_2 . METHOD_7 ( ) ; VAR_1 . METHOD_8 ( ) . METHOD_9 ( ) ; VAR_1 . METHOD_8 ( ) . METHOD_10 ( ) ; }
<|startcomment|> addition pointless <|endcomment|> private void METHOD_1 ( TYPE_1 channel ) throws IOException { try ( TYPE_2 from = TYPE_3 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ) { TYPE_4 . METHOD_5 ( from , channel ) ; <START> return ; <END> } }
<|startcomment|> please remove <|endcomment|> protected void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( VAR_2 , STRING_1 , STRING_2 ) ; VAR_1 . close ( ) ; <START> VAR_2 . METHOD_4 ( false ) ; <END> }
<|startcomment|> null checks disappear a multimap <|endcomment|> public List < TYPE_1 > METHOD_1 ( final String name ) { List < TYPE_1 > list = VAR_1 . get ( name ) ; <START> if ( list == null ) { <END> return new ArrayList < > ( ) ; } return VAR_1 . get ( name ) ; }
<|startcomment|> actual runtime type ? overly defensive - I expect a string a Boolean randomly changing run run <|endcomment|> private static boolean METHOD_1 ( List < TYPE_1 > options ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( options , STRING_1 ) ; if ( VAR_1 != null ) { Object value = VAR_1 . getValue ( ) ; <START> return value instanceof Boolean ? ( Boolean ) value : STRING_2 . equals ( value ) ; <END> } return false ; }
<|startcomment|> interesting approach I guess I d qualifiers CDI alternative mechanism simplest <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 ) { <END> VAR_2 . METHOD_2 ( TYPE_2 . class , TYPE_3 . class ) ; } else { VAR_2 . METHOD_2 ( TYPE_4 . class , TYPE_5 . class ) ; } return VAR_2 ; }
<|startcomment|> log debug <|endcomment|> private TYPE_1 METHOD_1 ( String VAR_1 ) { <START> log . info ( STRING_1 , VAR_1 ) ; <END> TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 ) ; return VAR_2 ; }
<|startcomment|> ll need usage VAR_1 getId ( ) replaced VAR_1 METHOD_3 ( ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , Set < TYPE_3 > VAR_2 , TYPE_4 VAR_3 ) { return new TYPE_1 ( TYPE_1 . Type . VAR_4 , TYPE_1 . TYPE_5 . VAR_6 , VAR_1 . getName ( ) , VAR_7 . get ( ) , VAR_1 . METHOD_2 ( ) . getId ( ) , VAR_1 . METHOD_3 ( ) , <START> VAR_1 . getId ( ) , null , METHOD_4 ( VAR_1 , VAR_2 , VAR_3 ) , null , <END> null ) ; }
<|startcomment|> StringBuilder please <|endcomment|> public static String METHOD_1 ( byte [ ] VAR_1 ) { <START> TYPE_1 buf <END> = new TYPE_1 ( ) ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { if ( ( VAR_1 [ i ] & INT_1 ) < INT_2 ) buf . append ( CHAR_1 ) ; buf . append ( Integer . VAR_2 ( VAR_1 [ i ] & INT_1 ) ) ; } return buf . toString ( ) ; }
<|startcomment|> invert returns early <|endcomment|> private boolean METHOD_1 ( ) { boolean VAR_1 = ( VAR_2 == null ) ; <START> if ( ! VAR_1 ) { <END> TYPE_1 VAR_3 = VAR_4 . get ( VAR_5 ) ; if ( VAR_3 != null ) { VAR_1 = VAR_3 . METHOD_2 ( ) . containsKey ( VAR_2 ) ; } } return VAR_1 ; }
<|startcomment|> change batcher immediately execute create new instance TYPE_3 added tasks smaller VAR_3 size <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , int VAR_3 , long VAR_4 , TYPE_2 < T > VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = new ArrayList < T > ( ) ; this . VAR_7 = false ; <START> this . VAR_8 = 0 ; <END> }
<|startcomment|> line removed <|endcomment|> public static void METHOD_1 ( Map < String , Object > VAR_1 ) { <START> VAR_1 . remove ( TYPE_1 . VAR_3 ) ; <END> VAR_1 . remove ( TYPE_1 . VAR_4 ) ; }
<|startcomment|> Exception thrown method <|endcomment|> private void METHOD_1 ( ) throws Exception { try { info ( STRING_1 ) ; METHOD_2 ( VAR_1 . VAR_2 , VAR_1 . VAR_3 ) ; if ( VAR_4 != null ) { <START> METHOD_3 ( VAR_4 . METHOD_4 ( ) == 0 , <END> STRING_2 ) ; } } finally { if ( VAR_4 != null ) { VAR_4 . close ( ) ; } for ( TYPE_1 VAR_5 : VAR_6 . values ( ) ) { VAR_5 . close ( ) ; } } }
<|startcomment|> consider : return VAR_1 = = VAR_2 ? 0 : VAR_3 - VAR_1 - 1 ; <|endcomment|> public int size ( ) { if ( VAR_1 == VAR_2 ) { return 0 ; } <START> return VAR_3 - VAR_1 - 1 ; <END> }
<|startcomment|> VAR_1 anymore <|endcomment|> <START> public void METHOD_1 ( int VAR_1 ) { <END> METHOD_2 ( ) ; METHOD_3 ( ) ; if ( VAR_2 > 0 && VAR_2 < this . METHOD_4 ( ) ) { METHOD_5 ( VAR_2 ) ; } else { METHOD_5 ( 0 ) ; } METHOD_6 ( METHOD_7 ( ) ) ; }
<|startcomment|> other TYPE_3 METHOD_1 ( ) calls usual logic instance ( case Boolean ) treat other situation null provided remove need check Boolean METHOD_2 code issue error log message occur <|endcomment|> public Object execute ( TYPE_1 event ) throws TYPE_2 { <START> Object VAR_1 = TYPE_3 . METHOD_1 ( event , VAR_2 ) ; <END> if ( VAR_1 != null ) { return METHOD_2 ( event , VAR_1 ) ; } else { METHOD_3 ( event ) ; } return null ; }
<|startcomment|> another - permissible change <|endcomment|> <START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } this . VAR_1 = VAR_1 ; return this ; }
<|startcomment|> I copied piece JS s perfect : ) drop METHOD_3 ( STRING_2 STRING_3 ) ( 3 places ) done _CODE_ legacy mn minutes fixed some RSPEC mn plugin fails update RSPEC <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_2 . startsWith ( STRING_1 ) ) { <START> return VAR_1 . METHOD_2 ( VAR_3 . METHOD_3 ( STRING_2 , STRING_3 ) ) ; <END> } if ( STRING_4 . equals ( VAR_2 ) ) { return VAR_1 . METHOD_4 ( VAR_4 . METHOD_3 ( STRING_2 , STRING_3 ) ) ; } return VAR_1 . METHOD_5 ( VAR_4 . METHOD_3 ( STRING_2 , STRING_3 ) , VAR_5 . METHOD_3 ( STRING_2 , STRING_3 ) ) ; }
<|startcomment|> I find unintuitive find I d suggest moving log PMD _CODE_ guaranteed run a more natural <|endcomment|> public void METHOD_1 ( final TYPE_1 cache ) { if ( cache == null && METHOD_2 ( ) ) { VAR_1 = new TYPE_2 ( ) ; if ( ! METHOD_3 ( ) && LOG . VAR_2 ( Level . VAR_3 ) ) { final String version = TYPE_3 . METHOD_4 ( ) || TYPE_3 . METHOD_5 ( ) ? STRING_1 : STRING_2 + TYPE_3 . VAR_4 ; <START> LOG . VAR_5 ( STRING_3 <END> + STRING_4 + version + STRING_5 ) ; } } else if ( ! METHOD_3 ( ) ) { VAR_1 = cache ; } }
<|startcomment|> add clarifying parenthesis <|endcomment|> private static double METHOD_1 ( long value ) { <START> value = value ^ ( value > > INT_1 ) & Long . VAR_1 ; <END> return Double . VAR_2 ( value ) ; }
<|startcomment|> ( ! ( e instanceof TYPE_1 ) || e VAR_2 ( ) = = null ) { return e ; } Throwable VAR_1 = e VAR_2 ( ) ; return VAR_1 instanceof Exception ? ( Exception ) VAR_1 : new Exception ( VAR_1 ) ; making return statement simpler <|endcomment|> public static Exception METHOD_1 ( Exception e ) { if ( ! ( e instanceof TYPE_1 ) ) { return e ; } Throwable VAR_1 = e . VAR_2 ( ) ; return VAR_1 == null ? e : ( VAR_1 instanceof Exception ? ( Exception ) VAR_1 : new Exception ( VAR_1 ) ) ; <START> } <END>
<|startcomment|> minor : braces unnecessary <|endcomment|> boolean isEmpty ( ) { <START> return ( VAR_1 . isEmpty ( ) ) ; <END> }
<|startcomment|> please whitespace changes commit <|endcomment|> Set METHOD_1 ( ) { Set VAR_1 = new HashSet ( ) ; String [ ] VAR_2 = { STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 } ; <START> for ( String element : VAR_2 ) { <END> VAR_1 . add ( element ) ; } return VAR_1 ; }
<|startcomment|> child <|endcomment|> public static boolean METHOD_1 ( File file ) { if ( ! file . exists ( ) ) return true ; if ( file . VAR_1 ( ) ) { File [ ] VAR_2 = file . VAR_3 ( ) ; for ( File <START> VAR_4 : <END> VAR_2 ) { METHOD_1 ( VAR_4 ) ; } } return file . VAR_5 ( ) ; }
<|startcomment|> call METHOD_2 log ? aren t authenticated need log <|endcomment|> public void METHOD_1 ( final TYPE_1 monitor ) throws TYPE_2 { VAR_1 = - 1 ; token = null ; ( new TYPE_3 < Integer > ( this ) { ANNOTATION_1 ( STRING_1 ) @Override public Integer execute ( ) throws TYPE_2 { try { <START> VAR_2 . METHOD_2 ( monitor ) ; <END> } catch ( TYPE_4 e ) { e . VAR_3 ( ) ; } Object response = call ( monitor , VAR_4 , null ) ; return - 1 ; } } ) . execute ( ) ; return ; }
<|startcomment|> simplified : javareturn VAR_1 < 1 ? 0 : VAR_1 ; <|endcomment|> private double METHOD_1 ( double VAR_1 ) { <START> double VAR_2 ; <END> if ( VAR_1 < 1 ) VAR_2 = 0 ; else VAR_2 = VAR_1 ; return VAR_2 ; }
<|startcomment|> new flag VAR_4 passed ( ) _CODE_ <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( final Long offset , final Long VAR_1 , final String VAR_2 , final boolean VAR_3 , final boolean VAR_4 , final TYPE_3 < TYPE_4 > properties , final TYPE_5 VAR_5 ) throws TYPE_6 { <START> return VAR_6 . METHOD_1 ( offset , VAR_1 , VAR_2 , VAR_3 , properties , VAR_5 , VAR_7 . METHOD_2 ( VAR_5 ) ) ; <END> }
<|startcomment|> need convert VAR_1 a map instead <|endcomment|> <START> private static Map < String , String > METHOD_1 ( ) { <END> try { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( VAR_2 ) ; Map < String , String > VAR_3 = new HashMap < String , String > ( ) ; for ( String key : VAR_1 . keySet ( ) ) { VAR_3 . put ( key , VAR_1 . getString ( key ) ) ; } return VAR_3 ; } catch ( TYPE_2 e ) { log . error ( STRING_1 + VAR_2 ) ; throw new TYPE_3 ( e ) ; } }
<|startcomment|> needed ? removed efficiency reasons ( I don t method ) <|endcomment|> public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; <START> if ( getClass ( ) != obj . getClass ( ) ) return false ; <END> TYPE_1 VAR_1 = ( ( TYPE_2 ) obj ) . getValue ( ) ; return this . value . equals ( VAR_1 ) ; }
<|startcomment|> [ optional ] shortened : return VAR_2 METHOD_3 ( user ) METHOD_4 ( ) ; <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) ) { TYPE_3 user = VAR_3 . create ( VAR_1 . getId ( ) ) ; <START> if ( VAR_2 . METHOD_3 ( user ) . METHOD_4 ( ) ) { return true ; } <END> } return false ; }
<|startcomment|> please = = enum comparisons done 2 lines <|endcomment|> private boolean METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> return VAR_1 . length == 1 && TYPE_1 . TYPE_3 . equals ( VAR_1 [ 0 ] ) ; <END> }
<|startcomment|> file File <|endcomment|> <START> public String METHOD_1 ( ) <END> { return VAR_1 ; }
<|startcomment|> won t implement _CODE_ implement close ( ) <|endcomment|> <START> void close ( ) { <END> VAR_1 . add ( TYPE_1 . VAR_3 ) ; VAR_4 . METHOD_1 ( ) ; }
<|startcomment|> wouldn t / else ? unsubscribed previous lines I don t flow <|endcomment|> private void METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( this ) == 0 ) { METHOD_3 ( ) ; } <START> if ( VAR_1 . isEmpty ( ) && VAR_2 == VAR_3 ) { <END> if ( TYPE_2 . METHOD_4 ( this , 0 , 1 ) ) { if ( ! child . VAR_4 ( ) ) { child . VAR_5 ( ) ; } } } }
<|startcomment|> suggestionlogger error ( more vector errors { } VAR_2 ) ; <|endcomment|> protected boolean METHOD_1 ( ) { if ( VAR_1 == 0 ) { <START> logger . error ( STRING_1 + VAR_2 ) ; <END> } VAR_1 ++ ; if ( VAR_1 >= VAR_3 ) { return false ; } return true ; }
<|startcomment|> java7 - - resources feature <|endcomment|> protected static List < Integer > METHOD_1 ( File VAR_1 , String VAR_2 , List < String > VAR_3 ) { List < Integer > VAR_4 = new ArrayList < > ( ) ; TYPE_1 reader = null ; try { reader = new TYPE_2 ( VAR_1 ) ; VAR_4 = METHOD_1 ( reader , VAR_2 , VAR_3 ) ; } catch ( IOException e ) { e . VAR_5 ( ) ; } finally { <START> METHOD_2 ( reader ) ; <END> } return VAR_4 ; }
<|startcomment|> missing final ( previous patch ) <|endcomment|> private static void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 , final String VAR_3 , final TYPE_2 VAR_4 ) { <START> TYPE_3 VAR_5 = new TYPE_3 ( VAR_6 ) ; <END> VAR_5 . METHOD_2 ( TYPE_4 . VAR_8 , VAR_2 ) ; VAR_5 . METHOD_2 ( TYPE_4 . VAR_9 , VAR_3 ) ; VAR_5 . METHOD_2 ( TYPE_4 . VAR_10 , VAR_4 . METHOD_3 ( ) ) ; VAR_5 . METHOD_2 ( TYPE_4 . VAR_11 , VAR_4 . METHOD_4 ( ) ) ; VAR_1 . METHOD_5 ( VAR_5 ) ; }
<|startcomment|> static import <|endcomment|> public TYPE_3 ( Map < String , String > VAR_2 ) { <START> TYPE_1 . METHOD_1 ( VAR_2 , <END> STRING_1 ) ; this . VAR_2 = TYPE_2 . METHOD_2 ( VAR_2 ) ; }
<|startcomment|> A redundant else statement <|endcomment|> private static boolean METHOD_1 ( TYPE_1 element ) { if ( element instanceof TYPE_2 ) { TYPE_2 VAR_1 = ( TYPE_2 ) element ; return VAR_1 . METHOD_2 ( ) == TYPE_3 . VAR_3 || VAR_1 . METHOD_2 ( ) == TYPE_3 . VAR_4 || METHOD_3 ( VAR_1 ) ; } <START> else { <END> return false ; } }
<|startcomment|> wouldn t safer method synchronized <|endcomment|> <START> private void METHOD_1 ( ) { <END> for ( TYPE_1 VAR_1 : VAR_2 . values ( ) ) { if ( VAR_1 . METHOD_2 ( ) == null ) continue ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( STRING_1 ) ) ; VAR_1 . METHOD_2 ( ) . METHOD_5 ( ) ; } VAR_2 . clear ( ) ; }
<|startcomment|> need expand lambda <|endcomment|> private TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { TYPE_1 < TYPE_4 > VAR_2 = ( ) - > new TYPE_4 . TYPE_9 ( VAR_3 ) ; TYPE_6 VAR_4 = VAR_5 ? this . VAR_4 : VAR_6 ; return new TYPE_1 < TYPE_2 > ( ) { @Override public TYPE_2 get ( ) { return new TYPE_7 ( VAR_1 , VAR_2 , TYPE_8 : : METHOD_2 , VAR_4 , METHOD_3 ( ) ) ; } <START> } ; <END> }
<|startcomment|> package - private <|endcomment|> <START> public static byte [ ] METHOD_1 ( boolean [ ] VAR_1 ) { <END> byte [ ] VAR_2 = new byte [ ( VAR_1 . length + INT_1 ) / INT_2 ] ; for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { VAR_2 [ i ] = METHOD_2 ( VAR_1 , INT_2 * i ) ; } return VAR_2 ; }
<|startcomment|> minor : _CODE_ org assertj core util List list static import readability <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . assertThat ( 1 ) . METHOD_2 ( 1 ) ; VAR_1 . METHOD_3 ( ) ; VAR_2 . assertThat ( 1 ) . METHOD_2 ( 1 ) ; <START> VAR_2 . assertThat ( TYPE_2 . METHOD_4 ( 1 , 2 ) ) . METHOD_5 ( 1 , 2 ) ; <END> VAR_2 . METHOD_6 ( VAR_1 ) ; VAR_2 . METHOD_3 ( ) ; assertThat ( VAR_2 . METHOD_7 ( ) ) . METHOD_8 ( ) ; }
<|startcomment|> * super METHOD_2 ( ) public ? * want super METHOD_2 ( ) protected class open instead defining a new method : void METHOD_2 ( ) { super METHOD_2 ( ) ; } <|endcomment|> public void METHOD_1 ( ) { <START> this . METHOD_2 ( ) ; <END> }
<|startcomment|> a * * protected / private / default * * constructor * * List * * copied pointer t modified class javathis VAR_2 = VAR_2 clone ( ) ; I : _CODE_ b = TYPE_1 builder ( ) append ( key1 ) ; TYPE_1 jp1 = b build ( ) ; b append ( key2 ) ; TYPE_1 jp2 = b build ( ) ; ( jp1 toString ( ) equals ( jp2 toString ( ) ) { throw new Exception ( oops pointers sharing a backing array ) ; } <|endcomment|> <START> public TYPE_1 ( List < String > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> coudl ArrayList imported ^^ vv <|endcomment|> public VAR_1 ( ) { VAR_2 = new TYPE_1 ( ) ; VAR_3 = new TYPE_2 ( ) ; VAR_4 = new TYPE_3 ( ) ; <START> VAR_2 . METHOD_1 ( new TYPE_7 . TYPE_8 . ArrayList < TYPE_5 > ( ) ) ; <END> VAR_2 . METHOD_2 ( new TYPE_7 . TYPE_8 . ArrayList < TYPE_6 > ( ) ) ; VAR_5 = new TYPE_7 . TYPE_8 . HashMap < String , TYPE_5 > ( ) ; VAR_6 = "" ; VAR_7 = "" ; VAR_8 = false ; VAR_9 = 0 ; }
<|startcomment|> suggest private <|endcomment|> <START> long METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> other places suppress boxing warnings manually boxing code Integer valueOf ( ) expression especially true TYPE_1 format invocations common error paths I general approach preferred _CODE_ <|endcomment|> public TYPE_3 ( final int VAR_2 ) { if ( VAR_2 < 1 ) <START> throw new IllegalArgumentException ( TYPE_1 . format ( TYPE_2 . get ( ) . VAR_3 , VAR_2 ) ) ; <END> this . VAR_2 = VAR_2 - 1 ; }
<|startcomment|> missing braces ? VAR_1 1 VAR_3 METHOD_2 ( 10 ) returns 0 <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> VAR_1 = VAR_2 * VAR_3 . METHOD_2 ( 10 ) + 1 ; <END> METHOD_3 ( ) ; }
<|startcomment|> suggest protected signal subclass <|endcomment|> <START> TYPE_1 ( ) <END> { }
<|startcomment|> I wouldn t implement ( return null ) A long a fixed size METHOD_2 ( ) _CODE_ write file method more string structs want serialize <|endcomment|> public byte [ ] METHOD_1 ( ) { <START> return ByteBuffer . VAR_1 ( INT_1 ) . METHOD_2 ( VAR_2 ) . METHOD_3 ( ) ; <END> }
<|startcomment|> other article <|endcomment|> public String METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; <START> return VAR_1 . substring ( 0 , VAR_1 . METHOD_3 ( CHAR_1 ) ) ; <END> }
<|startcomment|> elena simply returning VAR_1 <|endcomment|> public int METHOD_1 ( ) { int result = VAR_1 ; result = INT_1 * result + VAR_1 ; <START> return result ; <END> }
<|startcomment|> required <|endcomment|> void METHOD_1 ( boolean VAR_1 ) { this . VAR_1 = VAR_1 ; if ( VAR_2 != null ) { <START> VAR_2 . METHOD_1 ( true ) ; <END> } }
<|startcomment|> hrmmm required ? happen cluster teardown ? redundant closing ( ) call <|endcomment|> public static void METHOD_1 ( ) throws Exception { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; } <START> VAR_2 . close ( ) ; <END> }
<|startcomment|> I give empty string input method <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> String VAR_1 = STRING_1 ; <END> assertThat ( TYPE_1 . METHOD_2 ( VAR_1 ) ) . METHOD_3 ( VAR_1 ) ; assertThat ( TYPE_1 . METHOD_2 ( VAR_1 + STRING_2 ) ) . METHOD_3 ( VAR_1 ) ; assertThat ( TYPE_1 . METHOD_2 ( VAR_1 + STRING_3 ) ) . METHOD_3 ( VAR_1 ) ; }
<|startcomment|> spell VAR_1 <|endcomment|> public Map < TYPE_1 , TYPE_2 > METHOD_1 ( TYPE_1 node , TYPE_2 context ) { <START> Map < TYPE_1 , TYPE_2 > VAR_1 = new TYPE_3 < > ( ) ; <END> VAR_1 . put ( node , null ) ; return VAR_1 ; }
<|startcomment|> private <|endcomment|> public int METHOD_1 ( ) { <START> return VAR_1 ; <END> }
<|startcomment|> simpler : } catch ( IOException e ) { throw e ; } catch ( Exception e ) { throw new IOException ( e ) ; } <|endcomment|> public TYPE_1 call ( ) throws IOException { if ( task == null ) { throw new IOException ( STRING_1 + this + STRING_2 ) ; } try { return task . call ( ) ; <START> } catch ( Exception ex ) { <END> if ( ex instanceof IOException ) { throw ( IOException ) ex ; } throw new IOException ( ex ) ; } }
<|startcomment|> please remove { } catch ( ) block altogether <|endcomment|> public static File task ( File VAR_1 , String VAR_2 ) throws IOException { File VAR_3 = new File ( VAR_1 . METHOD_1 ( ) , TYPE_1 . METHOD_2 ( VAR_2 ) ) ; try { if ( VAR_1 . METHOD_3 ( VAR_3 ) && TYPE_2 . METHOD_4 ( new File ( VAR_3 , VAR_4 ) , VAR_2 ) ) { return VAR_3 ; } else { throw new IOException ( STRING_1 + VAR_1 . METHOD_5 ( ) + STRING_2 + VAR_2 ) ; } } catch ( IOException e ) { <START> throw e ; <END> } }
<|startcomment|> remove extra variables aren t a setter <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { VAR_1 . METHOD_2 ( TYPE_6 . VAR_4 ) ; <START> TYPE_3 VAR_5 = TYPE_4 . METHOD_3 ( ) ; <END> VAR_1 . METHOD_4 ( VAR_5 ) ; TYPE_5 VAR_6 ; VAR_6 = VAR_2 . METHOD_5 ( ) ; VAR_1 . METHOD_6 ( VAR_6 ) ; VAR_1 . METHOD_7 ( VAR_2 . METHOD_8 ( ) ) ; Date VAR_7 = new Date ( ) ; VAR_1 . METHOD_9 ( VAR_7 ) ; VAR_1 . METHOD_10 ( METHOD_11 ( VAR_1 , VAR_2 . METHOD_12 ( ) ) ) ; return VAR_1 ; }
<|startcomment|> s a reason removing parametrized type TYPE_1 < T > setting VAR_1 loose type other methods state _CODE_ resout type <|endcomment|> <START> public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { <END> this . VAR_1 . addAll ( VAR_1 ) ; return this ; }
<|startcomment|> I generally prefer explicitly state access modifiers <|endcomment|> <START> long METHOD_1 ( ) { <END> return VAR_1 . get ( ) ; }
<|startcomment|> VAR_2 ( ) ? isn t a logger <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 key , TYPE_3 < TYPE_1 > VAR_1 ) { try { return VAR_1 . call ( ) ; } catch ( Exception e ) { <START> e . VAR_2 ( ) ; <END> return null ; } }
<|startcomment|> specific logic spilling a general function needs depend TYPE_2 METHOD_4 ( ) <|endcomment|> void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_1 . METHOD_3 ( ) && TYPE_2 . METHOD_4 ( ) && TYPE_3 . METHOD_5 ( ) <START> && TYPE_2 . METHOD_6 ( ) >= VAR_2 ? <END> VAR_3 : VAR_4 ) ; }
<|startcomment|> please remove unnecessary brackets : return config < Integer > getValue ( VAR_3 VAR_2 ! = null ? VAR_2 getValue ( ) : TYPE_1 METHOD_3 ( ) getValue ( ) <|endcomment|> public static int METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) { final TYPE_2 VAR_3 = METHOD_2 ( VAR_1 ) ; return TYPE_3 < Integer > getValue ( VAR_3 , <START> ( VAR_2 != null ) ? VAR_2 . getValue ( ) : TYPE_1 . METHOD_3 ( ) . getValue ( ) <END> ) ; }
<|startcomment|> incorrect VAR_1 command <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 ) { TYPE_6 . TYPE_7 . getInstance ( ) . METHOD_2 ( new TYPE_3 < TYPE_4 > ( ) { @Override public void METHOD_3 ( Throwable VAR_2 ) { new TYPE_5 ( STRING_1 + VAR_2 . getMessage ( ) ) ; METHOD_4 ( VAR_1 ) ; } @Override public void METHOD_5 ( TYPE_4 result ) { VAR_3 = result ; <START> METHOD_6 ( ) ; <END> METHOD_4 ( VAR_1 ) ; } } ) ; }
<|startcomment|> change bring ? need test working <|endcomment|> Context METHOD_1 ( boolean VAR_1 ) { Context context = new Context ( ) ; context . put ( VAR_2 , VAR_3 . METHOD_2 ( ) ) ; context . put ( VAR_4 , String . valueOf ( VAR_1 ) ) ; <START> context . put ( STRING_1 , STRING_2 ) ; <END> context . put ( VAR_5 , VAR_6 ) ; return context ; }
<|startcomment|> return null <|endcomment|> private String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 . contains ( VAR_1 ) ) return STRING_1 ; if ( VAR_3 . contains ( VAR_1 ) ) return STRING_2 ; else if ( VAR_4 . contains ( VAR_1 ) ) return STRING_3 ; <START> return STRING_4 ; <END> }
<|startcomment|> constant VAR_6 removed constant class <|endcomment|> private TYPE_1 METHOD_1 ( ) { switch ( this ) { case VAR_1 : return TYPE_2 . METHOD_2 ( STRING_1 ) ; case VAR_2 : return TYPE_2 . METHOD_2 ( STRING_2 ) ; case VAR_3 : return TYPE_2 . METHOD_2 ( STRING_3 ) ; case VAR_4 : return TYPE_2 . METHOD_2 ( STRING_4 ) ; case VAR_5 : return TYPE_2 . METHOD_2 ( STRING_4 ) ; case VAR_6 : <START> break ; <END> } return null ; }
<|startcomment|> I a liner : javathis VAR_1 = new HashMap < > ( VAR_1 ) ; <|endcomment|> public void METHOD_1 ( Map < String , Object > VAR_1 ) { <START> this . VAR_1 = new HashMap < > ( ) ; <END> for ( Object key : Collections . list ( VAR_1 . METHOD_2 ( ) ) ) { this . VAR_1 . put ( ( String ) key , VAR_1 . get ( key ) ) ; } }
<|startcomment|> private <|endcomment|> <START> protected <END> TYPE_1 METHOD_1 ( Integer VAR_1 , Guid VAR_2 ) { return METHOD_2 ( ) . METHOD_3 ( STRING_1 , Guid . VAR_3 ( ) ) . METHOD_3 ( STRING_2 , VAR_2 ) . METHOD_3 ( STRING_3 , VAR_1 ) ; }
<|startcomment|> I flip clarity : return data = = null ? null : METHOD_1 ( VAR_2 METHOD_2 ( VAR_3 METHOD_3 ( data ) ) ; <|endcomment|> public String read ( String key ) { String data = VAR_1 . read ( key ) ; <START> return ( data != null ) ? METHOD_1 ( VAR_2 . METHOD_2 ( VAR_3 , METHOD_3 ( data ) ) ) : data ; <END> }
<|startcomment|> super METHOD_2 ( ) method throw exception <|endcomment|> <START> public void METHOD_1 ( ) throws Exception { <END> super . METHOD_2 ( ) ; }
<|startcomment|> null acceptable VAR_1 null represent selected need Optional <|endcomment|> <START> <END> <END> public <END> <END> TYPE_1 METHOD_1 <END> <END> ( <END> TYPE_2 <END> VAR_1 <END> ) { <END> <END> <END> VAR_2 = Optional .
<|startcomment|> import static Assert assertEquals ( ) <|endcomment|> public void METHOD_1 ( ) { org . VAR_1 . VAR_2 . entity . TYPE_3 VAR_4 = VAR_5 . METHOD_2 ( METHOD_3 ( ) ) ; TYPE_1 VAR_6 = TYPE_2 . METHOD_4 ( VAR_4 . METHOD_5 ( ) ) ; <START> Assert . assertEquals ( STRING_1 , VAR_4 . METHOD_6 ( ) ) ; <END> Assert . assertEquals ( TYPE_4 . VAR_8 , VAR_6 . getType ( ) ) ; }
<|startcomment|> a set a negative size <|endcomment|> void METHOD_1 ( ) { for ( String VAR_1 : VAR_2 . METHOD_2 ( ) ) { Set < ? extends TYPE_1 < ? extends TYPE_2 > > VAR_3 = client . VAR_4 ( VAR_1 ) ; assertNotNull ( VAR_3 ) ; <START> assertTrue ( VAR_3 . size ( ) >= 0 ) ; <END> } }
<|startcomment|> package private enough testing package tests <|endcomment|> <START> public static String METHOD_1 ( String s ) { <END> if ( s == null ) { return null ; } if ( ! s . VAR_1 ( STRING_1 ) ) { return STRING_2 + s + STRING_2 ; } else { return s ; } }
<|startcomment|> offline discussion aman remove check serialize METHOD_3 ( ) <|endcomment|> public Object METHOD_1 ( ) { if ( VAR_1 == TYPE_3 . VAR_3 ) { <START> if ( VAR_4 == TYPE_2 . VAR_6 ) { <END> return ( ( TYPE_1 ) VAR_7 ) . METHOD_2 ( ) ; } else { return new String ( ( ( TYPE_1 ) VAR_7 ) . METHOD_3 ( ) ) ; } } return VAR_7 ; }
<|startcomment|> VAR_2 enough <|endcomment|> public int METHOD_1 ( ) { <START> int result = name . VAR_1 ( ) ; <END> result = INT_1 * result + VAR_2 . METHOD_1 ( ) ; return result ; }
<|startcomment|> I checking > 0 clearer a static DEFAULT_TIMEOUT = - 1 _CODE_ change checks VAR_1 ! = DEFAULT_TIMEOUT lines <|endcomment|> private TYPE_1 METHOD_1 ( int VAR_1 ) { return TYPE_1 . METHOD_2 ( ) . METHOD_3 ( true ) <START> . METHOD_4 ( VAR_1 > 0 ? VAR_1 : VAR_2 ) <END> . build ( ) ; }
<|startcomment|> line break ( set <|endcomment|> TYPE_6 ( TYPE_1 VAR_2 , TYPE_2 info ) { this . VAR_2 = VAR_2 ; TYPE_3 VAR_3 = info . VAR_3 ( ) ; if ( VAR_3 != null ) { VAR_4 = TYPE_4 . METHOD_1 ( VAR_3 ) ; VAR_5 = VAR_2 . METHOD_2 ( VAR_4 . METHOD_3 ( ) , VAR_4 . METHOD_4 ( ) , <START> TYPE_5 . create ( ) . set ( STRING_1 , <END> TYPE_7 . VAR_7 . METHOD_5 ( ) ) ) ; } }
<|startcomment|> pretty lonely semicolon : wink : <|endcomment|> public void METHOD_1 ( String VAR_1 , String VAR_2 ) { METHOD_2 ( VAR_1 ) ; new TYPE_1 ( STRING_1 ) . METHOD_3 ( ) ; String VAR_3 = "" ; TYPE_2 VAR_4 = new TYPE_3 ( ) ; List < String > VAR_5 = VAR_4 . METHOD_4 ( ) ; for ( String item : VAR_5 ) { if ( item . contains ( VAR_2 ) ) { VAR_3 = item ; break ; } } VAR_4 . METHOD_5 ( VAR_3 ) ; <START> ; <END> new TYPE_4 ( ) . METHOD_6 ( ) ; }
<|startcomment|> need log ? a command a log running a command <|endcomment|> public void METHOD_1 ( Collection < Guid > VAR_1 ) { for ( final Guid VAR_2 : VAR_1 ) { <START> log . VAR_3 ( STRING_1 , VAR_2 ) ; <END> TYPE_1 . execute ( new TYPE_2 ( ) { @Override public void run ( ) { TYPE_3 . getInstance ( ) . METHOD_2 ( TYPE_7 . TYPE_6 , new TYPE_4 ( VAR_2 ) , TYPE_5 . METHOD_3 ( ) ) ; } } ) ; } }
<|startcomment|> VAR_5 = TYPE_8 METHOD_3 ( VAR_5 ) <|endcomment|> public TYPE_9 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final TYPE_3 VAR_4 , final TYPE_4 < Pair < TYPE_5 , TYPE_6 > > VAR_5 ) { super ( log , VAR_2 . METHOD_1 ( ) , VAR_2 . METHOD_2 ( ) , VAR_3 , VAR_4 , new TYPE_7 < Set < TYPE_6 > > ( ) { } ) ; TYPE_8 . METHOD_3 ( VAR_5 ) ; <START> this . VAR_5 = VAR_5 ; <END> }
<|startcomment|> I don t work ? expose jackson user encoding decoding spring side SDK shouldn t mapper / converter logic instead <|endcomment|> protected void METHOD_1 ( final TYPE_1 . Builder builder ) { <START> TYPE_2 VAR_1 = new TYPE_2 ( ) ; <END> VAR_1 . METHOD_2 ( TYPE_7 . TYPE_8 . VAR_4 ) ; VAR_1 . METHOD_3 ( new TYPE_3 ( ) , new TYPE_4 ( ) ) ; TYPE_5 VAR_5 = new TYPE_5 ( ) ; VAR_5 . METHOD_4 ( new TYPE_3 ( ) ) ; VAR_5 . METHOD_4 ( new TYPE_4 ( ) ) ; builder . VAR_6 ( TYPE_6 . create ( VAR_5 ) ) ; }
<|startcomment|> _CODE_ enough process a topology change event discovery service more work refer _CODE_ combining events topology change leadership change a bit complex suggest call METHOD_2 topology change a notification API _CODE_ call fetch cached _CODE_ add more complexity doesn t completely solve problem <|endcomment|> public void METHOD_1 ( ) { log . debug ( STRING_1 ) ; VAR_1 = true ; METHOD_2 ( ) ; <START> METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <END> METHOD_5 ( ) ; }
<|startcomment|> return VAR_4 _CODE_ want introduce a local final <|endcomment|> public TYPE_1 METHOD_1 ( ) { METHOD_2 ( ) ; if ( VAR_1 ) { VAR_2 . info ( STRING_1 ) . c ( TYPE_2 . METHOD_3 ( ) ) . METHOD_4 ( ) ; } <START> TYPE_1 VAR_3 = VAR_4 . METHOD_5 ( ) ; return VAR_3 ; <END> }
<|startcomment|> strings <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> TYPE_1 config = METHOD_2 ( <END> STRING_1 + STRING_2 + STRING_3 + STRING_4 , TYPE_1 . class ) ; VAR_1 = new TYPE_2 ( TYPE_3 . METHOD_3 ( config ) , TYPE_3 . METHOD_3 ( VAR_2 ) ) ; }
<|startcomment|> TYPE_1 SC_ need TYPE_3 <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 result ) throws IOException { if ( result . VAR_2 ) { VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ; } else { <START> VAR_1 . METHOD_2 ( TYPE_3 . VAR_5 ) ; <END> } METHOD_3 ( VAR_1 , result . VAR_6 ( ) ) ; }
<|startcomment|> detach <|endcomment|> public TYPE_1 METHOD_1 ( Guid VAR_1 , Map < String , Object > VAR_2 ) { TYPE_2 request = new TYPE_3 ( STRING_1 ) . METHOD_2 ( STRING_2 , <START> VAR_1 ) <END> . METHOD_2 ( STRING_3 , VAR_2 ) . build ( ) ; Map < String , Object > response = new TYPE_4 ( this . client , request ) ; Map < String , Object > info = ( Map < String , Object > ) response . get ( STRING_4 ) ; return new TYPE_1 ( info ) ; }
<|startcomment|> a paranoia sufferer I invert equals avoid remote possibility a NPE : javaif ( TYPE_5 TYPE_6 equals ( VAR_3 getName ( ) ) ) { <|endcomment|> public static void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_2 ... VAR_2 ) { TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 ) ; for ( final TYPE_2 VAR_3 : VAR_2 ) { <START> if ( VAR_3 . getName ( ) . equals ( TYPE_5 . TYPE_6 ) ) { <END> continue ; } VAR_1 . METHOD_3 ( VAR_3 ) ; } }
<|startcomment|> path initialized a necessary <|endcomment|> public String METHOD_1 ( ) { <START> if ( "" . equals ( this . path ) || STRING_1 . equals ( this . path ) ) { <END> return STRING_1 ; } if ( this . path . VAR_1 ( STRING_1 ) ) { return this . path + STRING_2 ; } return this . path + STRING_3 ; }
<|startcomment|> a standalone function return _CODE_ remove temporary variable <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 ; try { <START> VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> } catch ( TYPE_3 e ) { throw new TYPE_4 ( VAR_3 , STRING_1 + VAR_1 . METHOD_4 ( ) , e ) ; } return VAR_2 ; }
<|startcomment|> _CODE_ test please equals hashcode <|endcomment|> public int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; <START> } <END>
<|startcomment|> return empty list instead <|endcomment|> protected final List < TYPE_1 > METHOD_1 ( TYPE_2 ctx ) { <START> return null ; <END> }
<|startcomment|> s a spacing issue spaces instead 4 <|endcomment|> protected boolean METHOD_1 ( String VAR_1 ) { <START> boolean VAR_2 = false ; <END> Set < String > VAR_3 = METHOD_2 ( ) ; if ( VAR_3 . contains ( VAR_1 ) ) { log . debug ( STRING_1 + VAR_1 ) ; VAR_2 = true ; } return VAR_2 ; }
<|startcomment|> log debug <|endcomment|> private TYPE_1 METHOD_1 ( String VAR_1 ) throws RuntimeException { <START> log . info ( STRING_1 ) ; <END> TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_2 ) ; return VAR_2 ; }
<|startcomment|> releases request IOException thrown <|endcomment|> public void METHOD_1 ( TYPE_1 request ) throws IOException { if ( ! VAR_1 ) { throw new TYPE_2 ( ) ; } while ( ! request . VAR_2 ( ) ) { request . VAR_3 ( VAR_4 ) ; } <START> request . VAR_5 ( ) ; <END> }
<|startcomment|> revert order deterministic <|endcomment|> public void METHOD_1 ( ) { assertThat ( TYPE_1 . METHOD_2 ( "" ) , METHOD_3 ( 0 ) ) ; assertThat ( TYPE_1 . METHOD_2 ( STRING_1 ) , contains ( STRING_2 ) ) ; assertThat ( TYPE_1 . METHOD_2 ( STRING_3 ) , <START> METHOD_4 ( STRING_4 , STRING_5 , STRING_6 , STRING_7 ) ) ; <END> }
<|startcomment|> I d check exception class parameters message isn t user <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = when ( METHOD_2 ( TYPE_1 . class ) . METHOD_3 ( ) ) . METHOD_4 ( false ) . METHOD_5 ( ) ; TYPE_2 result = VAR_2 . METHOD_6 ( METHOD_7 ( TYPE_3 . VAR_4 + STRING_1 ) ) . METHOD_8 ( ) ; <START> assertEquals ( result . VAR_5 ( ) . getMessage ( ) , STRING_2 ) ; <END> }
<|startcomment|> doesn t _CODE_ depend a _CODE_ instance created system ? TYPE_2 start ( ) called I call a time <|endcomment|> public void METHOD_1 ( Context ctx , TYPE_1 VAR_1 ) { String action = VAR_1 . METHOD_2 ( ) ; switch ( action ) { case VAR_2 : METHOD_3 ( ctx , VAR_1 ) ; break ; case TYPE_1 . VAR_3 : METHOD_4 ( ctx ) ; TYPE_2 . start ( ctx . VAR_4 ( ) ) ; break ; <START> default : <END> TYPE_3 . d ( STRING_1 + action ) ; break ; } }
<|startcomment|> overloaded method please don t pass null ? _CODE_ VAR_2 = TYPE_2 METHOD_2 ( VAR_1 ) ; <|endcomment|> private String METHOD_1 ( String VAR_1 , String token ) { if ( ! StringUtils . isEmpty ( VAR_1 ) ) { <START> TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 , null ) ; <END> if ( VAR_2 != null ) { logger . VAR_3 ( STRING_1 ) ; return VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; } } logger . VAR_3 ( STRING_2 ) ; return token ; }
<|startcomment|> able drop options ! = null check <|endcomment|> void METHOD_1 ( Exception e , TYPE_1 options ) { <START> if ( options != null && options . VAR_1 ( ) == TYPE_1 . TYPE_2 . TYPE_3 ) { <END> METHOD_2 ( e ) ; } else { METHOD_3 ( e , options ) ; } }
<|startcomment|> add ANNOTATION_1 s worth checking null safely assume client method fulfilling null pre - condition IDE client method a null argument passed remove ANNOTATION_1 remove check ! = null <|endcomment|> <START> public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { <END> if ( VAR_2 != null ) { METHOD_2 ( ) ; } this . VAR_2 = VAR_1 ; }
<|startcomment|> parentheses - line statements <|endcomment|> public void METHOD_1 ( TYPE_1 split ) throws IOException { super . METHOD_1 ( split ) ; <START> if ( VAR_1 != null ) <END> it = VAR_1 ; else it = this . VAR_2 . iterator ( ) ; }
<|startcomment|> remove ? I realize I don t example <|endcomment|> @Override protected void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; TYPE_2 VAR_2 = new TYPE_2 ( this ) ; VAR_2 . setText ( STRING_1 ) ; METHOD_2 ( VAR_2 ) ; METHOD_3 ( STRING_2 , STRING_3 , STRING_4 , STRING_5 ) ; Log . i ( STRING_6 , STRING_7 + METHOD_4 ( 4 ) ) ; TYPE_3 VAR_3 = new TYPE_3 ( STRING_8 ) ; Log . d ( STRING_9 , VAR_3 . METHOD_5 ( ) ) ; METHOD_6 ( ) ; <START> synchronized ( Boolean . VAR_4 ) { } <END> }
<|startcomment|> please remove VAR_2 a workaround absence TYPE_1 keySet ( ) android 2 x don t support android 2 more remove places replace VAR_1 keySet ( ) s read <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_1 values = VAR_1 ; if ( values == null ) { values = new TYPE_1 ( ) ; VAR_1 = values ; <START> VAR_2 = new HashSet < > ( ) ; <END> } return values ; }
<|startcomment|> parameter bee removed <|endcomment|> private TYPE_1 < ? extends TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { TYPE_4 VAR_2 = new TYPE_4 ( VAR_1 . getName ( ) , VAR_1 . METHOD_2 ( ) , null , false , <START> METHOD_3 ( VAR_1 , context . VAR_3 , true ) ) ; <END> TYPE_5 VAR_4 = new TYPE_5 ( new HashSet < > ( ) , new HashSet < > ( ) , VAR_2 ) ; return TYPE_6 . get ( VAR_4 , context . VAR_5 ) ; }
<|startcomment|> purpose _CODE_ ? <|endcomment|> public long METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { long VAR_2 = 0 ; TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_4 ) ; VAR_2 = VAR_1 . METHOD_3 ( VAR_3 , VAR_5 ) ; if ( VAR_2 != VAR_5 ) { throw new IOException ( STRING_1 + VAR_5 + STRING_2 + VAR_2 ) ; } <START> return VAR_2 ; <END> }
<|startcomment|> exists check done SNAPSHOT jars intentionally updated everytime SNAPSHOT jars testing designed updated run else reason method METHOD_1 exist i guess failure a result running concurrent jobs SNAPSHOT jars <|endcomment|> static void METHOD_1 ( File VAR_1 , Path VAR_2 , TYPE_1 VAR_3 , TYPE_2 job ) throws IOException { final Path VAR_4 = new Path ( VAR_2 , VAR_1 . getName ( ) ) ; <START> if ( ! VAR_5 . contains ( VAR_4 ) || ! VAR_3 . exists ( VAR_4 ) ) { <END> METHOD_2 ( VAR_1 , VAR_4 , VAR_3 ) ; VAR_5 . add ( VAR_4 ) ; } job . VAR_6 ( VAR_4 ) ; }
<|startcomment|> s listener unregister stop time instead storing a boolean instance _CODE_ init implementation _CODE_ <|endcomment|> public void start ( TYPE_1 context ) { super . start ( context ) ; VAR_1 . forEach ( this : : METHOD_1 ) ; VAR_2 . forEach ( this : : METHOD_2 ) ; if ( ! VAR_3 ) { TYPE_2 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( new TYPE_3 ( ) ) ; <START> VAR_3 = true ; <END> } }
<|startcomment|> please info level <|endcomment|> public void METHOD_1 ( int id , TYPE_4 . TYPE_5 status , long VAR_1 ) throws TYPE_2 { TYPE_3 message = session . VAR_2 ( STRING_1 + VAR_3 . getProperty ( STRING_2 ) + STRING_3 + id + STRING_3 + status + STRING_3 + VAR_1 ) ; VAR_4 . METHOD_2 ( message , TYPE_6 . VAR_6 , INT_1 , 0 ) ; <START> log . debug ( STRING_4 , id , status ) ; <END> }
<|startcomment|> done lazily ? ll need case <|endcomment|> public final TYPE_1 < T > METHOD_1 ( ) { <START> if ( VAR_1 != null && VAR_2 == null ) { <END> VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; } return VAR_2 ; }
<|startcomment|> configuration wouldn t more sense show parameters output accept input fix validation s done UI <|endcomment|> protected Object METHOD_1 ( ) throws Exception { String VAR_1 = METHOD_2 ( STRING_1 ) ; TYPE_1 VAR_2 ; if ( VAR_1 != null ) { TYPE_2 VAR_3 = VAR_4 . METHOD_3 ( ) . METHOD_4 ( VAR_1 ) ; VAR_2 = VAR_4 . METHOD_5 ( VAR_3 , VAR_5 ) ; } else { VAR_2 = VAR_4 . METHOD_5 ( VAR_5 ) ; } if ( VAR_2 == null ) { throw new TYPE_3 ( STRING_2 + VAR_1 + STRING_3 , Status . VAR_6 ) ; } <START> return VAR_2 . METHOD_6 ( true ) ; <END> }
<|startcomment|> return result METHOD_5 instead local variable <|endcomment|> private String METHOD_1 ( TYPE_1 request ) { String VAR_1 = "" ; try { byte [ ] VAR_2 = request . VAR_3 ( ) == null ? "" . METHOD_2 ( ) : TYPE_2 . METHOD_3 ( request . VAR_3 ( ) . METHOD_4 ( ) ) ; <START> VAR_1 = METHOD_5 ( VAR_2 ) ; <END> } catch ( IOException e ) { throw new TYPE_3 ( STRING_1 , e ) ; } return VAR_1 ; }
<|startcomment|> s a harsh return null deprecated method work original implementation ? t method read _CODE_ information <|endcomment|> public Map < Long , TYPE_1 > METHOD_1 ( TYPE_2 id ) { <START> return null ; <END> }
<|startcomment|> don t need METHOD_8 ( ) wait <|endcomment|> public void METHOD_1 ( ) throws Throwable { int VAR_1 = 100 ; int VAR_2 = 100 ; VAR_3 . METHOD_2 ( ( ) - > { VAR_4 . METHOD_3 ( VAR_2 ) ; VAR_4 . METHOD_4 ( VAR_5 . R . VAR_6 . VAR_7 ) ; VAR_4 . METHOD_5 ( VAR_1 ) ; } ) ; <START> TYPE_1 . METHOD_6 ( ) . METHOD_7 ( ) ; <END> METHOD_8 ( METHOD_9 ( R . id . VAR_8 ) ) . METHOD_10 ( METHOD_11 ( METHOD_12 ( VAR_2 + VAR_1 ) ) ) ; }
<|startcomment|> static import <|endcomment|> TYPE_1 < TYPE_2 > METHOD_1 ( ) { return VAR_1 <START> . METHOD_2 ( VAR_2 - > TYPE_3 . METHOD_3 ( ) <END> . METHOD_4 ( VAR_3 - > VAR_2 . METHOD_5 ( s - > { VAR_4 . METHOD_3 ( VAR_3 ) . METHOD_6 ( ) ; VAR_5 . METHOD_3 ( VAR_3 ) . METHOD_6 ( ) ; } ) ) ) ; }
<|startcomment|> change lock released some cases change case a failure _CODE_ responsible releasing lock _CODE_ releases lock case catches exception case a time - other _CODE_ vdsm failure lock unlocked <|endcomment|> public void METHOD_1 ( Throwable t ) { log . error ( STRING_1 , TYPE_1 . METHOD_2 ( t ) ) ; log . debug ( STRING_2 , t ) ; <START> METHOD_3 ( false , VAR_1 . METHOD_4 ( false ) ) ; <END> }
<|startcomment|> reason create new instance TYPE_3 VAR_7 static <|endcomment|> public TYPE_4 ( long VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , int VAR_5 , int VAR_6 ) { this ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , <START> new TYPE_3 ( ) . VAR_7 ) ; <END> }
<|startcomment|> elena t VAR_1 <|endcomment|> public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { List < TYPE_3 > VAR_2 = TYPE_4 . METHOD_2 ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { VAR_2 . add ( VAR_3 ) ; } <START> return new TYPE_1 ( VAR_2 ) ; <END> }
<|startcomment|> rely _CODE_ toString <|endcomment|> public void METHOD_1 ( ) { log . debug ( STRING_1 , <START> Arrays . toString ( super . VAR_1 . METHOD_2 ( ) ) ) ; <END> METHOD_3 ( ) ; }
<|startcomment|> constructor public <|endcomment|> <START> TYPE_1 ( String value ) { <END> super ( STRING_1 , value ) ; }
<|startcomment|> flip order checks - more intuitive IMO time valid time valid <|endcomment|> private boolean METHOD_1 ( long VAR_1 , long VAR_2 ) { <START> return VAR_1 < VAR_2 && VAR_1 != Utils . TYPE_1 ; <END> }
<|startcomment|> please METHOD_7 stdout / stderr please log instead output silenced build infrastructure <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( TYPE_2 . METHOD_3 ( ) , VAR_2 . TYPE_4 ) ; assertEquals ( STRING_1 , VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ) ; TYPE_3 e = METHOD_6 ( VAR_1 , VAR_2 . TYPE_5 ) ; assertNotNull ( e ) ; <START> METHOD_7 ( e ) ; <END> assertNotNull ( METHOD_6 ( e , VAR_2 . TYPE_7 ) ) ; assertNotNull ( METHOD_6 ( e , VAR_6 . TYPE_6 ) ) ; }
<|startcomment|> local variable declared bad scope <|endcomment|> public View METHOD_1 ( final View view ) { View VAR_1 = null ; <START> TYPE_1 container ; <END> if ( view != null ) { container = view . VAR_2 ( ) ; if ( METHOD_2 ( container ) || METHOD_3 ( container ) || METHOD_4 ( container ) ) { container = container . VAR_2 ( ) ; } if ( container instanceof View ) { VAR_1 = ( View ) container ; } } return VAR_1 ; }
<|startcomment|> I don t method called a constructor <|endcomment|> public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 parser ) { super ( VAR_2 , VAR_3 , VAR_4 , parser , stream ) ; this . VAR_2 = VAR_2 ; this . parser = parser ; <START> METHOD_1 ( ) ; <END> }
<|startcomment|> necessary ? AFAIK VAR_2 key _CODE_ <|endcomment|> public String toString ( ) { Object VAR_1 = VAR_2 ; Object VAR_3 = key ; <START> if ( VAR_1 instanceof TYPE_1 ) { <END> VAR_1 = ( ( TYPE_1 ) VAR_1 ) . get ( ) ; } if ( VAR_3 instanceof TYPE_1 ) { VAR_3 = ( ( TYPE_1 ) VAR_3 ) . get ( ) ; } return STRING_1 + VAR_1 + STRING_2 + VAR_3 + STRING_3 ; }
<|startcomment|> VAR_1 = = null true checked upfront ( correctly results null ) move empty string 0 length check functions <|endcomment|> static String METHOD_1 ( String VAR_1 , int VAR_2 ) { <START> if ( VAR_1 == null || VAR_1 . isEmpty ( ) || VAR_2 == 0 ) { <END> return "" ; } if ( VAR_2 > 0 ) { return VAR_1 . substring ( 0 , Math . VAR_3 ( VAR_2 , VAR_1 . length ( ) ) ) ; } final int VAR_4 = VAR_1 . length ( ) + VAR_2 ; return VAR_4 > 0 ? VAR_1 . substring ( 0 , VAR_4 ) : "" ; }
<|startcomment|> happen sinceorg springframework web bind annotation _CODE_ default true <|endcomment|> public TYPE_1 METHOD_1 ( ANNOTATION_1 ANNOTATION_2 TYPE_2 VAR_1 , TYPE_3 VAR_2 , ANNOTATION_3 ( TYPE_6 . VAR_4 ) String VAR_5 ) { <START> if ( VAR_1 == null ) <END> { throw new TYPE_4 ( STRING_1 , VAR_2 ) ; } if ( VAR_2 . METHOD_2 ( ) ) { throw new TYPE_4 ( VAR_6 , VAR_2 ) ; } TYPE_5 VAR_7 = VAR_8 . METHOD_3 ( VAR_1 , TYPE_5 . class ) ; return METHOD_4 ( config - > METHOD_1 ( config , VAR_7 ) , ( ) - > VAR_9 , VAR_5 ) ; }
<|startcomment|> minor : decrease visibility modifier some methods change some methods static <|endcomment|> <START> public TYPE_2 ( TYPE_1 parent ) { <END> super ( parent ) ; }
<|startcomment|> aboutthis VAR_2 = TYPE_2 METHOD_1 ( VAR_2 ) <|endcomment|> TYPE_3 ( TYPE_1 VAR_2 ) { TYPE_2 . METHOD_1 ( VAR_2 ) ; <START> this . VAR_2 = VAR_2 ; <END> }
<|startcomment|> METHOD_1 ( null null ) <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> return session . VAR_1 ( ) . METHOD_1 ( this , 0 , session . VAR_1 ( ) . METHOD_2 ( this ) . METHOD_3 ( ) ) ; <END> }
<|startcomment|> coding practices : interface i = new implementation ( ) ; <|endcomment|> public List < String > METHOD_1 ( ) { ArrayList < String > VAR_1 = new ArrayList < > ( this . VAR_2 ) ; <START> <END> for ( int i = 0 ; i < this . VAR_2 ; i ++ ) { VAR_1 . add ( METHOD_2 ( i ) ) ; } return VAR_1 ; }
<|startcomment|> needed default initialized 0 <|endcomment|> public TYPE_3 ( final TYPE_1 VAR_2 , final double VAR_3 , final boolean VAR_4 , final int VAR_5 ) { TYPE_2 . METHOD_1 ( VAR_5 >= 1 , STRING_1 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> this . VAR_6 = 0 ; <END> }
<|startcomment|> intentional change originial <|endcomment|> public void run ( ) { <START> LOG . trace ( STRING_1 ) ; <END> VAR_1 = new TYPE_1 ( 10 ) ; List < TYPE_2 > VAR_2 = new ArrayList < > ( ) ; try { for ( TYPE_3 entity : VAR_3 . keySet ( ) ) { VAR_2 . add ( VAR_1 . METHOD_1 ( new TYPE_4 ( entity , VAR_3 . get ( entity ) ) ) ) ; } METHOD_2 ( VAR_2 ) ; } finally { VAR_1 . METHOD_3 ( ) ; } }
<|startcomment|> VAR_1 set null check _CODE_ remove log output <|endcomment|> public void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; Log . d ( TAG , STRING_1 ) ; <START> } <END> super . METHOD_1 ( ) ; }
<|startcomment|> needed ( null won t ) <|endcomment|> private void METHOD_1 ( TYPE_1 parameters , TYPE_2 VAR_1 ) { if ( getParameters ( ) . METHOD_2 ( ) . equals ( VAR_1 . METHOD_3 ( ) ) ) { TYPE_3 . getInstance ( ) . METHOD_4 ( VAR_1 , <START> parameters . VAR_2 ( ) ? TYPE_6 . TYPE_5 : TYPE_6 . TYPE_4 , VAR_1 . METHOD_5 ( ) ) ; <END> } }
<|startcomment|> private <|endcomment|> <START> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , Optional < String > VAR_4 , <END> Optional < String > VAR_5 , Optional < TYPE_3 > VAR_6 ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; this . VAR_4 = METHOD_1 ( VAR_4 ) ; this . VAR_5 = METHOD_1 ( VAR_5 ) ; this . VAR_6 = METHOD_1 ( VAR_6 ) ; }
<|startcomment|> necessary protocol case - insensitive - equalsIgnoreCase <|endcomment|> private static boolean METHOD_1 ( final String VAR_1 , final int VAR_2 ) { <START> return VAR_2 > - 1 && ( ( TYPE_1 . equals ( VAR_1 ) && VAR_2 != INT_1 ) || ( TYPE_2 . equals ( VAR_1 ) && VAR_2 != INT_2 ) ) ; <END> }
<|startcomment|> inline vars <|endcomment|> public void METHOD_1 ( TYPE_1 data ) { int VAR_1 = data . VAR_2 ( ) ; <START> TYPE_2 page = data . VAR_3 ( ) ; <END> TYPE_3 VAR_4 = data . VAR_5 ( ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { VAR_4 . METHOD_2 ( page ) ; } VAR_4 . METHOD_3 ( ) ; }
<|startcomment|> import static <|endcomment|> private TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( TYPE_2 . VAR_2 , entity . VAR_3 ( ) ) ; <END> }
<|startcomment|> resolve groups recursive search <|endcomment|> private TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( TYPE_4 . getInstance ( ) . METHOD_3 ( VAR_2 ) , <START> VAR_1 , true , true ) ; <END> if ( VAR_3 == null ) { throw new RuntimeException ( String . format ( STRING_1 , VAR_1 , VAR_2 ) ) ; } return new TYPE_1 ( TYPE_5 . METHOD_4 ( VAR_2 , VAR_3 ) ) ; }
<|startcomment|> lambda <|endcomment|> public TYPE_3 ( ) { super ( VAR_2 ) ; <START> this . METHOD_1 ( new TYPE_1 ( ) { @Override public void METHOD_2 ( TYPE_2 event ) { if ( event . getProperty ( ) . equals ( TYPE_4 . VAR_4 ) ) { Object VAR_5 = event . VAR_6 ( ) ; if ( VAR_5 instanceof String ) { String data = ( String ) VAR_5 ; VAR_7 . METHOD_3 ( data ) ; METHOD_4 ( VAR_7 . METHOD_5 ( ) ) ; METHOD_6 ( ) ; <END> } } } } ) ; }
<|startcomment|> I && <|endcomment|> public void METHOD_1 ( double VAR_1 ) { <START> if ( this . VAR_1 == null || VAR_1 > this . VAR_1 ) { <END> this . VAR_1 = VAR_1 ; } }
<|startcomment|> minor : remove throws <|endcomment|> <START> Object getValue ( Object obj ) throws Exception { <END> throw new TYPE_1 ( STRING_1 ) ; }
<|startcomment|> debugging purpose result local necessary <|endcomment|> public boolean apply ( TYPE_1 resource ) { TYPE_2 < TYPE_3 > VAR_1 = new TYPE_4 ( VAR_2 ) ; <START> boolean result = TYPE_5 . METHOD_1 ( TYPE_6 < TYPE_3 > METHOD_2 ( resource , false ) , VAR_1 ) ; <END> return result ; }
<|startcomment|> VAR_3 null please add a null check <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 token ) { String VAR_1 = token . VAR_2 ( ) ; <START> TYPE_3 VAR_3 = this . VAR_4 . METHOD_2 ( VAR_1 ) ; <END> Object VAR_5 = VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) . get ( STRING_1 ) ; TYPE_1 result = null ; if ( VAR_5 != null ) { result = TYPE_1 . create ( VAR_5 . toString ( ) ) ; } return result ; }
<|startcomment|> VAR_3 <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = <START> VAR_4 ; <END> }
<|startcomment|> I some surprising results adding additional test cases doubles : * Double _CODE_ input returns 1 0 ( edit : Double MIN_VALUE fine I forgot slightly greater 0 ) <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( 1 ) ; addAll ( VAR_1 , 0 , 1 , 2 , 3 , 4 , 5 , INT_1 , INT_2 , INT_3 , INT_4 ) ; VAR_2 . METHOD_2 ( format ( STRING_1 , METHOD_3 ( VAR_1 ) ) , <START> VAR_3 , <END> FLOAT_1 ) ; VAR_2 . METHOD_2 ( format ( STRING_2 , METHOD_3 ( VAR_1 ) ) , VAR_3 , FLOAT_2 ) ; VAR_2 . METHOD_2 ( format ( STRING_3 , METHOD_3 ( VAR_1 ) ) , VAR_3 , FLOAT_3 ) ; }
<|startcomment|> I m capitalization needs consistent overutilized 2 lines capitalized differently <|endcomment|> public boolean METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> }
<|startcomment|> VAR_1 synchronized move VAR_1 checks METHOD_2 method execute ( ) method <|endcomment|> public String METHOD_1 ( ) throws TYPE_1 { <START> if ( VAR_1 == null ) <END> METHOD_2 ( ) ; synchronized ( METHOD_3 ( ) . METHOD_4 ( ) ) { return VAR_1 . METHOD_1 ( ) ; } }
<|startcomment|> return false <|endcomment|> public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) != null || getParameters ( ) . isEmpty ( ) ; <END> }
<|startcomment|> shound t ctor public protected ? I don t reason protected methods <|endcomment|> <START> TYPE_3 ( TYPE_1 < ? > factory , List < TYPE_2 > VAR_2 , <END> boolean VAR_3 ) { Assert . VAR_4 ( factory , STRING_1 ) ; Assert . VAR_4 ( VAR_2 , STRING_2 ) ; Assert . VAR_5 ( VAR_2 . size ( ) > 0 , STRING_3 ) ; this . factory = factory ; this . VAR_2 . addAll ( VAR_2 ) ; this . VAR_3 = VAR_3 ; this . iterator = this . VAR_2 . iterator ( ) ; }
<|startcomment|> tricky ! METHOD_1 currently checks WRITE_META permission entity acl created check breaks _CODE_ <|endcomment|> public void add ( TYPE_1 entity ) { METHOD_1 ( entity ) ; <START> METHOD_2 ( entity ) ; <END> super . add ( entity ) ; }
<|startcomment|> please add throws IOException _CODE_ _CODE_ search <|endcomment|> private TYPE_1 METHOD_1 ( Path p ) { <START> return TYPE_2 . METHOD_2 ( TYPE_3 : : METHOD_3 ) . apply ( ( TYPE_4 ) p ) ; <END> }
<|startcomment|> avoid accidental class casts signature : public < T extends TYPE_2 > TYPE_1 < T > METHOD_1 ( T node ) unchecked casts regrouped method ( clients ) <|endcomment|> <START> public TYPE_1 < ? extends TYPE_2 > METHOD_1 ( TYPE_2 node ) { <END> TYPE_1 < ? extends TYPE_2 > VAR_1 = null ; if ( node instanceof TYPE_3 ) { VAR_1 = new TYPE_4 ( ) ; } else if ( node instanceof TYPE_5 ) { VAR_1 = new TYPE_6 ( ) ; } else if ( node instanceof TYPE_7 ) { VAR_1 = new TYPE_8 ( ) ; } return VAR_1 ; }
<|startcomment|> please don t cleanups commit bugfixes / features / improvements <|endcomment|> public boolean METHOD_1 ( ) { TYPE_1 conf = VAR_1 . METHOD_2 ( ) ; <START> return conf . VAR_2 ( ) || conf . VAR_3 ( ) ; <END> }
<|startcomment|> style issue : please braces a multiline conditional <|endcomment|> public void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( ) ; <START> if ( VAR_1 . METHOD_3 ( ) != TYPE_1 . VAR_3 ) <END> METHOD_4 ( ) ; if ( VAR_4 ) { VAR_1 . METHOD_5 ( true ) ; VAR_4 = false ; } }
<|startcomment|> i d events ( ) model upgrade emitting events Status flags change properly set s baby steps introduce events ( some other good reason mentioned s need ) <|endcomment|> protected void METHOD_1 ( ) throws IOException { final String VAR_1 = METHOD_2 ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ; final String VAR_3 = METHOD_5 ( ) . METHOD_6 ( ) ; if ( VAR_1 . equals ( VAR_3 ) ) { METHOD_7 ( false ) ; } else { METHOD_7 ( true ) ; METHOD_5 ( ) . METHOD_8 ( VAR_1 ) ; METHOD_9 ( ) ; <START> VAR_4 . METHOD_10 ( new TYPE_1 ( this , VAR_3 , <END> VAR_1 ) ) ; } }
<|startcomment|> constructor call new ( a default additional parameter ) <|endcomment|> <START> public TYPE_6 ( String name , Type VAR_2 , List < TYPE_1 > VAR_3 , <END> TYPE_2 VAR_4 , boolean VAR_5 , TYPE_3 location ) { if ( VAR_3 == null ) { VAR_3 = new TYPE_4 < TYPE_1 > ( ) ; } this . type = METHOD_1 ( VAR_3 , VAR_2 ) ; this . name = name ; this . VAR_4 = ( TYPE_5 ) VAR_4 ; this . VAR_3 = VAR_3 ; this . VAR_6 = VAR_5 ; this . location = location ; }
<|startcomment|> add generic parameters acceptors ? ( TYPE_6 < TYPE_4 > ? ) <|endcomment|> <START> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return new TYPE_3 < TYPE_2 , TYPE_4 > ( ) . METHOD_2 ( new TYPE_5 ( client ) ) . METHOD_3 ( new TYPE_6 ( INT_1 , TYPE_10 . VAR_2 ) ) . METHOD_4 ( new TYPE_7 ( new TYPE_8 ( INT_2 ) , new TYPE_9 ( 5 ) ) ) . METHOD_5 ( VAR_3 ) . build ( ) ; }
<|startcomment|> couple question : 1 ) ticket description TAB ESC managed ( ) I : ESC managed ? 2 ) kind interaction specific ot _CODE_ ? other grid editor ? behavior component create a builder / getter else ( some abstract / parent class ) avoid duplicate snippet <|endcomment|> public TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_2 . create ( TYPE_1 . class ) ; VAR_1 . METHOD_2 ( VAR_2 - > { final int VAR_3 = VAR_2 . METHOD_3 ( ) ; <START> if ( VAR_3 == TYPE_4 . VAR_5 ) { <END> METHOD_4 ( ) ; VAR_6 . METHOD_5 ( true ) ; VAR_2 . METHOD_6 ( ) ; } VAR_2 . METHOD_7 ( ) ; } ) ; VAR_1 . METHOD_8 ( TYPE_3 : : METHOD_7 ) ; return VAR_1 ; }
<|startcomment|> METHOD_5 ( ) called designated keyword ? I a other tests <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; METHOD_3 ( VAR_2 , VAR_3 , VAR_1 ) ; if ( METHOD_4 ( ) ) { <START> METHOD_5 ( ) ; <END> } TYPE_2 VAR_4 = METHOD_6 ( ) ; List < TYPE_3 > VAR_5 = VAR_4 . METHOD_7 ( ) ; METHOD_8 ( VAR_5 , STRING_1 ) ; List < TYPE_3 > VAR_6 = VAR_5 . get ( 0 ) . METHOD_9 ( ) ; METHOD_8 ( VAR_6 , VAR_2 + VAR_7 + VAR_8 ) ; }
<|startcomment|> private <|endcomment|> <START> void METHOD_1 ( String name , long offset ) { <END> try { new TYPE_1 ( name , offset ) ; METHOD_2 ( STRING_1 ) ; } catch ( IllegalArgumentException e ) { } }
<|startcomment|> code present _CODE_ <|endcomment|> private void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( this ) ; if ( ! VAR_1 . METHOD_3 ( Constants . VAR_2 , false ) ) { <START> TYPE_3 . METHOD_4 ( this , true ) ; <END> VAR_1 . METHOD_5 ( ) . METHOD_6 ( Constants . VAR_2 , true ) . apply ( ) ; } }
<|startcomment|> raise issues case ( ) cross - procedural analysis assumption a null necessarily raise √† lot _CODE_ <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { TYPE_2 VAR_3 = VAR_4 . METHOD_2 ( ) ; TYPE_3 VAR_5 = VAR_4 . METHOD_3 ( VAR_3 ) ; if ( VAR_5 == null ) { <START> METHOD_4 ( VAR_1 , STRING_1 , VAR_2 ) ; <END> } else if ( VAR_5 . METHOD_5 ( ) ) { METHOD_4 ( VAR_1 , STRING_2 , VAR_2 ) ; } }
<|startcomment|> minor : consider replacing METHOD_2 hamcrest <|endcomment|> private void METHOD_1 ( TYPE_1 result ) { <START> assertThat ( result . VAR_1 ( ) , METHOD_2 ( VAR_2 ) ) ; <END> }
<|startcomment|> call super ( ) ; explicitly <|endcomment|> <START> public TYPE_1 ( ) { <END> }
<|startcomment|> instead copying list requiring a ( potentially ) unsafe cast I more generics _CODE_ <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( this ) <END> . stream ( ) . map ( r - > ( TYPE_1 ) r ) . collect ( Collectors . VAR_2 ( ) ) ; }
<|startcomment|> remove <|endcomment|> private String METHOD_1 ( int VAR_1 ) throws IOException { String VAR_2 = VAR_3 . METHOD_2 ( new TYPE_1 ( STRING_1 , server . VAR_4 ) , VAR_1 , VAR_1 , TYPE_2 . VAR_6 ) ; while ( ! VAR_3 . METHOD_3 ( ) . contains ( VAR_2 ) ) { <START> System . out . println ( STRING_2 ) ; <END> VAR_3 . METHOD_4 ( INT_1 ) ; } return VAR_2 ; }
<|startcomment|> constructor simply call other <|endcomment|> <START> public TYPE_2 ( double VAR_2 , double VAR_3 , <END> TYPE_1 VAR_4 ) { super ( VAR_3 ) ; this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; this . VAR_5 = METHOD_1 ( VAR_2 ) ; this . VAR_6 = METHOD_2 ( METHOD_3 ( ) , VAR_2 , this . VAR_5 ) ; }
<|startcomment|> VAR_3 null <|endcomment|> private final String METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null && VAR_2 . size ( ) > 0 ) { TYPE_2 VAR_3 = VAR_2 . get ( 0 ) ; <START> return VAR_3 . METHOD_1 ( ) ; <END> } return null ; }
<|startcomment|> I switch conditions <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! METHOD_2 ( ) ) { return ; } TYPE_2 method = ( TYPE_2 ) VAR_1 ; <START> if ( ! TYPE_3 . METHOD_3 ( method ) || method . VAR_2 ( ) == null ) { <END> return ; } method . VAR_3 ( new TYPE_4 ( ) ) ; }
<|startcomment|> t set xml <|endcomment|> protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; View . VAR_1 ( METHOD_2 ( ) , R . VAR_2 . VAR_3 , this ) ; VAR_4 = TYPE_1 . METHOD_3 ( this , R . id . VAR_5 ) ; <START> VAR_4 . METHOD_4 ( TYPE_2 . VAR_7 ) ; <END> }
<|startcomment|> static <|endcomment|> <START> private int METHOD_1 ( int VAR_1 , int value ) <END> { return ( VAR_1 < < VAR_2 ) | value ; }
<|startcomment|> METHOD_3 ( ) METHOD_4 ( ) null ? I suggest rewrite condition ! TYPE_3 TYPE_4 equals ( VAR_1 METHOD_3 ( ) METHOD_4 ( ) ) <|endcomment|> public void METHOD_1 ( ANNOTATION_1 final TYPE_1 VAR_1 ) { <START> if ( METHOD_2 ( VAR_1 ) && ! VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) . equals ( TYPE_3 . TYPE_4 ) ) { <END> METHOD_5 ( VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; } }
<|startcomment|> a feature requested current state division type root element discussed add a possibility types restricted context implement selection a standard type <|endcomment|> public String METHOD_1 ( ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { List < TYPE_2 > VAR_2 = METHOD_3 ( ) ; for ( TYPE_2 item : VAR_2 ) { <START> if ( STRING_1 . equals ( item . getValue ( ) ) ) { <END> METHOD_4 ( ( String ) item . getValue ( ) ) ; return VAR_1 ; } } METHOD_4 ( ( String ) VAR_2 . get ( 0 ) . getValue ( ) ) ; } return VAR_1 ; }
<|startcomment|> needed <|endcomment|> <START> public boolean METHOD_1 ( ) { <END> return TYPE_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_2 . VAR_2 ) && METHOD_5 ( ) == null && METHOD_6 ( ) . isPresent ( ) ; }
<|startcomment|> missing exception log rethrow runtime rename exception expand Exception <|endcomment|> public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) ; } <START> catch ( Exception ex ) { <END> } }
<|startcomment|> notif ( VAR_4 containsKey ( VAR_2 ) { } <|endcomment|> private static boolean METHOD_1 ( List < TYPE_1 > VAR_1 , String VAR_2 ) { if ( VAR_1 != null ) for ( TYPE_1 VAR_3 : VAR_1 ) { TYPE_2 < String , String > VAR_4 = VAR_3 . METHOD_2 ( ) ; if ( VAR_4 != null && ! VAR_4 . isEmpty ( ) ) for ( String key : VAR_4 . keySet ( ) ) { if ( key . equals ( VAR_2 ) ) return true ; <START> } <END> } return false ; }
<|startcomment|> assignment - please modify : VAR_1 = VAR_1 <|endcomment|> public void METHOD_1 ( boolean VAR_1 ) { <START> VAR_1 = VAR_1 ; <END> }
<|startcomment|> stupid question : long / Long ? VAR_2 METHOD_2 ( ) returns int Integer ( Map _CODE_ ( ) ) <|endcomment|> public void METHOD_1 ( TYPE_1 o ) { <START> VAR_1 . put ( o , Long . valueOf ( VAR_2 . METHOD_2 ( ) ) ) ; <END> }
<|startcomment|> superfluous casting <|endcomment|> private List < Object [ ] > METHOD_1 ( List < Object [ ] > list , int index ) { for ( Object [ ] item : list ) { <START> item [ index ] = new Long ( ( long ) item [ index ] ) ; <END> } return list ; }
<|startcomment|> new constant object loop pass null construct instance looop <|endcomment|> private void METHOD_1 ( ) throws TYPE_1 { for ( TYPE_2 . Entry < TYPE_3 < ? , ? > > e : VAR_1 ) { TYPE_4 VAR_2 = new TYPE_4 ( e . VAR_3 ( ) , e . VAR_4 ( ) , e . VAR_5 ( ) ) ; if ( TYPE_7 . TYPE_8 . equals ( VAR_2 . getName ( ) ) ) { continue ; } VAR_6 . get ( ) . apply ( VAR_2 , <START> new TYPE_7 . TYPE_9 ( ) ) ; <END> } }
<|startcomment|> I m I fact creating 2 - 3 lists maps everytime called wouldn t a _CODE_ map - - date analyzes register simply return map ( wrapped a Collections _CODE_ ) <|endcomment|> <START> public static Map < String , TYPE_1 > METHOD_1 ( ) { <END> if ( VAR_1 . isEmpty ( ) ) { TYPE_2 VAR_2 = TYPE_2 . getInstance ( ) ; List < TYPE_1 > VAR_3 = VAR_2 . METHOD_1 ( ) ; for ( TYPE_1 VAR_4 : VAR_3 ) { VAR_1 . add ( VAR_4 ) ; } } return METHOD_2 ( ) ; }
<|startcomment|> spaces <|endcomment|> void METHOD_1 ( String name , Object value ) { Class < ? extends TYPE_1 > VAR_1 [ ] = VAR_2 . METHOD_2 ( ) ; <START> if ( VAR_1 != null && VAR_1 . length > 0 ) { <END> for ( final Class < ? extends TYPE_1 > VAR_3 : VAR_1 ) { METHOD_1 ( VAR_3 , name , value ) ; } } }
<|startcomment|> final <|endcomment|> <START> public < TYPE_1 > TYPE_2 < TYPE_3 > METHOD_1 ( Object object , TYPE_4 VAR_1 , TYPE_1 context ) <END> { if ( VAR_2 . isPresent ( ) ) { return VAR_2 . get ( ) . METHOD_1 ( object , VAR_1 , context ) . METHOD_2 ( VAR_3 - > METHOD_3 ( object , VAR_3 . METHOD_4 ( ) , context ) ) ; } else { return METHOD_3 ( object , VAR_1 , context ) ; } }
<|startcomment|> global listener catch METHOD_4 don t need log <|endcomment|> public TYPE_1 METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; METHOD_2 ( VAR_2 ) ; METHOD_3 ( VAR_3 ) ; VAR_4 . METHOD_4 ( ) ; <START> TYPE_2 . log ( STRING_1 , STRING_2 , true ) ; <END> return new TYPE_1 ( VAR_5 ) ; }
<|startcomment|> please revert I s _CODE_ warning java create array generically reflection literally size <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , List < String > VAR_2 ) { Set < TYPE_2 > VAR_3 = VAR_4 . METHOD_2 ( ) ; Set < String > VAR_5 = new HashSet < > ( VAR_3 . size ( ) ) ; for ( TYPE_2 VAR_6 : VAR_3 ) { VAR_5 . add ( VAR_6 . getName ( ) ) ; } <START> VAR_7 . METHOD_3 ( VAR_1 , VAR_5 , VAR_3 . METHOD_4 ( new TYPE_2 [ 0 ] ) ) ; <END> }
<|startcomment|> need public ? package scoped protected work astyanax classes rackspace blueflood io astyanax \ * able call method public <|endcomment|> <START> public static TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> consistency final int <|endcomment|> void METHOD_1 ( final TYPE_1 VAR_1 , final TYPE_1 VAR_2 ) { <START> int VAR_3 = METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> METHOD_2 ( ) . METHOD_4 ( VAR_2 , VAR_3 ) ; }
<|startcomment|> I m fix removing TYPE_1 METHOD_7 invocation a part optimization process needed fix issue exposed _CODE_ mission control application blocks similar applications migrated E4 ( poor GUI rendering performance ) daniel <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 . METHOD_3 ( ) . length > 0 ) { VAR_2 . METHOD_4 ( true ) ; VAR_1 . METHOD_5 ( VAR_2 , SWT . VAR_3 | SWT . VAR_4 ) ; } else { VAR_1 . METHOD_5 ( null ) ; VAR_2 . METHOD_4 ( false ) ; } VAR_2 . METHOD_6 ( ) ; <START> VAR_1 . METHOD_7 ( true , true ) ; <END> }
<|startcomment|> assert context = = null <|endcomment|> TYPE_1 buffer ( ) throws IOException { if ( buf == null ) { buf = TYPE_2 . METHOD_1 ( context . get ( ) ) ; context = null ; <START> } <END> return buf ; }
<|startcomment|> isEmpty method strings Utils good idea <|endcomment|> public String getName ( ) { String name = super . getName ( ) ; <START> if ( name == null || name . isEmpty ( ) ) { <END> return "" ; } else { return name ; } }
<|startcomment|> minor : put _only_ statement expect METHOD_5 <|endcomment|> private void METHOD_1 ( TYPE_1 value , String VAR_1 ) { try { int VAR_2 = TYPE_3 . TYPE_4 . METHOD_2 ( value . VAR_3 ( ) . METHOD_3 ( ) ) ; ByteBuffer VAR_4 = ByteBuffer . VAR_5 ( VAR_2 ) ; VAR_4 . put ( value . VAR_3 ( ) . METHOD_4 ( ) , 0 , VAR_2 ) ; <START> new TYPE_1 ( VAR_1 , VAR_4 , version ) ; <END> METHOD_5 ( STRING_1 + VAR_4 . METHOD_3 ( ) ) ; } catch ( IllegalArgumentException e ) { } }
<|startcomment|> session set null METHOD_1 ( ) <|endcomment|> void METHOD_1 ( ) { if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( ) ; VAR_1 = null ; <START> } <END> }
<|startcomment|> line asnew TYPE_3 ( ) METHOD_2 ( VAR_2 VAR_3 ) METHOD_3 ( type id ( ) ) METHOD_3 ( type id ( ) ) METHOD_4 ( ) ; <|endcomment|> public void METHOD_1 ( final TYPE_1 type ) throws TYPE_2 { <START> final TYPE_3 VAR_1 = new TYPE_3 ( ) ; <END> VAR_1 . METHOD_2 ( VAR_2 . VAR_3 ) ; VAR_1 . METHOD_3 ( type . id ( ) ) ; VAR_1 . METHOD_3 ( type . id ( ) ) ; VAR_1 . METHOD_4 ( ) ; }
<|startcomment|> block needed <|endcomment|> public int METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( 0 ) ; <START> } <END> return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> logger error ( ) <|endcomment|> public void run ( ) { while ( ! VAR_1 ) { synchronized ( this ) { try { if ( VAR_2 ) { METHOD_1 ( VAR_3 , VAR_4 ) ; } METHOD_2 ( VAR_5 ) ; } catch ( Exception e ) { <START> logger . info ( <END> STRING_1 , e ) ; } } } }
<|startcomment|> need force byte order wrapping byte [ ] <|endcomment|> public TYPE_6 ( final TYPE_1 < TYPE_2 > VAR_2 , final int VAR_3 , final TYPE_3 VAR_4 , final int size ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . size = size ; this . VAR_5 = new byte [ size ] ; <START> new TYPE_4 ( VAR_3 , TYPE_5 . METHOD_1 ( VAR_5 , TYPE_7 . VAR_7 ) ) ; <END> }
<|startcomment|> expected 1st affects error messages junit <|endcomment|> public void METHOD_1 ( ) { Set < TYPE_1 < TYPE_2 > > VAR_1 = VAR_2 . METHOD_2 ( new TYPE_2 ( VAR_3 ) ) ; <START> assertEquals ( VAR_1 . isEmpty ( ) , VAR_4 ) ; <END> }
<|startcomment|> good idea ; ) <|endcomment|> public void METHOD_1 ( TYPE_1 < ? > parent , View view , int VAR_1 , long id ) { try { if ( VAR_2 != null ) METHOD_2 ( ) ; } catch ( TYPE_2 e ) { <START> context . VAR_3 ( e . getMessage ( ) ) ; <END> VAR_4 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; return ; } VAR_2 = VAR_5 . METHOD_5 ( VAR_1 ) ; VAR_6 . METHOD_6 ( VAR_2 ) ; METHOD_7 ( ) ; }
<|startcomment|> return false <|endcomment|> public boolean METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 type ) { TYPE_2 . METHOD_2 ( type , STRING_1 , VAR_1 , VAR_2 ) ; VAR_3 . add ( new TYPE_4 . TYPE_5 ( VAR_4 , VAR_1 , VAR_2 , type . toString ( ) ) ) ; <START> return false ; <END> }
<|startcomment|> comparing null enough replace existing VAR_1 a instance case return true short return input changed <|endcomment|> public boolean add ( TYPE_1 VAR_1 ) { <START> return set ( VAR_1 ) != null ; <END> }
<|startcomment|> ditto : sort please <|endcomment|> public String toString ( ) { <START> return TYPE_1 . METHOD_1 ( this ) . add ( STRING_1 , VAR_1 ) <END> . add ( STRING_2 , VAR_2 ) . add ( STRING_3 , VAR_3 ) . add ( STRING_4 , VAR_4 ) . add ( STRING_5 , VAR_5 ) . add ( STRING_6 , VAR_6 ) . add ( STRING_7 , VAR_7 ) . toString ( ) ; }
<|startcomment|> suggestion METHOD_5 ( ( ) - > ! j VAR_3 METHOD_6 ( ) METHOD_7 ( task ) ) ; <|endcomment|> public static final void METHOD_1 ( final TYPE_1 j ) { METHOD_2 ( ) . METHOD_3 ( INT_1 , TimeUnit . VAR_1 ) . METHOD_4 ( 10 , TimeUnit . VAR_2 ) <START> . METHOD_5 ( ( ) - > ! j . VAR_3 . get ( ) . METHOD_6 ( ) . METHOD_7 ( task ) ) ; <END> }
<|startcomment|> method signature doesn t Exception thrown <|endcomment|> private TYPE_1 <START> METHOD_1 ( ) <END> { TYPE_2 VAR_1 = ( TYPE_2 ) METHOD_2 ( ) . METHOD_3 ( TYPE_2 . class ) ; TYPE_3 VAR_2 = VAR_1 . METHOD_4 ( ) ; if ( VAR_2 instanceof TYPE_4 ) { TYPE_4 VAR_3 = ( TYPE_4 ) VAR_2 ; TYPE_3 VAR_4 = VAR_3 . METHOD_5 ( ) ; if ( VAR_4 instanceof TYPE_5 ) { return ( ( TYPE_5 ) VAR_4 ) . METHOD_1 ( ) ; } } throw new TYPE_6 ( STRING_1 ) ; }
<|startcomment|> return <|endcomment|> public boolean equals ( ANNOTATION_1 Object obj ) { <START> if ( ! ( obj instanceof TYPE_1 ) ) { <END> return false ; } return true ; }
<|startcomment|> ! [ MAJOR ] ( ) remove unused VAR_1 local variable [ ! [ rule ] ( ) ] ( ) <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) . METHOD_2 ( ) ; <END> TYPE_1 VAR_2 = new TYPE_1 ( ) . METHOD_3 ( ) ; String VAR_3 = VAR_4 . METHOD_4 ( ) ; Assert . assertEquals ( VAR_3 , STRING_1 ) ; TYPE_1 VAR_5 = new TYPE_1 ( ) . METHOD_5 ( ) ; String VAR_6 = VAR_4 . METHOD_4 ( ) ; TYPE_1 VAR_7 = new TYPE_1 ( ) . METHOD_6 ( ) ; String VAR_8 = VAR_4 . METHOD_4 ( ) ; Assert . VAR_9 ( VAR_6 , VAR_8 ) ; }
<|startcomment|> I deprecate add a new <|endcomment|> <START> String METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 . METHOD_2 ( ) == INT_1 ) { return "" ; } try ( TYPE_2 stream = VAR_1 . METHOD_3 ( ) ) { TYPE_3 VAR_2 = new TYPE_3 ( ) ; return VAR_2 . parse ( stream ) ; } catch ( IOException | TYPE_4 | TYPE_5 e ) { throw new TYPE_6 ( STRING_1 , e ) ; } }
<|startcomment|> package - level protected : suggestion / / visible testingstatic void METHOD_1 ( String action ) { <|endcomment|> <START> public static void METHOD_1 ( String action ) { <END> if ( ! TYPE_1 . stream ( ) . METHOD_2 ( action : : equalsIgnoreCase ) ) { throw new TYPE_2 ( String . format ( STRING_1 + STRING_2 , action , TYPE_1 ) ) ; } }
<|startcomment|> VAR_1 getName ( ) length ( ) invocation redundant <|endcomment|> private String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . getName ( ) . startsWith ( TYPE_2 ) ) { return VAR_2 . getValue ( VAR_3 ) + STRING_1 + <START> VAR_1 . getName ( ) . substring ( TYPE_2 . length ( ) , VAR_1 . getName ( ) . length ( ) ) ; <END> } else { return VAR_1 . getName ( ) ; } }
<|startcomment|> [ _CODE_ ( long id ) ] ( ) üíØ <|endcomment|> private Long METHOD_1 ( ) { <START> while ( VAR_1 . METHOD_2 ( VAR_2 ) != null ) { <END> VAR_2 ++ ; } return VAR_2 ; }
<|startcomment|> move _CODE_ ( ) VAR_1 a local variable <|endcomment|> public void METHOD_1 ( ) throws InterruptedException { <START> TYPE_1 . METHOD_2 ( VAR_1 != null ) ; <END> VAR_2 . METHOD_3 ( VAR_3 . METHOD_4 ( METHOD_5 ( VAR_4 . METHOD_6 ( ) ) ) ) ; VAR_2 . METHOD_7 ( ) ; VAR_3 . METHOD_8 ( VAR_5 ) ; VAR_2 . VAR_6 . METHOD_9 ( 1 ) ; VAR_3 . METHOD_10 ( VAR_5 ) ; VAR_2 . VAR_6 . METHOD_11 ( 1 ) ; }
<|startcomment|> beware invoking [ METHOD_3 ( TYPE_1 METHOD_4 ( ) ) ] ( ) invoking [ METHOD_3 ( ) ] ( ) <|endcomment|> public String METHOD_1 ( ) { <START> return METHOD_2 ( ) . getName ( ) . METHOD_3 ( TYPE_1 . METHOD_4 ( ) ) <END> + ( VAR_1 instanceof TYPE_2 ? ( STRING_1 + ( ( TYPE_2 ) VAR_1 ) . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) + STRING_2 ) : "" ) ; }
<|startcomment|> other method need public ? protected suffice <|endcomment|> <START> public boolean METHOD_1 ( ) { <END> TYPE_1 target = server . VAR_1 ( ) . get ( 0 ) . METHOD_2 ( ) ; TYPE_2 event = TYPE_3 . METHOD_3 ( new TYPE_2 ( this , location . VAR_2 ( ) , target , null ) ) ; if ( event . VAR_3 ( ) ) { return false ; } target = event . VAR_4 ( ) ; METHOD_4 ( target ) ; return true ; }
<|startcomment|> please variable initialized empty array avoid a null check done <|endcomment|> public String [ ] METHOD_1 ( ) { <START> String [ ] result = null ; <END> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( METHOD_3 ( ) , TYPE_2 . class ) ; if ( VAR_1 != null ) { result = ( ( TYPE_3 ) VAR_1 ) . METHOD_1 ( ) ; } return result ; }
<|startcomment|> some protected items package private <|endcomment|> <START> protected TYPE_3 ( TYPE_1 VAR_2 , int VAR_3 , long length , <END> long VAR_4 , long VAR_5 ) throws IOException { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_6 = VAR_2 . METHOD_1 ( ) / VAR_3 ; this . length = length ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; try ( TYPE_2 VAR_7 = VAR_2 . METHOD_2 ( 0 , VAR_8 ) ) { METHOD_3 ( VAR_7 , length ) ; } if ( VAR_4 != 0 ) { METHOD_4 ( VAR_4 ) ; } }
<|startcomment|> don t precompute VAR_3 METHOD_5 unnecessary code harder follow <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 page , TYPE_3 VAR_3 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . VAR_4 = METHOD_1 ( page , STRING_2 ) . METHOD_2 ( ) ; this . VAR_3 = METHOD_1 ( VAR_3 , STRING_3 ) ; this . VAR_5 = VAR_3 . METHOD_3 ( ) ; if ( VAR_3 . METHOD_4 ( ) ) { this . VAR_6 = VAR_3 . METHOD_5 ( ) ; } else { this . VAR_6 = null ; <START> } <END> }
<|startcomment|> ternary behave stated 1 annotation <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) throw new IllegalArgumentException ( STRING_1 ) ; else if ( VAR_1 . METHOD_2 ( ) == null ) throw new IllegalArgumentException ( STRING_2 ) ; <START> return VAR_1 . METHOD_3 ( ) ? this . VAR_2 . METHOD_1 ( ) + STRING_3 <END> + VAR_1 . METHOD_2 ( ) : null ; }
<|startcomment|> change variable VAR_4 _CODE_ <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , boolean VAR_2 , TYPE_3 VAR_3 ) { <START> TYPE_1 VAR_4 = null ; <END> if ( ! VAR_2 && VAR_1 . METHOD_2 ( ) ) { TYPE_1 VAR_5 = VAR_1 . METHOD_3 ( ) ; if ( VAR_5 != null ) { for ( TYPE_1 VAR_6 : VAR_3 . METHOD_4 ( ) ) { if ( VAR_5 . equals ( VAR_6 ) ) { VAR_4 = VAR_6 ; break ; } } } } return VAR_4 ; }
<|startcomment|> parent METHOD_1 throw a TYPE_3 parameter invalid method longer throws TYPE_2 <|endcomment|> public void METHOD_1 ( int VAR_1 ) throws TYPE_1 , <START> TYPE_2 , <END> TYPE_3 { METHOD_2 ( ) ; super . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> please java conventions - param <|endcomment|> private List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > <START> TYPE_2 = <END> new ArrayList < > ( ) ; TYPE_3 VAR_1 = VAR_2 ; VAR_1 . METHOD_2 ( ) . addAll ( VAR_3 ) ; TYPE_2 . add ( VAR_2 ) ; TYPE_2 . add ( VAR_4 ) ; TYPE_2 . add ( VAR_5 ) ; TYPE_2 . add ( VAR_6 ) ; return TYPE_2 ; }
<|startcomment|> enabling indexing VAR_1 = = false ? auto - enabling happen VAR_1 = = true <|endcomment|> public TYPE_1 METHOD_1 ( boolean VAR_1 ) { <START> METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( VAR_3 ) . set ( VAR_1 ) ; return this ; }
<|startcomment|> dao return empty list populated null <|endcomment|> private boolean METHOD_1 ( String VAR_1 , Guid VAR_2 ) { return <START> TYPE_1 . METHOD_2 ( VAR_3 . METHOD_3 ( VAR_2 , <END> TYPE_2 . VAR_5 , VAR_1 ) ) ; }
<|startcomment|> static <|endcomment|> <START> private void METHOD_1 ( TYPE_1 stream ) { <END> if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { Logger . e ( TAG , STRING_1 , "" , TYPE_2 . VAR_2 , e ) ; } } }
<|startcomment|> simplify string construction : _CODE_ VAR_3 = System getProperty ( VAR_4 STRING_4 + VAR_7 ) ; String VAR_5 = System getProperty ( VAR_6 STRING_4 + VAR_8 ) ; <|endcomment|> public static String METHOD_1 ( ) { String VAR_1 = System . getProperty ( VAR_2 ) ; String VAR_3 = System . getProperty ( VAR_4 ) ; <START> String VAR_5 = System . getProperty ( VAR_6 ) ; <END> return STRING_1 + VAR_2 + STRING_2 + VAR_1 + STRING_3 + VAR_4 + STRING_2 + ( VAR_3 == null ? STRING_4 + VAR_7 : VAR_3 ) + STRING_3 + VAR_6 + STRING_2 + ( VAR_5 == null ? STRING_4 + VAR_8 : VAR_5 ) + STRING_5 ; }
<|startcomment|> I recommend returning a boolean true a successful update false - op case <|endcomment|> <START> public void METHOD_1 ( final ANNOTATION_1 TYPE_1 node ) throws IOException { <END> if ( node == VAR_1 . get ( node . VAR_2 ( ) ) ) { TYPE_2 . METHOD_2 ( new TYPE_3 ( ) { @Override public void run ( ) { VAR_3 . METHOD_3 ( ) ; } } ) ; METHOD_4 ( node ) ; } }
<|startcomment|> rest class expects VAR_2 nonnull I recommend initialize VAR_2 empty mutable list setter <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 != null ) { <END> METHOD_2 ( ) ; VAR_1 . METHOD_3 ( STRING_1 , VAR_2 ) ; } }
<|startcomment|> necessary <|endcomment|> public TYPE_2 ( String name , double VAR_2 ) { <START> super ( ) ; <END> this . name = name ; this . VAR_2 = VAR_2 ; this . position = new ArrayList < TYPE_1 > ( ) ; this . VAR_3 = new ArrayList < TYPE_1 > ( ) ; }
<|startcomment|> task <|endcomment|> <START> private TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_2 VAR_1 ) { <END> String VAR_2 = VAR_1 . METHOD_2 ( ) ; String VAR_3 = STRING_1 ; TYPE_3 VAR_4 = TYPE_4 . METHOD_3 ( ) . METHOD_4 ( VAR_3 ) ; String VAR_5 = VAR_4 . METHOD_5 ( VAR_3 ) ; String VAR_6 = VAR_4 . METHOD_6 ( VAR_3 ) ; TYPE_2 VAR_7 = VAR_8 . METHOD_7 ( VAR_6 , VAR_5 ) ; if ( VAR_7 == null ) { return Collections . VAR_9 ( ) ; } return TYPE_5 . of ( VAR_7 ) ; }
<|startcomment|> override <|endcomment|> <START> protected void METHOD_1 ( StringBuilder builder ) <END> { builder . append ( this . value ) ; }
<|startcomment|> public static boolean METHOD_1 ( final TYPE_1 url ) <|endcomment|> <START> public static boolean METHOD_1 ( TYPE_1 url ) { <END> return TYPE_2 . equals ( url . VAR_1 ( ) ) || TYPE_3 . equals ( url . VAR_2 ( Constants . VAR_3 , Constants . VAR_4 ) ) ; }
<|startcomment|> I delete synchronized block values modified reading state 2 s move prior accesses values synchronized blocks currently a test <|endcomment|> void METHOD_1 ( ) { int [ ] VAR_1 ; synchronized ( VAR_2 ) { VAR_1 = values ; state = 1 ; } int s ; do { synchronized ( VAR_2 ) { s = state ; } } while ( s != 2 ) ; int [ ] VAR_3 ; <START> synchronized ( VAR_2 ) { <END> VAR_3 = values ; } int VAR_4 = VAR_1 [ 0 ] ; int VAR_5 = VAR_3 [ 0 ] ; System . out . println ( STRING_1 + VAR_4 + STRING_2 + VAR_5 ) ; }
<|startcomment|> isn t easier VAR_1 a field test ? _CODE_ created settings ? field instead local variable simplify test methods <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> TYPE_1 VAR_1 = new TYPE_2 ( ) . build ( ) ; <END> String VAR_2 = STRING_1 ; String VAR_3 = ( String ) METHOD_2 ( VAR_1 , VAR_2 ) ; assertNotNull ( VAR_3 ) ; assertEquals ( VAR_2 , VAR_3 ) ; }
<|startcomment|> please add braces else block <|endcomment|> public boolean equals ( final Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } final TYPE_1 VAR_1 = ( TYPE_1 ) obj ; if ( name == null ) { return VAR_1 . name == null ; <START> } else return name . equals ( VAR_1 . name ) ; <END> }
<|startcomment|> need wrap a new ArrayList ? wasteful <|endcomment|> public TYPE_1 ( List < ByteBuffer > VAR_2 ) { if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> VAR_3 = new ArrayList < > ( VAR_2 ) ; <END> size = METHOD_1 ( VAR_2 ) ; }
<|startcomment|> I don t s necessary log message host other unmet conditions don t log necessary VDS ID helpful ( assuming VM ID printed elsewehere ) <|endcomment|> boolean METHOD_1 ( final List < TYPE_1 > VAR_1 , final List < TYPE_2 > VAR_2 ) { for ( final TYPE_1 VAR_3 : VAR_1 ) { boolean VAR_4 = false ; for ( final TYPE_2 VAR_5 : VAR_2 ) { if ( StringUtils . equals ( VAR_3 . METHOD_2 ( ) , VAR_5 . METHOD_2 ( ) ) ) { VAR_4 = true ; break ; } } if ( ! VAR_4 ) { <START> log . debug ( STRING_1 ) ; <END> return false ; } } return true ; }
<|startcomment|> catch exceptions test code want declare method throws Exception <|endcomment|> public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( ) . call ( ) ; METHOD_3 ( STRING_1 , VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) + STRING_2 ) ; VAR_1 . METHOD_6 ( ) . call ( ) ; VAR_1 . METHOD_7 ( ) . call ( ) ; METHOD_3 ( STRING_1 , VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) + STRING_2 ) ; <START> } catch ( Exception e ) { <END> e . VAR_2 ( ) ; } }
<|startcomment|> include information e exception message <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) throws TYPE_2 { if ( VAR_1 . METHOD_2 ( ) ) { throw new TYPE_2 ( TYPE_5 . TYPE_6 . getMessage ( ) ) ; } try { return VAR_2 . get ( VAR_3 ) ; } catch ( TYPE_4 e ) { <START> throw new TYPE_2 ( STRING_1 ) ; <END> } }
<|startcomment|> rollback done test case ( i e notation notataion ) I preserve current behavior od METHOD_1 ( ) I suggest creating a new _CODE_ ( ) method performing METHOD_3 <|endcomment|> public static void METHOD_1 ( ) throws Exception { if ( VAR_1 != null ) { TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null ) { <START> VAR_2 . METHOD_3 ( ) ; <END> } } }
<|startcomment|> equality check ? done equals <|endcomment|> public void METHOD_1 ( final String VAR_1 , final String value ) { VAR_2 . METHOD_2 ( VAR_1 , ( key , values ) - > { values . forEach ( i - > { <START> if ( ( i . getValue ( ) . equals ( value ) || i . getValue ( ) == value ) && i . VAR_3 ( ) == false ) { <END> i . VAR_4 ( true ) ; } } ) ; return values ; } ) ; }
<|startcomment|> needed <|endcomment|> public TYPE_2 ( Guid VAR_2 , TYPE_1 VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; }
<|startcomment|> I don t need check METHOD_3 result VAR_4 exceeded <|endcomment|> private void METHOD_1 ( TYPE_1 key , TYPE_2 value ) { TYPE_1 [ ] VAR_1 = this . VAR_1 ; TYPE_2 [ ] VAR_2 = this . VAR_2 ; for ( int i = METHOD_2 ( key ) ; ; i = ( i + 1 ) & VAR_3 ) { if ( VAR_1 [ i ] == null ) { VAR_1 [ i ] = key ; VAR_2 [ i ] = value ; break ; } } <START> if ( ++ size >= VAR_4 ) { <END> METHOD_3 ( VAR_1 . length < < 1 ) ; } }
<|startcomment|> isn t VAR_3 I ve overloaded variable meanings need : * _CODE_ * _CODE_ * _CODE_ * _CODE_ 3 true _CODE_ _CODE_ ( ) true true _CODE_ _CODE_ ( ) true want VAR_2 <|endcomment|> protected void METHOD_1 ( ) { METHOD_2 ( false ) ; super . METHOD_1 ( ) ; TYPE_4 . TYPE_5 . METHOD_3 ( VAR_1 , new TYPE_2 < TYPE_3 > ( ) { public void METHOD_4 ( final TYPE_3 result ) { METHOD_2 ( true ) ; METHOD_5 ( result ) ; <START> VAR_2 . METHOD_6 ( result . VAR_3 ) ; <END> VAR_4 . METHOD_6 ( result . VAR_3 ) ; } } ) ; }
<|startcomment|> TYPE_1 valueOf <|endcomment|> public static TYPE_1 METHOD_1 ( String name ) { try { <START> return TYPE_2 . valueOf ( TYPE_1 . class , name ) ; <END> } catch ( Exception ex ) { TYPE_3 . METHOD_2 ( STRING_1 + name , true , ex ) ; } return null ; }
<|startcomment|> minor : a shortcut METHOD_2 ( ) method deserialization class _CODE_ consistent places <|endcomment|> public Set < TYPE_1 > keySet ( TYPE_2 VAR_1 ) { METHOD_1 ( VAR_1 , STRING_1 ) ; Set < TYPE_1 > VAR_2 = new HashSet < TYPE_1 > ( ) ; Set < TYPE_3 > query = VAR_3 . query ( VAR_1 ) ; if ( query != null ) { for ( TYPE_3 entry : query ) { <START> TYPE_1 key = ( TYPE_1 ) VAR_4 . METHOD_2 ( entry . VAR_5 ( ) ) ; <END> VAR_2 . add ( key ) ; } } else { METHOD_3 ( VAR_1 , VAR_2 ) ; } return VAR_2 ; }
<|startcomment|> a tiny miss a whitespace - > <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( new HashSet < > ( ) ) ; <START> TYPE_2 . METHOD_3 ( TYPE_3 . class , ( ) - > TYPE_4 . METHOD_4 ( VAR_1 , TYPE_1 . class . METHOD_5 ( STRING_1 ) ) ) ; <END> }
<|startcomment|> declared _CODE_ <|endcomment|> protected void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( binder ( ) , TYPE_2 . class ) ; <END> METHOD_3 ( new TYPE_3 ( ) { @Override protected void METHOD_1 ( ) { factory ( TYPE_9 . TYPE_10 . class ) ; } } ) ; bind ( TYPE_5 . class ) ; bind ( TYPE_6 . class ) . to ( TYPE_5 . class ) ; bind ( TYPE_7 . class ) . to ( TYPE_8 . class ) ; listener ( ) . to ( TYPE_8 . class ) ; }
<|startcomment|> doesn t : building VAR_1 VAR_2 need check VAR_2 disabled I ? ( VAR_2 ! = null && ! VAR_2 METHOD_2 ( ) ) { ( VAR_1 ! = null && ! VAR_1 METHOD_2 ( ) ) { VAR_1 dispose ( ) ; } VAR_1 = new TYPE_1 ( VAR_2 METHOD_3 ( ) VAR_2 SWT VAR_3 ) ; } <|endcomment|> private void METHOD_1 ( ) { <START> if ( this . VAR_1 != null && ! this . VAR_1 . METHOD_2 ( ) ) <END> VAR_1 = new TYPE_1 ( this . VAR_2 . METHOD_3 ( ) , this . VAR_2 , SWT . VAR_3 ) ; }
<|startcomment|> VAR_1 clear ( ) <|endcomment|> public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_1 . data . clear ( ) ; <END> VAR_2 . METHOD_2 ( VAR_1 ) ; }
<|startcomment|> builder concatenate 3 strings loops I guess unnecessary <|endcomment|> private String METHOD_1 ( TYPE_1 row ) { <START> StringBuilder builder = new StringBuilder ( ) ; <END> builder . append ( row . VAR_1 ( ) ) . append ( STRING_1 ) . append ( row . getMessage ( ) ) ; return builder . toString ( ) ; }
<|startcomment|> a tombstone longer hierarchy ( result removing proxy ) method return a null throw exception <|endcomment|> <START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( this ) ; }
<|startcomment|> braces more occurrences file <|endcomment|> private void METHOD_1 ( ) { String VAR_1 = VAR_2 . get ( VAR_3 ) ; <START> if ( VAR_1 != null ) { <END> VAR_4 . setText ( VAR_1 ) ; } }
<|startcomment|> needed <|endcomment|> public String toString ( ) { return METHOD_1 ( this ) . METHOD_2 ( ) <START> . add ( STRING_1 , this . VAR_1 ) <END> . add ( STRING_2 , filter . VAR_2 ( null ) ) . toString ( ) ; }
<|startcomment|> more appropriately logger warn <|endcomment|> private void METHOD_1 ( TYPE_1 < String , ? > config ) { TYPE_2 < String > VAR_1 = config . VAR_1 ( ) ; while ( VAR_1 . METHOD_2 ( ) ) { String key = VAR_1 . METHOD_3 ( ) ; if ( STRING_1 . equals ( key ) ) { continue ; } TYPE_3 matcher = TYPE_4 . matcher ( key ) ; if ( ! matcher . VAR_2 ( ) ) { logger . error ( STRING_2 + key <START> + STRING_3 ) ; <END> continue ; } } }
<|startcomment|> _CODE_ ( other plan printer ) expect expression METHOD_2 s fix tests failing <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_1 context ) { <START> String VAR_1 = METHOD_2 ( node . VAR_2 ( ) ) ? node . VAR_2 ( ) . toString ( ) : VAR_3 . METHOD_3 ( node . VAR_2 ( ) ) ; <END> METHOD_4 ( node , STRING_1 , VAR_1 , TYPE_3 . get ( TYPE_4 . VAR_5 ) ) ; return node . VAR_6 ( ) . METHOD_5 ( this , context ) ; }
<|startcomment|> move line logging error case error logged <|endcomment|> public void run ( ) { METHOD_1 ( ) ; VAR_1 = true ; for ( TYPE_1 VAR_2 : TYPE_1 . values ( ) ) { METHOD_2 ( VAR_2 ) ; } try { METHOD_3 ( VAR_3 ) ; } catch ( InterruptedException e ) { <START> Thread . VAR_4 ( ) . METHOD_4 ( ) ; <END> logger . error ( STRING_1 + e . getMessage ( ) ) ; } VAR_5 = TYPE_1 . NONE ; VAR_1 = false ; VAR_6 . METHOD_5 ( VAR_7 ) ; }
<|startcomment|> return METHOD_2 ( ) ! = null && ( STRING_1 equals ( METHOD_2 ( ) ) || STRING_2 ( METHOD_2 ( ) ) ) ; <|endcomment|> public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) != null && ( STRING_1 . equals ( METHOD_2 ( ) ) || STRING_2 . equals ( METHOD_2 ( ) ) || STRING_3 . equals ( METHOD_2 ( ) ) ) ; <END> }
<|startcomment|> redundant <|endcomment|> TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , long VAR_3 , TYPE_4 VAR_4 , TYPE_5 VAR_5 , int VAR_6 , Optional < TYPE_5 > VAR_7 , boolean VAR_8 , Map < String , Type > VAR_9 ) { if ( VAR_8 ) { return new TYPE_6 ( VAR_5 , VAR_6 , VAR_7 , VAR_10 , VAR_3 , VAR_4 , this , VAR_1 , VAR_2 ) ; } <START> else { <END> return new TYPE_7 ( VAR_5 , VAR_9 , VAR_10 , VAR_3 , VAR_4 , VAR_11 , this , VAR_2 , VAR_12 , VAR_13 , VAR_14 ) ; } }
<|startcomment|> TEXT datatype more <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( STRING_1 ) ; METHOD_3 ( VAR_1 , VAR_2 ) . METHOD_2 ( STRING_2 ) ; METHOD_3 ( VAR_3 , VAR_4 , VAR_5 ) . METHOD_4 ( false ) . METHOD_5 ( true ) . METHOD_2 ( STRING_3 ) ; <START> METHOD_3 ( VAR_6 , VAR_5 ) . METHOD_2 ( STRING_4 ) . METHOD_6 ( VAR_7 ) ; <END> }
<|startcomment|> space IOException { <|endcomment|> <START> @Override public Long call ( ) throws IOException { <END> String VAR_1 = Thread . VAR_2 ( ) . getName ( ) ; Thread . VAR_2 ( ) . METHOD_1 ( VAR_1 + STRING_1 + this . parent . VAR_3 . toString ( ) ) ; this . parent . VAR_4 ( VAR_5 ) ; Thread . VAR_2 ( ) . METHOD_1 ( VAR_1 ) ; return VAR_5 ; }
<|startcomment|> additional list creation ( new ArrayList < > ( ) ) provide benefits compared ? javathis VAR_2 = asList ( VAR_2 ) ; <|endcomment|> public TYPE_2 ( TYPE_1 ... VAR_2 ) { <START> this . VAR_2 = new ArrayList < > ( asList ( VAR_2 ) ) ; <END> }
<|startcomment|> nitpick : instead application <|endcomment|> @Override public void METHOD_1 ( int VAR_1 , ANNOTATION_1 String [ ] VAR_2 , ANNOTATION_1 int [ ] VAR_3 ) { if ( VAR_1 == VAR_4 ) { if ( VAR_3 . length > 0 && VAR_3 [ 0 ] == TYPE_2 . VAR_6 ) { METHOD_2 ( ) ; } else { <START> TYPE_1 . METHOD_3 ( METHOD_4 ( ) , STRING_1 , <END> TYPE_1 . VAR_7 ) . METHOD_5 ( ) ; METHOD_6 ( ) ; } } else { super . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; } }
<|startcomment|> I missing simplybuffer append ( STRING_1 ) ; METHOD_2 ( buffer VAR_1 ) ; buffer append ( STRING_2 ) ; METHOD_2 ( buffer VAR_2 ) ; buffer append ( STRING_3 ) ; <|endcomment|> private static void METHOD_1 ( StringBuilder buffer , TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { StringBuilder VAR_3 = new StringBuilder ( ) ; METHOD_2 ( VAR_3 , VAR_1 ) ; StringBuilder VAR_4 = new StringBuilder ( ) ; METHOD_2 ( VAR_4 , VAR_2 ) ; <START> buffer . append ( STRING_1 + VAR_3 . toString ( ) + STRING_2 + VAR_4 . toString ( ) + STRING_3 ) ; <END> }
<|startcomment|> synchronized access _CODE_ instance cool transaction performance impact want initialize invoking full resource <|endcomment|> <START> public static synchronized TYPE_1 instance ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_2 ( ) ; } return VAR_1 ; }
<|startcomment|> simplify reordering states <|endcomment|> public int METHOD_1 ( ) { int state = VAR_1 . METHOD_2 ( ) ; if ( METHOD_3 ( ) ) state = INT_1 ; if ( METHOD_4 ( ) ) { if ( METHOD_3 ( ) ) state += 1 ; else state += INT_2 ; <START> } <END> return state ; }
<|startcomment|> den cast auf ( TYPE_1 ) ist hier √ºberfl√ºssig <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( VAR_1 - > { <START> TYPE_1 VAR_2 = ( TYPE_1 ) VAR_1 . METHOD_3 ( 1 ) ; <END> VAR_2 . METHOD_4 ( STRING_1 , STRING_2 ) ; return null ; } ) . when ( VAR_3 ) . METHOD_5 ( METHOD_6 ( ) , METHOD_6 ( ) ) ; METHOD_7 ( METHOD_8 ( STRING_3 ) ) . METHOD_9 ( view ( ) . name ( STRING_4 ) ) ; }
<|startcomment|> I part PR changed new StringBuilder ( TYPE_1 METHOD_2 ( ) ) avoid useless append ( StringBuilder ( ) constructor create StringBuilder capacity 16 immediately expand append ) <|endcomment|> private String METHOD_1 ( final TYPE_1 TYPE_1 ) { final StringBuilder sb = new StringBuilder ( ) <START> . append ( TYPE_1 . METHOD_2 ( ) ) <END> . append ( TYPE_1 . METHOD_3 ( ) ? STRING_1 : STRING_2 ) ; return sb . toString ( ) ; }
<|startcomment|> logger instead sysout logging <|endcomment|> public void METHOD_1 ( ) { TYPE_1 table = new TYPE_1 ( ) ; for ( int i = 0 ; i < table . VAR_1 ( ) ; i ++ ) { <START> System . out . println ( STRING_1 + i + STRING_2 + table . VAR_2 ( i ) . METHOD_2 ( 1 ) ) ; <END> } }
<|startcomment|> revert TYPE_2 X instead TYPE_1 TYPE_2 X <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( TYPE_1 . TYPE_2 . VAR_3 , TYPE_1 . TYPE_2 . VAR_4 , true ) ; METHOD_2 ( TYPE_1 . TYPE_2 . VAR_4 , TYPE_1 . TYPE_2 . VAR_3 , true ) ; METHOD_2 ( TYPE_1 . TYPE_2 . VAR_3 , TYPE_1 . TYPE_2 . VAR_3 , true ) ; <START> METHOD_2 ( TYPE_1 . TYPE_2 . VAR_4 , TYPE_1 . TYPE_2 . VAR_4 , false ) ; <END> }
<|startcomment|> cast busimpl needed METHOD_1 _CODE_ interface <|endcomment|> private String METHOD_1 ( ) { <START> return ( ( TYPE_1 ) VAR_1 ) . METHOD_1 ( ) ; <END> }
<|startcomment|> TYPE_3 exception <|endcomment|> private void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) ) ; if ( VAR_1 . METHOD_3 ( ) ) { try { VAR_1 . METHOD_4 ( ) ; VAR_1 . METHOD_5 ( ) ; } catch ( TYPE_2 e ) { throw new TYPE_3 ( TYPE_4 . TYPE_6 , STRING_1 ) ; <START> } catch ( TYPE_3 e ) { <END> throw new TYPE_3 ( TYPE_4 . TYPE_5 , STRING_2 ) ; } } else { throw new TYPE_3 ( TYPE_4 . TYPE_6 , STRING_1 ) ; } }
<|startcomment|> I forgot change - return METHOD_1 ( VAR_1 METHOD_3 ( ) ) ; <|endcomment|> <START> public static Response METHOD_1 ( TYPE_1 VAR_1 ) { return METHOD_2 ( VAR_1 , METHOD_3 ( ) ) ; } <END>
<|startcomment|> need static <|endcomment|> <START> private static Optional < TYPE_1 > METHOD_1 ( Optional < TYPE_1 > VAR_1 , Optional < TYPE_1 > VAR_2 ) { <END> if ( ! VAR_1 . isPresent ( ) ) { return VAR_2 ; } return VAR_1 ; }
<|startcomment|> a constant a magic string <|endcomment|> public TYPE_1 ( String VAR_2 , String host ) { this . VAR_2 = VAR_2 ; this . host = host ; this . VAR_3 = 0 ; <START> this . VAR_4 = STRING_1 ; <END> }
<|startcomment|> change order save a temp variable s <|endcomment|> private void METHOD_1 ( TYPE_1 c , int VAR_1 ) { VAR_2 = null ; for ( ; ; ) { METHOD_2 ( c , VAR_1 ) ; TYPE_2 s = VAR_2 ; if ( s != null ) { <START> VAR_2 = s . VAR_3 ; c = s . c ; VAR_1 = s . VAR_1 ; <END> continue ; } break ; } }
<|startcomment|> VAR_1 METHOD_2 ( String valueOf ( i ) ) ; <|endcomment|> private TYPE_1 [ ] METHOD_1 ( TYPE_2 VAR_1 , int n ) { TYPE_1 [ ] VAR_2 = new TYPE_1 [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { VAR_2 [ i ] = VAR_1 . METHOD_2 ( i ) ; <START> VAR_1 . METHOD_2 ( "" + String . valueOf ( i ) ) ; <END> } return VAR_2 ; }
<|startcomment|> create a new instance time cache instance a member variable <|endcomment|> public TYPE_1 get ( ) { <START> return VAR_1 . getInstance ( METHOD_1 ( ) ) ; <END> }
<|startcomment|> ( VAR_1 ! = null && METHOD_4 ( ) ! = null ) { } <|endcomment|> protected void METHOD_1 ( TYPE_1 path , TYPE_2 VAR_1 ) { if ( METHOD_2 ( ) . METHOD_3 ( ) ) { return ; } if ( VAR_1 != null ) { <START> if ( METHOD_4 ( ) != null ) { <END> final TYPE_3 VAR_2 = METHOD_5 ( path ) ; TYPE_4 t = new TYPE_4 ( ) { @Override public void run ( ) { METHOD_4 ( ) . METHOD_6 ( ) . METHOD_7 ( VAR_2 ) ; } } ; METHOD_8 ( ) . METHOD_9 ( t , 0 ) ; } } }
<|startcomment|> I don t called patch a reason public <|endcomment|> <START> public void METHOD_1 ( float VAR_1 , float VAR_2 ) { <END> METHOD_2 ( VAR_1 , VAR_2 ) ; this . VAR_3 = VAR_1 ; this . VAR_2 = VAR_2 ; }
<|startcomment|> needed unboxing <|endcomment|> public static void METHOD_1 ( Object source , ANNOTATION_1 Object target ) { Integer VAR_1 = TYPE_1 . get ( ) ; METHOD_2 ( VAR_1 , STRING_1 , source , target ) ; if ( VAR_1 == null ) { TYPE_1 . set ( 1 ) ; TYPE_2 . set ( new TYPE_3 < Object , Object > ( ) ) ; } else { <START> TYPE_1 . set ( VAR_1 . METHOD_3 ( ) + 1 ) ; <END> } TYPE_2 . get ( ) . put ( source , target ) ; }
<|startcomment|> remove throws TYPE_2 <|endcomment|> <START> public List < TYPE_1 > METHOD_1 ( ) throws TYPE_2 { <END> return this . VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; }
<|startcomment|> change <|endcomment|> protected void METHOD_1 ( ) { if ( VAR_1 != null ) { try { <START> VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> METHOD_4 ( ) ; } finally { VAR_1 . METHOD_2 ( ) . METHOD_5 ( ) ; } } else { METHOD_4 ( ) ; } }
<|startcomment|> list#of _CODE_ <|endcomment|> public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = METHOD_2 ( STRING_1 , VAR_2 ) ; TYPE_2 VAR_3 = METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; <START> List < TYPE_3 > params = Arrays . asList ( <END> factory ( STRING_2 , TYPE_5 , STRING_3 ) ) ; VAR_3 . METHOD_5 ( VAR_5 , params , true ) ; TYPE_4 result = VAR_3 . METHOD_6 ( VAR_5 ) ; assertNotNull ( result ) ; assertEquals ( STRING_4 , result . getString ( ) ) ; }
<|startcomment|> work / read TYPE_1 default values return early instead creating new objects rest code work properly <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; <START> TYPE_2 VAR_3 = TYPE_3 . METHOD_2 ( VAR_1 , STRING_1 , ( ) - > new TYPE_2 ( ) ) ; <END> METHOD_3 ( VAR_2 , VAR_3 ) ; METHOD_4 ( VAR_2 , VAR_1 ) ; VAR_2 . METHOD_5 ( TYPE_4 . METHOD_6 ( TYPE_3 . METHOD_7 ( VAR_3 , STRING_2 ) , 0 ) ) ; return VAR_2 ; }
<|startcomment|> methods class synchronized change good <|endcomment|> public static void METHOD_1 ( TYPE_1 conf ) { if ( ! VAR_1 ) { TYPE_2 . conf = conf ; TYPE_2 . VAR_1 = true ; <START> } <END> }
<|startcomment|> return false else case <|endcomment|> private void METHOD_1 ( long VAR_1 ) { if ( METHOD_2 ( ) > VAR_1 ) { try { METHOD_3 ( VAR_1 ) ; <START> if ( METHOD_2 ( ) == VAR_1 ) { <END> return ; } } catch ( TYPE_1 VAR_2 ) { log . warn ( STRING_1 , this , VAR_1 , VAR_2 ) ; METHOD_4 ( ) ; } } }
<|startcomment|> I new TYPE_3 < > ( options ) work <|endcomment|> public void METHOD_1 ( TYPE_1 options ) { TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; TYPE_2 . METHOD_2 ( VAR_2 , STRING_2 ) ; <START> VAR_3 = new TYPE_3 < TYPE_4 , TYPE_5 > ( options ) ; <END> }
<|startcomment|> disposed <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 parent ) throws TYPE_3 { final TYPE_1 VAR_1 = super . METHOD_1 ( parent ) ; <START> final TYPE_4 VAR_2 = new TYPE_4 ( new TYPE_5 [ ] { <END> new TYPE_6 ( ) , new TYPE_4 ( TYPE_4 . TYPE_8 . TYPE_9 . VAR_5 ) } ) ; VAR_6 = new TYPE_7 ( VAR_2 ) ; return VAR_1 ; }
<|startcomment|> else redundant <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { logger . trace ( STRING_1 , VAR_1 . toString ( ) ) ; if ( VAR_1 . METHOD_2 ( ) ) { return METHOD_1 ( VAR_1 . METHOD_3 ( ) ) ; <START> } else { <END> return METHOD_1 ( VAR_1 . METHOD_4 ( ) ) ; } }
<|startcomment|> call <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> VAR_2 . forEach ( ( key , VAR_3 ) - > { <END> if ( VAR_3 == null ) { System . VAR_4 ( key ) ; } else { System . VAR_5 ( key , VAR_3 ) ; } } ) ; VAR_2 . clear ( ) ; }
<|startcomment|> lines definitions necessary ? isn t shorter VAR_3 METHOD_6 ( ) METHOD_7 ( ) assert <|endcomment|> private void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( ) ; TYPE_2 VAR_3 = VAR_2 . METHOD_3 ( VAR_4 ) . METHOD_4 ( new TYPE_3 ( STRING_1 + VAR_1 + STRING_1 ) ) ; new TYPE_4 ( new TYPE_5 ( VAR_3 , TYPE_6 . VAR_5 ) , TYPE_7 . METHOD_5 ( INT_1 ) ) ; TYPE_8 VAR_6 = VAR_3 . METHOD_6 ( ) ; TYPE_6 VAR_7 = VAR_6 . METHOD_7 ( ) ; <START> assertTrue ( STRING_2 , VAR_7 == TYPE_6 . VAR_5 ) ; <END> }
<|startcomment|> please ! don t ship a null object ! : cry : <|endcomment|> TYPE_1 METHOD_1 ( final String VAR_1 , final String VAR_2 , final String VAR_3 , final boolean VAR_4 , final String VAR_5 ) { <START> return new TYPE_2 ( VAR_1 , VAR_2 , null , VAR_3 , VAR_4 , VAR_5 ) ; <END> }
<|startcomment|> I move <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 , Set < TYPE_2 > VAR_2 ) { if ( VAR_1 instanceof TYPE_3 ) { for ( TYPE_1 type : ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ) { if ( METHOD_1 ( type , VAR_2 ) ) { return true ; } } } <START> if ( METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_2 ) ) { <END> return true ; } return false ; }
<|startcomment|> int VAR_1 ( ) ; <|endcomment|> static int METHOD_1 ( ) { TYPE_1 f = new TYPE_1 ( ) { @Override <START> public String METHOD_2 ( int n ) { <END> METHOD_3 ( ) ; METHOD_1 ( ) ; return 0 ; } } ; return f . VAR_1 ( ) ; }
<|startcomment|> moving VAR_7 won t affect result <|endcomment|> private synchronized void METHOD_1 ( ) { this . VAR_1 = TYPE_1 . VAR_3 ; VAR_4 = true ; <START> if ( state != TYPE_2 . VAR_6 ) <END> state = TYPE_2 . VAR_7 ; }
<|startcomment|> need <|endcomment|> public Path METHOD_1 ( TYPE_1 uri , int size ) throws IOException { <START> new TYPE_2 ( TYPE_3 . get ( uri ) ) ; <END> METHOD_2 ( ) ; return METHOD_3 ( ) ; }
<|startcomment|> minor declaring a new TYPE_1 time good practice <|endcomment|> public void METHOD_1 ( ) { Utils . VAR_1 ( 100 ) ; <START> TYPE_1 VAR_2 = new TYPE_1 ( ) ; <END> Integer value = VAR_2 . METHOD_2 ( INT_1 ) ; VAR_3 . METHOD_3 ( new TYPE_2 ( value ) ) ; }
<|startcomment|> 3 methods public need <|endcomment|> <START> public void METHOD_1 ( final Class < ? > VAR_1 , final Object VAR_2 ) { <END> VAR_3 = "" ; }
<|startcomment|> setting true indexing <|endcomment|> public void METHOD_1 ( ) throws Exception { try ( TYPE_1 writer = new TYPE_1 ( new TYPE_2 ( METHOD_2 ( "" , false ) ) ) ) { writer . write ( METHOD_3 ( ) . trim ( ) ) ; } <START> TYPE_3 . METHOD_4 ( ) . METHOD_5 ( TYPE_3 . VAR_1 , true ) ; <END> METHOD_6 ( ) ; TYPE_3 . METHOD_4 ( ) . METHOD_5 ( TYPE_3 . VAR_1 , false ) ; String result = METHOD_7 ( ) ; METHOD_8 ( STRING_1 , result ) ; }
<|startcomment|> Log e <|endcomment|> public void METHOD_1 ( String VAR_1 ) { <START> Log . e ( STRING_1 , STRING_2 ) ; <END> VAR_2 = VAR_1 ; METHOD_2 ( query , query != null && query . length ( ) > 1 ) ; }
<|startcomment|> move tag a constant <|endcomment|> public T METHOD_1 ( TYPE_1 db , T VAR_1 , boolean VAR_2 ) { <START> Log . d ( STRING_1 , STRING_2 ) ; <END> T result = VAR_3 . METHOD_1 ( db , VAR_1 , VAR_2 ) ; Log . d ( STRING_1 , STRING_3 + VAR_1 . id ( ) ) ; return result ; }
<|startcomment|> won t copy map <|endcomment|> protected TYPE_1 ( TYPE_1 status ) { VAR_1 = status . VAR_1 ; VAR_2 = status . VAR_2 ; VAR_3 = status . VAR_3 ; VAR_4 = status . VAR_4 ; VAR_5 = status . VAR_5 ; VAR_6 = status . VAR_6 ; <START> VAR_7 = status . VAR_7 ; <END> }
<|startcomment|> VAR_2 null throw NPE <|endcomment|> boolean METHOD_1 ( ) { if ( VAR_1 ) { return false ; } TYPE_1 VAR_2 = TYPE_1 . METHOD_2 ( VAR_3 . METHOD_3 ( ) , true ) ; assert VAR_2 != null : <START> VAR_2 . METHOD_4 ( ) ; <END> return VAR_2 . METHOD_5 ( TYPE_2 . VAR_5 , VAR_6 ) ; }
<|startcomment|> s ( = _CODE_ ) public user _CODE_ ( user user String password ) instead rid _CODE_ Context evict user key consists user _CODE_ _CODE_ called invalidating entries issue <|endcomment|> public void METHOD_1 ( String VAR_1 , String value ) { METHOD_2 ( ) . put ( VAR_1 , value ) ; <START> Context . VAR_2 ( ) ; <END> }
<|startcomment|> revert change don t need specific class <|endcomment|> TYPE_2 ( TYPE_1 VAR_2 , String VAR_3 , List < String > VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = ( VAR_4 == null ? null : new ArrayList < > ( VAR_4 ) ) ; <END> }
<|startcomment|> properties provider return VAR_2 case network <|endcomment|> public String METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_1 VAR_3 = new TYPE_6 . TYPE_7 ( ) ; String result = VAR_3 . METHOD_1 ( VAR_1 , null ) ; if ( result == null ) { try { <START> result = VAR_4 . getValue ( VAR_1 , VAR_2 , new TYPE_3 ( ) ) ; <END> } catch ( TYPE_4 e ) { throw new TYPE_5 ( e ) ; } } return result ; }
<|startcomment|> simply return result METHOD_3 return true / false statements imo nicer extract i - > i VAR_2 ( VAR_1 getId ( ) ) METHOD_4 ( ) = = TYPE_3 TYPE_2 part a separate method _CODE_ easier read <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) . stream ( ) . METHOD_3 ( i - > i . VAR_2 ( VAR_1 . getId ( ) ) . METHOD_4 ( ) == TYPE_3 . TYPE_2 ) ) { return true ; } <START> return false ; <END> }
<|startcomment|> a reason TYPE_2 VAR_4 ? needed remove spaces ? a trim ( ) removing spaces words <|endcomment|> public void METHOD_1 ( String context ) { <START> VAR_1 . METHOD_1 ( TYPE_1 . valueOf ( context . VAR_2 ( STRING_1 , "" ) . METHOD_2 ( TYPE_2 . VAR_4 ) ) ) ; <END> }
<|startcomment|> close done TYPE_2 read ( ) <|endcomment|> private String METHOD_1 ( String c ) throws IOException { TYPE_1 is = getClass ( ) . METHOD_2 ( c ) ; try { return TYPE_2 . read ( is ) ; } finally { if ( is != null ) { <START> is . close ( ) ; <END> } } }
<|startcomment|> inlined <|endcomment|> protected void build ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> String name = ( String ) VAR_1 . getName ( ) . METHOD_1 ( ) ; <END> TYPE_3 VAR_3 = ( TYPE_3 ) VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( VAR_3 . getId ( ) ) ; VAR_2 . METHOD_5 ( name ) ; VAR_2 . METHOD_6 ( ( String ) VAR_1 . METHOD_7 ( ) . METHOD_1 ( ) ) ; VAR_2 . METHOD_8 ( VAR_1 . METHOD_9 ( ) . METHOD_1 ( ) ) ; }
<|startcomment|> test method combination parameters goal public method service layer tested write tests methods * METHOD_2 ( ) * METHOD_2 ( _CODE_ ) need test passing true passing false another case drugs return empty list ? I tedious written start tests wasnt <|endcomment|> public void METHOD_1 ( ) throws Exception { int VAR_1 = 4 ; int VAR_2 = 2 ; List < TYPE_1 > VAR_3 = VAR_4 . METHOD_2 ( ) ; assertEquals ( VAR_1 , VAR_3 . size ( ) ) ; <START> VAR_3 = VAR_4 . METHOD_2 ( false ) ; <END> assertEquals ( VAR_2 , VAR_3 . size ( ) ) ; }
<|startcomment|> classes reading worse <|endcomment|> public List < TYPE_6 . TYPE_5 > METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { <START> final TYPE_3 < List < TYPE_6 . TYPE_5 > > <END> VAR_2 = VAR_3 . METHOD_2 ( TYPE_4 . METHOD_3 ( VAR_1 ) ) ; return VAR_2 . METHOD_4 ( ) ; }
<|startcomment|> VAR_1 null <|endcomment|> public void METHOD_1 ( String name , Long id ) { <START> if ( VAR_1 . put ( name , id ) == null ) { <END> VAR_2 . METHOD_2 ( ) ; } }
<|startcomment|> result double logging <|endcomment|> static void METHOD_1 ( boolean VAR_1 ) { if ( VAR_1 ) { log . debug ( STRING_1 ) ; try { if ( TYPE_1 . METHOD_2 ( ) ) { TYPE_1 . METHOD_3 ( ) . METHOD_4 ( ) ; } else if ( TYPE_1 . METHOD_5 ( ) ) { TYPE_1 . METHOD_3 ( ) . METHOD_6 ( ) ; } } catch ( IOException e ) { <START> log . error ( STRING_2 ) ; <END> throw new RuntimeException ( e ) ; } } }
<|startcomment|> braces <|endcomment|> void METHOD_1 ( ) { for ( int i = 0 ; i < VAR_1 ; i ++ ) <START> for ( int j = 0 ; j < VAR_1 ; j ++ ) VAR_2 [ i ] [ j ] = 0 ; <END> VAR_3 = VAR_4 ; VAR_5 = VAR_6 ; VAR_7 = 0 ; VAR_8 = false ; }
<|startcomment|> replace arrays#stream stream#of consistency <|endcomment|> protected TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 TYPE_4 ) { String list = TYPE_5 . METHOD_2 ( TYPE_4 ) ; String name = TYPE_4 . METHOD_3 ( ) ; log . debug ( STRING_1 + name + STRING_2 + list ) ; if ( list == null ) { return TYPE_1 . empty ( ) ; } else { <START> return Arrays . stream ( list . split ( STRING_3 ) ) . map ( TYPE_4 : : METHOD_4 ) . filter ( TYPE_6 : : METHOD_5 ) ; <END> } }
<|startcomment|> please assertj assertion case fail error message explaining list sizes current implementation print assertion error expected true false reference list size <|endcomment|> public void METHOD_1 ( ) { <START> assertTrue ( VAR_1 . METHOD_2 ( VAR_2 ) . isEmpty ( ) ) ; <END> }
<|startcomment|> function public ? class <|endcomment|> <START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { <END> TYPE_1 VAR_4 = VAR_2 . METHOD_2 ( ) ; if ( VAR_5 != null ) { VAR_4 . METHOD_3 ( VAR_5 ) ; VAR_4 . METHOD_4 ( 0 , 0 , VAR_6 , VAR_7 ) ; } TYPE_5 VAR_8 = new TYPE_5 ( ) ; VAR_8 . METHOD_5 ( VAR_1 , VAR_4 , VAR_6 , VAR_7 , VAR_9 , VAR_3 ) ; return VAR_4 ; }
<|startcomment|> needed delete <|endcomment|> public static void METHOD_1 ( TYPE_1 [ ] VAR_1 , TYPE_2 monitor ) throws TYPE_3 { try { TYPE_4 VAR_2 = TYPE_4 . METHOD_2 ( monitor , TYPE_6 . TYPE_5 , VAR_1 . length ) ; for ( TYPE_1 resource : VAR_1 ) { if ( VAR_2 . METHOD_3 ( ) ) break ; resource . VAR_5 ( TYPE_1 . VAR_6 , VAR_2 . METHOD_4 ( 1 ) ) ; <START> VAR_2 . METHOD_5 ( 1 ) ; <END> } } finally { monitor . VAR_7 ( ) ; } }
<|startcomment|> return false instead else return false <|endcomment|> private boolean METHOD_1 ( TYPE_1 event ) { if ( VAR_1 . x == VAR_1 . y ) return false ; int offset = METHOD_2 ( event . x , event . y , null , true ) ; if ( VAR_1 . x <= offset && offset < VAR_1 . y ) return true ; <START> else return false ; <END> }
<|startcomment|> throws Exception needed <|endcomment|> <START> public void METHOD_1 ( ) throws Exception { VAR_1 = new TYPE_1 ( ) ; VAR_2 = new File ( VAR_3 ) ; } <END>
<|startcomment|> System ? booh <|endcomment|> public void METHOD_1 ( TYPE_1 e ) { if ( e . VAR_1 ( ) == VAR_2 ) { <START> System . out . println ( VAR_3 ) ; <END> if ( VAR_3 != null ) { VAR_3 . METHOD_2 ( true ) ; } this . METHOD_3 ( ) ; } else if ( e . VAR_1 ( ) == VAR_4 ) { if ( VAR_3 != null ) { VAR_3 . METHOD_2 ( false ) ; } this . METHOD_3 ( ) ; } }
<|startcomment|> instead initializing _CODE_ METHOD_1 ? _CODE_ = _CODE_ ( VAR_3 VAR_4 VAR_5 VAR_6 ) ; <|endcomment|> public TYPE_5 ( List < Path > VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 , List < TYPE_4 > VAR_6 ) { this . VAR_2 = VAR_2 ; this . VAR_7 = new ArrayList < > ( ) ; <START> METHOD_1 ( VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; <END> }
<|startcomment|> isn t present biojava <|endcomment|> <START> public static char METHOD_1 ( char VAR_1 , boolean VAR_2 ) { <END> if ( VAR_1 == CHAR_1 && VAR_2 ) return CHAR_2 ; if ( VAR_1 == CHAR_1 ) return CHAR_3 ; if ( VAR_1 == CHAR_3 && ! VAR_2 ) return CHAR_1 ; if ( VAR_1 == CHAR_2 && VAR_2 ) return CHAR_1 ; if ( VAR_1 == CHAR_4 ) return CHAR_5 ; if ( VAR_1 == CHAR_5 ) return CHAR_4 ; return CHAR_6 ; }
<|startcomment|> replace ( null ) <|endcomment|> public TYPE_2 ( TYPE_1 in ) throws IOException { super ( in ) ; <START> this . VAR_2 = Thread . VAR_3 ( ) . METHOD_1 ( ) ; <END> }
<|startcomment|> add log <|endcomment|> private void run ( ) { try { boolean VAR_1 = VAR_2 . METHOD_1 ( ) ; if ( ! VAR_1 ) { VAR_3 . run ( ) ; } } catch ( Exception e ) { <START> logger . warn ( STRING_1 ) ; <END> } }
<|startcomment|> remove VAR_2 <|endcomment|> protected String METHOD_1 ( final TYPE_1 context ) { <START> final String VAR_1 ; <END> final String VAR_2 = METHOD_2 ( ) ; if ( TYPE_2 . METHOD_3 ( VAR_2 ) ) { VAR_1 = VAR_2 ; } else { VAR_1 = TYPE_2 . METHOD_4 ( 10 ) ; } return VAR_1 ; }
<|startcomment|> logic potentially fragile accidentally types * spaces * e g - c [ space ] [ space ] test investigated a potentially tools / API apache commons CLI VAR_2 parsing ( instead string parsing ) ? CLI API d rewriting <|endcomment|> public TYPE_1 ( String VAR_2 ) { <START> this ( StringUtils . VAR_3 ( VAR_2 , STRING_1 ) , StringUtils . VAR_4 ( VAR_2 , STRING_1 ) ) ; <END> }
<|startcomment|> line ? check returned list empty <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 c ) { VAR_1 = list . VAR_2 ( ) ; <START> if ( list . VAR_3 ( ) ) return null ; <END> return new TYPE_3 ( ( ArrayList < TYPE_4 > ) list . VAR_4 ( ) ) ; }
<|startcomment|> don t eat exception throw wrap update interface <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; try { Collection < TYPE_2 > VAR_2 = VAR_3 . get ( ) . METHOD_2 ( ) ; for ( TYPE_2 VAR_4 : VAR_2 ) { VAR_1 . add ( TYPE_3 . METHOD_3 ( VAR_4 ) ) ; } } catch ( Exception e ) { LOG . warn ( STRING_1 , e ) ; <START> } <END> return VAR_1 ; }
<|startcomment|> deprecate <|endcomment|> <START> protected void METHOD_1 ( ) throws TYPE_1 { <END> if ( VAR_1 == null ) { throw new IllegalStateException ( TYPE_2 . METHOD_2 ( STRING_1 , STRING_2 ) . getMessage ( ) ) ; } try { VAR_1 . METHOD_3 ( METHOD_4 ( ) ) ; VAR_1 . METHOD_5 ( ) ; synchronized ( this ) { VAR_2 = VAR_1 . METHOD_6 ( ) ; } } catch ( Exception e ) { throw new TYPE_1 ( METHOD_7 ( STRING_3 ) , e ) ; } }
<|startcomment|> org modeshape common util _CODE_ compute ( ) instead ? return VAR_2 ( ) ? ( null ? ) <|endcomment|> public int METHOD_1 ( ) { int VAR_1 = INT_1 ; VAR_1 = INT_2 * VAR_1 + ( this . name != null ? this . name . VAR_2 ( ) : 0 ) ; <START> return VAR_1 ; <END> }
<|startcomment|> VAR_2 I <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < TYPE_3 > VAR_2 ) { Exception exception = null ; VAR_3 . VAR_4 . METHOD_2 ( ) ; long VAR_5 = System . currentTimeMillis ( ) ; if ( ! VAR_6 ) { exception = new TYPE_4 ( STRING_1 , TYPE_6 . TYPE_5 ) ; } else if ( VAR_1 == null || VAR_2 == null ) { throw new IllegalArgumentException ( STRING_2 ) ; } <START> VAR_2 . METHOD_3 ( null , exception ) ; <END> VAR_3 . VAR_9 . update ( System . currentTimeMillis ( ) - VAR_5 ) ; }
<|startcomment|> static <|endcomment|> <START> private TYPE_1 [ ] <END> METHOD_1 ( List < TYPE_1 > VAR_1 ) { return VAR_1 . METHOD_1 ( new TYPE_1 [ VAR_1 . size ( ) ] ) ; }
<|startcomment|> update wouldn t work id a new idsetting a new id job add command <|endcomment|> public TYPE_1 ( ) { <START> VAR_2 . METHOD_1 ( Guid . VAR_3 ( ) ) ; <END> }
<|startcomment|> safe call METHOD_2 multiple times source METHOD_2 ( ) s a nice global check lines ( _CODE_ ! = null && _CODE_ ( ) ) <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( null != VAR_2 ) { <START> VAR_2 . METHOD_2 ( ) ; <END> } }
<|startcomment|> done <|endcomment|> <START> public void METHOD_1 ( ) { <END> METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , true ) ; METHOD_2 ( VAR_1 , VAR_4 , VAR_5 , true ) ; VAR_6 . METHOD_3 ( ) ; }
<|startcomment|> TYPE_5 METHOD_6 ( 5 ) - > 5 timeout parameter METHOD_5 ( ) seconds milliseconds <|endcomment|> public void METHOD_1 ( ) { config . VAR_1 ( TYPE_1 . getName ( ) , STRING_1 ) ; METHOD_2 ( ) ; final TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . VAR_3 = INT_1 ; VAR_4 . METHOD_3 ( VAR_2 , METHOD_4 ( ) ) ; final TYPE_3 VAR_5 = new TYPE_3 ( ) ; VAR_4 . execute ( VAR_5 ) ; METHOD_5 ( new TYPE_4 ( ) { @Override public void run ( ) { assertTrue ( VAR_5 . VAR_6 ) ; } <START> } , TYPE_5 . METHOD_6 ( 5 ) ) ; <END> }
<|startcomment|> I guess assert temporary variable <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( INT_1 ) ; <START> boolean result = VAR_1 . equals ( VAR_1 ) ; <END> assertTrue ( result ) ; }
<|startcomment|> return : METHOD_1 ( VAR_4 VAR_1 ) ; <|endcomment|> <START> public TYPE_1 METHOD_1 ( TYPE_2 < TYPE_3 > VAR_1 ) { <END> return new TYPE_1 ( this . state , this . VAR_2 , this . container , this . VAR_3 , this . VAR_4 , this . VAR_5 , VAR_1 , this . VAR_6 , this . VAR_7 ) ; }
<|startcomment|> return true more obvious <|endcomment|> public boolean METHOD_1 ( String VAR_1 , String VAR_2 , TYPE_1 VAR_3 ) { try { final Optional < TYPE_2 > VAR_4 = METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; if ( ! VAR_4 . isPresent ( ) ) { TYPE_3 . METHOD_3 ( TYPE_4 . format ( Messages . TYPE_6 , VAR_1 , VAR_6 ) ) ; } return <START> VAR_4 . isPresent ( ) ; <END> } catch ( final TYPE_5 ex ) { return false ; } }
<|startcomment|> duplicate assert <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 ) ; assertEquals ( STRING_2 , VAR_1 . METHOD_2 ( ) ) ; assertEquals ( STRING_3 , VAR_1 . METHOD_3 ( ) ) ; <START> assertEquals ( STRING_3 , VAR_1 . METHOD_3 ( ) ) ; <END> assertEquals ( STRING_1 , VAR_1 . METHOD_4 ( ) ) ; assertEquals ( null , VAR_1 . METHOD_5 ( ) ) ; }
<|startcomment|> null source odd <|endcomment|> public void METHOD_1 ( Object event ) { <START> METHOD_1 ( new TYPE_1 < Object > ( null , event ) ) ; <END> }
<|startcomment|> personally simple I simple a ternary operation code simplicity mind code size <|endcomment|> public boolean METHOD_1 ( ) { <START> if ( VAR_1 ) <END> return VAR_2 . METHOD_1 ( ) ; else return false ; }
<|startcomment|> I don t need check method simply _CODE_ METHOD_3 ( getParameters ( ) METHOD_2 ( ) ) needed getParameters ( ) METHOD_2 ( ) simply won t result <|endcomment|> private TYPE_1 METHOD_1 ( ) { if ( getParameters ( ) . METHOD_2 ( ) != null ) { return VAR_1 . METHOD_3 ( getParameters ( ) . METHOD_2 ( ) ) ; } <START> return null ; <END> }
<|startcomment|> method protected changing signature break - team / junit - committers handle ? add new feature breaking extension point I m favour modifying methods signature making private users create a new rule instead extending timeout builder creating VAR_1 <|endcomment|> protected TYPE_1 METHOD_1 ( <START> TYPE_1 VAR_1 , TYPE_2 description ) throws Exception { <END> return TYPE_3 . builder ( ) . METHOD_2 ( VAR_2 , VAR_3 ) . METHOD_3 ( VAR_4 ) . METHOD_4 ( description ) . build ( VAR_1 ) ; }
<|startcomment|> loop fails VAR_1 _the first_ stop ( 0 ) method : Set < TYPE_1 < TYPE_2 > > VAR_2 = new HashSet < > ( ) ; ( VAR_1 hasNext ( ) ) { VAR_2 addAll ( VAR_4 ( VAR_1 ( ) ) ) ; } return VAR_2 iterator ( ) ; <|endcomment|> @Override public Iterator < ? extends TYPE_1 < TYPE_2 > > METHOD_1 ( TYPE_3 VAR_1 ) { Set < TYPE_1 < TYPE_2 > > VAR_2 = new HashSet < > ( ) ; int VAR_3 = VAR_1 . next ( ) ; while ( VAR_3 > 0 ) { VAR_2 . addAll ( VAR_4 . get ( VAR_3 ) ) ; VAR_3 = VAR_1 . next ( ) ; } <START> return VAR_2 . iterator ( ) ; <END> }
<|startcomment|> unnecessary set VAR_2 expected elements org jboss weld bootstrap _CODE_ _CODE_ ( _CODE_ ) other places constructor <|endcomment|> public TYPE_2 ( T context , Class < T > type , Set < TYPE_1 > VAR_2 ) { this . context = context ; this . type = type ; <START> this . VAR_2 = METHOD_1 ( TYPE_3 . VAR_4 , TYPE_4 . VAR_4 ) ; <END> this . VAR_2 . addAll ( VAR_2 ) ; }
<|startcomment|> unnecessary ; enabled default core disabled wizard <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_4 . TYPE_5 . get ( ) . METHOD_2 ( true ) ; <END> Set < String > VAR_1 = new HashSet < > ( j . VAR_2 . METHOD_3 ( ) ) ; VAR_1 . add ( TYPE_2 . METHOD_4 ( TYPE_3 . class ) . getName ( ) ) ; j . VAR_2 . METHOD_5 ( VAR_1 ) ; }
<|startcomment|> a lack symmetry VAR_4 initialized ctors <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 context , TYPE_3 VAR_3 ) { this . VAR_2 = VAR_2 ; this . context = context ; this . VAR_3 = VAR_3 ; this . VAR_4 = <START> 1 ; <END> }
<|startcomment|> ImmutableList VAR_5 <|endcomment|> public TYPE_4 ( List < TYPE_1 > VAR_2 , List < TYPE_2 > VAR_3 , List < TYPE_3 > VAR_4 ) { this . VAR_2 = ImmutableList . VAR_5 ( METHOD_1 ( VAR_2 , STRING_1 ) ) ; this . VAR_3 = ImmutableList . VAR_5 ( METHOD_1 ( VAR_3 , STRING_2 ) ) ; <START> this . VAR_4 = METHOD_1 ( VAR_4 , STRING_3 ) ; <END> }
<|startcomment|> i m getValue ( ) supposed called I work correctly called set VAR_2 zero METHOD_1 <|endcomment|> public Double getValue ( ) { try { <START> VAR_1 . METHOD_1 ( VAR_2 ) ; <END> } catch ( TYPE_1 ex ) { throw new RuntimeException ( STRING_1 + ex ) ; } return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> hmm I remove line s needed close ( null ) s a left - line some previous version file result set closed properly : - ) <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { boolean result = true ; TYPE_2 VAR_2 = null ; try { VAR_2 = VAR_1 . METHOD_2 ( ) ; while ( VAR_2 . next ( ) && result ) { result = false ; } } catch ( TYPE_3 e ) { throw TYPE_4 . METHOD_3 ( e , STRING_1 , TYPE_6 . VAR_4 ) ; } finally { TYPE_5 . METHOD_4 ( VAR_2 ) ; <START> close ( null ) ; <END> } return result ; }
<|startcomment|> ( ! event VAR_1 ( ) ) avoided adding ( observation = observation POST ) class level <|endcomment|> public void METHOD_1 ( TYPE_1 event ) { if ( ! event . VAR_1 ( ) ) { METHOD_2 ( ( String ) event . getKey ( ) ) ; } <START> } <END>
<|startcomment|> flip move METHOD_1 call <|endcomment|> public void METHOD_1 ( ANNOTATION_1 String path ) { if ( path == null ) { <START> return ; <END> } METHOD_1 ( TYPE_1 . parse ( path ) ) ; }
<|startcomment|> block simplified ? javapublic TYPE_1 METHOD_1 ( ) { VAR_1 = new TYPE_2 ( ) ; ( VAR_2 = = null ) { METHOD_2 ( ) ; } ( VAR_3 = = null ) { METHOD_3 ( ) ; } return ; } <|endcomment|> public TYPE_1 METHOD_1 ( ) { VAR_1 = new TYPE_2 ( ) ; if ( VAR_2 == null && VAR_3 == null ) { return this . METHOD_2 ( ) . METHOD_3 ( ) ; } else if ( VAR_2 == null ) { return this . METHOD_2 ( ) ; } else if ( VAR_3 == null ) { return this . METHOD_3 ( ) ; } <START> return this ; <END> }
<|startcomment|> I don t code duplication aboutif ( ! = null ) { switch ( ) { } } Assert VAR_1 ( false ) ; return null ; <|endcomment|> public static String METHOD_1 ( String name ) { if ( name == null ) { Assert . VAR_1 ( false ) ; return null ; <START> } <END> switch ( name ) { case VAR_2 : return Messages . TYPE_2 ; case VAR_4 : return Messages . TYPE_1 ; case VAR_6 : return Messages . TYPE_3 ; default : break ; } Assert . VAR_1 ( false ) ; return null ; }
<|startcomment|> need public <|endcomment|> <START> public String METHOD_1 ( String VAR_1 , char VAR_2 ) { <END> return VAR_1 . substring ( 0 , VAR_1 . METHOD_2 ( VAR_2 ) ) ; }
<|startcomment|> minor s consistent initialize set map ? I check a specific reason initialize compared others <|endcomment|> private TYPE_1 ( ) { this . VAR_2 = null ; this . VAR_3 = null ; this . VAR_4 = null ; this . VAR_5 = null ; this . VAR_6 = null ; this . VAR_7 = null ; <START> this . VAR_8 = new HashSet < > ( 0 ) ; <END> this . VAR_9 = VAR_10 ; this . VAR_11 = true ; this . VAR_12 = METHOD_1 ( ) ; this . properties = METHOD_2 ( ) ; }
<|startcomment|> I concerned addition METHOD_4 single METHOD_3 read data METHOD_3 checksum instead expensive dealing large files performance regressions <|endcomment|> public static TYPE_8 . TYPE_9 METHOD_1 ( TYPE_2 is , File file ) throws IOException { file . VAR_1 ( ) . METHOD_2 ( ) ; try ( TYPE_3 VAR_2 = new TYPE_4 ( new TYPE_5 ( file ) ) ) { TYPE_6 . METHOD_3 ( is , VAR_2 ) ; } finally { TYPE_7 . close ( is ) ; } <START> return TYPE_8 . TYPE_9 . METHOD_4 ( file . VAR_3 ( ) ) ; <END> }
<|startcomment|> _CODE_ ( dont else ) longer need synchronized keyword <|endcomment|> <START> @Override public synchronized boolean METHOD_1 ( final boolean VAR_1 ) { <END> return VAR_2 . METHOD_2 ( false , true ) ; }
<|startcomment|> hey quick a potential NPE produced ? I METHOD_3 ( null ) getValue ( ) <|endcomment|> <START> <END> protected <END> TYPE_1 <END> < <END> <END> TYPE_2 > METHOD_1 <END> ( final <END> <END> TYPE_3 <END> < ? > <END> command ) { <END> return <END> VAR_1 . <END> entrySet <END> ( ) . <END> stream <END> ( ) . <END> filter ( e <END> - <END> > <END> e <END> . getKey ( <END> )
<|startcomment|> TAG <|endcomment|> public TYPE_1 ( ) { <START> super ( TYPE_1 . class . METHOD_1 ( ) , VAR_1 , <END> null , null ) ; VAR_2 = Integer . VAR_3 ; VAR_4 = Integer . VAR_3 ; VAR_5 = Integer . VAR_3 ; VAR_6 = Integer . VAR_3 ; VAR_7 = Integer . VAR_3 ; VAR_8 = null ; VAR_9 = null ; }
<|startcomment|> encapsulating underlying implementation TYPE_1 need _CODE_ ? I m thinking _CODE_ _CODE_ ( ) bug I meant call METHOD_9 ( ) bug live place expose a large object _CODE_ lots flexibility a card meant s some notes some tradeoffs : <|endcomment|> private void METHOD_1 ( ANNOTATION_1 final TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( METHOD_2 ( ) ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) <START> . METHOD_7 ( VAR_1 . METHOD_8 ( ) . METHOD_9 ( ) ) <END> . METHOD_10 ( VAR_1 . METHOD_11 ( ) ) ; METHOD_1 ( VAR_2 ) ; }
<|startcomment|> TYPE_2 toString ( ) - > String valueOf ( TYPE_2 ) s int <|endcomment|> private int METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = TYPE_2 ; try { <START> VAR_2 = Integer . parseInt ( VAR_1 . METHOD_2 ( ) . getProperty ( VAR_3 , TYPE_2 . toString ( ) ) ) ; <END> } catch ( TYPE_3 e ) { log . warn ( String . format ( STRING_1 , VAR_3 ) , e ) ; } return VAR_2 ; }
<|startcomment|> a WARN instead ERROR <|endcomment|> private void METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { <START> logger . error ( STRING_1 , VAR_1 ) ; <END> return ; } TYPE_2 VAR_4 = VAR_2 . METHOD_2 ( ) ; if ( VAR_4 != null ) { try { logger . debug ( STRING_2 , VAR_1 ) ; VAR_4 . METHOD_3 ( ) ; } catch ( TYPE_3 e ) { logger . debug ( STRING_3 , VAR_1 ) ; } } }
<|startcomment|> I d prefer ImmutableList <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( <START> TYPE_1 . METHOD_3 ( STRING_1 ) , <END> TYPE_1 . METHOD_3 ( STRING_2 ) , TYPE_1 . METHOD_3 ( STRING_3 ) ) ; }
<|startcomment|> I d expect union POINT ( 1 2 ) LINESTRING EMPTY POINT ( 1 2 ) test asserts result GEOMETRYCOLLECTION ( POINT ( 1 2 ) ) <|endcomment|> public void METHOD_1 ( ) { <START> METHOD_2 ( STRING_1 , STRING_2 , STRING_3 ) ; <END> }
<|startcomment|> protected <|endcomment|> <START> public TYPE_4 ( TYPE_1 entity , TYPE_2 < T > VAR_2 , TYPE_3 < T > VAR_3 , double x , double y , double VAR_4 ) <END> { super ( entity , VAR_2 , x , y , VAR_4 ) ; this . VAR_3 = VAR_3 ; }
<|startcomment|> output cache reset <|endcomment|> public void METHOD_1 ( final TYPE_1 server ) throws TYPE_2 { File VAR_1 = METHOD_2 ( ) ; Arrays . stream ( server . VAR_2 ( ) ) <START> . forEach ( VAR_3 - > METHOD_3 ( VAR_3 , VAR_1 ) ) ; <END> }
<|startcomment|> I recommend < code > ( ) < / code > constructor <|endcomment|> public TYPE_3 ( String format , int line , TYPE_1 VAR_2 ) throws TYPE_2 { <START> set ( format , line , VAR_2 ) ; <END> }
<|startcomment|> sense static methods wrote ? ( buf = = null || Math min ( buf length VAR_3 ) < VAR_2 + 1 / * required array length method work correctly * / ) { return false ; } I a common practice currently libjitsi a sloppy access arrays I change write more defensive code <|endcomment|> public boolean METHOD_1 ( byte [ ] VAR_1 , int VAR_2 , int VAR_3 ) { <START> if ( VAR_1 == null || VAR_3 < 1 || VAR_1 . length < VAR_3 ) <END> { return false ; } int VAR_4 = VAR_1 [ VAR_2 ] & VAR_5 ; if ( VAR_4 == VAR_6 ) { if ( METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ) { return true ; } } else { if ( METHOD_3 ( VAR_1 , VAR_2 , VAR_3 ) ) { return true ; } } return false ; }
<|startcomment|> ( TYPE_3 NO_RESPONSE ) change return type void remove return statement <|endcomment|> <START> public TYPE_1 < ? > METHOD_1 ( ANNOTATION_1 List < Long > VAR_1 ) throws IOException { <END> for ( long id : VAR_1 ) { TYPE_2 VAR_2 = VAR_3 . get ( id ) ; if ( VAR_2 != null ) { VAR_3 . remove ( VAR_2 ) ; } } return new TYPE_1 < > ( TYPE_3 . VAR_5 ) ; }
<|startcomment|> VAR_3 other files <|endcomment|> public TYPE_1 METHOD_1 ( int VAR_1 ) { return VAR_2 . METHOD_2 ( VAR_1 , VAR_3 - > new <START> TYPE_1 ( VAR_1 , METHOD_3 ( METHOD_4 ( ) ) ) ) ; <END> }
<|startcomment|> context GUVNOR - 2821 I expect assertTrue please update METHOD_2 method achieve ? don t point <|endcomment|> public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = METHOD_2 ( STRING_1 ) ; final TYPE_1 VAR_2 = METHOD_2 ( STRING_2 ) ; final TYPE_2 VAR_3 = new TYPE_2 ( METHOD_3 ( VAR_1 , VAR_2 ) ) ; <START> METHOD_4 ( VAR_3 . METHOD_5 ( VAR_2 ) ) ; <END> }
<|startcomment|> need a class member <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> VAR_3 = VAR_2 . METHOD_1 ( TYPE_1 . name ( TYPE_2 . class , STRING_1 ) ) ; VAR_4 = VAR_2 . METHOD_2 ( TYPE_1 . name ( TYPE_2 . class , STRING_2 ) ) ; VAR_5 = VAR_2 . METHOD_2 ( TYPE_1 . name ( TYPE_2 . class , STRING_3 ) ) ; }
<|startcomment|> minor : VAR_2 size ( ) > 0 check isn t needed <|endcomment|> TYPE_1 ( List < String > VAR_2 ) { if ( VAR_2 != null && VAR_2 . size ( ) > 0 ) { VAR_3 . addAll ( VAR_2 ) ; } <START> } <END>
<|startcomment|> TYPE_1 renamed _CODE_ <|endcomment|> <START> protected TYPE_1 METHOD_1 ( ) { <END> return new TYPE_1 ( ) { @Override public byte [ ] get ( final String key ) throws IOException { return VAR_1 . get ( VAR_2 . METHOD_2 ( ) . format ( key ) ) ; } } ; }
<|startcomment|> tests don t rely TYPE_1 VAR_2 remove line rename method rid _CODE_ ( ) <|endcomment|> public void METHOD_1 ( ) throws IOException { <START> TYPE_1 . VAR_2 = STRING_1 ; <END> VAR_3 = resource ( STRING_2 ) ; }
<|startcomment|> good include causing exception user couldn t created <|endcomment|> private TYPE_1 METHOD_1 ( String VAR_1 ) { try { Class < ? > VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 , this . getClass ( ) . METHOD_3 ( ) ) ; Object instance = TYPE_3 . METHOD_4 ( VAR_2 ) ; Assert . VAR_3 ( TYPE_1 . class , instance ) ; return ( TYPE_1 ) instance ; } catch ( Exception ex ) { throw new IllegalStateException ( <START> STRING_1 + VAR_1 + STRING_2 ) ; <END> } }
<|startcomment|> need swap order nullcheck / isEmpty lead NPE ( METHOD_3 returns null s ) validator fail <|endcomment|> protected Optional < TYPE_1 > METHOD_1 ( Path VAR_1 ) { TYPE_2 VAR_2 = this . METHOD_2 ( VAR_3 , VAR_1 ) ; <START> if ( VAR_2 . METHOD_3 ( ) . isEmpty ( ) || VAR_2 . METHOD_3 ( ) == null ) { <END> return Optional . empty ( ) ; } else { return Optional . of ( new TYPE_1 ( TYPE_3 . class . METHOD_4 ( ) , "" ) ) ; } }
<|startcomment|> VAR_2 = = null ? isn t set open ( ) ? need check VAR_1 <|endcomment|> public boolean METHOD_1 ( ) { <START> return VAR_1 . METHOD_1 ( ) && VAR_2 != null && VAR_2 . METHOD_1 ( ) ; <END> }
<|startcomment|> enabled ? restore <|endcomment|> public static void METHOD_1 ( ) { System . VAR_1 ( STRING_1 ) ; <START> System . VAR_1 ( STRING_2 ) ; <END> System . VAR_1 ( STRING_3 ) ; }
<|startcomment|> I d more specific error messages s a scenarios aware : * A permanent group s * * patched description updated * a community / Collection group s ( editable ) & description ( editable ) s detached case patched a minimum need errors & checks permanent groups * * updates description updates community / Collection groups updated community / Collection deleted considered permanent <|endcomment|> protected void METHOD_1 ( Context context , TYPE_1 request , String VAR_1 , String model , TYPE_2 id , TYPE_3 VAR_2 ) throws TYPE_4 , TYPE_5 { final TYPE_6 group = VAR_3 . METHOD_2 ( context , id ) ; if ( group != null && METHOD_3 ( context , group ) ) { <START> throw new TYPE_7 ( STRING_1 ) ; <END> } METHOD_4 ( VAR_1 , model , id , VAR_2 ) ; }
<|startcomment|> need assign VAR_1 return line add a null check VAR_3 <|endcomment|> protected String METHOD_1 ( TYPE_1 < ? > message ) { <START> String VAR_1 = VAR_2 . getValue ( VAR_3 , message , TYPE_2 . class ) . toString ( ) ; <END> return VAR_1 ; }
<|startcomment|> break statement multiple readability <|endcomment|> public boolean METHOD_1 ( final TYPE_1 VAR_1 ) { <START> return VAR_2 . isEmpty ( ) <END> || ( VAR_2 . size ( ) == 1 && VAR_1 . METHOD_2 ( TYPE_2 . METHOD_3 ( VAR_2 ) ) != null && ! VAR_1 . METHOD_4 ( TYPE_2 . METHOD_3 ( VAR_2 ) ) ) ; }
<|startcomment|> method changed private <|endcomment|> <START> public <END> void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; }
<|startcomment|> please write ! config VAR_4 ( ) isEmpty ( ) instead checking size <|endcomment|> private long METHOD_1 ( TYPE_1 node ) { return VAR_1 . stream ( ) . filter ( VAR_2 - > { TYPE_2 config = node . VAR_3 ( ) . METHOD_2 ( VAR_2 . getName ( ) ) ; if ( config != null ) { <START> return config . VAR_4 ( ) . size ( ) >= 1 ; <END> } return false ; } ) . count ( ) ; }
<|startcomment|> change toString VAR_3 ; ( VAR_2 METHOD_3 ( ) ) { VAR_3 = VAR_2 METHOD_4 ( ) ; } else { VAR_3 = VAR_2 METHOD_2 ( ) ; } <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 value , TYPE_3 parent , TYPE_4 VAR_2 ) { String VAR_3 = VAR_2 . METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( ) ) { VAR_3 = VAR_2 . METHOD_4 ( ) ; <START> } <END> TYPE_5 . METHOD_5 ( parent , VAR_2 . getName ( ) , VAR_1 . METHOD_6 ( ) , VAR_3 ) ; }
<|startcomment|> final VAR_2 ? issue line 130 final local variables spock I d remove <|endcomment|> private boolean METHOD_1 ( Throwable exception ) { if ( ! ( exception instanceof TYPE_1 ) ) return false ; <START> final TYPE_1 VAR_1 = ( TYPE_1 ) exception ; <END> TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( ) ; return VAR_3 != null && VAR_3 . METHOD_4 ( ) && VAR_1 . METHOD_5 ( ) == null ; }
<|startcomment|> checks necessary logout <|endcomment|> public final TYPE_1 METHOD_1 ( final TYPE_2 context ) { <START> if ( VAR_1 . METHOD_2 ( context ) ) { <END> logger . info ( STRING_1 ) ; METHOD_3 ( context ) ; return null ; } final String VAR_2 = ( String ) context . VAR_3 ( getName ( ) + VAR_4 ) ; if ( TYPE_3 . METHOD_4 ( VAR_2 ) ) { return null ; } METHOD_5 ( context ) ; return METHOD_6 ( context ) ; }
<|startcomment|> debug / trace / remove <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> logger . info ( STRING_1 ) ; <END> METHOD_2 ( VAR_1 ) ; }
<|startcomment|> need I feel else A binding _CODE_ dependencies TYPE_1 classes work <|endcomment|> public TYPE_4 ( TYPE_1 config , String VAR_2 , TYPE_2 VAR_3 ) { this . VAR_4 = config . getString ( VAR_5 , TYPE_5 . VAR_7 ) ; this . VAR_2 = VAR_2 ; this . config = config . VAR_8 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; <START> TYPE_3 . getInstance ( ) . METHOD_1 ( this ) ; <END> }
<|startcomment|> ( equivalent 3 0 class ) place a field isn t shadowed intentional <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 context ) { TYPE_4 VAR_2 = METHOD_2 ( context , null ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_3 ( TYPE_6 . TYPE_7 . toString ( ) ) ; } <START> return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 , this . METHOD_4 ( context ) ) ; <END> }
<|startcomment|> drop empty block <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { logger . trace ( STRING_1 ) ; <START> if ( VAR_1 instanceof TYPE_2 ) { <END> } super . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> please remove final modifiers redundant <|endcomment|> private Map < String , String > METHOD_1 ( ) { final Map < String , String > VAR_1 = TYPE_1 . METHOD_2 ( ) ; for ( final TYPE_2 VAR_2 : METHOD_3 ( ) ) { final String VAR_3 = VAR_2 . METHOD_4 ( ) . getPath ( ) ; try { <START> final String VAR_4 = TYPE_3 . METHOD_5 ( VAR_3 ) ; <END> VAR_1 . put ( VAR_3 , VAR_4 ) ; } catch ( Exception e ) { LOG . info ( STRING_1 + VAR_3 + STRING_2 , e ) ; } } return VAR_1 ; }
<|startcomment|> message needs changed retrofit ? care people overwrite ? I don t breaks _CODE_ ( ) desire <|endcomment|> public Builder client ( ANNOTATION_1 TYPE_1 client ) { if ( client == null ) { throw new TYPE_2 ( STRING_1 ) ; } if ( VAR_1 != null ) { throw new IllegalArgumentException ( STRING_2 ) ; } VAR_1 = new TYPE_3 ( client , client . cache ( ) , true ) ; return this ; <START> } <END>
<|startcomment|> a small remark feel free skip a nicer else logic direct likeif ( VAR_2 = = null ) { return Optional empty ( ) ; } else { final TYPE_4 VAR_4 = ( TYPE_4 ) VAR_2 ; return Optional ( ( TYPE_1 ) VAR_4 METHOD_3 ( ) ) ; } <|endcomment|> protected Optional < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { final TYPE_3 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 != null ) { <END> final TYPE_4 VAR_4 = ( TYPE_4 ) VAR_2 ; return Optional . of ( ( TYPE_1 ) VAR_4 . METHOD_3 ( ) ) ; } else { return Optional . empty ( ) ; } }
<|startcomment|> generally don t sort _CODE_ case - don t sort move top list firstly consider dropping method making METHOD_1 ( ) protected add logic _CODE_ drop comparator iterate items find specific ID move top list comparator isn t necessary <|endcomment|> private void METHOD_1 ( ) { if ( METHOD_2 ( ) != null ) { return ; } TYPE_1 VAR_1 = METHOD_3 ( ) ; if ( VAR_1 == null ) { return ; } <START> METHOD_4 ( VAR_1 ) ; <END> TYPE_2 model = new TYPE_3 ( VAR_1 , this , METHOD_5 ( ) ) ; model . VAR_2 ( ) ; METHOD_6 ( model ) ; }
<|startcomment|> considering expected exception test assertThat superfluous want VAR_3 hasNext ( ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = db . VAR_2 ( ) . METHOD_2 ( TYPE_1 . class ) ; Iterator < TYPE_2 > VAR_3 = VAR_1 . METHOD_3 ( ) ; <START> assertThat ( VAR_3 . hasNext ( ) ) . METHOD_4 ( ) ; <END> }
<|startcomment|> class included method called <|endcomment|> public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 s , List < String > VAR_2 ) { Set < String > VAR_3 = TYPE_3 . METHOD_2 ( s , VAR_1 ) ; Boolean VAR_4 = true ; <START> assertEquals ( VAR_3 . size ( ) , VAR_2 . size ( ) ) ; <END> for ( String i : VAR_2 ) { if ( ! VAR_3 . contains ( i ) ) { VAR_4 = false ; break ; } } assertTrue ( VAR_4 ) ; }
<|startcomment|> edge case duplicate code ; ) extracted a common private method params id type want change ; ) <|endcomment|> public List < TYPE_1 > METHOD_1 ( String VAR_1 ) throws TYPE_2 { <START> if ( VAR_1 == null || VAR_1 . trim ( ) . isEmpty ( ) ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } return TYPE_3 . METHOD_2 ( VAR_2 , VAR_3 , VAR_1 ) ; }
<|startcomment|> return true disks storage domain ( remember don t check validate method VAR_6 ) change assertTrue <|endcomment|> public void METHOD_1 ( ) { final TYPE_1 vm = new TYPE_1 ( ) ; command . VAR_1 ( vm ) ; when ( VAR_2 . get ( command . getParameters ( ) . METHOD_2 ( ) ) ) . METHOD_3 ( vm ) ; command . VAR_3 ( new TYPE_2 ( ) ) ; Guid VAR_4 = METHOD_4 ( vm ) ; when ( VAR_5 . get ( VAR_4 ) ) . METHOD_3 ( METHOD_5 ( true ) ) ; <START> METHOD_6 ( STRING_1 , <END> command . VAR_6 ( ) ) ; }
<|startcomment|> shouldn t max ( ) offset VAR_1 avoid VAR_3 previous offset <|endcomment|> public long METHOD_1 ( long n ) { if ( n > 0 ) { long VAR_1 = VAR_2 . length - VAR_3 ; if ( VAR_1 > n ) VAR_1 = n ; VAR_3 += VAR_1 ; return VAR_1 ; } else { int VAR_4 = Math . VAR_5 ( VAR_2 . length , VAR_3 ) ; long VAR_1 = VAR_4 + n ; <START> VAR_3 = ( int ) VAR_1 ; <END> return VAR_1 ; } }
<|startcomment|> want put a / finally block <|endcomment|> public void METHOD_1 ( TYPE_1 e ) { TYPE_3 . TYPE_4 s = METHOD_2 ( e ) ; List < String > VAR_1 = Collections . VAR_2 ( s . VAR_3 ( ) ) ; s . VAR_4 ( VAR_1 ) ; <START> s . VAR_5 ( ) ; <END> }
<|startcomment|> rename s <|endcomment|> public void addAll ( TYPE_1 status ) { Assert . VAR_1 ( status != null ) ; TYPE_1 [ ] VAR_2 = ( TYPE_1 [ ] ) status . VAR_3 ( ) ; for ( TYPE_1 <START> VAR_4 : <END> VAR_2 ) { add ( VAR_4 ) ; } }
<|startcomment|> moving METHOD_3 ( ) METHOD_4 ( ) ? case METHOD_4 ( ) returns false save DB call : ) <|endcomment|> protected boolean METHOD_1 ( ) { <START> return super . METHOD_1 ( ) && METHOD_2 ( ) && METHOD_3 ( ) && METHOD_4 ( ) ; <END> }
<|startcomment|> reason t iterate values ? VAR_3 values ( ) foreach ( - > METHOD_2 ( ) ) ; VAR_3 clear ( ) ; <|endcomment|> protected void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; Set < String > VAR_2 = METHOD_3 ( ) ; for ( String key : VAR_3 . keySet ( ) ) { VAR_3 . get ( key ) . METHOD_2 ( ) ; VAR_3 . remove ( key ) ; <START> } <END> for ( final String VAR_4 : VAR_2 ) { METHOD_4 ( VAR_4 ) ; } }
<|startcomment|> assertion removed test java type system code <|endcomment|> public void METHOD_1 ( ) { TYPE_1 configuration = METHOD_2 ( ) ; configuration . VAR_1 ( STRING_1 , STRING_2 , STRING_3 ) ; <START> assertEquals ( TYPE_2 . class , configuration . VAR_2 ( ) . getClass ( ) ) ; <END> assertEquals ( STRING_1 , configuration . VAR_2 ( ) . getId ( ) ) ; assertEquals ( STRING_2 , configuration . VAR_2 ( ) . METHOD_3 ( ) ) ; assertEquals ( STRING_3 , configuration . VAR_2 ( ) . getName ( ) ) ; }
<|startcomment|> need call file toString ( ) - > TYPE_2 File constructor <|endcomment|> private void METHOD_1 ( File file , String VAR_1 ) throws IOException { <START> try ( TYPE_1 VAR_2 = new TYPE_1 ( new TYPE_2 ( file . toString ( ) ) ) ) { <END> VAR_2 . write ( VAR_1 ) ; } }
<|startcomment|> minor : calls collapsed TYPE_3 METHOD_3 handles nulls fine <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Object VAR_2 = VAR_3 . METHOD_2 ( ) . get ( TYPE_5 . VAR_5 ) ; if ( VAR_2 == null ) { return VAR_1 . VAR_6 ; } <START> Long VAR_7 = TYPE_3 . METHOD_3 ( VAR_2 , true ) ; <END> if ( VAR_7 == null ) { return VAR_1 . VAR_6 ; } return TYPE_4 . create ( VAR_1 . VAR_6 , VAR_1 . VAR_8 , METHOD_4 ( 0 ) , METHOD_4 ( VAR_7 ) ) ; }
<|startcomment|> TYPE_1 unused <|endcomment|> <START> public void METHOD_1 ( ) throws IOException , TYPE_1 { <END> TYPE_2 VAR_1 = new TYPE_2 ( ) ; try { TYPE_3 VAR_2 = METHOD_2 ( ) ; VAR_2 . METHOD_3 ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; METHOD_5 ( STRING_3 ) ; } catch ( TYPE_1 VAR_3 ) { String VAR_4 = STRING_4 ; assertEquals ( VAR_4 , VAR_3 . getMessage ( ) ) ; } }
<|startcomment|> TYPE_3 thrown shouldn t declared throws <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 url ) <START> throws IOException , TYPE_3 { <END> return METHOD_1 ( url , VAR_1 ) ; }
<|startcomment|> 1 s replace params _CODE_ more sense method reside _CODE_ - I don t related _CODE_ <|endcomment|> public void METHOD_1 ( ArrayList < TYPE_1 > parameters , TYPE_2 command ) { <START> for ( TYPE_1 VAR_1 : parameters ) { <END> VAR_1 . METHOD_2 ( command . VAR_2 ( ) ) ; VAR_1 . METHOD_3 ( command . getParameters ( ) ) ; } }
<|startcomment|> nm I misread diff I thought METHOD_1 ( ) called METHOD_4 ( ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , TYPE_4 VAR_3 ) { TYPE_5 VAR_4 = null ; String VAR_5 = VAR_6 . METHOD_2 ( VAR_1 , VAR_7 ) ; if ( VAR_5 != null ) { VAR_4 = TYPE_5 . METHOD_3 ( VAR_5 ) ; } if ( VAR_4 == null ) { VAR_4 = TYPE_5 . VAR_8 ; } <START> return METHOD_4 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; <END> }
<|startcomment|> null safe I suggest stringutils equalsignorecase start expression constant <|endcomment|> public boolean METHOD_1 ( ) { <START> return ( METHOD_2 ( TYPE_1 . VAR_2 ) . equalsIgnoreCase ( TYPE_2 . TYPE_3 . VAR_5 ) ) ; <END> }
<|startcomment|> works s hard read I readable return <|endcomment|> static Path METHOD_1 ( Path file , String VAR_1 ) { <START> return file == null ? null : ( file . VAR_2 ( ) ? file : ( file . VAR_3 ( ) . startsWith ( File . VAR_4 ) ? file . VAR_5 ( ) : ( TYPE_1 . get ( VAR_1 , <END> file . VAR_3 ( ) . toString ( ) ) ) ) ) ; }
<|startcomment|> s TYPE_2 VAR_3 include others TYPE_2 <|endcomment|> public void METHOD_1 ( Object listener ) { assert METHOD_2 ( ) . METHOD_3 ( ) ; TYPE_1 entry = new TYPE_1 ( listener , null ) ; <START> if ( TYPE_2 . VAR_1 && TYPE_2 . VAR_2 && TYPE_2 . VAR_3 ) { <END> String msg = new TYPE_3 ( ) . format ( STRING_1 , TYPE_4 . METHOD_4 ( ) , TYPE_5 . toString ( listener ) , TYPE_5 . toString ( this ) , getId ( ) ) . toString ( ) ; TYPE_2 . trace ( msg ) ; } VAR_4 . remove ( entry ) ; }
<|startcomment|> I smell incoming NPE <|endcomment|> private static void METHOD_1 ( TYPE_1 VAR_1 ) { String VAR_2 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_2 . isEmpty ( ) ) <END> { throw new TYPE_2 ( new TYPE_3 ( format ( STRING_1 , VAR_1 . getId ( ) ) ) ) ; } else if ( VAR_2 . trim ( ) . equals ( "" ) ) { throw new TYPE_2 ( new TYPE_3 ( format ( STRING_2 , VAR_1 . getId ( ) ) ) ) ; } }
<|startcomment|> call METHOD_1 ( path ) s <|endcomment|> public void METHOD_1 ( File path , String user , String VAR_1 ) throws IOException { <START> LOG . info ( STRING_1 , path ) ; <END> Path p = path . VAR_2 ( ) ; if ( TYPE_1 . exists ( p ) ) { try { TYPE_2 . METHOD_2 ( path ) ; } catch ( TYPE_3 VAR_3 ) { } } }
<|startcomment|> ( VAR_2 ! = VAR_1 ) <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 == null ) { <END> super . METHOD_1 ( VAR_1 ) ; } }
<|startcomment|> a couple thousand times slower : - ) keys rarely overlap VAR_1 creating a StringBuilder initialization cost amortized <|endcomment|> String METHOD_1 ( String name , Map < String , Map < String , String > > VAR_1 ) { StringBuilder builder = new StringBuilder ( name ) ; while ( VAR_1 . containsKey ( name ) ) { <START> builder . append ( STRING_1 ) ; <END> } VAR_1 . put ( builder . toString ( ) , new TYPE_1 < > ( ) ) ; return builder . toString ( ) ; }
<|startcomment|> a RuntimeException ? case don t want catch <|endcomment|> public synchronized void METHOD_1 ( ) { METHOD_2 ( ) ; File VAR_1 = VAR_2 . METHOD_3 ( ) ; try { if ( ! VAR_1 . METHOD_4 ( ) ) { TYPE_1 . METHOD_5 ( ) . METHOD_6 ( STRING_1 + VAR_1 . getName ( ) ) ; } <START> } catch ( TYPE_2 e ) { <END> TYPE_1 . METHOD_5 ( ) . METHOD_6 ( e . getMessage ( ) , e ) ; } }
<|startcomment|> replace method content super METHOD_1 ( VAR_1 ) ; underlying code METHOD_1 entity fire event <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( ) . remove ( VAR_1 ) ; <END> }
<|startcomment|> allow create class * * _CODE_ * * some * * METHOD_1 method * * override issue METHOD_1 final provide <|endcomment|> <START> public void METHOD_1 ( ) { <END> if ( VAR_1 == null ) { try { VAR_1 = VAR_2 . METHOD_2 ( TYPE_1 . class ) ; } catch ( TYPE_2 VAR_3 ) { if ( log . VAR_4 ( ) ) { log . debug ( STRING_1 ) ; } VAR_1 = METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; } } VAR_1 . METHOD_5 ( VAR_5 ) ; VAR_1 . METHOD_6 ( VAR_6 ) ; }
<|startcomment|> I find easier read ( ) <|endcomment|> public static void METHOD_1 ( TYPE_1 VAR_1 ) { Set < String > VAR_2 = new HashSet < String > ( ) ; for ( TYPE_2 item : VAR_1 . METHOD_2 ( ) ) { <START> String url = ( item . VAR_3 ( ) ) ? item . VAR_4 ( ) . METHOD_3 ( ) : null ; <END> if ( url != null ) { if ( VAR_2 . contains ( url ) ) { item . VAR_5 ( null ) ; } else { VAR_2 . add ( url ) ; } } } }
<|startcomment|> shouldn t changed super METHOD_1 ( ) <|endcomment|> protected void METHOD_1 ( ) { <START> super . METHOD_2 ( ) ; <END> METHOD_3 ( ) ; }
<|startcomment|> shouldn t loop release memory discarded arrays ? E g VAR_4 [ VAR_3 ] = null <|endcomment|> public int [ ] METHOD_1 ( int VAR_1 ) { int [ ] VAR_2 ; <START> while ( VAR_3 >= 0 && VAR_4 [ VAR_3 ] . length < VAR_1 ) { <END> VAR_5 -= METHOD_2 ( VAR_4 [ VAR_3 ] . length ) ; -- VAR_3 ; } if ( VAR_3 < 0 ) { VAR_2 = new int [ VAR_1 ] ; VAR_5 += METHOD_2 ( VAR_1 ) ; } else { VAR_2 = VAR_4 [ VAR_3 ] ; -- VAR_3 ; } ++ VAR_6 ; return VAR_2 ; }
<|startcomment|> I suspect want preserve order return a List <|endcomment|> <START> public Collection < TYPE_1 > METHOD_1 ( ) { <END> List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; VAR_1 . addAll ( METHOD_2 ( ) ) ; VAR_1 . addAll ( METHOD_3 ( ) ) ; return VAR_1 ; }
<|startcomment|> alias null <|endcomment|> public String METHOD_1 ( ) { <START> return getName ( ) + ( METHOD_2 ( ) == null ? "" : STRING_1 + METHOD_2 ( ) + STRING_2 ) ; <END> }
<|startcomment|> TYPE_2 thrown method ? return void throw TYPE_2 instead <|endcomment|> boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) <START> throws TYPE_2 { <END> if ( ! VAR_3 . METHOD_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_2 . METHOD_4 ( ) ) ) return false ; METHOD_5 ( VAR_3 ) ; return true ; }
<|startcomment|> protected bad allow - user mutate local property <|endcomment|> <START> public void METHOD_1 ( String VAR_1 ) { <END> this . VAR_1 = VAR_1 ; }
<|startcomment|> case file exist long ? a system a longer filename limit existing file worry length I <|endcomment|> protected String METHOD_1 ( TYPE_1 task , TYPE_2 < String > VAR_1 ) { String VAR_2 = TYPE_3 . METHOD_2 ( task . VAR_3 ( ) ) ; <START> if ( VAR_2 . length ( ) <= VAR_4 && VAR_1 . METHOD_3 ( VAR_2 ) ) { <END> return VAR_2 ; } String VAR_5 ; if ( METHOD_4 ( task . VAR_3 ( ) ) ) { VAR_5 = VAR_2 ; } else { VAR_5 = task . VAR_3 ( ) ; } return METHOD_5 ( VAR_5 ) ; }
<|startcomment|> extraction a variable ? I inlined : return client VAR_4 ( ) create ( METHOD_2 ( VAR_1 ) TYPE_3 VAR_6 ) METHOD_3 ( ) ; <|endcomment|> public boolean METHOD_1 ( String VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; try { TYPE_1 VAR_3 = METHOD_2 ( VAR_1 ) ; <START> return client . VAR_4 ( ) . create ( VAR_3 , TYPE_3 . VAR_6 ) . METHOD_3 ( ) ; <END> } catch ( Exception e ) { throw new TYPE_2 ( STRING_2 + VAR_1 , e ) ; } }
<|startcomment|> property <|endcomment|> public static TYPE_1 METHOD_1 ( ) { TYPE_1 properties = TYPE_2 . METHOD_1 ( ) ; <START> properties . VAR_1 ( TYPE_3 . VAR_3 , STRING_1 ) ; <END> return properties ; }
<|startcomment|> changed return ! command VAR_1 ( TYPE_3 VAR_6 ) ) <|endcomment|> protected boolean METHOD_1 ( TYPE_1 ctx , TYPE_2 command , Object key ) { if ( command . VAR_1 ( TYPE_3 . VAR_3 ) ) { return false ; } if ( ctx . VAR_4 ( ) ) { if ( ! command . VAR_5 ( ) ) { return false ; } <START> if ( command . VAR_1 ( TYPE_3 . VAR_6 ) ) { <END> return false ; } } else { if ( ! command . VAR_7 ( ) ) { return false ; } } return true ; }
<|startcomment|> ! [ MINOR ] ( severity : MINOR ) remove declaration thrown exception java io IOException thrown constructor s body [ ! [ rule ] ( ) ] ( ) <|endcomment|> public TYPE_6 ( TYPE_1 VAR_2 , Integer VAR_3 , TYPE_2 project , TYPE_3 VAR_4 , String VAR_5 , <START> TYPE_4 VAR_6 ) throws IOException { <END> super ( STRING_1 , TYPE_1 . class , STRING_2 , VAR_2 , VAR_3 ) ; if ( METHOD_1 ( ) && VAR_4 == null ) throw new TYPE_5 ( STRING_3 ) ; this . project = project ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; VAR_7 = VAR_2 . METHOD_2 ( ) ; }
<|startcomment|> VAR_5 return null <|endcomment|> public void METHOD_1 ( TYPE_1 id ) { VAR_1 . remove ( id . getKey ( ) ) ; VAR_2 . remove ( id . VAR_3 ( ) ) ; <START> VAR_4 . remove ( new TYPE_2 ( id . VAR_5 ( ) ) ) ; <END> }
<|startcomment|> create a VAR_1 getName ( ) delegates parameter <|endcomment|> public void METHOD_1 ( ) { for ( TYPE_1 VAR_1 : VAR_2 . METHOD_2 ( ) ) { <START> result . VAR_3 ( VAR_1 . METHOD_3 ( ) . getName ( ) , VAR_1 . getValue ( ) ) ; <END> } }
<|startcomment|> constructors set protected properties base class called super <|endcomment|> <START> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <END> }
<|startcomment|> move null check VAR_1 a level protect access METHOD_2 wdyt <|endcomment|> public void METHOD_1 ( ) { super . METHOD_1 ( ) ; VAR_1 . METHOD_2 ( METHOD_3 ( ) ) ; <START> if ( VAR_1 != null && VAR_1 . METHOD_4 ( ) ) { <END> VAR_1 . METHOD_5 ( ) ; } }
<|startcomment|> please remove redundant brackets ( _CODE_ ) <|endcomment|> protected Guid METHOD_1 ( ) { <START> if ( METHOD_2 ( ) != null && ( METHOD_3 ( ) ) ) { <END> return ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_1 ( ) ; } return null ; }
<|startcomment|> trace lines removed <|endcomment|> public TYPE_1 ( ) { <START> logger . trace ( STRING_1 ) ; <END> logger . trace ( STRING_2 , this ) ; }
<|startcomment|> I util obfuscates code <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_2 . getName ( ) ; this . VAR_4 = VAR_4 ; <START> VAR_6 = Utils . VAR_7 ( 1 ) ; <END> }
<|startcomment|> I dislike confuses / s templates special slash added a good opportunity future mistakes a case changing String format ( ) templates essentially varying numbers parameters String join ( ) <|endcomment|> public TYPE_3 ( final String VAR_2 , TYPE_1 VAR_3 ) { <START> this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 ) ? "" : VAR_2 + STRING_1 ; <END> this . VAR_3 = VAR_3 ; }
<|startcomment|> I more concise UNKNOWN_STATS <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( 0 , <START> new TYPE_2 ( VAR_2 , TYPE_3 . METHOD_3 ( ) ) , <END> new TYPE_2 ( VAR_3 , TYPE_3 . METHOD_3 ( ) ) ) ; TYPE_1 VAR_4 = METHOD_2 ( 0 , new TYPE_2 ( VAR_5 , TYPE_3 . METHOD_3 ( ) ) , new TYPE_2 ( VAR_6 , TYPE_3 . METHOD_3 ( ) ) ) ; METHOD_4 ( VAR_7 , VAR_1 , VAR_4 , VAR_1 ) ; }
<|startcomment|> didn t remove guava GWTP <|endcomment|> public Collection < TYPE_1 > METHOD_1 ( TYPE_2 input ) throws TYPE_3 { TYPE_4 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null ) { METHOD_3 ( VAR_1 ) ; commit ( VAR_1 ) ; METHOD_4 ( ) ; } else { METHOD_5 ( ) . debug ( STRING_1 ) ; } <START> return TYPE_5 . METHOD_6 ( METHOD_7 ( ) ) ; <END> }
<|startcomment|> üëçah a good reason picasso3 package long common names request API <|endcomment|> ANNOTATION_1 public void METHOD_1 ( ) { String [ ] VAR_1 = { STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , } ; for ( String VAR_2 : VAR_1 ) { final TYPE_1 uri = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) . build ( ) ; final Boolean VAR_3 = VAR_4 . METHOD_4 ( <START> TYPE_3 . METHOD_5 ( uri ) <END> ) ; assertThat ( VAR_3 ) . METHOD_6 ( ) ; } }
<|startcomment|> ( VAR_1 ! = null ) { TYPE_4 METHOD_3 ( ( ) - > METHOD_4 ( VAR_1 ) ) ; } <|endcomment|> public void METHOD_1 ( TYPE_1 session ) throws TYPE_2 { TYPE_3 VAR_1 = TYPE_4 . METHOD_2 ( TYPE_3 . class ) ; TYPE_4 . METHOD_3 ( ( ) - > { if ( VAR_1 != null ) { METHOD_4 ( VAR_1 ) ; } <START> } ) ; <END> }
<|startcomment|> finally <|endcomment|> public void METHOD_1 ( TYPE_1 context ) throws Exception { try { TYPE_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 , null ) ; <START> VAR_2 = null ; <END> } finally { super . METHOD_1 ( context ) ; } }
<|startcomment|> move null check action change behaviour <|endcomment|> public TYPE_1 < ? > METHOD_1 ( TYPE_2 command , long VAR_1 , TimeUnit VAR_2 ) { TYPE_3 . METHOD_2 ( VAR_2 , STRING_1 ) ; if ( VAR_1 < 0 ) { VAR_1 = 0 ; } METHOD_3 ( VAR_1 , VAR_2 ) ; return METHOD_1 ( new TYPE_4 < TYPE_5 > ( this , <START> TYPE_3 . METHOD_2 ( command , STRING_2 ) , <END> METHOD_4 ( VAR_2 . METHOD_5 ( VAR_1 ) ) ) ) ; }
<|startcomment|> I ( = = null ) return null a slightly deal <|endcomment|> public Integer METHOD_1 ( ) { Integer result = 0 ; try ( TYPE_1 in = cache . VAR_1 ( key ) ) { int read = 0 ; while ( ( read = in . read ( buffer ) ) != - 1 ) result = result + read ; return value = result ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; <START> } catch ( TYPE_2 e ) { <END> return null ; } }
<|startcomment|> check VAR_1 ! = null <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_1 event ) throws TYPE_2 { try { return METHOD_2 ( event , this ) ; } catch ( Exception error ) { Throwable VAR_1 = error . VAR_2 ( ) ; <START> if ( VAR_1 instanceof TYPE_3 && <END> VAR_1 . METHOD_3 ( ) instanceof TYPE_4 ) { throw ( ( TYPE_4 ) VAR_1 . METHOD_3 ( ) ) ; } else { throw error ; } } }
<|startcomment|> missing a ( ) getKey ( ) UUID key map TYPE_1 key object instance <|endcomment|> private static void METHOD_1 ( Map < String , List < TYPE_1 > > VAR_1 , List < TYPE_1 > VAR_2 , List < TYPE_1 > VAR_3 ) { if ( VAR_2 != null ) { for ( TYPE_1 c : VAR_2 ) { VAR_3 . add ( c ) ; <START> METHOD_1 ( VAR_1 , VAR_1 . get ( c . getKey ( ) ) , VAR_3 ) ; <END> } } }
<|startcomment|> logging buying ? need <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( STRING_1 , this ) ; <END> VAR_1 = null ; }
<|startcomment|> part redundant : byte [ ] class ! = obj getClass ( ) <|endcomment|> public boolean equals ( byte [ ] obj , Object VAR_1 ) { if ( obj == VAR_1 ) return true ; <START> if ( obj == null || byte [ ] . class != obj . getClass ( ) ) return false ; <END> if ( VAR_1 == null || byte [ ] . class != VAR_1 . getClass ( ) ) return false ; byte [ ] VAR_2 = obj ; byte [ ] VAR_3 = ( byte [ ] ) VAR_1 ; return Arrays . equals ( VAR_2 , VAR_3 ) ; }
<|startcomment|> private <|endcomment|> <START> public TYPE_2 ( TYPE_1 query , int VAR_2 ) { <END> this . query = query ; this . VAR_2 = VAR_2 ; }
<|startcomment|> don t push _CODE_ : : VAR_2 ? ( s deserialize invoked ) <|endcomment|> protected boolean METHOD_1 ( final TYPE_1 data ) { if ( data != null ) { try { <START> final Object VAR_1 = data . VAR_2 ( VAR_3 ) ; <END> } catch ( Throwable e ) { log . error ( STRING_1 , data . VAR_4 ( ) , data . VAR_5 ( ) , data . getType ( ) ) ; throw e ; } } return false ; }
<|startcomment|> reason disabling cache descending order queries <|endcomment|> public boolean METHOD_1 ( TYPE_1 query ) { <START> return ! query . VAR_1 ( ) && ! VAR_2 . contains ( query . getType ( ) ) ; <END> }
<|startcomment|> replace new code TYPE_3 equals ( resource VAR_2 ( ) ) <|endcomment|> public static boolean METHOD_1 ( TYPE_1 resource ) { if ( resource instanceof TYPE_2 ) { <START> String VAR_1 = resource . VAR_2 ( ) ; return VAR_1 != null && resource . VAR_2 ( ) . equals ( TYPE_3 ) ; <END> } return false ; }
<|startcomment|> change List < properties > API fixed <|endcomment|> <START> public TYPE_1 [ ] METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( new TYPE_1 [ VAR_1 . size ( ) ] ) ; }
<|startcomment|> need tests independent instance count zero <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { <START> VAR_1 = TYPE_3 . class . METHOD_2 ( STRING_1 ) ; <END> VAR_1 . METHOD_3 ( true ) ; VAR_2 = VAR_1 . getInt ( null ) ; VAR_3 = TYPE_4 . METHOD_4 ( TYPE_5 . class ) . create ( ) . get ( ) ; }
<|startcomment|> need ? s creating a circular dependency EMF TYPE_2 EMF depends TYPE_2 <|endcomment|> public static TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = TYPE_2 . METHOD_2 ( new TYPE_3 ( VAR_2 ) ) ; <END> } return VAR_1 ; }
<|startcomment|> don t System : ) <|endcomment|> public void METHOD_1 ( ) throws Exception { String VAR_1 = VAR_2 . METHOD_1 ( VAR_3 ) ; <START> System . out . println ( VAR_1 ) ; <END> TYPE_1 . METHOD_2 ( STRING_1 , VAR_1 ) ; TYPE_1 . METHOD_2 ( STRING_2 , VAR_1 ) ; TYPE_1 . METHOD_2 ( STRING_3 , VAR_1 ) ; }
<|startcomment|> instanceof nightmare <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) <START> { <END> TYPE_4 VAR_3 = VAR_1 . METHOD_2 ( VAR_2 ) ; return VAR_3 instanceof TYPE_1 ? ( TYPE_1 ) VAR_3 : null ; }
<|startcomment|> a protected method <|endcomment|> <START> public void METHOD_1 ( final TYPE_2 . TYPE_3 method ) { <END> this . method = method . VAR_1 ( ) ; this . id = method . getId ( ) ; }
<|startcomment|> multi return forbidden <|endcomment|> <START> public TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 instanceof TYPE_2 ) { return ( ( TYPE_2 ) VAR_1 ) . METHOD_1 ( ) ; } return new TYPE_1 ( ) ; }
<|startcomment|> VAR_1 METHOD_5 VAR_2 null initially logic a bit muddled <|endcomment|> private static synchronized TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_1 VAR_2 = VAR_3 . get ( VAR_1 . METHOD_2 ( ) ) ; if ( VAR_2 == null ) { VAR_2 = TYPE_4 . METHOD_3 ( STRING_1 ) ; VAR_3 . put ( VAR_1 . METHOD_2 ( ) , VAR_2 ) ; <START> } else if ( VAR_1 . METHOD_4 ( ) ) { <END> return null ; } else { VAR_1 . METHOD_5 ( new TYPE_5 ( ) ) ; return null ; } return VAR_2 ; }
<|startcomment|> declare VAR_2 a long <|endcomment|> public long METHOD_1 ( ) { <START> return ( long ) TYPE_1 . VAR_2 ; <END> }
<|startcomment|> CMAS severe alerts shouldn t METHOD_1 ( ) return VAR_6 ? spec severity extreme urgency expected <|endcomment|> private int METHOD_1 ( ) { switch ( VAR_1 ) { case TYPE_1 . VAR_3 : case TYPE_1 . VAR_4 : return TYPE_2 . VAR_6 ; case TYPE_1 . VAR_7 : <START> case TYPE_1 . VAR_8 : <END> case TYPE_1 . VAR_9 : case TYPE_1 . VAR_10 : case TYPE_1 . VAR_11 : case TYPE_1 . VAR_12 : return TYPE_2 . VAR_13 ; default : return TYPE_2 . VAR_14 ; } }
<|startcomment|> instead thowing return empty list <|endcomment|> public Collection < String > METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 { try { if ( VAR_1 != null ) return Collections . list ( VAR_1 . METHOD_2 ( ) ) ; } catch ( TYPE_3 e ) { throw new TYPE_2 ( STRING_1 , e ) ; } <START> throw new TYPE_2 ( STRING_1 , null ) ; <END> }
<|startcomment|> Type argument TYPE_1 need <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > result = new ArrayList < TYPE_1 > ( VAR_1 ) ; <END> result . add ( VAR_2 ) ; return result ; }
<|startcomment|> API private <|endcomment|> <START> public boolean METHOD_1 ( ) { <END> try { TYPE_1 VAR_1 = context . VAR_2 ( ) . METHOD_2 ( context . VAR_3 ( ) , TYPE_6 . VAR_5 ) ; for ( TYPE_2 VAR_6 : VAR_1 . VAR_7 ) { if ( VAR_6 . name . equals ( TYPE_3 . class . getName ( ) ) ) { return true ; } } } catch ( TYPE_4 e ) { TYPE_5 . e ( TAG , STRING_1 , e ) ; } return false ; }
<|startcomment|> noted commit public testing <|endcomment|> <START> public List < TYPE_1 > METHOD_1 ( ) { <END> return new ArrayList < TYPE_1 > ( VAR_1 . VAR_2 ) ; }
<|startcomment|> I don t sense trace null shouldn t create a new message file case <|endcomment|> public TYPE_1 METHOD_1 ( String path ) { if ( VAR_1 == null ) { <START> return new Status ( TYPE_1 . VAR_2 , TYPE_2 . VAR_4 , Messages . TYPE_3 ) ; <END> } return VAR_1 . METHOD_1 ( null , path ) ; }
<|startcomment|> wondering worth putting VAR_2 = = VAR_3 check a short - circuiting efficiency improvement <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { int VAR_2 = TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> return METHOD_3 ( VAR_1 ) && VAR_2 == VAR_3 ; <END> }
<|startcomment|> < code > ! = < / code > correct <|endcomment|> private TYPE_1 METHOD_1 ( ) throws InterruptedException , IOException { TYPE_1 result ; <START> while ( ( result = METHOD_2 ( ) ) != null ) { <END> Thread . VAR_1 ( INT_1 ) ; } return result ; }
<|startcomment|> missing VAR_1 close ( ) <|endcomment|> public void METHOD_1 ( ) throws IOException , TYPE_1 { TYPE_2 reader = new TYPE_2 ( ) ; TYPE_3 VAR_1 = new TYPE_3 ( reader ) ; assertNotNull ( VAR_1 . METHOD_2 ( ) ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; assertNotNull ( VAR_1 . METHOD_2 ( ) ) ; <START> } <END>
<|startcomment|> rid variables place <|endcomment|> public void METHOD_1 ( ) { <START> String VAR_1 = STRING_1 ; <END> int VAR_2 = 1 ; TYPE_1 VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; assertEquals ( VAR_2 , ( int ) VAR_3 . getId ( ) ) ; }
<|startcomment|> I don t logic necessary default visibility VAR_3 <|endcomment|> public void METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) { VAR_2 . METHOD_2 ( VAR_3 ) ; } else { VAR_2 . METHOD_2 ( VAR_4 ) ; <START> VAR_5 . setText ( VAR_1 ) ; <END> } }
<|startcomment|> protected <|endcomment|> <START> public TYPE_1 <END> METHOD_1 ( ) { return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> public interface <|endcomment|> <START> void start ( ) { <END> if ( ! VAR_1 ) { log . info ( STRING_1 ) ; VAR_2 . execute ( new TYPE_1 ( ) ) ; } VAR_1 = true ; }
<|startcomment|> new ArrayList < > ( <|endcomment|> public TYPE_1 ( String VAR_2 ) { <START> this . VAR_2 = new ArrayList < > ( Arrays . asList ( VAR_2 . split ( STRING_1 ) ) ) ; <END> }
<|startcomment|> Double volatile read rid VAR_4 <|endcomment|> public long METHOD_1 ( ) throws TYPE_1 { long VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; <START> long VAR_4 = VAR_5 ; <END> if ( VAR_1 > VAR_4 ) { METHOD_3 ( VAR_1 ) ; } VAR_6 . METHOD_4 ( ) ; return VAR_1 ; }
<|startcomment|> please remove line <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> this . VAR_4 = new TYPE_3 < > ( VAR_2 ) ; <END> this . VAR_5 = new TYPE_3 < > ( VAR_3 ) ; }
<|startcomment|> a - dunlap please update docs : TYPE_4 thanks <|endcomment|> public Response METHOD_1 ( ANNOTATION_1 ( STRING_1 ) String VAR_1 ) { return METHOD_2 ( response ( req - > METHOD_3 ( METHOD_4 ( METHOD_5 ( new TYPE_1 ( req , METHOD_6 ( VAR_1 ) ) ) , false , <START> VAR_2 . METHOD_7 ( TYPE_3 . TYPE_2 . TYPE_4 , false ) <END> ) ) ) ) ; }
<|startcomment|> super ( id ( ) ) ? some other places [ 1 ] provide decoded id TYPE_2 ( String ) shouldn t places decoded id VAR_2 id ? [ 1 ] <|endcomment|> public TYPE_2 ( TYPE_1 id ) { <START> super ( id . VAR_2 ( ) ) ; <END> }
<|startcomment|> TYPE_1 < ? > VAR_1 = ( TYPE_1 < ? > ) METHOD_1 ( ) ; sense ( VAR_1 instanceof TYPE_1 ) <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 instanceof TYPE_3 ) { VAR_1 = ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) ; <START> if ( VAR_1 instanceof TYPE_1 ) { <END> return ( TYPE_1 ) VAR_1 ; } } throw new TYPE_4 ( STRING_1 ) ; }
<|startcomment|> forgot revert <|endcomment|> public void METHOD_1 ( final File VAR_1 , final double VAR_2 ) throws IOException { TYPE_1 VAR_3 = TYPE_2 . read ( VAR_1 ) ; File VAR_4 = File . VAR_5 ( STRING_1 , STRING_2 ) ; TYPE_2 . write ( VAR_3 , STRING_3 , VAR_4 ) ; <START> METHOD_1 ( TYPE_2 . read ( VAR_4 ) , VAR_2 ) ; <END> }
<|startcomment|> good catch I spotted a other log messages _CODE_ attribued clearer remove _CODE_ _CODE_ prefix I <|endcomment|> public TYPE_1 METHOD_1 ( ) { try { return VAR_1 != null ? new TYPE_1 ( VAR_1 ) : null ; } catch ( TYPE_2 e ) { if ( TYPE_3 . logger . METHOD_2 ( ) ) { <START> TYPE_3 . logger . METHOD_3 ( STRING_1 , <END> METHOD_4 ( ) , e . getMessage ( ) ) ; } return null ; } }
<|startcomment|> redundant logging current user base class <|endcomment|> public void METHOD_1 ( TYPE_1 method ) throws Exception { logger . info ( STRING_1 + method . getName ( ) ) ; <START> TYPE_2 . METHOD_2 ( TYPE_5 . VAR_2 ) ; <END> VAR_3 [ 0 ] = TYPE_3 . METHOD_3 ( ) [ 0 ] [ 0 ] ; VAR_3 [ 0 ] = new TYPE_4 ( VAR_3 [ 0 ] , cluster . VAR_4 ( ) , cluster . VAR_5 ( ) ) ; VAR_3 [ 0 ] . METHOD_4 ( ) ; VAR_3 [ 0 ] . METHOD_5 ( VAR_6 ) ; }
<|startcomment|> reason check view <|endcomment|> public View METHOD_1 ( ) { View view = METHOD_2 ( ) . METHOD_3 ( R . id . VAR_1 ) ; <START> return METHOD_2 ( ) ; <END> }
<|startcomment|> I thought catch exception call close ( ) rethrow <|endcomment|> public List < TYPE_1 > METHOD_1 ( List < TYPE_2 > VAR_1 ) throws IOException { if ( VAR_2 ) { throw new IllegalStateException ( STRING_1 ) ; } List < TYPE_1 > VAR_3 = new ArrayList < TYPE_1 > ( ) ; for ( TYPE_2 VAR_4 : VAR_1 ) { VAR_5 . add ( new TYPE_3 ( time . VAR_6 ( ) , VAR_4 , null ) ) ; } List < TYPE_4 > VAR_7 = METHOD_2 ( VAR_3 ) ; VAR_8 . METHOD_3 ( VAR_9 , VAR_7 ) ; METHOD_4 ( VAR_3 ) ; <START> return VAR_3 ; <END> }
<|startcomment|> I enums = = / ! = operators s a matter style I prefer ( instance enum referenced entity enum constant ) fine <|endcomment|> public void METHOD_1 ( ) { VAR_1 = false ; TYPE_1 VAR_2 = ( TYPE_1 ) TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; if ( VAR_2 != null <START> && TYPE_6 . TYPE_7 . equals ( VAR_2 . getType ( ) ) ) { <END> TYPE_4 VAR_3 = ( TYPE_4 ) VAR_2 . METHOD_4 ( ) ; if ( ! TYPE_8 . TYPE_9 . equals ( VAR_3 . METHOD_5 ( ) ) ) { VAR_1 = true ; } } METHOD_6 ( ) ; }
<|startcomment|> shouldn t force put ? returned s cache s doesn t matter <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( String name ) { TYPE_2 VAR_1 = VAR_2 . get ( name ) ; if ( VAR_1 != null ) { return TYPE_1 . METHOD_2 ( VAR_1 ) ; } return VAR_3 . METHOD_1 ( name ) . METHOD_3 ( ( VAR_4 ) - > { VAR_2 . METHOD_4 ( name , null ) ; return null ; } ) <START> . METHOD_5 ( ( file ) - > { VAR_2 . METHOD_4 ( name , file ) ; return file ; } ) ; <END> }
<|startcomment|> _CODE_ supports a similar server - side SSL_OP_NO_TICKET page : <|endcomment|> public void METHOD_1 ( ) throws Throwable { METHOD_2 ( TYPE_1 . METHOD_3 ( ) ) ; <START> METHOD_2 ( TYPE_1 . METHOD_4 ( ) ) ; <END> METHOD_5 ( TYPE_2 . VAR_2 , false ) ; }
<|startcomment|> a _CODE_ static ( doesn t run ) I wondering passed hudson remembered perf tests don t run <|endcomment|> <START> public void METHOD_1 ( ) { <END> TYPE_1 . METHOD_2 ( new TYPE_2 ( ) ) ; TYPE_1 . METHOD_2 ( new TYPE_3 ( ) ) ; }
<|startcomment|> more sense mark VAR_1 parameter _CODE_ instead checking <|endcomment|> protected void METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 != null ) { <END> TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) ; METHOD_4 ( VAR_2 . METHOD_5 ( METHOD_6 ( ) , VAR_1 ) ) ; } }
<|startcomment|> I d throw exception <|endcomment|> public static int METHOD_1 ( Object key , TYPE_1 cache ) { TYPE_2 VAR_1 = METHOD_2 ( cache , TYPE_2 . class ) ; if ( VAR_1 != null ) { return VAR_1 . METHOD_3 ( key ) ; } <START> return TYPE_3 . VAR_3 ; <END> }

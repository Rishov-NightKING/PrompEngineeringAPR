<|startcomment|> I think LIBRARY are no more used <|endcomment|> private static Set<String> getRootQualifiers(ResourceTypes resourceTypes) { return resourceTypes.getRoots().stream() .map(ResourceType::getQualifier) <START> .filter(q -> !DEPRECATED_QUALIFIERS.contains(q)) <END> .collect(Collectors.toCollection(TreeSet::new)); }
<|startcomment|> Consider using `System.lineSeparator()` instead. <|endcomment|> public RuntimeFilterManager(QueryWorkUnit workUnit, DrillbitContext drillbitContext) { this.rootWrapper = workUnit.getRootWrapper(); this.drillbitContext = drillbitContext; <START> lineSeparator = java.security.AccessController.doPrivileged(new sun.security.action.GetPropertyAction("line.separator")); <END> }
<|startcomment|> ChangeDetailEditor_EGerriTipValue has no more arguments, should we just use it directly , no need to set the arguments ? <|endcomment|> private void activateMarkers() { if (!fGerritClient.getRepository().getServerInfo().isAnonymous()) { String value = NLS.bind(Messages.ChangeDetailEditor_EGerriTipValue, <START> fChangeInfo.getUserSelectedRevision().get_number()); <END> UIUtils.showDialogTip(MARKERS_KEY, headerSection.getShell(), Messages.EGerriTip, value); } }
<|startcomment|> should be called `resource` <|endcomment|> public void testCreate() throws StripeException { Map<String, Object> params = new HashMap<String, Object>(); params.put("currency", "usd"); final Order order = Order.create(params); assertNotNull(order); verifyRequest( APIResource.RequestMethod.POST, <START> "/v1/orders", <END> params ); }
<|startcomment|> Just `return rule`. <|endcomment|> private FirewallRule findById(List<FirewallRule> collection, String id) { FirewallRule result = null; for (FirewallRule rule : collection) { if (rule.id().equals(id)) { <START> result = rule; <END> } } return result; }
<|startcomment|> Should probably use a Set<String> instead of a List<String> so that the intention of the code is clear by first glance. <|endcomment|> public void addDownload(String download){ <START> if(!downloads.contains(download)) { <END> downloads.add(download); } }
<|startcomment|> Should this be 1 or null instead of 0? <|endcomment|> public void copyDetailsFromOtherCuObjectCodeActivationGlobal(CuObjectCodeActivationGlobal oldGlobal) { for (CuObjectCodeGlobalDetail oldDetail : oldGlobal.getObjectCodeGlobalDetails()) { CuObjectCodeGlobalDetail newDetail = (CuObjectCodeGlobalDetail) ObjectUtils.deepCopy(oldDetail); newDetail.setObjectId(null); newDetail.setDocumentNumber(getDocumentNumber()); <START> newDetail.setVersionNumber(new Long(0)); <END> getObjectCodeGlobalDetails().add(newDetail); } }
<|startcomment|> You can not be sure that the value is present in the local storage (see the storeVncData). Please wrap the ...valueOf(...) by try-catch <|endcomment|> private void loadVncData(HasConsoleModel model, KeyMaker keyMaker) { if (!(model.getDefaultConsoleModel() instanceof VncConsoleModel)) { return; } model.setSelectedProtocol(ConsoleProtocol.VNC); asVncConsoleModel(model).setVncImplementation(VncConsoleModel.ClientConsoleMode <START> .valueOf(clientStorage.getLocalItem(keyMaker.make(VNC_CLIENT_MODE)))); <END> }
<|startcomment|> These arguments can all go on the same line <|endcomment|> private RuleApplication applyRule() { SymbolAllocator symbolAllocator = new SymbolAllocator(symbols); Memo memo = new Memo(idAllocator, plan); Lookup lookup = Lookup.from(memo::resolve); Optional<PlanNode> result = inTransaction(session -> rule.apply(memo.getNode(memo.getRootGroup()), lookup, idAllocator, symbolAllocator, session)); <START> return new RuleApplication( <END> memo, lookup, symbolAllocator.getTypes(), result); }
<|startcomment|> Why the expected output was changed? <|endcomment|> public void testPushDownArray() throws Exception { testParquetFilterPushDown("t.`user`.hobby_ids[0] = 1", 3, 2); testParquetFilterPushDown("t.`user`.hobby_ids[0] = 100", 0, 1); <START> testParquetFilterPushDown("t.`user`.hobby_ids[0] <> 1", 8, 7); <END> testParquetFilterPushDown("t.`user`.hobby_ids[2] > 20", 5, 4); testParquetFilterPushDown("t.`user`.hobby_ids[0] between 10 and 20", 5, 5); testParquetFilterPushDown("t.`user`.hobby_ids[4] = 15", 1, 3); testParquetFilterPushDown("t.`user`.hobby_ids[2] is not null", 11, 6); testParquetFilterPushDown("t.`user`.hobby_ids[3] is null", 11, 7); }
<|startcomment|> This logic should be in the default implementation. <|endcomment|> default Direction getBubbleElevatorDirection() { Block block = this.getBlockState().getBlock(); if (block == Blocks.BUBBLE_COLUMN) { <START> return this.getBlockState().get(BubbleColumnBlock.DRAG) ? Direction.DOWN : Direction.UP; <END> } else { return block.getBubbleElevatorDirection(this.getBlockState()); } }
<|startcomment|> Why access this method staticly? <|endcomment|> public void testSystemPropertiesOverrideConfigurationValues() { final String keyName = CoreConfig.MAX_CASSANDRA_CONNECTIONS.toString(); Configuration config = Configuration.getInstance(); try { Assert.assertEquals("75", config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS)); System.setProperty(keyName, "something else"); Assert.assertEquals("something else", config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS)); } finally { System.clearProperty(keyName); <START> Configuration.clearProperty(keyName); <END> } }
<|startcomment|> You can set it on a plain field, no need for atomics: ``` java this.inner = inner; o.onSubscribe(this); inner.request(Long.MAX_VALUE); ``` <|endcomment|> public void onSubscribe(Subscription inner) { <START> SubscriptionHelper.setOnce(this, inner); <END> o.onSubscribe(this); inner.request(Long.MAX_VALUE); }
<|startcomment|> `true` -> `false` ? <|endcomment|> public WebElement forElementPresent(By by) { changeImplicitWait(250, TimeUnit.MILLISECONDS); try { return wait.until(ExpectedConditions.presenceOfElementLocated(by)); } catch(TimeoutException e) { PageObjectLogging.log( ELEMENT_PRESENT_MESSAGE, String.format(ELEMENT_PRESENT_ERROR_FORMAT, by.toString()), <START> true <END> ); throw e; } finally { restoreDeaultImplicitWait(); } }
<|startcomment|> could be simplified. <|endcomment|> public boolean accept(Issue issue) { <START> if (issueShouldNotBeReported(issue, excludedLinesByRule())) { <END> return false; } return true; }
<|startcomment|> this method should be changed to private <|endcomment|> <START> public HashMap<String, <END> ArrayList<Order>> getBuyOrders() { return buyOrders; }
<|startcomment|> There's no need to make these public, even if the package is internal. <|endcomment|> <START> public static <END> Color getSystemForegroundColor(Display display) { ColorRegistry colorRegistry = JFaceResources.getColorRegistry(); Color foreground = colorRegistry.get(JFacePreferences.INFORMATION_FOREGROUND_COLOR); if (foreground == null) { return JFaceColors.getInformationViewerForegroundColor(display); } return foreground; }
<|startcomment|> You should go one step more in simplifying the rule: Change this method to return a boolean: `hasNoDefault(switchStatementTree)` ``` return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault); ``` <|endcomment|> public void visitNode(Tree tree) { if (!hasSemantic()) { return; } SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree; <START> Optional<CaseLabelTree> defaultLabel = getDefaultLabel(switchStatementTree); <END> if (!defaultLabel.isPresent()) { if (!isSwitchOnEnum(switchStatementTree)) { reportIssue(switchStatementTree.switchKeyword(), "Add a default case to this switch."); } else if (missingCasesOfEnum(switchStatementTree)) { reportIssue(switchStatementTree.switchKeyword(), "Complete cases by adding the missing enum constants or add a default case to this switch."); } } }
<|startcomment|> This method should be synchronized, otherwise, chances are eventually there might be a race condition for setting fAttribute. <|endcomment|> <START> public String getAttribute() { <END> if (fAttribute.equals(NOT_SET)) { setAttribute(); } return fAttribute; }
<|startcomment|> ![BLOCKER](https://sonarsource.github.io/sonar-github/severity-blocker.png 'Severity: BLOCKER') Move this "start" call to another method. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3AS2693) <|endcomment|> public DotRunnableThread(final List<DotRunnable> allListeners) { this.listeners = getListeners(allListeners); this.flushers = getFlushers(allListeners); <START> this.networkCacheFlushThread.start(); <END> }
<|startcomment|> style nit: no braces around single line blocks <|endcomment|> private void createIndex() { lastFoundElementPosition = 0; filteredPlan.clear(); for (PlanElement element : plan.getList()) { <START> if (!element.isComment()) { <END> filteredPlan.add(element); } } }
<|startcomment|> is there a difference between parallelStream() and entryStream().parallel() ? <|endcomment|> public Collection<Map.Entry<K, V>> scanAndFilterByEntry( Predicate<? super Map.Entry<K, V>> entryPredicate) { <START> return mainMap.entryStream().parallel() <END> .filter(entryPredicate) .collect(Collectors.toCollection(ArrayList::new)); }
<|startcomment|> can be `private`? or at least package protected access? <|endcomment|> <START> protected boolean isValidChar(final char c) { <END> return isValidChar(regExp, c); }
<|startcomment|> Toni, could we please choose better variable names here? `equals` and `equals1` do not say much for newcomer to the codebase. Or we could avoid storing partial results by: ```java if(!Objects.equals(editorPlaceRequest, event.getPlace())) { return false; } if (!Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier())) { return false; } return true; ``` Please let me know what do you think. <|endcomment|> public boolean verifyEventIdentifier(AbstractPlaceEvent event) { boolean equals = Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier()); boolean equals1 = Objects.equals(editorPlaceRequest, event.getPlace()); return (equals && <START> equals1); <END> }
<|startcomment|> It's an obvious code duplication. We can save this new request with a modified URI into `this.request`, and use it in all methods. This is how it works in other classes, take a look <|endcomment|> public void star() throws IOException { this.entry.uri() <START> .path(RtGist.PATH_ELEMENT_STAR).back().method("PUT") <END> .fetch().as(RestResponse.class) .assertStatus(HttpURLConnection.HTTP_NO_CONTENT); }
<|startcomment|> What is the need to make `issueArticles` nullable? It would be easier to understand this view class if we required it. If that's totally impractical, we should consider having a separate view class to capture the difference. <|endcomment|> public IssueOutputView(Issue issue) { <START> this(issue, null, null); <END> }
<|startcomment|> not 100% sure, but this breaks binary compatibility, right? <|endcomment|> <START> public ProcessEngineConfiguration setDefaultNumberOfRetries(int defaultNumberOfRetries) { <END> this.defaultNumberOfRetries = defaultNumberOfRetries; return this; }
<|startcomment|> The Exception is never thrown. <|endcomment|> <START> public void testSequenceFlowSupplier() throws Exception { <END> final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent, candidate, index, originalParent, originalIndex); final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier(); final ViewConnector<SequenceFlow> viewConnector = supplier.get(); assertNotNull(viewConnector); assertNotNull(viewConnector.getSourceConnection()); assertNotNull(viewConnector.getTargetConnection()); assertNotNull(viewConnector.getBounds()); assertNotNull(viewConnector.getDefinition()); }
<|startcomment|> instead of an early assignment which might be overridden in line 2355, it can be set as the 'else' part of the if statement below (line 2356). <|endcomment|> public long getSessionSeqId() { if (sessionSeqId == null) { <START> sessionSeqId = -1L; <END> String sessionId = getContext().getEngineContext().getSessionId(); // The session may not exists for quartz jobs if (getSessionDataContainer().isSessionExists(sessionId)) { sessionSeqId = getSessionDataContainer().getEngineSessionSeqId(sessionId); } } return sessionSeqId; }
<|startcomment|> Allocate write ID is a DB/table related event and should be ignored if not lookup on this DB/table. <|endcomment|> private boolean isTxnRelatedEvent(final NotificationEvent event) { return ((event.getEventType().equals(MessageFactory.OPEN_TXN_EVENT)) || (event.getEventType().equals(MessageFactory.COMMIT_TXN_EVENT)) || (event.getEventType().equals(MessageFactory.ABORT_TXN_EVENT)) || <START> (event.getEventType().equals(MessageFactory.ALLOC_WRITE_ID_EVENT)) <END> ); }
<|startcomment|> Can't we have this static flag on FS instead? Then we wouldn't need to make FileStoreAttributeCache public. <|endcomment|> public static void setBackground(boolean async) { background = async; <START> } <END>
<|startcomment|> For a small maximuSize, like 1, it may be more reasonable to check for: map.size() > maximumSize <|endcomment|> public V put(@NonNull K key, @NonNull V value) { map.put(key, new Entry<>(key, value, ++time)); <START> if (map.size() >= maximumSize) { <END> purge(); } return value; }
<|startcomment|> Shouldn't do this line - it's handled by the ...Optionally... bit in the Encr class. https://github.com/pentaho/pentaho-kettle/blob/master/core/src/org/pentaho/di/core/encryption/KettleTwoWayPasswordEncoder.java#L86-L91 <|endcomment|> private static void setIfNotNullOrEmpty( MongoProperties.Builder builder, MongoProp prop, String value ) { if ( value != null && value.trim().length() > 0 ) { boolean isPassword = MongoProp.PASSWORD.equals( prop ); <START> boolean isEncrypted = value.startsWith( Encr.PASSWORD_ENCRYPTED_PREFIX ); <END> if ( isPassword && isEncrypted ) { value = Encr.decryptPasswordOptionallyEncrypted( value ); } builder.set( prop, value ); } }
<|startcomment|> One use/test case is, a non-serializable pojo (user type) that is encoded as a UTF-8 byte[ ] with some string representation of it. <|endcomment|> public Mutation toMutation(K key) { <START> V valueFromStorage = (V) valueDataConversion.fromStorage(value); <END> return new Mutations.ReadWriteWithValue<>(valueFromStorage, f); }
<|startcomment|> IMHO it does not need to be public <|endcomment|> <START> public Entry(Map.Entry<String,String> e) { <END> this(e.getKey(), e.getValue()); }
<|startcomment|> parts[1].isEmpty <|endcomment|> private String parsePath() throws URISyntaxException { String[] parts = uri.split("\\?")[0].split(":", 2); <START> if (parts.length < 2 || parts[1].length() < 1) throw new URISyntaxException(uri, "invalid path"); <END> else return parts[1]; }
<|startcomment|> this will affect the sorting also on the webadmin - but on webadmin we support sortable columns. Please move this logic to UserPortalTemplateListModel. <|endcomment|> public void setItems(Collection value) { genVersionToBaseTemplate(value); <START> final List<VmTemplate> sortedValues = sortTemplates(value); <END> super.setItems(sortedValues); }
<|startcomment|> why you need this line? table.setRowData(new ArrayList<ListModel>()); <|endcomment|> public void edit(VolumeBrickModel object) { <START> table.setRowData(new ArrayList<ListModel>()); <END> table.edit(object.getBricks()); Driver.driver.edit(object); }
<|startcomment|> `return quickFilters` <|endcomment|> public List<QuickFilter> getQuickFilters() { <START> return this.quickFilters; <END> }
<|startcomment|> why not directly assertEquals(LOW, fCondition.min()); ? <|endcomment|> public void testBounds() { int low = fCondition.min(); <START> assertEquals(LOW, low); <END> int high = fCondition.max(); assertEquals(HIGH, high); }
<|startcomment|> `this` is redundant here. <|endcomment|> public String weather() { <START> String result = this.restTemplate.getForObject("http://" + WEATHER_SERVICE + "/weather", String.class); <END> return "Weather Service Response: " + result; }
<|startcomment|> Let's move this into an EnablementTester.evaluate(...) method. <|endcomment|> public boolean isExtensionEnabled() { if (enablement != null) { try { <START> return enablement.getExpression().evaluate(new EvaluationContext(null, new Object())) <END> .equals(EvaluationResult.TRUE); } catch (CoreException e) { // TODO: handle exception } } return true; }
<|startcomment|> 'null' must be first operande <|endcomment|> public ProviderNotificationManager createProviderNotificationManager(final DiagramEventBroker diagramEventBroker, final EObject view, final NotificationListener notificationListener) { <START> if (manager != null) { <END> return manager; } manager = new ProviderNotificationManager(diagramEventBroker, view, notificationListener) { @Override protected void registerListeners() { // TODO install listener on allocation(Abstraction) of the model. } }; return manager; }
<|startcomment|> This method can be`private`. <|endcomment|> <START> public void startSyncFolderOperation(OCFile folder) { <END> long currentSyncTime = System.currentTimeMillis(); mSyncInProgress = true; // perform folder synchronization RemoteOperation synchFolderOp = new RefreshFolderOperation( folder, currentSyncTime, false, false, false, getStorageManager(), getAccount(), getApplicationContext() ); synchFolderOp.execute(getAccount(), this, null, null); }
<|startcomment|> This can be private again. <|endcomment|> <START> public static ProtobufMetadataManagerImpl getProtobufMetadataManager(EmbeddedCacheManager cacheManager) { <END> if (cacheManager == null) { throw new IllegalArgumentException("cacheManager cannot be null"); } ProtobufMetadataManagerImpl metadataManager = (ProtobufMetadataManagerImpl) cacheManager.getGlobalComponentRegistry().getComponent(ProtobufMetadataManager.class); if (metadataManager == null) { throw new IllegalStateException("ProtobufMetadataManager not initialised yet!"); } return metadataManager; }
<|startcomment|> Should this log message be before or after we actually do update the session key? <|endcomment|> public void onSessionKeyUpdate(SessionKey sessionKey) { <START> log.info("Session key updated"); <END> synchronized (DistributedHerder.this) { DistributedHerder.this.sessionKey = sessionKey.key(); if (isLeader() && keyRotationIntervalMs > 0) { DistributedHerder.this.keyExpiration = sessionKey.creationTimestamp() + keyRotationIntervalMs; } } }
<|startcomment|> forgotten line of code? <|endcomment|> public String getAuthorizationUrl(OAuthConfig config) { <START> System.out.print("Authorisation URL: "); <END> // User must provide these 5 elements to the service builder String url = String.format(AUTHORIZE_URL, OAuthEncoder.encode(config.getApiKey()), OAuthEncoder.encode(config.getCallback()), OAuthEncoder.encode(config.getScope()), OAuthEncoder.encode(config.getState())); return url; }
<|startcomment|> This code here should be inside the if, because we don't need to do anything if the parameter request is not PARAM_WORKER <|endcomment|> public Object getParameter(String name) { <START> final HostThread currentHostThread = fCurrentHostThread; <END> if (currentHostThread == null) { return null; } if (name.equals(CriticalPathModule.PARAM_WORKER)) { /* Try to find the worker for the critical path */ IAnalysisModule mod = getModule(); if ((mod != null) && (mod instanceof CriticalPathModule)) { LttngWorker worker = new LttngWorker(currentHostThread, "", 0); //$NON-NLS-1$ return worker; } return currentHostThread; } return null; }
<|startcomment|> Maybe `expectThrowable` for consistency? <|endcomment|> public static ExceptionThrowingSubTest expectThrowable(Runnable runnable) { <START> return expectException( runnable.toString(), runnable ); <END> }
<|startcomment|> remove this <|endcomment|> protected CONNECTCXFClient(ServicePortDescriptor<T> portDescriptor, String url, AssertionType assertion, ServicePortBuilder<T> portBuilder) { serviceEndpoint = super.configureBasePort(portBuilder.createPort(), url, assertion != null ? assertion.getTransactionTimeout() : null); <START> configCNCheck(); <END> }
<|startcomment|> Can we add the name of the setting in there somewhere as well? <|endcomment|> public <V> Setting<V> get(SimpleUri id, Class<V> valueType) { Setting setting = settings.get(id); Class settingValueClass = setting.getValueClass(); if (!settingValueClass.equals(valueType)) { throw new ClassCastException( "Expected a Setting of type " + valueType.getName() + ", found a Setting of type " + settingValueClass.getName() <START> ); <END> } return (Setting<V>) setting; }
<|startcomment|> it's better to init customFields with an empty collection to avoid "==null" <|endcomment|> public String getCustomField(String fieldName) { <START> if(customFields == null) return null; <END> for (CustomField f : customFields) { if (f.getName().equals(fieldName)) { return f.getValue(); } } return null; }
<|startcomment|> Any way we can clean this up? It seems to only be needed for example commands, but hard to check what the command is here since it's wrapped in decorators. <|endcomment|> private CommandCall duplicateCommandForDifferentElement(CommandCall commandCall, Element element) { String expression = commandCall.getExpression(); <START> if (expression.equals("")) { <END> expression = element.getText(); } return new CommandCall(null, commandCall.getCommand(), element, expression, commandCall.getResource()); }
<|startcomment|> TException is throwable, too, and treated the same -- combine the catch clauses? <|endcomment|> public M fromBytes(byte[] messageBuffer) { if (deserializer == null) deserializer = new ThriftBinaryDeserializer(); try { M message = typeRef.safeNewInstance(); deserializer.deserialize(message, messageBuffer); return message; } catch (TException e) { logWarning("failed to deserialize", e); return null; <START> } catch (Throwable e) { <END> // Arbitrary bytes can cause a runtime exception in Thrift logWarning("failed to deserialize", e); return null; } }
<|startcomment|> remove <|endcomment|> public void showPage(Control page) { if (page.isDisposed() || page.getParent() != this) { return; } currentPage = page; // show new page page.setVisible(true); layout(true); // hide old (and all others) *after* new page has been made visible in // order to avoid flashing Control[] children = getChildren(); for (Control element : children) { <START> Control child = element; <END> if (child != page && !child.isDisposed()) { child.setVisible(false); } } }
<|startcomment|> info vs warn <|endcomment|> public void info(String message, Object... objects) { <START> LOG.warn(message, objects); <END> }
<|startcomment|> Let's avoid `null` and rework to empty string <|endcomment|> public String getLinkAt(int offset) { // Check if there is a link at the offset for (int i = 0; i < linkRanges.size(); i++) { if (linkRanges.get(i).isOffsetInRange(offset)) { return hrefs.get(i); } } <START> return null; <END> }
<|startcomment|> This change I requested was supposed to remove the need for a read lock <|endcomment|> public String toString() { readLock.lock(); try { <START> return "FileListCacheValue{fileNames=" + getFileNames() + "}"; <END> } finally { readLock.unlock(); } }
<|startcomment|> Please not here. This is not a standard SWT table. <|endcomment|> protected Control createControl(Composite parent) { // Configure table CTConfiguration config = new CTConfiguration(parent, CTConfiguration.STYLE_GRID); config.setHorizontalAlignment(SWT.CENTER); config.setCellSelectionEnabled(false); config.setColumnSelectionEnabled(false); config.setRowSelectionEnabled(false); config.setColumnHeaderLayout(CTConfiguration.COLUMN_HEADER_LAYOUT_FILL_EQUAL); config.setRowHeaderLayout(CTConfiguration.ROW_HEADER_LAYOUT_DEFAULT); <START> this.table = new ComponentTable(parent, SWT.FULL_SELECTION, config); <END> return this.table.getControl(); }
<|startcomment|> return 'true' <|endcomment|> public boolean isEnabled() { return <START> getActiveTextEditor() != null; <END> }
<|startcomment|> maybe you need a specific Exception Type <|endcomment|> void verifyMetadata(MessageMetadata metadata) throws Exception { if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) { log.error("Wrong message metadata {}, expecting type {} snapshot {}", metadata, MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot); <START> throw new Exception("wrong type of message"); <END> } }
<|startcomment|> This is a bug, the setter does nothing, use 'this' <|endcomment|> public void setVmBackup(VmBackup value) { <START> vmBackup = value; <END> }
<|startcomment|> what is this part for? you are not checking throw statements. <|endcomment|> public void setPrice1(int price3) { if (price3 < 0 || price3 > 10000) { <START> throw new IllegalArgumentException("Invalid price: " + price3); // Compliant <END> } if (true) { assert price3 > 1000; // Noncompliant } }
<|startcomment|> This will fail on `null` <|endcomment|> public String evaluate(TransactionContext txnCtx, Input<Object>[] args) { assert args.length == 2 : "repeat takes exactly two arguments"; var text = (String) args[0].value(); if (text == null) { return null; } <START> var repetitions = (int) args[1].value(); <END> if (repetitions <= 0) { return ""; } else { return text.repeat(repetitions); } }
<|startcomment|> why is this public? <|endcomment|> <START> public void setActionBarNotificationBarColor(MaterialColor color) { <END> getSupportActionBar().setBackgroundDrawable(new ColorDrawable(color.toActionBarColor(this))); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { getWindow().setStatusBarColor(color.toStatusBarColor(this)); } }
<|startcomment|> Please use {} for every if/else/for/etc. block. <|endcomment|> public static ProjectBuildType getProjectType(IProject project) { // ------------ AUTOTOOLS // Autotools has an 'Autotools' nature by which we can identify it. <START> if (isAutoTools(project)) <END> return ProjectBuildType.AUTO_TOOLS; IConfiguration defaultConfiguration = helper_getActiveConfiguration(project); IBuilder builder = defaultConfiguration.getBuilder(); Boolean projIsManaged = builder.isManagedBuildOn(); if (projIsManaged) return ProjectBuildType.MANAGED_MAKEFILE; else return ProjectBuildType.OTHER; //E.g a manual makefile. }
<|startcomment|> This isn't necessary. <|endcomment|> protected long download(T object, File outFile) throws IOException { try { openObjectFunction.open(object, outFile); } <START> catch (IOException e) { <END> throw new RuntimeException(e); } return outFile.length(); }
<|startcomment|> what's the point of catching and then throwing the same exception type? <|endcomment|> private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) { Collection<VCastResult> results = null; try { results = dataStore.getAllResults(); } catch (OseeCoreException ex) { <START> throw new OseeCoreException(ex, "SQL error while reading results"); <END> } return results; }
<|startcomment|> public <|endcomment|> public PinotQueryGeneratorContext visitFilter(FilterNode node, PinotQueryGeneratorContext context) <START> { <END> context = node.getSource().accept(this, context); requireNonNull(context, "context is null"); LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections(); String filter = node.getPredicate().accept(pinotFilterExpressionConverter, (var) -> selections.get(var)).getDefinition(); return context.withFilter(filter).withOutputColumns(node.getOutputVariables()); }
<|startcomment|> JavaDoc and method signature did not match. Please update the JavaDoc! <|endcomment|> <START> private Space(String enumeratedValue) { <END> this.enumeratedValue = enumeratedValue; }
<|startcomment|> still requires fix: domain.getstorage_domain_type() == type <|endcomment|> public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) { Guid returnValue = Guid.Empty; List<storage_domains> domains = getAllForStoragePool(pool); for (storage_domains domain : domains) { <START> if (domain.getstorage_domain_type() == StorageDomainType.Master) { <END> returnValue = domain.getId(); break; } } return returnValue; }
<|startcomment|> For this it's better to do: ``` threadsLocked.inc(); try { // other stuff } finally { threadsLocked.dec(); } ``` This way if an exception is thrown we still decrement the threadsLocked counter. <|endcomment|> public void lock(T id) throws InterruptedException { <START> threadsLocked.inc(); <END> idsLocked.update(1); lockInternal(id); threadsLocked.dec(); }
<|startcomment|> looks like syntax typo (`Add position checks in RunLenghtEncodedBlock` commit) <|endcomment|> public RunLengthEncodedBlock(Block value, int positionCount) { requireNonNull(value, "value is null"); if (value.getPositionCount() != 1) { throw new IllegalArgumentException(format("Expected value to contain a single position but has %s positions", value.getPositionCount())); } // value can not be a RunLengthEncodedBlock because this could cause stack overflow in some of the methods if (value instanceof RunLengthEncodedBlock) { throw new IllegalArgumentException(format("Value can not be an instance of a %s", getClass().getName())); } if (positionCount < 0) { throw new IllegalArgumentException("positionCount is negative"); } <START> this.value = value <END> this.positionCount = positionCount; }
<|startcomment|> Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?) <|endcomment|> public Message.Request request() { <START> Message.Request request = callback.request(); <END> if (retryConsistencyLevel != null && retryConsistencyLevel != request.consistency()) return request.copy(retryConsistencyLevel); else return request; }
<|startcomment|> I would prefer to use full words. For example `directoryAllow`. <|endcomment|> public void init(FilterConfig filterConfig) throws ServletException { <START> dirAllowed = Context.getConfig().getBoolean("media.dirAllowed"); <END> }
<|startcomment|> This is backwards, you want the expected condition to be here. <|endcomment|> public ExtentBufferedCompositePattern(Extent extent, Pattern... patterns) { super(extent); <START> checkArgument(patterns.length == 0, "patterns cannot be empty"); <END> this.patterns = patterns; }
<|startcomment|> It's tangential, but `IllegalArgumentException` seems more reasonable. <|endcomment|> public boolean isValid(Object[] value, ConstraintValidatorContext context) { if ( value.length != 3 ) { <START> throw new IllegalStateException( "Unexpected method signature" ); <END> } // one or both limits are unbounded => always consistent if ( value[1] == null || value[2] == null ) { return true; } return ( (Date) value[1] ).before( (Date) value[2] ); }
<|startcomment|> maybe check for start of file or newline also? <|endcomment|> <START> private static boolean monoNativeFailure(Either<Utils.CommandResult> result) { <END> if (result == null || !result.isSuccess()) { return true; } else { Utils.CommandResult commandResult = result.get(); return monoNativeFailure(commandResult.output) || monoNativeFailure(commandResult.error); } }
<|startcomment|> Another extra space, can you plese cleanup all these similar things? There're a few others, some functions have spaces in parameters, some don't like `queryPos( APPBARDATA ABData )` vs. `dwABM.setValue(ShellAPI.ABM_QUERYPOS);`. Sorry to be a pest, just looks messy and inconsistent. <|endcomment|> private void removeAppBar() { DWORD dwABM = new DWORD(); APPBARDATA ABData = new APPBARDATA.ByReference(); ABData.cbSize.setValue( ABData.size() ); dwABM.setValue(ShellAPI.ABM_REMOVE); UINT_PTR result = Shell32.INSTANCE.SHAppBarMessage( dwABM, ABData); <START> assertNotNull(result ); <END> }
<|startcomment|> stray parens Also, use the standard couldMatch format used through Denizen, not this weird inline thing. <|endcomment|> public boolean couldMatch(ScriptPath path) { <START> return (path.eventLower.startsWith("mythicmob") && (path.eventArgLowerAt(2).equals("spawns"))); <END> }
<|startcomment|> Why does it resolve controller home? is it better to name it with HomeDir? It's because this class not only called from controller but agent. <|endcomment|> void init() { <START> controllerHomeDir = resolveControllerHomeDir(); <END> this.initAccessOfDirectories(); this.initAccessOfHosts(); }
<|startcomment|> It is always expected that launch would be an instance of GdbLaunch, I don't think the check is required. <|endcomment|> protected Sequence getServicesSequence(DsfSession session, ILaunch launch, IProgressMonitor rm) { if (launch instanceof GdbLaunch) { return new ServicesLaunchSequence(session, (GdbLaunch)launch, rm); } return null; <START> } <END>
<|startcomment|> `MiddlewareQueryException` is now a run time exception so it is not required to be part of the method signature. Not invalid to have it in signature, but Sonar will report it as a _Major_ category violation. <|endcomment|> <START> public AdvanceResult advanceNursery(final AdvancingNursery advanceInfo, final Workbook workbook) throws RuleException, MiddlewareQueryException, FieldbookException { <END> return this.namingConventionService.advanceNursery(advanceInfo, workbook); }
<|startcomment|> Please make it non-static, similar to what is done with ManagementNetworkFinder <|endcomment|> public org.ovirt.engine.api.model.Cluster update(org.ovirt.engine.api.model.Cluster incoming) { //TODO MM: Dear code reviewer! I'm not sure if this is really cool. I'd assume mapping should happen in mappers, but their powers are limited. Please advise. MacPool macPool = incoming.getMacPool(); <START> macPool.setId(MacPoolIdByIdOrName.get(macPool.getId(), <END> macPool.getName(), this)); return performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetClusterById, IdQueryParameters.class), VdcActionType.UpdateCluster, new UpdateParametersProvider()); }
<|startcomment|> handle this with an error log and returning null instead of a viewer? as the view won't work with an incorrect id? <|endcomment|> protected @NonNull TmfViewer createLeftChildViewer(@Nullable Composite parent) <START> { String analysisId = NonNullUtils.nullToEmptyString(getViewSite().getSecondaryId()); <END> return new AbstractSegmentStoreScatterChartTreeViewer(Objects.requireNonNull(parent)) { @Override protected @Nullable ISegmentStoreProvider getSegmentStoreProvider(ITmfTrace trace) { IAnalysisModule module = TmfTraceUtils.getAnalysisModuleOfClass(trace, IAnalysisModule.class, analysisId); if (module instanceof ISegmentStoreProvider) { return (ISegmentStoreProvider) module; } return null; } }; }
<|startcomment|> I think it makes more sense to omit this assert in the expected exception cases? <|endcomment|> public void testReservedSkippableBeforeStreamIdentifier() throws Exception { ByteBuf in = Unpooled.wrappedBuffer(new byte[] { -0x7f, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y' }); <START> assertFalse(channel.writeInbound(in)); <END> }
<|startcomment|> In the `get` method which calls `getChild` we use `property.getName()` instead of `field.getName().getPrefixedName()` as the key in the `children` map. Can you make this consistent so that we're sure there's no discrepancy between prefixed/unprefixed? <|endcomment|> public void set(String name, Property property) throws PropertyNotFoundException { Field field = getType().getField(name); if (field == null) { Property removedProperty = computeRemovedProperty(name); if (removedProperty != null) { removedProperty.set(name, property); } return; } <START> children.put(field.getName().getPrefixedName(), property); <END> setIsModified(); }
<|startcomment|> `andCardinality(Container)` should be called here instead of `and(Container).getCardinality()` <|endcomment|> public int andCardinality(Container x) { if (this.getCardinality() == 0) return 0; else if (x.getCardinality() ==0) return 0; else { if (x instanceof ArrayContainer) <START> return and((ArrayContainer) x).getCardinality(); <END> else if (x instanceof BitmapContainer) return and((BitmapContainer) x).getCardinality(); return and((RunContainer) x).getCardinality(); } }
<|startcomment|> (nit) Initialize with initial capacity to be the number of workers. <|endcomment|> public Set<WorkerNetAddress> getWorkerAddresses() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } <START> Set<WorkerNetAddress> workerAddresses = new HashSet<>(); <END> for (MasterWorkerInfo worker : mWorkers) { // worker net address is unmodifiable after initialization, no locking is needed workerAddresses.add(worker.getWorkerAddress()); } return workerAddresses; }
<|startcomment|> move this to where `signature` is declared, since it never changes? <|endcomment|> public void setUp() { params.put("CallSid", "CA1234567890ABCDE"); params.put("Caller", "+14158675309"); params.put("Digits", "1234"); params.put("From", "+14158675309"); params.put("To", "+18005551212"); <START> signature = "RSOYDt4T1cUTdK1PDd93/VVr8B8="; <END> }
<|startcomment|> public @Nullable String... <|endcomment|> <START> public String getAttributeValue(@Nullable String name) { <END> return name; }
<|startcomment|> This logic will obviously need updated once we change `this.cookiesToClear`. <|endcomment|> public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { for (Object cookie : cookiesToClear) { Cookie realCookie = null; <START> if (cookie instanceof String) { <END> realCookie = new Cookie((String) cookie, null); String cookiePath = request.getContextPath() + "/"; realCookie.setPath(cookiePath); realCookie.setMaxAge(0); }else if (cookie instanceof Cookie){ realCookie = (Cookie) cookie; } response.addCookie(realCookie); } }
<|startcomment|> Can remove the throws `InvalidWebSocketException` now. <|endcomment|> <START> private MethodHandles.Lookup getMethodHandleLookup(Class<?> endpointClass) throws InvalidWebSocketException <END> { return MethodHandles.publicLookup().in(endpointClass); }
<|startcomment|> won't this be a double-decrement? <|endcomment|> public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { if (maxConnections > 0) { if (numConnections.incrementAndGet() > maxConnections) { ctx.getChannel().close(); <START> numConnections.decrementAndGet(); <END> log.info("Accepted connection above limit ({}). Dropping.", maxConnections); } } super.channelOpen(ctx, e); }
<|startcomment|> this assumes the input is sorted, but the test case is what calls this; its very possible that the test defined them in non-sorted order <|endcomment|> public Builder from(int ... nums) { <START> this.matchers.add((from, to, msg) -> Arrays.binarySearch(nums, from) >= 0); <END> return this; }
<|startcomment|> @qeesung: nit you can merge the above 2 lines as `checkNotNull` returns `channelClass`. <|endcomment|> public B channel(Class<? extends C> channelClass) { ObjectUtil.checkNotNull(channelClass, "channelClass"); <START> return channelFactory(new ReflectiveChannelFactory<C>(channelClass)); <END> }
<|startcomment|> For variables which you are using in one place, remove them and just use the actual value in that one place. <|endcomment|> public void getActiveConditions_shouldGetActiveConditions() { List<Condition> activeConditions = conditionService.getActiveConditions(patientService.getPatient(2)); Condition firstActiveCondition = activeConditions.get(0); Condition secondActiveCondition = activeConditions.get(1); <START> String firstUUID = "2cc6880e-2c46-11e4-9138-a6c5e4d20fb7"; <END> String secondUUID = "2cc6880e-2c46-15e4-9038-a6c5e4d22fb7"; Assert.assertTrue(activeConditions.size() == 2); Assert.assertEquals(firstUUID,firstActiveCondition.getUuid()); Assert.assertEquals(secondUUID, secondActiveCondition.getUuid()); }
<|startcomment|> why is there a `newArrayList`? <|endcomment|> public synchronized Inode<?> getInodeOrNull() { if (!fullPathExists()) { return null; } <START> List<Inode<?>> inodeList = Lists.newArrayList(mLockList.getInodes()); <END> return inodeList.get(inodeList.size() - 1); }
<|startcomment|> why not `list.stream().forEach`? <|endcomment|> private static <T> Set<T> findDuplicates(Collection<T> list) { Set<T> duplicates = new HashSet<>(); Set<T> uniques = new HashSet<>(); <START> for(T t : list) { <END> if(!uniques.add(t)) { duplicates.add(t); } } return duplicates; }
<|startcomment|> This isn't right. <|endcomment|> public boolean next() throws IOException { for (;;) { LogQueueEntry t = queue.poll(); if (t == null) { return false; } refName = t.lc.getRefName(); updateIndex = t.lc.getUpdateIndex(); entry = t.lc.getReflogEntry(); boolean include = includeDeletes || entry != null; skipShadowed(refName, updateIndex); add(t); <START> if (include) { return true; } return true; <END> } }
<|startcomment|> That's not logic for this method. If we are here, we have to be already sure that it is our own group. The real problem is definitely in the `ForceReleaseMessageGroupProcessor` implementation. We have to check for its presence there. All other logic should not be affected. Please, make this `remove()` method `protected`. <|endcomment|> void remove(MessageGroup group) { Object correlationKey = group.getGroupId(); <START> if (this.groupIds.contains(correlationKey)) { <END> this.messageStore.removeMessageGroup(correlationKey); this.groupIds.remove(correlationKey); } }
<|startcomment|> Hmm, this feels like premature optimization. The offsets map is more likely to be a problem. Also, I'm not sure we should restrict the usage. It is possible today to send offsets for multiple groups. Is there a good reason to restrict this even if it doesn't make sense in streams? <|endcomment|> public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets, String consumerGroupId) throws ProducerFencedException { <START> if (!cachedGroupMetadata.groupId().equals(consumerGroupId)) { <END> // Generally this logic should only be triggered once during first call. log.warn("Cached consumer groupId changed from {} to {}. If the old group id is not empty, this indicates an abuse of this API", cachedGroupMetadata.groupId(), consumerGroupId); cachedGroupMetadata = new ConsumerGroupMetadata(consumerGroupId, JoinGroupRequest.UNKNOWN_GENERATION_ID, JoinGroupRequest.UNKNOWN_MEMBER_ID, Optional.empty()); } sendOffsetsToTransactionInternal(offsets, cachedGroupMetadata, false); }
<|startcomment|> The issue we found was when the original `reason` could not be logged due to an error in its `toString`. Do we have any concern that logging the _new_ error might have the same issue? Would it be better to have two stages to this? 1. Catch the logging error, then try to log that error. 2. Catch _that_ error if it happens, and log a generic, static message. <|endcomment|> public boolean cancel(final Exception rootReason) { if (transitionCancel(rootReason)) { final Exception reason = new CancellationException(rootReason); try { traceFailure(reason); } catch (Throwable ex) { <START> LOGGER.warn("Exception thrown in logging trace for failure!", ex); <END> } getSettableDelegate().fail(reason); return true; } return false; }
<|startcomment|> Can be private <|endcomment|> <START> int allVersionsCombined() <END> { return formatIdentifier >>> SHIFT_FORMAT_IDENTIFIER | formatVersion >>> SHIFT_FORMAT_VERSION; }
<|startcomment|> the connection configuration is never serialized. <|endcomment|> <START> protected void writeJDBCStoreConnection(XMLExtendedStreamWriter writer, SimpleConnectionFactoryConfiguration configuration) throws XMLStreamException { <END> writer.writeStartElement(Element.SIMPLE_CONNECTION); writeOptional(writer, Attribute.CONNECTION_URL, configuration.connectionUrl()); writeOptional(writer, Attribute.DRIVER_CLASS, configuration.driverClass()); writeOptional(writer, Attribute.USERNAME, configuration.username()); writeOptional(writer, Attribute.PASSWORD, configuration.password()); writer.writeEndElement(); }
<|startcomment|> "public" or "private" ? <|endcomment|> <START> static ByteBuf copyData(ByteBufList list) { <END> ByteBuf buf = Unpooled.buffer(list.readableBytes()); for (int i = 0; i < list.size(); i++) { buf.writeBytes(list.getBuffer(i).slice()); } return buf; }
<|startcomment|> Useless <|endcomment|> private String getXMI_ID(final EObject eobject) { if (eobject.eResource() instanceof XMIResource) { return ((XMIResource) eobject.eResource()).getID(eobject); } <START> ; <END> return null; }
<|startcomment|> Can you format these overrides? <|endcomment|> <START> @Override public float getPressure () { <END> return 0; }
<|startcomment|> I'm probably missing something, but it seems like this is part of the next case (isn't `queue.size() >= 0` an invariant?). Is this called out just to emphasize that setting `0` => "no queuing"? <|endcomment|> private boolean checkForJournalFlush() { // System.err.printf("checkForJournalFlush: queue size=%d; journal size = %d\n", queue.size(), journal.size()) ; // System.err.printf("checkForJournalFlush: QueueBatchSize=%d; MaxQueueThreshold=%d; JournalThresholdSize=%d\n", // QueueBatchSize, MaxQueueThreshold, JournalThresholdSize) ; <START> if ( QueueBatchSize == 0 ) <END> return true ; if ( queue.size() >= QueueBatchSize ) // Based on number of queued commits // The MaxQueueThreshold is handled in processDelayedReplayQueue. return true ; boolean journalSizeFlush = (JournalThresholdSize > 0 && journal.size() > JournalThresholdSize ) ; if ( journalSizeFlush ) // JENA-1222 // Based on Journal file growing large in terms of bytes return true ; // No test for excessive queue length (MaxQueueThreshold). // That happens in notifyCommit (writer exit). return false ; }
<|startcomment|> Use add(ProjectConfig) method here instead of repeating the same code? <|endcomment|> private ProjectState newProjectState(ProjectConfig local) { <START> PrologEnvironment.Factory envFactory = null; GitRepositoryManager gitMgr = null; ProjectControl.AssistedFactory projectControlFactory = null; RulesCache rulesCache = null; SitePaths sitePaths = null; List<CommentLinkInfo> commentLinks = null; all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local)); <END> return all.get(local.getProject().getNameKey()); }
<|startcomment|> There's a re-declaration error here, that got fixed on the parent branch. That needs to get merged in here. <|endcomment|> public static Collection<PersonaAccount> getPersonaAccountsForAccount(long accountId) throws CentralRepoException { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId <START> + "AND p.status_id != " + Persona.PersonaStatus.DELETED.getStatusId(); <END> CentralRepository cr = CentralRepository.getInstance(); if (cr != null) { String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE + " WHERE persona_accounts.account_id = " + accountId; PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback(); cr.executeSelectSQL(queryClause, queryCallback); return queryCallback.getPersonaAccountsList(); } return new ArrayList<>(); }
<|startcomment|> The same question, how "column supports filtering" relates to "has multiple values"? <|endcomment|> public boolean hasMultipleValues(final String dimension) { if (isVirtualColumn(dimension)) { return virtualColumns.getVirtualColumn(dimension).capabilities(dimension).hasMultipleValues(); } final Column column = index.getColumn(dimension); <START> if (column == null || !columnSupportsFiltering(column)) { <END> return false; } else { return column.getCapabilities().hasMultipleValues(); } }
<|startcomment|> This won't work? You wait until the node is powered on when you want to resume it. This will take forever. <|endcomment|> public void resumeNode(String id) { <START> waitServerUntilAvailable.apply(getNode(id)); <END> api.serverApi().updateStatus(id, Server.UpdateStatus.create(Types.ServerAction.POWER_ON, Types.ServerActionMethod.HARDWARE)); }
<|startcomment|> either make this a get method that returns the result, or have it be a "load" method. Having it do both is unexpected (same for above method) <|endcomment|> public IStyledLabelProvider[] getLabelProviders() { <START> if (fLabelProviders == null) { <END> fLabelProviders = CHEProviderSettings.getCCallHierarchyLabelProviders(); } return fLabelProviders; }
<|startcomment|> Why are these registered at all? What invokes them? <|endcomment|> public void registerOperations(ManagementResourceRegistration resourceRegistration) { if (showResources) { resourceRegistration.registerOperationHandler(ShowJaxrsResourcesHandler.DEFINITION, new ShowJaxrsResourcesHandler()); } else { resourceRegistration.registerOperationHandler(ADD_DEFINITION, JaxrsSubsystemAdd.INSTANCE); <START> resourceRegistration.registerOperationHandler(REMOVE_DEFINITION, ReloadRequiredRemoveStepHandler.INSTANCE); <END> } }
<|startcomment|> And one for luck ;-) <|endcomment|> public int hashCode() { <START> int result = processId.hashCode(); <END> result = 31 * result + taskId.hashCode(); result = 31 * result + taskName.hashCode(); result = 31 * result + formName.hashCode(); return result; }
<|startcomment|> Can probably remove synchronized now? <|endcomment|> <START> public synchronized void stop(final String reason) <END> { new Thread( "Shutdown Thread" ) { @Override public void run() { independentThreadStop( reason, true ); } }.start(); }
<|startcomment|> braces <|endcomment|> public boolean equals(Object o) { if (!(o instanceof Map.Entry)) <START> return <END> false; Map.Entry<?,?> e = (Map.Entry<?,?>)o; return ((key == null ? e.getKey() == null : key.equals(e.getKey())) && (value == null ? e.getValue() == null : value.equals(e.getValue()))); }
<|startcomment|> protected ? <|endcomment|> <START> public PostgreSqlEngine(final PdbProperties properties, final String driver) throws DatabaseEngineException { <END> super(driver, properties, Dialect.POSTGRESQL); }
<|startcomment|> make dispose synchronized, then we could remove the volatile keyword in the class member. <|endcomment|> <START> public void dispose() { <END> clearCachedSwingEditor(); }
<|startcomment|> I'm thinking that new thread is not needed for the reconnect task. This thread should be dead already by the time a new reconnect is needed and I see `Timer` instance serving the purpose of this thread. What do you think? <|endcomment|> public void run() { if(thread == null || !Thread.currentThread().equals(thread)) { <START> thread = new Thread(this); <END> thread.start(); } else { try { if (logger.isInfoEnabled()) logger.info("Start reconnecting " + provider); provider.register( getUIService().getDefaultSecurityAuthority(provider)); } catch (OperationFailedException ex) { logger.error("cannot re-register provider will keep going", ex); } } }
<|startcomment|> Couldn't this actually depend on the class and generate the name from that? <|endcomment|> public void checkProperties(Properties properties) { <START> properties.setProperty("log4j.shutdownCallbackRegistry", "io.druid.common.config.Log4jShutdown"); <END> properties.setProperty("log4j.shutdownHookEnabled", "true"); }
<|startcomment|> ```suggestion assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, EMPTY_VALUE); ``` <|endcomment|> public void testUnmarshallTopLevelEmptyEventProperties() throws Exception { Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_<START>_EVENT_FILE_PATH); assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartTimerEvent emptyTop = getStartNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, StartTimerEvent.class); assertGeneralSet(emptyTop.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); <START> assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, ""); <END> // Know issue. Should be uncommented after https://issues.jboss.org/browse/JBPM-7038 will be fixed //assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE); }
<|startcomment|> We should handle maxIdle as well <|endcomment|> private EmbeddedExpirableMetadata( long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit, EntryVersion version) { super(version); this.lifespan = lifespan < 0 ? lifespan : lifespanUnit.toMillis(lifespan); <START> this.maxIdle = maxIdleUnit.toMillis(maxIdle); <END> }
<|startcomment|> @Lars Do you think that for consistency (and maybe another slight performance enhancement) this line should be changed as well? <|endcomment|> protected void setMatcherString(String pattern) { if (pattern.length() == 0) { searchPattern = null; } else { SearchPattern patternMatcher = new SearchPattern(); if (pattern.indexOf('*') != 0 && pattern.indexOf('?') != 0 && pattern.indexOf('.') != 0) { <START> pattern = "*" + pattern; //$NON-NLS-1$ <END> } patternMatcher.setPattern(pattern); searchPattern = patternMatcher; } }
<|startcomment|> yeah let's remove this :) <|endcomment|> public DefaultEditorSession(final ManagedSession session, final CanvasCommandManager<AbstractCanvasHandler> canvasCommandManager, final @Session SessionCommandManager<AbstractCanvasHandler> sessionCommandManager, final @Request SessionCommandManager<AbstractCanvasHandler> requestCommandManager, final ClientCommandRegistry<org.kie.workbench.common.stunner.core.command.Command<AbstractCanvasHandler, CanvasViolation>> clientCommandRegistry) { this.session = session; <START> this.commandRegistry = clientCommandRegistry.setSession(session); <END> this.sessionCommandManager = sessionCommandManager; this.requestCommandManager = requestCommandManager; this.canvasCommandManager = canvasCommandManager; }
<|startcomment|> For consistency across the project, please remove the `final` keyword here. <|endcomment|> private String transformToHeaderValue(Directive... directives) { <START> final StringBuilder sb = new StringBuilder(); <END> for (int i = 0; i < directives.length - 1; i++) { sb.append(directives[i].headerValue).append(", "); } sb.append(directives[directives.length - 1].headerValue); return sb.toString(); }
<|startcomment|> 🐜 De-facto we process errors in the logging handler. E.g. logging constructs the string, and it may cause OutOfMemoryError, which suppresses the original one. I'd rather vote that Errors are being rethrown without any processing <|endcomment|> private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) { for (CloudProvisioningListener cl : CloudProvisioningListener.all()) { try { cl.onFailure(plannedNode, cause); } catch (Throwable e) { LOGGER.log(Level.SEVERE, "Unexpected uncaught exception encountered while " + "processing onFailure() listener call in " + cl + " for agent " + plannedNode.displayName, e); <START> if (e instanceof Error) { <END> throw e; } } } }
<|startcomment|> These two logs could be `Logger.v()`. That's all, good to go! <|endcomment|> public synchronized boolean isLastMQNotifLongAgo() { long delay = 18 * 3600; // 24h - 3h = 18h long threshold = sharedPreferences.getLong(getCurrentModeName() + LAST_MORNING_Q_TIMESTAMP, - delay) + delay; if (threshold < Calendar.getInstance().getTimeInMillis()) { Logger.d(TAG, "{} - Last MQ notif was yesterday", getCurrentModeName()); return true; } else { <START> Logger.d(TAG, "{} - Last MQ notif was recent, do not notify", getCurrentModeName()); <END> return false; } }
<|startcomment|> Ditto `input != null` <|endcomment|> public CrewMember apply(org.atlasapi.media.entity.CrewMember input) { if (input instanceof org.atlasapi.media.entity.Actor) { return translateLegacyActor((org.atlasapi.media.entity.Actor) input); <START> } else if(Objects.nonNull(input)) { <END> return translateLegacyCrewMember(input); } else { return null; } }
<|startcomment|> Did you want to assert something before close in all these cases? i.e. it's not empty. <|endcomment|> public void testSocket() throws Exception { Socket s = new Socket(); s.connect(server.getLocalAddress()); s.close(); assertEquals(Collections.EMPTY_MAP, <START> tagger.getLiveDescriptors()); <END> }
<|startcomment|> `requireNonNull` is not needed given `copyOf` checks for nullability. <|endcomment|> public ValuesMatcher( Map<String, Integer> outputSymbolAliases, Optional<Integer> expectedOutputSymbolCount, Optional<List<List<Expression>>> expectedRows) { <START> this.outputSymbolAliases = ImmutableMap.copyOf(requireNonNull(outputSymbolAliases, "outputSymbolAliases is null")); <END> this.expectedOutputSymbolCount = requireNonNull(expectedOutputSymbolCount, "expectedOutputSymbolCount is null"); this.expectedRows = requireNonNull(expectedRows, "expectedRows is null"); }
<|startcomment|> Can just pass id and let Java autoboxing take care of it. <|endcomment|> protected Button getButton(int id) { <START> return buttons.get(new Integer(id)); <END> }
<|startcomment|> Better: Map <|endcomment|> public void setInitializationData(IConfigurationElement config, String propertyName, Object data) { if (data instanceof <START> Hashtable) { <END> Hashtable<?, ?> table = (Hashtable<?, ?>) data; color = (String) table.get("color"); //$NON-NLS-1$ } }
<|startcomment|> `cause` —> `e` please <|endcomment|> public void addRequestCleanupHandler(HttpServletRequest request) { RequestContext.getActiveContext(request).addRequestCleanupHandler(new RequestCleanupHandler() { @Override public void cleanup(HttpServletRequest req) { try { close(); } catch (OperationException cause) { <START> throw new NuxeoException(cause); <END> } } }); }
<|startcomment|> Why not move the logic about `Kind.FILE_INPUT` inside `isStmtListIncrementsNestingLevel`? <|endcomment|> public void visitStatementList(PyStatementListTree pyStatementListTree) { <START> if (isStmtListIncrementsNestingLevel(pyStatementListTree) && !pyStatementListTree.parent().is(Kind.FILE_INPUT)) { <END> nestingLevelStack.peek().increment(); super.visitStatementList(pyStatementListTree); nestingLevelStack.peek().decrement(); } else { super.visitStatementList(pyStatementListTree); } }
<|startcomment|> no need to add the same message to the secondary location <|endcomment|> private static void checkLxmlParseCall(SubscriptionContext ctx) { CallExpression callExpression = (CallExpression) ctx.syntaxNode(); if (checkCallExpressionFqn(callExpression, LXML_PARSE)) { CallExpression parserCall = getParserCall( getArgValueAsCallExpression( TreeUtils.nthArgumentOrKeyword(1, "parser", callExpression.arguments()))); if (parserCall != null && isUnsafeParserUsage(parserCall)) { <START> ctx.addIssue(parserCall, MESSAGE).secondary(callExpression, MESSAGE); <END> } } }
<|startcomment|> The same error is reported twice. <|endcomment|> public int getVisibility(IBinding member) { try { PDOMCPPMemberBlock members = new PDOMCPPMemberBlock(getLinkage(), record + MEMBERLIST); return members.getAccessibility(member); } catch (CoreException e) { CCorePlugin.log(e); <START> throw new IllegalArgumentException(member.getName() + " is not a member of " + getName()); //$NON-NLS-1$ <END> } }
<|startcomment|> Nitpick: It's generally safer to include curly brackets for _all_ if statements. It can help protect against a future developer accidentally introducing a bug if another line is added to the if statement. Alternatively, a more succinct way of writing this method would be: ``` return (dynamicTemplateData == null) ? Collections.<String, Object>emptyMap() : dynamicTemplateData; ``` <|endcomment|> public Map<String,Object> getDynamicTemplateData() { if(dynamicTemplateData == null) <START> return Collections.<String,Object>emptyMap(); <END> return dynamicTemplateData; }
<|startcomment|> I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems. <|endcomment|> <START> public String getVersion() { <END> return version; }
<|startcomment|> You can drop PERUNADMIN check here. And also in all other such methods in this file please. <|endcomment|> public List<User> getUsers(PerunSession sess) throws InternalErrorException, PrivilegeException { Utils.checkPerunSession(sess); // Authorization if(!AuthzResolver.isAuthorized(sess, Role.PERUNADMIN) && <START> !AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) { <END> throw new PrivilegeException(sess, "getUsers"); } return getUsersManagerBl().getUsers(sess); }
<|startcomment|> Negation missing? if (!cluster.isSetRequiredSwitchType()) { <|endcomment|> protected void setDefaultSwitchTypeIfNeeded() { Cluster cluster = getCluster(); <START> if (cluster.isSetRequiredSwitchType()) { <END> SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion()); cluster.setRequiredSwitchTypeForCluster(defaultSwitchType); } }
<|startcomment|> Removed. <|endcomment|> public List<BlockLocationInfo> getBlockLocations(AlluxioURI alluxioURI) <START> throws IOException <END> { throw new UnsupportedOperationException("GetBlockLocations is not supported."); }
<|startcomment|> can this be in the second ctor and call this(null) here? <|endcomment|> public CustomTxtParserWizard() { super(); <START> setWindowTitle(Messages.CustomTxtParserInputWizardPage_windowTitle); <END> }
<|startcomment|> Don't see how this change is necessary <|endcomment|> <START> protected Provider<AdditionalProperties> createProvider(String name) { <END> Provider<AdditionalProperties> p = mock(Provider.class); when(p.getName()).thenReturn(name); return p; }
<|startcomment|> You can change the 28 case to a default case, and remove this. <|endcomment|> public static int mapApiToArtVersion(int api) { if (api < 19) { return NO_VERSION; } switch (api) { case 19: case 20: return 7; case 21: return 39; case 22: return 45; case 23: return 64; case 24: case 25: return 79; case 26: return 124; case 27: return 131; case 28: // 144 is the current version in the master branch of AOSP as of 2018-05-22 return 144; } <START> return 143; <END> }
<|startcomment|> @jomarko If it is possible to move all those "context.getScenarioGridPanel().setFocus(true);" inside commonExecution, then move this "verify(scenarioGridPanelMock).setFocus(true);" inside "commonExecution" Test <|endcomment|> public void onAppendColumnEvent() { AppendColumnEvent event = new AppendColumnEvent(COLUMN_GROUP); scenarioSimulationEventHandler.onEvent(event); verify(scenarioSimulationEventHandler, times(1)).commonExecution(eq(scenarioSimulationContextLocal), isA(AppendColumnCommand.class)); <START> verify(scenarioGridPanelMock).setFocus(true); <END> }
<|startcomment|> Since getAdapter() has a generic interface, there is no need to type cast anymore. <|endcomment|> public static <T extends Widget> T serializeAndDeserialize( T instance ) throws Exception { byte[] bytes = serialize( instance ); T result = ( T )deserialize( bytes ); <START> Object adapter = result.getDisplay().getAdapter( IDisplayAdapter.class ); <END> IDisplayAdapter displayAdapter = ( IDisplayAdapter )adapter; displayAdapter.attachThread(); return result; }
<|startcomment|> maybe line wrap? <|endcomment|> <START> public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) { <END> for (PreReceiveHook hook : hooks) { hook.onPreReceive(rp, commands); } }
<|startcomment|> This only checks the first parameter for `null`. Could you update the version that takes in a `List` to check the entries for `null`s and update this line to call that version? <|endcomment|> public DescriptionBuilder withAdditionalAnnotations(Annotation annotation, Annotation... additionalAnnotations) { if (annotation == null) { throw new NullPointerException("Cannot add a null annotation"); } annotations.add(annotation); <START> annotations.addAll(Arrays.asList(additionalAnnotations)); <END> return this; }
<|startcomment|> instanceof? <|endcomment|> public void onAttach(final Activity activity) { super.onAttach(activity); try { mListener = (Listener) activity; <START> } catch (final ClassCastException e) { <END> Lg.e(activity.getClass().getName(), " should implement ", Listener.class.getName()); } }
<|startcomment|> Need to be careful here. We can't always assume classification problems. Maybe use -1 (last dimension) instead? <|endcomment|> private void preloadDataSet(){ preloadedDataSet = load(iter.next()); totalOutcomes = preloadedDataSet.getLabels().size(1); inputColumns = preloadedDataSet.getFeatureMatrix().size(1); <START> batch = preloadedDataSet.numExamples(); <END> }
<|startcomment|> `log.info()` to `ss.info()`. <|endcomment|> public void startup(Application application, ComponentStartupStatus ss) { FileOps.ensureDir(deltaClientZone); FileOps.clearAll(deltaClientZone); zone = Zone.connect(deltaClientZone); deltaLink = DeltaLinkHTTP.connect(deltaServerURL); deltaClient = DeltaClient.create(zone, deltaLink); jmsMessagingClient = application.getJMSMessagingClient(); <START> log.info(String.format("DeltaClient connected to DeltaServer at %s with zone %s", deltaServerURL, deltaClientZone)); <END> }
<|startcomment|> I think we don't need this change. We have similar structure in the `UdpSyslogReceivingChannelAdapter` below but you don't override the `onInit()` logic there. <|endcomment|> protected void onInit() { super.onInit(); if (this.connectionFactory == null) { <START> this.connectionFactory = new TcpNioServerConnectionFactory(super.getPort()); <END> this.connectionFactory.setDeserializer(new ByteArrayLfSerializer()); this.connectionFactory.setBeanFactory(getBeanFactory()); if (this.applicationEventPublisher != null) { this.connectionFactory.setApplicationEventPublisher(this.applicationEventPublisher); } this.connectionFactory.afterPropertiesSet(); } this.connectionFactory.registerListener(this); }
<|startcomment|> are there some unit tests for this? Will this handle extraneous whitespaces well? <|endcomment|> <START> public static Pair<Integer, Integer> getPrecisionAndScale(String type) { <END> String param = type.substring(8, type.length() - 1); String[] params = param.split(","); return new Pair<>(Integer.parseInt(params[0].trim()), Integer.parseInt(params[1].trim())); }
<|startcomment|> we don't know if these were used in extensions, can the things that were public remain so? <|endcomment|> <START> static String constructSegmentPath(String baseKey, String storageDir) <END> { return JOINER.join( baseKey.isEmpty() ? null : baseKey, storageDir ) + "/index.zip"; }
<|startcomment|> I find it strange that the constructor already does some work. Might catch someone by surprise, especially if he wants to concatenate several iterators. I'd like this better if only hasNext() or next() actually advanced. It's more predictable. Maybe similar to the logic in CachingKeyPairProvider$CancellingKeyPairIterator . That one is similar to MappingIterator<Path, KeyPair>. <|endcomment|> public MappingIterator(Collection<S> source, Function<S, D> transformation) { this.sourceIt = source.iterator(); this.transformation = transformation; <START> readNext(); <END> }
<|startcomment|> remove(a,b) is going to use equals which is not right for XWikiAttachment. You should use remove(a) != b instead. <|endcomment|> public boolean removeAll(Collection<?> c) { boolean changed = false; for (XWikiAttachment x : (Collection<? extends XWikiAttachment>) c) { <START> if (map.remove(x.getFilename(), x)) { <END> changed = true; } } if (changed) { updatedMap(); } return changed; }
<|startcomment|> @erdemedeiros let's remove all the system outs <|endcomment|> public void run(String... strings) throws Exception { <START> System.out.println(">>> Starting Audit App... "); <END> }
<|startcomment|> This is already initialized by super class. <|endcomment|> public CollectEnvCommand(FileSystemContext fsContext) { super(fsContext); <START> mCommands = new HashMap<>(); mCommandsAlt = new HashMap<>(); <END> registerCommands(); }
<|startcomment|> The "else" seems unnecessary <|endcomment|> protected void setBlobStorageService(BlobStorageService blobStorageService) { if (blobStorageService == null) { throw new IllegalArgumentException("BlobStorageService cannot be null"); <START> } else { <END> this.blobStorageService = blobStorageService; logger.trace("BlobStorage service set to {}", blobStorageService.getClass()); } }
<|startcomment|> I don't think this hurts but line 96 already sets this window.tbr to false and I have not seen that this property has changed. <|endcomment|> public void dispose() { app.getChildren().remove(windowModel); coolBarManager.dispose(); menuManager.dispose(); statusLineManager.dispose(); <START> windowModel.setToBeRendered(false); <END> windowModel.getContext().deactivate(); windowModel.getContext().dispose(); ((Shell) windowModel.getWidget()).dispose(); }
<|startcomment|> The executor shouldn't be needed here either <|endcomment|> public void setUp() { n = new CacheManagerNotifierImpl(); cl = new CacheManagerListener(); <START> TestingUtil.inject(n, TestingUtil.named(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR, new WithinThreadExecutor())); <END> n.start(); n.addListener(cl); }
<|startcomment|> Should be `final char rv;`. <|endcomment|> public char getLabel() { <START> char rv; <END> switch (getType()) { case INPUT_VAL: rv = buttonData.inputVal; break; case AUTO_CHAR: rv = buttonData.autoChar; break; case CUSTOM: rv = buttonData.customChar; break; default: rv='*'; // Should never happen. } return rv; }
<|startcomment|> I would prefer to move this call to the private `ReleasableBytesReference` constructor. <|endcomment|> public ReleasableBytesReference retainedSlice(int from, int length) { BytesReference slice = delegate.slice(from, length); <START> refCounted.incRef(); <END> return new ReleasableBytesReference(slice, refCounted); }
<|startcomment|> This set races with the dereference of L101 and may cause NPE. Besides, since it would be set to the value `lio` essentially (plus a transparent SafeSubscriber layer), you don't really need this field. Just call `this.unsubscribe()` on L101. <|endcomment|> public static <T> Iterable<T> latest(final Observable<? extends T> source) { return new Iterable<T>() { @Override public Iterator<T> iterator() { LatestObserverIterator<T> lio = new LatestObserverIterator<T>(); <START> lio.subscription = source.materialize().subscribe(lio); <END> return lio; } }; }
<|startcomment|> Discussion: does it make sense to return an enum entry here that I guess only exists for this method? Other alternatives could be to return `null` here, or an Optional <|endcomment|> public static MessageType fromId(String id) { for(MessageType current : values()) { if(current.getId().equals(id)) { return current; } } <START> return UNKNOWN; <END> }
<|startcomment|> Please remove unnecessary brackets: return vdsDynamic.getStatus() == VDSStatus.Down || vdsDynamic.getStatus() == VDSStatus.Reboot || (vdsDynamic.getStatus() == VDSStatus.NonOperational && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE); Even remaining brackets are not necessary, but they makes code more readable <|endcomment|> private boolean isHostNetworkUnreacable(VDS vds) { VdsDynamic vdsDynamic = vds.getDynamicData(); return ((vdsDynamic.getStatus() == VDSStatus.Down) || (vdsDynamic.getStatus() == VDSStatus.Reboot) || (vdsDynamic.getStatus() == VDSStatus.NonOperational <START> && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE)); <END> }
<|startcomment|> Having the Java Config style, it'd better to make this class `public`. <|endcomment|> <START> ScriptExecutingMessageSource(AbstractScriptExecutingMessageProcessor<?> scriptMessageProcessor) { <END> this.scriptMessageProcessor = scriptMessageProcessor; }
<|startcomment|> How come there needs to be a substring for this? <|endcomment|> public void typeInSearchField(String content, int length) { waitForElementVisibleByElement(searchInput); <START> searchInput.sendKeys(content.substring(0, length)); <END> PageObjectLogging.log( "typeInSearchField", "String >>" + content.substring(0, length) + "<< was typed in string field", true ); }
<|startcomment|> Inline. <|endcomment|> public Iterable<E> read(Configuration configuration) throws IOException { // TODO: what to do with Configuration? create new view? DatasetReader<E> reader = view.newReader(); <START> return reader; // TODO: who calls close? <END> }
<|startcomment|> if it is not constant, please convert to lower case? <|endcomment|> public void setRefreshInterval(final long refreshInterval) { <START> REFRESH_INTERVAL_IN_SECONDS = refreshInterval; <END> }
<|startcomment|> These copy-paste sections are starting to clutter up the presenter. Please try to extract a common denominator (e.g. a function) to reduce repeating code snippets. <|endcomment|> public void onNewImageFromCamera() { <START> if (navigator.isSdkAboveOrEqualM() && !navigator.doIHavePermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) { <END> navigator.askForPermission(new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE}, PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA); } else { interactor.createFile(this, CREATE_FILE_TAKE_PHOTO, null); } }
<|startcomment|> Please make sure there are overloaded constructors available for the old constructor signature. Then you also wont have to change this existing test. <|endcomment|> public void testEquals() throws Exception { FixedWidthConfiguration conf1 = new FixedWidthConfiguration(1, "UTF8", <START> 10, true, false, true); <END> FixedWidthConfiguration conf2 = new FixedWidthConfiguration(1, "UTF8", 10, true, false, true); assertEquals(conf1, conf2); FixedWidthConfiguration conf3 = new FixedWidthConfiguration(1, "UTF8", 10, false, false, true); assertFalse(conf1.equals(conf3)); }
<|startcomment|> You actually don't need a private variable for storing the link preview. If you look at the line directly above, the findFragmentByTag() function finds the dialog by its tag name (also specified above). You can cast the return value of this function into a LinkPreviewDialog, and call dismiss() on it. <|endcomment|> public void showLinkPreview(PageTitle title, int entrySource) { final String linkPreviewFragmentTag = "link_preview_dialog"; if (getSupportFragmentManager().findFragmentByTag(linkPreviewFragmentTag) == null) { <START> linkPreview = LinkPreviewDialog.newInstance(title, entrySource); <END> linkPreview.show(getSupportFragmentManager(), linkPreviewFragmentTag); } }
<|startcomment|> IMO, if you use `if (...) { ... }`, it makes the code easy to read. I meant the `{` and `}` are missing :) edit: the same for the following `if`s <|endcomment|> public void clear() { <START> if (loader instanceof CacheStore) <END> try { ((CacheStore) loader).clear(); } catch (CacheLoaderException e) { throw newCacheLoaderException(e); } }
<|startcomment|> This file needs some work to ensure it works with client. <|endcomment|> public ApplicabilityIds getApplicabilityIds() { // TBD - Replace with call to IApplicabilityService calls once implemented <START> ApplicabilityIds ids = new ApplicabilityIds(); <END> // ids.getApplicabilityIds().add(new ApplicabilityId(345L, "ARC-210")); // ids.getApplicabilityIds().add(new ApplicabilityId(366L, "COMM")); // ids.getApplicabilityIds().add(new ApplicabilityId(376L, "ASM")); // ids.getApplicabilityIds().add(new ApplicabilityId(368L, "UTF")); // ids.getApplicabilityIds().add(new ApplicabilityId(466L, "MDR")); return ids; }
<|startcomment|> private? <|endcomment|> <START> MediaType tryNarrowMediaType(MediaType negotiated, AdvancedCache<?, ?> cache) { <END> if (!negotiated.matchesAll()) return negotiated; MediaType storageMediaType = cache.getValueDataConversion().getStorageMediaType(); if (storageMediaType == null) return negotiated; if (storageMediaType.equals(MediaType.APPLICATION_OBJECT)) return TEXT_PLAIN; if (storageMediaType.match(MediaType.APPLICATION_PROTOSTREAM)) return APPLICATION_JSON; return negotiated; }
<|startcomment|> This does not do anything. Can be removed <|endcomment|> protected void addJAROption(Composite comp) { fJarButton = new Button(comp, SWT.CHECK); fJarButton.setText(getJarButtonText()); <START> fJarButton.addSelectionListener(widgetSelectedAdapter(e -> { <END> })); }
<|startcomment|> The additional check is not used in other instructions, is it needed? <|endcomment|> public String getTurnDescription( Translation tr ) { <START> if (rawName || !name.isEmpty()) <END> return getName(); return tr.tr("finish"); }
<|startcomment|> Catch? <|endcomment|> private void fetchPresenterWidgetTemplate(PresenterOptions presenterOptions) throws Exception { PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions(); presenterWidgetOptions.setSingleton(presenterConfigModel.isUseSingleton()); try { createdPresenterWidgetTemplates = CreatePresenterWidget.run(presenterOptions, presenterWidgetOptions, true); } catch (Exception e) { <START> throw e; <END> } }
<|startcomment|> Make this as a log.error statement. And needs to have space after the "," <|endcomment|> public String toString() { StringWriter writer = new StringWriter(); try { new ObjectMapper().writeValue(writer, graph); } catch (Exception e) { log.debug ("Error while constructing new ObjectMapper",e); <START> } <END> return writer.toString(); }
<|startcomment|> How about replacing these four lines with: ``` this(topic, Objects.requireNotNull(task).connector(), task.task(), discoverTimestamp); ``` and then removing the TODO line? <|endcomment|> public TopicStatus(String topic, ConnectorTaskId task, long discoverTimestamp) { //TODO: check non-null this.topic = topic; this.connector = task.connector(); this.task = task.task(); <START> this.discoverTimestamp = discoverTimestamp; <END> }
<|startcomment|> Just add an envelope section to `createFromEsriGeometry` method in this file <|endcomment|> private static OGCGeometry readGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length) { switch (type) { case POINT: return readPoint(input); case MULTI_POINT: case LINE_STRING: case MULTI_LINE_STRING: case POLYGON: case MULTI_POLYGON: return readSimpleGeometry(input, inputSlice, type, length); case GEOMETRY_COLLECTION: return readGeometryCollection(input, inputSlice); case ENVELOPE: <START> return OGCGeometry.createFromEsriGeometry(readEnvelope(input), null); <END> default: throw new IllegalArgumentException("Unexpected type: " + type); } }
<|startcomment|> Could set `null` to the `values` field too <|endcomment|> public void close() { <START> sketch = null; <END> }
<|startcomment|> We still need to account for the probe batch size here when we are processing a spilled partition. If we try to account for it in he PostBuildCalculator it will already be too late, because we will have already prefetched the probe side batch. <|endcomment|> public boolean shouldSpill() { // Expected new batch size like the current, plus the Hash Values vector (4 bytes per HV) long batchSize = ( batchMemoryManager.getRecordBatchSizer(RIGHT_INDEX).getRowAllocWidth() + 4 ) * recordsPerBatch; long reserveForOutgoing = batchMemoryManager.getOutputBatchSize(); <START> long memoryAvailableNow = allocator.getLimit() - allocator.getAllocatedMemory() - reserveForOutgoing; <END> boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow; if ( needsSpill ) { logger.debug("should spill now - batch size {}, mem avail {}, reserved for outgoing {}", batchSize, memoryAvailableNow, reserveForOutgoing); } return needsSpill; // go spill if too little memory is available }
<|startcomment|> same as above. we shouldn't be throwing run-time exceptions when close is called. <|endcomment|> public void close() { try { Await.result(beam.close()); } catch (Exception e) { final String errorMsg = "Error while closing Druid beam client"; LOG.error(errorMsg, e); <START> throw new RuntimeException(errorMsg); <END> } }
<|startcomment|> Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1. <|endcomment|> private boolean isPlatformKeybindingBug517068Fixed() { Bundle bundle = Platform.getBundle("org.eclipse.e4.ui.bindings"); //$NON-NLS-1$ Version currentVersion = bundle.getVersion(); <START> Version fixVersion = new Version(0, 12, 100); <END> return currentVersion.compareTo(fixVersion) >= 0; }
<|startcomment|> Why not just: return StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ); <|endcomment|> public static boolean isPluginPrefixAndArtifactIdEquals( Plugin p1, Plugin p2 ) { <START> if ( StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) <END> && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ) ) { return true; } return false; }
<|startcomment|> I think tuple size used to be 3. I'll fix it. <|endcomment|> public <VT> MessageOut<T> withParameter(ParameterType type, VT value) { <START> List<Object> newParameters = new ArrayList<>(parameters.size() + 3); <END> newParameters.addAll(parameters); newParameters.add(type); newParameters.add(value); return new MessageOut<T>(verb, payload, serializer, newParameters); }
<|startcomment|> should this be < 0? do we want to import a 0 nanosecond range? <|endcomment|> private boolean validateTimeRange() { boolean isEmpty = fStartTimeRangeText.getText().isEmpty() || fEndTimeRangeText.getText().isEmpty(); return !isEmpty && parseTimeRange() && fStartTimestamp.compareTo(fEndTimestamp) <= 0; <START> } <END>
<|startcomment|> Move filenamePath declaration to this line and make it final <|endcomment|> public static String getFileNamePath(final String filename, final FieldbookProperties fieldbookProperties) { String filenamePath = ""; StringBuilder filenameBuilder = new StringBuilder(); filenameBuilder.append(fieldbookProperties.getUploadDirectory()); filenameBuilder.append(File.separator); filenameBuilder.append(SettingsUtil.cleanSheetAndFileName(filename)); <START> filenamePath = filenameBuilder.toString(); <END> return filenamePath; }
<|startcomment|> this line can be removed <|endcomment|> protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status) { executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() { @SuppressWarnings("synthetic-access") @Override public StoragePoolIsoMap runInTransaction() { <START> CompensationContext context = getCompensationContext(); <END> context.snapshotEntityStatus(map, map.getstatus()); map.setstatus(status); getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getstatus()); getCompensationContext().stateChanged(); return null; } }); }
<|startcomment|> remove `final` modifier. <|endcomment|> public void visitMemberSelectExpression(MemberSelectExpressionTree tree) { if (tree.expression().is(Tree.Kind.IDENTIFIER)) { IdentifierTree identifier = (IdentifierTree) tree.expression(); <START> final Symbol owner = identifier.symbol().owner(); <END> if (owner != null && owner.isMethodSymbol()) { // No need to investigate selection on local symbols return; } } if (tree.expression().symbolType().isSubtypeOf("java.lang.Class")) { // No need to investigate selection on a Class object return; } super.visitMemberSelectExpression(tree); }
<|startcomment|> Hi, @mmedenjak is right we need a fallback mechanism when server is not available. Having a fallback mechanism have greater scope. Lets make the `computeIfPresentLocally` only implementation for now for the client. The optimisation for the client can be addressed later. <|endcomment|> public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED); checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED); <START> if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) { <END> BiFunctionExecutingEntryProcessor<K, V> ep = new BiFunctionExecutingEntryProcessor<>(remappingFunction); return executeOnKeyInternal(key, ep); } else { return computeIfPresentLocally(key, remappingFunction); } }
<|startcomment|> we don't need this check right. For loop won't enter if tasks are empty. We should avoid having multiple returns. <|endcomment|> public void sendUnanchored(Task task, String stream, List<Object> values, ExecutorTransfer transfer) { Tuple tuple = task.getTuple(stream, values); List<Integer> tasks = task.getOutgoingTasks(stream, values); <START> if (tasks.size() == 0) { <END> return; } for (Integer t : tasks) { transfer.transfer(t, tuple); } }
<|startcomment|> Unless I'm mistaken, you don't need to reload the whole server, just restart the services of the parent resource. You can leverage RestartParentResourceRegistration for this. <|endcomment|> AffinityResourceDefinition(PathElement path) { <START> super(path, UndertowExtension.getResolver(Constants.HANDLER, Constants.AFFINITY, path.getValue()), new ReloadRequiredAddStepHandler(), new ReloadRequiredRemoveStepHandler()); <END> }
<|startcomment|> throws <|endcomment|> @Override public E poll() { lock.lock(); try { if (queue.isEmpty()) { return null; } E peek = queue.peek(); queue.remove(); return peek; } catch (IOException e) { QueueFile.<Error>getSneakyThrowable(e); <START> return null; <END> } finally { lock.unlock(); } }
<|startcomment|> log.tracef <|endcomment|> public void testTimeout() throws SystemException, RemoteException { <START> log.info("Method stateful #testTimeout called"); <END> Transaction txn; txn = tm.getTransaction(); TxTestUtil.enlistTestXAResource(txn); TxTestUtil.enlistTestXAResource(txn); try { TxTestUtil.waitForTimeout(tm); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); throw new RemoteException("Interupted during waiting for transaction timeout", ie); } }
<|startcomment|> doesn't need to be public <|endcomment|> <START> public UnstagedComparator(boolean sortAlphabetically) { <END> this.alphabeticallySort = sortAlphabetically; }
<|startcomment|> So why not just add it to the boolean expression in line #1377? <|endcomment|> public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) { StorageType storageType = diskImage.getStorageTypes().get(0); String diskType = getDiskType(vm, diskImage, device); boolean isNativeIO = !"file".equals(diskType) || (storageType == StorageType.GLUSTERFS && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion())); // marked as transient disk (file type) and uses cache when snapshotId is not null if <START> (device.getSnapshotId() != null) { <END> isNativeIO = false; } return isNativeIO; }
<|startcomment|> Lines 316-319 can be rewritten as return execute(request, !isAnonymous(), monitor); <|endcomment|> public <T> T execute(Request<T> request, IProgressMonitor monitor) throws IOException, GerritException { if (!isAnonymous()) { return execute(request, true, monitor); } <START> return execute(request, false, monitor); <END> }
<|startcomment|> Maybe highlight should be called from setText instead? That way, if the text is changed after construction it will get highlighted too. <|endcomment|> public HighlightingInlineHyperlink(final String text, final String token, final String toHighlight) { super(text, token); <START> highlight(text, toHighlight); <END> }
<|startcomment|> Not sure if this is guideline, I would prefer to use `protected` visibility rather than package protected one. <|endcomment|> <START> String serializeInstallCmd(Collection<String> packages) { <END> if (packages.isEmpty()) { return ""; } else { return CommandInfo.CMD_INSTALL + " " + String.join(" ", packages); } }
<|startcomment|> I would prefer to have the IOException thrown by roundtrip. Catching it will still cause the test to fail, but it will be harder to debug. <|endcomment|> private List roundtrip(List vals, Map conf) { List ret = null; try { ret = deserialize(serialize(vals, conf), conf); <START> } catch (IOException e) { <END> LOG.error("Exception when serialize/deserialize ", e); } return ret; }
<|startcomment|> Why RESTART_JVM? AFAICT if I add this after boot the service is installed immediately. You'd have to redeploy any app for it to use the module, but that doesn't even require a reload much less a process restart. <|endcomment|> public GlobalDirectoryResourceDefinition() { super(new SimpleResourceDefinition.Parameters(PathElement.pathElement(EESubsystemModel.GLOBAL_DIRECTORY), EeExtension.getResourceDescriptionResolver(EESubsystemModel.GLOBAL_DIRECTORY)) <START> .setAddRestartLevel(OperationEntry.Flag.RE<START>_JVM) <END> .setRemoveRestartLevel(OperationEntry.Flag.RE<START>_JVM) .setAddHandler(GlobalDirectoryResourceDefinition.ADD) .setRemoveHandler(GlobalDirectoryResourceDefinition.REMOVE) .setCapabilities(EE_GLOBAL_DIRECTORY_CAPABILITY) ); }
<|startcomment|> You can remove the this <|endcomment|> public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) { super(parentShell); <START> this.fChartViewer <END> = chartViewer; }
<|startcomment|> I am confused when this is supposed to be "" or `this`? <|endcomment|> public String toStringShort() { <START> return MoreObjects.toStringHelper("") <END> .add("ClientType", getStringFromOptional(mClientType)) .add("ClientHostname", mLocalHostName) .add("ServerAddress", mServerAddress) .add("ChannelId", mChannelId) .omitNullValues() .toString(); }
<|startcomment|> for the boolean parameter could be useful to use enums, so that it is more clear what it means <|endcomment|> public CompilationUnit() { <START> this(null, false, null, new NodeList<>(), new NodeList<>(), null); <END> }
<|startcomment|> cast is not needed. <|endcomment|> public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); <START> description = (String) command.getParam(PARAM_DESC); <END> }
<|startcomment|> shouldn't provider be validated for existence prior to accessing it? <|endcomment|> protected void executeQueryCommand() { <START> Provider provider = getDbFacade().getProviderDao().get(getParameters().getId()); <END> NetworkProviderProxy client = getProviderProxyFactory().create(provider); getQueryReturnValue().setReturnValue(client.getAll()); }
<|startcomment|> In some tests you're using `editor.clear()`, in some you don't. I guess it's better to use it in all tests. Assume that the tests are executed in a random order and should also start in a clean state. So using a [@Before method (setUp)](http://junit.sourceforge.net/javadoc/org/junit/Before.html) to clear the `SharedPreferences` seems like a good idea. Maybe create a static util method so others can benefit from it as well. <|endcomment|> public void testCrashlyticsUninitializedOnAnonymousReportDisabled() { Context context = InstrumentationRegistry.getTargetContext(); SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit(); editor.putBoolean(SettingsActivity.SETTINGS_CRASH_REPORTS, false); <START> editor.clear(); <END> editor.commit(); CrashReporter crashReporter = new CrashReporter(context); assertFalse(crashReporter.initialize()); }
<|startcomment|> it can be simplified to a single return statement protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { return VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages()); } <|endcomment|> <START> protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { <END> if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages())) { return false; } else { return true; } }
<|startcomment|> typo --> ;; <|endcomment|> private CompletableFuture<CorfuInterClusterReplicationServerNode> startDiscoveryService(ServerContext serverContext) throws InterruptedException { log.info("Start Discovery Service."); CompletableFuture<CorfuInterClusterReplicationServerNode> discoveryServiceCallback = new CompletableFuture<>(); this.clusterManagerAdapter = buildClusterManagerAdapter(serverContext.getPluginConfigFilePath()); // Start LogReplicationDiscovery Service, responsible for // acquiring lock, retrieving Site Manager Info and processing this info // so this node is initialized as Source (sender) or Sink (receiver) replicationDiscoveryService = new CorfuReplicationDiscoveryService(serverContext, <START> clusterManagerAdapter, discoveryServiceCallback);; <END> return discoveryServiceCallback; }
<|startcomment|> I would change the order to: assertTrue(prevChunk < smallChunk2); assertTrue(smallChunk2 < smallChunk1); assertTrue(smallChunk1 < nextChunk); <|endcomment|> public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock() throws Exception { long prevChunk = mallocChunks(4); long middleChunk = mallocChunks(4); long nextChunk = mallocChunks(2); free(middleChunk); // This should be taken from the end of "middleChunk", since that's closer to the smaller neighbor long smallChunk1 = mallocChunks(1); // This should also be taken from the end of the remaining portion of "middleChunk" long smallChunk2 = mallocChunks(1); <START> assertTrue("The small chunks should have been allocated from the end of the free block", smallChunk1 > smallChunk2); assertTrue("The small chunks should have been allocated from space before 'nextChunk'", smallChunk1 < nextChunk); assertTrue("The small chunks should have been allocated from space after 'prevChunk'", smallChunk2 > prevChunk); <END> }
<|startcomment|> Why did you add this `System.out.println()` call? Maybe a logger is a better solution. <|endcomment|> public void shouldSetTempImagesPathAsCompleteDirectory() { URI path = URI.create("/pages/newImagesTemp/"); ConfigCore.setImagesPath(URI.create("/pages/newImagesTemp/")); <START> System.out.println(ConfigCore.getTempImagesPathAsCompleteDirectory()); <END> assertEquals("Temp images path was set incorrectly!", path, URI.create("/pages/newImagesTemp/")); }
<|startcomment|> Please move this check before assigning the variables. <|endcomment|> public MetadataHashAggPOP(@JsonProperty("child") PhysicalOperator child, @JsonProperty("context") MetadataAggregateContext context, @JsonProperty("phase") OperatorPhase phase) { super(child, phase, context.groupByExpressions(), Collections.emptyList(), 1.0F); <START> this.context = context; <END> this.phase = phase; Preconditions.checkArgument(context.createNewAggregations(), "Hash aggregate for metadata collecting should be used only for creating new aggregations."); }
<|startcomment|> Please first log the error and then inform the user. <|endcomment|> private void saveProcess(Process process) { try { serviceManager.getProcessService().save(process); } catch (DataException e) { <START> Helper.setFehlerMeldung(KITODO_SCRIPT_FIELD, "Error while saving process: " + process.getTitle(), e); <END> logger.error(KITODO_SCRIPT_FIELD + "Error while saving process: " + process.getTitle(), e); } }
<|startcomment|> private static <|endcomment|> <START> private String toHexString(QuantileDigest qdigest) <END> { return new SqlVarbinary(qdigest.serialize().getBytes()).toString().replaceAll("\\s+", " "); }
<|startcomment|> this should be private method <|endcomment|> <START> public String getHeader(){ <END> return selectedPageHeader.getText(); }
<|startcomment|> Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods "checkDuplicateEmail" and "checkDuplicateUsername" . And you can instead implement method on the HardcodedAttributeMapperFactory "validateConfiguration" and throw an error in case that "username" or "email" was configured as user model attribute. <|endcomment|> public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) { String userModelAttrName = getUserModelAttribute(); String attributeValue = getAttributeValue(); Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase()); if (userModelProperty != null) { <START> checkDuplicateEmail(userModelAttrName, attributeValue, realm, ldapProvider.getSession(), user); <END> setPropertyOnUserModel(userModelProperty, user, attributeValue); } else { user.setAttribute(userModelAttrName, Arrays.asList(attributeValue)); } }
<|startcomment|> boolean instead of Boolean <|endcomment|> <START> public Boolean delete( ProjectName projectName ) <END> { return callWithContext( () -> { final Boolean result = doDelete( projectName ); LOG.info( "Project deleted: " + projectName ); return result; } ); }
<|startcomment|> this isn't needed anymore right? <|endcomment|> public static void startServerInstance(File dataDir, ServerCnxnFactory factory, String hostPort) throws IOException, <START> InterruptedException, KeeperException.NoNodeException { <END> final int port = getPort(hostPort); LOG.info("<START>ING server instance 127.0.0.1:{}", port); ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000); factory.startup(zks); Assert.assertTrue("waiting for server up", ClientBase.waitForServerUp( "127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure())); }
<|startcomment|> If you want, you can change to use hamcrest here too. The method `Matchers.is` compare if two objects are equals. <|endcomment|> public void shouldShowAllMusicsAsHTTP() { MockHttpResult mockHttpResult = new MockHttpResult(); controller = new MusicController(dao, userInfo, mockHttpResult, validator, musics); when(dao.listAll()).thenReturn(Arrays.asList(music)); controller.showAllMusicsAsHTTP(); assertEquals("<p class=\"content\">"+ Arrays.asList(music).toString()+"</p>", mockHttpResult.getBody()); <START> } <END>
<|startcomment|> wouldn't you want the conditions check prior to assignments? <|endcomment|> public AttributeValueSearch(IAttributeType attributeType, String attributeValue) { this.attributeType = attributeType; this.attributeValue = attributeValue; <START> Conditions.checkNotNull(attributeType, "attributeType"); Conditions.checkNotNullOrEmpty(attributeValue, "attributeValue"); <END> }
<|startcomment|> What made you to wrap, when you still use a simple long afterwards? <|endcomment|> public ListenerContainerIdleEvent(Object source, long idleTime, @Nullable String id, String... queueNames) { super(source); <START> this.idleTime = Duration.ofMillis(idleTime); <END> this.listenerId = id; this.queueNames = Arrays.asList(queueNames); }
<|startcomment|> you should break out of the loop early after finding the target module <|endcomment|> public static XARecoveryModule getRegisteredXARecoveryModule () { if (registeredXARecoveryModule == null) { RecoveryManager recMan = RecoveryManager.manager(); Vector recoveryModules = recMan.getModules(); if (recoveryModules != null) { Enumeration modules = recoveryModules.elements(); while (modules.hasMoreElements()) { RecoveryModule m = (RecoveryModule) modules.nextElement(); if (m instanceof XARecoveryModule) { <START> registeredXARecoveryModule = (XARecoveryModule) m; <END> } } } } return registeredXARecoveryModule; }
<|startcomment|> possible NPE <|endcomment|> public String getUrl() { <START> return PluginImpl.getInstance().getServer(serverName).getConfig().getGerritFrontEndUrlFor(tEvent); <END> }
<|startcomment|> Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log. <|endcomment|> public void testBoundarySignalProcessInstance() throws Exception { Long processInstanceId = processClient.startProcess(CONTAINER_ID, PROCESS_ID_BOUNDARY_SIGNAL_PROCESS); assertNotNull(processInstanceId); assertTrue(processInstanceId.longValue() > 0); try { <START> checkAvailableBoundarySignals(CONTAINER_ID, processInstanceId); <END> } catch (Exception e){ processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); e.printStackTrace(); fail(e.getMessage()); } }
<|startcomment|> why not calling isAppConfiguredInSourceServerXml(fileName) to make sure the app installed to the dropins location is not configured? <|endcomment|> private void validateAppConfig(String fileName) throws Exception { String appsDir = getAppsDirectory(); if (appsDir.equalsIgnoreCase("apps") && !isAppConfiguredInSourceServerXml(fileName)) { // add application configuration applicationXml.createWebApplicationElement(fileName); } <START> else if (appsDir.equalsIgnoreCase("dropins") && isAnyAppConfiguredInSourceServerXml()) <END> throw new MojoExecutionException(messages.getString("error.install.app.dropins.directory")); }
<|startcomment|> Please add `private` modifier <|endcomment|> <START> static RequestContextDataHolder getRequestContext(Context ctx) { <END> return ctx.getOrDefault(REQUEST_CONTEXT_DATA_HOLDER, null); }
<|startcomment|> I'd inline this to conform with the rest of the class. <|endcomment|> public long getNumberOfImagesInStorageDomain(Guid storageDomainId) { <START> MapSqlParameterSource params = getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainId); <END> return getCallsHandler().executeRead("GetNumberOfImagesInStorageDomain", getLongMapper(), params); }
<|startcomment|> Is it really necessary to wait 100 milliseconds? Why not `Thread.sleep(1)`. Why not `Thread.yield()`? <|endcomment|> public TestObjectAsync() { try { <START> Thread.sleep(100); <END> Thread.sleep(100); counter = 1; } catch (InterruptedException ie) { throw new RuntimeException(ie); } }
<|startcomment|> Maybe `beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0` should be checked before calling getField ? Method getField modifies field via reflection and optionally recursively calls itself, so it could be costly. <|endcomment|> private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) { Field field = getField(beanClass, beanProp.getName()); return field != null ? field.getAnnotationsByType(Optional.class).length > 0 <START> || beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0 <END> : beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0; }
<|startcomment|> Why is this method required? Didn't see it used anywhere in the code <|endcomment|> public int getImageselector () { return imageSelectorIndex; <START> } <END>
<|startcomment|> I don't think we want to pass in an `Inflater` and than have `ZipInflaterInputStream` call `end()` on it. <|endcomment|> public InputStream getInputStream(FileHeader entry) throws IOException { if (entry == null) { return null; } InputStream inputStream = getEntryData(entry).getInputStream(); if (entry.getMethod() == ZipEntry.DEFLATED) { <START> inputStream = new ZipInflaterInputStream(inputStream, new Inflater(true), <END> (int) entry.getSize()); } return inputStream; }
<|startcomment|> Can you explain the idea behind storing transformation here and not anywhere else (at the very beginning of repaint())? Is it worth to keep this information and to compare it within getDoubleBufferGraphics() rather using the up-to-date viewportModel Transformation. is it because of a non-atomar opration betwenn getImage() and getDoubleBufferGraphics() calls? <|endcomment|> private org.eclipse.swt.graphics.Image createImage() { org.eclipse.swt.graphics.Image newImage; RenderedImage image = renderManager.getImage(); <START> this.backBufferTrsf=renderManager.getMapInternal().getViewportModel().worldToScreenTransform(); <END> if (image != null) newImage = AWTSWTImageUtils.createSWTImage(image, false); else { newImage = new Image(getDisplay(), getWidth(), getHeight()); } return newImage; }
<|startcomment|> this is nullable <|endcomment|> public VirtualMachine getCurrentMachineBuild(ITmfEvent event) { VirtualMachine machine = innerGetCurrentMachine(event); if (machine == null) { synchronized (fStateSystem) { String hostId = event.getTrace().getHostId(); <START> machine = createMachine(fStateSystem, event.getTimestamp().toNanos(), hostId, event.getTrace().getName()); <END> fKnownMachines.put(hostId, machine); } } return machine; }
<|startcomment|> Why do we need it here? <|endcomment|> public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && isDeterministic(expression) && !mayReturnNullOnNonNullInput(expression) && <START> !isDynamicFilter(expression)) { <END> ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { // We should only consider equalities that have distinct left and right components return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; }
<|startcomment|> instanceof <|endcomment|> private void updateGroup(final TupleBatch tb, final int row, final Object[] curAggStates) throws DbException { for (int agg = 0; agg < aggregators.length; ++agg) { if (!(aggregators[agg] .getClass() .getName() <START> .equals(StatefulUserDefinedAggregator.class.getName()))) { <END> aggregators[agg].addRow(tb, row, curAggStates[agg]); } } }
<|startcomment|> Please apply same changes as requested in first review here. <|endcomment|> protected void update(float delta) { int lengthInterpretation; try { <START> lengthInterpretation = length == null ? 0 : length.interpretInteger(sprite); <END> } catch (InterpretationException interpretationException) { lengthInterpretation = 0; Log.d(getClass().getSimpleName(), "Formula interpretation for this specific Brick failed.", interpretationException); } this.sprite.runningStitch.activateStitching(sprite, new SimpleRunningStitch(sprite, lengthInterpretation)); }
<|startcomment|> remove line <|endcomment|> protected void processSpanImpl(Span span, Map<String, String[]> servletRequestParameters) { long sum = 0; for (String weaselParameterToSum : weaselParametersToSum) { final Long timing = parsedLongOrNull(getParameterValueOrNull(weaselParameterToSum, servletRequestParameters)); if (timing == null) { <START> discardSpan(span); <END> return; } else { sum += timing; } } span.setTag(TIMING_RESOURCE, sum); }
<|startcomment|> `.map(ThrowingFunction.unchecked(p -> p))` unnecessary <|endcomment|> private void close(Path path) throws IOException { Path directoryWhereGeneratedArtifactsWasPlaced = path.getParent(); try (Stream<Path> s = Files.list(directoryWhereGeneratedArtifactsWasPlaced)) { <START> s.filter(p -> !Files.isDirectory(p)).map(ThrowingFunction.unchecked(p -> p)) <END> .forEach(ThrowingConsumer.unchecked(Files::delete)); } }
<|startcomment|> As a general rule: If you're unsure whether or not to suppress a warning, don't! You discovered the principal problem of mutable objects. The easy fix is to use [immutable objects](http://en.wikipedia.org/wiki/Immutable_object) whenever possible. `MessageReference` looks like it could be easily made immutable. So you should definitely do that instead of suppressing the warning. <|endcomment|> public void hashcodeVerifyEqualsContract() { <START> EqualsVerifier.forClass(MessageReference.class).suppress(Warning.NONFINAL_FIELDS).verify(); <END> }
<|startcomment|> nit: you can merge both lines above as `checkNotNull` will return the given argument <|endcomment|> public HttpRequest setUri(String uri) { ObjectUtil.checkNotNull(uri, "uri"); <START> this.uri = uri; <END> return this; }
<|startcomment|> Make all Guice constructors package private by removing the method modifier. Just: ``` java @Inject ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { ``` <|endcomment|> <START> protected ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { <END> this.creds = creds; }
<|startcomment|> rename 'child' <|endcomment|> protected int countChildrenOf(IResource checkResource) throws CoreException { if (checkResource.getType() == IResource.FILE) { return 1; } int count = 0; if (checkResource.isAccessible()) { for (IResource <START> resource : <END> ((IContainer) checkResource).members()) { count += countChildrenOf(resource); } } return count; }
<|startcomment|> If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The `startMonitor` method below also checks for the return value of this method being `null`. I guess `null` would then also be the default. <|endcomment|> public String getAppFolderToMonitor() { <START> if (folder == null) { <END> File f = new File("Applications"); folder = f.getAbsolutePath(); } return folder; }
<|startcomment|> I don't think you need this <|endcomment|> private static void count(Object inputBase, long inputAddress, int inputSize, int[] counts) { long input = inputAddress; Arrays.fill(counts, 0); <START> if (inputSize != 0) { <END> for (int i = 0; i < inputSize; i++) { int symbol = UNSAFE.getByte(inputBase, input) & 0xFF; input++; counts[symbol]++; } } }
<|startcomment|> If it's interrupted you might want to return too, rather than getting stuck in another park. <|endcomment|> public void submit(List<LuceneWork> workList, IndexingMonitor monitor) { Changeset changeset = new Changeset( workList, Thread.currentThread(), monitor ); transferQueue.add( changeset ); wakeUpConsumer(); boolean interrupted = false; while ( ! changeset.isProcessed() ) { LockSupport.park(); if ( Thread.interrupted() ) { <START> interrupted = true; <END> } } if ( interrupted ) { Thread.currentThread().interrupt(); } }
<|startcomment|> could we directly reduce this to debug level? <|endcomment|> public void setHttpService(HttpService httpService) { <START> logger.info("setHttpService called"); <END> this.httpService = httpService; }
<|startcomment|> Oh, yes, `Name` can only be qualified by another `Name`. I think it's a safe assumption to make :-) <|endcomment|> public boolean isInternal() { return getParentNode() .filter(parent -> parent instanceof Name) .map(parent -> (Name) parent) .flatMap(Name::getQualifier) <START> .map(parentNameQualifier -> parentNameQualifier == this) <END> .orElse(false); }
<|startcomment|> `valueOf` looks more appropriate (like `String#valueOf`) <|endcomment|> private void logStart() { log(3, "Running test " + m_testName + " on " + m_classMap.size() + " " + " classes, " <START> + " included groups:[" + Strings.mapToString(m_xmlMethodSelector.getIncludedGroups()) <END> + "] excluded groups:[" + Strings.mapToString(m_xmlMethodSelector.getExcludedGroups()) + "]"); if (getVerbose() >= 3) { for (ITestClass tc : m_classMap.values()) { ((TestClass) tc).dump(); } } }
<|startcomment|> Does this mean that every Job will be named ```"NutchJob"```? <|endcomment|> public NutchJob(Configuration conf) throws IOException { <START> super(conf, "NutchJob"); <END> }
<|startcomment|> Should use BundleContext.getProperty here, or the EnvonmentInfo service. <|endcomment|> private void loadMachineUUID() { if <START> (System.getProperty(PROP_UUID) != <END> null) return; String uuid = loadExistingUUID(); if (uuid == null) { uuid = UUID.randomUUID().toString(); saveUUID(uuid); } EnvironmentInfo environment = environmentTracker.getService(); if (environment != null) { environment.setProperty(PROP_UUID, uuid); } else { System.setProperty(PROP_UUID, uuid); } }
<|startcomment|> Maybe we can use `AtomicInteger` and get rid of `synchronized` keyword ? On a side note, I noticed that you haven't enabled the `parallel` attribute on `@DataProvider` annotation. So you can completely get rid of the need for ensuring Thread safety. <|endcomment|> public synchronized boolean retry(ITestResult result) { if (currentTry < maxreruntimes) { <START> ++currentTry; <END> return true; } return false; }
<|startcomment|> It was much nicer when we did not have to explicitly cast everywhere to `(Statistics<T>)`. Please consider re-working this part your changes. <|endcomment|> public Statistics<T> visitIntConstant(ValueExpressions.IntExpression expr, Void value) throws RuntimeException { <START> return (Statistics<T>)getStatistics(expr.getInt()); <END> }
<|startcomment|> It might even be more readable to export the symbolic constants outside the class, instead of null. Either way is fine. It might be clearer for debugging and logging. <|endcomment|> public ServiceDate getEnd() { <START> return end == UNBOUNDED_<END> ? null : end; <END> }
<|startcomment|> no public <|endcomment|> <START> public boolean <END> isLoggedIn() { return token != null && hub != null; }
<|startcomment|> The complete method could be stripped down to: ``` try { this.buildStatus = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values } ``` <|endcomment|> <START> public void setBuildStatus(String buildStatus) { <END> StashBuildState overwrittenBuildState = null; try { overwrittenBuildState = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values } this.buildStatus = overwrittenBuildState; }
<|startcomment|> Put this in the config preinit please <|endcomment|> public void preInit(FMLPreInitializationEvent evt) { RegistryHelper.useOtherModConfigFor(MODID, BCCore.MODID); BCSiliconConfig.preInit(); BCSiliconItems.preInit(); BCSiliconBlocks.preInit(); // Reload after all of the definitions have been created. <START> BCSiliconConfig.reloadConfig(EnumRestartRequirement.GAME); <END> NetworkRegistry.INSTANCE.registerGuiHandler(INSTANCE, BCSiliconProxy.getProxy()); BCSiliconProxy.getProxy().fmlPreInit(); }
<|startcomment|> Recycling a digest to which we still have references (namely in the member variable`digest`) is bound to give problems at some point: another thread may obtain it by means of `HashType.get()` while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of `Hash`. Note that the semantics of `finally` don't have anything to do with finalizers! <|endcomment|> public Hash(HashType type){ this.type = type; try { digest = type.get(); } finally { <START> type.recycle(digest); <END> } }
<|startcomment|> the mapping is still performed before the validation. it should be after it <|endcomment|> private boolean validateExternalVnicProfileMapping() { <START> drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings()); <END> final ValidationResult validationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping( getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId()); return validate(validationResult); }
<|startcomment|> do we need a `null` case? <|endcomment|> public void serDeTest() { <START> doSerDeTest(Collections.emptyList()); <END> doSerDeTest(Arrays.asList("a", "b", "/signedId/abcdef")); }
<|startcomment|> use String.valueOf(vm.getnum_of_monitors()) instead. <|endcomment|> protected void buildVmVideoCards() { createInfo.add(VdsProperties.display, vm.getdisplay_type().toString()); // vnc,qxl createInfo.add(VdsProperties.num_of_monitors, <START> (new Integer(vm.getnum_of_monitors())).toString()); <END> }
<|startcomment|> [optional] maybe this method can be static and should be moved to end of the class <|endcomment|> <START> String encode(String segment) { <END> return URL.encodeQueryString(type.replacePathSeparator(segment)); }
<|startcomment|> This code is duplicate. Moreover, repeated "add" operations are not necessary. You can use something like this: ``` return Arrays.asList( A_U_D_preferredMail, A_U_D_ISMail, A_U_D_publicAliasMails, A_U_D_privateAliasMails, A_U_D_o365EmailAddressesMU); ``` <|endcomment|> public List<String> getStrongDependencies() { List<String> strongDependencies = new ArrayList<>(); <START> strongDependencies.add(A_U_D_preferredMail); <END> strongDependencies.add(A_U_D_ISMail); strongDependencies.add(A_U_D_publicAliasMails); strongDependencies.add(A_U_D_privateAliasMails); strongDependencies.add(A_U_D_o365EmailAddressesMU); return strongDependencies; }
<|startcomment|> `isCacheable` is now `true`? I guess this was supposed to be `false` for generic extractors. Or am I wrong? <|endcomment|> boolean isCacheable() { <START> return true; <END> }
<|startcomment|> It does not make sense to expose a protected method and mark it as @Deprecated from the beginning. Maybe you should remove the annotation and make it package-private ? <|endcomment|> <START> protected static KeyManagerFactory buildKeyManagerFactory(File certChainFile, <END> String keyAlgorithm, File keyFile, String keyPassword, KeyManagerFactory kmf, String keyStore) throws KeyStoreException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidAlgorithmParameterException, IOException, CertificateException, KeyException, UnrecoverableKeyException { return buildKeyManagerFactory(toX509Certificates(certChainFile), keyAlgorithm, toPrivateKey(keyFile, keyPassword), keyPassword, kmf, keyStore); }
<|startcomment|> It's probably a bad idea to be checking for exception messages in the first place. <|endcomment|> public void testWrongPortConnection() throws Exception { BlockingChannel channel = new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory, clientSSLConfig); try { // send request channel.connect(); fail("should have thrown!"); } catch (IOException e) { <START> assertTrue(e.getMessage().contains("Connection refused")); <END> } }
<|startcomment|> the .contains() should probably be in the synchronized block too <|endcomment|> public void notifyParameterChanged(String name) { if (!fParameterNames.contains(name)) { throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName())); } <START> synchronized (fParameters) { <END> Object oldValue = fParameters.get(name); Object value = getParameter(name); if ((value != null) && !(value.equals(oldValue))) { parameterChanged(name); } } }
<|startcomment|> Is this idiomatic? In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns? Would be clearer to omit the assertTrue? <|endcomment|> public void testUnrecognizedSpec() { when(authentication.getAttributes().get(any(String.class))).thenReturn("strong_two_factor"); spec.setAuthenticationMethod("weak_two_factor"); <START> assertTrue(this.spec.isSatisfiedBy(this.assertion)); <END> }
<|startcomment|> Why does this claim to return Bundle? Doesn't really matter though :) <|endcomment|> <START> public static Bundle updateBundleConfig(Connection connection, Bundle bundle) <END> throws SQLException { final String sql = "UPDATE portti_view_bundle_seq SET config=? WHERE bundle_id=? AND view_id=?"; try (final PreparedStatement statement = connection.prepareStatement(sql)) { statement.setString(1, bundle.config); statement.setLong(2, bundle.bundle); statement.setLong(3, bundle.view); statement.execute(); } return null; }
<|startcomment|> `Integer.parseInt` <|endcomment|> protected int getOverProvisioningFactor() { <START> return Integer.valueOf(Framework.getProperty(WORKMANAGER_OVERPROVISIONING_PROP, DEFAULT_WORKMANAGER_OVERPROVISIONING)); <END> }
<|startcomment|> Please move `super.onDestroy` to the end of the method. <|endcomment|> protected void onDestroy() { <START> super.onDestroy(); <END> webView.setDownloadListener(null); }
<|startcomment|> Which part in this test calls `NettyResponseChannel.close()`? <|endcomment|> <START> public void closeTest() { <END> // request is keep-alive by default. HttpRequest request = createRequestWithHeaders(HttpMethod.GET, TestingUri.Close.toString()); EmbeddedChannel channel = createEmbeddedChannel(); channel.writeInbound(request); // drain the channel of content. while (channel.readOutbound() != null) { ; } assertFalse("Channel should be closed", channel.isOpen()); }
<|startcomment|> Please consider adding an overridden version of the `Script(String, int, Logger)` constructor that accepts `Duration` to encapsulate this type conversion. <|endcomment|> public String getRuleLogsForVms() { <START> final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); <END> cmd.add("get_rule_logs_for_vms"); final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser(); final String result = cmd.execute(parser); if (result == null) { return parser.getLine(); } return null; }
<|startcomment|> We can avoid the instance creation if the reporter already exist <|endcomment|> private void addReporter(Class<? extends IReporter> r) { <START> m_reporters.put(r, ClassHelper.newInstance(r)); <END> }
<|startcomment|> Don't mark methods as `final`. <|endcomment|> <START> public final synchronized void addFunctions(List<? extends SqlFunction> functions) <END> { addFunctions(TEMP_DEFAULT_CATALOG, functions); }
<|startcomment|> You can join the ifs. There's a content assist for that, it's awesome. <|endcomment|> public synchronized void inputChanged(Viewer viewer, Object oldInput, Object newInput) { <START> if (oldInput != newInput) { <END> if (newInput != null) { ImportTraceContentProvider input = (ImportTraceContentProvider) newInput; clearCandidates(); fTraceTypes.putAll(input.fTraceTypes); fTraceFiles.putAll(fTraceFiles); } } }
<|startcomment|> please set a modifier - protected seem suitable <|endcomment|> <START> boolean isPowerManagementLegal() { <END> return IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup() .getcompatibility_version().toString()); }
<|startcomment|> Should avoid `System.out` in tests. Instead can you write to log4j <|endcomment|> public void info(String message) { <START> System.out.println(message); <END> info.add(message); }
<|startcomment|> Probably should crash if bad format string <|endcomment|> public static File makeNumericDimFile(File dir, String dimension, ByteOrder order) { <START> return new File(dir, StringUtils.safeFormat("numeric_dim_%s_%s.drd", dimension, order)); <END> }
<|startcomment|> Is there any longer a need for the VM ID ? <|endcomment|> private AuditLogableBase createAuditLog(final VmNic iface) { AuditLogableBase logable = new AuditLogableBase(); <START> logable.setVmId(iface.getVmId()); <END> logable.addCustomValue("MACAddr", iface.getMacAddress()); logable.addCustomValue("IfaceName", iface.getName()); return logable; }
<|startcomment|> same here, redundant? <|endcomment|> public boolean equals( VirtualValue other ) { <START> if ( other == null || !(other instanceof MapValue) ) <END> { return false; } MapValue that = (MapValue) other; return size() == that.size() && Arrays.equals( keys, that.keys ) && Arrays.equals( values, that.values ); }
<|startcomment|> nit: Formatting <|endcomment|> private void processSingleClusterChanges(ManageNetworkClustersParameters param) { final List<ActionParametersBase> setupNetworksParams = new ArrayList<>( createNetworkClustersToSetupNetworksParametersTransformer().transform( param.getAttachments(), param.getDetachments(), param.getUpdates()) ); HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams); setupNetworksParams.forEach(this::withRootCommandInfo); <START> runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, setupNetworksParams, getContext().getExecutionContext()); <END> }
<|startcomment|> [minor] Can be static? <|endcomment|> <START> private void setFixedLengthStreamingMode(HttpURLConnection connection, long length) { <END> try { // Not caching method as invocation is literally sending > 2GB, which means reflection isn't a limiter! HttpURLConnection.class.getMethod("setFixedLengthStreamingMode", long.class).invoke(connection, length); } catch (Exception e) { throw new IllegalArgumentException("Cannot transfer 2 GB or larger chunks due to JDK 1.6 limitations." + " Use chunked encoding or multi-part upload, if possible, or use a different http driver." + " For more information: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6755625"); } }
<|startcomment|> Method should probably be protected, given writing this for sub-classing. <|endcomment|> <START> String getErrorMessage(ClientResponse clientResponse) { <END> String response = clientResponse.getEntity(String.class); try { // Try to see if the server responded with an error message from the API ApiError error = getJsonParser().readValue(response, ApiError.class); return error.getMessage(); } catch (IOException e) { // If not, inform the user of the underlying response (e.g. if server threw NPE or whatever) int statusCode = clientResponse.getStatus(); ClientResponse.Status status = clientResponse.getClientResponseStatus(); String responseText = clientResponse.getEntity(String.class); return "Server returned "+status+"("+statusCode+"); "+responseText; } }
<|startcomment|> `b ^ (b >> 31)` is missed here. <|endcomment|> public int hashCode() { int bits = 1; bits = 31 * bits + this.type.ordinal(); bits = 31 * bits + getToX(); bits = 31 * bits + getToY(); bits = 31 * bits + getToZ(); bits = 31 * bits + getFromX(); bits = 31 * bits + getFromY(); bits = 31 * bits + getFromZ(); <START> return bits; <END> }
<|startcomment|> This should call all ``` java return all(params, (RequestOptions) null); ``` <|endcomment|> public static AccountCollection all(Map<String, Object> params) throws AuthenticationException, InvalidRequestException, APIConnectionException, CardException, APIException { <START> return request(RequestMethod.GET, classURL(Account.class), params, AccountCollection.class, (RequestOptions) null); <END> }
<|startcomment|> Since this is a Fragment with a lifecycle, consider holding a reference to Call<?> and canceling it in onDestroy() if Call<?> is nonnull. <|endcomment|> public void onSaveClick() { editView.setSaveState(true); WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient(); <START> client.submitDescription(pageTitle, editView.getDescription(), <END> new WikidataDescriptionEditDataClient.Callback() { @Override public void success() { editView.setSaveState(false); L.i("WD description edit successful"); // TODO: go to success fragment } @Override public void failure(@NonNull Throwable caught) { editView.setSaveState(false); L.e("WD description edit failed: ", caught); // TODO: go to failure fragment } }); }
<|startcomment|> why not use the passed in editorInput <|endcomment|> protected ResourceSet loadResource(IEditorInput editorInput) { <START> final URI resourceURI = EditUIUtil.getURI(getEditorInput(), null); <END> return ResourceSetHelpers.loadResourceSetWithProxies(resourceURI, getCommandStack()); }
<|startcomment|> declared exception isn't thrown <|endcomment|> FileReftableStack.CompactionStats getCompactionStats() <START> throws IOException { <END> return reftableStack.getStats(); }
<|startcomment|> This changes default behaviour, right? Should it? <|endcomment|> public OnlineBackup incremental( String targetDirectory ) { outcome = new BackupService().doIncrementalBackup( hostNameOrIp, port, new File( targetDirectory ), <START> getConsistencyCheck( true ), timeoutMillis, defaultConfig() ); <END> return this; }
<|startcomment|> This could just be `return !(isDiscarding() || isCalleeData()) || isAsync();` <|endcomment|> private boolean isValidConfiguration() { if (isDiscarding() || isCalleeData()) { return isAsync(); } else { return true; <START> } <END> }
<|startcomment|> should this be set if ret is false? I don't know. <|endcomment|> public boolean setTrace(@NonNull ITmfTrace trace) throws TmfAnalysisException { boolean ret = super.setTrace(trace); if (!ret) { return ret; } ret = fCriticalPathModule.setTrace(trace); <START> fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId()); <END> return ret; }
<|startcomment|> Before, with waitOtherJobs, we "Do nothing" in case of InterruptedException. Why do you change that? Have you test the difference? <|endcomment|> public void fillContextMenu(final IMenuManager menu) { super.fillContextMenu(menu); final ISelection selection = getContext().getSelection(); if (selection.isEmpty()) { return; } // Wait the end of the loading of the representations file try { Job.getJobManager().join(AbstractRepresentationsFileJob.FAMILY, new NullProgressMonitor()); } catch (InterruptedException e) { <START> throw new RuntimeException(e); <END> } // Differents behavior between win and linux : windows will not // display contextual menu if busy cursor while dialog is shown. // Fill the context menu contextMenuFiller.fillContextMenu(menu, selection); }
<|startcomment|> Are you sure about that cast operation? You are asking for a service interface and cast it to a concrete implementation without instanceof check. You perform that check in the tracker that is only added to a SaveablesList. <|endcomment|> public void dispose() { // run super. super.dispose(); // remove ourselves as a selection and registry listener getSite().getPage().removePostSelectionListener(this); RegistryFactory.getRegistry().removeListener(this); SaveablesList saveables = <START> (SaveablesList) getSite().getService(ISaveablesLifecycleListener.class); <END> if (saveables != null) { saveables.removeModelLifecycleListener(saveablesTracker); } currentPart = null; currentSelection = null; pinPropertySheetAction = null; }
<|startcomment|> `String.format()` is no longer necessary here. <|endcomment|> public void setBaseballCard(BaseballCard card) { Locale locale = Locale.getDefault(); brand.setText(card.brand); year.setText(String.format(locale, "%d", card.year)); <START> number.setText(String.format(locale, "%s", card.number)); <END> player.setText(card.playerName); }
<|startcomment|> Can be static <|endcomment|> <START> private String capitalize(String word) { <END> return Character.toUpperCase(word.charAt(0)) + word.substring(1); }
<|startcomment|> instead of this, use (at the callsite where you have the JavaContext) TypeDescriptor type = context.getType(expression); return type != null && type.matchesSignature(JavaContext.TYPE_STRING); <|endcomment|> <START> private static boolean isStringParameter( <END> @NonNull Expression expression, @NonNull JavaContext context) { if (expression instanceof StringLiteral) { return true; } else { JavaParser.ResolvedNode resolvedNode = context.resolve(expression); if (resolvedNode instanceof JavaParser.ResolvedField) { if (((JavaParser.ResolvedField) resolvedNode).getValue() instanceof String) { return true; } } } return false; }
<|startcomment|> Nit: could we inline this to avoid unnecessary object creation <|endcomment|> protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) { <START> TopologyDetails td = getNextHighest(); <END> return getScore(availableCpu, availableMemory, availableGenericResources, td); }
<|startcomment|> I think this should be reverted, so it would still take into account additions from pre-`TransientActionFactory` implementations. <|endcomment|> public <T extends Action> List<T> getActions(Class<T> type) { <START> List<T> _actions = Util.filter(getPersistedActions(), type); <END> for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) { _actions.addAll(Util.filter(createFor(taf), type)); } return Collections.unmodifiableList(_actions); }
<|startcomment|> ImageData for current image needs to be updated in the array? <|endcomment|> public void addRepresentation (ImageData srcImageData, int zoom) { if (srcImageData == null) SWT.error(SWT.ERROR_NULL_ARGUMENT); int imageSelectorIndex = DPIUtil.mapZoomToImageSelectorIndex(zoom); if (imageSelectorIndex == device.getImageSelector ()) { init(srcImageData); <START> init(); <END> } else { data [imageSelectorIndex] = srcImageData; } }
<|startcomment|> you don't need to do that if you're already calling `loadProperties` in the public constructor, right? https://github.com/caelum/vraptor4/pull/973/files#diff-b7b62c45c7478eb642acfb81c12a4227R82 <|endcomment|> private DefaultEnvironment buildEnvironment(EnvironmentType environmentType) { DefaultEnvironment defaultEnvironment = new DefaultEnvironment(environmentType); <START> defaultEnvironment.setup(); <END> return defaultEnvironment; }
<|startcomment|> Style-nit: This is hard to read. Maybe: if (getRepositoryName() != null) return getRepositoryName().hashCode(); return System.identityHashCode(this); <|endcomment|> public int hashCode() { <START> return getRepositoryName() != null ? getRepositoryName().hashCode() : <END> System.identityHashCode(this); }
<|startcomment|> Can be removed and return only extensions without assigning logic. <|endcomment|> public List<String> getExtensions() { <START> return extensions == null ? DEFAULT_EXTS : extensions; <END> }
<|startcomment|> use final <|endcomment|> public List<RadiologyOrder> getRadiologyOrdersByPatient(Patient patient) { Criteria radiologyOrderCriteria = createRadiologyOrderCriteria(); addRestrictionOnPatient(radiologyOrderCriteria, patient); <START> List<RadiologyOrder> result = (List<RadiologyOrder>) radiologyOrderCriteria.list(); <END> return result == null ? new ArrayList<RadiologyOrder>() : result; }
<|startcomment|> This variable is useless in most cases. I would rather pass `new Object[] {}` to log method directly. <|endcomment|> public Weld addExtensions(Class<? extends Extension>... extensionClasses) { <START> Object[] constructorParams = new Object[] {}; <END> for (Class<? extends Extension> extensionClass : extensionClasses) { try { Extension extension = SecurityActions.newInstance(extensionClass); addExtension(extension); } catch (Exception ex) { CommonLogger.LOG.unableToInstantiate(extensionClass, constructorParams, ex); } } return this; }
<|startcomment|> If the last parameter is `true` then you need to overwrite `isLineInteresting`. <|endcomment|> public RTTestsParser() { super(Messages._Warnings_RTTests_ParserName(), Messages._Warnings_RTTests_LinkName(), Messages._Warnings_RTTests_TrendName(), <START> CYCLICTEST_WARNING_PATTERN, true); <END> }
<|startcomment|> You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID; <|endcomment|> private ValidationResult hostExists() { <START> if (getVds() == null) { <END> return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST); } return ValidationResult.VALID; }
<|startcomment|> You can remove all the requireNonNull due to @NNBD. I'm surprised we're allowed to use it, doing an explicit null check would be a compilation error... <|endcomment|> public static ToolTipString fromString(String text) { <START> Objects.requireNonNull(text, "fromString cannot take null"); //$NON-NLS-1$ <END> return new ToolTipString(text, toHtmlString(text)); }
<|startcomment|> `if (listStations.isEmpty())` <|endcomment|> public DataRadioStation getNextById(String id) { <START> if (listStations.size() == 0) <END> return null; for (int i = 0; i < listStations.size() - 1; i++) { if (listStations.get(i).ID.equals(id)) { return listStations.get(i + 1); } } return listStations.get(0); }
<|startcomment|> Please add the `{}` for the one-liner <|endcomment|> public static void setBiomeArrayMethod(boolean jeidPresent) { try { if (jeidPresent) { biomeArrayMethod = Chunk.class.getMethod("getIntBiomeArray"); } else <START> biomeArrayMethod = Chunk.class.getMethod("getBiomeArray"); <END> } catch (NoSuchMethodException e) { throw new RuntimeException(e); } }
<|startcomment|> I think since this will change in future release, it's better to let it be here so it's easier to update. <|endcomment|> public String getDescription() { return "Transform files representing a structured table under an Alluxio directory." + "\n\n" + "Files are coalesced and converted to parquet format." + "\n\n" + "Definition is in format like 'write(hive).option(hive.num.files, 100)'," + "currently, the only modification you can do to the example definition is " <START> + "the number of files in the option." <END> }
<|startcomment|> Handling of nulls? You have some in the later methods, but not here... If null is acceptable, we should return null here. If not, let's either add a lombok ```@NonNull``` or a ```Preconditions.checkNotNull(```. At present, nulls will give a non-useful NPE. <|endcomment|> <START> public static void validateNonNegative(int[] data, String paramName){ <END> boolean nonnegative = true; for(int value : data){ if(value < 0) { nonnegative = false; } } Preconditions.checkArgument(nonnegative, "Values for %s must be >= 0, got: %s", paramName, data); }
<|startcomment|> Looking at this (and i realize this is my own crappy code), its really a configuration error for the files to fail to load, and we really don't want to be eating that and just putting something in the log. Could you either remove the try block and make this constructor throw the IOException, or rethrow an exception with a little extra context? Up to you which you prefer. <|endcomment|> <START> public SetContentTypeFilter() { <END> try { mimetypeToExtensionMap = new Properties(); mimetypeToExtensionMap.load(new InputStreamReader(this.getClass().getResourceAsStream( "mimetypeToExtension.txt"))); contentTypeProperties = new Properties(); contentTypeProperties.load(new InputStreamReader(this.getClass().getResourceAsStream( "toContentType.properties"))); } catch (IOException e) { log.error("Failed to load mimetype mappings", e); } }
<|startcomment|> Instead of passing null, remove this check and call this method with a new Properties object. <|endcomment|> private SwiftApi api(String authUrl, Properties overrides) throws IOException { if (overrides == null){ overrides = new Properties(); <START> } <END> overrides.setProperty(CREDENTIAL_TYPE, "tempAuthCredentials"); return ContextBuilder.newBuilder(new SwiftApiMetadata()) .credentials("user", "password") .endpoint(authUrl) .overrides(overrides) .modules(ImmutableSet.of(new ExecutorServiceModule(sameThreadExecutor()))) .buildApi(SwiftApi.class); }
<|startcomment|> add null check <|endcomment|> public void setAcceptableValues(Collection<K> values) { buttons.clear(); panels.clear(); wrapperPanel.clear(); <START> for (final K value : values) { <END> addValue(value); } updateButtons(); }
<|startcomment|> `StorageException` is a runtime exception, no need to catch and rethrow it (several occurrences). <|endcomment|> public Bucket getOrCreateBucket(String bucketName) { try { Bucket bucket = storage.get(bucketName); if (bucket == null) { log.debug(String.format("Creating a new bucket %s", bucketName)); return storage.create(BucketInfo.of(bucketName)); } return bucket; } catch (StorageException e) { <START> throw new NuxeoException(e); <END> } }
<|startcomment|> You need to keep in mind that the sentence construction in other languages could be different, so the query string doesn't always show at the end. You should use %1$s in your string on values/strings.xml and pass the query term as an extra argument to getString() <|endcomment|> private void onFragmentLoaded() { if (searchAdapter == null) { searchAdapter = new SearchlistAdapter(getActivity(), itemAccess); setListAdapter(searchAdapter); } searchAdapter.notifyDataSetChanged(); setListShown(true); String query = getArguments().getString(ARG_QUERY); <START> setEmptyText(getString(R.string.no_results_for_query) + " \"" + query + "\""); <END> }
<|startcomment|> Thanks. Marking resolved. <|endcomment|> private Iterable<Ref> getSortedRefs() throws Exception { List<Ref> all = db.getRefDatabase().getRefsByPrefix(ALL); <START> if (all instanceof RefMap <END> || (all instanceof SortedMap && ((SortedMap) all).comparator() == null)) { return all; } return RefComparator.sort(all); }
<|startcomment|> I don't understand why you need to create a new ArrayList for a collection that is coming from a query - it is necessarily not being used by anyone else. Also, why cast what's coming from the backend to an ArrayList? This means you're committing to a specific implementation. I think a cast to Collection is more appropriate. If it's important for you to have the end result in specifically an ArrayList (and not any other kind of collection), then I would create a new ArrayList, but still cast the result from the backend to Collection. <|endcomment|> private static void convertAAAProfilesResult(AsyncQuery aQuery) { aQuery.converterCallback = new IAsyncConverter() { @Override public Object Convert(Object source, AsyncQuery _asyncQuery) { List<String> results = new ArrayList<String>(); <START> for (ProfileEntry profileEntry : source != null ? new ArrayList<ProfileEntry>((ArrayList<ProfileEntry>) source) <END> : new ArrayList<ProfileEntry>()) { results.add(profileEntry.getProfile()); } return results; } }; }
<|startcomment|> Since the `class` has _package_ protected access the constructor can probably have _package_ protection too? <|endcomment|> <START> public FunctionKindRowColumnHeaderMetaData(final Supplier<FunctionDefinition> functionSupplier, <END> final CellEditorControlsView.Presenter cellEditorControls, final KindPopoverView.Presenter editor, final Optional<String> editorTitle, final FunctionGrid gridWidget) { super(cellEditorControls, editor, editorTitle); this.functionSupplier = functionSupplier; this.gridWidget = gridWidget; }
<|startcomment|> Wouldn't starts with make more sense? <|endcomment|> public List<ProxiedPlayer> matchPlayer(String partialName) { List<ProxiedPlayer> matched = new ArrayList<ProxiedPlayer>(); for (ProxiedPlayer iPlayer : this.getPlayers()) { String iterPlayerName = iPlayer.getName(); if (partialName.equalsIgnoreCase(iterPlayerName)) { matched.add(iPlayer); break; } <START> if (iterPlayerName.toLowerCase().contains(partialName.toLowerCase())) { <END> matched.add(iPlayer); } } return matched; }
<|startcomment|> I notice in the unzigzag method below, you use the unsigned right shift operator (`>>>`), but here you're using the signed one (`>>`). Is that intentional? <|endcomment|> private int zigzagDecode(int input) { <START> return (input >> 1) ^ (-(input & 1)); <END> }
<|startcomment|> Please create method`doTest() { doTest(GoStringIndexIsByteQuickFix.NAME); }` and maybe same method `doTestNoFix()` <|endcomment|> <START> public void testEqualsCondition() { doTest(GoStringIndexIsByteQuickFix.NAME); } <END>
<|startcomment|> why do we need try/catch here? It should not fail, and if it fails, junit will take care about the stack etc <|endcomment|> public void testRedrawAfterDispose() { LineNumberRulerColumn lineNumberRulerColumn= new LineNumberRulerColumn(); CompositeRuler ruler= new CompositeRuler(); ruler.addDecorator(0, lineNumberRulerColumn); SourceViewer sourceViewer= new SourceViewer(fParent, ruler, SWT.NONE); lineNumberRulerColumn.getControl().setSize(10, 10); sourceViewer.getTextWidget().dispose(); try { lineNumberRulerColumn.redraw(); } <START> catch (Exception <END> notExpected) { notExpected.printStackTrace(); fail(); } }
<|startcomment|> Please consider adding an overridden version of the `Script(String, int, Logger)` constructor that accepts `Duration` to encapsulate this type conversion. <|endcomment|> public boolean configureDefaultNetworkRulesForSystemVm(final Connect conn, final String vmName) { if (!_canBridgeFirewall) { return false; } <START> final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); <END> cmd.add("default_network_rules_systemvm"); cmd.add("--vmname", vmName); cmd.add("--localbrname", _linkLocalBridgeName); final String result = cmd.execute(); if (result != null) { return false; } return true; }
<|startcomment|> shouldn't it be `> 1` <|endcomment|> public void testQueryCumulativeTable() { computeActual("SELECT * FROM \"*:*\""); computeActual("SELECT * FROM \"java.util.logging:*\""); <START> assertTrue(computeActual("SELECT * FROM \"java.lang:*\"").getRowCount() > 0); <END> assertTrue(computeActual("SELECT * FROM \"jAVA.LANg:*\"").getRowCount() > 0); }
<|startcomment|> should these be `debug` level? <|endcomment|> public RequestLogger get() { LoggingRequestLogger logger = new LoggingRequestLogger(mapper, setMDC, setContextMDC); <START> log.info(new Exception("Stack trace"), "Creating %s at", logger); <END> return logger; }
<|startcomment|> shouldn't we wrap the original `e` ? <|endcomment|> private IllegalReferenceCountException handleIllegalReferenceCountException(IllegalReferenceCountException e) { String accessRecord = leak.toString(); if (StringUtil.isNullOrEmpty(accessRecord)) { // means leak has been closed and there is no accessRecord. return e; } <START> return new TrackedIllegalReferenceCountException(e.getMessage(), accessRecord); <END> }
<|startcomment|> The new flag `withAttempts` is not passed (used) the `paymentProcessor#getAccountPayments` <|endcomment|> public List<Payment> getAccountPayments(final UUID accountId, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getAccountPayments(accountId, withPluginInfo, tenantContext, internalCallContextFactory.createInternalTenantContext(accountId, tenantContext)); <END> }
<|startcomment|> No need to cast to `String`, here `getParam` is a generic method `public <T> T getParam(String key)` <|endcomment|> public void startBucket(String bucketKey) { BulkCommand command = getCurrentCommand(); Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER); disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString()); retentionManager = Framework.getService(RetentionManager.class); <START> ruleId = (String) command.getParam(PARAM_RULE_ID); <END> }
<|startcomment|> should this check that the queue is not 0? Why acquire a connection if there are no waiting exchanges? <|endcomment|> public boolean remove(Connection connection) { boolean removed = connectionPool.remove(connection); if (getHttpExchanges().isEmpty()) { tryRemoveIdleDestination(); } else { // We need to execute queued requests // even if this connection was removed. // We may create a connection that is not // needed, but it will eventually idle timeout. if (removed) <START> process(true); <END> } return connectionPool.remove(connection); }
<|startcomment|> return null ? I think you meant 'false', did not you? <|endcomment|> public boolean getRewriteBatchedStatements() { final String isRewrite = super.connectionProperties.getProperty(REWRITE_BATCHED_STATEMENTS); <START> return isRewrite == null ? null : Boolean.valueOf(isRewrite); <END> }
<|startcomment|> I am little wary about this. coz, all our existing schedulers are using this and setting this might cause them to be removed immediately. Even though ideally we want to be in that position, when rolling this out, don't want to have any unexpected behaviors. <|endcomment|> public static ScheduledExecutorService newScheduler(int numThreads, String threadNamePrefix, boolean isDaemon) { ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(numThreads, new SchedulerThreadFactory(threadNamePrefix, isDaemon)); scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false); <START> scheduler.setRemoveOnCancelPolicy(true); <END> return scheduler; }
<|startcomment|> Ah, that's what you meant. =) No, this isn't good: it's too generic, it wouldn't help you debug a failure. The validator itself has to log a warning and then return false, so that the warning can be very specific on what went wrong, i.e. the new value being beyond the maximum value allowed. <|endcomment|> public boolean setValue(T newValue) { if (!validator.validate(newValue)) { <START> LOGGER.warn("The passed value {} is invalid.", newValue); <END> return false; } PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue); this.value = newValue; dispatchChangedEvent(event); return true; }
<|startcomment|> Do we really want to move this from `trace` to `debug`? <|endcomment|> public void onMessage(MessageHolderWithTokens message) { try { <START> logger.debug("receiving tokens from queue, triggering Notification Dispatcher class to pick the right sender"); <END> dequeueEvent.fire(message); } catch (DispatchInitiationException e) { throw e; } catch (Exception e) { logger.error("NotificationDispatcher or PushNotificationSender unexpectedly failed, the message won't be redelivered", e); } }
<|startcomment|> why not: return result.addAll(cacheMap.keySet()); <|endcomment|> private Collection<Key> getRegisteredKeys() { List<Key> result = new ArrayList<Key>(); <START> for (Iterator<Key> i = cacheMap.keySet().iterator(); i.hasNext();) { result.add(i.next()); } return result; <END> }
<|startcomment|> I would make this constructor `protected` because you cannot directly instantiate abstract classes. See the answers to http://stackoverflow.com/questions/260666/can-an-abstract-class-have-a-constructor for a discussion. <|endcomment|> <START> public AbstractMetric(String metricName, String metricType, T initialValue, MetricReportManager manager) { <END> name = metricName; type = metricType; value = initialValue; metricManager = manager; }
<|startcomment|> Shouldn't this line be something like AssertTrue(allergy.hasSameValues(allergy())); ? <|endcomment|> public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues() { Allergy allergy = allergy(); <START> allergy.hasSameValues(allergy()); <END> }
<|startcomment|> You are open a stream object without closing it never. Maybe you can use the try-with-resources statement here and avoid / handle the unhandled IOException here. <|endcomment|> private static String readMapping() throws IOException, ParseException { JSONParser parser = new JSONParser(); ClassLoader classloader = Thread.currentThread().getContextClassLoader(); <START> InputStream inputStream = classloader.getResourceAsStream("mapping.json"); <END> String mapping = IOUtils.toString(inputStream, "UTF-8"); Object object = parser.parse(mapping); JSONObject jsonObject = (JSONObject) object; return jsonObject.toJSONString(); }
<|startcomment|> @mjwall I found the bug. Its my fault, I suggested clearing `observedColumns` and that is a bad thing to do. `observedColumns` is shared between transactions. It should be an immutable set, I'll open an issue for that. <|endcomment|> public synchronized void commit() throws CommitException { SyncCommitObserver sco = null; try { sco = new SyncCommitObserver(); commitAsync(sco); sco.waitForCommit(); } finally { updates.clear(); weakNotification = null; <START> observedColumns.clear(); <END> columnsRead.clear(); } }
<|startcomment|> I would simplify to "return isValid(buf,off) && (buf[off] & X_BIT != 0) && (buf[off+1] & I_BIT) != 0)" <|endcomment|> public static boolean hasPictureId(byte[] buf, int off, int len) { if (!isValid(buf, off)) return false; if ((buf[off] & X_BIT) == 0 || (buf[off+1] & I_BIT) == 0) <START> return false; <END> return true; }
<|startcomment|> remove the println <|endcomment|> public void setEnabled(boolean enabled) { this.active = enabled; <START> System.out.println("active state change: " + active); <END> updateButtonState(); }
<|startcomment|> Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations. <|endcomment|> <START> default void beforeDataProviderExecution(IDataProviderMethod dataProviderMethod, ITestNGMethod method, ITestContext iTestContext) { <END> throw new UnsupportedOperationException("Method is not implemented"); }
<|startcomment|> the inner 'if' isn't needed - the conditions can be added to the outer 'if' <|endcomment|> private void handleEndActionJobAndStep() { if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) { <START> if (!parentHasCallback() || getExecutionContext().getExecutionMethod() == ExecutionMethod.AsStep) { <END> startFinalizingStep(); } } }
<|startcomment|> why did you change the do ... while into a while do loop. The caller already knows the scan state is not equal to state and since this is a private method it is safe to assume that the caller has already checked (under the lock) that he has to wait for a state change. <|endcomment|> private boolean waitForScanState(ScanStates state) { try { <START> while (!getScanState().equals(state)) { <END> scanState.wait(); } return true; } catch (InterruptedException e) { tsLogger.logger.warn("problem waiting for scanLock whilst in state " + state.name(), e); return false; } }
<|startcomment|> Could we merge RESTORING and SUSPENDED? <|endcomment|> private void maybeScheduleCheckpoint() { switch (state()) { <START> case RESTORING: <END> this.checkpoint = checkpointableOffsets(); break; case RUNNING: if (!eosEnabled) { this.checkpoint = checkpointableOffsets(); } break; case SUSP<END>ED: this.checkpoint = checkpointableOffsets(); break; case CREATED: case CLOSED: throw new IllegalStateException("Illegal state " + state() + " while scheduling checkpoint for active task " + id); default: throw new IllegalStateException("Unknown state " + state() + " while scheduling checkpoint for active task " + id); } }
<|startcomment|> Why do you cast to HostProviderProxy? <|endcomment|> protected void executeQueryCommand() { Provider hostProvider = getProvider(); <START> HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(hostProvider)); <END> getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain())); }
<|startcomment|> We could have leveraged `InvokedMethodListener` for this. See [here](https://github.com/cbeust/testng/blob/master/src/test/java/test/InvokedMethodListener.java) <|endcomment|> public void t1() { <START> testCaseExecutionOrder.add(new Object() {}.getClass().getEnclosingMethod().getName()); <END> }
<|startcomment|> Currently when the test fails with any error then there is no stacktrace to the original failure, which I think makes pinpointing the culprit easier? That being said, this is just preference, so feel free to ignore :) <|endcomment|> public void testValidateDataStreamsNoConflicts() { Metadata metadata = createIndices(5, 10, "foo-datastream").metadata; try { <START> validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE)); <END> } catch (Exception e) { fail("did not expect exception when validating a system without indices that would conflict with future backing indices: " + e.getMessage()); } }
<|startcomment|> I dont think that this check is needed here (otherwise it will throw an index out of bounds exception, which says the same). https://github.com/libgdx/libgdx/wiki/Contributing#performance-considerations <|endcomment|> public ShaderProvider getPassShaderProvider (int n) { <START> if (n >= passShaderProviders.length) <END> throw new GdxRuntimeException("ShaderProvider " + n + " doesn't exist in " + getClass().getName()); return passShaderProviders[n]; }
<|startcomment|> stopTimer() нужно поставить где сессия закрывается вообще, а не для конкретного юзера <|endcomment|> public void onConnectionClosedForUser(QBRTCSession qbrtcSession, Integer integer) { setStatusForOpponent(integer, getString(R.string.closed)); <START> stopTimer(); <END> }
<|startcomment|> It would be better to run checks in the constructor to make sure no reconciler is null, or to create an actual list of non-null reconcilers that would be dereferenced here. <|endcomment|> public void install(ITextViewer textViewer) { for (IReconciler iReconciler : fReconcilers) { <START> if(iReconciler != null) { <END> iReconciler.install(textViewer); } } }
<|startcomment|> а мы разве можем хоть когда-то не захотеть добавлять listener - я бы это унес прям в основной webAppInitializer <|endcomment|> public JettyServer run(WebApplicationContext baseContext, boolean directlyUseAsWebAppRoot, Function<Function<Integer, JettyServer>, JettyServer> serverStarter, boolean exitOnError) { try { configureLogger(); configureSentry(baseContext); JettyServer jettyServer = createJettyServer(baseContext, directlyUseAsWebAppRoot, serverStarter, <START> v->v.addLifeCycleListener(new JettyLifeCycleListener(baseContext))); <END> jettyServer.start(); logStartupInfo(baseContext); return jettyServer; } catch (Exception e) { return logErrorAndExit(e, exitOnError); } }
<|startcomment|> AFAIK this is redundant. <|endcomment|> public PlanItem(String id, String definitionRef) { <START> super(); <END> this.id = id; this.definitionRef = definitionRef; }
<|startcomment|> Looking on `QName` class, maybe we should use `return ~~name.hashCode()`. <|endcomment|> public int hashCode() { <START> return name.hashCode(); <END> }
<|startcomment|> `LOG.debug` please to avoid overhead on operations. <|endcomment|> protected boolean copyObject(String src, String dst) { try { <START> LOG.info("Copying {} to {}", src, dst); <END> mClient.copyObject(mBucketNameInternal, src, mBucketNameInternal, dst); return true; } catch (CosClientException e) { LOG.error("Failed to rename file {} to {}", src, dst, e); return false; } }
<|startcomment|> Since the logic switch, this should be true (former behavior). <|endcomment|> public RepositorySearchDialog(Collection<String> existingDirs) { this(existingDirs, false, <START> false); <END> }
<|startcomment|> Aren't the name and description properties already added by the super class? <|endcomment|> public DelegatingResourceDescription getCreatableProperties() { DelegatingResourceDescription description = super.getCreatableProperties(); <START> description.addProperty("name"); <END> description.addProperty("location"); description.addProperty("description"); return description; }
<|startcomment|> Character should be "char" https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#charAt(int) This is returning a char (primitive type) and that is why the "=="test works I think, if it was returning Character (object wrapper for char) we would need to use ".equals" <|endcomment|> private JsonParser getParser(String data) throws IOException { // If the first character is { or [, assume this is // JSON data and use a JsonParser. Otherwise assume // YAML and use a YAMLParser. <START> Character firstChar = data.charAt(0); <END> if (firstChar == '{' || firstChar == '[') { return this.jsonFactory.createParser(data); } else { return this.yamlFactory.createParser(data); } }
<|startcomment|> Redundant cast. <|endcomment|> public void testGenerateDroolsTestOption() { ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig(); assertThat(config.isGenerateDroolsTestOnError()).isNull(); config.setGenerateDroolsTestOnError(true); <START> assertThat((boolean) config.isGenerateDroolsTestOnError()).isTrue(); <END> config.setGenerateDroolsTestOnError(Boolean.FALSE); assertThat((boolean) config.isGenerateDroolsTestOnError()).isFalse(); config.setGenerateDroolsTestOnError(null); assertThat(config.isGenerateDroolsTestOnError()).isNull(); }
<|startcomment|> Style-nit: Use curly brackets and wrap the return to next line. <|endcomment|> private RawText getRawText(ObjectId id, Repository repo) throws IOException { <START> if (id.equals(ObjectId.zeroId())) return new RawText(new byte[] {}); <END> return new RawText(repo.openBlob(id).getCachedBytes()); }
<|startcomment|> We can make this inline. ```suggestion return ";" + USER_AGENT_SUFFIX; ``` <|endcomment|> private static String getUserAgentSuffix() { String suffix = ";" + USER_AGENT_SUFFIX; <START> return suffix; <END> }
<|startcomment|> you don't validate in other builders method (and you don't have to) <|endcomment|> public Builder setDataSize(Estimate dataSize) { <START> this.dataSize = requireNonNull(dataSize, "dataSize can not be null"); <END> return this; }
<|startcomment|> Statement can be rewritten inline. <|endcomment|> public boolean isExpired(Date invocationDate) { if (getExpires() != null) { Date currentInvocationDate = invocationDate == null ? new Date() : invocationDate; <START> return getExpires().before(currentInvocationDate); <END> } return false; }
<|startcomment|> Is this really needed? <|endcomment|> public void stop() { if (isRunning()) { process.destroy(); try { if (stdout !=null) { <START> stdout.close(); <END> } if (stdin !=null) { stdin.close(); } } catch (IOException e) { throw new RuntimeException(e.getMessage(),e); } finally { running.set(false); } } }
<|startcomment|> Actually since MacroId is not really supposed to be extended you could replace this with a `if (!(object instanceof MacroId))`. Can't be null if it's an instance of MacroId. Also I would put it after the `if (object == this)` test instead of before. <|endcomment|> public boolean equals(Object object) { <START> if (object == null || object.getClass() != getClass()) { <END> return false; } if (object == this) { return true; } MacroId rhs = (MacroId) object; return new EqualsBuilder() .append(getId(), rhs.getId()) .append(getSyntax(), rhs.getSyntax()) .isEquals(); }
<|startcomment|> this is public API, we can't lower the visibility without deprecating first <|endcomment|> <START> Map<String, Object> getExtraInformation() { <END> return extraInformation; }
<|startcomment|> neat. <|endcomment|> public int hashCode() { <START> return Objects.hash(pointer, ownerName, owner, readers, writers); <END> }
<|startcomment|> What about the same when the list is empty, it still adds `-Xfriend-paths=` option? <|endcomment|> private String getFriendsPath( SourcePathResolver sourcePathResolver, ImmutableList<SourcePath> friendPathsSourcePaths) { // https://youtrack.jetbrains.com/issue/KT-29933 ImmutableSortedSet<String> absoluteFriendPaths = ImmutableSortedSet.copyOf( friendPathsSourcePaths .stream() .map(path -> sourcePathResolver.getAbsolutePath(path).toString()) .collect(Collectors.toSet())); return "-Xfriend-paths=" <START> + absoluteFriendPaths.stream().reduce("", (path1, path2) -> path1 + "," + path2); <END> }
<|startcomment|> Do we need super(), if the class is not inheriting from a super class? <|endcomment|> public Target(String targetUriAsString) { <START> super(); <END> Assert.hasText(targetUriAsString, "The provided targetUriAsString must neither be null nor empty."); this.targetUri = URI.create(targetUriAsString); }
<|startcomment|> Minor, but rather than duplicating lines 44 - 51, perhaps put them in a private method invoked by both constructors, or have this constructor invoke the other. <|endcomment|> public PropertyInvertedRegexTester(IPersonAttributesGroupTestDefinition definition) { super(definition); final String propertyName = definition.getTestValue(); String regexExpression = PropertiesManager.getProperty (propertyName, ""); if (StringUtils.isBlank(regexExpression)) { logger.error("Unable to find property name {} in portal.properties or has empty value." + " PAGS PropertyInvertedRegexTester will always return true for attribute {}", propertyName, definition.getAttributeName()); } setPattern(regexExpression); <START> } <END>
<|startcomment|> Looking bad indeed, I fixed later during my work on the branch: https://github.com/apache/wicket/pull/210/commits/b64f2b4b2cb50a594cabb50a0c1eeca43485f6b9#diff-36b11db0d92a540368a080c520de953aL177 The three states looks overcomplicated. There's no place in Wicket core needing to test such flag for the value "OLD". <|endcomment|> public final boolean doesProvideNewPage() { if (provision == null) { <START> throw new IllegalStateException("Page instance not yet resolved"); <END> } return getProvision().doesProvideNewPage(); }
<|startcomment|> This doesn't look thread-safe. <|endcomment|> private Handler getHandler() { <START> if (mHandler == null) { <END> // Use current main looper mHandler = new Handler(mContext.getMainLooper()); } return mHandler; }
<|startcomment|> Let's remove this behavior. `setDebugging` will only affect the indicators. <|endcomment|> @SuppressWarnings("UnusedDeclaration") @Deprecated public void setDebugging(boolean debugging) { setIndicatorsEnabled(debugging); <START> setLoggingEnabled(debugging); <END> }
<|startcomment|> I guess we no longer need `store` to be of `ConcurrentHashMap` implementation if we are fully locking it. <|endcomment|> public List<ServerTemplate> load() { synchronized (store) { return store.values().stream().map(e -> cloneServerTemplate(e)).collect(Collectors.toList()); <START> } <END> }
<|startcomment|> if `learnerMaster` is `null` here then you'll get a NPE on the `learnerMaster.addr.getReachableOrOne()` above. <|endcomment|> public String getLearnerMaster() { QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster(); InetSocketAddress address = learnerMaster.addr.getReachableOrOne(); <START> if (learnerMaster == null || address == null) { <END> return "Unknown"; } return address.getAddress().getHostAddress() + ":" + address.getPort(); }
<|startcomment|> I think we should drop redundant "Task" suffix from the task types e.g.: "nestedTask" -> "nested" "withSideEffectTask" -> "withSideEffect" "timeoutTask" -> "timeout" "withTimeoutTask" -> "withTimeout" <|endcomment|> default <R> Task<R> flatMap(final String desc, final Function1<? super T, Task<R>> func) { ArgumentUtil.requireNotNull(func, "function"); final Task<Task<R>> nested = map("map: " + desc, func); nested.getShallowTraceBuilder().setSystemHidden(true); <START> nested.getShallowTraceBuilder().setTaskType("nestedTask"); <END> return flatten(desc, nested); }
<|startcomment|> As stated above, I don't see the need for this method to throw an exception. <|endcomment|> protected List<String> findStringsInFileCommon(String regexp, boolean stopOnFirst, int searchLimit, File fileToSearch) <START> throws Exception { <END> return findStringsInFileCommon(regexp, stopOnFirst, searchLimit, fileToSearch, Project.MSG_INFO); }
<|startcomment|> can you pass null in here for the status, I recently refactored similar code, and status should not be part of the event. <|endcomment|> public void notifyAboutStartProcess(String id) { Long processInstanceId = Long.parseLong(id); newProcessInstanceEvent.fire(new NewProcessInstanceEvent(serverTemplateId, deploymentId, processInstanceId, processDefId, processName, <START> 1)); <END> final String message = Constants.INSTANCE.ProcessStarted(processInstanceId.longValue()); notificationEvent.fire(new NotificationEvent(message, NotificationEvent.NotificationType.SUCCESS)); close(); }
<|startcomment|> I don't understand what this check is doing here. maybeMove is already taking check of checking rights. <|endcomment|> protected void process(final SpaceReference source, final SpaceReference destination) { visitDocuments(source, new Visitor<DocumentReference>() { @Override public void visit(DocumentReference oldChildReference) { DocumentReference newChildReference = oldChildReference.replaceParent(source, destination); <START> if (MoveJob.this.hasAccess(Right.VIEW, newChildReference)) { <END> maybeMove(oldChildReference, newChildReference); } } }); }
<|startcomment|> same, we can delete LogReplicationDiscoveryServiceException.java file now. <|endcomment|> <START> public void processEvent(DiscoveryServiceEvent event) throws LogReplicationDiscoveryServiceException { <END> log.info("Process event {}", event.getType()); switch (event.type) { case DISCOVER_INIT_TOPOLOGY: startDiscovery(); break; case ACQUIRE_LOCK: processLockAcquire(); break; case RELEASE_LOCK: processLockRelease(); break; case DISCOVERED_TOPOLOGY: processTopologyChangeNotification(event); break; case UPGRADE: processUpgrade(event); break; default: log.error("Invalid event type {}", event.type); } }
<|startcomment|> Don't really like firing events when holding locks on things... If anything that receives a ProgramErrorDeletedEvent tries to access the ErrorManager (which is not altogether unreasonable!) you'll end up with a nasty deadlock. Could we just make errors a ConcurrentSkipListSet and drop all the synchronization? <|endcomment|> public void deleteError(final ProgramError error) { synchronized (errors) { errors.remove(error); <START> eventBus.publish(new ProgramErrorDeletedEvent(error)); <END> } }
<|startcomment|> Can remove checkNotNull, we have external @NonNull annotation on Collections.emptyList(). <|endcomment|> public LamiTableContentProvider() { fCurrentEntries = <START> checkNotNull(Collections.emptyList()); <END> }
<|startcomment|> in case of switching, in my opinion it's better to us etry/finnally like that: ``` switchToIFrame(); try { waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); return new ArticlePageObject(driver); }finally { switchOutOfIFrame(); } ``` it's clearer in reading <|endcomment|> public ArticlePageObject clickGetInfoLink() { switchToIFrame(); waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); switchOutOfIFrame(); <START> return new ArticlePageObject(driver); <END> }
<|startcomment|> would this work? (also removing the import) ```suggestion .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice); ``` <|endcomment|> @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent() { SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setAdviceChain(new CacheInterceptor()); assertThat(rabbitTracing.decorateSimpleRabbitListenerContainerFactory(factory).getAdviceChain()) .hasSize(2) <START> .matches(adviceArray -> asList(adviceArray).get(0) instanceof TracingRabbitListenerAdvice); <END> }
<|startcomment|> Use ArrayList<> <|endcomment|> private static List<IResource> getReadonlyFiles(IResource[] resources) { <START> List<IResource> readOnlyFiles= new ArrayList<IResource>(); <END> for (int i= 0; i < resources.length; i++) { IResource resource= resources[i]; ResourceAttributes resourceAttributes= resource.getResourceAttributes(); if (resource.getType() == IResource.FILE && resourceAttributes != null && resourceAttributes.isReadOnly()) readOnlyFiles.add(resource); } return readOnlyFiles; }
<|startcomment|> I think this is not necessary as the GC will remove it as soon as there is no more reference on the Object <|endcomment|> void clean(K key) { List<V> data = getDataMap().get(key); if (data != null) { <START> data.clear(); <END> } getDataMap().remove(key); }
<|startcomment|> IllegalArgumentException sounds better here. <|endcomment|> public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) { if (!isMemory(memoryDevice)) { <START> throw new RuntimeException("Memory device expected but device " + memoryDevice + " obtained."); <END> } return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent() && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent(); }
<|startcomment|> Would be nice if you add here an exception text. Something like "unable to load the list of connector configurations" <|endcomment|> public boolean connectorExists(String id) { try { List<ConnectorConfiguration> list = configPersistence.load(ImmutableMap.of(Constants.CONNECTOR_PERSISTENT_ID, id)); if (list.isEmpty()) { return false; } return true; } catch (PersistenceException e) { <START> throw new RuntimeException(e); <END> } }
<|startcomment|> can we maybe have separate test cases for the returning clause? <|endcomment|> public void testUpdateStmtBuilder() { printStatement("update foo set \"column['looks_like_nested']\"=1"); printStatement("update foo set foo.a='b'"); printStatement("update bar.foo set bar.foo.t=3"); printStatement("update foo set col['x'] = 3"); printStatement("update foo set col['x'] = 3 where foo['x'] = 2"); printStatement("update schemah.foo set foo.a='b', foo.b=foo.a"); printStatement("update schemah.foo set foo.a=abs(-6.3334), x=true where x=false"); printStatement("update foo set foo='a' returning id"); printStatement("update foo set foo='a' where x=false returning id"); printStatement("update foo set foo='a' returning id AS foo"); printStatement("update foo set foo='a' returning id + 1 AS foo, id -1 as bar"); <START> } <END>
<|startcomment|> nit: I know that in other parts of this class we put the requireNonNull calls inside another method call, but let's not do it here for the sake of slightly better readability: ``` requireNonNull(path, "path is null"); setPath.set(path); ``` <|endcomment|> public void setSetPath(String path) { <START> setPath.set(requireNonNull(path, "path is null")); <END> }
<|startcomment|> Something like this: ``` public EnvVars getEnvironment() throws IOException, InterruptedException { EnvVars cachedEnvironment = this.cachedEnvironment; if (cachedEnvironment != null) { return cachedEnvironment; cachedEnvironment = EnvVars.getRemote(getChannel()); // all non-null values should be equivalent so in a race it doesn't matter who wins this.cachedEnvironment = cachedEnvironment; return cachedEnvironment; } ``` <|endcomment|> public EnvVars getEnvironment() throws IOException, InterruptedException { if (cachedEnvironment != null) { <START> return cachedEnvironment; <END> } cachedEnvironment = EnvVars.getRemote(getChannel()); return cachedEnvironment; }
<|startcomment|> why should add lock here? <|endcomment|> public int getMaxCapacity() { <START> readLock.lock(); <END> try { return maxCapacity; } finally { readLock.unlock(); } }
<|startcomment|> Can you use isEmpty()? <|endcomment|> public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser() { List<VDS> result = dao.getAllForVdsGroup(existingVds.getvds_group_id(), UNPRIVILEGED_USER_ID, true); assertNotNull(result); <START> assertTrue(result.size() == 0); <END> }
<|startcomment|> Я еще люблю в сообщение вставлять изначальный exception, nипа "Failed to check data source " + e.toString(), e). <|endcomment|> private static DataSource createC3P0DataSource(String name, Map<Object, Object> properties) { ComboPooledDataSource ds = new ComboPooledDataSource(false); ds.setDataSourceName(name); ds.setIdentityToken(name); new BeanMap(ds).putAll(properties); C3P0Registry.reregister(ds); try { checkDataSource(ds, name); } catch (SQLException e) { <START> throw new RuntimeException("Failed check data source", e); <END> } return ds; }
<|startcomment|> no need to center it, just give it SWT.NONE <|endcomment|> protected Control createPageControls(Composite parent) { setTitle(Messages.RemoveReviewerDialog_Remove_Reviewer); <START> Label label = new Label(parent, SWT.CENTER); <END> label.setText( NLS.bind(Messages.RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove, userToRemove.getDisplayName())); return parent; }
<|startcomment|> I think you need to call super otherwise you loose the permissions that you need to check by default. <|endcomment|> public List<PermissionSubject> getPermissionCheckSubjects() { List<PermissionSubject> list = new ArrayList<PermissionSubject>(); Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue(); list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup())); QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId()); return list; <START> } <END>
<|startcomment|> This is actually wrong but it is an error that has propagated to all drivers. The init struct has size 2 and not size 1. We are saved by ignoring the struct size when we read the init message. <|endcomment|> public void onInit( String clientName, Map<String,Object> credentials ) throws IOException { <START> packer.packStructHeader( 1, INIT.signature() ); <END> packer.pack( clientName ); packer.pack( ValueUtils.asMapValue( credentials ) ); onMessageComplete.onMessageComplete(); }
<|startcomment|> Remove the public modifier <|endcomment|> <START> public SecurityGroupExtensionProvider(NeutronSecurityGroupExtension neutronSecurityGroupExtension, <END> NovaSecurityGroupExtension novaSecurityGroupExtension) { this.neutronSecurityGroupExtension = neutronSecurityGroupExtension; this.novaSecurityGroupExtension = novaSecurityGroupExtension; }
<|startcomment|> @vilchik-elena Do we need this block? <|endcomment|> private static ExpressionTree getComparedWithNullExpression(ExpressionTree expression, Tree.Kind kind) { ExpressionTree comparedExpression = getExpressionEqualNullWithAnd(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionNotEqualNullWithOr(expression, kind); if (comparedExpression == null) { comparedExpression = getExpressionComparedWithFunction(expression, kind); <START> if (comparedExpression == null) { <END> return null; } } } return comparedExpression; }
<|startcomment|> Is the `(Runnable)` needed? <|endcomment|> private void scheduleRefresh(Duration delay) { // already stopped? avoids rejection exception if (executor.isShutdown()) { return; } <START> executor.schedule((Runnable) this::refresh, delay.toMillis(), TimeUnit.MILLISECONDS); <END> }
<|startcomment|> Technically, you should `queryRunner.close()` (or t-w-r). This would ensure proper cleanup of any temp files (or whatevers) it might have created <|endcomment|> public static void main(String[] args) { <START> LocalQueryRunner queryRunner = createLocalQueryRunner(ImmutableMap.of("reorder_joins", "false")); <END> new SqlConsecutiveJoinBenchmark(queryRunner).runBenchmark(new SimpleLineBenchmarkResultWriter(System.out)); }
<|startcomment|> Shouldn't they be protected not public? <|endcomment|> <START> public void beforeStartingVertx(VertxOptions options) { <END> }
<|startcomment|> Ah, so I guess that lack of a Guice context here (and above) is the reason for the system properties? How do we solve that elsewhere in jclouds? Would we inject some kind of factory object via Guice? <|endcomment|> public Builder body(String json) { checkNotNull(json, "body required"); checkArgument(json.getBytes().length <= getInteger(MESSAGE_BODY_MAX_IN_BYTES), <START> "json size must be <= %s bytes", getInteger(MESSAGE_BODY_MAX_IN_BYTES)); <END> this.body = new JsonBall(json).toString(); return self(); }
<|startcomment|> s/"Bearer"/BEARER <|endcomment|> private String getTokenFromHeader(HttpServletRequest request) { String token = null; String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION); if (headerValue != null && headerValue.startsWith(BEARER)) { token = <START> headerValue.substring("Bearer".length()).trim(); <END> } return token; }
<|startcomment|> This method should not be public or what's the point? <|endcomment|> <START> public static CDIProvider getCDIProvider() { <END> if (configuredProvider != null) { return configuredProvider; } else { // Discover providers and cache if (discoveredProviders == null) { synchronized (lock) { if (discoveredProviders == null) { findAllProviders(); } } } configuredProvider = discoveredProviders.stream() .filter(c -> c.getCDI() != null) .findAny().orElseThrow(() -> new IllegalStateException("Unable to access CDI")); return configuredProvider; } }
<|startcomment|> The Exception is never thrown. <|endcomment|> <START> public void testIsDrawable_Stage() throws Exception { <END> testIsDrawable(CaseManagementDiagram.class, AdHocSubprocess.class, true); }
<|startcomment|> The container exists method should already return false [if the container exists call returns a 404](https://github.com/jclouds/jclouds/blob/master/providers/azureblob/src/main/java/org/jclouds/azureblob/AzureBlobClient.java#L156). Worth removing the catch, as it might be caused by other errors that should be taken into acount? <|endcomment|> public static boolean customImageExists(String storage, String key) { final AzureBlobClient azureBlob = ContextBuilder.newBuilder("azureblob") .credentials(storage, key) .buildApi(AzureBlobClient.class); try { return azureBlob.containerExists("system"); } catch (Exception e) { e.printStackTrace(); return false; <START> } <END> finally { Closeables2.closeQuietly(azureBlob); } }
<|startcomment|> Nit: By convention, this is almost always the first thing called, unless there's a explicit reason why it needs to happen after (which is usually a code smell) <|endcomment|> public void enter() { mUseEap = (IkeSessionOptions.IKE_AUTH_METHOD_EAP == mIkeSessionOptions.getLocalAuthConfig().mAuthMethod); <START> super.enter(); <END> }
<|startcomment|> you can static import these functions. <|endcomment|> public static Predicate<Expression> isInferenceCandidate() { return expression -> { expression = normalizeInPredicateToEquality(expression); if (expression instanceof ComparisonExpression && DeterminismEvaluator.isDeterministic(expression) && <START> !NullabilityAnalyzer.mayReturnNullOnNonNullInput(expression) && <END> !isDynamicFilter(expression)) { ComparisonExpression comparison = (ComparisonExpression) expression; if (comparison.getType() == ComparisonExpressionType.EQUAL) { // We should only consider equalities that have distinct left and right components return !comparison.getLeft().equals(comparison.getRight()); } } return false; }; }
<|startcomment|> why is this needed? <|endcomment|> public void startMasters() throws Exception { mMaster = LocalAlluxioMaster.create(mWorkDirectory, true); mMaster.start(); <START> CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.CLIENT); <END> }
<|startcomment|> mind the code style <|endcomment|> public Proxy getProxy() { <START> if (mProxyHost == null) return null; <END> Proxy.Type type = null; switch (mProxyType) { case TYPE_HTTP: type = Proxy.Type.HTTP; break; case TYPE_SOCKS: type = Proxy.Type.SOCKS; break; } return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort)); }
<|startcomment|> nit: you can merge both lines above as `checkNotNull` will return the given argument <|endcomment|> public HttpRequest setMethod(HttpMethod method) { ObjectUtil.checkNotNull(method, "method"); <START> this.method = method; <END> return this; }
<|startcomment|> a matter of taste - types can be avoided for the sake of return statements from the if-else block. <|endcomment|> public Set<VmDeviceGeneralType> getDeviceTypesWithProperties(Version version) { if (!FeatureSupported.deviceCustomProperties(version)) { return Collections.emptySet(); } <START> Set<VmDeviceGeneralType> types; <END> EnumMap<VmDeviceGeneralType, Map<String, Pattern>> map = deviceProperties.get(version); if (map.isEmpty()) { // no device type has any properities types = Collections.emptySet(); } else { // prevent client to modify types = Collections.unmodifiableSet(map.keySet()); } return types; }
<|startcomment|> generic has come with mars. Consequently that code won't compile against previous platform <|endcomment|> public SWTBotSiriusDiagramEditor(final IEditorReference reference, final SWTWorkbenchBot bot) throws WidgetNotFoundException { super(reference, bot); GraphicalViewer graphicalViewer = UIThreadRunnable.syncExec(new Result<GraphicalViewer>() { @Override public GraphicalViewer run() { final IEditorPart editor = partReference.getEditor(true); <START> return editor.getAdapter(GraphicalViewer.class); <END> } }); ReflectionHelper.setFieldValueWithoutException(this, "viewer", new SWTBotSiriusGefViewer(graphicalViewer), this.getClass().getSuperclass()); }
<|startcomment|> I'd prefer that we handled it (the snapshot type) in a separate change. <|endcomment|> public CreateAllSnapshotsFromVmParameters() { needsLocking = true; <START> snapshotType = SnapshotType.REGULAR; <END> saveMemory = true; diskIdsToIgnoreInChecks = Collections.emptySet(); }
<|startcomment|> afacit vvv is all noise <|endcomment|> public SchedulerTask<?> createTaskInstance( String taskType ) throws IllegalArgumentException <START> { <END> try { return lookupTask( taskType ); } catch ( ComponentLookupException e ) { this.logger.debug( "Failed to load Schedule Task: " + taskType, e ); throw new IllegalArgumentException( "Could not create task of type" + taskType, e ); } }
<|startcomment|> It worries me a bit to imagine that _each_ decorator will start its own service (whatever that means, I'm not familiar with papyrus services) Can you check whether this is a common way of using services? Would it be possible to share a common instance somehow between decorators? <|endcomment|> public PapyrusStereotypedElementItemProviderDecorator(ComposeableAdapterFactory adapterFactory) { super(adapterFactory); <START> labelProviderService = new LabelProviderServiceImpl(); <END> try { labelProviderService.startService(); } catch (ServiceException ex) { Activator.getDefault().getLog().log( new Status(IStatus.WARNING, Activator.PLUGIN_ID, "Unable to start Papyrus Label Provider Service", ex)); //$NON-NLS-1$ } }
<|startcomment|> Why not rely on `Optional`, rather than introducing another method which could lead to NPEs? <|endcomment|> <START> default SourceMap sourceMap() { <END> return null; }
<|startcomment|> Why do we create empty directory for all tests that extend this class? I guess need to create it only for those tests that need it. <|endcomment|> public static void setupDefaultTestCluster() throws Exception { config = DrillConfig.create(cloneDefaultTestConfigProperties()); classpathScan = ClassPathScanner.fromPrescan(config); openClient(); // turns on the verbose errors in tests // sever side stacktraces are added to the message before sending back to the client test("ALTER SESSION SET `exec.errors.verbose` = true"); <START> emptyDirCreating(); <END> }
<|startcomment|> As I am looking at the code, this is not necessary wrong, but maybe it would be better to throw new RuntimeException() in the end of the method. It's up to you what do you prefer. <|endcomment|> private static String parseAnnotationFieldTypeName(final Supplier<Class<?>> theTypeSupplier, final String errorMessage) { try { theTypeSupplier.get(); <START> throw new RuntimeException(errorMessage); <END> } catch (MirroredTypeException mte) { return mte.getTypeMirror().toString(); } }
<|startcomment|> return `null` instead when there is no priority <|endcomment|> default StreamPriority getStreamPriority() { <START> return StreamPriority.DEFAULT; <END> }
<|startcomment|> ?? Pourquoi cette ligne. Bootstrap est déjà une classe concrète... <|endcomment|> protected void configure() { bind(EventDao.class).to(EventDaoInMemory.class).asEagerSingleton(); <START> bind(Bootstrap.class); <END> }
<|startcomment|> Second `ENABLED` check is not necessary if you have the first one. <|endcomment|> public static void onAdvancementEvent(AdvancementEvent event) { <START> if (ENABLED && event.getAdvancement().getDisplay() != null && event.getAdvancement().getDisplay().shouldAnnounceToChat()) <END> { logger.info("{} got the {} advancement", event.getEntityPlayer().getDisplayNameString(), event.getAdvancement().getDisplayText().getUnformattedText()); } }
<|startcomment|> let's use URI.create and avoid try/catch <|endcomment|> public ExampleEndpointsProvider() { // Put custom code here to get endpoints // In our case they will be hardcoded try { JHttpEndpoint httpEndpoint = new JHttpEndpoint(new URI("https://jagger.griddynamics.net:443")); <START> endpoints.add(httpEndpoint); <END> } catch (URISyntaxException e) { throw new IllegalStateException(e); } }
<|startcomment|> do we need any content in this constructor at all? <|endcomment|> public SlackUserProperty() { <START> this.userId = null; <END> this.disableNotifications = false; }
<|startcomment|> do return <|endcomment|> public void onStreamCreate(IMediaStream stream) { <START> if (!stream.isTranscodeResult()) { <END> PacketListener listener = new PacketListener(); WMSProperties props = stream.getProperties(); synchronized (props) { props.setProperty(STREAM_ACTION_LISTENER_PROPERTY, listener); } stream.addLivePacketListener(listener); } }
<|startcomment|> result -> size <|endcomment|> public long getEstimatedSizeInBytes() { <START> int result = INSTANCE_SIZE; <END> result += sizeOf(levelOffsets); result += tree.sizeOf(); for (T item : items) { result += item.getEstimatedSizeInBytes(); } return result; }
<|startcomment|> `==` instead of `.equals` (in both instances) would make this null-safe <|endcomment|> public boolean respondsTo(RunEvent event) { Run r = event.getEventObject(); <START> if (event.getEventType().equals(MisoEventType.RUN_FAILED) && r.getHealth().equals(HealthType.Failed)) { <END> log.info("Run " + r.getAlias() + ": " + event.getEventMessage()); return true; } return false; }
<|startcomment|> en profiter pour enlever cette variable intermédiaire? <|endcomment|> public boolean isEnabled() { <START> final boolean res = super.isEnabled() || isDirty(); <END> return res; }
<|startcomment|> If I understand this change correctly, this shouldn't be needed anymore? <|endcomment|> private void updateSslVerifyUser(boolean value) { StoredConfig userConfig = GlobalConfigCache.getInstance() .getUserConfig(); try { <START> userConfig.load(); <END> updateSslVerify(userConfig, value); } catch (IOException | ConfigInvalidException e) { // Log it, but otherwise ignore here. LOG.error(MessageFormat.format(JGitText.get().userConfigFileInvalid, userConfig, e)); } }
<|startcomment|> this method could be static i guess? more relevant: is this method necessary? i only see one usage <|endcomment|> <START> private boolean isUserBrickAdapter(BaseAdapter baseAdapter) { <END> return baseAdapter instanceof UserBrickAdapter; }
<|startcomment|> Please check if the fragment exists. It could lead to a null-pointer exception. <|endcomment|> private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor(CategoryListItem categoryListItem) { FormulaEditorFragment formulaEditorFragment = ((FormulaEditorFragment) getFragmentManager() .findFragmentByTag(FormulaEditorFragment.FORMULA_EDITOR_FRAGMENT_TAG)); <START> formulaEditorFragment.addResourceToActiveFormula(categoryListItem.nameResId); <END> return formulaEditorFragment; }
<|startcomment|> Shouldn't this return ReviewCategoryStrategy.NONE? Otherwise why do we have ReviewCategoryStrategy.NONE if null means NONE too? <|endcomment|> public final ReviewCategoryStrategy reviewCategoryStrategy() { String s = reviewCategeoryStrategyRaw(); return s != null ? ReviewCategoryStrategy.valueOf(s) : <START> null; <END> }
<|startcomment|> `metastore` is nullable here <|endcomment|> public Iterable<ConnectorFactory> getConnectorFactories() { <START> return ImmutableList.of(new HiveConnectorFactory(name, getClassLoader(), Optional.of(metastore))); <END> }
<|startcomment|> Did you apply saveaction? <|endcomment|> public void testDBConnectionTimeMetrics() { <START> metrics.setDBConnectionTime(14); <END> assertEquals(14, testUtil.getGaugeValue("dbConnectionTime")); }
<|startcomment|> I think I like 20 better, to exercise the key migration code more. <|endcomment|> protected void createCacheManagers() throws Throwable { ConfigurationBuilder builder = getDefaultClusteredCacheConfig(getCacheMode(), true); <START> builder.clustering().stateTransfer().chunkSize(200).sync().replTimeout(45, TimeUnit.SECONDS); <END> createClusteredCaches(4, cacheName(), builder); }
<|startcomment|> getFullName() <|endcomment|> private String getByAccountName(CodeReviewCommit codeReviewCommit) { Account account = getAccount(codeReviewCommit); if (account != null && account.getFullName() != null) { return " by " + <START> account.getUserName(); <END> } return ""; }
<|startcomment|> I believe the Auth system should remain on in this method. <|endcomment|> public void findByUndefinedSchema() throws Exception { <START> context.turnOffAuthorisationSystem(); <END> getClient().perform(get("/api/core/metadatafields/search/bySchema") .param("schema", "undefined")) .andExpect(status().isOk()) .andExpect(content().contentType(contentType)) .andExpect(jsonPath("$.page.size", is(20))) .andExpect(jsonPath("$.page.totalElements", is(0))); }
<|startcomment|> private static <|endcomment|> <START> private void addAll(QuantileDigest digest, long... values) <END> { requireNonNull(values, "values is null"); for (long value : values) { digest.add(value); } }
<|startcomment|> Move this to default. <|endcomment|> protected Object encodeCommand(Command command) { initDevicePassword(command, LaipacProtocolDecoder.DEFAULT_DEVICE_PASSWORD); switch (command.getType()) { case Command.TYPE_CUSTOM: return formatCommand(command, "{%s}", Command.KEY_DATA); case Command.TYPE_POSITION_SINGLE: return formatCommand(command, "AVREQ,{%s},1", Command.KEY_DEVICE_PASSWORD); case Command.TYPE_REBOOT_DEVICE: return formatCommand(command, "AVRESET,{%s},{%s}", Command.KEY_UNIQUE_ID, Command.KEY_DEVICE_PASSWORD); default: break; } <START> return null; <END> }
<|startcomment|> We shouldn't need to check or clear any fields here, as `SelectObjectContentResult` is a `Closeable` which guarantees that `close()` is idempotent: > If the stream is already closed then invoking this method has no effect. <|endcomment|> public void close() throws IOException { <START> if (selectObjectContentResult != null) { <END> selectObjectContentResult.close(); selectObjectContentResult = null; selectObjectRequest = null; } }
<|startcomment|> `get()`. (Btw since `inner` is plain, this check may end up hoisted and you'd never see it turning null). <|endcomment|> @Override public boolean isDisposed() { <START> return inner == null; <END> }
<|startcomment|> I think that we need `super.close()` here. <|endcomment|> public void close() throws IOException { if (s3Object != null) { <START> s3Object.close(); <END> } }
<|startcomment|> (z, z) certainly doesn't look right. <|endcomment|> public void loadChunk(int x, int z) { <START> w.loadChunk(z, z); <END> }
<|startcomment|> rm public <|endcomment|> <START> public GeneratorUtil(TypeOracle typeOracle, <END> Logger logger, GeneratorContext generatorContext) { this.typeOracle = typeOracle; this.logger = logger; this.generatorContext = generatorContext; }
<|startcomment|> replace equals with == for enums. <|endcomment|> protected boolean failPassthroughVnicHotPlug() { if <START> (VmInterfaceType.pciPassthrough.equals(VmInterfaceType.forValue(getParameters().getNic().getType()))) <END> { addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED); return true; } return false; }
<|startcomment|> It would be great if this map could use generics so we know what it contains. <|endcomment|> <START> public List<Map> getStageReachedCounts(Context context) throws SQLException { <END> return workspaceItemDAO.getStageReachedCounts(context); }
<|startcomment|> usually this `) {` is on the next line <|endcomment|> Evaluator( final ObjectMapper mapper, final AsyncTaskExecutor asyncTaskExecutor, <START> final long timeoutLength) { <END> this.mapper = mapper; this.asyncTaskExecutor = asyncTaskExecutor; this.timeoutLength = timeoutLength; }
<|startcomment|> do we still need to throw exception here? if not, you can remove the next TODO <|endcomment|> public MetaMasterSync(Address masterAddress, MetaMasterMasterClient masterClient) <START> throws IOException { <END> // TODO(lu) should avoid throw exception in Java constructor to avoid half-baked class instances mMasterAddress = masterAddress; mMasterClient = masterClient; mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT_MS); mLastSuccessfulHeartbeatMs = System.currentTimeMillis() - mHeartbeatTimeoutMs; }
<|startcomment|> Seems me a ```` listeners.forEach(listener -> layerDeleted(layerName)); ```` would have been at the same time more compact, readable, and faster (streams are very slow) <|endcomment|> public void sendLayerDeleted(String layerName) { <START> listeners.stream().forEachOrdered(listener->{ <END> listener.layerDeleted(layerName); }); }
<|startcomment|> Please immutable collection. <|endcomment|> public List<SqlIdentifier> getProjectionFields(MetadataType metadataLevel, OptionManager options) { <START> List<SqlIdentifier> columnList = new ArrayList<>(); <END> columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_FQN_COLUMN_LABEL), SqlParserPos.ZERO)); columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL), SqlParserPos.ZERO)); return columnList; }
<|startcomment|> can TypedSnapshotBase constructor take SnapshotBase instead of Snapshot? <|endcomment|> protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) { <START> super((Snapshot)tx, encoder, tl); <END> this.tx = tx; this.encoder = encoder; this.tl = tl; }
<|startcomment|> `permissions` can't be `null`, otherwise the constructor would throw a NPE. <|endcomment|> public int hashCode() { int result = name != null ? name.hashCode() : 0; <START> result = 31 * result + (permissions != null ? permissions.hashCode() : 0); <END> result = 31 * result + mask; return result; }
<|startcomment|> this.contributor <|endcomment|> public EEFTabbedPropertySheetPage(Object contributor, String contributorId) { if (contributor instanceof IEEFTabbedPropertySheetPageContributor) { this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor; } else { this.contributor = new ContributorWrapper(contributor, contributorId); } this.registry = <START> EEFTabbedPropertyRegistry.getDefault(this.contributor.getContributorId()); <END> }
<|startcomment|> You should probably extract the world-stream extraction to its own method. <|endcomment|> public List<String> getSuggestions(String input) { <START> return WorldEdit.getInstance().getPlatformManager() <END> .queryCapability(Capability.GAME_HOOKS).getWorlds().stream() .map(World::getId) .filter(world -> world.startsWith(input)) .collect(Collectors.toList()); }
<|startcomment|> I don't understand something - now we will perform the this command for one host and then the connection will be removed from db, how we will perform the disconnect for other hosts? the load of connection will return null..no? you should take care of that i guess. <|endcomment|> <START> protected void executeCommand() { <END> //disconnect the connection from vdsm boolean isStorageDisconnectSucceeded = disconnectStorage(); if(isStorageDisconnectSucceeded) { String connectionId = getConnection().getid(); if(StringUtils.isNotEmpty(connectionId)) { //remove the connection record from db getDbFacade().getStorageServerConnectionDao().remove(connectionId); setSucceeded(true); } } }
<|startcomment|> curious: why remove `anyTree`? <|endcomment|> public void testNotEliminateSorts() { @Language("SQL") String sql = "SELECT quantity, row_number() OVER (ORDER BY quantity) FROM lineitem ORDER BY tax"; PlanMatchPattern pattern = anyTree( sort( <START> window(windowMatcherBuilder -> windowMatcherBuilder <END> .specification(windowSpec) .addFunction(functionCall("row_number", Optional.empty(), ImmutableList.of())), anyTree(LINEITEM_TABLESCAN_Q)))); assertUnitPlan(sql, pattern); }
<|startcomment|> Perform this operation in the custom ProgramFinder.findProgram() method instead. <|endcomment|> public Program getAssociatedProgram(Artifact artifact) { String extension = getAssociatedExtension(artifact); Program program = <START> ProgramFinder.findProgram(extension.toLowerCase()); <END> if (program == null) { throw new OseeArgumentException("No program associated with the extension [%s] found on your local machine.", extension); } return program; }
<|startcomment|> Please replace all the occurrences of `AbstractTree.this`. Indeed, the code style we are using does not recommend to add `this` as a prefix of a function call when the function is in the current object. <|endcomment|> public final Iterable<N> toDepthFirstIterable() { <START> return () -> AbstractTree.this.depthFirstIterator(); <END> }
<|startcomment|> This is definitely a leftover that must be removed. <|endcomment|> void put(final K key, final V value) { clusterRegistry.put(scope, key, value); <START> System.out.println("putting key "+key+" ffrom thread "+Thread.currentThread().getName()); <END> localCacheInsert(key, value); }
<|startcomment|> Missed a space here between the `)` and `{` <|endcomment|> <START> public static String getWarningMessages(String filename){ <END> String warningMessage = ""; if (getErrorMessage(filename).length() == 0 && filename.length() > 0) { if (!filename.matches("[A-Za-z][A-Za-z0-9_]*")) { // check to make sure if filename has no spaces String errorMessage = MESSAGES.whitespaceProjectNameError(); filename = filename.replaceAll("( )+", " ").replace(" ","_"); warningMessage = errorMessage + ". \n '" + filename + "' will be used if continued."; } } return warningMessage; }
<|startcomment|> this doesn't seem to change anything for me? <|endcomment|> public @NonNull TraceSessionComponent[] getSessions() { List<ITraceControlComponent> compenents = getChildren(TraceSessionGroup.class); if (compenents.size() > 0) { TraceSessionGroup group = (TraceSessionGroup)compenents.get(0); List<ITraceControlComponent> sessions = group.getChildren(TraceSessionComponent.class); return sessions.toArray(new @NonNull TraceSessionComponent[sessions.size()]); } return new <START> @NonNull TraceSessionComponent[0]; <END> }
<|startcomment|> Minor: Move declaration before the if block where it is used? <|endcomment|> private static void cacheColors(Display display) { BG_COLOR_RGB= JFaceColors.getInformationViewerBackgroundColor(display).getRGB(); FG_COLOR_RGB= JFaceColors.getInformationViewerForegroundColor(display).getRGB(); Color hyperlinkText= JFaceColors.getHyperlinkText(display); <START> Color activeHyperlinkText= JFaceColors.getActiveHyperlinkText(display); <END> if (hyperlinkText != null) { LINK_COLOR_RGB= hyperlinkText.getRGB(); } if (activeHyperlinkText != null) { ACTIVE_LINK_COLOR_RGB= activeHyperlinkText.getRGB(); } }
<|startcomment|> you can use TypeCastUtility.getGenericsParameterClass(getClass(), IHolder.class); to check the type parameter <|endcomment|> private IRadioButton<T> findFirstButtonInFieldTree(IFormField f) { if (f instanceof IRadioButton) { <START> return (IRadioButton<T>) f; //TODO: mnick <END> } else if (f instanceof ICompositeField) { for (IFormField sub : ((ICompositeField) f).getFields()) { IRadioButton<T> b = findFirstButtonInFieldTree(sub); if (b != null) { return b; } } } return null; }
<|startcomment|> fix name <|endcomment|> public void testGenerateXpathSuppressionOptionEmptyConfig() throws Exception { final String expected = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<!DOCTYPE suppressions PUBLIC\n" <START> + " \"-//Puppy Crawl//DTD Suppressions Xpath Experimental 1.2//EN\"\n" <END> + " \"http://checkstyle.sourceforge.net/dtds/" + "suppressions_1_2_xpath_experimental.dtd\">\n" + "<suppressions>\n" + "</suppressions>\n"; exit.checkAssertionAfterwards(() -> { assertEquals("Unexpected output log", expected, systemOut.getLog()); assertEquals("Unexpected system error log", "", systemErr.getLog()); }); Main.main("-c", getPath("InputMainConfig-empty.xml"), "--generate-xpath-suppression", getPath("InputMainComplexityOverflow.java")); }
<|startcomment|> Can this method return null? Or should it return empty string? <|endcomment|> public String getPackageName() { if (clazz.getPackage() != null) { return clazz.getPackage().getName(); } <START> return null; <END> }
<|startcomment|> This could also be `java.lang.String`. <|endcomment|> public void testIsStringLiteral() { Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1); ASTLiteral literal = literals.iterator().next(); assertTrue(literal.isStringLiteral()); <START> assertEquals("String", literal.getTypeImage()); <END> }
<|startcomment|> formatting weird <|endcomment|> public ImmutableMap<K, V> getAllPresent(final Iterable<K> keys) { ImmutableMap.Builder builder = ImmutableMap.builder(); for (K key : keys <START> ) { <END> V value = getIfPresent(key); if (value != null) { builder.put(key, value); } } return builder.build(); }
<|startcomment|> Please make this protected to avoid exposing methods that consumers of the API do not care about. <|endcomment|> <START> public void configure(ServerHttpSecurity http) { <END> ReactiveAuthenticationManager authenticationManager = getAuthenticationManager(); X509PrincipalExtractor principalExtractor = getPrincipalExtractor(); AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager); filter.setServerAuthenticationConverter(new ServerX509AuthenticationConverter(principalExtractor)); http.addFilterAt(filter, SecurityWebFiltersOrder.AUTHENTICATION); }
<|startcomment|> Would it not be better to obtain this from the session? With this approach it's not pluggable. <|endcomment|> public void action(AuthenticationFlowContext context) { if (DisplayUtils.isConsole(context)) { <START> ConsoleOTPFormAuthenticator.SINGLETON.action(context); <END> return; } validateOTP(context); }
<|startcomment|> A null check is needed also. An NPE will be thrown if reopening a very large project. java.lang.NullPointerException at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.handleResourceChange(GitSubscriberMergeContext.java:141) at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.access$1(GitSubscriberMergeContext.java:137) at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext$2.indexDiffChanged(GitSubscriberMergeContext.java:69) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.notifyListeners(IndexDiffCache.java:94) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.access$0(IndexDiffCache.java:86) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache$1.indexDiffChanged(IndexDiffCache.java:81) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.notifyListeners(IndexDiffCacheEntry.java:313) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.access$6(IndexDiffCacheEntry.java:306) at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry$3.run(IndexDiffCacheEntry.java:171) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54) <|endcomment|> private void handleResourceChange(GitResourceVariantTreeSubscriber subscriber, Repository which, Collection<IFile> resources) { for (GitSynchronizeData gsd : gsds) { if (which.equals(gsd.getRepository())) { <START> if (!resources.isEmpty()) <END> refreshResources(subscriber, resources); else refreshRepository(subscriber); } } }
<|startcomment|> Don't necessarily need the type info in the right hand assignment anymore. Only mention it because you use both ways throughout. <|endcomment|> public static Set<Path> getIncludedFieldsOfRootEntityForSort(CompositeMetadata root, Sort rootSort) { <START> Set<Path> ret=new HashSet<Path>(); <END> if(rootSort!=null) { SortFieldInfo[] sfi=SortFieldInfo.buildSortFields(rootSort,root.getFieldTreeRoot()); for(SortFieldInfo fi:sfi) ret.add(fi.getName()); } return ret; }
<|startcomment|> Why remove unused at only one level below if its not used at all remove all together. <|endcomment|> public LocalCluster(String jarFileName, int siteCount, int hostCount, int kfactor, int clusterId, BackendTarget target, FailureState failureState, boolean debug, boolean isRejoinTest, Map<String, String> env) { // NOTE: isRejoinTest is unused <START> this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, env); <END> }
<|startcomment|> I would prefer to move this logic into the `FollowModeManager` <|endcomment|> public void execute(String userName) { FollowModeManager currentFollowModeManager = followModeManager; User userToFollow = findUser(userName); if (currentFollowModeManager == null) { return; } <START> User currentlyFollowedUser = followModeManager.getFollowedUser(); <END> if ((currentlyFollowedUser != null && !currentlyFollowedUser.equals(userToFollow)) || (currentlyFollowedUser == null && userToFollow != null)) { currentFollowModeManager.follow(userToFollow); } actionPerformed(); }
<|startcomment|> nit: `sep` –> `separator` ? <|endcomment|> @Override public Appendable write(Appendable appendable, Context context) throws IOException { <START> String sep = ""; <END> for (TypeName className : typeNames) { appendable.append(sep); className.write(appendable, context); sep = " & "; } return appendable; }
<|startcomment|> for single-log manager, it is better to flush `rotated logs` before flushing `current logs`, because the way how it rotates files and do the checkpoint. I would prefer keeping existing logic unchanged to reduce the risks. besides that, why not provide `flush` method in EntryLogManager? so different entry log manager implementation can implement its own flushing logic rather than exposing this knowledge to EntryLogger. If you provide `flush` method, it is possible that you don't need to expose `flushCurrentLogs` and `flushRotatedLogs`. <|endcomment|> public void flush() throws IOException { <START> entryLogManager.flushCurrentLogs(); <END> entryLogManager.flushRotatedLogs(); }
<|startcomment|> Also notice OpaqueObjectsNode.java needs the same treatment. <|endcomment|> public void disableWireframe() { boolean refreshTaskList = false; EnableFaceCulling faceCullingStateChange = new EnableFaceCulling(); <START> if (!getDesiredStateChanges().contains(faceCullingStateChange)) { <END> addDesiredStateChange(faceCullingStateChange); refreshTaskList = true; } if (getDesiredStateChanges().contains(wireframeStateChange)) { removeDesiredStateChange(wireframeStateChange); refreshTaskList = true; } if (refreshTaskList) { worldRenderer.requestTaskListRefresh(); } }
<|startcomment|> What's the point of this return value if it's always true? <|endcomment|> public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) { List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId()); connections.clear(); connections.addAll(res); <START> return true; <END> }
<|startcomment|> I am not sure that converter should be part of DAO. Given we still using save on single entity I would suggest i would move that code to Service layer. <|endcomment|> public HibernateErrorReportingServiceDao() { <START> this.errorOccurrenceConverter = new ErrorOccurrenceConverter(); <END> }
<|startcomment|> Would much rather use the ternary operator here. Or even Optional, since we're on Java8 now. ``` Optional.ofNullable(jettyConfig).orElse(() -> new DefaultJettyConfig()); ``` <|endcomment|> public JettyConfig getJettyConfig() { <START> if(jettyConfig != null) <END> { return jettyConfig; } else { return new DefaultJettyConfig(); } }
<|startcomment|> Why do we not allow this field to be null? <|endcomment|> public void setNumThreads(final Integer numThreads) { <START> m_threads = ConfigUtils.assertNotNull(numThreads, "threads"); <END> }
<|startcomment|> change to private <|endcomment|> <START> public String getModeName() { <END> String header = getHeader(); return header.substring(0, header.indexOf('"') - 1); }
<|startcomment|> If you make the getIdsToDelete() to return a list of blob Ids, we can avoid idsToDelete.clear(). We can just call idsToDelete = putManager.getIdsToDelete() everytime. <|endcomment|> private List<RequestInfo> pollForRequests() { // these are ids that were successfully put for an operation that eventually failed idsToDelete.clear(); <START> putManager.getIdsToDelete(idsToDelete); <END> // this is a best effort to delete ids for cleanup purposes (these may fail and we will // not do anything about it at this time). for (String blobId : idsToDelete) { // possibly add a batch api going forward. deleteManager .submitDeleteBlobOperation(operationIdGenerator.incrementAndGet(), blobId, new FutureResult<Void>(), null); } List<RequestInfo> requests = new ArrayList<RequestInfo>(); putManager.poll(requests); getManager.poll(requests); deleteManager.poll(requests); return requests; }
<|startcomment|> Static import `fromTypes`. <|endcomment|> public InternalAggregationFunction specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionManager functionManager) { Type type = boundVariables.getTypeVariable("E"); MethodHandle compareMethodHandle = functionManager.getScalarFunctionImplementation( <START> functionManager.resolveOperator(operatorType, TypeSignatureProvider.fromTypes(ImmutableList.of(type, type)))).getMethodHandle(); <END> return generateAggregation(type, compareMethodHandle); }
<|startcomment|> it would be easier to read if would surround the entire method with this type of try / catch like: ``` @Override public AccountInfo getAccountInfo() throws IOException { try { CoingiBalances coingiBalances = getCoingiBalance(); return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } } ``` please apply this hint to all the methods that have this type of try catch <|endcomment|> public AccountInfo getAccountInfo() throws IOException { CoingiBalances coingiBalances; try { coingiBalances = getCoingiBalance(); } catch (CoingiException e) { throw CoingiErrorAdapter.adapt(e); } return CoingiAdapters.adaptAccountInfo( coingiBalances, exchange.getExchangeSpecification().getUserName()); <START> } <END>
<|startcomment|> `Map<TableScanNode, Void> result = new IdentityHashMap<>();` <|endcomment|> public IdentityHashMap<TableScanNode, Void> visitPlan(PlanNode node, Void context) { <START> IdentityHashMap<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> node.getSources().forEach(source -> ret.putAll(source.accept(this, context))); return ret; }
<|startcomment|> you handle all these exceptions in the same way so you can use multi-catch: } catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e) { <|endcomment|> protected RevCommit findHead(Repository repo) { try (RevWalk walk = new RevWalk(repo)) { try { ObjectId head = repo.resolve(HEAD); return walk.parseCommit(head); <START> } catch (RevisionSyntaxException e) { <END> throw new RuntimeException(e); } catch (AmbiguousObjectException e) { throw new RuntimeException(e); } catch (IncorrectObjectTypeException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } } }
<|startcomment|> You're not passing in the message even though you have a marker there. Think that might throw weird RTEs. <|endcomment|> public void process(EquivalentContentUpdatedMessage message) throws RecoverableException { Id contentId = message.getContentRef().getId(); <START> log.debug("Processing message on id {}, took PT{}S, message: {}", <END> contentId, getTimeToProcessInSeconds(message)); Timer.Context time = timer.time(); try { Content content = getContent(contentId); neo4JContentStore.writeContent(content); time.stop(); } catch (Exception e) { failureMeter.mark(); throw Throwables.propagate(e); } }
<|startcomment|> Internally Druid treats nulls and empty strings as similar values. So I think one workaround here is to do dimValue == null ? "" : dimValue Druid's handling of nulls and empty strings could definitely be better though. <|endcomment|> public String apply(String dimValue) { <START> if (dimValue == null) return null; <END> Matcher matcher = pattern.matcher(dimValue); return matcher.find() ? dimValue : null; }
<|startcomment|> default: throw new IllegalArgumentException... <|endcomment|> private void writeSubscribeCommands( String repoName, List<SubscribeCommand> commands) throws IOException { write("repository " + repoName); for (SubscribeCommand cmd : commands) { switch (cmd.getCommand()) { case SUBSCRIBE: write("want " + cmd.getSpec()); break; case UNSUBSCRIBE: write("stop " + cmd.getSpec()); break; <START> } <END> } }
<|startcomment|> consider !existingServes.isEmpty() <|endcomment|> private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) { Set<GlusterServerInfo> fetchedServers = null; <START> while (fetchedServers == null && existingServers.size() > 0) { <END> fetchedServers = fetchServers(upServer); if (fetchedServers == null) { logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED); // Couldn't fetch servers from the up server. Mark it as non-operational setNonOperational(upServer); existingServers.remove(upServer); upServer = getNewUpServer(existingServers, upServer); } } return fetchedServers; }
<|startcomment|> ![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck) <|endcomment|> public static String sanitizeSecondCachedKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException, DotSecurityException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeSecondCacheKey(host.getIdentifier(), vanityUrl.getLanguageId()); }
<|startcomment|> please keep the body of an `if` on its own line <|endcomment|> void remove(I key) { Integer prev = this.identityMap.remove(key); <START> if (prev != null) this.objectList.set(prev, null); <END> }
<|startcomment|> This is always FALSE. since name is `static final` <|endcomment|> public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof TaskPropertyType)) { return false; } TaskPropertyType that = (TaskPropertyType) o; <START> if (!name.equals(that.name)) { <END> return false; } return true; }
<|startcomment|> This could be `private` right? <|endcomment|> <START> protected long obtainEntityId() { <END> return nextEntityId++; }
<|startcomment|> I'm not sure that this INFO message is helpful to users. <|endcomment|> public void markInCatalog() { <START> exportLog.info("ExportDataSource for table " + m_tableName + " partition " + m_partitionId + " marked as in catalog."); <END> m_isInCatalog = true; }
<|startcomment|> This results conversion will be applyed also to subclass of `StringParameterValue`. It would be better applied to exact `StringParameterValue`. <|endcomment|> private static boolean canConvert(ParameterDefinition def, ParameterValue v) { return def instanceof SimpleParameterDefinition && !(def instanceof StringParameterDefinition) && v instanceof StringParameterValue; <START> } <END>
<|startcomment|> Why are you using `EventHandlerTest` here? It has nothing to do with filtering. <|endcomment|> public void setUp() { <START> deviceHandler = new EventHandlerTest(); <END> passingHandler = new FilterHandler(); filtingHandler = new FilterHandler(); filtingHandler.setFilterInvalid(true); filtingHandler.setFilterZero(true); filtingHandler.setFilterDuplicate(true); filtingHandler.setFilterFuture(true); filtingHandler.setFilterApproximate(true); filtingHandler.setFilterStatic(true); filtingHandler.setFilterDistance(10); filtingHandler.setFilterLimit(10); }
<|startcomment|> The connector setup should fail when an exception occurs. <|endcomment|> public void download(String url, String downloadPath) { InputStream in = null; try { in = new URL(url).openStream(); FileUtils.writeByteArrayToFile(new File(downloadPath), IOUtils.toByteArray(in)); System.out.println(IOUtils.toString(in)); } catch (IOException e) { <START> log.error(e); <END> } finally { IOUtils.closeQuietly(in); } }
<|startcomment|> Simpler: oldChildValue != && oldChildValue.booleanValue() <|endcomment|> private boolean getOldChildStale(IObservable child) { Boolean oldChildValue = staleMap.get(child); boolean oldChildStale = <START> oldChildValue == null ? false : oldChildValue .booleanValue(); <END> return oldChildStale; }
<|startcomment|> Add tooltip <|endcomment|> public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) { if (!CommonRefactoringUtil.checkReadOnlyStatus(file)) return; if (editor.getSettings().isVariableInplaceRenameEnabled()) { final TemplateState templateState = TemplateManagerImpl.getTemplateState(editor); <START> if (templateState != null && !templateState.isFinished()) return; <END> } performAction(new GoIntroduceOperation(project, editor, file)); }
<|startcomment|> but you removed the static from there as well. <|endcomment|> <START> private List<String> getListOfIsoFiles(File directory, OVirtNodeInfo info) { <END> List<String> isoFileList = new ArrayList<String>(); File[] filterOvirtFiles = filterOvirtFiles(directory, getIsoPattern(info)); for (File file : filterOvirtFiles) { isoFileList.add(file.getName()); } return isoFileList; }
<|startcomment|> nit: jgit spells this for (;;) <|endcomment|> EWAHCompressedBitmap getBitmap() { // Fast path to immediately return the expanded result. Object r = bitmapContainer; if (r instanceof EWAHCompressedBitmap) return (EWAHCompressedBitmap) r; // Expand the bitmap and cache the result. XorCompressedBitmap xb = (XorCompressedBitmap) r; EWAHCompressedBitmap out = xb.bitmap; <START> while (true) { <END> r = xb.xorBitmap.bitmapContainer; if (r instanceof EWAHCompressedBitmap) { bitmapContainer = out = out.xor((EWAHCompressedBitmap) r); return out; } xb = (XorCompressedBitmap) r; out = out.xor(xb.bitmap); } }
<|startcomment|> ??? `this.` of course. That's why I said to revert those all changes for the `messagingTemplate` and PR is becoming clear <|endcomment|> public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store, CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) { Assert.notNull(processor); Assert.notNull(store); setMessageStore(store); this.outputProcessor = processor; this.correlationStrategy = correlationStrategy == null ? new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy; this.releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy() : releaseStrategy; <START> super.messagingTemplate.setSendTimeout(DEFAULT_S<END>_TIMEOUT); <END> sequenceAware = this.releaseStrategy instanceof SequenceSizeReleaseStrategy; }
<|startcomment|> Hmmm this is wrong now? There should be two methods, one passing null and the other one passing the nodeName. <|endcomment|> public Statement createBootstrapScriptForGroup(String group, @Nullable String nodeName) { <START> return groupToBootScript.apply(group, null); <END> }
<|startcomment|> No need for result variable <|endcomment|> public boolean create(Personname personnameRecord) { LOG.trace("PersonnameDAO.create() - Begin"); <START> boolean result = true; <END> if (personnameRecord != null) { result = super.create(personnameRecord); } LOG.trace("PersonnameDAO.create() - End"); return result; }
<|startcomment|> Please only log at debug or trace <|endcomment|> public void handleInvocation(EJBClientInvocationContext context) throws Exception { <START> log.info("In the client interceptor handleInvocation : " + this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); <END> context.getContextData().put("ClientInterceptorInvoked", this.getClass().getName() + " " + context.getViewClass() + " " + context.getLocator()); // Must make this call context.sendRequest(); }
<|startcomment|> If I'm not mistaken, it shouldn't be possible for subnet.getNetwork() to be null, so you can drop the check. <|endcomment|> public void edit(final NewExternalSubnetModel subnet) { driver.edit(subnet); <START> if (subnet.getNetwork().getEntity() != null){ <END> networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName()); } }
<|startcomment|> this is probably simple enough to be inlined... <|endcomment|> protected AddVmFromTemplateCommand<AddVmParameters> createCommand() { initVM(); AddVmParameters <START> param = <END> new AddVmParameters(vm); return new AddVmFromTemplateCommand<>(param, null); }
<|startcomment|> Please split this test into several, testing each case separately. <|endcomment|> public void testGetNameFromPath() { <START> String path1 = "/group1"; <END> String path2 = "/group1/group2/group3"; String emptyPath = ""; String nullPath = null; String rootPath = "/"; assertEquals(HDF5Utils.getNameFromPath(path1), "group1"); assertEquals(HDF5Utils.getNameFromPath(path2), "group3"); assertEquals(HDF5Utils.getNameFromPath(emptyPath), ""); assertNull(HDF5Utils.getNameFromPath(nullPath)); assertEquals(HDF5Utils.getNameFromPath(rootPath), ""); }
<|startcomment|> Coding conventions: Let's have the @Override on its own line please <|endcomment|> <START> @Override public <END> GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList() { JsonRpcRequest request = new RequestBuilder("GlusterHost.logicalVolumeList").build(); Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey(); return new GlusterLocalLogicalVolumeListReturn(response); }
<|startcomment|> needs `@Override` <|endcomment|> <START> public String toString() { <END> return "TypedByteArray[length=" + length() + "]"; }
<|startcomment|> Not an issue, but could be rewritten as ``` java if (entity.isPersistent()) { // do stuff } ``` to avoid multiple points of return from the method (and save a line of code). <|endcomment|> public void onEntityDestroyed(EntityRef entity) { <START> if (!entity.isPersistent()) { <END> return; // ignore } entityDeltas.remove(entity.getId()); destroyedEntities.add(entity.getId()); }
<|startcomment|> Isn't this use of `Optional` and returning `null` contradictory? Surely checking `isPresent(..)` in `getDefaultOrganizationalUnit(..)` would be better? <|endcomment|> private OrganizationalUnit getOU( String ouIdentifier, Collection<OrganizationalUnit> organizationalUnits ) { Optional<OrganizationalUnit> targetOU = organizationalUnits.stream() .filter( p -> p.getIdentifier().equalsIgnoreCase( ouIdentifier ) ).findFirst(); <START> if ( targetOU.isPresent() ) { <END> return targetOU.get(); } return null; }
<|startcomment|> to keep code consistency, you may use `testK("v2");` <|endcomment|> public void testPutAsync() throws Exception { // put Future<String> f = c.putAsync("k", "v"); testFuture(f, null); testK("v"); f = c.putAsync("k", "v2"); testFuture(f, "v"); <START> assertEquals("v2", c.get("k")); <END> }
<|startcomment|> should this return true instead ? <|endcomment|> public boolean isReady(TaskActionClient taskActionClient) throws Exception { <START> return false; <END> }
<|startcomment|> why not public <|endcomment|> <START> static Map<String, EntryValue> convertBeanToEntryMap(Object bean) { <END> Map<String, Object> buildAttributeValueMap = BeanUtilsExtended.buildObjectAttributeMap(bean); return Maps.transformEntries(buildAttributeValueMap, new ObjectToEntryValueTransformer()); }
<|startcomment|> nit: replace with `this(new RequestHeaderData(struct, headerVersion), headerVersion)`. Consolidates c'tor logic to one place. <|endcomment|> public RequestHeader(Struct struct, short headerVersion) { this.data = new RequestHeaderData(struct, headerVersion); <START> this.headerVersion = headerVersion; <END> }
<|startcomment|> Please add braces to conditionals (like `if { }`). <|endcomment|> public void accountSession(String username, String password) throws TmdbInvalidParametersException { <START> if (username == null || password==null) <END> throw new TmdbInvalidParametersException(401,"Username and Password may not be null"); this.username = username; this.password = password; hasAccountSession = true; }
<|startcomment|> Use if (!fRemoteDirSelected) { <|endcomment|> public void setProjectName(String projectName) { fProjectName = projectName; // If remote directory field is empty if(fLocationText.getText().equals(EMPTY_STRING)) { fRemoteDirSelected = false; } // If remote directory was not selected yet <START> if (fRemoteDirSelected == false) { <END> fLocationText.setText(getDefaultPathDisplayString()); } }
<|startcomment|> unreachable. Maybe you should remove. <|endcomment|> public void testAddChildCycle3() { assertNotNull(fFixture); assertNotNull(f42Fixture); assertNotNull(fHiFixture); ((CalledFunction) f42Fixture).addChild(fHiFixture); <START> assertEquals(Collections.singletonList(fHiFixture), f42Fixture.getChildren()); <END> }
<|startcomment|> I think the condition needs top start as `fieldName.length() > 1` instead of `fieldName.length() > 2 `. I think the generated code getters/setters has same rules for fields **aField** and **aF**. Or am I wrong? <|endcomment|> private char formatFieldFirstCharacterToFitDroolsCoreStandards(final String fieldName) { <START> if (fieldName.length() > 2 && Character.isLowerCase(fieldName.charAt(0)) && Character.isUpperCase(fieldName.charAt(1))) { <END> return fieldName.charAt(0); } else { return Character.toUpperCase(fieldName.charAt(0)); } }
<|startcomment|> Are these logging statements really needed? <|endcomment|> public void start() { <START> logger.debug("start()"); <END> for (final Class<?> stepDefinitionType : cachedStepsInstances.keySet()) { cachedStepsInstances.put(stepDefinitionType, createStepsInstance(stepDefinitionType)); } }
<|startcomment|> I don't have the code now but if the contract od sselection is to return null on getFirstElement() if sselection is empty, the code can be changed to simply return the first element, without the if. <|endcomment|> private WorkingSetDescriptor getSelectedWorkingSet() { IStructuredSelection selection = typesListViewer.getStructuredSelection(); WorkingSetDescriptor descriptor = null; if (!selection.isEmpty()) { descriptor = (WorkingSetDescriptor) <START> selection.getFirstElement(); <END> } return descriptor; }
<|startcomment|> Is it reasonable for the caller to pass in a null value for previous into the constructor? If not, then the constructor should throw a `NullPointerException` if it is null. <|endcomment|> public void evaluate() throws Throwable { <START> if (null != previous) { <END> previous.evaluate(); } for (FrameworkMethod before : befores) { before.invokeExplosively(target); } next.evaluate(); }
<|startcomment|> It is a bit weird to create here an empty "StoragePool" to indicate that there is no storage pool to use. Can't we just pass "null" to the backend in that case? <|endcomment|> public Response add(OpenStackVolumeProvider provider) { validateParameters(provider, "name"); StoragePool storagePool = provider.isSetDataCenter() ? <START> getStoragePool(provider.getDataCenter()) : new StoragePool(); <END> provider.setDataCenter(DataCenterMapper.map(storagePool, null)); return performCreate( VdcActionType.AddProvider, new ProviderParameters(map(provider)), new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class) ); }
<|startcomment|> private <|endcomment|> <START> protected void doStoreUsers() <END> { try { usersFileManager.store(new UsersDto(new HashSet<>(userMap.values()))); } catch (IOException e) { throw new UndeclaredThrowableException(e); } }
<|startcomment|> Why is this needed now? <|endcomment|> <START> public void tearDown() throws IOException, SQLException { <END> try { globalScheduler.shutdown(); } catch (Exception e) { } cleanup(); tearDownOnce(); }
<|startcomment|> This shouldn't call `getAllConfigBag()`. It should use the `config` passed in, otherwise we lose the local values passed in to the obtain() method. Do you agree? <|endcomment|> private CloudMachineNamer getCloudMachineNamer(ConfigBag config) { String namerClass = config.get(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS); if (namerClass != null) { try { return (CloudMachineNamer) getManagementContext().getCatalog().getRootClassLoader().loadClass(namerClass) .getDeclaredConstructor(ConfigBag.class).newInstance(config); } catch (Exception e) { throw Exceptions.propagate(e); } } else { <START> return new JcloudsMachineNamer(getAllConfigBag()); <END> } }
<|startcomment|> Missing JavaDoc. <|endcomment|> <START> public IllustratedSelectItem(Object value, String label, String image) { <END> super(value, label); this.image = image; }
<|startcomment|> The last six lines can be squashed into: return "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service); <|endcomment|> private boolean layerGroupContainmentCheckRequired() { // first, is it WMS? Request request = Dispatcher.REQUEST.get(); if(request == null) { return false; } // layer groups are used only in WMS final String service = request.getService(); boolean isMapService = "WMS".equalsIgnoreCase(service) || "gwc".equalsIgnoreCase(service); if(!isMapService) { return false; } <START> return true; <END> }
<|startcomment|> I would do this instead: ``initialize(absoluteUri, contextPath, (initData != null && InitData.canBeCached(absoluteUri)) ? initData : null);`` IOW, no point in spending time on checking if the cache can be used if there's no ``initData`` provided. <|endcomment|> public ResteasyUriInfo(final String absoluteUri, final String contextPath, final InitData initData) { <START> initialize(absoluteUri, contextPath, InitData.canBeCached(absoluteUri) ? initData : null); <END> }
<|startcomment|> @benzonico The fact that postfix operators return value before modification shouldn't change order in CFG, because loading of value should anyway happen before operation, i.e. order should be the same. <|endcomment|> private void buildUnaryExpression(UnaryExpressionTree tree) { <START> if(tree.is(Tree.Kind.PREFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT)) { <END> build(tree.expression()); currentBlock.elements.add(tree); } else { currentBlock.elements.add(tree); build(tree.expression()); } }
<|startcomment|> Class<?> <|endcomment|> <START> public Class getRealClass() { <END> return testNGMethod.getRealClass(); }
<|startcomment|> Good it is the way <|endcomment|> private KeyStore getSecretsStore() { final File secretStoreFile = createStoreIfNeeded(); try { final KeyStore keyStore = KeyStore.getInstance(SECRETS_STORE_KEYSTORE_TYPE); <START> try (InputStream inputStream = Files.newInputStream(secretStoreFile.toPath())) { <END> keyStore.load(inputStream, loadStorePassword()); } return keyStore; } catch (Exception e) { Logger.warn(this.getClass(), "unable to load secrets store " + SECRETS_STORE_FILE + ": " + e); throw new DotRuntimeException(e); } }
<|startcomment|> This should be ROLE_ANONYMOUS. However given the defaults in AnonymousSpec you should just delete it <|endcomment|> public AnonymousSpec anonymous(){ if (this.anonymous == null) { this.anonymous = new AnonymousSpec(); } <START> return this.anonymous.authorities("ROLE_USER"); <END> }
<|startcomment|> ```suggestion return this.connectionPool.getNumWaiters(); ``` <|endcomment|> public int getNumWaiters() { <START> return this.connectionPool.getNumActive(); <END> }
<|startcomment|> can we do this atomically? <|endcomment|> private void store() throws IOException { byte[] serialized = state.toCbor().serialize(); System.out.println("Writing "+ serialized.length +" bytes to "+ statePath); Files.write( statePath, serialized, <START> StandardOpenOption.CREATE); <END> }
<|startcomment|> Please add curlies here <|endcomment|> private static void initFacets(@CheckForNull Fingerprint fingerprint){ if (fingerprint==null) return; <START> for (FingerprintFacet facet : fingerprint.facets) <END> facet._setOwner(fingerprint); }
<|startcomment|> For clarity it's preferable: Map.Entry <|endcomment|> public Map<FactoryContainer, Attributes> getEnabledContainers() { Map<FactoryContainer, Attributes> map = new LinkedHashMap<>(); synchronized(_path) { for <START> (Entry<FactoryContainer, <END> Attributes> entry : getReversed(_path.entrySet())) { Attributes attr = entry.getValue(); if (attr.isEnabled()) { Attributes attrClone = new Attributes(attr); map.put(entry.getKey(), attrClone); } } } return map; }
<|startcomment|> I'm concerned about this lock.. it doesn't seem necessary as each operation invoking this private method is guarded already, and whenever a thread needs to acquire two locks I have an alarm bell ringing in my head. <|endcomment|> private FileListCacheValue getFileList() { <START> readLock.lock(); <END> try { FileListCacheValue fileList = (FileListCacheValue) cache.get(fileListCacheKey); if (fileList == null) { fileList = new FileListCacheValue(); FileListCacheValue prev = (FileListCacheValue) cache.putIfAbsent(fileListCacheKey, fileList); if (prev != null) { fileList = prev; } } if (trace) log.trace("Refreshed file listing view"); return fileList; } finally { readLock.unlock(); } }
<|startcomment|> What happens when one of these `TypedOutput` instances return `-1` because they don't know their length? <|endcomment|> public long size() { build(); <START> return body.length() + partBoundary.length + partHeader.length; <END> }
<|startcomment|> Performance gezien is het natuurlijk handiger eerst een boolean check te hebben en dan extra logica.. <|endcomment|> public boolean canStreamToNextPipe() { <START> return super.canStreamToNextPipe() && !isCollectResults(); // when collectResults is false, streaming is not necessary or useful <END> }
<|startcomment|> Where do you handle this now? <|endcomment|> public FoundViewHolder getFoundViewHolder(JFieldRef idRef, AbstractJClass viewClass) { String idRefString = idRef.name(); FoundViewHolder foundViewHolder = (FoundViewHolder) foundHolders.get(idRefString); if (foundViewHolder == null) { foundViewHolder = createFoundViewAndIfNotNullBlock(idRef, viewClass); <START> foundHolders.put(idRefString, foundViewHolder); <END> } return foundViewHolder; }
<|startcomment|> `finally` is not really needed. If `close` throws the test will fail anyway and we won't care whether `queryRunner` is `null` or not. <|endcomment|> public void tearDown() { try { queryRunner.close(); } <START> finally { <END> queryRunner = null; } }
<|startcomment|> What if this throws an exception? Should probably be mapped to a ConfigInvalidException, and the caller should report the error. <|endcomment|> private CommitConfig(Config rc) { commitTemplatePath = rc.getString(ConfigConstants.CONFIG_COMMIT_SECTION, null, ConfigConstants.CONFIG_KEY_COMMIT_TEMPLATE); String i18nCommitEncoding = rc.getString( ConfigConstants.CONFIG_SECTION_I18N, null, ConfigConstants.CONFIG_KEY_COMMIT_ENCODING); if (i18nCommitEncoding != null) { <START> commitMessageEncoding = Charset.forName(i18nCommitEncoding); <END> } }
<|startcomment|> What's broken (add some details in the commit message)? This is not very obvious. <|endcomment|> public int decompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength) throws MalformedInputException { <START> try { <END> Inflater inflater = new Inflater(true); inflater.setInput(input, inputOffset, inputLength); int resultLength = inflater.inflate(output, outputOffset, maxOutputLength); inflater.end(); return resultLength; } catch (DataFormatException e) { throw Throwables.propagate(e); } }
<|startcomment|> we should return an ImmutableList if we don't intend for users of this method to edit the list. <|endcomment|> <START> public List<OutputLine> getLog() { <END> return this.log; }
<|startcomment|> `!this.closeStreamAfterSend || this.isSingleUse` ? <|endcomment|> protected void doInit() { super.doInit(); if (!this.evaluationContextSet) { this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory()); } <START> Assert.state(this.closeStreamAfterSend ? this.isSingleUse : true, <END> "Single use connection needed with closeStreamAfterSend"); }
<|startcomment|> I'm reworking this code in the context of the class, also to avoid potential NPE if the extensionRegisters field might have not been initialized, from the no-args constructor. <|endcomment|> public ExtensionElementsConverter(XStream xStream, List<DMNExtensionRegister> extensionRegisters) { super(xStream); this.extensionRegisters = new ArrayList<DMNExtensionRegister>(); if(extensionRegisters != null && extensionRegisters.size() > 0) <START> this.extensionRegisters.addAll(extensionRegisters); <END> }
<|startcomment|> Maybe we should move that inside the `if` body, since we won't always execute the batch... ? <|endcomment|> public void executeBatch(OperationsQueue operationsQueue) { <START> log.tracef( "Executing batch" ); <END> try { if ( GridDialects.hasFacet( getGridDialect(), BatchableGridDialect.class ) || GridDialects.hasFacet( getGridDialect(), GroupingByEntityDialect.class ) ) { super.executeBatch( operationsQueue ); } } catch ( TupleAlreadyExistsException taee ) { // TODO: Ideally, we should log the entity name + id here; For now we trust the datastore to provide this // information via the original exception; It'd require a fair bit of changes to obtain the entity name here // (we'd have to obtain the persister matching the given entity key metadata which in turn would require // access to the session factory which is not easily available here) throw log.mustNotInsertSameEntityTwice( taee.getMessage(), taee ); } }
<|startcomment|> nit-pick: startCommit.hashCode can just be xored/added in since it is well distributed <|endcomment|> public int hashCode() { <START> return (((startCommit.hashCode() * 31) + numbers.length) * 31) <END> + getNumber(); }
<|startcomment|> can this function now throw NoSuchAlgorithmException <|endcomment|> <START> private void prepareAuthForBrokerCall() throws NoSuchAlgorithmException { <END> AuthenticationSettings.INSTANCE.setUseBroker(true); }
<|startcomment|> I woudl remove this else, if the gridCoverage is a wrapper and says "false" but iface is "GridCoverage2D" you want to fall back on the isInstance check anyways. <|endcomment|> public boolean isWrapperFor(Class<?> iface) { if (gridCoverage instanceof Wrapper) return ((Wrapper) gridCoverage).isWrapperFor(iface); <START> else if (iface.isInstance(gridCoverage)) return true; <END> else return false; }
<|startcomment|> Would you change the log level to debug? it doesn't look worth to be the info level. <|endcomment|> DataSegment uploadDataSegment( DataSegment segment, final int binaryVersion, final long size, final File compressedSegmentData, final String azurePath ) throws StorageException, IOException, URISyntaxException { azureStorage.uploadBlob(compressedSegmentData, config.getContainer(), azurePath); final DataSegment outSegment = segment .withSize(size) .withLoadSpec(this.makeLoadSpec(new URI(azurePath))) .withBinaryVersion(binaryVersion); <START> log.info("Deleting file [%s]", compressedSegmentData); <END> compressedSegmentData.delete(); return outSegment; }
<|startcomment|> not done <|endcomment|> public EEFButtonLifecycleManager(EEFButtonDescription description, IVariableManager variableManager, IInterpreter interpreter, TransactionalEditingDomain editingDomain) { <START> super(description, variableManager, <END> interpreter, editingDomain); this.description = description; }
<|startcomment|> useless parenthesis <|endcomment|> private static boolean isProbablyLog4jFormatterLogger(MethodInvocationTree mit, String formatString) { return mit.symbol().owner().type().is(ORG_APACHE_LOGGING_LOG4J_LOGGER) && <START> (!formatString.contains("{}") && formatString.contains("%")); <END> }
<|startcomment|> PatchUtil.M <|endcomment|> void setMarker(TextMarker marker, int length) { this.marker = marker; numSkipLines = length; if (checkAndUpdateArrows()) { upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND)); } <START> skipNum.setText(PatchUtil.C.patchSkipRegion(Integer <END> .toString(length))); }
<|startcomment|> Wouldn't be better to directly call the new constructor? Just for easier maintenance in the future. <|endcomment|> public ExtendedEmailPublisherContext(ExtendedEmailPublisher publisher, AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) { this.publisher = publisher; this.run = build; this.workspace = build.getWorkspace(); this.launcher = launcher; <START> this.listener = listener; <END> }
<|startcomment|> this might be obsolete if `isValueValid`is implemented... <|endcomment|> public void testWrongFormatNumber() throws Exception { NumberCellEditor editor; editor = new NumberCellEditor(shell, Integer.class); //empty string editor.setValue(" "); editor.getValue(); assertNull(editor.getValue() ); //not parsable number editor.setValue("aa"); <START> editor.getValue(); <END> assertNull(editor.getValue() ); }
<|startcomment|> else if on one line. <|endcomment|> public void onReloadPlugin(Plugin oldPlugin, Plugin newPlugin) { if (hasAvatarProvider(newPlugin)) { avatarSupport = true; <START> } else { if (avatarSupport <END> && hasAvatarProvider(oldPlugin)) { avatarSupport = false; } } }
<|startcomment|> `Class<?>` <|endcomment|> <START> public Class getRealClass() { <END> return clazz; }
<|startcomment|> I suppose close() is already done in Util.read(..) <|endcomment|> private String read(String resourcePath) throws IOException { InputStream is = getClass().getResourceAsStream(resourcePath); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }
<|startcomment|> I don't see why I need this cast. The group and artifact IDs are accessible even at interface level. Also the version is accessible, but I don't think you should add it here: this is for multimodule project compilaton and afaik you cannot have different modules with same GA and different version in the same project. <|endcomment|> public static String getModelFileWithGAV(ReleaseId releaseId) { <START> ReleaseIdImpl releaseIdImpl = (ReleaseIdImpl) releaseId; <END> return Paths.get(MODEL_FILE_DIRECTORY, releaseIdImpl.getGroupId(), releaseIdImpl.getArtifactId(), releaseIdImpl.getVersion(), MODEL_FILE_NAME).toString(); }
<|startcomment|> This operation can be O(n), though the size of the list may be small. Making sense to use a set instead? <|endcomment|> void removeConnection(String connectionId) { <START> if (availableConnections.remove(connectionId)) { <END> availableCount--; } poolCount--; }
<|startcomment|> return before instantiating the map? <|endcomment|> private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) { Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>(); if <START> (!desiredColumns.isEmpty()) <END> { for (Long columnsId : desiredColumns) { ISegmentAspect segmentAspect = fAspectMap.get(columnsId); if (segmentAspect != null) { aspects.put(columnsId, segmentAspect); } } return aspects; } return fAspectMap; }
<|startcomment|> Why Objects.nonNull instead of != null? <|endcomment|> static boolean isValidMining(ICodeMining mining) { <START> return Objects.nonNull(mining) && mining.getLabel() != null && !mining.getLabel().isEmpty(); <END> }
<|startcomment|> `-1` would be more correct. AFAIC you can skip this. <|endcomment|> public void addInput(Page page) { verify(probe == null); probe = page; probePosition = 0; joinAddresses = null; <START> joinAddressIndex = 0; <END> }
<|startcomment|> Simpler to just rename the field. Then XStream will discard the old data automatically. <|endcomment|> public DescriptorImpl() { super(ThrottleJobProperty.class); synchronized(propertiesByCategoryLock) { load(); // Explictly drop queue items loaded from 1.8.1 version if (!propertiesByCategory.isEmpty()) { propertiesByCategory = new HashMap<String,Map<ThrottleJobProperty,Void>>(); save(); // Save the configuration to remove obsolete data } <START> } <END> }
<|startcomment|> you don't need this. the "+" operator does this for you. <|endcomment|> public String toString() { // Since the static data arrives from external source it's not guarenteed not to be null so a null check is // mandatory in order to avoid NPE when invoking toString by the logger String domainName = staticData.getName() == null ? "null" : staticData.getName(); <START> String domainId = staticData.getId() == null ? "null" : staticData.getId().toString(); <END> return "StorageDomain[" + domainName + ", " + domainId + "]"; }
<|startcomment|> Can this be simplified to: ```java return input -> range == null || range.contains(input.getKey()); ``` <|endcomment|> Predicate<Entry<Key,Value>> getScanPredicate() { final Range range = getRange(); <START> return input -> { if (range != null && !range.contains(input.getKey())) return false; return true; }; <END> }
<|startcomment|> nit ```java this.client = requireNonNull(client, "client is null"); <|endcomment|> public AlluxioHiveMetastore(TableMasterClient client) { <START> requireNonNull(client, "client is null"); <END> this.client = client; }
<|startcomment|> Should this be above "isColorTeamMatch"? For example, on line #755. <|endcomment|> private void addWorkPackageCriteria() { if (isWorkPackageSpecified()) { ArtifactId workPackArt = atsApi.getQueryService().getArtifactOrSentinel(workPackageId); if (isColorTeamMatch(workPackArt)) { <START> if (workPackArt.isValid()) <END> { queryAnd(AtsAttributeTypes.WorkPackageReference, workPackArt.getIdString()); } } } }
<|startcomment|> you directly use the member variable tcpSocket, but shouldnt it be the parameter socket? <|endcomment|> private void sendToSocket(Socket socket, String cmdString) throws IOException { // remove spaces at beginning and end and replace double spaces in // string with single space byte[] sendBytes = ("A" + cmdString.trim().replaceAll("\\s+", " ") + "\n").getBytes(); <START> socket.getInputStream().skip(tcpSocket.getInputStream().available()); <END> socket.getOutputStream().write(sendBytes); socket.getOutputStream().flush(); AstericsErrorHandling.instance.reportInfo(this, "IRTrans sent data: " + cmdString); }
<|startcomment|> can you explain why this is necessary? <|endcomment|> public int hashCode() { <START> return getClass().hashCode(); <END> }
<|startcomment|> i do not think we need to save this line better make it more readable <|endcomment|> private void reset() { <START> setId( next = NO_ID ); <END> }
<|startcomment|> so now you can drop the "toString()" <|endcomment|> public String getActualDowntime() { <START> return (actualDowntime == null) ? "(N/A)" : actualDowntime.toString() + "ms"; <END> }
<|startcomment|> @wezell , missing return statement... This is breaking when compiling the code <|endcomment|> String resolveTemplatePath(final Context context, final Writer writer, final RenderParams params, final String argument) { if (argument.contains("/")) { <START> <END> }else{ return (params.live) ? "/live/" + argument + "." + EXTENSION : "/working/" + argument + "." + EXTENSION; } }
<|startcomment|> andNameEquals is un-needed and probably undesired incase name ever changes <|endcomment|> public DispoConfig findDispoConfig(DispoProgram program) { <START> ArtifactReadable config = <END> getQuery().fromBranch(program.getUuid()).andNameEquals("Program Config").getResults().getOneOrNull(); if (config == null) { DispoUtil.getDefaultConfig(); } return DispoUtil.configArtToConfigData(new DispoConfigArtifact(config)); }
<|startcomment|> This is wrong, should be `entry.getValue()` <|endcomment|> public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) { // Indexing on signatures optimises this type of request for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) { if (mask.covers(entry.getKey())) { <START> if (operations.get(entry.getKey()).contains(name)) { <END> return true; } } } return false; }
<|startcomment|> Make these methods public since they are part of the public API of the class. If we want to restrict access to the class, we would make the class itself package private. <|endcomment|> <START> IonSqlQueryBuilder(TypeManager typeManager) <END> { this.typeManager = requireNonNull(typeManager, "typeManager is null"); }
<|startcomment|> Should we abstract this. I mean the way we choose the operation controller. What in case in future, we wish to choose the one which is less loaded compared to others? <|endcomment|> protected OperationController getOperationController() { <START> return ocList.get(ThreadLocalRandom.current().nextInt(ocList.size())); <END> }
<|startcomment|> So I believe the only way this could be null is if a configuration was saved without the <jdks> entry and then reloaded. I don't see how that could happen - but there may be some old version of Jenkins that could have done it. Would probably make sense to modify a `readResolve()` to set it to an empty list and remove this check and the theoretical possibility? <|endcomment|> public List<JDK> getJDKs() { <START> if(jdks==null) <END> jdks = new ArrayList<JDK>(); return jdks; }
<|startcomment|> same as above: please pass on the original exception so that we retain the stacktrace and message. <|endcomment|> public boolean addAll(int index, Collection<? extends T> c) { Collection<T> uniqueValuesToAdd = getUniqueValues(c); if (uniqueValuesToAdd.isEmpty()) { return false; } try { return super.addAll(index, uniqueValuesToAdd); } catch (IndexOutOfBoundsException ioobException) { comparingSet.removeAll(uniqueValuesToAdd); <START> throw new IndexOutOfBoundsException(); <END> } }
<|startcomment|> why sdk version hardcoded? <|endcomment|> public Context getContext() { if (sdkName == null) { sdkName = this.getClass().getPackage().getName(); } return new Context("Sdk-Name", sdkName) <START> .addData("Sdk-Version", SDK_VERSION); <END> }
<|startcomment|> Can this be protected. I assume only the ListModel is using it <|endcomment|> <START> public void setSelectedDevices(List<StorageDevice> selectedDevices) { <END> getStorageDevices().setSelectedItems(selectedDevices); }
<|startcomment|> Why US? <|endcomment|> private JsonObject toJson(Timer timer, TimeUnit rateUnit, TimeUnit durationUnit) { Snapshot snapshot = timer.getSnapshot(); JsonObject json = new JsonObject(); // Meter populateMetered(json, timer, rateUnit); // Snapshot double factor = 1.0 / durationUnit.toNanos(1); populateSnapshot(json, snapshot, factor); // Duration rate <START> String duration = durationUnit.toString().toLowerCase(Locale.US); <END> json.putString("durationRate", duration); return json; }
<|startcomment|> Should be ResourceDoesNotSupportOperationException <|endcomment|> protected void delete(LogEntry delegate, String reason, RequestContext context) throws ResourceDoesNotSupportOperationException { <START> throw new UnsupportedOperationException("delete not supported"); <END> }
<|startcomment|> Why is this `protected` ? Are you going to detect this option internally by the `@RabbitListener(Handler)` method signature? <|endcomment|> <START> protected void setConsumerBatchEnabled(boolean consumerBatchEnabled) { <END> this.consumerBatchEnabled = consumerBatchEnabled; }
<|startcomment|> old code seems to indicate this should be "level" not "toclevel"? Could be causing failure of getLevel() calls being compared in SectionsFetchTask.processResult? <|endcomment|> public int getLevel() { <START> return data.optInt("toclevel"); <END> }
<|startcomment|> use getContext() instead of this.getContext() ? <|endcomment|> private void setPagesRecycler(OnThisDayCard card) { if (card.pages() != null) { RecyclerAdapter recyclerAdapter = new RecyclerAdapter(card.pages(), card.wiki(), true, (Activity) <START> this.getContext()); <END> recyclerAdapter.setCallback(new ItemCallback()); pagesRecycler.setAdapter(recyclerAdapter); } else { pagesRecycler.setVisibility(GONE); } }
<|startcomment|> Add a getExtendedLabelsForVSM(IConfigurationElement) method to avoid duplication <|endcomment|> public String getExtendedLabelForVSM(String providedShapeURI) { for (IConfigurationElement configurationElement : extensions) { String identifier = ((ExtensionHandle) configurationElement.getParent()).getSimpleIdentifier(); if (identifier != null && identifier.equals(providedShapeURI)) { return <START> configurationElement.getAttribute(LABEL_ATTRIBUTE) + " - " + configurationElement.getNamespaceIdentifier(); //$NON-NLS-1$ <END> } } return "Unknown URI"; //$NON-NLS-1$ }
<|startcomment|> I would not use setCleanIdleConnections as the name of the function without parmeters. Maybe add a parameter. <|endcomment|> public void stopServer() { if (server instanceof GrizzlyServer) { <START> ((GrizzlyServer) server).setCleanIdleConnections(); <END> } server.stop(); }
<|startcomment|> We can make `DestroyProxyMessageTask` implement the Supplier, so that this method will no create a lamda but return `this` instead. <|endcomment|> protected Supplier<Operation> createOperationSupplier() { <START> return () -> new DistributedObjectDestroyOperation(parameters.serviceName, parameters.name); <END> }
<|startcomment|> So model change listener will be called twice for single modification? I do not like it. @monperrus Could you explain why it is good? <|endcomment|> public <C extends CtTypedElement> C setType(CtTypeReference<T> type) { if (type != null) { type.setParent(this); } // even if the setter delegates to getExecutable, it makes sense to create an event <START> getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, getExecutable().getType()); <END> if (getExecutable() != null) { getExecutable().setType(type); } return (C) this; }
<|startcomment|> I do not understand the above two... but for ut it will be hell. <|endcomment|> public static AuthenticationProfileRepository getInstance() { return instance; <START> } <END>
<|startcomment|> ```suggestion ``` <|endcomment|> public HttpRequest filterKey(HttpRequest request) throws HttpException { request = replaceDateHeader(request); String signature = calculateSignature(createStringToSign(request)); <START> request = replaceAuthorizationHeader(request, signature); <END> return request; }
<|startcomment|> Again, should just return the value if not null. <|endcomment|> public ScreenshotSize get() { <START> if (config.getScreenshotSize() == ScreenshotSize.DOUBLE_SIZE) { <END> return ScreenshotSize.DOUBLE_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.NORMAL_SIZE) { return ScreenshotSize.NORMAL_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.HALF_SIZE) { return ScreenshotSize.HALF_SIZE; } else if (config.getScreenshotSize() == ScreenshotSize.QUARTER_SIZE) { return ScreenshotSize.QUARTER_SIZE; } else { return ScreenshotSize.NORMAL_SIZE; } }
<|startcomment|> Why make this non-final? Given how important this method is for its serialization/internal representation, it's pretty important that it not be overridden. <|endcomment|> <START> public String canonicalID() { <END> return canonical; }
<|startcomment|> close does an implicit flush <|endcomment|> protected void close() { try { <START> m_sout.flush(); <END> m_sout.close(); } catch (IOException ex) { } }
<|startcomment|> No need for parentheses. <|endcomment|> protected boolean isProcessed(ChronicleLogOffsetTracker tracker, long offset) { long last = tracker.readLastCommittedOffset(); <START> return (last > 0) && (last >= offset); <END> }
<|startcomment|> Please don't create a new list on every call of getDifferences(), but create the list once, e.g., on the first call, and then return the same instance. You might want to use an UnmodifiableEList instead, to fail early, if someone tries to modify it. <|endcomment|> public EList<Diff> getDifferences() { <START> return new BasicEList<Diff>(this.diffs); <END> }
<|startcomment|> @clevertension Why do we need to expose `IOWorkers.Selector`? Looks completely unnecessary to me. <|endcomment|> <START> public IOWorkers.Selector getWorkerSelector() { <END> return workerSelector; }
<|startcomment|> `super.children().forEach(res::add);` ? <|endcomment|> public Iterable<Tree> children() { List<Tree> result = new ArrayList<>(); if(openParenToken != null) { result.add(openParenToken); } <START> for (Tree tree : super.children()) { <END> result.add(tree); } if(closeParenToken != null) { result.add(closeParenToken); } return result; }
<|startcomment|> `requireNonNull` could be on same line than affectation. <|endcomment|> public void setName(String name) { Objects.requireNonNull(name); <START> this.name = name; <END> }
<|startcomment|> I believe it should be `omitNorms() || indexOptions() != IndexOptions.NONE` <|endcomment|> public Query existsQuery(QueryShardContext context) { if (hasDocValues()) { return new DocValuesFieldExistsQuery(name()); <START> } else if (omitNorms()) { <END> return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())); } else { return new NormsFieldExistsQuery(name()); } }
<|startcomment|> This method should be static <|endcomment|> <START> private void handleYieldExpression(SubscriptionContext ctx, PyYieldExpressionTree yieldExpr) { <END> if (yieldExpr.fromKeyword() == null && yieldExpr.expressions().size() == 1) { yieldExpr.expressions().forEach(e -> checkExpr(e, ctx, "yield")); } }
<|startcomment|> We do not need to declare that this throws an `LDAPException`. <|endcomment|> <START> private void importLdif(InMemoryDirectoryServer directoryServer) throws LDAPException { <END> if (StringUtils.hasText(this.ldif)) { try { Resource resource = locateResource(); try (InputStream inputStream = resource.getInputStream()) { directoryServer.importFromLDIF(false, new LDIFReader(inputStream)); } } catch (Exception ex) { throw new IllegalStateException("Unable to load LDIF " + this.ldif, ex); } } }
<|startcomment|> I would insist in having all methods that use a `CT*` parameter to be annotated as `@Internal` when they are not private. <|endcomment|> <START> public XSSFTableColumn(XSSFTable table, CTTableColumn ctTableColumn) { <END> this.table = table; this.ctTableColumn = ctTableColumn; }
<|startcomment|> We'd use `{` and `}` here or just fold the conditional into a single `return` statement. <|endcomment|> private boolean isDateSelectable(Date date) { <START> if (isCheckDayInSelectableCals && !containsDate(selectableCals, date)) return false; <END> return dateConfiguredListener == null || dateConfiguredListener.isDateSelectable(date); }
<|startcomment|> make static <|endcomment|> <START> public void updatePathGroup(List<Variable> <END> variables, IPath node, IPath selection) { final int segmentsSelection = selection.segmentCount(); for (final Variable variable : variables) if (variable.getPath().uptoSegment(segmentsSelection).equals(selection.makeAbsolute())) { final IPath oldPath = variable.getPath(); final int count = selection.segmentCount(); variable.setPath(buildPath(oldPath, node, count)); } }
<|startcomment|> is this necessary? <|endcomment|> private FactorComparator(String factorName, int weight, Comparator<T> comparator){ this.factorName = factorName; this.weight = weight; this.comparator = comparator; <START> logger.info("comparator created for " + this.factorName); <END> }
<|startcomment|> why was this done? <|endcomment|> <START> public PatternMatcher(TermContext context) { <END> this.termContext = context; multiSubstitutions = new ArrayList<java.util.Collection<Map<Variable, Term>>>(); }
<|startcomment|> result = prime * result + getBranchId().hashCode(); can use BranchId's hashCode method directly since branchId is not allowed to be null and it will work whether the id is valid or not <|endcomment|> public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((getArtUuid() == null) ? 0 : getArtUuid().hashCode()); <START> result = prime * result + ((getBranchId().isInvalid()) ? 0 : getBranchId().hashCode()); <END> return result; }
<|startcomment|> Can be private <|endcomment|> <START> protected void <END> setUpGetUnregisteredVmTemplateExpectations(boolean notFound) { setUpEntityQueryExpectations( QueryType.GetUnregisteredVmTemplate, GetUnregisteredEntityQueryParameters.class, new String[] { "StorageDomainId", "EntityId" }, new Object[] { STORAGE_DOMAIN_ID, TEMPLATE_ID }, notFound ? null : getEntity(1)); }
<|startcomment|> The whole purpose of FullListAdapter is to abstract the implementation details of querying the device list from the caller - so how about moving the changes that are done in VmDevicesMonitoring to FullListVDSCommand ? <|endcomment|> <START> public boolean isDomainXmlEnabledForVds(Guid vdsId) { <END> return FeatureSupported.isDomainXMLSupported(getVdsManager(vdsId).getCompatibilityVersion()); }
<|startcomment|> Please add {} also for `if` blocks with only one statement. <|endcomment|> public void mousePressed(MouseEvent e) { <START> if (e.isPopupTrigger()) <END> doPop(e); }
<|startcomment|> Use .getSize to see if element is on page <|endcomment|> public boolean isSuggestionListDisplayed() { try { <START> waitForElementByElement(searchSuggestions.get(0)); <END> return searchSuggestions.get(0).isDisplayed(); } catch (NoSuchElementException|IndexOutOfBoundsException e) {} return false; }
<|startcomment|> no need to use String.format as there is no parameter. Either provide directly throw new IllegalArgumentException("Port must be greater than 0"); or maybe improve message with somethign like: throw new IllegalArgumentException(String.format("Port must be greater than 0 (provided {0})", port)); <|endcomment|> public ConnectionId(final String host, final int port, final String connectionId) { Objects.requireNonNull(host); if (port <= 0) { <START> throw new IllegalArgumentException(String.format("Port must be greater than 0")); <END> } this.host = host; this.port = port; this.connectionId = connectionId; }
<|startcomment|> use static import. <|endcomment|> public RecursiveLoggerContextInstantiationException(String message) { <START> super(I18nMessageFactory.createStaticMessage(message)); <END> }
<|startcomment|> why is it public? <|endcomment|> <START> public Map<String, MetricPlotDTOs> createTaskPlots() { <END> sessionId = getSessionIdProvider().getSessionId(); // check new model List<MetricPointEntity> metricDetails = getHibernateTemplate().find( "select m from MetricPointEntity m where m.metricDescription.taskData.sessionId=?", sessionId); if (metricDetails == null || metricDetails.isEmpty()) { return oldWay(); } else { return newWay(metricDetails); } }
<|startcomment|> Why not inline this variable? <|endcomment|> public void testDeadlock() throws Exception { doTest(1000 * 30); // 30 secs almost always locks boolean <START> interrupted = <END> Thread.interrupted(); if (interrupted) { fail("Thread was interrupted at end of test"); } }
<|startcomment|> instead of creating a new object every time, it might make more sense to store constants for each predefined granularity string <|endcomment|> public static QueryGranularity fromString(String str) { String name = str.toUpperCase(); if(name.equals("ALL")) { return QueryGranularity.ALL; } else if(name.equals("NONE")) { return QueryGranularity.NONE; } else if(CAL<END>RIC_GRANULARITIES.containsKey(name)) { <START> return new PeriodGranularity(CAL<END>RIC_GRANULARITIES.get(name), null, null); <END> } return new DurationGranularity(convertValue(str), 0); }
<|startcomment|> style nit: we don't use braces around single line blocks <|endcomment|> public Object[] getElements(Object element) { <START> if (element instanceof Object[]) { <END> return (Object[]) element; } if (element instanceof Collection) { return ((Collection) element).toArray(); } return new Object[0]; }
<|startcomment|> maybe we should create a common utility function to build EventLoopGroups and do not duplicate this kind of code <|endcomment|> public void setUp() throws Exception { super.setUp(); <START> if (SystemUtils.IS_OS_LINUX) { <END> try { eventLoopGroup = new EpollEventLoopGroup(); } catch (Throwable t) { LOG.warn("Could not use Netty Epoll event loop {}", t.getMessage()); eventLoopGroup = new NioEventLoopGroup(); } } else { eventLoopGroup = new NioEventLoopGroup(); } executor = OrderedSafeExecutor.newBuilder() .name("BKClientOrderedSafeExecutor") .numThreads(2) .build(); }
<|startcomment|> Don't need the `toString` call. <|endcomment|> private void readInternal(long position, byte[] buffer, int bufferOffset, int bufferLength) { try { long readStart = System.nanoTime(); inputStream.readFully(position, buffer, bufferOffset, bufferLength); stats.readDataBytesPerSecond(bufferLength, System.nanoTime() - readStart); } catch (PrestoException e) { // just in case there is a Presto wrapper or hook throw e; } catch (Exception e) { <START> throw new PrestoException(HIVE_FILESYSTEM_ERROR, format("Error reading from %s at position %s", id.toString(), position), e); <END> } }
<|startcomment|> Don't you prefer to use assertEquals? <|endcomment|> public void invalidPropertiesFormat() { VmDevice device = new VmDevice(); device.setType(VmDeviceGeneralType.DISK); device.setCustomProperties("bootable"); DevicePropertiesUtils utils = mockDevicePropertiesUtils(); List<ValidationError> errors = utils.validateDeviceProperties(Version.v3_3, device); assertFalse(errors.isEmpty()); <START> assertTrue(errors.get(0).getReason() == ValidationFailureReason.SYNTAX_ERROR); <END> }
<|startcomment|> If this is the use of the "MANDATORY" constant then you may want to define it as a "Name" instead of "String": privates static final Name MANDATORY = NameParser.parseUsingCase("Mandatory"); Then you can compare it easily: return expression.getMethod().equals(MANDATORY); <|endcomment|> private boolean isMandatory(MethodExpression expression) { <START> return expression.getMethod().getWords().get(0).equals(MANDATORY) ? true : false; <END> }
<|startcomment|> Good change making this an instance member, thanks. <|endcomment|> <START> private DeltaVisit next() { <END> // If our parent has no more children, discard it. if (parent != null && parent.nextChild == null) { parent.data = null; parent = parent.parent; } if (nextChild != null) return new DeltaVisit(this); // If we have no child ourselves, our parent must (if it exists), // due to the discard rule above. With no parent, we are done. if (parent != null) return new DeltaVisit(parent); return null; }
<|startcomment|> we can do something like: numOfSkips = ++numOfSkips % MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM; return numOfSkips == 0; and remove clearSkipCounter, no? if this was already properly verified, we can merge this and think about the change above on master-only <|endcomment|> boolean delayNextTimeToRun(Date timeToRunTheVm) { this.timeToRunTheVm = timeToRunTheVm; <START> return ++numOfSkips < MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_<START>_VM; <END> }
<|startcomment|> Of the "53" class of errors, I think only "53300" might be transient, no? <|endcomment|> protected boolean isTransientException(Throwable e) { if(e instanceof SQLException) { final String sqlState = ((SQLException) e).getSQLState(); // retry on connection errors and insufficient resources // (see http://www.postgresql.org/docs/current/static/errcodes-appendix.html) <START> return sqlState.startsWith("08") || sqlState.startsWith("53"); <END> } return false; }
<|startcomment|> So you pointed me to this line and what is the problem here ? The problem is that discardAcknowledgedOperations is never called. This was never done in this method anyway. <|endcomment|> public JupiterActivity generateJupiterActivity(Operation op, User source, SPath editor) { // send(op, myMsgs, otherMsgs); JupiterActivity jupiterActivity = new JupiterActivity(this.vectorTime, op, source, editor); // add(op, myMsgs) to outgoing; <START> if (!(op instanceof TimestampOperation)) { <END> this.ackJupiterActivityList.add( new OperationWrapper(op, this.vectorTime.getLocalOperationCount())); } // myMsgs = myMsgs + 1; this.vectorTime = this.vectorTime.incrementLocalOperationCount(); return jupiterActivity; }
<|startcomment|> Should it be assignExecutor(1, flow.getExecutionId())? Also how do you know 1 is a non-existent executor? <|endcomment|> public void testAssignExecutorInvalidExecutor() throws Exception { final ExecutableFlow flow = TestUtils.createExecutableFlow("exectest1", "exec1"); this.executionFlowDao.uploadExecutableFlow(flow); assertThatThrownBy( <START> () -> this.assignExecutor.assignExecutor(flow.getExecutionId(), 1)) <END> .isInstanceOf(ExecutorManagerException.class) .hasMessageContaining("non-existent executor"); }
<|startcomment|> no `Exception` is thrown here <|endcomment|> private static BackgroundHiveSplitLoader backgroundHiveSplitLoaderOfflinePartitions() <START> throws Exception <END> { ConnectorSession connectorSession = new TestingConnectorSession( new HiveSessionProperties(new HiveClientConfig().setMaxSplitSize(new DataSize(1.0, GIGABYTE))).getSessionProperties()); return new BackgroundHiveSplitLoader( SIMPLE_TABLE, createPartitionMetadataWithOfflinePartitions(), TupleDomain.all(), createBucketSplitInfo(Optional.empty(), ImmutableList.of()), connectorSession, new TestingHdfsEnvironment(), new NamenodeStats(), new TestingDirectoryLister(TEST_FILES), directExecutor(), 2, false); }
<|startcomment|> 'methodPrefix.toString()' is redundant <|endcomment|> public String toString() { <START> return methodPrefix.toString(); <END> }
<|startcomment|> TCM is an optional Android system service. Check for null. <|endcomment|> private void setPlatformTextClassifier(@Nullable TextClassifier textClassifier) { android.view.textclassifier.TextClassificationManager <START> textClassificationManager = <END> (android.view.textclassifier.TextClassificationManager) mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE); android.view.textclassifier.TextClassifier platformTextClassifier = textClassifier == null ? null : new PlatformTextClassifier(mContext, textClassifier); textClassificationManager.setTextClassifier(platformTextClassifier); }
<|startcomment|> mime type is mandatory <|endcomment|> Object loadServiceCapabilities(String serviceUrl) throws IOException { HttpGet request = new HttpGet(serviceUrl); request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES)); CloseableHttpResponse httpResponse = execute(request, serviceUrl, "retrieve help"); validateResponse(httpResponse, serviceUrl); HttpEntity httpEntity = httpResponse.getEntity(); ContentType contentType = ContentType.getOrDefault(httpEntity); <START> if ("text/plain".equals(contentType.getMimeType())) { <END> return getContent(httpEntity); } return parseJsonMetadata(httpEntity); }
<|startcomment|> I think it is the boss who should be shut down if (!datagram) <|endcomment|> protected void doStop() { log.info("Stopping Netty server"); boss.shutdownGracefully(); if(!datagram) { <START> wrkr.shutdownGracefully(); <END> } try { sock.channel().closeFuture().sync(); } catch (InterruptedException e) { log.warn("Netty server stop interrupted"); Thread.currentThread().interrupt(); } log.info("Netty server stopped"); notifyStopped(); }
<|startcomment|> Maybe pass the layout inflater as a param to the adapter. <|endcomment|> public ChannelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { <START> LayoutInflater inflater = LayoutInflater.from(parent.getContext()); <END> return new ChannelViewHolder((ChannelView) inflater.inflate(R.layout.channel_item_layout, parent, false)); }
<|startcomment|> is there a reason that this is displayed everytime? since this is shown when the second project is selected, it will always be there. <|endcomment|> public void onSelectionChanged(int selectedItemCnt) { int numberMergeSelections = adapter.numberMergeSelections; if (adapter.isMergeSelection && selectedItemCnt >= numberMergeSelections) { <START> ToastUtil.showError(getContext(), "We can only merge " + numberMergeSelections + " projects"); <END> } updateSelectionToggle(actionMode.getMenu().findItem(R.id.toggle_selection)); actionMode.setTitle(getResources() .getQuantityString(getActionModeTitleId(actionModeType), selectedItemCnt, selectedItemCnt)); }
<|startcomment|> The method will grow (i once already wanted to add something here), so what about putting this in a more lengthy but more readable way? (Note, I also changed TopNNode's condition) ``` if (planNode instanceof JoinNode) { return true; } if (planNode instanceof AggregationNode) { return true; // here you could differentiate between partial/... } if (planNode instanceof TopNNode) { return ((TopNNode) planNode).getStep() != TopNNode.Step.FINAL; } return false; ``` <|endcomment|> private boolean shouldBeDistributed(PlanNode planNode) { return planNode instanceof AggregationNode || planNode instanceof JoinNode || <START> (planNode instanceof TopNNode && ((TopNNode) planNode).getStep().equals(TopNNode.Step.PARTIAL)); <END> }
<|startcomment|> ```suggestion assertNotNull(response); ``` <|endcomment|> public void testConcurrency() { final ServerTemplate serverTemplate = templateStorage.load(serverTemplateId); marshal("application/xml", serverTemplate); Thread disconnect = new Thread(() -> disconnect()); disconnect.start(); String response = marshal("application/xml", serverTemplate); <START> LOGGER.info(response); <END> }
<|startcomment|> ```suggestion builder.append(Integer.toString(node.getValue())); ``` Cheaper than going through `String.format` <|endcomment|> protected Void visitIntegerLiteral(IntegerLiteral node, Integer indent) { <START> builder.append(String.format(Locale.ENGLISH, "%d", node.getValue())); <END> return null; }
<|startcomment|> This is essentially one line of code, I'd prefer to inline this. <|endcomment|> <START> private List<GerritQueryResult> executeQueryRest(String query) throws GerritException { <END> List<GerritQueryResult> results = null; results = client.executeQueryRest(new NullProgressMonitor(), query); return results; }
<|startcomment|> to avoid redundant pattern check : ```suggestion this(query, queryType, null); ``` <|endcomment|> public QueryWrapper(@JsonProperty("query") String query, @JsonProperty("queryType") String queryType) { <START> this(query, queryType, ""); <END> }
<|startcomment|> Why not `return ImmutableList.of(compactSegments);` instead? <|endcomment|> private List<CoordinatorDuty> makeCompactSegmentsDuty() { <START> List<CoordinatorDuty> duties = new ArrayList<>(); duties.add(compactSegments); return ImmutableList.copyOf(duties); <END> }
<|startcomment|> The "standard" jclouds pattern would be `checkNotNull(networks, "networks")`, but in this case it's not doing the expected thing since a varargs argument cannot be `null`, it will be an empty array instead. If we want to enforce this check, it probably should be: ``` checkArgument(networks.length > 0, "networks should not be empty"); return networks(ImmutableSet.copyOf(networks)); ``` but since `networks(Iterable<String> networks)` already checks I don't think we need the check here. <|endcomment|> public CreateServerOptions networks(String... networks) { <START> return networks(ImmutableSet.copyOf(checkNotNull(networks, "network should not be empty"))); <END> }
<|startcomment|> Style-nit: We don't put () around ?: in a return. <|endcomment|> private static AbbreviatedObjectId id(DiffEntry de) { <START> return (de.changeType == ChangeType.DELETE ? de.oldId : de.newId); <END> }
<|startcomment|> private <|endcomment|> protected VariableReferenceExpression getVariableReference(RowExpression expression) { if (expression instanceof VariableReferenceExpression) { return ((VariableReferenceExpression) expression); } else { <START> throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), "Expected a variable reference but got " + expression); <END> } }
<|startcomment|> it could be simpler `return this == LOCAL` <|endcomment|> public boolean isLocalOnly() { <START> switch (this) { <END> case LOCAL: return true; default: return false; } }
<|startcomment|> Done <|endcomment|> protected void findUsers(String searchString, AsyncQuery query) { Frontend.getInstance() .runQuery(VdcQueryType.Search, <START> new DirectorySearchParameters("ADUSER@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryUser, (String) getNamespace().getSelectedItem()), query); //$NON-NLS-1$ //$NON-NLS-2$ <END> }
<|startcomment|> if it's v2 older hosts won't work since they use HEAD, no? <|endcomment|> public String getImageUrl(String id) { return getProvider().getUrl() + API_VERSION + "/images/" + id + <START> "/file"; <END> }
<|startcomment|> I recommend using Collections.emptyMap() instead <|endcomment|> public User(@NonNull String username, @NonNull String password) { this(username, password, <START> new HashMap<String, Integer>(), null); <END> }
<|startcomment|> no... this can be relative as well... see: frontend/webadmin/modules/uicommonweb/src/main/java/org/ovirt/engine/ui/uicommonweb/ReportInit.java <|endcomment|> public final String consoleClientResourcesUrl() { String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL); boolean isAbsolute = url.contains("://"); return isAbsolute ? url : Window.Location.getProtocol() + "//" + Window.Location.getHost() + //$NON-NLS-1$ <START> "/" + BaseContextPathData.getInstance().getRelativePath() + url; //$NON-NLS-1$ <END> }
<|startcomment|> don't need this. Just refer to entry.getName() in both places <|endcomment|> private boolean isFileEntryPackageable(ZipEntry entry) { <START> String entryName = entry.getName(); <END> return ApkBuilder.checkFileForPackaging(entry.getName()) && isValidMetaInfEntry(entryName); }
<|startcomment|> I'd just assert that it contains the created VM. <|endcomment|> public void testList() { List<VirtualMachine> list = api().list(); <START> for (VirtualMachine machine : list) { <END> assertTrue(!machine.name().isEmpty()); } }
<|startcomment|> package-private? <|endcomment|> <START> void addLayer(String id, StyleLayer layer) { <END> layersById.put(id, layer); }
<|startcomment|> idem <|endcomment|> public void setSelection(ITimeGraphEntry trace) { /* if there is a pending selection, ignore this one */ synchronized (fListenerNotifierLock) { <START> if (fListenerNotifier != null && fListenerNotifier.hasSelectionChanged()) { <END> return; } } fSelectedEntry = trace; fTimeGraphCtrl.selectItem(trace, false); adjustVerticalScrollBar(); }
<|startcomment|> Why not use the constructor right away, i.e. without reflection? <|endcomment|> private ClassFile newClassFile(String name, int accessFlags, String superclass, String... interfaces) { try { <START> return SecurityActions.getConstructor(ClassFile.class, String.class, int.class, String.class, ClassLoader.class, Arrays2.EMPTY_STRING_ARRAY.getClass()) <END> .newInstance(name, accessFlags, superclass, classLoader, interfaces); } catch (Exception e) { throw BeanLogger.LOG.unableToCreateClassFile(name, e.getCause()); } }
<|startcomment|> We can change the return type of getLocalClassLoader only in the implementation to avoid the cast. <|endcomment|> public boolean addListener(String type, long id, ClassLoaderListener classLoaderListener) { <START> final VirtualClassLoader localClassLoader = ((VirtualClassLoader) getLocalClassLoader(type, id)); <END> return localClassLoader.addListener(classLoaderListener); }
<|startcomment|> JDT uses compact assignement, e.g. i= 3; <|endcomment|> public static final void setPreferenceNodeId (String id) { if (fgPreferenceNodeId == null) { <START> fgPreferenceNodeId = <END> id; } }
<|startcomment|> Please remove this. This is probably due to an incorrect /etc/hosts file in your test environment <|endcomment|> private void init() { // get the localhost. try { hostname = InetAddress.getLocalHost().getHostName(); <START> hostname = "localhost"; <END> } catch (UnknownHostException e) { logger.warn("Error getting the value of localhost. " + "Proceeding with 'localhost'.", e); } }
<|startcomment|> Make it package private by removing the `protected` modifier. <|endcomment|> <START> protected OSImageToImage(JustProvider provider) { <END> this.provider = provider; }
<|startcomment|> return immediately, no need to store it in a local var <|endcomment|> private Optional<Cookie> findCookieWithName(String cookieName, HttpClient httpClient) { <START> Optional<Cookie> cookie = <END> Arrays.stream(httpClient.getState().getCookies()) .filter(c -> cookieName.equals(c.getName())) .findFirst(); return cookie; }
<|startcomment|> This class is effectively a provider. Instead of doing the export directly, we should bind the JMX export when we bind IO pool and let the export happen the normal way. <|endcomment|> public void destroy() { // clients must be destroyed before the pools or // you will create a several second busy wait loop for (JettyHttpClient client : clients) { client.close(); } if (pool != null) { pool.close(); pool = null; <START> if(injector.getExistingBinding(Key.get(MBeanExporter.class)) != null) { <END> injector.getInstance(MBeanExporter.class) .unexport(generatedNameOf(QueuedThreadPoolMBean.class) + "_" + name); } } destroyed.set(true); }
<|startcomment|> you could do the difference and return in inside the if, and save 2 checks. <|endcomment|> private Set<String> expandRegionalChannelUris(String channelUri) { Set<String> expandedUris = null; if (BBC1_TXLOG_CHANNEL_URIS.contains(channelUri)) { expandedUris = BBC1_TXLOG_CHANNEL_URIS; } if (BBC2_TXLOG_CHANNEL_URIS.contains(channelUri)) { expandedUris = BBC2_TXLOG_CHANNEL_URIS; } <START> return expandedUris == null ? null : Sets.difference(expandedUris, ImmutableSet.of(channelUri)); <END> }
<|startcomment|> Should "planner.enable_hashagg" be set to **false** ? "planner.enable_streamagg" defaults to **true** anyway. <|endcomment|> public void testMultipleBatchesLateral_WithStreamingAgg() throws Exception { String sql = "SELECT t2.maxprice FROM (SELECT customer.c_orders AS c_orders FROM " + "dfs.`lateraljoin/multipleFiles/` customer) t1, LATERAL (SELECT CAST(MAX(t.ord.o_totalprice)" + " AS int) AS maxprice FROM UNNEST(t1.c_orders) t(ord) GROUP BY t.ord.o_orderstatus) t2"; testBuilder() .optionSettingQueriesForTestQuery("alter session set `%s` = true", <START> PlannerSettings.STREAMAGG.getOptionName()) <END> .sqlQuery(sql) .unOrdered() .baselineColumns("maxprice") .baselineValues(367190) .baselineValues(316347) .baselineValues(146610) .baselineValues(306996) .baselineValues(235695) .baselineValues(177819) .build().run(); }
<|startcomment|> This might throw IllegalArgumentException in case `value` doesn't match any enum constant. It's much easier to compare `value` to name() of enum constants: for (GlusterStatus status : values) { if (status.name().equals(value)) { return true; } } return false; <|endcomment|> public boolean isType(String value) { GlusterStatus volStatus = <START> GlusterStatus.valueOf(value); <END> for (GlusterStatus status : values) { if (status.equals(volStatus)) { return true; } } return false; }
<|startcomment|> `ctx.close()` <|endcomment|> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); <START> ctx.channel().close(); <END> }
<|startcomment|> remove public <|endcomment|> <START> public CloseNoOpServerProtocolHandler(String websocketPath) { <END> super(websocketPath, null, false); }
<|startcomment|> Since you are forcing the orientation, it might be a good idea to use the `super.setOrientation()` instead, override the `setOrientation()` method and only print a log or throw an exception if someone tries to mess with it <|endcomment|> public MessageView(Context context, AttributeSet attrs) { super(context, attrs); <START> setOrientation(VERTICAL); <END> }
<|startcomment|> Shouldn't it be a part of `shape#setUUID` method? <|endcomment|> public Canvas addShapeIntoView(final Shape shape) { if (shape.getUUID() == null) { shape.setUUID(UUID.uuid()); } <START> shape.getShapeView().setUUID(shape.getUUID()); <END> getView().add(shape.getShapeView()); return this; }
<|startcomment|> You don't need to give this string (even as other similar do) since it's the default message for getRequiredParam(key). <|endcomment|> public boolean getRequiredParamBoolean(final String key) throws ActionParamsException { <START> final String errMsg = "Required parameter '" + key + "' missing!"; <END> final String val = getRequiredParam(key, errMsg); try { return Boolean.parseBoolean(val); } catch (Exception e) { throw new ActionParamsException(errMsg); } }
<|startcomment|> In the `@ReceiveEvent` annotation and in the `@RegisterSystem` annotation you can specify if a event handler / all event handlers of that class are for a server or client. So you don't need to check the mode of networkSystem. <|endcomment|> public void onPingFromClient(PingFromClientEvent event, EntityRef entity){ <START> if (networkSystem.getMode().isServer()) { <END> Instant end = Instant.now(); endMap.put(entity, end); updatePing(entity); } }
<|startcomment|> This block is useless. <|endcomment|> public boolean areEqual(MapObject o1, MapObject o2) { if (o1 == null ^ o2 == null) { return false; <START> } else if (o1 == o2) { <END> return true; } else { return o1.id.equals(o2.id); } }
<|startcomment|> `StringRedisTemplate` constructor takes care of it. <|endcomment|> public RedisMetadataStore(RedisConnectionFactory connectionFactory) { Assert.notNull(connectionFactory, "'connectionFactory' must not be null."); this.redisTemplate = new StringRedisTemplate(connectionFactory); <START> this.redisTemplate.afterPropertiesSet(); <END> }
<|startcomment|> Can you use the inherited "m_isLeaderToReplica" instead of adding a new "m_toLeader"? The message is either from leader to replica or from MPI to leader? <|endcomment|> public CompleteTransactionMessage(long initiatorHSId, long coordinatorHSId, long txnId, boolean isReadOnly, int hash, boolean isRollback, boolean requiresAck, boolean isRestart, boolean isForReplay) { super(initiatorHSId, coordinatorHSId, txnId, 0, isReadOnly, isForReplay); m_hash = hash; setBit(ISROLLBACK, isRollback); setBit(REQUIRESACK, requiresAck); setBit(ISRE<START>, isRestart); <START> m_toLeader = false; <END> m_ackRequestedFromSender = true; }
<|startcomment|> This will always return true, did you want cuEinvoiceDao instead of null here <|endcomment|> private CuEinvoiceDao getCuEinvoiceDao() { <START> if (ObjectUtils.isNull(null)) { <END> cuEinvoiceDao = SpringContext.getBean(CuEinvoiceDaoOjb.class); } return cuEinvoiceDao; }
<|startcomment|> Can we make this method private? <|endcomment|> <START> public static EchoTagStatementTree newEchoTagStatement(ExpressionTree expression, InternalSyntaxToken eosToken) { <END> SeparatedList<ExpressionTree> expressionList = new SeparatedListImpl(Collections.singletonList(expression), Collections.emptyList()); return newEchoTagStatement(expressionList, eosToken); }
<|startcomment|> Perhaps it would be better to return null instead of throwing an exception? Nothing has really gone wrong. And then you wouldn't need that empty catch block. <|endcomment|> private static TextSummarizer getLocalSummarizer() throws IOException { Collection<? extends TextSummarizer> summarizers = Lookup.getDefault().lookupAll(TextSummarizer.class ); if (!summarizers.isEmpty()) { summarizerToUse = summarizers.iterator().next(); return summarizerToUse; } <START> throw new IOException("No summarizers found"); <END> }
<|startcomment|> could you please put it in brackets to make it easier to read? <|endcomment|> public void verifyNoVideo() { if(checkIfElementOnPage(mediaNode)) <START> throw new AssertionError("Media Node is still on the page"); <END> else PageObjectLogging.log("verifyNoVideo", "Verified no video is on page", true, driver); }
<|startcomment|> Is it save to assign a new subscription here without unsubscribing a potentially existing previous subscription? Or to ask different: Can you guarantee this is not called two times in a row in the activity lifecycle with requireGeodata==true? <|endcomment|> private void startOrStopGeoDataListener() { if (requireGeodata) { <START> geoDataSubscription = locationUpdater.start(GeoDirHandler.UPDATE_GEODATA); <END> } else { geoDataSubscription.unsubscribe(); } }
<|startcomment|> not needed. <|endcomment|> ZipFormatter( <START> Formatters formatters, <END> FormatterUtil formatterUtil, HtmlBuilder html) { this.formatters = formatters; this.util = formatterUtil; this.html = html; }
<|startcomment|> I think I saw multiple ppc types in the enum: ppc, ppc64, ppcle, ppc64le <|endcomment|> private boolean clusterHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); return cluster != null && cluster.getArchitecture() != null <START> && ArchitectureType.ppc.getFamily() == cluster.getArchitecture().getFamily(); <END> }
<|startcomment|> We can make this private <|endcomment|> <START> protected void createIndex(Connection conn, String indexExt, String columnName) throws PersistenceException { <END> if (metaData.isIndexingDisabled()) return; boolean indexExists = indexExists(getIndexName(false, indexExt), conn); if (!indexExists) { String ddl = String.format("CREATE INDEX %s ON %s (%s)", getIndexName(true, indexExt), getTableName(), columnName); if (log.isTraceEnabled()) { log.tracef("Adding index with following DDL: '%s'.", ddl); } executeUpdateSql(conn, ddl); } }
<|startcomment|> This should be simplified to just: >return value; <|endcomment|> public Object getValue() { <START> if (value == null) { <END> return null; } else { return value; } }
<|startcomment|> `false ==` is a peculiar way to express `!`. BTW, `peculiar` is a polite way to say `wrong`. <|endcomment|> private boolean needProjectionNode (AbstractPlanNode root) { <START> if ( false == root.planNodeClassNeedsProjectionNode()) { <END> return false; } // If there is a complexGroupby at his point, it means that // display columns contain all the order by columns and // does not require another projection node on top of sort node. // If there is a complex aggregation case, the projection plan node is already added // right above the group by plan node. In future, we may inline that projection node. if (m_parsedSelect.hasComplexGroupby() || m_parsedSelect.hasComplexAgg()) { return false; } if (root instanceof AbstractReceivePlanNode && m_parsedSelect.hasPartitionColumnInGroupby()) { // Top aggregate has been removed, its schema is exactly the same to // its local aggregate node. return false; } return true; }
<|startcomment|> just one cell please <|endcomment|> public void isExecutable_HeaderCellSelected() { when(scenarioGridModelMock.getSelectedCells()).thenReturn(Collections.emptyList()); <START> when(scenarioGridModelMock.getSelectedHeaderCells()).thenReturn(Lists.create(selectedCell, selectedCell2)); <END> assertTrue(handler.isExecutable(scenarioGridMock)); }
<|startcomment|> This is not really relevant IMO. It's not data of that rules, just an internal helper. In practice this is always going to be true anyway since it's a singleton component. <|endcomment|> public boolean equals(Object object) { if (object == this) { return true; } if (!(object instanceof XarSecurityRule)) { return false; } XarSecurityRule rhs = (XarSecurityRule) object; return new EqualsBuilder() .append(this.right, rhs.right) .append(this.simple, rhs.simple) <START> .append(this.securityTool, rhs.securityTool) <END> .isEquals(); }
<|startcomment|> Any reason why you added `ReflectionHelper.`? Might as well remove it so that we see it's a method of this very class? <|endcomment|> public static boolean containsSearchAnnotations(XClass mappedClass) { <START> List<XClass> hierarchy = ReflectionHelper.createXClassHierarchy( mappedClass ); <END> for ( XClass clazz : hierarchy ) { if ( containsLocalSearchAnnotation( clazz ) ) { return true; } } return false; }
<|startcomment|> `Math.max(newUsedCapacity, currentCapacity)` would be a little bit clearer here. <|endcomment|> private static int computeNewVectorCapacity(int usedCapacity, int newPayload, int currentCapacity) { int newUsedCapacity = BaseAllocator.nextPowerOfTwo(usedCapacity + newPayload); assert newUsedCapacity >= 0; <START> return newUsedCapacity <= currentCapacity ? currentCapacity : newUsedCapacity; <END> }
<|startcomment|> This doesn't help at all, I suspect it can even cause loss of the logs. Logback already have solved the problem, and we have it enabled https://github.com/CorfuDB/CorfuDB/blob/30c8d154f59dfe22d4cc16b94ab9e2c51851c2e5/infrastructure/src/main/resources/logback.prod.xml#L5 <|endcomment|> private static void cleanShutdown() { log.info("CleanShutdown: Starting Cleanup."); shutdownServer = true; try { CorfuServerNode current = activeServer; if (current != null) { activeServer.close(); } } catch (Throwable th) { log.error("cleanShutdown: failed during shutdown", th); } // Flush the async appender before exiting to prevent the loss of logs <START> LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory(); <END> loggerContext.stop(); }
<|startcomment|> As I said in the last PR (https://github.com/AntiqueAtlasTeam/AntiqueAtlas/pull/205) that did something like this, this should use `LogManager.getLogger(...)`. Honestly, `Log#modLog` should just be changed to ```java private static final Logger LOGGER = LogManager.getLogger(AntiqueAtlasMod.ID); ``` <|endcomment|> public void preInit(FMLPreInitializationEvent event) { <START> Log.setModLog(event.getModLog()); <END> configDir = new File(event.getModConfigurationDirectory(), "antiqueatlas"); configDir.mkdir(); extTileIdMap = ExtTileIdMap.instance(); extTileConfig = new ExtTileConfig(new File(configDir, "tileids.json")); extTileConfig.load(extTileIdMap); // Assign default values AFTER the config file loads, so that the old saved values are kept: registerVanillaCustomTiles(); checkSaveConfig(); }
<|startcomment|> Checkstyle violation: ``` [ant:checkstyle] [ERROR] /home/travis/build/spring-projects/spring-integration/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpSession.java:157: 'if' construct must use '{}'s. [NeedBraces] ``` You can verify yourself locally using `gradlew clean :spring-integration-ftp:check` <|endcomment|> public void close() { try { if (this.readingRaw.get() && !finalizeRaw() && LOGGER.isWarnEnabled()) { LOGGER.warn("Finalize on readRaw() returned false for " + this); } <START> if (this.client.isConnected()) <END> this.client.logout(); this.client.disconnect(); } catch (Exception e) { LOGGER.warn("failed to disconnect FTPClient", e); } }
<|startcomment|> No extra (clutter) please. <|endcomment|> protected FileType doGetType() throws Exception { <START> return (this.stat == null) ? FileType.IMAGINARY : FileType.FILE_OR_FOLDER; <END> }
<|startcomment|> `capacity * loadFactor` maybe? <|endcomment|> public EquivalentHashMap( int initialCapacity, float loadFactor, Equivalence<K> keyEq, Equivalence<V> valueEq) { int capacity = 1; while (capacity < initialCapacity) capacity <<= 1; this.loadFactor = loadFactor; <START> threshold = (int)(capacity * DEFAULT_LOAD_FACTOR); <END> table = new Node[capacity]; this.keyEq = keyEq; this.valueEq = valueEq; }
<|startcomment|> just throw the exception upwards.. <|endcomment|> <START> private void mockSSHClient() { <END> try { doNothing().when(sshclient).connect(); doNothing().when(sshclient).authenticate(); } catch(Exception e) {} }
<|startcomment|> ![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck) <|endcomment|> public static String sanitizeKey(final Contentlet vanityUrl) <START> throws DotDataException, DotRuntimeException, DotSecurityException { <END> Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR), APILocator.systemUser(), false); return sanitizeKey(host.getIdentifier(), fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)), vanityUrl.getLanguageId()); }
<|startcomment|> You can revert this change now. <|endcomment|> protected void dataTemplateToJsonGenerator(Object data, DataSchema schema, JsonGenerator generator, boolean order) throws IOException { if (order) { JacksonTraverseCallback callback = new SchemaOrderTraverseCallback(schema, generator); Data.traverse(data, callback); } else { <START> objectToJsonGenerator(data, generator, false); <END> } }
<|startcomment|> these exceptions are unacceptable (intended pun miserably failed) we are listing clusters, no resource-, allocation-, or any change related exception should ever occur. at most a entity not found kind of thing. <|endcomment|> <START> public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException { <END> ListResponse<KubernetesSupportedVersionResponse> response = kubernetesVersionService.listKubernetesSupportedVersions(this); response.setResponseName(getCommandName()); setResponseObject(response); }
<|startcomment|> the turnOff is not really needed <|endcomment|> public void loggedInUserPropertyFalseTest() throws Exception { <START> context.turnOffAuthorisationSystem(); <END> configurationService.setProperty("webui.user.assumelogin", false); context.restoreAuthSystemState(); String token = getAuthToken(admin.getEmail(), password); getClient(token).perform(get("/api/authn/status") .header("X-On-Behalf-Of", eperson.getID())) .andExpect(status().isBadRequest()); context.turnOffAuthorisationSystem(); configurationService.setProperty("webui.user.assumelogin", true); context.restoreAuthSystemState(); }
<|startcomment|> Could use an entrySet. <|endcomment|> protected void addExtraHeaders(Builder webResource) { if (additionalHeaders != null) { <START> for (String key : additionalHeaders.keySet()) { <END> webResource.header(key, additionalHeaders.get(key)); } } }
<|startcomment|> I think return (newList.size() > currentList.size()) is sufficient <|endcomment|> private boolean hasNewFragment(EList<InteractionFragment> currentList, List<InteractionFragment> newList) { <START> boolean newFragment = false; if (newList.size() > currentList.size()) { newFragment = true; } return newFragment; <END> }
<|startcomment|> This is unnecessary as generatedKeysResultSet is added to activeResultSets when created <|endcomment|> void closeResultSets() throws SQLException { closeResultSets(activeResultSets); <START> <END> if (generatedKeysResultSet != null && !generatedKeysResultSet.isClosed()) { generatedKeysResultSet.internalClose(); } generatedKeysResultSet = null; }
<|startcomment|> The scope of this `try` block is broader than necessary. It only needs to contain this line. <|endcomment|> public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader, ResourceLoader resourceLoader) { if (ClassUtils.isPresent("org.apache.jasper.compiler.JspConfig", classLoader)) { try { String resourceName = getResourceName(view, environment); if (resourceLoader.getResource(resourceName).exists()) { return true; } <START> return new File("src/main/webapp", resourceName).exists(); <END> } catch (AccessControlException ex) { return false; } } return false; }
<|startcomment|> Why does this return Object instead of T ? <|endcomment|> <START> public Object visit(final AntlrBaseNode node) { <END> return node.accept(this); }
<|startcomment|> please remove alias setting (should be encapsulated in addManagedDevice <|endcomment|> public static void addDiskToVm(BaseDisk disk, Guid vmId) { DbFacade.getInstance().getBaseDiskDao().save(disk); VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId), VmDeviceType.DISK, VmDeviceType.DISK, null, true, false, <START> ""); <END> }
<|startcomment|> return here <|endcomment|> private static Throwable getConfigFailureException(ITestContext context) { Throwable t = null; for (IInvokedMethod method : context.getSuite().getAllInvokedMethods()) { ITestNGMethod m = method.getTestMethod(); if (m.isBeforeSuiteConfiguration() && (!method.getTestResult().isSuccess())) { <START> t = method.getTestResult().getThrowable(); <END> break; } } return t; }
<|startcomment|> I recommend adding `{}` here <|endcomment|> protected String toString(Operator operator) { <START> if (Operator.<START>SWITH.equals(operator)) return LIKE; <END> return operator.toString(); }
<|startcomment|> This looks like a leftover and it hasn't any usage. Can we remove it? <|endcomment|> <START> static UberDocument toUberDocument(final Object object) { <END> if (object == null) { return null; } if (object instanceof UberDocument) { return (UberDocument) object; } if (object instanceof Iterable) { } else if (object instanceof Map) { } throw new IllegalArgumentException("Don't know how to handle type : " + object.getClass()); }
<|startcomment|> There is no point exposing this constructor if there is not even a single public method. All methods are private (except for the static, which does not require a constructor to be used) <|endcomment|> <START> public ArgumentSplitter(String arguments) { <END> this.arguments = arguments; }
<|startcomment|> please improve error handling in accordance to: https://github.com/knowm/XChange/wiki/New-Implementation-Best-Practices#step-7 you should introduce and LgoException that implements HttpStatusExceptionSupport try catch adapt should be done in methods that implement generic interfaces, *Raw methods should throw our the LgoException <|endcomment|> public LgoProducts getProducts() { LgoProducts products = null; try { products = this.proxy.getProducts( exchange.getNonceFactory().createValue(), exchange.getSignatureService()); <START> } catch (HttpStatusIOException e) { <END> LgoErrorAdapter.adapt(e); } return products; }
<|startcomment|> Do you still need to prepend the blank space, now that you're using MessageFormat.format()? If not, then you should be able to simplify this a little further. <|endcomment|> protected void addAttachmentToNote(T document, AccountingXmlDocumentBackupLink backupLink, Note note) { try { Attachment attachment = accountingXmlDocumentDownloadAttachmentService.createAttachmentFromBackupLink(document, backupLink); note.setAttachment(attachment); } catch (IOException e) { LOG.error("addAttachmentToNote, unable to create attachment: " + e.getMessage()); String message = MessageFormat.format( configurationService.getPropertyValueAsString(CuFPKeyConstants.ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD), <START> KFSConstants.BLANK_SPACE + backupLink.getLinkUrl()); <END> throw new ValidationException(message); } }
<|startcomment|> This is effectively final class, so just `throw new UnsupportedOperationException()` <|endcomment|> public Void getResult() { <START> throw new UnsupportedOperationException(getClass().getName()); <END> }
<|startcomment|> Please add the actual type, just in case it ever fails <|endcomment|> public PlanWithProperties visitUnnest(UnnestNode node, PreferredProperties preferredProperties) { PreferredProperties translatedPreferred = preferredProperties.translate(variable -> { <START> checkArgument(variable instanceof VariableReferenceExpression, "Expect VariableReferenceExpression"); <END> return node.getReplicateVariables().contains(variable) ? Optional.of(variable) : Optional.empty(); }); return rebaseAndDeriveProperties(node, planChild(node, translatedPreferred)); }
<|startcomment|> please put the correct status. <|endcomment|> public ValidationResult isAnyDomainInProcess() { List<StoragePoolIsoMap> poolIsoMaps = getStoragePoolIsoMapDao().getAllForStoragePool(storagePool.getId()); for (StoragePoolIsoMap domainIsoMap : poolIsoMaps) { if (domainIsoMap.getStatus() != null && domainIsoMap.getStatus().isStorageDomainInProcess()) { return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2, <START> String.format("$status %1$s", StorageDomainStatus.Locked)); <END> } } return ValidationResult.VALID; }
<|startcomment|> static <|endcomment|> <START> private boolean isFunctionNameMatch(RowExpression rowExpression, String expectedName) <END> { if (castToExpression(rowExpression) instanceof FunctionCall) { return ((FunctionCall) castToExpression(rowExpression)).getName().toString().equalsIgnoreCase(expectedName); } return false; }
<|startcomment|> We can slightly simplify: ```java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType()); ``` <|endcomment|> public boolean hasError() { <START> return result != null && result.getType() != null && CommandResult.Type.ERROR.equals(result.getType()); <END> }
<|startcomment|> Why did you have to change the order of the lines here?... <|endcomment|> private void setupVdsNetworkInterfaceDao() { when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(vdsNetworkInterfaceDaoMock); List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface); when(vdsNetworkInterfaceDaoMock.getVdsInterfacesByNetworkId(networkId)).thenReturn( <START> expectedVdsNetworkInterface); <END> }
<|startcomment|> Do we need this method public ? The place where it's used is in the same package so protected/default should work ? <|endcomment|> <START> public void setProject(IProject project) { <END> this.project=project; }
<|startcomment|> I think this should be `headers.get(name)`. <|endcomment|> public List<String> values(String name) { <START> return headers == null ? null : headers.get("Request-Id"); <END> }
<|startcomment|> dude <|endcomment|> <START> @Override protected Pair<Recipients, Boolean> doInBackground(Recipients... recipients) { <END> Capability textCapability = DirectoryHelper.getUserCapabilities(context, recipients[0]).getTextCapability(); return new Pair<>(recipients[0], textCapability == Capability.SUPPORTED); }
<|startcomment|> Generally speaking, there's no need to null out the fields of an object if no one is going to hold the reference to the object afterwards. The GC is going to do its job, you don't need to help. :) <|endcomment|> public void cleanup() { <START> myIdeFrame = <END> null; myNavigationHelper.cleanup(); myNavigationHelper = null; myStateComponent = null; myTaskContext = null; }
<|startcomment|> Why is this public? <|endcomment|> <START> public static DateTime setBeginValidTime(DateTime beginValidTimeArg, DateTime issueInstant) { <END> DateTime beginValidTime = beginValidTimeArg; final DateTime now = new DateTime(); if (beginValidTime == null || beginValidTime.isAfter(now)) { beginValidTime = now; } // If provided time is after the given issue instant, // modify it to include the issue instant if (beginValidTime.isAfter(issueInstant)) { if (issueInstant.isAfter(now)) { beginValidTime = now; } } else { beginValidTime = issueInstant; } return beginValidTime; }
<|startcomment|> We do not have synchronized protection inside this function, If you would like to protect mUpdateLock from outside of this function, I think you may need to add a note to remind caller in the future to remember protect it. <|endcomment|> private void <START> setupRestrictedNotification() <END> { final Resources res = getResources(mContext, mActiveDataSubId); final String title = res.getString(R.string.disable_tether_notification_title); final String message = res.getString(R.string.disable_tether_notification_message); showNotification(R.drawable.stat_sys_tether_general, title, message, ""); }
<|startcomment|> Any specific reason to make this method no ``static`` anymore ? <|endcomment|> <START> private File getFeatureTypeDir( <END> File featureTypesBaseDir, String namespacePrefix, String typeName) { return new File(featureTypesBaseDir, getDataStoreName(namespacePrefix, typeName)); }
<|startcomment|> Just a note about consistency: does it make any sense to find free port and set system property if you're setting `org.uberfire.nio.git.daemon.enabled=false` on the lines below that? <|endcomment|> public static void setupSystemProperties() { <START> int freePort = TestUtilGit.findFreePort(); <END> System.setProperty("org.uberfire.nio.git.daemon.port", String.valueOf(freePort)); logger.info("Git port used:{}", freePort); //These are not needed for the tests System.setProperty("org.uberfire.nio.git.daemon.enabled", "false"); System.setProperty("org.uberfire.nio.git.ssh.enabled", "false"); System.setProperty("org.uberfire.sys.repo.monitor.disabled", "true"); }
<|startcomment|> "This method is not actually very useful and will likely be deprecated in the future." <|endcomment|> public void setPreferredAgencies(String s) { if (s != null && !s.equals("")) <START> preferredAgencies = Sets.newHashSet(s.split(",")); <END> }
<|startcomment|> Thanks for the PR! I just noticed these two log messages are completely redundant; can we remove one of them, or combine into a single log? <|endcomment|> synchronized void updateSubscribedTopics(final Set<String> topics, final String logPrefix) { <START> log.debug("{}found {} topics possibly matching subscription", logPrefix, topics.size()); <END> subscriptionUpdates.clear(); subscriptionUpdates.addAll(topics); log.debug("{}updating builder with {} topic(s) with possible matching regex subscription(s)", logPrefix, subscriptionUpdates.size()); setRegexMatchedTopicsToSourceNodes(); setRegexMatchedTopicToStateStore(); }
<|startcomment|> why not put this with an `&&` in the previous `if`? <|endcomment|> public void releaseCursor(Cursor cursor) { try { cursor.release(); if (cursors.remove(cursor)) { <START> if (provider.isClosed() && cursors.isEmpty()) { <END> releaseResources(); } } } catch (Exception e) { LOGGER.warn("Exception was found trying to release cursor resources. Execution will continue", e); } finally { statistics.decrementOpenCursors(); } }
<|startcomment|> Check for null missing? <|endcomment|> protected void doStop() { <START> autoEncryptionSupport.close(); <END> super.doStop(); LDAPCache.clear(); }
<|startcomment|> make the constructor package private instead of private to avoid going through a generated synthetic constructor. <|endcomment|> <START> private Now(A a) { <END> this.a = a; }
<|startcomment|> I am not sure that toPortableString() is preferred here to just toString(). IPath.toString() makes only separator '/' for all platforms and it is what we need. Docs say that if toPortableString() is used it has to be matched with fromPortableString() when converting back to Path. toPortableString() doubles all ':' after the one that belongs to the device part (for Windows). For example "c:\one\two:x" will be transformed into "c://one/two::x". If segments have no ':' symbols, then there is no difference from toString(). However if a segment has ':' symbol, fromPortableString() is necessary to restore the original path, even for Linux. <|endcomment|> private String getWorkspaceRelativePath(String sourcePath) { if (org.apache.commons.lang.StringUtils.isBlank(sourcePath) || sourcePath.contains("{")) { return sourcePath; } IPath absolutePath = new Path(sourcePath); IContainer container = ResourcesPlugin.getWorkspace().getRoot().getContainerForLocation(absolutePath); if (container != null) { <START> return container.getFullPath().toPortableString(); <END> } return null; }
<|startcomment|> style name wrong? should use the style.something()? <|endcomment|> private void buildErrataDetailPanel() { errataDetailPanel.clear(); errataDetailFormPanel = new GeneralFormPanel(); errataTitle = new Span(); errataTitle.setStyleName(style.errataTitleLabel()); FlowPanel errataTitlePanel = new FlowPanel(); errataTitlePanel.setStyleName(style.errataTitlePanel()); errataTitlePanel.add(errataTitle); errataDetailPanel.add(errataTitlePanel); <START> errataDetailPanel.setStyleName("testtest"); //$NON-NLS-1$ <END> errataDetailPanel.add(errataDetailFormPanel); }
<|startcomment|> This subList should not be mutable to the caller. <|endcomment|> public List<String> getMoreStable(String branch) { int i = order.indexOf(fullName(branch)); if (0 <= i) { <START> return order.subList(i + 1, order.size()); <END> } else { return Collections.emptyList(); } }
<|startcomment|> why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table. <|endcomment|> public void notifyListeners(int eventType, Event event) { if <START> (this.dropdownTableViewer != <END> null && !this.dropdownTable.isDisposed()) this.dropdownTable.notifyListeners(eventType, event); }
<|startcomment|> Can't we move check to `BaseTestHiveImpersonation` and extend from some common Hive test class? <|endcomment|> public static void setup() throws Exception { <START> assumeTrue("Skipping tests since Hive supports only JDK 8.", HiveTestUtilities.supportedJavaVersion()); <END> startMiniDfsCluster(TestSqlStdBasedAuthorization.class.getSimpleName()); prepHiveConfAndData(); setSqlStdBasedAuthorizationInHiveConf(); startHiveMetaStore(); startDrillCluster(true); addHiveStoragePlugin(getHivePluginConfig()); addMiniDfsBasedStorage(new HashMap<>()); generateTestData(); }
<|startcomment|> these fields are already set by AOP in RetireSaveHandler and this needs to delegate to saveOrderType instead of calling the DAO just in case there is extra logic in the save method we don't want to by pass <|endcomment|> public OrderType retireOrderType(OrderType orderType, String reason) { orderType.setRetired(true); <START> orderType.setRetireReason(reason); <END> return dao.saveOrderType(orderType); }
<|startcomment|> rename 'child'? <|endcomment|> private void updateFiltersCheckState() { Object[] children = filterContentProvider .getElements(getContentService()); ICommonFilterDescriptor filterDescriptor; INavigatorFilterService filterService = getContentService() .getFilterService(); for (Object <START> element : <END> children) { filterDescriptor = (ICommonFilterDescriptor) element; if(filterService.isActive(filterDescriptor.getId())) { getTableViewer().setChecked(element, true); getCheckedItems().add(element); } else { getTableViewer().setChecked(element, false); } } }
<|startcomment|> This may return null if layer visibility = false <|endcomment|> public FeatureTypeStyle transform(MBStyle styleContext, Double minScaleDenominator, Double maxScaleDenominator) { // Would prefer to accept zoom levels here (less concepts in our API) // If we accept zoom levels we may be able to reduce, and return a list of FeatureTypeStyles // (with the understanding that the list may be empty if the MBLayer does not contribute any content // at a specific zoom level range) <START> FeatureTypeStyle style = transform(styleContext); <END> for (Rule rule : style.rules()) { if (minScaleDenominator != null) { rule.setMinScaleDenominator(minScaleDenominator); } if (maxScaleDenominator != null) { rule.setMaxScaleDenominator(maxScaleDenominator); } } return style; }
<|startcomment|> The reason why ReachabilityChecker supports reusing an existing RevWalk (instead of maintaining our own), presumably, is so that we can save on object parsing. So I think it's less flexible if we set this here - the caller should be setting it if they know that they want it. <|endcomment|> public Optional<RevCommit> areAllReachable(Collection<RevCommit> targets, Collection<RevCommit> starters) throws MissingObjectException, IncorrectObjectTypeException, IOException { walk.reset(); <START> walk.setRetainBody(false); <END> if (topoSort) { walk.sort(RevSort.TOPO); } for (RevCommit target: targets) { walk.markStart(target); } for (RevCommit starter : starters) { walk.markUninteresting(starter); } return Optional.ofNullable(walk.next()); }
<|startcomment|> shouldn't trackableSession be an Optional? Either they are both or none are for me… actually, I don't think we really need to introduce Optional here, it is the caller that should be careful of not calling this with a null value! <|endcomment|> <START> public Optional<SessionStore<J2EContext>> buildFromTrackableSession(final J2EContext context, final Object trackableSession) { <END> return trackableSession == null ? Optional.empty() : Optional.of(new J2EProvidedSessionStore((HttpSession) trackableSession)); }
<|startcomment|> I don't see any advantage of using `requireNonNull()` <|endcomment|> public Response awaitResponse() throws Exception { <START> return Objects.requireNonNull(remoteFuture).get(); <END> }
<|startcomment|> "<init>".equals() is null safe and consistent to the last check in this method. <|endcomment|> static boolean isDefaultArgumentsConstructor(final MethodNode methodNode) { <START> if (!methodNode.name.equals("<init>")) { <END> return false; } final Type[] argumentTypes = Type.getMethodType(methodNode.desc) .getArgumentTypes(); if (argumentTypes.length < 2) { return false; } return "kotlin.jvm.internal.DefaultConstructorMarker" .equals(argumentTypes[argumentTypes.length - 1].getClassName()); }
<|startcomment|> Where is currentSecond being updated? <|endcomment|> public void increment(long amount) { long now = clock.now() / 1000L; <START> if (now != currentSecond.get()) { <END> currentCount.set(0); } long count = currentCount.addAndGet(amount); updatePeak(count); }
<|startcomment|> Ack <|endcomment|> public static void assertValidSubmodulePath(String path) throws SubmoduleValidationException { if (path.startsWith("-")) { //$NON-NLS-1$ throw new SubmoduleValidationException( MessageFormat.format( JGitText.get().submodulePathInvalid, path), <START> ObjectChecker.ErrorType.GITMODULES_PATH); <END> } }
<|startcomment|> `ret` -> `message` <|endcomment|> public String getMessage() { <START> String ret = super.getMessage(); <END> if (pql.isPresent()) { ret += " with pql \"" + pql.get() + "\""; } return ret; }
<|startcomment|> Minor suggestion to change this exception to: ``` throw new IllegalArgumentException("g may not be null."); ``` <|endcomment|> protected AbstractGraphDecorator(Graph g) { if (g == null) { <START> throw new NullPointerException("g may not be null."); <END> } this.inner = g; }
<|startcomment|> `return getCodecA() != null && ("dts".contains(getCodecA()) || "dca".contains(getCodecA()));` <|endcomment|> public boolean isDTS() { <START> return getCodecA() != null && (getCodecA().startsWith("dts") || "dca".equals(getCodecA()) || "dca (dts)".equals(getCodecA())); <END> }
<|startcomment|> This one shouldn't be public. <|endcomment|> <START> public CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) { <END> return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader)); }
<|startcomment|> Please, change as discussed. <|endcomment|> public synchronized void setBrightnessInUserInterfaceDimensionUnit(float percent) { if (percent < 0f) { percent = 0f; } else if (percent > 200f) { percent = 200f; } brightness = percent / 100f; <START> changeShader = true; <END> refreshTextures(); }
<|startcomment|> This is a backwards incompatible change and cannot be merged. <|endcomment|> <START> public Handles setForceEndTransactions(boolean forceEndTransactions) { <END> this.forceEndTransactions = forceEndTransactions; return this; }
<|startcomment|> You should remove obsolete class casts <|endcomment|> protected Cause createUpstreamCause(Run<?, ?> build) { if(Jenkins.getInstance().getPlugin("promoted-builds") != null) { // Test only when promoted-builds is installed. if(build instanceof Promotion) { Promotion promotion = (Promotion)build; // This cannot be done for PromotionCause#PromotionCause is in a package scope. // return new PromotionCause(build, promotion.getTarget()); return new UpstreamCause((Run<?,?>)promotion.getTarget()); } } <START> return new UpstreamCause((Run) build); <END> }
<|startcomment|> Wouldn't it actually be better to check if instance of Date and then delegate to compare(Date, Date)? <|endcomment|> public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) { if (d1 == null) { return d2 == null; } else if (d2 == null) { return false; } <START> return (d1 instanceof Timestamp || d2 instanceof Timestamp) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2); <END> }
<|startcomment|> You don't need the `else` clause because the `if` clause does a `return`. <|endcomment|> public boolean equals( Object obj ) { if ( this == obj ) { return true; } if ( obj == null ) { return false; } if ( getClass() != obj.getClass() ) { return false; } final HeapObject other = (HeapObject) obj; if ( node == null ) { return other.node == null; } <START> else return node.equals(other.node); <END> }
<|startcomment|> I think in this class it is possible. <|endcomment|> public void testSignalIntermediateThrow() throws Exception { KieBase kbase = createKnowledgeBase("BPMN2-IntermediateThrowEventSignal.bpmn2"); ksession = createKnowledgeSession(kbase); Map<String, Object> params = new HashMap<String, Object>(); params.put("x", "MyValue"); ProcessInstance processInstance = ksession.startProcess( "SignalIntermediateEvent", params); <START> Assertions.assertThat(processInstance.getState()).isEqualTo(ProcessInstance.STATE_COMPLETED); <END> }
<|startcomment|> nit: how about `minhash.values().stream().forEach(this:: increaseTotalHllSize)`? <|endcomment|> public KHyperLogLog(int maxSize, int hllBuckets, Long2ObjectSortedMap<HyperLogLog> minhash) { this.maxSize = maxSize; this.hllBuckets = hllBuckets; this.minhash = requireNonNull(minhash, "minhash is null"); hllsTotalEstimatedInMemorySize = 0; hllsTotalEstimatedSerializedSize = 0; <START> for (HyperLogLog hll : minhash.values()) { <END> increaseTotalHllSize(hll); } }
<|startcomment|> This is dumb. Add a Project.Id form to ProjectControl.GenericFactory and ProjectControl.Factory. That way we only have to perform 1 cache lookup, not 2. <|endcomment|> public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException { <START> final Project.NameKey projectKey = projectCache.get(change.getProject()).getProject().getNameKey(); <END> try { return projectControl.controlFor(projectKey, user).controlFor(change); } catch (NoSuchProjectException e) { throw new NoSuchChangeException(change.getId(), e); } }
<|startcomment|> Should throw ```IllegalStateException``` , or similar. <|endcomment|> public void onAttach(Activity activity) { super.onAttach(activity); try { mListener = (ShareFragmentListener) activity; } catch (ClassCastException e) { <START> throw new ClassCastException(activity.toString() <END> + " must implement OnShareFragmentInteractionListener"); } }
<|startcomment|> I wonder why we don't emit an event in this case. Another thing is that I think in this case (using JMS) we will update autitTaskImpl in the database, but we currently don't update it in case we use normal JPA LifeCycleListener for tasks. Isn't this a little bit inconsistent? https://github.com/kiegroup/jbpm/blob/25fabbca948df52f69475ca54a8cf85fe09e4074/jbpm-human-task/jbpm-human-task-audit/src/main/java/org/jbpm/services/task/audit/JPATaskLifeCycleEventListener.java#L743-L753 Here we just index and persist variables. <|endcomment|> <START> public void afterTaskInputVariableChangedEvent(TaskEvent event, Map<String, Object> variables) { <END> if (variables == null || variables.isEmpty()) { return; } Task task = event.getTask(); List<TaskVariableImpl> taskVariables = indexVariables(task, variables, VariableType.INPUT); AuditTaskImpl auditTaskImpl = createAuditTask(task, event.getEventDate()); sendMessage(new AuditTaskData(auditTaskImpl, null, taskVariables, null), 2); }
<|startcomment|> Remember to put {} around if/else/while/for etc. <|endcomment|> public RubyGemParser(IFile file) throws IOException, CoreException { mSetupDefinitions = new HashMap<String, ArrayList<Object>>(); mSetupDependencies = new HashMap<String, ArrayList<Object>>(); <START> if (file.getContents().available() <= 0) <END> return; this.file = file; gemVariable = ""; parse(); }
<|startcomment|> I would turn this `&&` around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification. <|endcomment|> public boolean canHandle(Message<?> message) { <START> return super.canHandle(message) && deadlineNameMatch((DeadlineMessage) message); <END> }
<|startcomment|> This approach won't work if all the classes of a project are in a single root package: ``` package org; import org.B; class A { org.B b; // should be noncompliant } ``` ``` package org; class B { ... } ``` You probably should rather rely on the type of the symbol associated to the identifier of the parent member select, if the parent is a member select. ``` if (parent.is(Kind.MEMBER_SELECT)) { ExpressionTree expression = ((MemberSelectExpressionTree) parent).expression(); if (expression.is(Kind.MEMBER_SELECT) && !((MemberSelectExpressionTree) expression).identifier().symbol().isTypeSymbol()) { return; } reportIssue(parent, String.format(MESSAGE, symbol.name())); hasIssue.add(parent); } ``` <|endcomment|> private void checkImportedSymbol(Symbol symbol) { for (IdentifierTree usageIdentifier : symbol.usages()) { Tree parent = usageIdentifier.parent(); <START> if (parent.is(Kind.MEMBER_SELECT) && ((MemberSelectExpressionTree) parent).expression().is(Kind.MEMBER_SELECT)) { <END> reportIssue(parent, String.format(MESSAGE, symbol.name())); hasIssue.add(parent); } } }
<|startcomment|> maybe, if @ Before doesn't work, create a method setUp for this? since the same code lines are in the beginning of each test of this class <|endcomment|> public void jmsPort_shouldBeExportedWithCorrectId() throws Exception { <START> if (!featuresService.isInstalled(featuresService.getFeature("openengsb-ports-ws"))) { <END> featuresService.installFeature("openengsb-ports-jms"); } OutgoingPort serviceWithId = OpenEngSBCoreServices.getServiceUtilsService().getServiceWithId(OutgoingPort.class, "jms-json", 60000); assertNotNull(serviceWithId); }
<|startcomment|> we have lambdas for this now. <|endcomment|> private EventHandler createContextEventHandler() { if (contextEventHandler == null) { contextEventHandler = <START> new EventHandler() { <END> @Override public void handleEvent(Event event) { handleContextSet(event); } }; } return contextEventHandler; }
<|startcomment|> Make the "super" dex field protected and remove this one? Or a protected getDexBuffer() method? <|endcomment|> public AnnotationValueReader(@Nonnull DexBuffer dex, @Nonnull ByteInput in) { <START> super(dex, in); this.dex = dex; <END> }
<|startcomment|> You can pass `null` instead of `new HashMap<String, Serializable>()`. <|endcomment|> protected Blob convertBlobToMimeType(Blob blob, String destinationMimeType) { BlobHolder bh = new SimpleBlobHolder(blob); <START> bh = convertToMimeType(destinationMimeType, bh, new HashMap<String, Serializable>()); <END> if (bh == null) { return null; } Blob result = bh.getBlob(); return result; }
<|startcomment|> i don't think redeclaring the type on the right side is needed. <|endcomment|> private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() { // Lets not modify the existing collection. Hence creating a new hashset. Set<SupportedAdditionalClusterFeature> featuresSupported = <START> new HashSet<SupportedAdditionalClusterFeature>(getVdsGroup().getAddtionalFeaturesSupported()); <END> featuresSupported.removeAll(clusterFeatureDao.getSupportedFeaturesByClusterId(getVdsGroup().getId())); return featuresSupported; }
<|startcomment|> Eeek, eatin away exceptions? <|endcomment|> static void runScript(String filename, Connection cx) throws SQLException { try { SqlUtil.runScript(new GeoPackage().getClass().getResourceAsStream(filename), cx); } catch (IOException e) { <START> <END> } }
<|startcomment|> why stream? entrySet is iterable. <|endcomment|> public void recycleAttributes(long ts) { <START> fPoolAttributes.entrySet().stream().forEach(e <END> -> { NonNullUtils.checkNotNull(e.getKey()).recycle(e.getValue(), ts); }); }
<|startcomment|> please invert `if` condition <|endcomment|> public boolean hasNext() { // If we do not have the next element pipelined, go ahead and fetch it. <START> if (next == null) { <END> // If the iterator is valid, this means that the next entry exists. checkInvariants(); if (iterator.isValid()) { // Go ahead and cache that entry. next = new AbstractMap.SimpleEntry( serializer.deserialize(Unpooled.wrappedBuffer(iterator.key()), corfuRuntime), serializer.deserialize(Unpooled.wrappedBuffer(iterator.value()), corfuRuntime)); // Advance the underlying iterator. iterator.next(); } else { // If there is no more elements to consume, we should release the resources. iterator.close(); } } return next != null; }
<|startcomment|> Missing braces <|endcomment|> public int run() throws IOException { int b; if (in != null) { <START> while ((b = in.read()) != -1) out.write(b); <END> in.close(); } out.close(); return -1; }
<|startcomment|> Do you have a voided field in this cohort_member table? In theory members don't get removed from the set. You might need to update Cohort.removeMember() to set stop date instead of removing. Which means that getCohortsContainingPatientId() should return cohorts that contain the patient as of the current date i.e members that have no stop date or those where the startDate is before current date and end date is after current date <|endcomment|> public List<Cohort> getCohortsContainingPatientId(Integer patientId) throws DAOException { return (List<Cohort>) sessionFactory.getCurrentSession().createCriteria(Cohort.class) <START> .add(Restrictions.eq("voided", false)) <END> .createAlias("members", "m") .createAlias("m.patientId", "p") .add(Restrictions.eq("p.patientId", patientId)) .list(); }
<|startcomment|> How can this succeed if `tupleWriter.open()` isn't called (when `dataSink` is `null`)? <|endcomment|> protected void init(final ImmutableMap<String, Object> execEnvVars) throws DbException { try { if (dataSink != null) { tupleWriter.open(dataSink.getOutputStream()); } <START> tupleWriter.writeColumnHeaders(getChild().getSchema().getColumnNames()); <END> } catch (IOException e) { throw new DbException(e); } }
<|startcomment|> use partitionData.length for consistency with getRetainedSizeInBytes ``` public long getSizeInBytes() { long sizeInBytes = 0; for (int i = 0; i < partitionData.length; i++) { sizeInBytes += partitionData[i].getSizeInBytes(); } return sizeInBytes; } ``` <|endcomment|> public long getSizeInBytes() { long sizeInBytes = 0; <START> int partitionCount = partitionFunction.getPartitionCount(); <END> for (int i = 0; i < partitionCount; i++) { sizeInBytes += partitionData[i].getSizeInBytes(); } return sizeInBytes; }
<|startcomment|> Replace by `this(name, value, value, model);` <|endcomment|> public FixedRealVarImpl(String name, double value, Model model) { <START> super(name, model); this.lb = value; this.ub = value; <END> }
<|startcomment|> I'd expect this to be the other way around, when version is a WAN version. I'm thinking about subclassing `Version`. That way we can create `ClusterVersion` and `WanVersion` that can - compare/sort the versions properly, - validate that once we set a cluster version, it can't be replaced by a WAN version (checking the sign bit) and vice-versa. WDYT? <|endcomment|> public void isGreaterThan() { assertTrue(V3_0.isGreaterThan(of(2, 0))); assertFalse(V3_0.isGreaterThan(of(3, 0))); assertFalse(V3_0.isGreaterThan(of(4, 0))); assertTrue(V3_0.isGreaterThan(NEGATIVE_VERSION_1)); <START> assertTrue(NEGATIVE_VERSION_1.isGreaterThan(NEGATIVE_VERSION_2)); <END> }
<|startcomment|> I think that it is ok, although I am not sure how I feel about including the "\n". <|endcomment|> private String extractDefinitionLine(String typeDeclaration) { String typeLine = ""; String[] lines = typeDeclaration.split("\n"); for (String line : lines) { typeLine = typeLine + "\n" + line; if (line.contains("{")) { break; } } return typeLine; <START> } <END>
<|startcomment|> stackable armo(u)r? <|endcomment|> public ItemAshenMask(ArmorMaterial material, int renderIndex, EntityEquipmentSlot slot, AshenMasks maskType) { super(material, renderIndex, slot); setHasSubtypes(true); <START> this.maxStackSize = 64; <END> this.maskType = maskType; ItemRegistry.maskMap.put(maskType, this); }
<|startcomment|> I don't understand the `if` here. If the errorCount() was higher or equal to `config.storeIOErrorCountToTriggerShutdown`, won't the store be shutting/shut down? <|endcomment|> private void onSuccess() { <START> if (errorCount.getAndSet(0) >= config.storeIOErrorCountToTriggerShutdown) { <END> logger.info("Resetting the error count of BlobStore {} because restart or one operation succeeded", storeId); } }
<|startcomment|> Perhaps the '104' could be a constant? <|endcomment|> private ApplicationReportModel createAppDependencyGraphReport(GraphContext context) { <START> ApplicationReportService applicationReportService = new ApplicationReportService(context); <END> ApplicationReportModel report = applicationReportService.create(); report.setReportPriority(104); report.setReportIconClass("glyphicon glyphicon-tree-deciduous"); report.setTemplatePath(TEMPLATE); report.setTemplateType(TemplateType.FREEMARKER); report.setDisplayInApplicationReportIndex(Boolean.TRUE); report.setDescription(REPORT_DESCRIPTION); return report; }
<|startcomment|> Should this not be WARN or some exception thrown? Instead of logging that the ip is incorrect. And maybe this validation should be done in the doStart method so its validated earlier <|endcomment|> private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException { if (client == null) { LOG.info("Connecting to the ElasticSearch cluster: " + configuration.getClusterName()); if (configuration.getHostAddressesList() != null && !configuration.getHostAddressesList().isEmpty()) { client = createClient(); } else { <START> LOG.info("Incorrect ip address and port parameters settings for ElasticSearch cluster"); <END> } } }
<|startcomment|> shouldn't the message get the 'size'? <|endcomment|> protected String getRemoveQosMessage(int size) { <START> return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage(); <END> }
<|startcomment|> Just use images.forEach <|endcomment|> public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) { Map<Guid, List<DiskImage>> retVal = new HashMap<>(); <START> images.stream().forEach(image <END> -> MultiValueMapUtils.addToMap(image.getId(), image, retVal)); retVal.values().forEach(ImagesHandler::sortImageList); return retVal; }
<|startcomment|> What is the contract for the return of this method? If we are already at the state that we are trying to move to, it could be said that the moveToState is successful (i.e. true). <|endcomment|> protected boolean moveToState(STATE to) { if (state.get() == to) { <START> return false; <END> } return moveToState(state.get(), to); }
<|startcomment|> @NielsCharlier try-with-resources? <|endcomment|> public void writeTo(Resource file) throws JDOMException, IOException { OutputStream out = path.out(); try { IOUtils.write(body, out); } finally { out.close(); <START> } <END> }
<|startcomment|> The class is abstract. Constructor should be `protected` <|endcomment|> <START> public ApplicationFetchException(String apiKey, ErrorCode errorCode) { <END> super(); this.apiKey = apiKey; this.errorCode = errorCode; }
<|startcomment|> using this approach only root collections will have validatorLocator, all sub-collections/resources will get NPE, when you'll try to use it, you need to inject it in runtime to every resource. <|endcomment|> private void addResource(final BackendResource resource) { resource.setMessageBundle(messageBundle); resource.setBackend(backend); resource.setSessionHelper(sessionHelper); if (resource instanceof AbstractBackendResource) { ((AbstractBackendResource) resource).setMappingLocator(mappingLocator); } else if (resource instanceof CapabilitiesResource) { ((BackendCapabilitiesResource) resource).setMappingLocator(mappingLocator); } <START> resource.setValidatorLocator(validatorLocator); <END> singletons.add(resource); }
<|startcomment|> listeners is atomic <|endcomment|> public boolean isEmpty() { <START> synchronized (listeners) <END> { return listeners.size() == 0; } }
<|startcomment|> Here we need to take sequence number wrap around into account. Alternatively, what we could do is unconditionally set the `maxSeen`, and prevent the `maxSeen` from being set if the `end` has been set. However, I don't like adding this kind of logic in the setters. Maybe it'd be better to have a getMaxOrEnd() method. <|endcomment|> void setEnd(int end) { this.end = end; <START> if (this.end > this.maxSeen) <END> { this.maxSeen = this.end; } }
<|startcomment|> > Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2 <|endcomment|> public void dispose() { //Remove all messages from the queue <START> this.mHandler.removeCallbacksAndMessages(null); <END> this.mHandler = null; this.mPhone = null; }
<|startcomment|> a couple of questions: - can't you return true here? - is it possible to configure multiple directory providers? <|endcomment|> public boolean indexShareable() { TypedProperties properties = properties(); boolean hasRamDirectoryProvider = false; boolean hasOtherDirectoryProvider = false; for (Object objKey : properties.keySet()) { String key = (String) objKey; if (key.endsWith(DIRECTORY_PROVIDER_KEY)) { if (properties.get(key).equals(RAM_DIRECTORY_PROVIDER)) { hasRamDirectoryProvider = true; } else { <START> hasOtherDirectoryProvider = true; <END> } } } boolean ramOnly = hasRamDirectoryProvider && !hasOtherDirectoryProvider; return !ramOnly; }
<|startcomment|> move this to the first line of this method for optimization. <|endcomment|> public boolean delete( final ConcreteResource resource, final EventMetadata eventMetadata ) throws TransferException { final Transfer item = getCacheReference( resource ); if ( !resource.allowsDeletion() ) { throw new TransferException( "Deletion not allowed for: {}", resource ); <START> } <END> return doDelete( item, eventMetadata ); }
<|startcomment|> when will it be < 0? isnt it better to use Integer that can be null? (like other fields in vm dynamic) <|endcomment|> public String getActualCpuTopology() { <START> if (actualCpuTopology < 0) { <END> return ConstantsManager.getInstance().getConstants().notAvailableLabel(); } else { return String.valueOf(actualCpuTopology); } }
<|startcomment|> Oh I see now it does get slightly darker when you manually page. It was so subtle I didn't see it at first. <|endcomment|> public void onPageScrolled(int i, float v, int i2) { if (pager.getCurrentItem() != 0) { speakerbox.stop(); } if (pager.getCurrentItem() == pagerPositionWhenPaused) { resume.setVisibility(View.GONE); <START> getView().findViewById(R.id.routes).setBackgroundColor(act.getBaseContext() <END> .getResources().getColor(R.color.transparent_white)); } }
<|startcomment|> If an exception can be thrown, then wrap wavTrack.close() in a try-finally block, to guarantee resources are properly closed. <|endcomment|> public void benchWavTrack() throws Exception { WavTrack wavTrack = new WavTrack(url); boolean isEOMReached = false; while (!isEOMReached) { Frame process = wavTrack.process(0); isEOMReached = process.isEOM(); } <START> wavTrack.close(); <END> }
<|startcomment|> aren't these already set by logging.properties? <|endcomment|> private static void setupLogger(Map<String, Object> args) throws IOException{ String logfile = (String)args.get("log-file"); Logger logger = Logger.getLogger(""); logger.setLevel((Level)args.get("log-level")); logger.addHandler(new ConsoleHandler()); if(logfile != null) { FileHandler fh = new FileHandler(logfile); fh.setFormatter(new SimpleFormatter()); logger.addHandler(fh); <START> } <END> }
<|startcomment|> I would use == instead of equals. XWikiAttachment don't implement equals and even if they were is might be super slow (they would have to compare sometime big files contents). Then no need for `put == null` anymore since the input cannot be null. <|endcomment|> public XWikiAttachment set(XWikiAttachment attachment) { XWikiAttachment put = map.put(attachment.getFilename(), attachment); <START> if (put == null || !put.equals(attachment)) { <END> added(attachment); updatedMap(); } return put; }
<|startcomment|> final, here and elsewhere <|endcomment|> <START> public boolean equals(Object obj) { <END> if (obj instanceof MethodKey) { MethodKey toCompare = (MethodKey) obj; return toCompare.name.equals(name) && toCompare.parameterTypes.equals(parameterTypes); } return false; }
<|startcomment|> Copy into a new set too, the user will still be able to modify the set through the builder. <|endcomment|> MongoDBTracing(Builder builder) { tracing = builder.tracing; maxAbbreviatedCommandLength = builder.maxAbbreviatedCommandLength; <START> commandsWithCollectionName = Collections.unmodifiableSet(builder.commandsWithCollectionName); <END> }
<|startcomment|> this makes no sense. synchronizing on a new object is meaningless. I do not know why partitions must be null, if we want synchronize on this object, we should make it final and never null, instead simply clear() them on dispose <|endcomment|> public void disconnect() { <START> Object lock = partitions != null ? partitions : new Object(); <END> synchronized (lock) { document = null; partitions = null; try { inputStream.close(); } catch (IOException e) { } } }
<|startcomment|> can use `inMemMessage.isEmpty()` <|endcomment|> private void printInfo(String sizeMessage, String inAlluxioMessage, String inMemMessage, String path) { <START> System.out.println(inMemMessage.equals("") <END> ? String.format(SHORT_INFO_FORMAT, sizeMessage, inAlluxioMessage, path) : String.format(LONG_INFO_FORMAT, sizeMessage, inAlluxioMessage, inMemMessage, path)); }
<|startcomment|> I think alternatively we can move out the construction of the service from the test cases into a factory method that sets a shutdown function object field that we can call in the tearDown. This may prevent some other unwanted potential side-effects. With this approach we construct two services, but shutdown only one. For example, the service submits a scheduled task. I think it is fine for now, but it would be safer with the function proposed. <|endcomment|> public void tearDown() { // Destroy JMX beans created during testing. <START> MetricsService metricsService = new MetricsService(nodeEngineMock, () -> metricsRegistry); <END> metricsService.init(nodeEngineMock, new Properties()); metricsService.shutdown(true); JmxLeakHelper.checkJmxBeans(); // Stop executor service. if (executionService != null) { executionService.shutdown(); } }
<|startcomment|> swap the left and right for the equals to avoid NullPointerException also, use equalsIgnoreCase instead ``` "MOBILE".equalsIgnoreCase(src); ``` <|endcomment|> public AdsBaseObject verifyAdImage(String slotName, String src, String imageUrl) { WebElement element = getWebElement(slotName); <START> boolean isMobile = src.toUpperCase().equals("MOBILE"); <END> Assertion.assertTrue(new AdsComparison().compareImageWithScreenshot(imageUrl, element, driver, isMobile)); PageObjectLogging.log("verifyAdImage", "Ad looks good", true, driver); return this; }
<|startcomment|> Missing synchronization? <|endcomment|> <START> public Set<String> getUnmatchedLabels() { <END> return Collections.unmodifiableSet(unmatchedLabels); }
<|startcomment|> This shouldn't be necessary anymore. RefDirectory.refresh() should trigger an event listener if one or more refs was detected to be modified, which means we can drop the getAllRefs() call here. <|endcomment|> public void scanForRepoChanges() throws IOException { refs.refresh(); <START> getAllRefs(); // This will look for changes to refs <END> if (!isBare()) getIndex(); // This will detect changes in the index }
<|startcomment|> In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean. <|endcomment|> public List<Server> getReachableServers() { <START> return getServerList(true); <END> }
<|startcomment|> Might throw an IndexOutOfBound if no the storage domain is not attached to any storage pool <|endcomment|> protected Guid getStoragePoolId() { <START> return getDbFacade().getStoragePoolDao().getAllForStorageDomain(getStorageDomainId()).get(0).getId(); <END> }
<|startcomment|> Why returning Integer instead of plain int? <|endcomment|> <START> private Integer prerequirementImgResource(String group) { <END> if (group.equalsIgnoreCase(AssignmentPrerequirement.RANK.toString())) { return R.drawable.rank_prerequirement; } else if (group.equalsIgnoreCase(AssignmentPrerequirement.MISSION.toString())) { return R.drawable.group_prerequirement; } else { return R.drawable.empty; } }
<|startcomment|> The TODO above the changed line indicates the reason for using a multi value list here... But of course, we could change this until we actually return multiple values. <|endcomment|> public Iterator<ImageTypeSpecifier> getImageTypes(int pImageIndex) throws IOException { checkBounds(pImageIndex); // TODO: Better implementation, include INT_RGB types for 3BYTE_BGR and 4BYTE_ABGR for INT_ARGB <START> return Collections.singletonList(getRawImageType(pImageIndex)).iterator(); <END> }
<|startcomment|> For better readability i would sort the methods in the way they are used `resetPositions` -> `addPosition` -> `appendData` -> `flush`. Please also order the private methods accordingly: Method that uses a private method - > private method <|endcomment|> <START> public void resetPositions(int positionCount) <END> { positions = ensureCapacity(positions, positionCount); this.positionCount = 0; }
<|startcomment|> Why `selectorStr.substring(0, 1)` <|endcomment|> public static SelectorHandler getHandler(final String selectorStr) { if (!selectorStr.isEmpty()) <START> for (final Entry<String, SelectorHandler> handler : selectorHandlers.subMap(selectorStr, true, selectorStr.substring(0, 1), true).entrySet()) <END> if (selectorStr.startsWith(handler.getKey())) return handler.getValue(); return vanillaHandler; }
<|startcomment|> This `if` is redundant. Question for you, @nezihyigitbasi: Do you see IntelliJ "warning"s for this? If not, you should turn those on. <|endcomment|> public synchronized void close() { if (closed) { return; } closed = true; <START> if (parentMemoryContext != null) { <END> parentMemoryContext.updateBytes(-usedBytes); } usedBytes = 0; }
<|startcomment|> Change seems unneeded. And actually the unchecked can be removed as well. <|endcomment|> <START> public Map<K, V> getEntries() { <END> return (Map<K, V>) entries; }
<|startcomment|> Why are you changing expectation, when no related production code changed? There should be really two events (`modification` and `modification 2`) Please note that this test is platform dependent. We are targetting to Linux and CI reports no issues or flakes with this test. Which OS are you running tests? Last CI build is here: https://builds.apache.org/view/C/view/Apache%20Camel/job/Camel/job/master/1533/consoleFull <|endcomment|> public void testDefaultConfig() throws Exception { Files.write(springTestFile.toPath(), "modification".getBytes(), StandardOpenOption.SYNC); // Adding few millis to avoid fleaky tests // The file hasher could sometimes evaluate these two changes as duplicate, as the second modification of file could be done before hashing is done Thread.sleep(50); Files.write(springTestFile.toPath(), "modification 2".getBytes(), StandardOpenOption.SYNC); MockEndpoint mock = getMockEndpoint("mock:springTest"); <START> mock.setExpectedCount(1); // The same with testCustomHasher, that second MODIFY event is discarded <END> mock.setResultWaitTime(1000); mock.assertIsSatisfied(); }
<|startcomment|> Isn't isNotBlank already checking for null? <|endcomment|> private boolean startsOrEndsWithWhitespace(String value) { boolean startsOrEndsWithWhitespace = false; <START> if (value != null && StringUtils.isNotBlank(value)) { <END> int lastIndex = value.length() - 1; if (Character.isSpaceChar(value.charAt(0))) { startsOrEndsWithWhitespace = true; } else if (Character.isSpaceChar(value.charAt(lastIndex))) { startsOrEndsWithWhitespace = true; } } else { startsOrEndsWithWhitespace = false; } return startsOrEndsWithWhitespace; }
<|startcomment|> This Block can be shortened to `share.setIsFolder(mPath.endsWith(FileUtils.PATH_SEPARATOR))` <|endcomment|> private void updateData(OCShare share) { // Update DB with the response share.setPath(mPath); <START> if (mPath.endsWith(FileUtils.PATH_SEPARATOR)) { <END> share.setIsFolder(true); } else { share.setIsFolder(false); } share.setPermissions(READ_ONLY); getStorageManager().saveShare(share); // Update OCFile with data from share: ShareByLink and publicLink OCFile file = getStorageManager().getFileByPath(mPath); if (file!=null) { file.setShareWithSharee(true); // TODO - this should be done by the FileContentProvider, as part of getStorageManager().saveShare(share) getStorageManager().saveFile(file); } }
<|startcomment|> does the propagated exception not get logged? This looks like it would result in logging the same thing twice <|endcomment|> protected void startMasters(boolean isLeader) { try { connectToUFS(); mRegistry.start(isLeader); } catch (IOException e) { <START> LOG.error("Failed to start master.", e); <END> throw Throwables.propagate(e); } }
<|startcomment|> The default constructor should assign "null" to connector. <|endcomment|> <START> public BugzillaRestRepositoryConnectorUi() { <END> connector = BugzillaRestConnector.getDefault() == null ? new BugzillaRestConnector() : BugzillaRestConnector.getDefault(); }
<|startcomment|> helper for setting common options? <|endcomment|> public static ListStatusPOptions getListStatusOptions() { <START> FileSystemMasterCommonPOptions commonOptions = <END> getCommonOptions().toBuilder().setTtl(Configuration.getMs(PropertyKey.USER_FILE_LOAD_TTL)) .setTtlAction(GrpcUtils.toProto( Configuration.getEnum(PropertyKey.USER_FILE_LOAD_TTL_ACTION, TtlAction.class))) .build(); return ListStatusPOptions.newBuilder().setCommonOptions(commonOptions) .setLoadMetadataType(GrpcUtils.toProto(Configuration .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class))) .build(); }
<|startcomment|> small typo - I think `name` is supposed to be `dag`, right? <|endcomment|> Node(final String name, final NodeProcessor nodeProcessor, final Dag dag) { requireNonNull(nodeProcessor, "The nodeProcessor parameter can't be null."); this.nodeProcessor = nodeProcessor; requireNonNull(name, "The name of the node can't be null"); this.name = name; <START> requireNonNull(name, "The dag of the node can't be null"); <END> this.dag = dag; }
<|startcomment|> Here it's not the state of this class that's invalid, it's the given parameter. The relevant exception in such a case is IllegalArgumentException <|endcomment|> public String getTooltip(MergeMode mode) { String tooltip; switch (mode) { case LEFT_TO_RIGHT: tooltip = EMFCompareDiagramEditMessages.getString("merged.to.right.tooltip"); //$NON-NLS-1$ break; case RIGHT_TO_LEFT: tooltip = EMFCompareDiagramEditMessages.getString("merged.to.left.tooltip"); //$NON-NLS-1$ break; case ACCEPT: tooltip = EMFCompareDiagramEditMessages.getString("accept.change.tooltip"); //$NON-NLS-1$ break; case REJECT: tooltip = EMFCompareDiagramEditMessages.getString("reject.change.tooltip"); //$NON-NLS-1$ break; default: <START> throw new IllegalStateException(); <END> } return tooltip; }
<|startcomment|> Please add an overloaded constructor to keep comparibility (like `TriggerredBuildSelector(boolean)`). <|endcomment|> <START> public TriggeredBuildSelector(boolean fallbackToLastSuccessful, UpstreamFilterStrategy upstreamFilterStrategy, boolean allowUpstreamDependencies) { <END> this.fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean.TRUE : null; this.upstreamFilterStrategy = upstreamFilterStrategy; this.allowUpstreamDependencies = allowUpstreamDependencies ? Boolean.TRUE : null; }
<|startcomment|> 사소한 거긴 하지만 if (not a) { ... } not not a { ... } 가 되지 않도록 if 순서를 변경해 주세요. <|endcomment|> public static Result deleteUser(Long userId) { if (User.findByLoginId(session().get("loginId")).isSiteManager()){ <START> if (!Project.isOnlyManager(userId)) { <END> User.find.byId(userId).delete(); } else { flash(Constants.WARNING, "site.userList.deleteAlert"); } } else { flash(Constants.WARNING, "auth.unauthorized.waringMessage"); } return redirect(routes.SiteApp.userList(0, null)); }
<|startcomment|> I know these are annotated nonnull, but since this is an assertion let's leave it in <|endcomment|> public Attachment(@NonNull Uri uri, @NonNull String contentType, long date, @Nullable String fileName) { <START> if (date < 0) { <END> throw new AssertionError("uri, content type, and date must all be specified"); } this.uri = uri; this.fileName = fileName; this.contentType = contentType; this.date = date; }
<|startcomment|> Just this will work too : services.add(new CoordinatorProxyService(config, storeClientConfigs)); You can save a line by not declaring a coordinator object. <|endcomment|> private List<VoldemortService> createServices() { List<VoldemortService> services = new ArrayList<VoldemortService>(); CoordinatorProxyService coordinator = new CoordinatorProxyService(config, storeClientConfigs); <START> services.add(coordinator); <END> if(config.isAdminServiceEnabled()) { services.add(new CoordinatorAdminService(config, storeClientConfigs)); } return ImmutableList.copyOf(services); }
<|startcomment|> log.trace <|endcomment|> public void afterBegin() throws EJBException, RemoteException { <START> log.info("afterBegin called"); <END> checker.setSynchronizedBegin(); }
<|startcomment|> This is a part of the java spec I'm not as familiar with. Is this doing `((descending ? 1 : 0) ^ value) < 0` or `descending ^ (value < 0)`? <|endcomment|> private boolean checkPagingSpec(PagingSpec pagingSpec, boolean descending) { for (Integer value : pagingSpec.getPagingIdentifiers().values()) { <START> if (descending ^ value < 0) { <END> return false; } } return pagingSpec.getThreshold() >= 0; }
<|startcomment|> Can we unroll this to use the new `Configurable` method instead? <|endcomment|> private void init(Jdbi db) { <START> db.registerArrayType(SqlArrayTypeFactory.of(UserId.class, "int", UserId::getId)); <END> db.registerColumnMapper(new UserIdColumnMapper()); }
<|startcomment|> shouldn't it return false even if addCanDoActionMessage=false? from the name of the parameter it sounds like only the message is not needed but still give the correct return value <|endcomment|> protected boolean updateBrickServerName(GlusterBrickEntity brick, boolean addCanDoActionMessage) { VdsStatic server = getVdsStaticDao().get(brick.getServerId()); <START> if ((server == null || !server.getvds_group_id().equals(getVdsGroupId())) && addCanDoActionMessage) { <END> addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID); return false; } brick.setServerName(server.gethost_name()); return true; }
<|startcomment|> private <|endcomment|> <START> public static <END> @NonNull String getSpanName(String attributeName) { return attributeName.substring(0, attributeName.lastIndexOf('/')); }
<|startcomment|> Why do you need to type parameter ? <|endcomment|> private static boolean containsAll(String text, final Collection<String> items) { final String _text = text.toLowerCase(); return items.stream() <START> .allMatch((String it) -> { <END> return _text.contains(it); }); }
<|startcomment|> This doesn't really need to be in an else clause. It might be more readable to invert the logic of this block, i.e.: if (e != null) { throw e; } Files.delete(dir); return FileVisitResult.CONTINUE; <|endcomment|> private void recursiveDelete(Path file) throws IOException { Files.walkFileTree(file, new SimpleFileVisitor<Path>() { @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return FileVisitResult.CONTINUE; } @Override public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException { if (e == null) { Files.delete(dir); return FileVisitResult.CONTINUE; <START> } else { throw e; } <END> } }); }
<|startcomment|> Does the `pageNumber` start at 1 or 0? If it starts at one, this conditional could be wrong: pageNumber=1, totalCount=7,pageSize=5 would return false, but there is still a next page. <|endcomment|> public Optional<Object> nextMarker() { if (totalCount < pageSize) return Optional.absent(); <START> if (pageNumber < (totalCount / pageSize)) { <END> return Optional.of(toPaginationOptions(pageNumber + 1)); } return Optional.absent(); }
<|startcomment|> Is it really necessary to add this check here? Doesn't the AuthenticationProcessor prevent the login request from reaching this point? <|endcomment|> public void testInvalidUser(AuthenticationFlowContext context, UserModel user) { <START> if (user == null || user.getServiceAccountClientLink() != null) { <END> dummyHash(context); context.getEvent().error(Errors.USER_NOT_FOUND); Response challengeResponse = challenge(context, getDefaultChallengeMessage(context)); context.failureChallenge(AuthenticationFlowError.INVALID_USER, challengeResponse); } }
<|startcomment|> missing second argument to view the actual exception message/stack trace: `file: " + downloadedFilePath, e)` <|endcomment|> public boolean validateChecksum() { if (StringUtils.isNotBlank(checksum)) { try { return DigestHelper.check(checksum, new FileInputStream(downloadedFilePath)); } catch (IOException e) { <START> throw new CloudRuntimeException("could not check sum for file: " + downloadedFilePath); <END> } catch (NoSuchAlgorithmException e) { throw new CloudRuntimeException("Unknown checksum algorithm: " + checksum, e); } } return true; }
<|startcomment|> can we avoid using `unmodifiableList` and have the cluster manager trust the list will be not modified ? <|endcomment|> public RegistrationUpdateEvent(String address, List<RegistrationInfo> registrations) { this.address = address; if (registrations == null || registrations.isEmpty()) { this.registrations = Collections.emptyList(); } else { <START> this.registrations = Collections.unmodifiableList(registrations); <END> } }
<|startcomment|> I would remove the variables and do `return new SingleKeyNonTxInvocationContext(true, keyEq);` the same thing can be applied to other methods <|endcomment|> public InvocationContext createInvocationContext(boolean isWrite, int keyCount) { if (keyCount == 1) { <START> SingleKeyNonTxInvocationContext result = <END> new SingleKeyNonTxInvocationContext(true, keyEq); return result; } else if (keyCount > 0) { NonTxInvocationContext ctx = new NonTxInvocationContext(keyCount, true, keyEq); return ctx; } return createInvocationContext(null); }
<|startcomment|> Remove all of the unnecessary final modifier from the local variables from all of the modified classes. <|endcomment|> private boolean isRealWorklog(final EveritWorklog worklog) { boolean isRealWorklog = true; if (issuesRegex != null) { <START> for (final Pattern issuePattern : issuesRegex) { <END> final boolean issueMatches = issuePattern.matcher(worklog.getIssue()).matches(); // if match not count in summary if (issueMatches) { isRealWorklog = false; break; } } } return isRealWorklog; }
<|startcomment|> remove instead? <|endcomment|> public void removed(IExtension[] extensions) { for (IExtension extension : extensions) { CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider.get(extension); if (layoutAlgorithmProvider != null) { List<CustomLayoutAlgorithm> customLayoutAlgorithms = layoutAlgorithmProvider.getCustomLayoutAlgorithms(); for (CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms) { layoutProviderRegistry.remove(customLayoutAlgorithm.getId()); } } <START> extensionToLayoutAlgorithmProvider.put(extension, <END> null); } }
<|startcomment|> This needs to be `typeId + 1`, since the parameter here is the _length_, while `typeId` is elsewhere used as an _index_. <|endcomment|> public void increment( int typeId ) { if ( typeId >= counts.length ) { <START> counts = Arrays.copyOf( counts, max( counts.length * 2, typeId ) ); <END> } counts[typeId]++; if ( typeId > highestTypeId ) { highestTypeId = typeId; } }
<|startcomment|> s/n/name/ n is always an index <|endcomment|> private static void delete(List<ReceiveCommand> cmds, List<ReceiveCommand> createCmds) { for (ReceiveCommand c : createCmds) { ObjectId id = c.getNewId(); String <START> n = <END> c.getRefName(); cmds.add(new ReceiveCommand(id, ObjectId.zeroId(), n)); } }
<|startcomment|> Use the one-argument version of convert, since the second argument passed in here is never used. <|endcomment|> public RefreshLocalVisitor(IProgressMonitor monitor) { this.monitor = <START> SubMonitor.convert(monitor, <END> TOTAL_WORK); workspace = (Workspace) ResourcesPlugin.getWorkspace(); resourceChanged = false; String msg = Messages.resources_errorMultiRefresh; errors = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.FAILED_READ_LOCAL, msg, null); }
<|startcomment|> Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](http://beanvalidation.org/1.1/spec/#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters) "arg0", "arg1" etc. as the default names. I feel we should stick to this for now. <|endcomment|> private ConfigurationImpl() { this.validationBootstrapParameters = new ValidationBootstrapParameters(); this.defaultResourceBundleLocator = new PlatformResourceBundleLocator( ResourceBundleMessageInterpolator.USER_VALIDATION_MESSAGES ); this.defaultTraversableResolver = new DefaultTraversableResolver(); this.defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl(); if ( Version.getJavaRelease() >= 8 ) { <START> this.defaultParameterNameProvider = new Java8DefaultParameterNameProvider(); <END> } else { this.defaultParameterNameProvider = new DefaultParameterNameProvider(); } this.defaultMessageInterpolator = new ResourceBundleMessageInterpolator( defaultResourceBundleLocator ); }
<|startcomment|> Do we need to declare object and then assign to null? Just remove them <|endcomment|> public void testNull_Event() { XDRResponseEventType eventA = new XDRResponseEventType(); <START> XDREventType eventB = new XDREventType(); <END> eventA = null; eventB = null; assertNull(xdrTransformHelper.transformXDRResponseToCheckPolicy(eventA)); assertNull(xdrTransformHelper.transformXDRToCheckPolicy(eventB)); }
<|startcomment|> Cruft, It doesn't matter, but this is an unused variable. <|endcomment|> public void testJNDIBindingsNoAppName() throws Exception { <START> boolean passed = false; <END> Context ctx = getInitialContext(HOST, PORT); Hello ejb = (Hello) ctx.lookup("ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello"); Assert.assertNotNull("Null object returned for local business interface lookup in the ejb namespace", ejb); Assert.assertTrue("Expected JNDI binding message not found", LoggingUtil.hasLogMessage(managementClient, TEST_HANDLER_NAME, "ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello")); }
<|startcomment|> remove <|endcomment|> public CrossesListDescriptionSheetParser(final T importedList, final UserDataManager userDataManager) { this.importedList = importedList; this.doParseDetails = true; this.doParseConditions = true; this.doParseFactors = true; this.doParseVariates = true; this.userDataManager = userDataManager; this.descriptionSheetIndex = 0; <START> ; <END> }
<|startcomment|> please change to ternary <|endcomment|> public VolumeClassification getVolumeClassification() { if (volumeClassification == null) { if <START> (active) <END> { return VolumeClassification.Volume; } return VolumeClassification.Snapshot; } return volumeClassification; }
<|startcomment|> no need for isNotNull nor isInstanceOf(String.class). They are both implicit with .isEqualTo("1.0.0.0") <|endcomment|> public void registerSonarQubeVersion_publishes_version_on_first_call() { ClusterProperties clusterProperties = new ClusterProperties(newClusterSettings()); try (HazelcastCluster hzCluster = HazelcastCluster.builder(clusterProperties).build()) { hzCluster.registerSonarQubeVersion("1.0.0.0"); HazelcastInstance hzInstance = createHazelcastClient(hzCluster); assertThat(hzInstance.getAtomicReference(SONARQUBE_VERSION).get()) .isNotNull() .isInstanceOf(String.class) <START> .isEqualTo("1.0.0.0"); <END> } }
<|startcomment|> Null pointer... <|endcomment|> public String[] getColumnTexts(@NonNull ITimeGraphEntry entry) { String[] texts = new <START> String[fColumns.length]; <END> for (int i = 0; i < fColumns.length; i++) { texts[i] = fLabelProvider.getColumnText(entry, i); } return texts; }
<|startcomment|> private <|endcomment|> protected Pageview() { <START> } <END>
<|startcomment|> import the class Messages ? <|endcomment|> public TreeFillingConfigurationDialog(final Shell parentShell, final TreeFillingConfiguration treefillingConfiguration, final List<ILabelProviderConfiguration> existingLabelProvidersConfiguration, final List<PasteEObjectConfiguration> existingPasteConfigurations) { super(parentShell); this.modifiedTreefillingConfiguration = EcoreUtil.copy(treefillingConfiguration); this.existingLabelProviderConfigurations = existingLabelProvidersConfiguration; this.existingPasteConfigurations = existingPasteConfigurations; <START> setTitle(org.eclipse.papyrus.customization.nattableconfiguration.messages.Messages.TreeFillingConfigurationDialog_treeFillingConfigurationDialogName); <END> }
<|startcomment|> `current` is redundant, just use `idx` <|endcomment|> public void execute(final Talks talks) throws IOException { int idx = this.index(talks); for (final Talk talk : talks.active()) { <START> final int current = idx + 1; <END> talk.modify( new Directives() .xpath("/talk/request") .attr("index", Integer.toString(current)) ); idx = current; } }
<|startcomment|> Looks good to me, but worth to protect `getFirstDrId()` and `getLastDrId()` too, they'll throw `NoSuchElementException` also if `m_map` is empty. <|endcomment|> public long getSafePointDrId() { // Acquire lock to avoid seeing bad data while another thread is in truncate() <START> synchronized (m_map) { <END> assert (!m_map.isEmpty()); return end(m_map.asRanges().iterator().next()); } }
<|startcomment|> is this necessary in the set up? wouldnt it be sufficient if this would be done once in the layout test? <|endcomment|> public void setUp() throws Exception { createProjectWithNfcAndSetVariable(PROJECT_NAME); numDetectedTags.setValue(0); nfcBrickPosition = 0; setVariableIDPosition = 1; setVariableMessagePosition = 2; baseActivityTestRule.launchActivity(null); <START> checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableIDPosition, READ_TAG_ID); <END> checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableMessagePosition, READ_TAG_MESSAGE); }
<|startcomment|> I don't think ProjectsImpl.this is necessary, it would only be necessary if the method call were get(this) which conflicts with the method name in the anonymous class. <|endcomment|> public ListRequest list() { return new ListRequest() { @Override public List<ProjectInfo> get() throws RestApiException { <START> return ProjectsImpl.this.list(this); <END> } }; }
<|startcomment|> potential NPE, entity can be NULL <|endcomment|> <START> public void validateEnums(WatchDog entity) { <END> EnumValidator.validateEnum(WatchdogAction.class, entity.getAction(), true); EnumValidator.validateEnum(WatchdogModel.class, entity.getModel(), false); }
<|startcomment|> My preference would be to remove `e.printStackTrace()` altogether and let the 'error' filters determine if they want to log the error. <|endcomment|> void error(ZuulException e) { RequestContext.getCurrentContext().setThrowable(e); zuulRunner.error(); <START> LOG.error(e.getMessage(), e); <END> }
<|startcomment|> rename to element <|endcomment|> private List<String> defaultIncludedModuleNamesForUnnamedModule() { if (fJavaElements != null) { List<IPackageFragmentRoot> roots= new ArrayList<>(); for (IJavaElement <START> fJavaElement : <END> fJavaElements) { if (fJavaElement instanceof IPackageFragmentRoot) { roots.add((IPackageFragmentRoot) fJavaElement); } } return JavaCore.defaultRootModules(roots); } return Collections.emptyList(); }
<|startcomment|> `@ResponseStatus(HttpStatus.NO_RESPONSE)`, void return type Same for `/enable` <|endcomment|> <START> public ResponseEntity<?> disable(@RequestBody List<Long> printerIds) throws IOException { <END> return setState(printerIds, false); }
<|startcomment|> Make the option validators above typed: `public static final FloatValidator FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR ...` and change this line to: `return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR);` Same for the other option. <|endcomment|> public double getFilterMinSelectivityEstimateFactor() { <START> return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR.getOptionName()).float_val; <END> }
<|startcomment|> why did you need to copy the env? it is accessible via getFactory().getEnv(). <|endcomment|> public JavaOutputProcessor(PrettyPrinter printer) { <START> this.printer = printer; <END> this.environment = printer.getEnvironment(); }
<|startcomment|> nit `IllegalArgumentException` <|endcomment|> public BucketFunction getBucketFunction( ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorPartitioningHandle partitioningHandle, List<Type> partitionChannelTypes, int bucketCount) { HivePartitioningHandle handle = (HivePartitioningHandle) partitioningHandle; BucketFunctionType bucketFunctionType = handle.getBucketFunctionType(); switch (bucketFunctionType) { case HIVE_COMPATIBLE: return createHiveCompatibleBucketFunction(bucketCount, handle.getHiveTypes().get()); case PRESTO_NATIVE: return createPrestoNativeBucketFunction(bucketCount, handle.getTypes().get()); default: <START> throw new IllegalStateException("Unsupported bucket function type " + bucketFunctionType); <END> } }
<|startcomment|> This is only required in things that render the FluidStack in a TESR. <|endcomment|> public void writePacketData(RailcraftOutputStream data) throws IOException { super.writePacketData(data); <START> tankManager.writePacketData(data); <END> data.writeBoolean(boiler.isBurning()); }
<|startcomment|> This _smells_ bad.. what was your reasoning to catch `UpdateException`? <|endcomment|> protected void setValue(final int rowIndex, final int columnIndex, final Date value) { DTCellValue52 dtCellValue52 = table52.getData() .get(rowIndex) .get(columnIndex); dtCellValue52 .setDateValue(value); try { updateManager.update(table52, getUpdates(rowIndex, columnIndex)); <START> } catch (UpdateException e) { <END> e.printStackTrace(); } }
<|startcomment|> ```suggestion () -> new TreeMap<>(Comparator.comparing(Event::getWhenOccured).thenComparing(Event::getExternalId)), Collectors.toList())); ``` <|endcomment|> private TreeMap<Event, List<EntryDTO>> buildEventEntryDTOMap(List<EntryDTO> entryDTOS) { return entryDTOS.stream().collect(Collectors.groupingBy(EntryDTO::getEvent, <START> () -> new TreeMap<>(Comparator.comparing(Event::getExternalId).thenComparing(Event::getWhenOccured)), Collectors.toList())); <END> }
<|startcomment|> 1. set this method to private, 2. create helpers for each property <|endcomment|> <START> public void verifyTableProperty(String propertyName, int propertyValue) { <END> waitForElementByElement(table); Assertion.assertEquals(table.getAttribute(propertyName), Integer.toString(propertyValue)); PageObjectLogging.log( "verifyTableProperty", "table has correct " + propertyName + " property", true ); }
<|startcomment|> Please post the examples of content for new metadata cache files to the Jira description <|endcomment|> public ColumnMetadata_v4(String[] name, PrimitiveType.PrimitiveTypeName primitiveType, Object minValue, Object maxValue, Long nulls) { <START> this.name = name; <END> this.minValue = minValue; this.maxValue = maxValue; this.nulls = nulls; this.primitiveType = primitiveType; }
<|startcomment|> The @Override should go on a line on its own, like in getReverseEntries() and the same below. <|endcomment|> <START> @Override public <END> ReflogEntry getReverseEntry(int number) throws IOException { lock.lock(); try { LogCursor cursor = reftable.seekLog(refname); while (true) { if (!cursor.next() || number < 0) { return null; } if (number == 0) { return cursor.getReflogEntry(); } number--; } } finally { lock.unlock(); } }
<|startcomment|> the .bagit folder does not have to be hidden. .bagit is our incubating next version of the bagit spec; it solves a lot of problems from the originial spec. <|endcomment|> public void testVersion0_98IsValid() throws Exception{ rootDir = Paths.get(getClass().getClassLoader().getResource("bags/v0_98/bag").toURI()); if (System.getProperty("os.name").contains("Windows")){ <START> Path bagitDir = rootDir.resolve(".bagit"); <END> Files.setAttribute(bagitDir, "dos:hidden", Boolean.TRUE); } Bag bag = reader.read(rootDir); sut.isValid(bag, true); }
<|startcomment|> remove `final` modifiers everywhere. <|endcomment|> public ProgramState checkPreStatement(CheckerContext context, Tree syntaxNode) { <START> final AbstractStatementVisitor visitor = new PreStatementVisitor(context); <END> syntaxNode.accept(visitor); return visitor.programState; }
<|startcomment|> This breaks compatibility. <|endcomment|> <START> ParameterMap getQueryParams(MuleEvent event) <END> { return resolveParams(event, HttpParamType.QUERY_PARAM); }
<|startcomment|> maybe make a copy constructor for this case? <|endcomment|> public Mutation(Mutation m) { m.serialize(); this.row = m.row; this.data = m.data; <START> this.size = new MutationSize(m.size.entries, m.size.sizeInBytes); <END> this.values = m.values; this.replicationSources = m.replicationSources; }
<|startcomment|> The last `null` is interpreted as a null `Flag`, not as a null `Flag[]`, and is causing some NPEs in the test suite: http://ci.infinispan.org/viewLog.html?buildId=6702&buildTypeId=bt9 <|endcomment|> public DecoratedCache(AdvancedCache<K, V> delegate, ClassLoader classLoader) { <START> this(delegate, classLoader, null, null); <END> }
<|startcomment|> Ternary ? true : false. ;) <|endcomment|> default Query getRemoveByQuery() { <START> if (isVersionedEntity()) { <END> return getQueryForVersion(); } return getByIdQuery(); }
<|startcomment|> There are still a lot of calls to this method, resulting in errors that will not reference any BPMN element. From a quick look, many of those do have an element id that we could reference. <|endcomment|> <START> public void addError(String errorMessage, Element element) { <END> errors.add(new ProblemImpl(errorMessage, name, element)); }
<|startcomment|> Suggestion: Use an else-if for these two and provide the missing braces. And instead of length() == 0 I'd use isEmpty(). <|endcomment|> private void validatePage() { String message = null; if (userText.getText().trim().length() == 0) message = Messages.CredentialsWizardPage_ErrorUser; <START> if (message == null && passwordText.getText().trim().length() == 0) <END> message = Messages.CredentialsWizardPage_ErrorPassword; setErrorMessage(message); setPageComplete(message == null); }
<|startcomment|> You probably don't want to pick this if `browserName` is also `chrome` or `chromium`, right? Otherwise this will match: `{"browserName": "chrome", "goog:chromeOptions": {}}`, which isn't what you want. <|endcomment|> public boolean isSupporting(Capabilities capabilities) { return BrowserType.EDGE.equals(capabilities.getBrowserName()) || capabilities.getCapability("chromeOptions") != null || <START> capabilities.getCapability("goog:chromeOptions") != null; <END> }
<|startcomment|> getSHT() can never actually be null, we should just annotate it. <|endcomment|> public HistoryTreeStub getHistoryTree() { <START> return (HistoryTreeStub) NonNullUtils.checkNotNull(super.getSHT()); <END> }
<|startcomment|> why the newArrayList? Iterables.filter already returns an iterable. <|endcomment|> public static Iterable<ITmfEventAspect<?>> getEventAspects(ITmfTrace trace, Class<? extends ITmfEventAspect<?>> aspectClass) { return <START> Lists.newArrayList(Iterables.filter(Iterables.concat(trace.getEventAspects(), <END> EXTRA_ASPECTS), aspect -> aspectClass.isAssignableFrom(aspect.getClass()))); }
<|startcomment|> So `PrestoSparkRowBuffer#get` is a blocked call. Is there any reason for that -- I am asking this since the general convention in Presto seems to be using `ListenableFuture<PrestoSparkRow>` for such cases? <|endcomment|> public PrestoSparkRow get() throws InterruptedException { PrestoSparkRow row; synchronized (monitor) { while (!finished && buffer.isEmpty()) { <START> monitor.wait(); <END> } if (finished) { return null; } row = buffer.poll(); } memoryManager.updateMemoryUsage(-row.getRetainedSize()); return row; }
<|startcomment|> This is useless since clear() below resets position to zero? <|endcomment|> private ByteBuffer parsePacketIDBAndNRB(int blockLength) throws IOException { ByteBuffer pcapPacketData; pcapPacketData = ByteBuffer.allocate(blockLength - PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); <START> pcapPacketData.position(PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); <END> pcapPacketData.clear(); SeekableByteChannel fFileChannel; try { fFileChannel = getFileChannel(); fFileChannel.read(pcapPacketData); } catch (BadPcapFileException e1) { /* Just ignore */ } pcapPacketData.flip(); return pcapPacketData; }
<|startcomment|> merge into one line <|endcomment|> public MiniEditorComponentObject triggerEditCommentArea() { jsActions.scrollToElement(allCommentsArea); WebElement mostRecentComment = articleComments.get(0); PageObjectLogging.log("First check",mostRecentComment.getText(), true); JavascriptExecutor js = (JavascriptExecutor) driver; WebElement editButton = mostRecentComment.findElement(By.cssSelector(EDIT_BUTTON_SELECTOR)); <START> Actions actions = new Actions(driver); <END> actions.moveToElement(editButton).perform(); js.executeScript("arguments[0].querySelector(arguments[1]).click()", mostRecentComment, EDIT_BUTTON_SELECTOR); return new MiniEditorComponentObject(driver); }
<|startcomment|> @wottop Would this mean that the "entitlement" mode is always included? Even if a mode list has been set on the owner that did not include it? If so, that does not seem right as it is valid to set the list to not contain entitlements as an option, just that if the list is empty that means it should be set to entitlement. <|endcomment|> public String getContentAccessModeList() { String[] modeList = contentAccessModeList == null ? new String[0] : contentAccessModeList.split(","); String ammend = ""; <START> if (!ArrayUtils.contains(modeList, ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE)) { <END> ammend = modeList.length > 0 ? "," : ""; ammend += ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE; } return modeList.length > 0 ? this.contentAccessModeList + ammend : ammend; }
<|startcomment|> @timowest weird. I remembered it was failed with testing on querydls-sql module. but it's gone now. <|endcomment|> public void setUp() { <START> System.setProperty("user.timezone", "UTC"); <END> TimeZone.setDefault(null); configuration = Configuration.DEFAULT; }
<|startcomment|> mWebViewStateOnDestroyViewを追加せずに mWebViewBridge.destroy(); のあとにmWebViewBridge =null; で解決すると思います <|endcomment|> public void onDestroyView() { mWebViewStateOnDestroyView = new Bundle(); try { storeWebView(mWebViewStateOnDestroyView); <START> mWebViewBridge.destroy(); <END> } catch (Exception exp) { Log.w(TAG, exp.getMessage() + "", exp); } super.onDestroyView(); }
<|startcomment|> Declare the logger at the top of the class: ```java private static final Logger log = Logger.get(GlueHiveMetastore.class); ``` (you might see the inline `Logger.get()` pattern in some tests, but it's not the normal way) <|endcomment|> private static void deleteDir(HdfsContext context, HdfsEnvironment hdfsEnvironment, Path path, boolean recursive) { try { hdfsEnvironment.getFileSystem(context, path).delete(path, recursive); } catch (Exception e) { // don't fail if unable to delete path <START> Logger.get(GlueHiveMetastore.class).warn(e, "Failed to delete path: " + path.toString()); <END> } }
<|startcomment|> `private static` <|endcomment|> <START> private boolean isNakedTD1Key(String s) <END> { return NAKED_TD1_KEY_PATTERN.matcher(s).matches(); }
<|startcomment|> nit: for readability i prefer a method called `isSequentialReadMode` to determine whether to seek or not <|endcomment|> public long skip(long n) throws IOException { if (n <= 0) { return 0; } if (n > MOVEMENT_LIMIT) { mSequentialReadCount = 0; } else { <START> ((Seekable) in).seek(mPos + n); <END> } mPos += n; return n; }
<|startcomment|> Missing assertNotNull for executionSet here. <|endcomment|> public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception { <START> Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_<START>_EVENT_FILE_PATH); <END> assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM); StartNoneEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartNoneEvent.class); assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE); assertStartEventSlaDueDate(emptySubprocess.getExecutionSet(), EMPTY_VALUE); }
<|startcomment|> Remove the reversal here, and let the JDK 8 implementation return it in reverse, and the JDK 9 implementation *not* reversed. <|endcomment|> private List<Window> fetchWindowsInQueue() { List<Window> windows = Lists.newArrayList(getWindows()); <START> return ImmutableList.copyOf(Lists.reverse(windows)); <END> }
<|startcomment|> what is the point of catching the exception here? <|endcomment|> protected void executeCommand(IDeviceManagementInteractor executor) throws DeploymentException { <START> try { executor.startFB(resource, new FBDeploymentData("", resFB)); //$NON-NLS-1$ //TODO correctly determine prefix } catch (DeploymentException e) { throw e; } <END> }
<|startcomment|> Make this method private. <|endcomment|> <START> void setReaderBudget() <END> { reader.setResultSizeBudget(ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes); }
<|startcomment|> Same as with the imperative template: Shouldn't we just deprecate these methods and introduce `Flux<SearchHit<T>> search(…)`? <|endcomment|> <START> default <T> Flux<SearchHit<T>> find(Query query, Class<T> entityType) { <END> return find(query, entityType, entityType); }
<|startcomment|> True, now. <|endcomment|> public Object execute(ExecutionEvent event) throws ExecutionException { RepositorySearchWizard wizard = new RepositorySearchWizard( util.getConfiguredRepositories(), <START> false); <END> WizardDialog dialog = new WizardDialog(getShell(event), wizard); if (dialog.open() == Window.OK) { for (String dir : wizard.getDirectories()) { File repositoryDir = FileUtils.canonicalize(new File(dir)); addRepository(repositoryDir); } } return null; }
<|startcomment|> We normally check if this is `null` and only set if non-null... IDK if your code handles `null` differently? <|endcomment|> public Map<String, String> load() { final Map<String, String> preferences = new HashMap<String, String>(); <START> final String property = System.getProperty( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED ); <END> log.info( "Setting preference '" + GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED + "' to '" + property + "'." ); preferences.put( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED, property ); return preferences; }
<|startcomment|> I think you need to return `taskParallelism` here b/c if the value specified as the max degree != `DEFAULT_MAX_DEGREE_OF_PARALLELISM`, then we return `1`, not, say `40` <|endcomment|> protected int getParallelHostCount(UpgradeContext ctx, int defaultValue) { if (m_grouping.parallelScheduler != null) { int taskParallelism = m_grouping.parallelScheduler.maxDegreeOfParallelism; if (taskParallelism == ParallelScheduler.DEFAULT_MAX_DEGREE_OF_PARALLELISM) { <START> taskParallelism = ctx.getDefaultMaxDegreeOfParallelism(); <END> } } return defaultValue; }
<|startcomment|> think this has to be synchronized <|endcomment|> <START> public static boolean stopIfIsPlaying(@Nullable AudioSlide slide) { <END> if (playing.isPresent() && playing.get().getAudioSlide().equals(slide)) { playing.get().stop(); return true; } else { return false; } }
<|startcomment|> Line should be breaked after `)` <|endcomment|> public List<AggregatorFactory> getRequiredColumns() { return fields.stream() .map( input -> new CardinalityAggregatorFactory( input.getOutputName(), null, Collections.singletonList(input), byRow, round ) <START> ).collect(Collectors.toList()); <END> }
<|startcomment|> add the type parameter even if it's object <|endcomment|> <START> public Optional getRequestAttribute(final String name) { <END> return Optional.ofNullable(this.request.getAttribute(name)); }
<|startcomment|> this method doesn't need to be public <|endcomment|> <START> public static String reflogComments(List<ReflogEntry> entries) { <END> StringBuffer b = new StringBuffer(); for (ReflogEntry e : entries) { b.append(e.getComment()).append(";"); } return b.toString(); }
<|startcomment|> The return value is never used. <|endcomment|> private static boolean validateName(String value) throws WSSecurityException { Name name; try { name = new LdapName(value); } catch (Exception e) { LOG.info("Validation of X509 Subject Name failed: {}", e.getLocalizedMessage(), e); throw new WSSecurityException(ErrorCode.FAILURE, "Not a valid X509 Subject Name."); } <START> return name != null; <END> }
<|startcomment|> Move close() to a finally-block? <|endcomment|> private static SimpleFeatureCollection parseGeoJSON(InputStream in, CoordinateReferenceSystem crs) throws IOException { Map<String, Object> geojson = OM.readValue(in, TYPE_REF); <START> in.close(); <END> SimpleFeatureType schema = GeoJSONSchemaDetector.getSchema(geojson, crs); return GeoJSONReader2.toFeatureCollection(geojson, schema); }
<|startcomment|> Worth checking if we really need this method at all, although probably not in THIS patch. Regardless, why use Boolean.FALSE and not a primitive false? <|endcomment|> private void refreshHostStorage(Guid hostId) { getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, StorageType.ISCSI, Boolean.FALSE)); <START> } <END>
<|startcomment|> do not create new DefaultShell inside syncexec <|endcomment|> public void openTestShells() { Display.syncExec(() -> { for (int i = 1; i <= TEST_SHELLS_COUNT; i++) { String shellTitle = "shell" + i; ShellTestUtils.createShell(shellTitle); <START> shells.add(new DefaultShell(shellTitle)); <END> } }); }
<|startcomment|> I do not think it should be public. IMO it should only called from `Builder`. <|endcomment|> <START> public RangeColumnStatistics( <END> Optional<Object> lowValue, Optional<Object> highValue, Estimate fraction, Estimate dataSize, Estimate distinctValuesCount) { this.lowValue = requireNonNull(lowValue, "lowValue can not be null"); this.highValue = requireNonNull(highValue, "highValue can not be null"); requireNonNull(fraction, "fraction can not be null"); requireNonNull(dataSize, "dataSize can not be null"); requireNonNull(distinctValuesCount, "distinctValuesCount can not be null"); this.statistics = createStatisticsMap(dataSize, fraction, distinctValuesCount); }
<|startcomment|> Sounds reasonable to me <|endcomment|> public void close() { log.debug("Closing record collector"); if (eosEnabled) { streamsProducer.abortTransaction(); } <START> streamsProducer.flush(); <END> checkForException(); }
<|startcomment|> set this in `initContext` instead? <|endcomment|> public static FileSystemContext create(ClientContext clientContext) { FileSystemContext ctx = new FileSystemContext(); ctx.init(clientContext, MasterInquireClient.Factory.create(clientContext.getClusterConf())); <START> ctx.mUriValidationEnabled = clientContext.getUriValidationEnabled(); <END> return ctx; }
<|startcomment|> Replace scheme first since it's first in the URL. Let's also wrap this since it's getting long: ```java return uriInfo.getBaseUriBuilder() .scheme(scheme) .replacePath("/v1/statement") .path(queryId.toString()) .path(String.valueOf(resultId.incrementAndGet())) .replaceQuery("") .build(); <|endcomment|> private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo) { <START> return uriInfo.getBaseUriBuilder().replacePath("/v1/statement").path(queryId.toString()).path(String.valueOf(resultId.incrementAndGet())).replaceQuery("").scheme(scheme).build(); <END> }
<|startcomment|> ``` java assertEquals(expectedContent.length(), Files.size(af.toPath())); ``` <|endcomment|> public void commitToFile() throws Exception { // Given afw.write(expectedContent, 0, expectedContent.length()); // When afw.commit(); // Then <START> assertTrue(Files.size(af.toPath()) == expectedContent.length()); <END> }
<|startcomment|> add { and } <|endcomment|> public void setColumnWidthPercentageByPosition(int columnPosition, int width, boolean fireEvent) { this.columnWidthConfig.setPercentage(columnPosition, width); if <START> (fireEvent) <END> fireLayerEvent(new ColumnResizeEvent(this, columnPosition)); }
<|startcomment|> Don't think any method is going to throw an `IOException`. We can get rid of this. <|endcomment|> <START> protected void connect() throws IOException <END> { // note that we are not connecting via JMX for testing mbeanServerConn = null; jmxc = null; ssProxy = StorageService.instance; msProxy = MessagingService.instance(); streamProxy = StreamManager.instance; compactionProxy = CompactionManager.instance; fdProxy = (FailureDetectorMBean) FailureDetector.instance; cacheService = CacheService.instance; spProxy = StorageProxy.instance; hhProxy = HintedHandOffManager.instance; gcProxy = new GCInspector(); gossProxy = Gossiper.instance; memProxy = ManagementFactory.getMemoryMXBean(); runtimeProxy = ManagementFactory.getRuntimeMXBean(); }
<|startcomment|> To clarify, this does not catch the `PrestoException` thrown from comparatorResult? Do you wan to include the thrown `e` in the new `PrestoException` created here? <|endcomment|> private void sortPositions(int arrayLength, Comparator<Integer> comparator) { List<Integer> list = positions.subList(0, arrayLength); try { list.sort(comparator); } catch (IllegalArgumentException e) { <START> throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Lambda comparator violates the comparator contract"); <END> } }
<|startcomment|> debug <|endcomment|> public void deactivate() { try { httpService.unregister(WEBAPP_ALIAS + SERVLET_NAME); } catch(IllegalArgumentException e) { <START> logger.info("LgTv Servlet '{}' was not registered. Nothing to deactivate.", WEBAPP_ALIAS + SERVLET_NAME); <END> } finally { logger.info("Stopped LgTv Servlet"); } }
<|startcomment|> times(1) is by default in verify <|endcomment|> public void freeTicketWhenExists(TicketsInteractor mockedTicketsInteractor) throws RecordNotFoundException, UpdateTicketStateUnauthorizedException { long ticketId = 1; ObjectNode json = Json.newObject(); ArrayNode node = json.putArray(ConstantsManager.TICKET_IDS_FIELD_NAME); node.add(ticketId); when(mockedBody.asJson()).thenReturn(json); Result result = ticketsController.free(); assertEquals(Helpers.OK, Helpers.status(result)); <START> verify(mockedTicketsInteractor, times(1)).freeATicket(ticketId); <END> }
<|startcomment|> Should this be done in `OutputCommitter#setupTask` instead of here? This method could be called more than once, but we want to ensure we set up the environment config just one time per task. The `setupTask` methods seems like a good place, unless you have a reason to do it here? <|endcomment|> private static <E> View<E> load(JobContext jobContext) { Configuration conf = Hadoop.JobContext.getConfiguration.invoke(jobContext); Class<E> type = getType(jobContext); String outputUri = conf.get(KITE_OUTPUT_URI); <START> DefaultConfiguration.set(conf); <END> return Datasets.<E, View<E>>load(outputUri, type); }
<|startcomment|> if the principal login test will already print the root cause, do we still need to print this here? <|endcomment|> public boolean validate(Map<String, String> optionsMap) { if (shouldSkip()) { return true; } if (!super.validate(optionsMap)) { return false; } if (!validatePrincipalLogin()) { <START> System.err.format("Principal login test failed.%n"); <END> return false; } return true; }
<|startcomment|> Done <|endcomment|> <START> public void createEdit() { <END> Button button = createButton(buttonparent, buttonEdit_ID, buttonEdit_caption, true); buttonBar.pack(); }
<|startcomment|> This should probably just call `read(String line, E reuse)` and pass in `null` for `reuse` rather than duplicate the method. <|endcomment|> <START> public E read(String line) { <END> try { return builder.makeRecord(parser.parseLine(line), null); } catch (IOException e) { throw new DatasetIOException("Cannot parse line: " + line, e); } }
<|startcomment|> Why would this not be a part of findMe method? instead of the a wrapper? Like here where the call to getLocation happens: https://github.com/mapzen/mapzen-android-demo/blob/peter/noMoToast/src/main/java/com/mapzen/fragment/MapFragment.java#L245 <|endcomment|> public void centerOnCurrentLocation() { followMe = true; <START> if (getMapController().getLocation() != null) { <END> findMe(); } }
<|startcomment|> JsonProcessingException is not necessary. <|endcomment|> public void serialize(final DoublesSketch sketch, final JsonGenerator generator, final SerializerProvider provider) <START> throws IOException, JsonProcessingException <END> { generator.writeBinary(sketch.toByteArray(true)); }
<|startcomment|> please keep old "for loop" style to reduce GC. <|endcomment|> public String toString() { StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('['); <START> for (MqttTopicSubscription subscription : topicSubscriptions) { <END> builder.append(subscription).append(", "); } if (!topicSubscriptions.isEmpty()) { builder.setLength(builder.length() - 2); } return builder.append(']').toString(); }
<|startcomment|> if you change to while (currentClass != null) {} you can avoid the outer if clause <|endcomment|> private Field[] getFields(Class<?> currentClass) { final List<Field> fields = new ArrayList<>(); <START> if (currentClass != null) { do { <END> fields.addAll(Arrays.asList(currentClass.getDeclaredFields())); currentClass = currentClass.getSuperclass(); } while (currentClass.getSuperclass() != null); } return fields.toArray(new Field[0]); }
<|startcomment|> nit: you can merge both lines above as `checkNotNull` will return the given argument <|endcomment|> public void setDecoderResult(DecoderResult decoderResult) { ObjectUtil.checkNotNull(decoderResult, "decoderResult"); <START> this.decoderResult = decoderResult; <END> }
<|startcomment|> ```suggestion requestData = request; ``` <|endcomment|> protected String contentFrom(FitNesseContext context, Request request, WikiPage requestedPage) { <START> requestData= request; <END> return prepareResponseDocument(context).html(); }
<|startcomment|> Just wonder how high requests rate we are discussing, 1mln/s? The Coordinator balancing process will choke to halt from such amount long before the discussed queue will show a mere slight latency. I'm sure a single queue will manage the current request rate of Coordinator, besides threads don't need to call *drainTo()* as they can perfectly consume calling *queue.take()*. <|endcomment|> public void start() { for (int i = 0; i < numProcessingQueues; i++) { processingExecutor.scheduleAtFixedRate( new SegmentChangeProcessor(segmentProcessingQueues[i]), 0, <START> config.getCuratorCreateZkNodesRepeatDelay().getMillis(), <END> TimeUnit.MILLISECONDS ); } }
<|startcomment|> Indentation here looks crazy! I'm thinking this might be some mismatch (between your IDE and github) in the number of spaces a tab is worth. <|endcomment|> <START> protected void doc(Class c) throws IOException { <END> open("tr class='TableRowColor'"); open("td"); around("span class='modifiers'",getModifiers(c)); close("td"); open("td"); link(c.getType()); tag("br"); around("span class='doc'", getDoc(c)); close("td"); close("tr"); }
<|startcomment|> internal cache, or just return null from this. <|endcomment|> public ArrayList<Pair<AbstractIngredient[], Float>> lookupShapedRecipes(Item i) { if (shapedReverseLookupTable.get(i) != null) return shapedReverseLookupTable.get(i); <START> return new ArrayList<Pair<AbstractIngredient[], Float>>(); <END> }
<|startcomment|> At some point we will probably need a variant of exists() that accepts an EventMetadata parameter, in case the existence decorator needs to know if a path has special properties within the scope of some package type. Not critical now. <|endcomment|> public boolean exists() { OverriddenBooleanValue overriden = null; if ( decorator != null ) { <START> overriden = decorator.decorateExists( this, new EventMetadata( ) ); <END> } if ( ( overriden != null ) && overriden.overrides() ) { return overriden.getResult(); } else { return provider.exists( resource ); } }
<|startcomment|> I think there is a race in `IndexingService` between `createIndexes` and `shutdown` where population jobs can be added after `IndexPopulationJobController.stop` is called. Result will be that we can leak population jobs. It might be that this is guarded for higher up in the stack. But I think this should be guarded for explicitly. Either here or in `IndexingService`. <|endcomment|> public void startIndexPopulation( IndexPopulationJob job ) { populationJobs.add( job ); <START> scheduler.schedule( indexPopulation, new IndexPopulationJobWrapper( job, this ) ); <END> }
<|startcomment|> `Integer.parseInt` <|endcomment|> public static int getOptionAsInteger(Map<String, String> options, String option, int defaultValue) { String value = options.get(option); <START> return value == null ? defaultValue : Integer.valueOf(value); <END> }
<|startcomment|> should this be thread safe ? <|endcomment|> public void releaseBuffer() { if (serializedCache != null) { serializedCache.release(); <START> if (serializedCache.refCnt() == 0) { <END> serializedCache = null; } } }
<|startcomment|> Good idea 👍 , but this checking should IMO be moved to `AppCredentials`. The `Os<X>` classes should generally just expose the Os interface and then we do the mapping on the "upper" layer, i.e. `AppCredentials` <|endcomment|> public Credentials.IdentityProvider getProvider() { String nativeProvider = nativeGetProvider(nativePtr); String id = identityProvider.getId(); // Sanity check - ensure nothing changed in the OS if (nativeProvider.equals(id)) { return identityProvider; } else { <START> throw new AssertionError("The provider from the Object Store differs from the one in Realm."); <END> } }
<|startcomment|> minor: rely on interface rather that full type. <|endcomment|> private static Set<SymbolicValue> computedFrom(@Nullable SymbolicValue symbolicValue) { if (symbolicValue == null) { return Collections.emptySet(); } <START> HashSet<SymbolicValue> result = new HashSet<>(); <END> result.add(symbolicValue); symbolicValue.computedFrom().forEach(sv -> result.addAll(computedFrom(sv))); return result; }
<|startcomment|> This method recursively calls itself, which will result in stackoverflow. Is that ok? <|endcomment|> public ClassLoader getClassLoader() { <START> return this.getClassLoader(); <END> }
<|startcomment|> Shouldn't this throw an exception instead? <|endcomment|> public Integer add(Stream<E> entities) { return delegate().add(entities.filter(entity -> { <START> boolean permitted = isOperationPermitted(entity, Action.CREATE); <END> if (permitted) { createAcl(entity); } return permitted; })); }
<|startcomment|> @lukasz-szewc I'd rather propose ``` java delayedExecution.allAsyncCallsStarted(); verify(mock, timeout(50)).oneArg('1'); twentyMillisDelayedExecution.allAsyncCallsStarted(); verify(mock, timeout(50)).oneArg('2'); ``` I agree with you however the name of this test is wrong... <|endcomment|> public void canIgnoreInvocationsWithJunit() throws InterruptedException { // given DelayedExecution delayedExecution = createZeroMillisDelayedExecution(); DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution(); // when delayedExecution.allAsyncCallsStarted(); <START> twentyMillisDelayedExecution.allAsyncCallsStarted(); <END> // then verify(mock, timeout(50)).oneArg('1'); verify(mock, timeout(50)).oneArg('2'); }
<|startcomment|> > else { [](start = 10, length = 6) you don't need this else block. <|endcomment|> public final boolean isExtendedLifetimeValid() { //extended lifetime is only valid if it contains an access token if (mExtendedExpiresOn != null && !StringExtensions.IsNullOrBlank(mAccessToken)) { return !isTokenExpired(mExtendedExpiresOn); <START> } else { <END> return false; } }
<|startcomment|> Redundant String constructor. <|endcomment|> public void sendDocumentFinalizedMessage(IWantDocument iWantDocument) { BodyMailMessage message = buildDocumentFinalizedMessage(iWantDocument); try { emailService.sendMessage(message, false); } catch (Exception e) { <START> String errorMessage = new String("sendDocumentFinalizedMessage, Email could not be sent for IWNT edoc# " + iWantDocument.getDocumentNumber()); <END> LOG.error(errorMessage, e); } }
<|startcomment|> minor: can be package private <|endcomment|> <START> public void addStore(PartitionId partitionId, ReplicationTest.StoreEventListener listener) { <END> storesByPartition.computeIfAbsent(partitionId, partitionId1 -> new InMemoryStore(partitionId, infosByPartition.computeIfAbsent(partitionId1, (Function<PartitionId, List<MessageInfo>>) partitionId2 -> new ArrayList<>()), buffersByPartition.computeIfAbsent(partitionId1, (Function<PartitionId, List<ByteBuffer>>) partitionId22 -> new ArrayList<>()), listener)); }
<|startcomment|> Add clarifying parenthesis. It's easy to forget the precedence rules for `^` and `&` so that will make the code easier to reason about. <|endcomment|> private static long doubleToSortableLong(double value) { long bits = Double.doubleToLongBits(value); <START> return bits ^ (bits >> 63) & Long.MAX_VALUE; <END> }
<|startcomment|> It's probably a bit low. I doubt GroupedJobInitializer use much memory so we could easily increase it a bit by default (like 100 maybe). Would need to check how many nodes are created after a few jobs are run in XWiki Standard. On extension side there is the root "extension" node and then 1 per namespace (so in practice 1 par wiki). It's potentially a lot more for the refactoring module since you have the root "refactoring" node and then one node for each element of each EntityReference which is manipulated. <|endcomment|> default int getGroupedJobInitializerCacheSize() { <START> return 10; <END> }
<|startcomment|> minor: `this` qualifiers not required. <|endcomment|> public DefaultCompactionPolicyTest() throws InterruptedException { Pair<MockBlobStore, StoreConfig> initState = CompactionPolicyTest.initializeBlobStore(properties, time, -1, -1, DEFAULT_MAX_BLOB_SIZE); <START> this.config = initState.getSecond(); <END> this.blobStore = initState.getFirst(); this.mockBlobStoreStats = blobStore.getBlobStoreStats(); this.messageRetentionTimeInMs = config.storeDeletedMessageRetentionDays * Time.HoursPerDay * Time.SecsPerHour * Time.MsPerSec; this.compactionPolicy = new DefaultCompactionPolicy(config, time); }
<|startcomment|> Why not simply iterate over the array of chars and not check if `stringToValidate.contains(character)`. <|endcomment|> private boolean containtsOnlyValidXMLChars(String stringToValidate) { <START> String pattern = "[^" <END> + "\u0009\r\n" + "\u0020-\uD7FF" + "\uE000-\uFFFD" + "\ud800\udc00-\udbff\udfff" + "]"; String resultString = stringToValidate.replaceAll(pattern, ""); if (resultString.equals(stringToValidate)) { return true; } return false; }
<|startcomment|> It's a pity we have to change the public API, but I guess it's reasonable in this case. Let's hope not so many folks wrote custom migrations commands. <|endcomment|> <START> public CloseableLiquibase(String changeLogFile, ResourceAccessor resourceAccessor, Database database, ManagedDataSource dataSource) throws LiquibaseException, SQLException { <END> super(changeLogFile, resourceAccessor, database); this.dataSource = dataSource; }
<|startcomment|> Might as well remove these fields if they are not used. Perhaps just call the other constructor with: this(iters.get(0).getCtfTmfTrace()); <|endcomment|> public CtfTmfLightweightContext(ArrayList<CtfIterator> iters, ListIterator<CtfIterator> pos) { fIteratorPool = iters; <START> fCurrentIterator = pos; <END> fTrace = iters.get(0).getCtfTmfTrace(); curLocation = new CtfLocation((Long)null); collisions = 0; }
<|startcomment|> The Exception is never thrown. <|endcomment|> <START> public void testIsAdHocAutostart_true() throws Exception { <END> String id = UUID.randomUUID().toString(); AdHocSubProcess adHocSubProcess = bpmn2.createAdHocSubProcess(); adHocSubProcess.setId(id); CustomElement.autoStart.of(adHocSubProcess).set(Boolean.TRUE); tested = new AdHocSubProcessPropertyReader(adHocSubProcess, definitionResolverReal.getDiagram(), definitionResolverReal); assertTrue(tested.isAdHocAutostart()); }
<|startcomment|> Remove the parameter completely, the other constructor will initiate the publisher as null. <|endcomment|> private BroadcastTrimmer broadcastTrimmer() { return new ScheduleResolverBroadcastTrimmer( <START> null, <END> scheduleResolver, contentResolver, contentWriter ); }
<|startcomment|> clear the forwarders list after the loop? <|endcomment|> public void disconnect() throws IOException { if (forwarders != null) { for (LocalPortForwarder forwarder : forwarders) { try { forwarder.close(); } catch (IOException e) { log.warn("Error closing forwarder", e); } <START> } <END> } trans.disconnect(); super.disconnect(); }
<|startcomment|> NIT: is there just a plain `decrement()`? <|endcomment|> public void close() { super.close(); if (mRefCount != null) { <START> mRefCount.decrementAndGet(); <END> } }
<|startcomment|> Use logger instead of `printStackTrace()` calls. <|endcomment|> public static String getParameter(String key) { try { return getConfig().getString(key); } catch (NoSuchElementException e) { <START> e.printStackTrace(); <END> throw new NoSuchElementException("No configuration found in " + CONFIG_FILE + " for key " + key + "!"); } }
<|startcomment|> This class should be immutable anyway so why not wrap the collection in the constructor once rather than every time it is returned to caller? <|endcomment|> public List<Option> getOptions() { <START> return unmodifiableList(options); <END> }
<|startcomment|> Do we need to set the input position to the initial offset? <|endcomment|> public DataInputNavigableJsonAdapter(BufferObjectDataInput input, int initialOffset) { this.input = input; this.initialOffset = initialOffset; <START> } <END>
<|startcomment|> So it means that an argument with unknown type is considered as not serializable? Should we consider making the unknown check inside `isNotSerializable` and provide the same behavior for all rules using it? I'm saying this since the other rule (S2118) using `isNotSerializable` is also reporting an arguable issue with a similar message if we run it against an unknown type. > Make the "!Unknown!" class "Serializable" or don't write it. <|endcomment|> protected void onMethodInvocationFound(MethodInvocationTree mit) { ExpressionTree argument = mit.arguments().get(1); Type type = argument.symbolType(); <START> if (type.isUnknown()) { <END> return; } if (ExpressionsHelper.isNotSerializable(argument)) { String andParameters = JUtils.isParametrized(type) ? " and its parameters" : ""; reportIssue(argument, "Make \"" + type + "\"" + andParameters + " serializable or don't store it in the session."); } }
<|startcomment|> Is this cast still necessary? <|endcomment|> public Predicate createPredicateAndJoin(String filterString, Root<T> root) { LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer(new ANTLRInputStream(filterString)); LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser(new CommonTokenStream(lexer)); parser.addErrorListener(new OsiamAntlrErrorListener()); ParseTree tree = parser.parse(); EvalVisitor<T> visitor = new EvalVisitor<>(this, root); <START> return (Predicate) visitor.visit(tree); <END> }
<|startcomment|> Remove the exceptions, since they're never thrown from the method. <|endcomment|> <START> public Privilege[] getSupportedPrivileges(String path) throws PathNotFoundException, RepositoryException { <END> return privileges.listOfSupported(); }
<|startcomment|> I'd have thought preserving the use of ```Optional``` in the class's implementation would be nicer than just using ```Optional``` on the constructor and then reverting to ```null``` _inside_ the class. <|endcomment|> protected AbstractSessionPresenter(final SessionManager sessionManager, final SessionPresenter.View view, final Optional<? extends ToolbarFactory<S>> toolbarFactory, final Optional<PaletteWidgetFactory<DefinitionSetPalette, ?>> paletteFactory, final NotificationsObserver notificationsObserver) { this.sessionManager = sessionManager; <START> this.toolbarFactory = toolbarFactory.orElse(null); <END> this.paletteFactory = paletteFactory.orElse(null); this.notificationsObserver = notificationsObserver; this.view = view; this.hasToolbar = true; this.hasPalette = true; }
<|startcomment|> czy to musi byc publiczne? <|endcomment|> <START> public void prepareToNewMarker() { <END> drawerLayout.closeDrawers(); setLongClickListener(true); setToastMarkerInfo(); }
<|startcomment|> The skipRead parameter isn't used. <|endcomment|> <START> private MVCCEntry wrapMvccEntryForPut(InvocationContext ctx, Object key, CacheEntry cacheEntry, Metadata providedMetadata, boolean skipRead) { <END> if (cacheEntry instanceof MVCCEntry) { MVCCEntry mvccEntry = (MVCCEntry) cacheEntry; updateMetadata(mvccEntry, providedMetadata); return mvccEntry; } return wrapInternalCacheEntryForPut(ctx, key, (InternalCacheEntry) cacheEntry, providedMetadata, true); }
<|startcomment|> You should make the `read()` call part of the `SERVICE_FAILURE_ACTIONS(Pointer)` constructor. <|endcomment|> public SERVICE_FAILURE_ACTIONS getFailureActions() { Pointer buffer = queryServiceConfig2(Winsvc.SERVICE_CONFIG_FAILURE_ACTIONS); SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS(buffer); <START> result.read(); <END> return result; }
<|startcomment|> I would add the other createTempFile method to enforce the fact that we explicitly target this one only. <|endcomment|> void fun(String strPath, String StrParent, String StrChild, String prefix, String suffix, java.net.URI uri) throws Exception { // Questionable: check what is done with this file new File(strPath); // Noncompliant new File(StrParent, StrChild); // Noncompliant {{Make sure this file handling is safe here.}} File parent = new File(uri); // Noncompliant new File(parent, StrChild); // compliant we rely on the fact that parent should be highlighted <START> File.createTempFile(prefix, suffix); // Noncompliant <END> }
<|startcomment|> I see that VmName in not included in the error message.. not sure if the right thing to do is to include it in the message or not to set it here <|endcomment|> public ValidationResult vmNotHavingPciPassthroughDevices() { for (VM vm : vms) { if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) { return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES, <START> String.format("$VmName %s", vm.getName())); <END> } } return ValidationResult.VALID; }
<|startcomment|> did you want to log this exception ? <|endcomment|> public void onError(Throwable e) { <START> e.printStackTrace(); <END> try { FileLfsServlet.sendError(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage()); context.complete(); in.close(); } catch (IOException ex) { LOG.log(Level.SEVERE, ex.getMessage(), ex); } }
<|startcomment|> Return could be simplified: `return lines.remove(lines.lastKey());` :) <|endcomment|> public String pop() { <START> String value = lines.remove(lines.lastKey()); <END> return value; }
<|startcomment|> Shouldn't this be in onDestroy? <|endcomment|> public void onDestroyView() { mapView.onDestroy(); mapboxMap = null; unbinder.unbind(); unbinder = null; <START> WikipediaApp.getInstance().getRefWatcher().watch(this); <END> super.onDestroyView(); }
<|startcomment|> getClass comparison is required for Dtos because of the way their inheritance works (analyte is also a tissue and an identity for the purpose of including parent data), but instanceof should be used here (and typically for the non-dto models), and check vs. interfaces for flexibility. e.g. we could add another implementation of SampleCVSlide that this method should still work for, or we could subclass SampleCVSlideImpl (however unlikely) <|endcomment|> private static SampleTissueProcessingDto asTissueProcessingSampleDto(SampleTissueProcessing from) { SampleTissueProcessingDto dto = null; <START> if (from.getClass() == SampleCVSlideImpl.class) { <END> dto = asCVSlideSampleDto((SampleCVSlide) from); } else if (from.getClass() == SampleLCMTubeImpl.class) { dto = asLCMTubeSampleDto((SampleLCMTube) from); } else { dto = new SampleTissueProcessingDto(); } return dto; }
<|startcomment|> Unnecessary new line here and below: why leave the first line blank? (unless there's a wrap in the signature, in which case it can help to differentiate between the signature and the body). <|endcomment|> public void testMakeTimeZone_NoOffsets() throws IOException { <START> <END> int[][] times = {}; int[][] offsets = {}; try { createZoneInfo(times, offsets); fail("Did not detect no transitions"); } catch (IllegalStateException expected) { // Expected this to happen } }
<|startcomment|> Since the constructor is package private and only the Guice injector will be able to call it, you can remove all the null checks. The injector will already fail if any parameter is missing. <|endcomment|> DeploymentToNodeMetadata(@Memoized Supplier<Set<? extends Location>> locations, GroupNamingConvention.Factory namingConvention, OSImageToImage osImageToImage, RoleSizeToHardware roleSizeToHardware, Map<String, Credentials> credentialStore) { this.nodeNamingConvention = checkNotNull(namingConvention, "namingConvention").createWithoutPrefix(); this.locations = checkNotNull(locations, "locations"); this.osImageToImage = checkNotNull(osImageToImage, "osImageToImage"); this.roleSizeToHardware = checkNotNull(roleSizeToHardware, "roleSizeToHardware"); <START> this.credentialStore = checkNotNull(credentialStore, "credentialStore cannot be null"); <END> }
<|startcomment|> I wonder if you shouldn't keep the old constructor here, and not use an extra boolean argument. <|endcomment|> public AsyncContext startAsync() throws IllegalStateException { if (_asyncNotSupportedSource != null) throw new IllegalStateException("!asyncSupported: " + _asyncNotSupportedSource); HttpChannelState state = getHttpChannelState(); if (_async == null) _async = new AsyncContextState(state); <START> AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, this, getResponse(), false); <END> state.startAsync(event); return _async; }
<|startcomment|> After `throws Exception` is dropped from rollbackLocks, seems like this code should be : ```java CompletableFuture<Void> getFailureOp(CommitData cd) { return rollbackLocks(cd); } ``` <|endcomment|> CompletableFuture<Void> getFailureOp(CommitData cd) { <START> return CompletableFuture.supplyAsync(() -> { <END> try { rollbackLocks(cd); } catch (Exception e) { throw new CompletionException(e); } return null; }, env.getSharedResources().getSyncCommitExecutor()); }
<|startcomment|> symbol.name() called 3 times? maybe worth a dedicated variable. <|endcomment|> private boolean isGuavaPrecondition(Symbol.MethodSymbol symbol) { return symbol.owner().type().is("com.google.common.base.Preconditions") <START> && ("checkNotNull".equals(symbol.name()) || "checkArgument".equals(symbol.name()) || "checkState".equals(symbol.name()) ); <END> }
<|startcomment|> We had that cancelUpdate() at the beginning of updateContent(). Now the UpdateThread doesn't get cancelled with TmfXYChartViewer.windowRangeUpdated() and TmfCommonXAxisChartViewer.setNbPoints(). <|endcomment|> public void loadTrace(ITmfTrace trace) { <START> cancelUpdate(); <END> super.loadTrace(trace); initializeDataProvider(); }
<|startcomment|> StringInputRowParser is used by parser options that aren't file-oriented (you can use it on streams etc) so this isn't a good place to put this. imo, this should replace `reset()` and be called in places that `reset()` is currently called (like FileIteratingFirehose). With one addition: it needs to be called before the very first file too. <|endcomment|> public StringInputRowParser( @JsonProperty("parseSpec") ParseSpec parseSpec, @JsonProperty("encoding") String encoding ) { this.parseSpec = parseSpec; this.mapParser = new MapInputRowParser(parseSpec); this.parser = parseSpec.makeParser(); <START> parser.startFileFromBeginning(); <END> if (encoding != null) { this.charset = Charset.forName(encoding); } else { this.charset = DEFAULT_CHARSET; } }
<|startcomment|> The superclass only repeats the assertComplete() call. I don't think this PR adds any value. <|endcomment|> public Object getNegotiatedProperty(String propName) { assertComplete(); switch (propName) { case Sasl.QOP: return selectedQop.getName(); case Sasl.MAX_BUFFER: return Integer.toString(actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer); case Sasl.RAW_S<END>_SIZE: return Integer.toString(maxBuffer); } <START> return super.getNegotiatedProperty(propName); <END> }
<|startcomment|> this is inside Expressions, so maybe just `asBoolean(constant(value))`, the same with the others <|endcomment|> public static BooleanExpression asBoolean(boolean value) { <START> return asBoolean(Expressions.constant(value)); <END> }
<|startcomment|> You can do `this::deleteOldSegments` for the callable. It is more efficient lambda form <|endcomment|> public void startPolicyEnforcement() throws IOException { if (m_pbd.getUsageSpecificLog().isDebugEnabled()) { m_pbd.getUsageSpecificLog().debug("Starting time based retention policy enforcement with retainMillis=" + m_retainMillis + " for PBD " + m_pbd.getNonce()); } m_reader = m_pbd.openForRead(CURSOR_NAME); <START> scheduleTaskFor(m_pbd.getNonce(), ()->deleteOldSegments(), 0); <END> }
<|startcomment|> Do you need to guard against `null` here as well? <|endcomment|> public void afterRun() throws Exception { if (recordStore.isWanReplicationEnabled()) { CacheRecord record = recordStore.getRecord(key); if (record != null) { publishWanUpdate(key, record); <START> } else { <END> publishWanRemove(key); } } super.afterRun(); }
<|startcomment|> `toLowerCase` <|endcomment|> protected String getConfigRoot() { <START> return ClientConfigSections.HAZELCAST_CLIENT.name.toLowerCase(); <END> }
<|startcomment|> Does this method have to be synchronized, considering that `capacity` is `final`? <|endcomment|> <START> public synchronized int getCapacity() { <END> return capacity; }
<|startcomment|> why add 'null' to allArtTypes? <|endcomment|> private Set<IArtifactType> getAllArtTypes() { Set<IArtifactType> allArtTypes = new HashSet<>(); if (artifactTypes == null || !artifactTypes.isEmpty()) { <START> allArtTypes.addAll(artifactTypes); <END> } else { getArtifactTypesFromWorkItemTypes(); } return allArtTypes; }
<|startcomment|> This should be moved outside the try block <|endcomment|> public void testContextListenerIsSet() throws Exception { try (WizardCommandController tester = testHarness.createWizardController(MyFirstWizard.class)) { tester.initialize(); Assert.assertTrue("Wizard is not on a valid state", tester.isValid()); Assert.assertTrue("Listener is not set", listener.isContextInitialized()); tester.execute(); <START> Assert.assertFalse("Listener is still set", listener.isContextInitialized()); <END> } }
<|startcomment|> package private <|endcomment|> <START> private Later(F0<A> producer) { <END> this.memo = P.hardMemo(producer); }
<|startcomment|> Codacy flagged this method for "Avoid using a branching statement as the last in a loop." I think that is a reasonable call by Codacy and the code would be easier to read if runningFromCommandLine was set to true in the loop, followed by a break, and a single method return of runningFromCommandLine on what is currently line 136. Alternatively, one could also do away with runningFromCommandLine and have a return true statement in the loop, but I think the first alternative may be a little easier to read and will make Codacy content. <|endcomment|> private boolean isRunningFromCommandLine() { boolean runningFromCommandLine = false; // first look up all OptionProcessors and see if running from command line option is set Collection<? extends OptionProcessor> optionProcessors = Lookup.getDefault().lookupAll(OptionProcessor.class); Iterator<? extends OptionProcessor> optionsIterator = optionProcessors.iterator(); while (optionsIterator.hasNext()) { // find CommandLineOptionProcessor OptionProcessor processor = optionsIterator.next(); if (!(processor instanceof CommandLineOptionProcessor)) { continue; } // check if we are running from command line runningFromCommandLine = ((CommandLineOptionProcessor) processor).isRunFromCommandLine(); return runningFromCommandLine; } return false; <START> } <END>
<|startcomment|> Unless you want this to be tri-state, then "Boolean" should be "boolean". I don't see the need for tristate, so go with "boolean" <|endcomment|> <START> public Boolean onReceivedHttpAuthRequest(CordovaWebView view, ICordovaHttpAuthHandler handler, String host, String realm) { <END> for (CordovaPlugin plugin : this.pluginMap.values()) { if (plugin != null && plugin.onReceivedHttpAuthRequest(view, handler, host, realm)) { return true; } } return false; }
<|startcomment|> lockPath is already String <|endcomment|> private String createAndGetLockPath() throws InterruptedException, KeeperException { // Create locks if it does not exist <START> if (zk.exists(lockPath.toString(), false) == null) { <END> try { Util.mkdir(zk, lockPath.toString(), ZooDefs.Ids.OPEN_ACL_UNSAFE); } catch (CloudnameException e) { log.log( java.util.logging.Level.INFO, "CloudnameException while trying to get lock path " + absoluteLockPath, e); } } return lockPath + "/" + lockName; }
<|startcomment|> What I mean is, your dialect does not implement `BatchableGridDialect`, so items will never be put in to the operations queue. <|endcomment|> public Tuple getTuple(EntityKey key, TupleContext tupleContext) { Entity entity = getEntity( key, tupleContext.getOptionsContext() ); if ( entity != null ) { return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) ); } <START> else if ( isInTheQueue( key, tupleContext ) ) { <END> // The key has not been inserted in the db but it is in the queue return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) ); } else { return null; } }
<|startcomment|> Isn't it enough to throw the logging exception instead of also logging locally ? <|endcomment|> public void invoke(ClientEvent event) { try { method.invoke(listener, event); } catch (InvocationTargetException e) { log.errorInvokingListener(method, listener, e.getTargetException()); throw log.exceptionInvokingListener( e.getClass().getName(), method, listener, e.getTargetException()); } catch (Exception e) { throw log.exceptionInvokingListener( <START> e.getClass().getName(), method, listener, e); <END> } }
<|startcomment|> can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general. <|endcomment|> ConfigFileConfigProvider(@JsonProperty("configFile") String configFile){ this.configFile = configFile; <START> loadProperties(); <END> }
<|startcomment|> No println's, please. <|endcomment|> public void addDataSource(long dataSourceObjectId) throws IngestStreamClosedException { // Do nothing <START> System.out.println("### DefaultAddImageTaskIngestStream - addDataSource " + dataSourceObjectId); <END> }
<|startcomment|> I don't know if they should be put inside this method or not. Should temp table be considered as staging directories? <|endcomment|> private void deleteEmptyStagingDirectories(List<DeclaredIntentionToWrite> declaredIntentionsToWrite) { for (DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite) { <START> Path path = declaredIntentionToWrite.getRootPath(); <END> if (declaredIntentionToWrite.isTemporaryTable()) { // for temporary table simply delete the entire directory deleteRecursivelyIfExists(declaredIntentionToWrite.getContext(), hdfsEnvironment, path); continue; } if (declaredIntentionToWrite.getMode() != WriteMode.STAGE_AND_MOVE_TO_TARGET_DIRECTORY) { continue; } recursiveDeleteFilesAndLog(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, "staging directory cleanup"); } }
<|startcomment|> format <|endcomment|> public void edit() { if (getWindow() != null) { return; } <START> EditDiskProfileModel model = <END> new EditDiskProfileModel(this, getCompatibilityVersion(), (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId()); setWindow(model); initProfileStorageDomains(model); }
<|startcomment|> Please remove that line. It changes the tests. <|endcomment|> public void setUp() throws Exception { super.setUp(); gitDir = new File(project.getProject() .getLocationURI().getPath(), Constants.DOT_GIT); testRepository = new TestRepository(gitDir); testRepository.connect(project.getProject()); <START> testRepository.commit("initial commit"); <END> }
<|startcomment|> should look like this but without the declaration above - they should be on one line ```suggestion long deckID = getCol().getDecks().selected(); ``` <|endcomment|> protected long getParentDid() { long deckID; <START> deckID = getCol().getDecks().selected(); <END> return deckID; }
<|startcomment|> Actually this part does not throw any Exception. Just remove `throws Exception` and we should be good. Beware of spaces vs tabs. Prefer using spaces for indentation please. <|endcomment|> public static String getFileExtension(File file) throws Exception { <START> return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase(); <END> }
<|startcomment|> You do not need to call Integer.parseInt(getUuid()) more than once in a method. <|endcomment|> public void shouldPurgeAnAutoGenerationOption() throws Exception { <START> assertNotNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid()))); <END> MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + "/" + getUuid()); req.addParameter("purge", ""); handle(req); assertNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid()))); }
<|startcomment|> Any chance we could make this test `@Parameterized`? To test 35 different perspectives from within one test case seems evil. Alternatively (as I'm sniffing potential problems with the annotation and Arquillian.), can we at least make the looped code its own function and put some logging around it, so that we know when was it that the test actually failed? Of course, we could also have a different method for each of the perspectives - which would be the "cleanest" solution in this situation. But I sort of see how that would be overkill. <|endcomment|> <START> private void loadPerspectiveAndCheckLoadingTime(String perspectiveID, boolean headerIncluded) { <END> //long loadingStart = System.currentTimeMillis(); String standalonePerspectiveURL = getStandalonePerspectiveURL(perspectiveID, headerIncluded); driver.get(standalonePerspectiveURL); BusyPopup.waitForDisappearance(); ApplicationLoadingPopup.waitForDisappearance(PERSPECTIVE_LOADING_TIMEOUT); //double perspectiveLoadingTime = (System.currentTimeMillis() - loadingStart) / (double) 1000; //TODO: What is the acceptable loading time? Do we want to test this? //assertThat(perspectiveLoadingTime) // .as("It should take less than "+PERSPECTIVE_LOADING_TIMEOUT+" seconds to load the perspective " + perspectiveID + ".") // .isLessThan(PERSPECTIVE_LOADING_TIMEOUT); }
<|startcomment|> THis should return empty array <|endcomment|> public default IVariableBinding[] getSyntheticOuterLocals() { return <START> null; <END> }
<|startcomment|> Both should be initialized even for failures <|endcomment|> protected void executeCommand() { AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId()); if (profile == null) { setSucceeded(false); } else { sessionId = getParameters().getSessionId(); <START> sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId()); <END> sessionDataContainer.setSessionValid(getParameters().getSessionId(), false); setSucceeded(true); } }
<|startcomment|> Sure you shouldn't do this if the thread is visible? This way, the notification will not disappear when the thread is visible for some reason. <|endcomment|> public static void updateNotification(Context context, MasterSecret masterSecret, long threadId) { if (TextSecurePreferences.isNotificationsEnabled(context)) { if (visibleThread == threadId) { DatabaseFactory.getThreadDatabase(context).setRead(threadId); sendInThreadNotification(context); } else { <START> updateNotification(context, masterSecret, true); <END> } } updateBadge(context); }
<|startcomment|> not sure if makes sense, but instead of putting the `toString()` as values, I probably would use the Enum's `name() `method, as the `toString()` is usually been overridden... <|endcomment|> protected void fillOptions(Map<Enum, String> options) { options.put(EnumModel.VAL1, <START> EnumModel.VAL1.toString()); <END> options.put(EnumModel.VAL2, EnumModel.VAL2.toString()); options.put(EnumModel.VAL3, EnumModel.VAL3.toString()); options.put(EnumModel.VAL4, EnumModel.VAL4.toString()); }
<|startcomment|> The same `Arrays.stream()` can be applied here as well. <|endcomment|> public boolean removeQueues(Queue... queues) { <START> removeQueues(Arrays.asList(queues) <END> .stream() .map(Queue::getName)); return super.removeQueues(queues); }
<|startcomment|> String.valueOf() <|endcomment|> private static Object castIntegerToObect(int value, Type type) { if (type == INTEGER || type == TINYINT || type == BIGINT) { return (long) value; } if (type == VARCHAR) { <START> return value + ""; <END> } if (type == DOUBLE) { return (double) value; } throw new UnsupportedOperationException(); }
<|startcomment|> `stop()` should be in a finally block, or you could use `TestingUtil.withCacheManager()`. <|endcomment|> public void testXmlConfig() throws IOException { EmbeddedCacheManager cm = new DefaultCacheManager("jpa-config.xml"); Cache<String, KeyValueEntity> specificCache = cm.getCache("specificCache"); validateConfig(specificCache); KeyValueEntity entity = new KeyValueEntity("k", "v"); specificCache.put(entity.getK(), entity); <START> cm.stop(); <END> }
<|startcomment|> Shouldn't this be SessionEditorInput? Here equals() can return true for instances of different subclasses of URIEditorInput which point to the same URI. I have not checked, but maybe it happen could if have my aird opened at the same time inside a non-Sirius editor. <|endcomment|> public boolean equals(Object o) { boolean equals = this == o || o instanceof <START> URIEditorInput && <END> getURI().equals(((URIEditorInput) o).getURI()); if (equals && o instanceof SessionEditorInput) { EObject input = getInput(false); if (input != null) { SessionEditorInput otherSessionEditorInput = (SessionEditorInput) o; return input.equals(otherSessionEditorInput.getInput(false)); } } return equals; }
<|startcomment|> This will cause creator to change on every update <|endcomment|> private void loadChildEntities(LibraryDilution dilution) throws IOException { if (dilution.getLibrary() != null) { dilution.setLibrary(libraryDao.get(dilution.getLibrary().getId())); } if (dilution.getTargetedSequencing() != null) { dilution.setTargetedSequencing(targetedSequencingDao.get(dilution.getTargetedSequencing().getId())); } <START> dilution.setDilutionCreator(authorizationManager.getCurrentUsername()); <END> }
<|startcomment|> No need to have the styleState variable at all. <|endcomment|> GdkColor getContextColor () { long /*int*/ fontHandle = fontHandle (); long /*int*/ context = OS.gtk_widget_get_style_context (fontHandle); GdkRGBA rgba = new GdkRGBA (); if (OS.GTK_VERSION < OS.VERSION(3, 18, 0)) { rgba = display.styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba); } else { <START> int styleState = OS.gtk_widget_get_state_flags(handle); <END> rgba = display.styleContextGetColor (context, styleState, rgba); } return display.toGdkColor (rgba); }
<|startcomment|> These 2 can be called just once. <|endcomment|> public Subquery parameter(String listId, Object... values) { if (values == null || values.length == 0 || values[0] == null) { return this; } where.setToNormal(); where.setToIntersection(); where.addParameter(listId, values); <START> return this; <END> }
<|startcomment|> Minor : parentheses are not needed <|endcomment|> public int hashCode() { <START> int result = (key ? 1 : 0); <END> result = 31 * result + (path != null ? path.hashCode() : 0); return result; }
<|startcomment|> Is this only used for logging? <|endcomment|> public boolean doSynchronousPing() { MerlinLog.d("Pinging : " + hostAddress); try { <START> int responseCode = responseCodeFetcher.from(hostAddress); <END> MerlinLog.d("Got response : " + responseCode); } catch (RequestException e) { if (e.causedByIO()) { return false; } throw e; } return true; }
<|startcomment|> Is that bug reported? If not, it should be so we can track that it's getting fixed. Also, ensure that the bug fix should be done in a separate commit from the new feature work for elemMatch (I didn't check). <|endcomment|> public T hasThisElement(final Object val) { Assert.parametersNotNull("val", val); <START> return addCriteria(FilterOperator.ELEMENT_MATCH, val, not); <END> }
<|startcomment|> Since this class overrides the ```equals``` method, it also needs to override the ```hashCode``` method. Let me know if you have any questions on this. <|endcomment|> public Builder setSSHDirectory(final File sshDirectory) { this.sshDirectory = sshDirectory; <START> return this; <END> }
<|startcomment|> I believe you want to add result into the ``attributes`` list. Also, what if required attributes of passed services overlap? We probably should gather them into the set before returning as list. <|endcomment|> public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Facility facility, Resource resource, User user, Member member) throws InternalErrorException, MemberResourceMismatchException { List<Attribute> attributes = new ArrayList<>(); for (Service service : services) { <START> getRequiredAttributes(sess, service, facility, resource, user, member); <END> } return attributes; }
<|startcomment|> parameter sequence swapped: max, min is correct. <|endcomment|> public void zrevrangeByScoreWithScores(final byte[] key, final double max, final double min, final int offset, final int count) { <START> sendCommand(ZREVRANGEBYSCORE, key, toByteArray(min), toByteArray(max), LIMIT.raw, toByteArray(offset), <END> toByteArray(count), WITHSCORES.raw); }
<|startcomment|> `write(mSingleCharWrite)`? <|endcomment|> public void write(int b) throws IOException { mSingleCharWrite[0] = (byte) b; <START> write(mSingleCharWrite, 0, 1); <END> }
<|startcomment|> this method expects flowId, netId as parameters. Be careful with the order! <|endcomment|> public void deallocateFlow(String flowId) throws FlowNotFoundException, ProvisionerException { try { String netId = getNetworkSelector().findNetworkForFlowId(flowId); <START> getNclController().deallocateFlow(netId, flowId); <END> } catch (Exception e) { throw new ProvisionerException(e); } }
<|startcomment|> Perhaps in this case the best is to just rethrow the exception as a RuntimeException <|endcomment|> private String _encode(String strVal) { try { return URLEncoder.encode(strVal, StandardCharsets.UTF_8.toString()); } catch (UnsupportedEncodingException e) { <START> return e.getMessage(); <END> } }
<|startcomment|> if o is null, should no we just return false ? <|endcomment|> public boolean contains(Object o) { <START> boolean contains = super.contains(o); <END> if (!contains && o != null) { MarshalledEntry<K, V> me = persistenceManager.loadFromAllStores(o, true); contains = me != null; } return contains; }
<|startcomment|> The cast should not be removed to avoid compilation errors on Eclipse versions which do not have the generified getAdapter. <|endcomment|> public boolean provides(IOperation operation) { if (!(operation instanceof CreateDecoratorsOperation)) { return false; } IDecoratorTarget decoratorTarget = ((CreateDecoratorsOperation) operation).getDecoratorTarget(); <START> View view = decoratorTarget.getAdapter(View.class); <END> return view != null && DDiagramEditPart.MODEL_ID.equals(SiriusVisualIDRegistry.getModelID(view)); }
<|startcomment|> remove extra line <|endcomment|> public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert() { CuratedContentPageObject ccp = new CuratedContentPageObject(driver); wikiURL = urlBuilder.getUrlForWiki(MercuryWikis.MERCURY_CC); ccp.openMercuryArticleByNameWithNoCacheBuster(wikiURL, MercurySubpages.CC_MAIN_PAGE); MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject( driver, Mercury.AlertMessage.NOT_EXISTING_CATEGORY); <START> <END> String oldUrl = driver.getCurrentUrl(); ccp.clickOnCuratedContentElementByIndex(2); Assertion.assertTrue(mercuryAlert.isAlertMessageVisible()); ccp.waitForLoadingSpinnerToFinish(); Assertion.assertUrlEqualToCurrentUrl(driver, oldUrl); }
<|startcomment|> I would use a couple of assert equals since they give better output in case of failure. (Remember that the expected value should be the first one) <|endcomment|> private void testUpdateInterface(Guid interface_id) { VdsNetworkInterface iface = dao.get(interface_id); iface.setName(iface.getName().toUpperCase()); iface.setQos(newQos); dao.updateInterfaceForVds(iface); VdsNetworkInterface ifaced = dao.get(interface_id); <START> assertTrue(ifaced.getName().equals(iface.getName()) && ifaced.getQos().equals(iface.getQos())); <END> }
<|startcomment|> Shouldn't this be done before the patientProgram is saved, instead of after? <|endcomment|> public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException { if (patientProgram.getPatientProgramId() == null) { sessionFactory.getCurrentSession().save(patientProgram); } else { sessionFactory.getCurrentSession().merge(patientProgram); } <START> CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram); <END> return patientProgram; }
<|startcomment|> Does `unwrapApi` not work for some reason? Just curious...it would make a nice example of the new call, that's why I ask... <|endcomment|> public UploadDirectoryToCDN(String username, String apiKey) { Iterable<Module> modules = ImmutableSet.<Module> of(new SLF4JLoggingModule()); BlobStoreContext context = ContextBuilder.newBuilder(PROVIDER) .credentials(username, apiKey) .modules(modules) .buildView(BlobStoreContext.class); storage = context.getBlobStore(); <START> rackspace = context.unwrap(CloudFilesApiMetadata.CONTEXT_TOKEN).getApi(); <END> }
<|startcomment|> The `forServer == false` flow looks wrong. If `null` is passed, then `KeyManagerFactoryWrapper` will throw (and we probably want the `keyManagerFactory` to be `null` in that case). <|endcomment|> public SslContextBuilder keyManager(KeyManager keyManager) { <START> if (forServer) { <END> checkNotNull(keyManager, "keyManager required for servers"); } this.keyManagerFactory = new KeyManagerFactoryWrapper(keyManager); keyCertChain = null; key = null; keyPassword = null; return this; }
<|startcomment|> Should this be protected, or do we really want to allow to call it outside this class? <|endcomment|> <START> public boolean isTypeSupported(Class<T> clazz) { <END> // TODO: Add other types? Float, etc if (String.class.isAssignableFrom(clazz) || Integer.class.isAssignableFrom(clazz) || Boolean.class.isAssignableFrom(clazz)) { return true; } return false; }
<|startcomment|> Replace Boris? <|endcomment|> private List<Person> createModel() { List<Person> elements = new ArrayList<Person>(4); elements.add(new Person("Tom", "Schindl", "tom.schindl@bestsolution.at")); elements.add(new Person("Boris", "Bokowski", <START> "Boris_Bokowski@ca.ibm.com")); <END> elements.add(new Person("Tod", "Creasey", "Tod_Creasey@ca.ibm.com")); elements.add(new Person("Wayne", "Beaton", "wayne@eclipse.org")); return elements; }
<|startcomment|> maybe better to separate the incerement and then check <|endcomment|> protected void updateIteration() { <START> refreshIteration = refreshIteration++ % NUMBER_VMS_REFRESHES_BEFORE_SAVE; <END> }
<|startcomment|> you can do fListeners.forEach() directly on Collections <|endcomment|> public void add(E newInterval) { super.add(newInterval); <START> fListeners.stream().forEach(l -> l.elementAdded(this, newInterval)); <END> }
<|startcomment|> `new ArrayList<String>();` -> `new ArrayList<>();` <|endcomment|> public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) { this.docsToCheckAndEvents = docsToCheckAndEvents; <START> List<String> docs = new ArrayList<String>(); <END> docs.addAll(docsToCheckAndEvents.keySet()); setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs); }
<|startcomment|> alias variable is redundant <|endcomment|> private static String getTestingAlias(GoImportSpec testingImportSpec) { String alias = GoConstants.TESTING_PATH; <START> if (testingImportSpec != null) { <END> alias = !testingImportSpec.isDot() ? StringUtil.notNullize(testingImportSpec.getAlias(), GoConstants.TESTING_PATH) : ""; } return alias; }
<|startcomment|> This should be using `super(source);` instead of the populate method (I know it was like this in `ComplianceStatusDTO`, and it is wrong there too). <|endcomment|> public SystemPurposeComplianceStatusDTO(SystemPurposeComplianceStatusDTO source) { <START> this.populate(source); <END> }
<|startcomment|> We create a new map-operation for every call, so moving `evictions` here doesn't make any difference. <|endcomment|> public MapOperation() { final ILogger logger = this.logger(); final int forcedEvictionRetryCount = getRetryCount(); evictions = new Eviction[]{ new RecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new PartitionRecordStoreForcedEviction(forcedEvictionRetryCount, logger, this), new AllEntriesEviction(logger, this), <START> new PartitionAllEntriesEviction(logger, this) <END> }; }
<|startcomment|> We do not use single line if-statements throughout the project. Yes it's a nitty point, but I'd prefer you change it to curly braces. <|endcomment|> private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) { Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP); <START> if (timestamp instanceof String) return Instant.parse(timestamp.toString()); <END> return Instant.ofEpochMilli((long) timestamp); }
<|startcomment|> Do all of these getters need to be public ? I think except `getBytesInMemory()`, others can be default package access. <|endcomment|> <START> public AggregatorFactory[] getMetrics() <END> { return metrics; }
<|startcomment|> ```suggestion ``` Please don't add tables that are not used. Wastes CPU cycles. <|endcomment|> public void prepare() throws IOException { e = SQLExecutor.builder(clusterService) <START> .enableDefaultTables() <END> .addTable("create table t (" + " id integer primary key," + " qty integer constraint check_qty_gt_zero check (qty > 0)," + " constraint check_id_ge_zero check (id >= 0)" + ")") .build(); plannerContext = e.getPlannerContext(clusterService.state()); }
<|startcomment|> In JUnit4-style tests, you can assign variables where they are defined (and make them final if you want :-). JUnit4 won't create an instance of the class until just before it is run, and it will make it eligible for garbage collection right after it is run. <|endcomment|> public void setUp() { <START> jUnitCore = new JUnitCore(); <END> testListener = new TestListener(); jUnitCore.addListener(testListener); }
<|startcomment|> I tend to agree. I mean the validator should not be used in other places, as its name indicates, but several times we extended the use of validators in the past so it may be the better approach to simplify its instantiation <|endcomment|> protected boolean validate() { if (!canRunActionOnNonManagedVm()) { return false; } if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) { addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE); return false; } <START> ChangeVmClusterValidator validator = Injector.injectMembers(new ChangeVmClusterValidator(this, <END> getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion(), getVmDeviceUtils())); return validator.validate(); }
<|startcomment|> I would prefer this code to be done in the `KeyStoreHelper` constructor and keep a `Map<String, TrustManagerFactory >` so can be detected at this moment and this is also like how we do for the SNI key manager mapping. <|endcomment|> public TrustManagerFactory getTrustMgr(String serverName) { try { <START> KeyStore trustStore = trustMgrMap.get(serverName); <END> if (trustStore != null) { TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); fact.init(trustStore); return fact; } return null; } catch (NoSuchAlgorithmException | KeyStoreException e) { throw new RuntimeException(e); } }
<|startcomment|> I suggest putting this into a finally block. <|endcomment|> public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) { boolean tmp = this.isInModuleInfo; this.isInModuleInfo = true; TextEdit edit = format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator); <START> this.isInModuleInfo = tmp; <END> return edit; }
<|startcomment|> Should this become a property? <|endcomment|> public <K, V> RemoteCache<K, V> getCache(String cacheName) { <START> RemoteCache<K,V> cache = hotrodClient.getCache( cacheName, TransactionMode.NONE ); <END> if ( cache == null ) { throw log.expectedCachesNotDefined( Collections.singleton( cacheName ) ); } return cache; }
<|startcomment|> do we allow `type == null`? It doesn't make sense to me to take a value without type info. probably add a precondition check to forbid that. <|endcomment|> public static Object valueForStringWithType(String value, VoltType type) { <START> if (type == null || type == VoltType.NULL) { <END> return null; } // leverage existing (rather heavyweight) code to convert param types Object retval = ParameterConverter.tryToMakeCompatible(type.classFromType(), value); // check the result type in an assert assert(ParameterConverter.verifyParameterConversion(retval, type.classFromType())); return retval; }
<|startcomment|> doppelt? <|endcomment|> public void testContructor() throws IOException { String code = "S2020-04-04"; ReportingPeriod period = ReportingPeriod.from(code); assertEquals(period.getClass(), SinceX.class); <START> assertEquals(period.getClass(), SinceX.class); <END> }
<|startcomment|> please user assertEquals <|endcomment|> public void testGetConnectableFileStorageConnectionsByStorageType() { List<StorageServerConnections> conns = dao.getConnectableStorageConnectionsByStorageType(FixturesTool.STORAGE_POOL_NFS_2, StorageType.NFS); assertNotNull(conns); assertEquals(1, conns.size()); for (StorageServerConnections conn : conns) { <START> assertTrue(conn.getstorage_type() == StorageType.NFS); <END> } }
<|startcomment|> path <|endcomment|> public static void setOverrideFileName(String... path) { fOverridePath = <START> (path == null) ? null : path; <END> fOverride = true; }
<|startcomment|> Small style nit: We don't use braces around simple statements. <|endcomment|> void addChanges(Collection<String> filesToUpdate, Collection<IResource> resourcesToUpdate) { synchronized (lock) { files.addAll(filesToUpdate); resources.addAll(resourcesToUpdate); } <START> if (!filesToUpdate.isEmpty()) { <END> schedule(defaultDelay); } }
<|startcomment|> Why not use name as the key in CACHED_ENCRYPTION_KEYS? <|endcomment|> public static synchronized String getEncryptionKey(String name) { <START> final String keyString = getUniqueId(name); <END> if (CACHED_ENCRYPTION_KEYS.get(keyString) == null) { generateEncryptionKey(keyString); } return CACHED_ENCRYPTION_KEYS.get(keyString); }
<|startcomment|> That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead. <|endcomment|> public void init(IEditorSite site, IEditorInput input) { super.init(site, input); TaskData taskData = getModel().getTaskData(); if (taskData != null) { GerritChange change = GerritUtil.getChange(taskData); final ChangeDetailX detail = change.getChangeDetail(); try { review = GerritUtil.toReview(detail); } catch (GerritException e) { <START> throw new RuntimeException(e); <END> } } }
<|startcomment|> This will create a new object every time the method is called. Is this wanted? If not it'd be better to store the object once and always return it (static field). <|endcomment|> public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { <START> return new SnapshotInfo(EMPTY_STRING); <END> }
<|startcomment|> headSet(Object,boolean) is a Java 6 API. We need to define cutOff as super.getEntryLastModified() - 1 instead. <|endcomment|> public long getEntryLastModified() { if (modTimes == null) return 0; Long cutOff = Long.valueOf(super.getEntryLastModified()); <START> SortedSet<Long> head = modTimes.headSet(cutOff, true); <END> return head.isEmpty() ? 0 : head.last().longValue(); }
<|startcomment|> Initialization of the list should use generics. For this case, you can specify an empty generic-type placeholder and the compiler should be able to auto-detect what type should be used. <|endcomment|> public ParameterizedSqlFactory(String initialSql) { sqlStringBuilder = new StringBuilder(initialSql); <START> parameters = new ArrayList(); <END> }
<|startcomment|> Is this needed? What throws NumberFormatException? <|endcomment|> public long getReadyTimestamp(Constraints viewConstraints) { String normalizedConstraints = getNormalizedConstraints(viewConstraints); Path signalPath = new Path(signalDirectory, normalizedConstraints); // check if the signal exists try { try { FileStatus signalStatus = rootFileSystem.getFileStatus(signalPath); return signalStatus.getModificationTime(); } catch (final FileNotFoundException ex) { // empty, will be thrown when the signal path doesn't exist } return -1; <START> } catch (NumberFormatException e) { <END> throw new DatasetException("Signal contents were modified to not be a number: " + signalPath, e); } catch (IOException e) { throw new DatasetIOException("Could not access signal path: " + signalPath, e); } }
<|startcomment|> Use equals instead of '==' as follows (And do the same for the 2 other conditions): ArchitectureType.ppc64.equals(archType); <|endcomment|> private boolean hostHasPpcArchitecture() { Cluster cluster = getModel().getSelectedCluster(); if (cluster == null) { return false; } ArchitectureType archType = cluster.getArchitecture(); return <START> (archType == ArchitectureType.ppc64) || <END> (archType == ArchitectureType.ppc64le) || (archType == ArchitectureType.ppcle); }
<|startcomment|> name.substring(ext) is equivalent and shorter to write. <|endcomment|> private static String getExtension(String name) { int ext = name.lastIndexOf('.'); return 0 < ext ? <START> name.substring(ext, name.length()) : <END> ""; }
<|startcomment|> more consistent to make this a no-op like other methods <|endcomment|> public void checkpoint() { <START> throw new UnsupportedOperationException("Checkpoint is not supported in NoopJournalSystem"); <END> }
<|startcomment|> macToLong returns 'long' <|endcomment|> private void recalculateMacsCount() { if (!validate()) { setAvailableMacsCount(-1); return; } if (macRange.getMacPoolId() == null) { String from = getLeftBound().getEntity(); String to = getRightBound().getEntity(); <START> Long count <END> = MacRangeValidation.macToLong(to) - MacRangeValidation.macToLong(from) + 1; setAvailableMacsCount(count.intValue()); } }
<|startcomment|> Is this cast necessary? <|endcomment|> public void setup() { <START> buffer = (DiskBuffer) new DiskBuffer(BUFFER_DIR, maxEvents); <END> }
<|startcomment|> It would make sense to check minimum values as well. <|endcomment|> private boolean filterInvalid(Position position) { <START> return filterInvalid && !position.getValid() || position.getLatitude() > 90 || position.getLongitude() > 180; <END> }
<|startcomment|> Understood. IntelliJ does however suggest this small change: return new HashSet<Location>( asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE)); <|endcomment|> public Set<Location> getAllowedLocations() { Set<Location> allowedLocations = new HashSet<Location>(); allowedLocations.addAll(Arrays.asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE)); <START> return allowedLocations; <END> }
<|startcomment|> getTaskJsonString() 是否可以改成 static method <|endcomment|> public String getTasksJsonString(long taskId) throws JSONException { TaskObject task = TaskObject.get(taskId); <START> return new ConvertSprintBacklog().getTaskJsonString(task); <END> }
<|startcomment|> no need explicitly open transaction, only one save to DB, transaction will be open automaticly <|endcomment|> <START> private void addVolumeToDb(final GlusterVolumeEntity createdVolume) { <END> TransactionSupport.executeInNewTransaction( new TransactionMethod<Void>() { @Override public Void runInTransaction() { // volume fetched from VDSM doesn't contain cluster id GlusterFS // is not aware of multiple clusters createdVolume.setClusterId(getVdsGroupId()); DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume); return null; } }); }
<|startcomment|> It seems this have added a new import: org.jfree.util.Log, why not use the same log object as line 204? log.error("Workbook creation exception", e); ? Is there a reason behind using 2 different ways of logging errors? <|endcomment|> public Sheet getDataSheet(File file) { stream = new PushbackInputStream(new FileInputStream(file)); Workbook wb = null; try { wb = WorkbookFactory.create(stream); } catch (Exception e) { <START> Log.error("Workbook creation exception:" + e); <END> } return wb.getSheetAt(0); }
<|startcomment|> That's not much different than the current `getProcess(int processID)` except with an optional rather than null. (And the API for that is fixed so we can't change it.) That's not the problem I'm discussing... the problem is that someone writing `new OSProcess(1234)` will definitely get a Process object unless we throw an exception. We could throw an `InstantiationError`, for example, and require them to handle it. Or a `MissingResourceException`. Or return a class with the pid and essentially zero data. Perhaps I should have thought about this dilemma before suggesting the feature! <|endcomment|> public void updateAttributes() { OperatingSystem operatingSystem = getCurrentOperatingSystem(); if (operatingSystem != null) { OSProcess process = operatingSystem.getProcess(this.processID); if (process != null) { copyValuesToThisProcess(process); } else { <START> LOG.error("No process found: {}", this.processID); <END> } } else { LOG.error("Unsupported platform. No update performed."); } }
<|startcomment|> avoid using this in these cases. <|endcomment|> public boolean isMissingHookConflict() { <START> return (this.conflictStatus & MISSING_HOOK.getValue()) == MISSING_HOOK.getValue(); <END> }
<|startcomment|> Nit: My pref would be to eliminate the unneeded elses (117,120) since there are returns. <|endcomment|> public Map<AccountGroup.UUID, GroupMembersList> getUnresolvedGroups( final boolean recursive) { if (!recursive) { if (isResolved()) { return Collections.emptyMap(); <START> } else { <END> return Collections.singletonMap(getGroup().getGroupUUID(), this); } } else { return getAllUnresolvedGroups(new HashSet<AccountGroup.Id>()); } }
<|startcomment|> Can you use `parser.getCurrentToken()` to detect JSON type ? <|endcomment|> public boolean nextBoolean() throws IOException { requirePeek(); boolean value; try { <START> value = parser.getBooleanValue(); <END> } catch (JsonParseException e) { value = Boolean.parseBoolean(parser.getValueAsString()); } clearPeek(); return value; }
<|startcomment|> why are all methods public except this one ? <|endcomment|> <START> boolean closeOnProtocolViolation() { <END> return closeOnProtocolViolation; }
<|startcomment|> This should be done using the EnumTranslator. For example, see VmGeneralModel - > updateProperties(). In addition, add the appropriate values to LocalizedEnums.java an LocalizedEnums.properties. <|endcomment|> <START> public String getSelinuxEnforceMode() { <END> if (selinuxEnforceMode == null) { // Nothing } else if (selinuxEnforceMode.equals(SELinuxMode.DISABLED)) { return constants.disabled(); } else if (selinuxEnforceMode.equals(SELinuxMode.PERMISSIVE)) { return constants.permissive(); } else if (selinuxEnforceMode .equals(SELinuxMode.ENFORCING)) { return constants.enforcing(); } return constants.notAvailableLabel(); }
<|startcomment|> Sounds like you forgot to remove this one <|endcomment|> public void startThreads() { <START> if (!this.threadStarted) { <END> synchronized (this) { if (!this.threadStarted) { int nbThreads = this.configuration.getProperty("mentions.poolSize", 1); for (int i = 0; i < nbThreads; i++) { startConsumer(); } this.threadStarted = true; } } } }
<|startcomment|> Why do you perform this test on FeaturesProvider's class? This really looks strange and I do not see how this relates to the goal of this commit... <|endcomment|> public void init(EObject original, EditingDomain editingDomain) { List<EStructuralFeature> features = featuresProvider .getFeatures(original); initControlFactory(editingDomain, original); for (final EStructuralFeature feature : features) { <START> if(!featuresProvider.getClass().equals(FeaturesProvider.class) || isToBeRendered(feature) ){ <END> createControlForFeature(feature); } } // toolkit.paintBordersFor(main); this.layout(); }
<|startcomment|> I think you can return Arrays.asList(...) directly, no need to create wrap that in ArrayList. <|endcomment|> public List<Annotation> getQualifiers() { return new ArrayList<Annotation>( <START> Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() { <END> @Override public Class<? extends Annotation> annotationType () { return org.jboss.arquillian.warp.servlet.AfterServlet.class; } } ) ); }
<|startcomment|> It should not be necessary to crate the RemoteCacheManager in a PrivligedAction. Only the GSSAPI mech requires a Subject to initialize the SASL client, and that should be passed in by the configuration <|endcomment|> protected void initialize(Subject subj) throws PrivilegedActionException { final Configuration config = getRemoteCacheManagerConfig(subj); <START> Subject.doAs(subj, new PrivilegedExceptionAction<Void>() { <END> public Void run() throws Exception { remoteCacheManager = new RemoteCacheManager(config, true); return null; } }); remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME); }
<|startcomment|> Shouldn't this copy in `baseSelectors`? I know it it currently empty, but the code implies you want to add another selector to the base selectors. <|endcomment|> <START> LauncherDiscoveryRequest buildRequest(Bundle bundle) { <END> List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1); selectors.add(BundleSelector.selectBundle(bundle)); return LauncherDiscoveryRequestBuilder.request() .configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved) .selectors(selectors) .build(); }
<|startcomment|> there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to. <|endcomment|> protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) { super.statementExecuteUpdateBefore(statement,sql); <START> try { <END> Before(statement,sql); }catch (Exception e){ } }
<|startcomment|> nit: merge lines <|endcomment|> public static DecoderResult failure(Throwable cause) { ObjectUtil.checkNotNull(cause, "cause"); <START> return new DecoderResult(cause); <END> }
<|startcomment|> Why 5? Just use the default unless there's a good reason not to. <|endcomment|> private void writeObject(Schema schema, GenericRecord datum) throws Exception { <START> BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(5), null); <END> GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema); writter.write(schema, datum, encoder); }
<|startcomment|> Sorry--what I meant before was to just build and return the collection on _every_ invocation, rather than storing it in a field. There's only one place calling this method now, so the caching doesn't buy us anything. <|endcomment|> public Collection<String> getNames() { if (names == null) { <START> names = new HashSet<>(named.keySet()); <END> namedArgumentFinder.forEach(args -> names.addAll(args.getNames())); } return Collections.unmodifiableSet(names); }
<|startcomment|> Hmmm. I'm thinking we might want to turn this into a logger.warning instead. I'd use the error only if the program cannot proceed, while in this case the consumer code is responsible for reacting to a null return: this particular piece of code can cope perfectly well with it. <|endcomment|> public FBOConfig getFboConfig(ResourceUrn fboName) { FBOConfig fboConfig = fboConfigs.get(fboName); if (fboConfig == null) { <START> logger.error("Failed to retrieve FBOConfig '" + fboName + "'!"); <END> } return fboConfig; }
<|startcomment|> This is technically an API violation, although I can't find any usages. Probably an IDE recommendation? I don't think it is needed so we could swap it back to remain in compliance (to clarify see the surrounding diff since this preview gets confused) <|endcomment|> <START> void setKey(Input newInput, char newKeyChar) { <END> this.input = newInput; this.keyChar = newKeyChar; }
<|startcomment|> This doesn't seem right, the call to org.infinispan.configuration.cache.EvictionConfigurationBuilder#strategy(org.infinispan.eviction.EvictionStrategy) is missing completely, thus the default strategy will always be NONE. <|endcomment|> public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException { EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class); if (strategy.isEnabled()) { this.builder.type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong()); <START> } <END> return this; }
<|startcomment|> `CompletableFuture<Boolean>` to avoid raw types <|endcomment|> public void closed( BoltConnection connection ) { String id = connection.id(); try { <START> CompletableFuture currentFuture = activeWorkItems.remove( id ); <END> if ( currentFuture != null ) { currentFuture.cancel( true ); } } finally { activeConnections.remove( id ); } }
<|startcomment|> https://i0.wp.com/100happybirthdaymemes.com/wp-content/uploads/2016/06/grumpy-cat-no-4.jpg In other words: throw the exception upwards and fail the test if parsing the XML fails. <|endcomment|> public void testIsExternalVM() throws IOException { try { XmlDocument xmlDocument = new XmlDocument(getXmlOvfData()); assertFalse("VM should not be external VM", OvfUtils.isExternalVM(xmlDocument)); <START> } catch (Exception e) { e.printStackTrace(); } <END> }
<|startcomment|> Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files <|endcomment|> public static boolean folderContains(File folder, String filename) { if (folder == null) { return false; } if (!folder.isDirectory()) { return false; } <START> File[] fileList = folder.listFiles(); <END> if (fileList == null) { return false; } for (File f : fileList) { if (f.getName().equals(filename)) { return true; } } return false; }
<|startcomment|> `Collections.addAll(whiteListPatterns, patterns)` can be used here. <|endcomment|> public void addWhiteListPatterns(String... patterns) { <START> this.whiteListPatterns.addAll(Arrays.asList(patterns)); <END> }
<|startcomment|> I think that this check can be avoided as we already check if auth != null below <|endcomment|> private Long getRegistrationMillis(String playerName) { <START> if (!isRegistered(playerName.toLowerCase())) { <END> return null; } PlayerAuth auth = playerCache.getAuth(playerName); if (auth == null) { auth = dataSource.getAuth(playerName); } if (auth != null) { return auth.getRegistrationDate(); } return null; }
<|startcomment|> typo: capacityFactor instead of numSegments <|endcomment|> public HashConfigurationBuilder capacityFactor(float capacityFactor) { <START> if (numSegments < 0) throw new IllegalArgumentException("capacityFactor must be positive"); <END> this.capacityFactor = capacityFactor; return this; }
<|startcomment|> This is not needed here <|endcomment|> public synchronized void onHeaders(Response response) { long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString()); if (length > maxLength) { response.abort(new ResponseTooLargeException()); } <START> allocateCurrentArray(); <END> }
<|startcomment|> The return statement can never throw an exception here. So please remove the try-catch block. <|endcomment|> public WorkspaceItem build() { try { return workspaceItem; <START> } catch (Exception e) { <END> return handleException(e); } }
<|startcomment|> Why sorted map? TreeMap is sorted already?! <|endcomment|> <START> public static SortedMap<String, Charset> requiredCharsets() { <END> return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS); }
<|startcomment|> [minor] Split into two asserts or add a message showing what the offending value actually is? <|endcomment|> protected void checkProject(Project project) { assertNotNull(project.getId()); assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString()); <START> assertTrue(project.getState() != null && project.getState() != Project.State.UNRECOGNIZED); <END> }
<|startcomment|> Please call ArtifactToken constructors without guid. <|endcomment|> public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) { <START> super(id, GUID.create(), name, CoreBranches.COMMON, artifactType); <END> }
<|startcomment|> I think the deprecate is sufficient. Why also log a warning? <|endcomment|> public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) { <START> LOG.warning("Setting useBulkWriteOperations has no value functionally or performance-wise."); <END> }
<|startcomment|> When will this be false? <|endcomment|> public void setActionConfirmationMessage(String message) { boolean isNonEmptyMessage = message != null; if <START> (isNonEmptyMessage) { <END> actionConfirmationMessage.setText(message); } actionConfirmationMessage.setVisible(isNonEmptyMessage); }
<|startcomment|> the second parameter can be removed <|endcomment|> public void close() throws InterruptedException { <START> close(false, false); <END> }
<|startcomment|> This class has a member variable called `indent` which will incur a data race in `recursivelyPrint`. This is easily fixable though by just making `indent` a parameter to `recursivelyPrint`. I realize it's debug-only code. <|endcomment|> protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb) { for (int i = 0; i < indent; i++) { sb.append("\t"); } sb.append(node.toJSONString() + "\n"); indent++; if (node.getChildCount() > 0) { recursivelyPrint(node.getChild(0), sb); } <START> } <END>
<|startcomment|> if condition not needed. <|endcomment|> public void update(int inputIndex) { status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition())); <START> if (logger.isDebugEnabled()) { <END> logger.debug("BATCH_STATS, incoming {}: {}", inputIndex == 0 ? "left" : "right", getRecordBatchSizer(inputIndex)); } }
<|startcomment|> Better: nextMemberPosition < 0 <|endcomment|> private int getNextPosition() throws CoreException { <START> if (nextMemberPosition == -1) { <END> nextMemberPosition = 0; while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) { nextMemberPosition++; } } return nextMemberPosition; }
<|startcomment|> nit: make `bulkRequest.numberOfActions()` a Supplier so it is only called if trace logging is enabled. ```suggestion logger.trace("[{}] ES API CALL: bulk request with {} actions", () -> jobId, () -> bulkRequest.numberOfActions()); ``` <|endcomment|> public BulkResponse executeRequest() { if (bulkRequest.numberOfActions() == 0) { return null; } <START> logger.trace("[{}] ES API CALL: bulk request with {} actions", jobId, bulkRequest.numberOfActions()); <END> BulkResponse bulkResponse = resultsPersisterService.bulkIndexWithRetry( bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, "Bulk indexing of annotations failed " + msg)); bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME); return bulkResponse; }
<|startcomment|> isn't the iterator() excluding the expired and Tombstones? <|endcomment|> public int size() { int size = 0; // We have to loop through to make sure to remove expired entries for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) { <START> if (iter.next().getValue() == null) continue; <END> if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE; } return size; }
<|startcomment|> I'd prefer the old order so when Environment.getExternalStorageState() return null we don't get an NPE. <|endcomment|> public static File getDiskCacheDir(Context context, String uniqueName) { // Check if media is mounted or storage is built-in, if so, try and use external cache dir // otherwise use internal cache dir. final String cachePath; <START> if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) <END> && context.getExternalCacheDir() != null) { cachePath = context.getExternalCacheDir().getPath(); } else { cachePath = context.getCacheDir().getPath(); } return new File(cachePath + File.separator + uniqueName); }
<|startcomment|> mark this method private as this is only used in this class. <|endcomment|> <START> String getBucketName(URI uri) <END> { if (uri.getHost() != null) { return uri.getHost(); } else if (uri.getUserInfo() == null) { return uri.getAuthority(); } throw new IllegalArgumentException("Unable to determine S3 bucket from URI."); }
<|startcomment|> I think we could make this initialization more terse if we initialize `MustacheResolver` with the ternary operator and pass it to `DefaultMustacheFactory`. ```java new DefaultMustacheFactory(fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) : new PerClassMustacheResolver(key)) ``` <|endcomment|> private MustacheFactory createNewMustacheFactory(Class<? extends View> key) { <START> return (fileRoot != null) ? new DefaultMustacheFactory(new FileSystemResolver(fileRoot)) <END> : new DefaultMustacheFactory(new PerClassMustacheResolver(key)); }
<|startcomment|> If we're all agreed on letting users choose system protocols in the browser, then I suppose we should not have this condition. <|endcomment|> public boolean isValidValue(final Object element) { boolean result = super.isValidValue(element); if (result) { EObject eObject = EMFHelper.getEObject(element); result = (ProtocolUtils.isProtocol(eObject) && <START> !SystemElementsUtils.isSystemProtocol((Collaboration) eObject) && <END> !SystemElementsUtils.isBaseProtocol((Collaboration) eObject)); } return result; }
<|startcomment|> Very minor: consider another helper method for runOnMainSync() so we can focus on the interesting bit (loginTestTask.execute()). As a side note, executing from the main thread doesn't seem to be a requirement of "SaneAsyncTask" for whatever reason. However, it seems more proper to call execute on the main thread[0] since we think of it as a normal AsyncTask so I think we should keep it. [0] http://developer.android.com/reference/android/os/AsyncTask.html#execute(Params...) <|endcomment|> public void testLogin() throws Throwable { <START> InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() { <END> @Override public void run() { loginTestTask.execute(); } }); assertThat(completionLatch.await(), is(true)); }
<|startcomment|> We don't need to call `toString()` <|endcomment|> public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) { String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG); if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString())) log.warn("Configuration '{}' with value '{}' is deprecated and will be removed in " + "future version. Please use '{}' or another non-deprecated value.", <START> CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT.toString(), <END> ClientDnsLookup.USE_ALL_DNS_IPS); }
<|startcomment|> I would like to remove the method getStats and would like to make the aggStats static. <|endcomment|> public HdfsCopyStats(String source, File destination, boolean enableStatsFile, int maxVersionsStatsFile, boolean isFileCopy, HdfsPathInfo pathInfo) { this.sourceFile = source; this.totalBytesTransferred = 0L; this.bytesTransferredSinceLastReport = 0L; this.pathInfo = pathInfo; this.lastReportNs = System.nanoTime(); this.startTimeMS = System.currentTimeMillis(); initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy); <START> aggStats = HdfsFetcherAggStats.getStats(); <END> }
<|startcomment|> toString() is not needed here, AFAIK. <|endcomment|> private void writeAlias(VmDevice device) { writer.writeStartElement("alias"); writer.writeAttributeString("name", String.format("ua-%s", <START> device.getId().getDeviceId().toString())); <END> writer.writeEndElement(); }
<|startcomment|> You shouldn't need the checkNotNull <|endcomment|> public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) { fProvider = provider; <START> fSeries = checkNotNull(ImmutableList.copyOf(series)); <END> }
<|startcomment|> can this case be given? I mean having an entry for the given `uuid` but with no registrations? <|endcomment|> protected boolean isRegistered(final String uuid) { <START> return handlers.containsKey(uuid) && !handlers.get(uuid).isEmpty(); <END> }
<|startcomment|> @manstis can this synchronized be removed? this method is only calling the defineClass overload which is already sync'ed. <|endcomment|> <START> public synchronized Class<?> defineClass(String name, byte[] bytecode) { <END> return defineClass(name, convertClassToResourcePath(name), bytecode); }
<|startcomment|> Could we get brackets around this if {} <|endcomment|> public boolean onOptionsItemSelected(MenuItem item) { // home references the app icon if (item.getItemId() == android.R.id.home) { toggle(); // toggles the state of the sliding menu <START> if(getSlidingMenu().isMenuShowing() && menu.isAdded()) <END> setTitle(((ITitleable)menu).getTitle()); return true; } return false; }
<|startcomment|> super nit (okay to ignore): Here and below: For consistency, consider "e" rather than "ex". Typically we only use "ex" for nested catch blocks where the name "e" is already being used by the enclosing block. <|endcomment|> public static ParcelFileDescriptor fromSocket(Socket socket) { FileDescriptor fd = socket.getFileDescriptor$(); try { return fd != null ? ParcelFileDescriptor.dup(fd) : null; } catch (IOException <START> ex) { <END> throw new UncheckedIOException(ex); } }
<|startcomment|> Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ? <|endcomment|> private String getThemePrefixedPath(String path) { String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null; prefix = prefix == null ? "" : prefix.trim(); //$NON-NLS-1$ if (prefix.length() == 0) { return null; } <START> return prefix.charAt(prefix.length() - 1) == Path.SEPARATOR ? prefix + path : prefix + Path.SEPARATOR + path; <END> }
<|startcomment|> what about the null case? <|endcomment|> protected void writeString(int majorType, byte[] bytes) throws IOException { int len = (bytes == null) ? 0 : bytes.length; writeType(majorType, len); <START> m_os.write(bytes); <END> }
<|startcomment|> extra `else` statement, please remove <|endcomment|> private void checkLogData(long address, ILogData logData) { if (logData == null || logData.getType() == DataType.EMPTY) { throw new RuntimeException("Unexpected return of empty data at address " + address + " on read"); } else if (logData.isTrimmed()) { throw new TrimmedException(); } <START> } <END>
<|startcomment|> - space after comma - you need to pass the source duration as well <|endcomment|> private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) { long sourceDuration = source.getDuration(); long sourceSelfTime = source.getSelfTime(); destination.addToDuration(sourceDuration); destination.addToSelfTime(sourceSelfTime); <START> destination.fStatistics.update(source.fStatistics.getMaxSegment(),source.fStatistics.getMinSegment(), <END> sourceSelfTime); // merge the children callees. mergeChildren(destination, source); }
<|startcomment|> Think this needs to go right below line 91. `parseResponse` can return `null` (line 133), which will cause this future to never complete. <|endcomment|> @Override protected void doEnqueue(Callback<V> callback) { sendRequest().handle((response, t) -> { if (t != null) { callback.onError(t); } else { V value = null; try { value = parseResponse(response, bodyConverter); } catch (Throwable t1) { propagateIfFatal(t1); callback.onError(t1); } <START> if (value != null) callback.onSuccess(value); <END> } return null; }); }
<|startcomment|> if (!isExplicit) { // ... around the try <|endcomment|> public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) { SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel); <START> try { <END> transactionScopeManager.set(t); } catch (PersistenceException existingTransactionError) { t.end(); throw existingTransactionError; } return t; }
<|startcomment|> What about thread safety here? I might be mistaken, but by just looking at this code snippet it looks like more than one thread could check the condition, receive `false` from the `contains()` method and execute the above code block. That might be the reason the blocking `putIfAbsent` method is used here? <|endcomment|> C baseApply() { final TreeMap<String, String> t = new TreeMap<String, String>(validate()); if(!children.contains(t)) { C child = newChild(); children.put(t, child); <START> return child; <END> } else return children.get(t); }
<|startcomment|> i'd maybe just "forward" the `onConnect` to the presenter instead <|endcomment|> public void onConnect(String message) { debugView.showPermanently(getString(R.string.connected)); switchableView.setDisplayedChild(1); <START> presenter.startListeningForDirection(); <END> }
<|startcomment|> yup, this is incorrect, seems I failed somewhere, this logic has to be in `public ByteBuffer[] nioBuffers()`, gonna change it <|endcomment|> public ByteBuffer[] nioBuffers(int index, int length) { if (b1.nioBufferCount() == 1 && b2.nioBufferCount() == 1) { return new ByteBuffer[] { b1.nioBuffer(), b2.nioBuffer() }; } <START> return ObjectArrays.concat(b1.nioBuffers(), b2.nioBuffers(), ByteBuffer.class); <END> }
<|startcomment|> why the instance-level lock suggestion, vs. what's been implemented here. seems like overkill <|endcomment|> <START> public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) { <END> this.disabledAdministrativeMonitors = new CopyOnWriteArraySet<>(disabledAdministrativeMonitors); }
<|startcomment|> Is this method going to be overridden in a subclass to provide a different behavior? This method can be protected if is not supposed to be overridden outside the package. <|endcomment|> <START> public boolean waitUntilReadyToProcess(Properties jobProps) { <END> return true; }
<|startcomment|> Casting to `ArrayList` is brittle. Could we return `List<>` from here instead? <|endcomment|> private ArrayList<Comment> fetchAllComments(ArticleTable article) { <START> return (ArrayList<Comment>) hibernateTemplate.find("FROM Comment WHERE articleId = ?", article.getArticleId()); <END> }
<|startcomment|> Missed this one in the previous review, needs updating as well! <|endcomment|> <START> public String getPreview() { <END> StringBuilder bld= new StringBuilder(); bld.append("\n"); if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) { bld.append("long number1 = 10L;\n"); bld.append("float number2 = 10F;\n"); bld.append("double number3 = 10D;\n"); } else { bld.append("long number1 = 10l;\n"); bld.append("float number2 = 10f;\n"); bld.append("double number3 = 10d;\n"); } return bld.toString(); }
<|startcomment|> Is this a race or corruption happens all the time? Change looks fine, but I did not understand the actual issue with the current code on why corruption happening. <|endcomment|> private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) { int size = msg.getSerializedSize(); ByteBuf buf = allocator.heapBuffer(size, size); try { <START> msg.writeTo(new ByteBufOutputStream(buf)); <END> } catch (IOException e) { // This is in-memory serialization, should not fail throw new RuntimeException(e); } // Advance writer idx buf.writerIndex(buf.capacity()); return buf; }
<|startcomment|> Is this the value we use for all other protocols? <|endcomment|> public void testEncodeOutputControl() { Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder(); Command command = new Command(); command.setDeviceId(1); command.setType(Command.TYPE_OUTPUT_CONTROL); command.set(Command.KEY_INDEX, 0); <START> command.set(Command.KEY_DATA, "1"); <END> assertEquals("(123456789012345AV001)", encoder.encodeCommand(command)); }
<|startcomment|> No `if` check needed, just always set the reference to `null`. <|endcomment|> void cancel() { super.cancel(); <START> if (callback != null) { <END> callback = null; } }
<|startcomment|> `new Error` -> `new RuntimeException` <|endcomment|> public void cancel() { try { Field field = FileWatchdog.class.getDeclaredField("interrupted"); field.setAccessible(true); field.set(this, true); } catch (ReflectiveOperationException cause) { <START> throw new Error("Cannot cancel log4j watchdog", cause); <END> } }
<|startcomment|> Very minor: it's probably cleaner just to initialized ENABLED_LANGUAGES using Arrays.asList <|endcomment|> public static boolean isEditAllowed(@NonNull PageTitle title) { return <START> Arrays.asList(ENABLED_LANGUAGES).contains(title.getWikiSite().languageCode()); <END> }
<|startcomment|> Why is this hardcoded? and why is it 1 not 0? <|endcomment|> private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException { byte[] bytes = baos.toByteArray(); baos.reset(); <START> int testMessageNo = 1; <END> PacketFormat format = new PacketFormat(testMessageNo, bytes); format.serialize(baos); return new ByteArrayInputStream(baos.toByteArray()); }
<|startcomment|> This wasn't necessary, I was using the constructor I added that defaults to battlefield because most activated abilities are on the battlefield anyway. It doesn't really matter, I just figured I'd mention it. <|endcomment|> public ShovingMatch(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, "{2}{U}"); // Until end of turn, all creatures gain "{tap}: Tap target creature." <START> Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost()); <END> ability.addTarget(new TargetCreaturePermanent()); this.getSpellAbility().addEffect( new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent()) .setText("Until end of turn, all creatures gain \"{T}: Tap target creature.\"") ); }
<|startcomment|> Use `assertEquals` <|endcomment|> public void testCompareRanges() { <START> assertTrue(compareRanges("abcdefghij".getBytes(), 0, 10, "abcdefghij".getBytes(), 0, 10) == 0); <END> assertTrue(compareRanges("123abcdefghij".getBytes(), 3, 10, "abcdefghij".getBytes(), 0, 10) == 0); }
<|startcomment|> Verificar necessidade desse else <|endcomment|> public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){ this.paymentDate = paymentDate; this.timeframe = timeframe; this.requestedAmount = requestedAmount; //??? if(build){ this.build = build; }else{ <START> this.building = build; <END> } }
<|startcomment|> unnecessary `throws` (same for the constructor above). <|endcomment|> public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode) <START> throws Exception <END> { super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables())); this.embeddedElasticsearchNode = embeddedElasticsearchNode; }
<|startcomment|> print help all the time? the command `> server` alone isn't valid. <|endcomment|> public CommandResult exec(ContextAwareCommandInvocation commandInvocation) { <START> if (help) { <END> commandInvocation.println(commandInvocation.getHelpInfo()); } return CommandResult.SUCCESS; }
<|startcomment|> .value() returns .name().toLowerCase() <|endcomment|> for (OsType type : OsType.values()) { <START> osTypeValues.add(type.value().toLowerCase()); <END> }
<|startcomment|> Why don't you change getAction() to return a Collection<ContributionItem>? <|endcomment|> private Menu fillMenu(Menu m) { for (IAction action : getActions()) { IContributionItem item; String actionText = action.getText(); if (actionText == null || actionText.isEmpty()) { item = new Separator(); } else { item = new ActionContributionItem(action); <START> } <END> item.fill(m, -1); } return m; }
<|startcomment|> In all `assert` method, the first argument is the "expected" value while the second one is the "actual" value. Can you swap them in this file to match that definition? <|endcomment|> public void testThreadNameWithoutNumberNoDemon() { <START> Assert.assertEquals(ThreadUtils.createThreadFactory(THREAD_NAME, false). <END> newThread(EMPTY_RUNNABLE).getName(), THREAD_NAME); }
<|startcomment|> ```suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType); ``` <|endcomment|> public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) { //noinspection unchecked <START> return (ModelAdaptor<T>) adaptors.get(attributeType); <END> }
<|startcomment|> If you override accountId then the parentKey is automatically a member, and this needs to only include the patchKey. <|endcomment|> public com.google.gwtorm.client.Key<?>[] members() { <START> return new com.google.gwtorm.client.Key<?>[] {accountId, patchKey}; <END> }
<|startcomment|> If it is then do what exactly? If we don't want to do anything do we need this ```if(..)``` block at all? <|endcomment|> public void init(final RuleModellerPage page) { this.page = page; if (page.plugin() instanceof BRLActionColumnPlugin) { <START> <END> } }
<|startcomment|> nit: Could you have `Override` in its own line. <|endcomment|> <START> @Override public TaskResult syncShards() { <END> return periodicShardSyncManager.start(); }
<|startcomment|> Drop this `ImmutableList.copyOf` wrapper. It reduces clarity and we do expect random-access lists here anyway. <|endcomment|> static <T> List<T> without(List<T> list, Collection<Integer> indexes) { Set<Integer> indexesSet = ImmutableSet.copyOf(indexes); return IntStream.range(0, list.size()) .filter(index -> !indexesSet.contains(index)) <START> .mapToObj(ImmutableList.copyOf(list)::get) <END> .collect(toImmutableList()); }
<|startcomment|> CacheException instanceOf RuntimeException, I guess you can simplify here. <|endcomment|> private Throwable getRealException(Throwable re) { if (re.getCause() == null) return re; Throwable cause = re.getCause(); <START> if (cause instanceof CacheException || cause instanceof RuntimeException || cause instanceof Error) <END> return getRealException(cause); else return re; }
<|startcomment|> What does this change do? <|endcomment|> public void layoutIfNecessary() { if (dirtySize != null && control != null && control instanceof Composite) { if (control.getSize().equals(dirtySize)) { <START> ((Composite) control).layout(); <END> flushChildren = false; } } dirtySize = null; }
<|startcomment|> We ususally don't put the logic in the entity class. Will be confusing that this setter has side effects: `addAttribute("blah").setNillable(true).setLabelAttribute(true)` <|endcomment|> public Attribute setLabelAttribute(Boolean isLabelAttr) { set(IS_LABEL_ATTRIBUTE, isLabelAttr); <START> if (isLabelAttr != null && isLabelAttr) <END> { setNillable(false); } return this; }
<|startcomment|> So, maybe just remove this code for now? And keep in mind it. However I remember this one: https://github.com/SpringSource/spring-integration/pull/827#issuecomment-20274110 I mean to rely just only on 'system-wide conversion service', not from endpoint. <|endcomment|> public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if (bean instanceof IntegrationEvaluationContextAware) { StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory); if (bean instanceof IntegrationObjectSupport) { ConversionService conversionService = ((IntegrationObjectSupport) bean).getConversionService(); <START> if (conversionService != null) { <END> evaluationContext.setTypeConverter(new StandardTypeConverter(conversionService)); } } ((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext); } return bean; }
<|startcomment|> I believe we shouldn't close the handle here. It will be closed in the `afterCompletion` method. I think also it will probably be ignored because the handle is still binded to the active transaction. <|endcomment|> public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X { Handle h = JdbiUtil.getHandle(jdbi); R result = callback.withHandle(h); // close if not in transaction <START> JdbiUtil.closeIfNeeded(h); <END> return result; }
<|startcomment|> In this case, shouldn't we getrid of the project parameter here (if we know the project, we shouldn't specify an extra initial path, or we should explicitly use the initial path. <|endcomment|> <START> public LanguageServerWrapper(@Nullable IProject project, @NonNull LanguageServerDefinition serverDefinition, <END> @Nullable IPath initialPath) { this.initialProject = project; this.initialPath = initialPath; this.allWatchedProjects = new HashSet<>(); this.serverDefinition = serverDefinition; this.connectedDocuments = new HashMap<>(); }
<|startcomment|> minor: would prefer that `Cloud_Replica_Keyword` comes before mount path since that would order the path from least to most granular <|endcomment|> public String getReplicaPath() { // GetRequest.Cloud_Replica_Keyword is added to avoid error on its peers. <START> return getMountPath() + File.separator + GetRequest.Cloud_Replica_Keyword + File.separator <END> + partitionId.toPathString(); }
<|startcomment|> Why can't we add this parent->children listing cache even if the parent status is not in the other map? <|endcomment|> public void addChildren(AlluxioURI path, Collection<UfsStatus> children) { UfsStatus status = mStatuses.get(path); // If this path doesn't yet exist, we can't keep track of the parent-child relationship // We can still add statuses to the cache regardless <START> if (status != null) { <END> mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children); } children.forEach(child -> { AlluxioURI childPath = path.joinUnsafe(child.getName()); addStatus(childPath, child); }); }
<|startcomment|> Pointless two level submission. `executeCallbacks()` submits each callback to itself another one time (this means that it's valuable to annotate each method in this class in which executor it's supposed to be run. Given that there are two different executors, plus "external", client code execution context (which we kind of shouldn't know where runs) <|endcomment|> private void actionCompleted(SegmentHolder segmentHolder) { switch (segmentHolder.getType()) { case LOAD: segmentsToLoad.remove(segmentHolder.getSegment()); queuedSize.addAndGet(-segmentHolder.getSegmentSize()); break; case DROP: segmentsToDrop.remove(segmentHolder.getSegment()); break; default: throw new UnsupportedOperationException(); } callBackExecutor.execute( <START> () -> executeCallbacks(segmentHolder) <END> ); }
<|startcomment|> Is `this` needed here? If not, consider dropping it. <|endcomment|> public ScheduledReporter build(MetricRegistry registry) { GraphiteReporter.Builder builder = builder(registry); <START> if ("udp".equalsIgnoreCase(this.transport)) { <END> return builder.build(new GraphiteUDP(host, port)); } else { return builder.build(new Graphite(host, port)); } }
<|startcomment|> опять копипаст) у тебя ж сверху в onConnectionClosedForUser точно такой код, И вообще если мы удаляем в onConnectionClosedForUser , то зачем еще здесь? onConnectionClosedForUser в любом случае срабатывает когда с юзером связь остаточно закрылась, <|endcomment|> public void onReceiveHangUpFromUser(QBRTCSession session, Integer userId) { setStatusForOpponent(userId, getString(R.string.text_status_hang_up)); Log.d(TAG, "onReceiveHangUpFromUser userId= " + userId); if (!isPeerToPeerCall) { if (userId == userIDFullScreen) { Log.d(TAG, "setAnotherUserToFullScreen call userId= " + userId); setAnotherUserToFullScreen(); } <START> if (videoTrackMap != null && videoTrackMap.containsKey(userId)) { <END> Log.d(TAG, "onReceiveHangUpFromUser videoTrackMap.remove(userId)= " + userId); videoTrackMap.remove(userId); } } }
<|startcomment|> useless parentheses <|endcomment|> private boolean isThis(ExpressionTree expression) { <START> ExpressionTree expressionNoParenthesis = (ExpressionUtils.skipParentheses(expression)); <END> if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) { String targetName = ((IdentifierTree) expressionNoParenthesis).name(); return "this".equals(targetName); } return false; }
<|startcomment|> `Queue::getActualName` ? <|endcomment|> protected Map<String, Queue> getQueueNamesToQueues() { return this.queues.stream() <START> .collect(Collectors.toMap(q -> q.getActualName(), q -> q)); <END> }
<|startcomment|> Using String.valueOf(myBundle.getBundleId()) would make more sense than .valueOf.toString <|endcomment|> public String toString() { Bundle myBundle = getBundle(); if (myBundle == null) return ""; //$NON-NLS-1$ String name = myBundle.getSymbolicName(); <START> return name == null ? Long.valueOf(myBundle.getBundleId()).toString() : name; <END> }
<|startcomment|> The test on the "else" case isn't needed -- if it's anything but a TextSelection the text can be set to the emprty string. <|endcomment|> public void workbenchSelectionChanged(ISelection selection) { Object o = SelectionUtils.getSelectedObject(selection); if (o instanceof TextSelection) { String text = ((TextSelection) o).getText(); m_sourceGraphControl.setSourceText(text); <START> } else if (o == null) { <END> m_sourceGraphControl.setSourceText(""); //$NON-NLS-1$ } }
<|startcomment|> This could be private if you move the field creation to the holder as i suggested. <|endcomment|> <START> public JBlock getOnDestroyViewAfterSuperBlock() { <END> if (onDestroyViewAfterSuperBlock == null) { setContentViewRelatedMethods(); } return onDestroyViewAfterSuperBlock; }
<|startcomment|> Use isEmpty() to check whether the collection is empty or not. <|endcomment|> public boolean hasChildren(Object element) { <START> return ((MyModel) element).children.size() > 0; <END> }
<|startcomment|> I believe we can remove the `try`/`catch` wrappers. No checked Exceptions are thrown. Is there a particular Exception you are anticipating? <|endcomment|> public GroupedPropertyList getPropertyList() { if (propertyList == null) { <START> try{ <END> boolean parallel = true; long t1 = System.currentTimeMillis(); propertyList = new GroupedPropertyList(individual, vreq, editing,parallel); log.debug(" getPropertyList parallel: "+parallel+" time :"+(System.currentTimeMillis()-t1)+" ms"); }catch(Exception e) { e.printStackTrace(); } } return propertyList; }
<|startcomment|> Remove this ones <|endcomment|> private void doTheTest(UserGroup g0) { String s = MARSHALER.marshal(g0); UserGroup ug = MARSHALER.unmarshal(s); <START> System.out.println(g0); <END> System.out.println(ug); System.out.println(s); assertTrue(g0.equals(ug)); }
<|startcomment|> This too would benefit from the (proposed) `ConstraintType.EMPTY` enumeration item. <|endcomment|> String getConstraintType() { final ConstraintType constraintType = presenter.getConstraintType(); <START> if (constraintType == null) { <END> return presenter.inferComponentType(presenter.getConstraintValue()).value(); } else { return constraintType.toString(); } }
<|startcomment|> How about WikipediaApp.getInstance() instead? <|endcomment|> private WikipediaApp getApplication() { <START> return (WikipediaApp) getPageActivity().getApplication(); <END> }
<|startcomment|> Should this be public or private? It is used only in the validator <|endcomment|> <START> public boolean isHostedEngineDirectLunDisk() { <END> return disk.getDiskStorageType() == DiskStorageType.LUN && StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias()); }
<|startcomment|> Same here, JavaDocs for this method please <|endcomment|> <START> public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest, <END> UUID collectionId, @Nullable Pageable optionalPageable, Projection projection) { try { Context context = obtainContext(); Collection collection = collectionService.find(context, collectionId); Community parentCommunity = (Community) collectionService.getParentObject(context, collection); if (collection == null) { throw new ResourceNotFoundException("No such collection: " + collectionId); } return converter.toRest(parentCommunity, projection); } catch (SQLException e) { throw new RuntimeException(e); } }
<|startcomment|> Immutable <|endcomment|> public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException, DotSecurityException { <START> List<WorkflowAction> actions = new ArrayList<>(); <END> for(WorkflowStep step : steps) { actions.addAll(workFlowFactory.findActions(step)); } actions = APILocator.getPermissionAPI().filterCollection(actions, PermissionAPI.PERMISSION_USE, true, user); return actions; }
<|startcomment|> This code raises two more (previously existing) concerns: 1. Which iconURI has higher priority the descriptor or the part? 2. What happens if the iconURI of the descriptor is changed? <|endcomment|> private String updateIconUri(MPart part) { MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId()); <START> String iconURI = desc != null && desc.getIconURI() != null ? desc.getIconURI() : part.getIconURI(); <END> part.getTransientData().put(ICON_URI_FOR_PART, iconURI); return iconURI; }
<|startcomment|> This will throw redundancy warnings in IntelliJ <|endcomment|> private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){ //Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes //Provide the attribute name as key, and a pair of returntype (Class) and a Object to be used as test value Map<String, Pair<Class, Object>> map = new HashMap<>(); <START> return map; <END> }
<|startcomment|> why is it public? <|endcomment|> <START> public String getParentId(String testId) { <END> return (String) getHibernateTemplate().find("select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?", testId, sessionId).get(0); }
<|startcomment|> Why can't you just return diskList? If I'm not mistaken DbFacade does not return null lists, only empty <|endcomment|> protected void executeQueryCommand() { List<Disk> diskList = DbFacade.getInstance() .getDiskDao() .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered()); if (CollectionUtils.isEmpty(diskList)) { <START> setReturnValue(new ArrayList<>()); <END> return; } setReturnValue(filterDisks(diskList)); }
<|startcomment|> Oh, is this why we don't need thread-safety on filter hashcode methods i guess? This seems kind of a funny way to prime them with the cached values, I think maybe the supplier.memoize pattern would be a little cleaner and make this not necessary? <|endcomment|> public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent( Filter filter, List<JoinableClause> clauses, VirtualColumns virtualColumns ) { // Some filters have potentially expensive hash codes that are lazily computed and cached. // We call hashCode() here in a synchronized block before we attempt to use the Filter in the analyses map, // to ensure that the hashCode is only computed once per Filter since the Filter interface is not thread-safe. synchronized (analyses) { if (filter != null) { <START> filter.hashCode(); <END> } } JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns); return analyses.computeIfAbsent( key, (groupKey) -> { return JoinFilterAnalyzer.computeJoinFilterPreAnalysis( JoinableClauses.fromList(clauses), virtualColumns, filter, joinFilterRewriteConfig ); } ); }
<|startcomment|> there is already a constr, which takes (id,groupId,resource, dataSource,interval) Can we use that in indexTask, instead of adding a new one ? <|endcomment|> protected AbstractFixedIntervalTask( String id, <START> TaskResource taskResource, <END> String dataSource, Interval interval ) { this(id, id, taskResource, dataSource, interval); }
<|startcomment|> You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation <|endcomment|> private Object[][] finderSupportedResourceTypeData() { return new Object[][] <START> { <END> { FinderSupportedAssociationDataResource.class }, { FinderSupportedComplexKeyDataResource.class }, { FinderWithActionResource.class } }; }
<|startcomment|> We actually don't need this line at all. The test check something else <|endcomment|> public void addNotEmptyIdConnection() { StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30"); newPosixConnection.setId(Guid.newGuid().toString()); parameters.setStorageServerConnection(newPosixConnection); parameters.setVdsId(Guid.Empty); <START> doReturn(newPosixConnection.getId()).when(command).isConnWithSameDetailsExists(newPosixConnection, null); <END> ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY); }
<|startcomment|> I think if it's not visible, click should fail, so is the assertion needed? <|endcomment|> public void mercury_topbar_wikiaLogoRedirectsToFandomPage() { TopBar topBar = new ArticlePage() .open(MercurySubpages.MAIN_PAGE) .getTopBar(); <START> Assertion.assertTrue(topBar.isLogoVisible()); <END> topBar.clickWikiaLogo(); Assertion.assertTrue(topBar.getCurrentUrl().contains("www.wikia.com/fandom")); }
<|startcomment|> Should this be initialized in a static / thread-safe context? <|endcomment|> private ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{ String url = oProxyHelper.getAdapterEndPointFromConnectionManager(DirectConfigConstants.DIRECT_CONFIG_SERVICE_NAME); if(cfService == null) { <START> cfService = new ConfigurationServiceImplService(new URL(url+"?wsdl")); <END> } return cfService; }
<|startcomment|> This is a minor detail but the the assertZZZ methods work like this assertZZZ(expected, actual), this is valid for the whole of your test files. Also please format the file as some "," have no space after them. <|endcomment|> void testDtoListResponses() { FlowJsonObjectReader reader = new FlowJsonObjectReader(); TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {}; List<SurveyGroupDto> surveyList = null; try { surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference); } catch (IOException e) { // } assertNotEquals(surveyList, null); assertEquals(surveyList.size(), 1); <START> assertEquals(surveyList.get(0).getName(),"1.10.36 all questions"); <END> }
<|startcomment|> We should replace null columns with all_columns before verification or we will get exception. You have changed initial order of statements. <|endcomment|> public GroupScan clone(List<SchemaPath> columns) { <START> HBaseUtils.verifyColumns(columns, hTableDesc); <END> HBaseGroupScan newScan = new HBaseGroupScan(this); newScan.columns = columns == null ? ALL_COLUMNS : columns; return newScan; }
<|startcomment|> Can be private method. <|endcomment|> <START> static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) { <END> return t -> Result.failure( "Not yet implemented: " + Optional.ofNullable(t) .map(o -> o.getClass().getCanonicalName()) .orElse("null -- expected " + expectedClass.getCanonicalName())); }
<|startcomment|> hmm, I don't think this can get build pass. <|endcomment|> private void rematchAllNetworksAndRequests() { // TODO: This may be slow, and should be optimized. final long now = SystemClock.elapsedRealtime(); final NetworkReassignment changes = computeNetworkReassignment(); if (VDBG || DDBG) log(changes.toString()); applyNetworkReassignment(changes, <START> oldDefaultNetwork, now); <END> }
<|startcomment|> wdyt if we replace it by ` return Objects.requireNonNullElse(scroller, DEFAULT_SCROLLER)` if you agree you will have some adaptation on 10.10 (java 8) <|endcomment|> public String getScroller() { <START> return scroller == null ? DEFAULT_SCROLLER : scroller; <END> }
<|startcomment|> Nit: unnecessary this. <|endcomment|> public String getMessage(){ <START> return this.message; <END> }
<|startcomment|> no need for `.toString()` <|endcomment|> public Type convertReadValueToType(String pvReadValue) { Type lvType = convertReadValueToUnmodifiedType(pvReadValue); for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) { logger.debug("type of {} before modifier:{} type={}", getDevicePropertyPath(), <START> lvTypeModifier.getModifierName(), lvType.toString()); <END> lvType = lvTypeModifier.modify4Read(lvType); logger.debug("type of {} after modifier:{} type={}", getDevicePropertyPath(), lvTypeModifier.getModifierName(), lvType.toString()); } return lvType; }
<|startcomment|> this should be synchronized as well <|endcomment|> <START> public void clear() { <END> this.domainsVisibility.clear(); }
<|startcomment|> Since you are at it, can you please change this to `long` primitive type? :) <|endcomment|> public static Comment newComment(long issueId, int newCommentId, String comment) { DateTime now = DateTime.now(); <START> Long id = Long.parseLong(issueId + "0" + newCommentId); <END> URI selfUri = URI.create(TEST_JIRA_URL + "/rest/api/latest/issue/" + issueId + "/comment"); return new Comment(selfUri, comment, null, null, now, null, null, id); }
<|startcomment|> I don't think this works. We're swapping out `context` with a different instance. We should probably use a constant as a monitor. <|endcomment|> private void registerGlueCodeScope(ConfigurableApplicationContext context) { do { <START> synchronized (context) { <END> context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope()); context = (ConfigurableApplicationContext) context.getParent(); } } while (context != null); }
<|startcomment|> This line will actually return a substring of length maxLength + 1. If the substring indeed needs to be no longer than maxLength, then replace "maxLength + 1" with just "maxLength". <|endcomment|> private String truncateMessageLength(String message, int maxLength) { if (message.length() > maxLength) { <START> message = message.substring(0, maxLength + 1); <END> } return message; }
<|startcomment|> double `;` <|endcomment|> public void testErrorReceived() { TestObserver<Object> ts = new TestObserver<Object>(); TestException ex = new TestException("boo"); Flowable.error(ex).ignoreElements().subscribe(ts); ts.assertNoValues(); <START> ts.assertTerminated();; <END> ts.assertError(TestException.class); ts.assertErrorMessage("boo"); }
<|startcomment|> unnecessary linebreak <|endcomment|> public boolean select(Viewer viewer, Object parentElement, <START> Object element) { <END> if (!(element instanceof DisplayItem)) { return false; } if (actionSet == null) { return false; } return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet); }
<|startcomment|> Why not just bump it up to `180` across the board? <|endcomment|> public static void runJSTestSuite() throws InterruptedException { // FIXME Update this when we stop using ARM Emulators int timeout = Build.SUPPORTED_ABIS[0].contains("armeabi") ? 180 : 60; <START> JSTestCase.runJSTestSuite(JS_SUITE, data(), timeout); <END> }
<|startcomment|> Nit: declare as `Map` <|endcomment|> public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context) { <START> HashMap<String, String> combinedProperties = new HashMap<>(); <END> for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) { combinedProperties.putAll(sessionMatchSpec.match(context)); } return ImmutableMap.copyOf(combinedProperties); }
<|startcomment|> I thought it would be something like ``` LOG.info("Request ID: {} access from: {} principal: {} operation: {}", requestId, remoteAddress, principal, operation); ``` and ThriftAccessLogger.log would just go away <|endcomment|> public static void logAccess(Integer requestId, InetAddress remoteAddress, Principal principal, String operation) { new ThriftAccessLogger().log( String.format("Request ID: {} access from: {} principal: {} operation: {}", requestId, remoteAddress, principal, operation)); <START> } <END>
<|startcomment|> `getActiveInstance` is deprecated, please use good old `getInstance`. <|endcomment|> public static List<String> getComputerNames() { final ArrayList<String> names = new ArrayList<String>(); <START> for (Computer c : Jenkins.getActiveInstance().getComputers()) { <END> if (!c.getName().isEmpty()) { names.add(c.getName()); } } return names; }
<|startcomment|> As above, you must perform both the read and the write in the critical section, otherwise there's no guarantee of consistency. <|endcomment|> public void unbind(final String eventName, final SubscriptionEventListener listener) { validateArguments(eventName, listener); <START> final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName); <END> synchronized (lock) { if (listeners != null) { listeners.remove(listener); if (listeners.isEmpty()) { eventNameToListenerMap.remove(eventName); } } } }
<|startcomment|> If list.get(ListKey.ALL) returns a reasonable upper bounds for the size, I think that an ArrayList would likely be faster. <|endcomment|> public Iterable<AccountGroup> all() { <START> final List<AccountGroup> groups = new LinkedList<AccountGroup>(); <END> for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) { final AccountGroup group = get(groupName); if (group != null) { groups.add(group); } } return Collections.unmodifiableList(groups); }
<|startcomment|> We have a large number of tests that don't use `TestHazelcastInstanceFactory` at all and call `Hazelcast.newHazelcastInstance()` directly (in combination with `Hazelcast.shutdownAll()` / `HazelcastInstanceFactory.shutdownAll()` / `HazelcastInstanceFactory.terminateAll()`). Shouldn't those be checked as well, somehow? <|endcomment|> public void terminate(HazelcastInstance instance) { try { Address address = getNode(instance).address; terminateInstance(instance); if (isMockNetwork) { registry.removeInstance(address); } } finally { <START> TestJmxLeakHelper.checkJmxBeans(instance.getName()); <END> } }
<|startcomment|> please change to setSucceeded <|endcomment|> public void endSuccessfully() { super.endSuccessfully(); if (getParameters().getImportAsTemplate()) { Guid newTemplateId = createTemplate(); // No reason for this to happen, but checking just to make sure if (newTemplateId != null) { attachDiskToTemplate(newTemplateId); } } updateDiskStatus(ImageStatus.OK); <START> getReturnValue().setSucceeded(true); <END> }
<|startcomment|> Interesting wrapping style :) <|endcomment|> <START> void validate() { <END> // No-op, no validation required }
<|startcomment|> deliverEvents does not handle interruptions, so this is essentially a no-op if `previous` is already executing. <|endcomment|> private void scheduleImmediateDelivery() { cancelDelayedDelivery(); while (state == State.RUNNING) { DeliveryAttempt previous = immediateDelivery.get(); if (previous != null && !previous.isDone()) <START> previous.cancel(); <END> DeliveryAttempt current = new DeliveryAttempt(); if (immediateDelivery.compareAndSet(previous, current)) { current.executeNow(); return; } } }
<|startcomment|> Why do gauges get timestamp twice? <|endcomment|> private static ObjectNode handleGaugeRollup(GaugeRollup rollup) { ObjectNode rollupNode = JsonNodeFactory.instance.objectNode(); <START> rollupNode.put("timestamp", rollup.getTimestamp()); <END> SimpleNumber rollupValue = rollup.getLatestValue(); rollupNode.put("latestVal", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue()); return handleBasicRollup(rollup, rollupNode); }
<|startcomment|> this doesn't need to have the ability and effect both be optional, just the ability is fine. <|endcomment|> public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) { super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, "{3}{G}{G}"); this.subtype.add(SubType.RHINO); this.power = new MageInt(3); this.toughness = new MageInt(5); // Vigilance this.addAbility(VigilanceAbility.getInstance()); // When Garruk's Warsteed enters the battlefield, you may search your library and/or graveyard for a card named Garruk, Savage Herald, reveal it, and put it into your hand. If you search your library this way, shuffle it. <START> this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true), true)); <END> }
<|startcomment|> markDead doesn't need to be under a lock. The caller should call tryRetain() after receiving, which will either prevent markDead from having an effect, if it is called before it. <|endcomment|> private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) { lock.writeLock().lock(); try { if (cachedFileChannel.markDead()) { <START> try { <END> cachedFileChannel.fileChannel.close(); } catch (IOException e) { LOG.warn("Exception occurred in ReferenceCountedFileChannel" + " while closing channel for log file: {}", cachedFileChannel); } finally { IOUtils.close(LOG, cachedFileChannel.fileChannel); } // to guarantee the removed cachedFileChannel is what we want to remove. fileChannels.remove(logId, cachedFileChannel); } } finally { lock.writeLock().unlock(); } }
<|startcomment|> no need to declare this here, instead declare the type in line 141 <|endcomment|> private static File getDefaultFile() { <START> File netrc; <END> File home = new File(System.getProperty("user.home")); //$NON-NLS-1$ netrc = new File(home, ".netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; netrc = new File(home, "_netrc"); //$NON-NLS-1$ if (netrc.exists()) return netrc; return null; }
<|startcomment|> I can see that the method body was already synchronised. Can you instead remove the outer if (serviceContext == null)? Because i see it duplicated in the inner block. <|endcomment|> <START> static synchronized ServiceContext getServiceContext() { <END> if (serviceContext == null) { synchronized (Context.class) { if (serviceContext == null) { log.error("serviceContext is null. Creating new ServiceContext()"); serviceContext = ServiceContext.getInstance(); } } } log.trace("serviceContext: {}", serviceContext); return ServiceContext.getInstance(); }
<|startcomment|> remove this line <|endcomment|> public synchronized void activate() { <START> OTELog.getLogger("test").debug("something"); <END> listener = new Slf4jLogListener(); logService.addLogListener(listener); }
<|startcomment|> I don't understand the need of this test. We have the next one which tests serialization and deserialization if I am not wrong. Or does this tests something more than the next one ? <|endcomment|> <START> public void testDeserialization() throws Exception { <END> for (Short version : versions) { composedBlobIdAndDeserialize(version); } }
<|startcomment|> should be just return , no need for variable <|endcomment|> private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) { <START> List<VMWithPlugInfo> vmsWithPlugInfo = <END> getCallsHandler().executeReadList ("GetVmsByDiskId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_guid", id)); return vmsWithPlugInfo; }
<|startcomment|> @nykolaslima How about handling selecting db by constructor of BinaryJedis, as authentication takes place? <|endcomment|> public Jedis createResource() { <START> Jedis jedis = new Jedis(this); <END> try { jedis.select(db); } catch(JedisException e) { log.log(Level.SEVERE, "Can't select database due a Redis connection problem", e); } return jedis; }
<|startcomment|> Please keep initialization code out of the Activator class. <|endcomment|> public JSchUIConnectionManager(IRemoteServices services) { fConnMgr = (JSchConnectionManager) services.getConnectionManager(); <START> fConnMgr.setDefaultAuthenticatorFactory(new IUserAuthenticatorFactory() { <END> @Override public IUserAuthenticator createUserAuthenticator(IRemoteConnection conn) { return new RemoteAuthenticator(conn); } }); }
<|startcomment|> Nit: I think putAll is a no-op when the conf is empty, so you probably don't need to check. <|endcomment|> public BoltDeclarer addConfigurations(Map<String, Object> conf) { <START> if (conf != null && !conf.isEmpty()) { <END> component.componentConf.putAll(conf); } return this; }
<|startcomment|> Its a heavy read that bug! When you check if breakpoint applicable probably better reverse instanceof check and call. Instanceof is cheaper <|endcomment|> public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) { final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc, IBreakpointsTargetDMContext.class); IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId); for (IBreakpoint breakpoint : breakpoints) { <START> if (supportsBreakpoint(breakpoint) && breakpoint instanceof ICBreakpoint) { <END> setTargetFilter((ICBreakpoint) breakpoint, containerDmc); } } startTrackingBreakpoints(targetBpDmc, rm); }
<|startcomment|> Put this logic into GarbageInformer together with waitUntilAllTasksFinish as we discussed. <|endcomment|> protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) { // stop periodical tasks to prevent race condition rt.getGarbageInformer().stop(); // wait until all garbage decisions are sent to logUnit servers. rt.getGarbageInformer().waitUntilAllTasksFinish(); // send garbage decisions to logUnit servers <START> while (rt.getGarbageInformer().getGarbageReceivingQueue().size() > 0) { rt.getGarbageInformer().gcUnsafe(); } <END> // run compaction on LogUnit servers logUnitServer.runCompaction(); rt.getAddressSpaceView().resetCaches(); rt.getAddressSpaceView().invalidateServerCaches(); }
<|startcomment|> This addition is pointless <|endcomment|> private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException { try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) { ByteStreams.copy(from, channel); <START> return; <END> } }
<|startcomment|> Please remove that <|endcomment|> protected void setUp() throws Exception { super.setUp(); Statement stmt = con.createStatement(); /* Drop the test table if it already exists for some reason. It is not an error if it doesn't exist. */ TestUtil.createTable(con, "testtz", "col1 INTEGER, col2 TIMESTAMP"); stmt.close(); /* Generally recommended with batch updates. By default we run all tests in this test case with autoCommit disabled. */ <START> con.setAutoCommit(false); <END> }
<|startcomment|> These null checks will disappear if using a multimap <|endcomment|> public List<Currency> getCurrencyForName(final String name) { List<Currency> list = _namesToCurrency.get(name); <START> if (list == null) { <END> return new ArrayList<>(); } return _namesToCurrency.get(name); }
<|startcomment|> What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run. <|endcomment|> private static boolean parseAllowAlias(List<Option> options) { Option option = Option.findByName(options, "allow_alias"); if (option != null) { Object value = option.getValue(); <START> return value instanceof Boolean ? (Boolean) value : "true".equals(value); <END> } return false; }
<|startcomment|> Interesting approach. I guess I'd have tried to use qualifiers or the CDI alternative mechanism, but this seems the simplest. <|endcomment|> public WebArchive createDeployment() { <START> if (resourceLocal) { <END> archive.addClasses( MemberRegistrationWithResourceLocal.class, ResourceLocalResources.class ); } else { archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class ); } return archive; }
<|startcomment|> log.debug ? <|endcomment|> private StorageDomain recoverStorageDomain(String sdUUID) { <START> log.info("about to recover SD {}", sdUUID); <END> StorageDomain storageDomain = new StorageDomain(); storageDomain.setId(sdUUID); updateStorageDomain(storageDomain); return storageDomain; }
<|startcomment|> We'll need the second usage of consumer.getId() replaced with consumer.getUuid() as well. <|endcomment|> public Event complianceCreated(Consumer consumer, Set<Entitlement> entitlements, ComplianceStatus compliance) { return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE, consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(), <START> consumer.getId(), null, buildComplianceDataJson(consumer, entitlements, compliance), null, <END> null); }
<|startcomment|> Use StringBuilder please. <|endcomment|> public static String toHexString(byte[] digest) { <START> StringBuffer buf <END> = new StringBuffer(); for (int i = 0; i < digest.length; i++) { if ((digest[i] & 0xFF) < 0x10) buf.append('0'); buf.append(Integer.toHexString(digest[i] & 0xFF)); } return buf.toString(); }
<|startcomment|> Invert this so it returns early <|endcomment|> private boolean isLastKilledQueryGone() { boolean lastKilledQueryIsGone = (lastKilledQuery == null); <START> if (!lastKilledQueryIsGone) { <END> ClusterMemoryPool generalPool = pools.get(GENERAL_POOL); if (generalPool != null) { lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery); } } return lastKilledQueryIsGone; }
<|startcomment|> Is this change that makes batcher immediately execute after create new instance of Batcher and then added tasks smaller than capacity size? <|endcomment|> public Batcher(ScheduledExecutorService workExecutor, int capacity, long delay, BatchProcessor<T> processor) { this.workExecutor = workExecutor; this.capacity = capacity; this.delay = delay; this.processor = processor; this.inbox = new ArrayList<T>(); this.scheduled = false; <START> this.lastProcessedTime = 0; <END> }
<|startcomment|> This line should also be removed. <|endcomment|> public static void removeMagicResponseContextFields(Map<String, Object> responseContext) { <START> responseContext.remove(DirectDruidClient.QUERY_FAIL_TIME); <END> responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED); }
<|startcomment|> no Exception is thrown in this method <|endcomment|> private void validateAndClose() throws Exception { try { info("Validating static and Helix cluster maps"); verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout); if (validatingHelixClusterManager != null) { <START> ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0, <END> "Helix cluster manager should not have encountered any errors"); } } finally { if (validatingHelixClusterManager != null) { validatingHelixClusterManager.close(); } for (HelixAdmin admin : adminForDc.values()) { admin.close(); } } }
<|startcomment|> Consider: `return currentOffset == NO_VALUES ? 0 : maxOffset - currentOffset - 1;` <|endcomment|> public int size() { if (currentOffset == NO_VALUES) { return 0; } <START> return maxOffset - currentOffset - 1; <END> }
<|startcomment|> activatedPage is not used anymore <|endcomment|> <START> public void updateEditorPages(int activatedPage) { <END> removeAllPages(); addPages(); if (backToActivePage > 0 && backToActivePage < this.getPageCount()) { setActivePage(backToActivePage); } else { //Set active page if the backToActivePage is out of the range setActivePage(0); } setPartName(getPartName()); }
<|startcomment|> Looking at other HandlerUtil.getVariable() calls, the usual logic is to look for an instance of what you were looking for (in this case Boolean) and to treat any other situation as if null was provided. This would remove the need to check for Boolean in checkForCompositeRename and having code to issue an error log message which should never occur. <|endcomment|> public Object execute(ExecutionEvent event) throws ExecutionException { <START> Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY); <END> if (checkCompositeRename != null) { return checkForCompositeRename(event, checkCompositeRename); } else { performRename(event); } return null; }
<|startcomment|> Another non-permissible change <|endcomment|> <START> public Arguments setUntypedNullArgument(Argument untypedNullArgument) { <END> if (untypedNullArgument == null) { throw new IllegalArgumentException("the Argument itself may not be null"); } this.untypedNullArgument = untypedNullArgument; return this; }
<|startcomment|> @ivandalbosco I see that you just copied this piece from JS, but it's not perfect there :) We can drop `.replace("mn", "min")` everywhere (3 places). This was done as many RSPECs had legacy `mn` for minutes. It should be fixed now. It there is still some RSPEC using `mn` and plugin fails, then you better update this RSPEC <|endcomment|> private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) { if (func.startsWith("Constant")) { <START> return drf.constantPerIssue(constantCost.replace("mn", "min")); <END> } if ("Linear".equals(func)) { return drf.linear(linearFactor.replace("mn", "min")); } return drf.linearWithOffset(linearFactor.replace("mn", "min"), linearOffset.replace("mn", "min")); }
<|startcomment|> I find it very unintuitive to find this here... I'd suggest moving the log to `PMD.doPMD`, which is guaranteed to run once and a little more natural <|endcomment|> public void setAnalysisCache(final AnalysisCache cache) { if (cache == null && isAnalysisCacheFunctional()) { analysisCache = new NoopAnalysisCache(); // Log warning only once, if not explicitly disabled if (!isIgnoreIncrementalAnalysis() && LOG.isLoggable(Level.WARNING)) { final String version = PMDVersion.isUnknown() || PMDVersion.isSnapshot() ? "latest" : "pmd-" + PMDVersion.VERSION; <START> LOG.warning("This analysis could be faster, please consider using Incremental Analysis: " <END> + "https://pmd.github.io/" + version + "/pmd_userdocs_getting_started.html#incremental-analysis"); } } else if (!isIgnoreIncrementalAnalysis()) { // ignore new value if incr. analysis is disabled analysisCache = cache; } }
<|startcomment|> Same here. Add clarifying parenthesis <|endcomment|> private static double sortableLongToDouble(long value) { <START> value = value ^ (value >> 63) & Long.MAX_VALUE; <END> return Double.longBitsToDouble(value); }
<|startcomment|> ``` if (!(e instanceof ExecutionException) || e.getCause() == null) { return e; } Throwable cause = e.getCause(); return cause instanceof Exception ? (Exception) cause : new Exception(cause); ``` How about making return statement simpler? <|endcomment|> public static Exception extractExecutionExceptionCause(Exception e) { if (!(e instanceof ExecutionException)) { return e; } Throwable cause = e.getCause(); return cause == null ? e : (cause instanceof Exception ? (Exception) cause : new Exception(cause)); <START> } <END>
<|startcomment|> minor: braces unnecessary <|endcomment|> boolean isEmpty() { <START> return (validIndexSegments.isEmpty()); <END> }
<|startcomment|> Please do only whitespace changes in this commit. <|endcomment|> Set getDefaultIgnoreTypeNames() { Set ignored = new HashSet(); String[] ignore = {"org.eclipse.core.runtime.Plugin", "java.lang.ClassLoader", "org.eclipse.team.internal.ccvs.core.CVSTeamProvider", "org.eclipse.core.internal.events.BuilderPersistentInfo", "org.eclipse.core.internal.resources.Workspace", "org.eclipse.core.internal.events.EventStats", "java.net.URL"}; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-6$ <START> for (String element : ignore) { <END> ignored.add(element); } return ignored; }
<|startcomment|> child <|endcomment|> public static boolean delete(File file) { if (!file.exists()) return true; if (file.isDirectory()) { File[] children = file.listFiles(); for (File <START> children1 : <END> children) { delete(children1); } } return file.delete(); }
<|startcomment|> Why do we call authenticate to log out? If we aren't already authenticated, why do we need to log out? <|endcomment|> public void logout(final IProgressMonitor monitor) throws XmlRpcException { userID = -1; token = null; (new BugzillaXmlRpcOperation<Integer>(this) { @SuppressWarnings("serial") @Override public Integer execute() throws XmlRpcException { try { <START> bugzillaClient.authenticate(monitor); <END> } catch (CoreException e) { // TODO Auto-generated catch block e.printStackTrace(); } Object response = call(monitor, XML_USER_LOGOUT, null); return -1; } }).execute(); return; }
<|startcomment|> Could be simplified to: ```java return dirtyNumber < 1 ? 0 : dirtyNumber; ``` <|endcomment|> private double cleanNumber(double dirtyNumber) { <START> double clean; <END> if (dirtyNumber < 1) clean = 0; else clean = dirtyNumber; return clean; }
<|startcomment|> Same here: The new flag `withAttempts` is not passed (used) the `paymentProcessor#getAccountPayments` <|endcomment|> public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException { <START> return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext)); <END> }
<|startcomment|> why do you need to convert the bundle to a map, instead of using it directly? <|endcomment|> <START> private static Map<String, String> readMessagesFromBundle() { <END> try { ResourceBundle bundle = ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME); Map<String, String> messages = new HashMap<String, String>(); for (String key : bundle.keySet()) { messages.put(key, bundle.getString(key)); } return messages; } catch (MissingResourceException e) { log.error("Could not load audit log messages from the file " + APP_ERRORS_MESSAGES_FILE_NAME); throw new ApplicationException(e); } }
<|startcomment|> Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...) <|endcomment|> public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; <START> if (getClass() != obj.getClass()) return false; <END> BigFraction otherValue = ((ILScore)obj).getValue(); return this.value.equals(otherValue); }
<|startcomment|> [optional] this could be shortened to: return control.forUser(user).isRefVisible(); <|endcomment|> private boolean isValidReviewer(Account member, ChangeControl control) { if (member.isActive()) { IdentifiedUser user = identifiedUserFactory.create(member.getId()); // Does not account for draft status as a user might want to let a // reviewer see a draft. <START> if (control.forUser(user).isRefVisible()) { return true; } <END> } return false; }
<|startcomment|> please use == for enum comparisons like its done 2 lines above <|endcomment|> private boolean support( ValueGroup[] valueGroups ) { <START> return valueGroups.length == 1 && ValueGroup.NUMBER.equals( valueGroups[0] ); <END> }
<|startcomment|> You can make this file `File` <|endcomment|> <START> public String getConfigFile() <END> { return configFile; }
<|startcomment|> Probably won't be used, but you should implement AutoCloseable, since you implement close() anyway. <|endcomment|> <START> void close() { <END> writeQueue.add(WriteOperation.SHUTDOWN); writerService.shutdown(); }
<|startcomment|> Wouldn't this be an `if/else`? If we just `unsubscribed` in the previous lines I don't think we should ever go through this flow. <|endcomment|> private void completeInner() { // A group is removed, so check if we need to call `unsubscribe` if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) { // It means `groups.isEmpty() && child.isUnsubscribed()` is true unsubscribe(); } // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer <START> if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) { <END> // completionEmitted ensures we only emit onCompleted once if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) { if (!child.isUnsubscribed()) { child.onCompleted(); } } } }
<|startcomment|> ```suggestion logger.error("Found one or more vector errors from {}", opName); ``` <|endcomment|> protected boolean startError() { if (errorCount == 0) { <START> logger.error("Found one or more vector errors from " + opName); <END> } errorCount++; if (errorCount >= MAX_ERRORS) { return false; } return true; }
<|startcomment|> We use Java7, so you should use the try-with-resources feature. <|endcomment|> protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) { List<Integer> resultLineNumbers = new ArrayList<>(); Reader reader = null; try { reader = new FileReader(fileName); resultLineNumbers = grep(reader, regexp, resultLines); }catch (IOException e) { e.printStackTrace(); } finally { <START> closeQuietly(reader); <END> } return resultLineNumbers; }
<|startcomment|> Missing `final` (was indicated on the previous patch as well). <|endcomment|> private static void navigate(final Activity activity, final String destName, final String destCode, final Geopoint coords) { <START> Intent launchIntent = new Intent(INTENT_ACTION); <END> launchIntent.putExtra(Intents.EXTRA_NAME, destName); launchIntent.putExtra(Intents.EXTRA_GEOCODE, destCode); launchIntent.putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude()); launchIntent.putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude()); activity.startService(launchIntent); }
<|startcomment|> static import <|endcomment|> public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) { <START> Preconditions.checkNotNull(serverContent, <END> "Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"); this.serverContent = ImmutableMap.copyOf(serverContent); }
<|startcomment|> A redundant else statement <|endcomment|> private static boolean shouldCreateMyHandler(PsiElement element) { if (element instanceof LeafPsiElement) { LeafPsiElement leaf = (LeafPsiElement)element; return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf); } <START> else { <END> return false; } }
<|startcomment|> Wouldn't it be safer to make this method synchronized? <|endcomment|> <START> private void cancelRxCommands() { <END> for (CommandHandle commandHandle : fRxCommands.values()) { if (commandHandle.getRequestMonitor() == null) continue; commandHandle.getRequestMonitor().setStatus(genStatus( "Connection is shut down")); //$NON-NLS-1$ commandHandle.getRequestMonitor().done(); } fRxCommands.clear(); }
<|startcomment|> No need to expand the lambda <|endcomment|> private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores ) { Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService ); LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE; return new Supplier<StorageStatement>() { @Override public StorageStatement get() { return new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService, allocateCommandCreationContext() ); } <START> }; <END> }
<|startcomment|> Can be package-private? <|endcomment|> <START> public static byte[] convertBoolArrayToByteArray(boolean[] boolArr) { <END> byte[] byteArr = new byte[(boolArr.length + 7) / 8]; for (int i = 0; i < byteArr.length; i++) { byteArr[i] = readByte(boolArr, 8 * i); } return byteArr; }
<|startcomment|> Minor: use AssertJ `org.assertj.core.util.List.list` and static import for readability. <|endcomment|> public void all_composed_assertions_should_pass() { SoftAssertions delegate = new SoftAssertions(); delegate.assertThat(1).isEqualTo(1); delegate.assertAll(); softly.assertThat(1).isEqualTo(1); <START> softly.assertThat(Lists.newArrayList(1, 2)).containsOnly(1, 2); <END> softly.assertAlso(delegate); softly.assertAll(); assertThat(softly.wasSuccess()).isTrue(); }
<|startcomment|> * Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); } <|endcomment|> public void viewInfoUpdated() { <START> this.reinitialize(); <END> }
<|startcomment|> This should either be a **protected/private/or default** constructor, and the **List** should be copied so the Pointer can't be modified outside of the class. ``` java this.refTokens = refTokens.clone(); ``` as it is now, I could do this: ``` java Builder b = JSONPointer.builder().append("key1"); JSONPointer jp1 = b.build(); b.append("key2"); JSONPointer jp2 = b.build(); if(jp1.toString().equals(jp2.toString()){ throw new Exception("Oops, my pointers are sharing a backing array"); } ``` <|endcomment|> <START> public JSONPointer(List<String> refTokens) { <END> this.refTokens = refTokens; }
<|startcomment|> coudl be just ArrayList since now it is imported ^^ vv <|endcomment|> public VM() { mVmStatic = new VmStatic(); mVmDynamic = new VmDynamic(); mVmStatistics = new VmStatistics(); <START> mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); <END> mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>()); mDiskMap = new java.util.HashMap<String, DiskImage>(); mCdPath = ""; mFloppyPath = ""; mRunAndPause = false; _diskSize = 0; }
<|startcomment|> Would suggest to make it `private`. <|endcomment|> <START> long consumerLag() { <END> return consumerLag; }
<|startcomment|> In most other places we suppress boxing warnings by manually boxing in the code with Integer.valueOf() around the expression. This is especially true in MessageFormat.format invocations, which are very common in our error paths. I think that is the general approach preferred within JGit. <|endcomment|> public RegexGroupFilter(final int groupIdx) { if (groupIdx < 1) <START> throw new IllegalArgumentException(MessageFormat.format(HttpServerText.get().invalidIndex, groupIdx)); <END> this.groupIdx = groupIdx - 1; }
<|startcomment|> missing braces ? `blobSize` can end up to be 1 if `random.nextInt(10)` returns 0. <|endcomment|> public void testChunkFillingBlobSizeMultipleOfChunkSize() throws Exception { <START> blobSize = chunkSize * random.nextInt(10) + 1; <END> fillChunksAndAssertSuccess(); }
<|startcomment|> Suggest protected to signal that this is for the subclass <|endcomment|> <START> EapAkaAttributeFactory() <END> {}
<|startcomment|> I wouldn't implement this (just return null). A long has a fixed size, and we can use putLong() in HTInterval to write them to the file. This method was more for string, structs, etc. that we want to serialize. <|endcomment|> public byte[] toByteArray() { <START> return ByteBuffer.allocate(8).putLong(valueLong).array(); <END> }
<|startcomment|> there is no other way of getting article name? <|endcomment|> public String getModeName() { String header = getHeader(); <START> return header.substring(0, header.indexOf(' ')); <END> }
<|startcomment|> @vilchik-elena Why not simply returning `bitSet`? <|endcomment|> public int hashCode() { int result = bitSet; result = 31 * result + bitSet; <START> return result; <END> }
<|startcomment|> Not required <|endcomment|> void setUnresolvedCompact(boolean unresolvedCompact) { this.unresolvedCompact = unresolvedCompact; if (outer != null) { <START> outer.setUnresolvedCompact(true); <END> } }
<|startcomment|> hrmmm, is this required? Will this happen already with the cluster teardown? And, is there redundant closing with the `after()` call? <|endcomment|> public static void afterClass() throws Exception { if (sLocalAlluxioJobCluster != null) { sLocalAlluxioJobCluster.stop(); } <START> sFileSystem.close(); <END> }
<|startcomment|> What If I give the empty string as an input of that method ? <|endcomment|> public void testTrimLongSuffix() throws Exception { <START> String longValue = "12345"; <END> assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "l")).isEqualTo(longValue); assertThat(LiteralUtils.trimLongSuffix(longValue + "L")).isEqualTo(longValue); }
<|startcomment|> spell out ret <|endcomment|> public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context) { <START> Map<TableScanNode, Void> ret = new IdentityHashMap<>(); <END> ret.put(node, null); return ret; }
<|startcomment|> should not be this private? <|endcomment|> public int getStreamIndex() { <START> return streamIndex; <END> }
<|startcomment|> simpler: ``` } catch (IOException e) { throw e; } catch (Exception e) { throw new IOException(e); } ``` <|endcomment|> public Void call() throws IOException { if (task == null) { throw new IOException("The callable " + this + " has been serialized somehow, but it is actually not serializable"); } try { return task.call(); <START> } catch (Exception ex) { <END> if (ex instanceof IOException) { throw (IOException)ex; } throw new IOException(ex); } }
<|startcomment|> please remove the `try { .. } catch ( .. )` block altogether now. <|endcomment|> public static File task(File projectDir, String dstName) throws IOException { File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName)); try { if (projectDir.renameTo(dstDir) && XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) { return dstDir; } else { throw new IOException("Cannot rename project directory " + projectDir.getAbsolutePath() + " to " + dstName); } } catch (IOException e) { <START> throw e; <END> } }
<|startcomment|> Remove these extra variables that aren't used except in a setter. <|endcomment|> private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) { operation.setStatus(StockOperationStatus.NEW); <START> IStockOperationType operationType = WellKnownOperationTypes.getAdjustment(); <END> operation.setInstanceType(operationType); Stockroom stockroom; stockroom = delegate.getStockroom(); operation.setSource(stockroom); operation.setOperationNumber(delegate.getOperationNumber()); Date dNow = new Date(); operation.setOperationDate(dNow); operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList())); return operation; }
<|startcomment|> not sure if there's a reason for removing the parametrized type MarshallingResponseBuilder<T>, see that when setting the messages you loose the type. The other methods state, addMessage, and resout has the type. <|endcomment|> <START> public MarshallingResponseBuilder messages(List<MarshallingMessage> messages) { <END> this.messages.addAll(messages); return this; }
<|startcomment|> nit: I think we generally prefer to explicitly state the access modifiers. <|endcomment|> <START> long getTokenCount() { <END> return tokens.get(); }
<|startcomment|> `printStackTrace()`? Isn't it better to use a logger? <|endcomment|> public V getOrFill(K key, Callable<V> callable) { try { return callable.call() ; } catch (Exception e) { <START> e.printStackTrace(); <END> return null; } }
<|startcomment|> This is too much specific logic that is spilling over into a very general function. The only thing on which this needs to depend is Prefs.showActionFeedIndicator(), which it already does. <|endcomment|> void setUpHomeMenuIcon() { drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() && ReleaseUtil.isPreBetaRelease() <START> && Prefs.getTotalUserDescriptionsEdited() >= ACTION_DESCRIPTION_EDIT_UNLOCK_THRESHOLD ? <END> VISIBLE : GONE); }
<|startcomment|> Please remove unnecessary brackets: return Config.<Integer>getValue( configValue, compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue() <|endcomment|> public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) { final ConfigValues configValue = getMaxMemConfigValueByOsId(osId); return Config.<Integer>getValue( configValue, <START> (compatibilityVersion != null) ? compatibilityVersion.getValue() : Version.getLast().getValue() <END> ); }
<|startcomment|> this is incorrect place for command <|endcomment|> public void getPropertiesUpdatePlace(final TrendsPlace place){ CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() { @Override public void onFailure(Throwable caught) { new ExceptionPanel("Default properties will be used. Exception while properties retrieving: " + caught.getMessage()); updatePlace(place); } @Override public void onSuccess(WebClientProperties result) { webClientProperties = result; <START> updateTagFilter(); <END> updatePlace(place); } }); }
<|startcomment|> What does this change bring? Did we need this to get the test working? <|endcomment|> Context prepareDefaultContext(boolean parseAsFlume) { // Prepares a default context with Kafka Server Properties Context context = new Context(); context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl()); context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume)); <START> context.put("offsets.topic.replication.factor", "1"); <END> context.put(TOPIC_CONFIG, topic); return context; }
<|startcomment|> Should probably return null <|endcomment|> private String getDatacenter(InetAddressAndPort endpoint) { if (peersA.contains(endpoint)) return "datacenterA"; if (peersB.contains(endpoint)) return "datacenterB"; else if (peersC.contains(endpoint)) return "datacenterC"; <START> return "NA"; <END> }
<|startcomment|> Constant simpleSum could even removed as this constant is never used outside this class. <|endcomment|> private DateTimeFormatter getFormatter(){ switch (this){ case days: return DateTimeFormat.forPattern("yyyy-MM-dd"); case months: return DateTimeFormat.forPattern("yyyy/MM"); case weeks: return DateTimeFormat.forPattern("yyyy/ww"); case years: return DateTimeFormat.forPattern("yyyy"); case quarters: // has to be extended by the calling function return DateTimeFormat.forPattern("yyyy"); case simpleSum: <START> break; <END> } return null; }
<|startcomment|> I think this could be a one liner: ```java this.defaultProperties = new HashMap<>(defaultProperties); ``` <|endcomment|> public void setDefaultProperties(Map<String, Object> defaultProperties) { <START> this.defaultProperties = new HashMap<>(); <END> for (Object key : Collections.list(defaultProperties.propertyNames())) { this.defaultProperties.put((String) key, defaultProperties.get(key)); } }
<|startcomment|> Can this be private? <|endcomment|> <START> protected <END> MapSqlParameterSource createVnodeToPnodeParametersMapper( Integer pinnedIndex, Guid vNodeId) { return getCustomMapSqlParameterSource() .addValue("id", Guid.newGuid()) .addValue("vm_numa_node_id", vNodeId) .addValue("vds_numa_node_index", pinnedIndex); }
<|startcomment|> I would flip this for clarity: `return data == null ? null : encode(cryptoBox.decrypt(iv, decode(data));` <|endcomment|> public String read(String key) { String data = dataManager.read(key); <START> return (data != null) ? encode(cryptoBox.decrypt(iv, decode(data))) : data; <END> }
<|startcomment|> `super.init()` method never throw an exception. <|endcomment|> <START> public void setUp() throws Exception { <END> super.init(); }
<|startcomment|> `null` is not an acceptable value for `indexNullAs`. You can use `null` to represent "no value was selected", no need for an Optional. <|endcomment|> public S indexNullAs(F indexNullAs) { <START> indexNullAsValue = Optional.of( indexNullAs ); <END> return thisAsS(); }
<|startcomment|> import static Assert.assertEquals() <|endcomment|> public void testGenericImageExtraction() { org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage()); Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages()); <START> Assert.assertEquals("http://ichef.bbci.co.uk/images/ic/1024x576/p028s846.png", extractedGenericImage.getImage()); <END> Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType()); }
<|startcomment|> How can a set be of a negative size? <|endcomment|> void testDescribeInstances() { for (String region : ec2Api.getConfiguredRegions()) { Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region); assertNotNull(allResults); <START> assertTrue(allResults.size() >= 0); <END> } }
<|startcomment|> Package private should always be enough for testing. Use the same package for tests. <|endcomment|> <START> public static String quoteString(String s) { <END> if (s == null) { return null; } if (!s.matches("^\".*\"$")) { return "\"" + s + "\""; } else { return s; } }
<|startcomment|> Had an offline discussion with Aman, we can remove this check and serialize everything using getBytes() <|endcomment|> public Object getMin() { if (primitiveType == PrimitiveTypeName.BINARY) { <START> if (originalType == OriginalType.UTF8) { <END> return ((Binary) min).toStringUsingUTF8(); } else { return new String(((Binary) min).getBytes()); } } return min; }
<|startcomment|> fullName should be enough here too. <|endcomment|> public int hashCode() { <START> int result = name.hashCode(); <END> result = 31 * result + fullName.hashCode(); return result; }
<|startcomment|> I think rather than checking `> 0`, it would make things clearer if you had a static value like `DEFAULT_TIMEOUT = -1` and then use that in `createHttpClient` and change these checks to be `socketTimeout != DEFAULT_TIMEOUT`. Or something along those lines. <|endcomment|> private SocketConfig createSocketConfig(int socketTimeout) { return SocketConfig.custom() .setSoReuseAddress(true) <START> .setSoTimeout(socketTimeout > 0 ? socketTimeout : TIMEOUT_THREE_HOURS) <END> .build(); }
<|startcomment|> nit: line break after ( or before ".set" here. <|endcomment|> CommentBox(CodeMirror cm, CommentInfo info) { this.cm = cm; CommentRange range = info.range(); if (range != null) { fromTo = FromTo.fromCommentRange(range); rangeMarker = cm.markText( fromTo.getFrom(), fromTo.getTo(), <START> Configuration.create().set("className", <END> DiffTable.style.range())); } }
<|startcomment|> This is pretty lonely semicolon :wink: <|endcomment|> public void removeTagFromImage(String imageName, String tagToBeRemoved) { selectImage(imageName); new ContextMenu("Remove Tag").select(); String fullTag = ""; Combo combo = new DefaultCombo(); List<String> comboItems = combo.getItems(); for (String item : comboItems) { if (item.contains(tagToBeRemoved)) { fullTag = item; break; } } combo.setSelection(fullTag); <START> ; <END> new FinishButton().click(); }
<|startcomment|> do we really need this log? now that it is a command we should have a log for running a command, no? <|endcomment|> public void processOnVmStop(Collection<Guid> vmIds) { for (final Guid vmId : vmIds) { <START> log.infoFormat("process VM {0} that went down", vmId); <END> ThreadPoolUtil.execute(new Runnable() { @Override public void run() { Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(vmId), ExecutionHandler.createInternalJobContext()); } }); } }
<|startcomment|> nit: can just do this.defaultFilter = Preconditions.checkNotNull(defaultFilter) <|endcomment|> public BatchServerInventoryView( final ZkPathsConfig zkPaths, final CuratorFramework curator, final ObjectMapper jsonMapper, final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter ) { super( log, zkPaths.getAnnouncementsPath(), zkPaths.getLiveSegmentsPath(), curator, jsonMapper, new TypeReference<Set<DataSegment>>() { } ); Preconditions.checkNotNull(defaultFilter); <START> this.defaultFilter = defaultFilter; <END> }
<|startcomment|> Actually I don't think this is how it should work? We do not expose jackson directly to the user, and all the encoding and decoding happens on the spring side and not with the SDK itself.. shouldn't this go into the mapper/converter logic instead? <|endcomment|> protected void configureEnvironment(final ClusterEnvironment.Builder builder) { <START> Jackson2ObjectMapperBuilder jacksonBuilder = new Jackson2ObjectMapperBuilder(); <END> jacksonBuilder.serializationInclusion(JsonInclude.Include.NON_NULL); jacksonBuilder.modules(new CouchbaseJacksonModule(), new JsonValueModule()); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new CouchbaseJacksonModule()); objectMapper.registerModule(new JsonValueModule()); builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper)); }
<|startcomment|> Just doing updateTopologyConfigID is not enough. While process a topology change event, the discovery service does more work refer to processTopologyChangeNotification. While combining two events topology change and leadership change together, it is a bit complex. Would suggest to not call the fetchTopologyFromClusterManager. First, the topology change is a notification API from clusterManager. Even with this call, it will fetch the cached value from clusterManagerAdapter. Second, it just add more complexity and doesn't completely solve the problem. <|endcomment|> public void processLockAcquire() { log.debug("Process lock acquire event"); isLeader = true; // Regardless of the role of this node, on leadership acquisition // we shall query the topology provider to get the most up to date // topologyConfigId, which might have changed during our time as non-leaders // and for which we might have missed the change notification and update it on // the sink manager so the value is cached to filter messages upon receive. fetchTopologyFromClusterManager(); <START> updateTopologyConfigId(topologyDescriptor.getTopologyConfigId()); <END> onLeadershipAcquire(); }
<|startcomment|> Normally you just return mClientModeImpl.getSyncDhcpInfo. If you really want to introduce a local make it final. <|endcomment|> public DhcpInfo getDhcpInfo() { enforceAccessPermission(); if (mVerboseLoggingEnabled) { mLog.info("getDhcpInfo uid=%").c(Binder.getCallingUid()).flush(); } <START> DhcpInfo dhcpInfo = mClientModeImpl.syncGetDhcpInfo(); return dhcpInfo; <END> }
<|startcomment|> why do we use strings here? <|endcomment|> public void setUp() throws Exception { <START> MetadataStorageConnectorConfig config = jsonReadWriteRead( <END> "{" + "\"type\" : \"db\",\n" + "\"segmentTable\" : \"segments\"\n" + "}", MetadataStorageConnectorConfig.class ); connector = new TestDerbyConnector( Suppliers.ofInstance(config), Suppliers.ofInstance(tablesConfig) ); }
<|startcomment|> You should use `HttpServletResponse.SC_...` everywhere, no need for `HttpStatus` here. <|endcomment|> protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException { if (result.healthy) { resp.setStatus(HttpServletResponse.SC_OK); } else { <START> resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); <END> } sendResponse(resp, result.toJson()); }
<|startcomment|> Same for detach <|endcomment|> public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) { JsonRpcRequest request = new RequestBuilder("ManagedVolume.attach_volume") .withParameter("vol_id", <START> volumeId) <END> .withParameter("connection_info", connectionInfo) .build(); Map<String, Object> response = new FutureMap(this.client, request); Map<String, Object> info = (Map<String, Object>) response.get("info"); return new DeviceInfoReturn(info); }
<|startcomment|> As a paranoia sufferer, I would invert the equals to avoid the remote possibility of a NPE: ```java if (MantaHttpHeaders.REQUEST_ID.equals(header.getName())) { ``` <|endcomment|> public static void addHeaders(final HttpMessage httpMessage, final Header... headers) { Validate.notNull(httpMessage, "HttpMessage must not be null"); for (final Header header : headers) { <START> if (header.getName().equals(MantaHttpHeaders.REQUEST_ID)) { <END> continue; } httpMessage.addHeader(header); } }
<|startcomment|> `this.path` is initialized to a value so this is not necessary. <|endcomment|> public String getServletMapping() { <START> if ("".equals(this.path) || "/".equals(this.path)) { <END> return "/"; } if (this.path.endsWith("/")) { return this.path + "*"; } return this.path + "/*"; }
<|startcomment|> Now that this is a standalone function. You can just do `return InetAdress.get...` here, and remove the temporary variable. <|endcomment|> private static InetAddress toInetAddress(Slice ipAddress) { InetAddress address; try { <START> address = InetAddress.getByAddress(ipAddress.getBytes()); <END> } catch (UnknownHostException e) { throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Invalid IP address binary: " + ipAddress.toStringUtf8(), e); } return address; }
<|startcomment|> EqualsVerifier test please for equals and hashcode <|endcomment|> public int hashCode() { return Objects.hash(sqls, sqlFirehoseDatabaseConnector, objectMapper, foldCase); <START> } <END>
<|startcomment|> Can we return an empty list here instead? <|endcomment|> protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) { <START> return null; <END> }
<|startcomment|> Seems like there's a spacing issue here, two spaces instead of 4. <|endcomment|> protected boolean isAppConfiguredInSourceServerXml(String fileName) { <START> boolean bConfigured = false; <END> Set<String> locations = getAppConfigLocationsFromSourceServerXml(); if (locations.contains(fileName)) { log.debug("Application configuration is found in server.xml : " + fileName); bConfigured = true; } return bConfigured; }
<|startcomment|> log.debug ? <|endcomment|> private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException { <START> log.info("about to reinitialize dc"); <END> DataCenter dataCenter = new DataCenter(); dataCenter.setId(dcId); updateDataCenter(dataCenter); return dataCenter; }
<|startcomment|> who releases the request if an IOException is thrown? <|endcomment|> public void send(Send request) throws IOException { if (!connected) { throw new ClosedChannelException(); } while (!request.isSendComplete()) { request.writeTo(writeChannel); } <START> request.release(); <END> }
<|startcomment|> Can we revert this and keep the order deterministic? <|endcomment|> public void canParseNamedCaptureGroupsFromPattern() { assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""), hasSize(0)); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("(?<user>.*)"), contains("user")); assertThat(RegexUtils.getNamedCaptureGroupsFromPattern("Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)"), <START> containsInAnyOrder("poolName", "poolMember", "poolAddr", "slotNum")); <END> }
<|startcomment|> I'd then check the exception class plus parameters, not the message that isn't even sent to the user. <|endcomment|> public void testActivateAppUnknownApp() throws Exception { App app = when(mock(App.class).isActive()).thenReturn(false).getMock(); MvcResult result = mockMvc.perform(post(AppsController.URI + "/id/activate")).andReturn(); <START> assertEquals(result.getResolvedException().getMessage(), "Unknown app 'id'"); <END> }
<|startcomment|> Doesn't the InstallReceiver depend on a WikipediaApp instance being created by the system? Since NotificationPollService.start() is already called there, I think this would call it a second time <|endcomment|> public void onReceive(Context ctx, Intent intent) { String action = intent.getAction(); switch (action) { case INSTALL_ACTION: // for play store devices only: // * invoke the receiver and open the page: // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWombat&campaign_id=foo&install_id=bar"` // * invoke the receiver but don't open the app (bad url): // `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es "referrer" "referrer_url=gibberish&campaign_id=foo&install_id=bar"` installReferrer(ctx, intent); break; case Intent.ACTION_BOOT_COMPLETED: // `adb shell am broadcast -a android.intent.action.BOOT_COMPLETED` recordChannelId(ctx); NotificationPollService.start(ctx.getApplicationContext()); break; <START> default: <END> L.d("action=" + action); break; } }
<|startcomment|> can this have an overloaded method please so we don't have to pass null around? ```suggestion StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId); ``` <|endcomment|> private String getTokenToUse(String authTokenCredentialId, String token) { if (!StringUtils.isEmpty(authTokenCredentialId)) { <START> StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId, null); <END> if (credentials != null) { logger.fine("Using Integration Token Credential ID."); return credentials.getSecret().getPlainText(); } } logger.fine("Using Integration Token."); return token; }
<|startcomment|> and then you may be able to drop the `options != null` check. <|endcomment|> void onGetBlobError(Exception e, GetBlobOptions options) { <START> if (options != null && options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) { <END> onGetBlobInfoError(e); } else { onGetBlobDataError(e, options); } }
<|startcomment|> If you add `@NonNull` here than it's not worth checking the `null` again inside. You should safely assume that the client of the method is fulfilling the non null pre-condition. The IDE will tell the client of the method that a null argument should not be passed. So, either you remove `@NonNull` or remove the check for `!= null` inside. <|endcomment|> <START> public void setSelectedChapter(@NonNull Chapter chapter) { <END> if (mSelectedChapter != null) { trackView(); } this.mSelectedChapter = chapter; }
<|startcomment|> we always use parentheses, also for one-line statements. <|endcomment|> public void open(GenericInputSplit split) throws IOException { super.open(split); <START> if (serializableIter != null) <END> it = serializableIter; else it = this.dataSet.iterator(); }
<|startcomment|> Can we remove this? I realize what it was for but I don't think it should be kept around in the example. <|endcomment|> @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("Check logcat!"); setContentView(tv); printArgs("The", "Quick", "Brown", "Fox"); Log.i("Fibonacci", "fibonacci's 4th number is " + fibonacci(4)); Greeter greeter = new Greeter("Jake"); Log.d("Greeting", greeter.sayHello()); startSleepyThread(); <START> synchronized (Boolean.TRUE){} <END> }
<|startcomment|> Please remove `mAfterKeys` while you're at it. It was only a workaround for the absence of `ContentValues.keySet()` on Android 2.x. Since we don't support Android 2 any more you can remove it in most places and replace by `mAfterContentValues.keySet()` where it's being read. <|endcomment|> private ContentValues ensureAfter() { ContentValues values = mAfterContentValues; if (values == null) { values = new ContentValues(); mAfterContentValues = values; // also create mAfterKeys <START> mAfterKeys = new HashSet<>(); <END> } return values; }
<|startcomment|> The parameter can bee removed <|endcomment|> private Task<? extends Serializable> createDbTask(Database dbObj) { // note that we do not set location - for repl load, we want that auto-created. CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false, <START> updateDbProps(dbObj, context.dumpDirectory, true)); <END> // If it exists, we want this to be an error condition. Repl Load is not intended to replace a // db. // TODO: we might revisit this in create-drop-recreate cases, needs some thinking on. DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc); return TaskFactory.get(work, context.hiveConf); }
<|startcomment|> what is the purpose of maxWriteTimeInMs now? how is it being used? <|endcomment|> public long writeTo(Write writeChannel) throws IOException { long sizeWritten = 0; ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite); sizeWritten = writeChannel.appendFrom(readableByteChannel, sizeToWrite); if(sizeWritten != sizeToWrite) { throw new IOException("Not able to write fully. Expected : " + sizeToWrite + " Actual : " + sizeWritten ); } <START> return sizeWritten; <END> }
<|startcomment|> exists check is not done for SNAPSHOT jars intentionally so that they get updated everytime. SNAPSHOT jars are to be used for testing only and are designed to get updated on each run. Or else there would be no reason for method 'addSnapshotJarToClassPath' to exist. i guess your failure is a result of running concurrent jobs with SNAPSHOT jars. <|endcomment|> static void addSnapshotJarToClassPath( File jarFile, Path intermediateClassPath, FileSystem fs, Job job ) throws IOException { // Snapshot jars are uploaded to non shared intermediate directory. final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName()); // existing is used to prevent uploading file multiple times in same run. <START> if (!existing.contains(hdfsPath) || !fs.exists(hdfsPath)) { <END> uploadJar(jarFile, hdfsPath, fs); existing.add(hdfsPath); } job.addFileToClassPath(hdfsPath); }
<|startcomment|> It's better to make the listener unregister itself at stop time instead of storing a boolean. See for instance `WorkManagerImpl.init` and the implementation of `afterStop`. <|endcomment|> public void start(ComponentContext context) { super.start(context); configs.forEach(this::createStreamIfNotExists); processorDescriptors.forEach(this::initProcessor); if (! componentListenerAdded) { // this must be done only once while start method can be called multiple time on hot reload Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener()); <START> componentListenerAdded = true; <END> } }
<|startcomment|> Please keep it in info level. <|endcomment|> public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException { TextMessage message = session.createTextMessage("task:" + propertiesBean.getProperty("engine.unique.id") + ":" + id + ":" + status + ":" + miliseconds); producer.send(message, DeliveryMode.PERSISTENT, 6, 0); <START> log.debug("[{}] Task state {} sent to dispatcher.", id, status); <END> }
<|startcomment|> Why is it done lazily? Seems we'll need it in any case? <|endcomment|> public final BeanMetaData<T> getCurrentBeanMetaData() { <START> if ( currentBeanType != null && currentBeanMetaData == null ) { <END> currentBeanMetaData = beanMetaDataManager.getBeanMetaData( currentBeanType ); } return currentBeanMetaData; }
<|startcomment|> Given this is configuration, wouldn't it make more sense to show the parameters in the output, accept them in input, and then fix validation like it's done in the UI? <|endcomment|> protected Object handleObjectGet() throws Exception { String workspace = getAttribute("workspace"); ServiceInfo service; if (workspace != null) { WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace); service = geoServer.getService(ws, clazz); } else { service = geoServer.getService(clazz); } if (service == null) { throw new RestletException("Service for workspace " + workspace + " does not exist", Status.CLIENT_ERROR_NOT_FOUND); } <START> return service.clone(true); <END> }
<|startcomment|> Return the result of `sha256` instead of using the local variable. <|endcomment|> private String buildHashedPayload(HttpRequest request) { String hashedPayload = ""; try { byte[] unhashedBytes = request.getPayload() == null ? "".getBytes() : ByteStreams.toByteArray(request .getPayload().getInput()); <START> hashedPayload = sha256(unhashedBytes); <END> } catch (IOException e) { throw new HttpException("Error signing request", e); } return hashedPayload; }
<|startcomment|> It's a little harsh to return null because the deprecated method should work as the original implementation, right? Can't this method read the StreamInputReader and get the information from there? <|endcomment|> public Map<Long, EventDefinition> getEventDefs(StreamInput id) { <START> return null; <END> }
<|startcomment|> You don't need this. onView() will wait <|endcomment|> public void testSetTitleIconStartMargin() throws Throwable { int startMargin = 100; int navIconWidth = 100; mActivityRule.runOnUiThread(() -> { mToolbar.setNavigationIconContainerWidth(navIconWidth); mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon); mToolbar.setTitleIconStartMargin(startMargin); }); <START> InstrumentationRegistry.getInstrumentation().waitForIdleSync(); <END> onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin))); }
<|startcomment|> static import <|endcomment|> Publisher<CoreEvent> getDownstreamPublisher() { return downstreamFlux <START> .compose(downstreamPublisher -> Mono.subscriberContext() <END> .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> { innerFlux.subscriberContext(downstreamContext).subscribe(); upstreamFlux.subscriberContext(downstreamContext).subscribe(); }))); }
<|startcomment|> This change may cause the lock not to be released in some cases. With this change, in case of a failure VdsManager is responsible for releasing the lock. The VdsManager releases the lock only in case it catches an immediate exception. In case of a time-out or other SetupNetworks vdsm failure, the lock will never be unlocked. <|endcomment|> public void onFailure(Throwable t) { log.error("Unable to RefreshCapabilities: {}", ExceptionUtils.getRootCauseMessage(t)); log.debug("Exception", t); <START> postProcessRefresh(false, releaseLock.getAndSet(false)); <END> }
<|startcomment|> There is no reason to create new instance if SilentMigrationProgressMonitor here since NO_OP_SECTION is static <|endcomment|> public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships, int highLabelId, int highRelationshipTypeId ) { this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId, <START> new SilentMigrationProgressMonitor().NO_OP_SECTION ); <END> }
<|startcomment|> @vilchik-elena can't we directly use commaTokens? <|endcomment|> public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) { List<Tree> commas = Lists.newArrayList(); for (InternalSyntaxToken comma : commaTokens) { commas.add(comma); } <START> return new ArrayLiteralTreeImpl(commas); <END> }
<|startcomment|> why not to rely on AbstractCollection..toString? <|endcomment|> public void onSuccess() { log.debug("Command succeeded, releasing macs {}.", <START> Arrays.toString(super.macs.toArray())); <END> releaseMacs(); }
<|startcomment|> Make the constructor public <|endcomment|> <START> SubresourceParameter(String value) { <END> super("t", value); }
<|startcomment|> flip the order of the checks - more intuitive IMO. Something like saying "time is valid and is less than" rather than "time is less than and valid" <|endcomment|> private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) { <START> return expirationTimeInMs < referenceTimeInMs && expirationTimeInMs != Utils.Infinite_Time; <END> }
<|startcomment|> Please do not print to stdout/stderr. Please log instead so output can be silenced by the build infrastructure. <|endcomment|> public void testEncodeSpatial() throws Exception { Document doc = encode(FilterMockData.intersects(), FES.Filter); assertEquals("fes:Filter", doc.getDocumentElement().getNodeName()); Element e = getElementByQName(doc, FES.Intersects); assertNotNull(e); <START> print(e); <END> assertNotNull(getElementByQName(e, FES.ValueReference)); assertNotNull(getElementByQName(e, GML.Point)); }
<|startcomment|> The local variable is declared in bad scope. <|endcomment|> public View getTopContainer(final View view) { View topView = null; <START> EObject container; <END> if (view != null) { container = view.eContainer(); if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) { container = container.eContainer(); } if (container instanceof View) { topView = (View) container; } } return topView; }
<|startcomment|> I don't think this method should be called in a constructor. <|endcomment|> public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository, StreamRepository streamRepository, XDParser parser) { super(zkConnection, repository, streamRepository, parser, stream); this.zkConnection = zkConnection; this.parser = parser; <START> updateModuleDefinitions(); <END> }
<|startcomment|> Is this really necessary? AFAIK the scope and key should never be MarshalledValues. <|endcomment|> public String toString() { Object oScope = scope; Object oKey = key; <START> if (oScope instanceof MarshalledValue) { <END> oScope = ((MarshalledValue) oScope).get(); } if (oKey instanceof MarshalledValue) { oKey = ((MarshalledValue) oKey).get(); } return "ScopedKey{scope = " + oScope + ", key = " + oKey + "}"; }
<|startcomment|> `str == null` cannot be true here as this was already checked upfront by https://github.com/crate/crate/pull/8879/files#diff-7a2324ee3f0c0f2c921e7ffeb1740058R70 (it also correctly results in `null` there). We could also move this empty string or 0 length up under that check as it would be same for both functions. <|endcomment|> static String left(String str, int len) { <START> if (str == null || str.isEmpty() || len == 0) { <END> return ""; } if (len > 0) { return str.substring(0, Math.min(len, str.length())); } final int finalLen = str.length() + len; return finalLen > 0 ? str.substring(0, finalLen) : ""; }
<|startcomment|> It should never happen, since `org.springframework.web.bind.annotation.RequestBody#required` is `default true` <|endcomment|> public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm, BindingResult bindingResult, @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader) { <START> if (roleForm == null) <END> { throw new RequestBodyValidationException("Empty request body", bindingResult); } if (bindingResult.hasErrors()) { throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult); } // Convert RoleForm to Role Role role = conversionService.convert(roleForm, Role.class); return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader); }
<|startcomment|> Minor: you can decrease the visibility modifier for some methods here and change some methods to be static. <|endcomment|> <START> public AbstractJsonGetter(Getter parent) { <END> super(parent); }
<|startcomment|> how about this.vdsNumaNodeDao = Objects.requireNonNull(vdsNumaNodeDao) ? <|endcomment|> NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) { Objects.requireNonNull(vdsNumaNodeDao); <START> this.vdsNumaNodeDao = vdsNumaNodeDao; <END> }
<|startcomment|> getClients(this, null, null) <|endcomment|> public List<ClientModel> getClients() { <START> return session.realms().getClients(this, 0, session.realms().getClientsCount(this).intValue()); <END> }
<|startcomment|> Coding best practices: Interface i = new Implementation(); <|endcomment|> public List<String> getTokens() { ArrayList<String> ret = new ArrayList<>(this.tokenCount); <START> <END> for (int i = 0; i < this.tokenCount; i++) { ret.add(getToken(i)); } return ret; }
<|startcomment|> Not needed. By default it will always be initialized to 0 <|endcomment|> public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory, final int maxWidth) { Preconditions.checkArgument(maxWidth >= 1, "MaxWidth for given endpoint should be at least one."); this.endpoint = endpoint; this.affinity = affinity; this.mandatory = mandatory; this.maxWidth = maxWidth; <START> this.numLocalWorkUnits = 0; <END> }
<|startcomment|> Intentional change. Keep the originial. <|endcomment|> public void run() { <START> LOG.trace("BacklogMetricEmitter running for entities"); <END> executor = new ScheduledThreadPoolExecutor(10); List<Future> futures = new ArrayList<>(); try { for (Entity entity : entityBacklogs.keySet()) { futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity)))); } waitForFuturesToComplete(futures); } finally { executor.shutdown(); } }
<|startcomment|> projectListFragment is always set, no null check needed Please remove log output <|endcomment|> public void onBackPressed() { if (projectListFragment != null) { projectListFragment.cancelLoadProjectTask(); Log.d(TAG, "Back press detected!"); <START> } <END> super.onBackPressed(); }
<|startcomment|> not needed (the value is null and won't be used anyway) <|endcomment|> private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) { // do the state transition only if that VM is really running on SRC if (getParameters().getVdsId().equals(curVm.getRunOnVds())) { ResourceManager.getInstance().InternalSetVmStatus(curVm, <START> parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down, curVm.getStatusUpdatedTime()); <END> } }
<|startcomment|> Should this be private? <|endcomment|> <START> public TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri, <END> Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) { this.selection = checkNotNull(selection); this.publisher = checkNotNull(publisher); this.contentUri = checkNotNull(contentUri); this.transactionId = checkNotNull(transactionId); this.transactionStatus = checkNotNull(transactionStatus); }
<|startcomment|> maybe not necessary, but protocol is case-insensitive - maybe should be equalsIgnoreCase used? <|endcomment|> private static boolean appendPort(final String scheme, final int port) { <START> return port > -1 && ((HTTP.equals(scheme) && port != 80) || (HTTPS.equals(scheme) && port != 443)); <END> }
<|startcomment|> We can inline these two vars <|endcomment|> public void addPage(BenchmarkData data) { int pageCount = data.getPageCount(); <START> Page page = data.getDataPage(); <END> PartitionedOutputOperator operator = data.createPartitionedOutputOperator(); for (int i = 0; i < pageCount; i++) { operator.addInput(page); } operator.finish(); }
<|startcomment|> Use import static <|endcomment|> private Element timeZone() { <START> return textElement(BlogConstants.TIMEZONE, entity.getTimeZone()); <END> }
<|startcomment|> so do not resolve groups and no recursive as you going to search it anyway. <|endcomment|> private DbUser getDbUserForPrincipalName(String principalName, String authzName) { ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord( EngineExtensionsManager.getInstance().getExtensionByName(authzName), <START> principalName, true, true); <END> if (principalRecord == null) { throw new RuntimeException(String.format("Unable to find principal %s in domain '%s'", principalName, authzName)); } return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord)); }
<|startcomment|> lambda? <|endcomment|> public PatternScatterGraphView() { super(ID); <START> this.addPartPropertyListener(new IPropertyChangeListener() { @Override public void propertyChange(PropertyChangeEvent event) { if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) { Object newValue = event.getNewValue(); if (newValue instanceof String) { String data = (String) newValue; fViewInfo.setViewData(data); setPartName(fViewInfo.getLabel()); loadLatencyView(); <END> } } } }); }
<|startcomment|> I believe `&&` should be here also <|endcomment|> public void setMaxSpeed(double maxSpeed) { <START> if (this.maxSpeed == null || maxSpeed > this.maxSpeed) { <END> this.maxSpeed = maxSpeed; } }
<|startcomment|> Minor: can remove `throws` <|endcomment|> <START> Object getValue(Object obj) throws Exception { <END> throw new HazelcastException("Path agnostic value extraction is not supported"); }
<|startcomment|> Except for debugging purpose, the "result" local does not seem necessary. <|endcomment|> public boolean apply(Resource resource) { Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources); <START> boolean result = Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef); <END> return result; }
<|startcomment|> `clientRegistration` may be `null`. Please add a null check here. <|endcomment|> private URI endSessionEndpoint(OAuth2AuthenticationToken token) { String registrationId = token.getAuthorizedClientRegistrationId(); <START> ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId); <END> Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get("end_session_endpoint"); URI result = null; if (endSessionEndpoint != null) { result = URI.create(endSessionEndpoint.toString()); } return result; }
<|startcomment|> bitmap. <|endcomment|> public AddUnseenToBitmapFilter(BitmapBuilder seen, BitmapBuilder bitmap) { this.seen = seen; this.bitmap = <START> bitmapResult; <END> }
<|startcomment|> I see some surprising results here when adding additional test cases for doubles: * `Double.NaN` as the input value returns 1.0 (Edit: Double.MIN_VALUE is fine, I forgot this was just slightly greater than 0) <|endcomment|> public void testQuantileAtValueBigint() { QuantileDigest qdigest = new QuantileDigest(1); addAll(qdigest, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 20)", toHexString(qdigest)), <START> DOUBLE, <END> 1.0); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 6)", toHexString(qdigest)), DOUBLE, 0.6); functionAssertions.assertFunction(format("quantile_at_value(CAST(X'%s' AS qdigest(bigint)), -1)", toHexString(qdigest)), DOUBLE, 0.0); }
<|startcomment|> I'm ok with either capitalization. But it needs to be consistent. The `overutilized` 2 lines above is capitalized differently. <|endcomment|> public boolean isOverutilized() { <START> return memoryManager.isOverUtilized(); <END> }
<|startcomment|> c4query should also be synchronized. Move c4query checks to the check method itself. The same thing for the execute() method. See https://github.com/couchbase/couchbase-lite-ios/blob/feature/2.0/Objective-C/CBLQuery.mm#L605-L606 <|endcomment|> public String explain() throws CouchbaseLiteException { <START> if (c4query == null) <END> check(); synchronized (getDatabase().getLock()) { return c4query.explain(); } }
<|startcomment|> just return `false` here. <|endcomment|> public boolean isObjectFactory() { <START> return getTargetTypeParameter() != null || getParameters().isEmpty(); <END> }
<|startcomment|> Shound't this ctor be `public` or at least `protected`? Otherwise I don't see reason in all those `protected` methods below. <|endcomment|> <START> StandardRotationPolicy(DelegatingSessionFactory<?> factory, List<KeyDirectory> keyDirectories, <END> boolean fair) { Assert.notNull(factory, "factory cannot be null"); Assert.notNull(keyDirectories, "keyDirectories cannot be null"); Assert.isTrue(keyDirectories.size() > 0, "At least one KeyDirectory is required"); this.factory = factory; this.keyDirectories.addAll(keyDirectories); this.fair = fair; this.iterator = this.keyDirectories.iterator(); }
<|startcomment|> Tricky! `validateAddAllowed` currently checks if you have the WRITE_META permission on the entity. Acl gets created after the check. This breaks OneClickImporter <|endcomment|> public void add(EntityType entity) { validateAddAllowed(entity); <START> createAcl(entity); <END> super.add(entity); }
<|startcomment|> @adavid9 can you please add `throws IOException` here and use `TrowingFunction` at `GroupRepositoryProvider.search` ? <|endcomment|> private ArtifactCoordinates getArtifactCoordinates(Path p) { <START> return ThrowingFunction.unchecked(RepositoryFiles::readCoordinates).apply((RepositoryPath) p); <END> }
<|startcomment|> To avoid accidental class casts, you can use the following signature: public <T extends ActivityNode> IPinUpdater<T> instantiate(T node) Then unchecked casts can be regrouped into this method (Rather than in each Clients) <|endcomment|> <START> public IPinUpdater<? extends ActivityNode> instantiate(ActivityNode node){ <END> IPinUpdater<? extends ActivityNode> updater = null; if(node instanceof CallBehaviorAction){ updater = new CallBehaviorActionPinUpdater(); }else if(node instanceof CallOperationAction){ updater = new CallOperationActionPinUpdater(); }else if(node instanceof SendSignalAction){ updater = new SendSignalActionPinUpdater(); } return updater; }
<|startcomment|> Please don't do cleanups in the same commit as bugfixes/features/improvements <|endcomment|> public boolean supportsScroll() { StorageConfiguration conf = coreFeature.getStorageConfiguration(); // DBS mem and marklogic are not yet supported <START> return conf.isDBSMongoDB() || conf.isVCS(); <END> }
<|startcomment|> Style issue: please use braces in a multiline conditional. <|endcomment|> public void onResume() { super.onResume(); addCachedDevices(); <START> if (mLocalAdapter.getBluetoothState() != BluetoothAdapter.STATE_ON) <END> removeAllDevices(); if (mStartScanOnResume) { mLocalAdapter.startScanning(true); mStartScanOnResume = false; } }
<|startcomment|> Not sure i'd go with events (yet). Model upgrade was not emitting events either, and Status flags with this change would be properly set. Let's go with baby steps, and not introduce events for these yet (unless some other good reason mentioned for it's need) <|endcomment|> protected void upgradeNexusVersion() throws IOException { final String currentVersion = checkNotNull( applicationStatusSource.getSystemStatus().getVersion() ); final String previousVersion = getConfiguration().getNexusVersion(); if ( currentVersion.equals( previousVersion ) ) { setInstanceUpgraded( false ); } else { setInstanceUpgraded( true ); getConfiguration().setNexusVersion( currentVersion ); storeConfiguration(); <START> eventMulticaster.notifyEventListeners( new NexusVersionChangedEvent( this, previousVersion, <END> currentVersion ) ); } }
<|startcomment|> Can you make the old constructor call the new one (with a default value for the additional parameter)? <|endcomment|> <START> public DefDeclaration(String name, Type returnType, List<NameBinding> argNames, <END> TypedAST body, boolean isClassDef, FileLocation location) { if (argNames == null) { argNames = new LinkedList<NameBinding>(); } this.type = getMethodType(argNames, returnType); this.name = name; this.body = (ExpressionAST) body; this.argNames = argNames; this.isClass = isClassDef; this.location = location; }
<|startcomment|> Can we all add the generic parameters for the acceptors? (Like `HttpFailureStatusAcceptor<HeadBucketResult>`?) <|endcomment|> <START> public Waiter<HeadBucketRequest> bucketNotExists() { <END> return new WaiterBuilder<HeadBucketRequest, HeadBucketResult>() .withSdkFunction(new HeadBucketFunction(client)) .withAcceptors( new HttpFailureStatusAcceptor(404, WaiterState.SUCCESS)) .withDefaultPollingStrategy( new PollingStrategy(new MaxAttemptsRetryStrategy(20), new FixedDelayStrategy(5))) .withExecutorService(executorService).build(); }
<|startcomment|> @jomarko A couple of question: 1) from the ticket description it seems that somehow both TAB and ESC should be managed (in different way) but I do not see that here: is the ESC managed elsewhere or in different way? 2) is this kind of interaction specific ot ScenarioSImulation? Is it not the same for other grid editor? If the behavior should be the same on different component, then it should be better to create a builder/getter somewhere else (some abstract/parent class) to avoid duplicate this snippet <|endcomment|> public TextArea createWidget() { final TextArea textArea = GWT.create(TextArea.class); textArea.addKeyDownHandler(keyDownEvent -> { final int keyCode = keyDownEvent.getNativeKeyCode(); <START> if (keyCode == KeyCodes.KEY_TAB) { <END> destroyResources(); gridPanel.setFocus(true); keyDownEvent.preventDefault(); } keyDownEvent.stopPropagation(); }); textArea.addMouseDownHandler(DomEvent::stopPropagation); return textArea; }
<|startcomment|> Why is setupDataForMockito() called here when it is designated with the @Before keyword below? I have seen this in a few other tests as well. <|endcomment|> public void testHierarchyView() { DockerImagesTab imageTab = openDockerImagesTab(); buildImage(IMAGE_TEST_BUILD, DOCKERFILE_FOLDER, imageTab); if (mockitoIsUsed()) { <START> setupDataForMockito(); <END> } DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab(); List<TreeItem> treeItems = hierarchyTab.getTreeItems(); compareTextInFirstNode(treeItems, "alpine:3.3"); List<TreeItem> treeItems2 = treeItems.get(0).getItems(); compareTextInFirstNode(treeItems2, IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST); }
<|startcomment|> private <|endcomment|> <START> void doBadOffsetInputTest(String name, long offset) { <END> try { new Offset(name, offset); fail("Should have thrown because one of the inputs is invalid"); } catch (IllegalArgumentException e) { // expected. } }
<|startcomment|> why is the same code still present in the SettingsActivity? <|endcomment|> private void enablePhiro() { SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); if (!sharedPreferences.getBoolean(Constants.PHIRO_INITIALIZED, false)) { <START> BaseSettingsActivity.setPhiroSharedPreferenceEnabled(this, true); <END> sharedPreferences.edit().putBoolean(Constants.PHIRO_INITIALIZED, true).apply(); } }
<|startcomment|> We should not raise issues in this case, as we are not certain. As we are not (yet) doing cross-procedural analysis, doing the assumption that we may end up with a null value with necessarily raise à lot of FPs. <|endcomment|> private void checkReturnedValue(ReturnStatementTree tree, String nonNullAnnotation) { SymbolicValue returnedValue = programState.peekValue(); Constraint constraint = programState.getConstraint(returnedValue); if (constraint == null) { <START> reportIssue(tree, "This method''s return value is marked \"{0}\" but null may be returned.", nonNullAnnotation); <END> } else if (constraint.isNull()) { reportIssue(tree, "This method''s return value is marked \"{0}\" but null is returned.", nonNullAnnotation); } }
<|startcomment|> Minor: consider replacing equalTo with is from Hamcrest here and below. <|endcomment|> private void verifyEditResultCode(EditingResult result) { <START> assertThat(result.getResult(), equalTo(SUCCESS)); <END> }
<|startcomment|> should call super(); explicitly <|endcomment|> <START> public EnginesPreferencePage() { <END> }
<|startcomment|> Instead of copying the list and requiring a (potentially) unsafe cast. I think we could make more use of generics in `ClusterManagerCallback`. <|endcomment|> public List<AmbryReplica> getReplicaIds() { <START> return clusterManagerCallback.getReplicaIdsForPartition(this) <END> .stream() .map(r -> (AmbryReplica) r) .collect(Collectors.toList()); }
<|startcomment|> remove? <|endcomment|> private String blockingSSLConnect(int socketBufSize) throws IOException { String connectionId = selector.connect(new InetSocketAddress("localhost", server.port), socketBufSize, socketBufSize, PortType.SSL); while (!selector.connected().contains(connectionId)) { <START> System.out.println("here"); <END> selector.poll(10000L); } return connectionId; }
<|startcomment|> Why does this constructor not simply call the other one? <|endcomment|> <START> public EDDifferentialPrivacy(double epsilon, double delta, <END> DataGeneralizationScheme generalization) { super(delta); this.epsilon = epsilon; this.generalization = generalization; this.beta = calculateBeta(epsilon); this.k = calculateK(getDelta(), epsilon, this.beta); }
<|startcomment|> Can `statement` be null? <|endcomment|> private final String getSessionIndex(Assertion subjectAssertion) { List<AuthnStatement> authnStatements = subjectAssertion.getAuthnStatements(); if(authnStatements != null && authnStatements.size() > 0) { AuthnStatement statement = authnStatements.get(0); <START> return statement.getSessionIndex(); <END> } return null; }
<|startcomment|> I would switch those two conditions. <|endcomment|> public void visitNode(Tree tree) { if (!hasSemantic()) { return; } MethodTree method = (MethodTree) tree; <START> if (!INPUT_STREAM_READ.matches(method) || method.block() == null) { <END> return; } method.accept(new ReturnStatementVisitor()); }
<|startcomment|> Can't be set in xml ? <|endcomment|> protected void onFinishInflate() { super.onFinishInflate(); View.inflate(getContext(), R.layout.merge_login_view, this); loginButton = Views.findById(this, R.id.sign_in_button); <START> loginButton.setSize(SignInButton.SIZE_WIDE); <END> }
<|startcomment|> static <|endcomment|> <START> private int encode(int bucketIndex, int value) <END> { return (bucketIndex << VALUE_BITS) | value; }
<|startcomment|> Are you sure that `getTargetDock().getIdentifier()` is always not `null`? I suggest to rewrite the condition as `!TestToolsPresenter.IDENTIFIER.equals(uberfireDocksInteractionEvent.getTargetDock().getIdentifier())` <|endcomment|> public void onUberfireDocksInteractionEvent(@Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent) { <START> if (isUberfireDocksInteractionEventToManage(uberfireDocksInteractionEvent) && !uberfireDocksInteractionEvent.getTargetDock().getIdentifier().equals(TestToolsPresenter.IDENTIFIER)) { <END> populateRightDocks(uberfireDocksInteractionEvent.getTargetDock().getIdentifier()); } }
<|startcomment|> No, such a feature has not been requested so far. The current state is that each division can be the type of root element. It was discussed that we might later add a possibility that these types can be restricted. In the context, one could also implement the selection of a standard type. <|endcomment|> public String getDocType() { if (Objects.isNull(docType)) { List<SelectItem> allDocTypes = getAllDoctypes(); for (SelectItem item : allDocTypes) { <START> if ("Monograph".equals(item.getValue())) { <END> setDocType((String) item.getValue()); return docType; } } setDocType((String) allDocTypes.get(0).getValue()); } return docType; }
<|startcomment|> why is this needed ? <|endcomment|> <START> public boolean shouldUseCommitTemplate() { <END> return Activator.getDefault().getPreferenceStore() .getBoolean(UIPreferences.COMMIT_DIALOG_MESSAGE_TEMPLATE) && getCommitMessage() == null && getCommitTemplate().isPresent(); }
<|startcomment|> missing exception. either log, rethrow runtime or rename exception ignored. Expand Exception <|endcomment|> public void waitUntilAllBlocked() { try { _blockersDoneLatch.await(); } <START> catch (Exception ex) { <END> } }
<|startcomment|> Why not if (matrixParams.containsKey(param) { ... } ? <|endcomment|> private static boolean hasMatrixParam(List<PathSegment> pathSegments, String param) { if (pathSegments != null) for (PathSegment segement : pathSegments) { MultivaluedMap<String, String> matrixParams = segement.getMatrixParameters(); if (matrixParams != null && !matrixParams.isEmpty()) for (String key : matrixParams.keySet()) { if (key.equals(param)) return true; <START> } <END> } return false; }
<|startcomment|> this is self assignment - please modify to: this.attached = attached <|endcomment|> public void setAttached(boolean attached) { <START> attached = attached; <END> }
<|startcomment|> Stupid question: why long/Long? walk.getTreeDepth() returns int, so why not use Integer (also in the Map, and intValue() above)? <|endcomment|> public void visited(RevObject o) { <START> lowestDepthVisited.put(o, Long.valueOf(walk.getTreeDepth())); <END> }
<|startcomment|> Is this superfluous casting? <|endcomment|> private List<Object[]> convertIntegerToLong(List<Object[]> list, int index) { for (Object[] item : list) { <START> item[index] = new Long((long) item[index]); <END> } return list; }
<|startcomment|> No new for constant object in loop. Either pass null, or construct the instance outside of the looop. <|endcomment|> private void flushAll() throws AuthException { for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) { CacheResource cacheResource = new CacheResource(e.getPluginName(), e.getExportName(), e.getProvider()); if (FlushCache.WEB_SESSIONS.equals(cacheResource.getName())) { continue; } flushCache.get().apply(cacheResource, <START> new FlushCache.Input()); <END> } }
<|startcomment|> I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course) ? <|endcomment|> <START> public static Map<String, IAnalysisModule> getAnalysisModules() { <END> if (fAnalysisModules.isEmpty()) { TmfAnalysisType analysis = TmfAnalysisType.getInstance(); List<IAnalysisModule> modules = analysis.getAnalysisModules(); for (IAnalysisModule module : modules) { fAnalysisModules.add(module); } } return getExecutableModules(); }
<|startcomment|> Spaces. <|endcomment|> void validateValueParameter(String name, Object value) { Class<? extends IValueValidator> validators[] = wrappedParameter.validateValueWith(); <START> if (validators != null && validators.length>0) { <END> for(final Class<? extends IValueValidator> validator: validators) { validateValueParameter(validator, name, value); } } }
<|startcomment|> final? <|endcomment|> <START> public <C> Stream<Match> match(Object object, Captures captures, C context) <END> { if (previous.isPresent()) { return previous.get().match(object, captures, context) .flatMap(match -> accept(object, match.captures(), context)); } else { return accept(object, captures, context); } }
<|startcomment|> Global listener catch each click. You don't need to log it. <|endcomment|> public ArticlePageObject savePage() { waitForElementInViewPort(editSummary); waitForElementInViewPort(reviewChangesButton); waitForElementVisibleByElement(savePanel); publishButton.click(); <START> PageObjectLogging.log("savePage", "The 2nd Publish Button is clicked", true); <END> return new ArticlePageObject(driver); }
<|startcomment|> Please revert. I know it's an IntelliJ warning but why should we tell Java to create an array generically by reflection when we literally know the size beforehand? <|endcomment|> public void executeCommand(CommandSender sender, List<String> arguments) { // Get the list of banned players Set<OfflinePlayer> bannedPlayers = bukkitService.getBannedPlayers(); Set<String> namedBanned = new HashSet<>(bannedPlayers.size()); for (OfflinePlayer offlinePlayer : bannedPlayers) { namedBanned.add(offlinePlayer.getName()); } <START> purgeService.purgePlayers(sender, namedBanned, bannedPlayers.toArray(new OfflinePlayer[0])); <END> }
<|startcomment|> Why do we need to make this public? It should be package scoped, protected would work as well. All Astyanax classes in com.rackspace.blueflood.io.astyanax.\* should be able to call this method without it being public. <|endcomment|> <START> public static Keyspace getKeyspace() { <END> return keyspace; }
<|startcomment|> just for consistency, can we use `final int`? <|endcomment|> void setNewElementYPosition(final Element elementReference, final Element newElement) { <START> int referencePosition = getDndListComponent().getPositionY(elementReference); <END> getDndListComponent().setPositionY(newElement, referencePosition); }
<|startcomment|> I'm not sure if we should fix it in this way. Removing the CTabFolder.layout invocation is a part of the optimization process that is needed to fix the issue exposed by the "JRockit Mission Control " application. It blocks the similar applications to be migrated to the E4 (poor GUI rendering performance) Daniel <|endcomment|> public void layoutTopRight(CTabFolder ctf) { Composite trComp = getTRComposite(ctf); if (trComp.getChildren().length > 0) { trComp.setVisible(true); ctf.setTopRight(trComp, SWT.RIGHT | SWT.WRAP); } else { ctf.setTopRight(null); trComp.setVisible(false); } trComp.pack(); <START> ctf.layout(true, true); <END> }
<|startcomment|> Can we `assert context == null` here? <|endcomment|> ByteBuf buffer() throws IOException { if (buf == null) { buf = Netty4Utils.toByteBuf(context.get()); context = null; <START> } <END> return buf; }
<|startcomment|> Now we have `isEmpty` method for Strings in Utils. Is it good idea to use it here as well? https://github.com/kiegroup/kie-wb-common/blob/master/kie-wb-common-stunner/kie-wb-common-stunner-core/kie-wb-common-stunner-api/kie-wb-common-stunner-core-api/src/main/java/org/kie/workbench/common/stunner/core/util/StringUtils.java <|endcomment|> public String getName() { String name = super.getName(); <START> if (name == null || name.isEmpty()) { <END> return ""; } else { return name; } }
<|startcomment|> minor: put _only_ the statement you expect to fail in `try`. <|endcomment|> private void verifyInvalidValueSize(IndexValue value, String logSegmentName) { try { int capacity = TestUtils.RANDOM.nextInt(value.getBytes().capacity()); ByteBuffer invalidValue = ByteBuffer.allocate(capacity); invalidValue.put(value.getBytes().array(), 0, capacity); <START> new IndexValue(logSegmentName, invalidValue, version); <END> fail( "Contruction of IndexValue expected to fail with invalid byte buffer capacity of " + invalidValue.capacity()); } catch (IllegalArgumentException e) { } }
<|startcomment|> session could be set to null on dispose(). <|endcomment|> void dispose() { if (semanticResourcesUpdater != null) { semanticResourcesUpdater.dispose(); semanticResourcesUpdater = null; <START> } <END> }
<|startcomment|> you can do this things in one line such as ``` new DotConnect().setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE).addParam(type.id()).addParam(type.id()).loadResults(); ``` <|endcomment|> public void deleteByContentType(final ContentTypeIf type) throws DotDataException{ <START> final DotConnect dc = new DotConnect(); <END> dc.setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE); dc.addParam(type.id()); dc.addParam(type.id()); dc.loadResults(); }
<|startcomment|> Is the if block still needed? <|endcomment|> public int getUniqueNotificationId() { if (uniqueNotificationIdCounter == null) { uniqueNotificationIdCounter = new AtomicInteger(0); <START> } <END> return uniqueNotificationIdCounter.incrementAndGet(); }
<|startcomment|> How come not logger.error()? <|endcomment|> public void run() { // Loops till QueueProcessorThread is shutdown while (!shutdown) { synchronized (this) { try { // start processing queue if active, other wait for sometime if (isActive) { processQueuedFlows(activeExecutorRefreshWindowInMilisec, activeExecutorRefreshWindowInFlows); } wait(QUEUE_PROCESSOR_WAIT_IN_MS); } catch (Exception e) { <START> logger.info( <END> "QueueProcessorThread Interrupted. Probably to shut down.", e); } } } }
<|startcomment|> No need to force byte order when wrapping byte[] <|endcomment|> public HllSketchMergeBufferAggregator( final ColumnValueSelector<HllSketch> selector, final int lgK, final TgtHllType tgtHllType, final int size ) { this.selector = selector; this.lgK = lgK; this.tgtHllType = tgtHllType; this.size = size; this.emptyUnion = new byte[size]; //noinspection ResultOfObjectAllocationIgnored (Union writes to "emptySketch" as a side effect of construction) <START> new Union(lgK, WritableMemory.wrap(emptyUnion, ByteOrder.LITTLE_<END>IAN)); <END> }
<|startcomment|> The expected value should be 1st, it affects error messages by junit <|endcomment|> public void checkIPAdress() { Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address)); <START> assertEquals(validate.isEmpty(), expectedResult); <END> }
<|startcomment|> No good idea. ;) <|endcomment|> public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) { try { // Ignore first call, which comes from onCreate() if (currentFormat != null) calc(); } catch (GeopointException e) { <START> context.showToast(e.getMessage()); <END> spinner.setSelection(currentFormat.ordinal()); return; } currentFormat = coordInputFormatEnum.fromInt(pos); settings.setCoordInputFormat(currentFormat); updateGUI(); }
<|startcomment|> why return `false`? <|endcomment|> public boolean visitTableWithType(String schemaName, String tableName, TableType type) { Preconditions .checkNotNull(type, "Error. Type information for table %s.%s provided is null.", schemaName, tableName); records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString())); <START> return false; <END> }
<|startcomment|> Comparing with null is not enough. You might replace an existing attachment with a different instance in which case you should return true. In short if the return is different from the input then something changed. <|endcomment|> public boolean add(XWikiAttachment attachment) { <START> return set(attachment) != null; <END> }
<|startcomment|> ditto: sort by name please <|endcomment|> public String toString() { <START> return Objects.toStringHelper(this).add("liveWorkerNum", mLiveWorkerNum) <END> .add("lostWorkerNum", mLostWorkerNum).add("capacityBytes", mCapacityBytes) .add("usedBytes", mUsedBytes).add("freeBytes", mFreeBytes) .add("capacityBytesOnTiers", mCapacityBytesOnTiers) .add("usedBytesOnTiers", mUsedBytesOnTiers).toString(); }
<|startcomment|> ```suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task)); ``` <|endcomment|> public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) { await().pollInterval(250, TimeUnit.MILLISECONDS) .atMost(10, TimeUnit.SECONDS) <START> .until(() -> !j.jenkins.get().getQueue().isBlockedByShutdown(task)); <END> }
<|startcomment|> The method signature doesn't specify the Exception which could be thrown. <|endcomment|> private TreeLayer <START> getTreeLayer() <END> { NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class); ILayer layer = natTable.getLayer(); if (layer instanceof PapyrusGridLayer) { PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer; ILayer rowLayer = gridLayer.getRowHeaderLayer(); if (rowLayer instanceof RowHeaderHierarchicalLayerStack) { return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer(); } } throw new UnknownError("TreeLayer has not been found"); //$NON-NLS-1$ }
<|startcomment|> return directly <|endcomment|> public boolean equals(@Nullable Object obj) { <START> if (!(obj instanceof DataDrivenValueSelf)) { <END> return false; } return true; }
<|startcomment|> ![MAJOR](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/severity-major.png) Remove this unused "searchInput" local variable. [![rule](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/rule.png)](http://sonar-s1/coding_rules#rule_key=squid%3AS1481) <|endcomment|> public void differentUrlForPostsAndVideo() { <START> SearchInput searchInput = new SearchInput().searchInputValue(); <END> SearchInput searchInputSubmit = new SearchInput().searchInputSubmit(); String URL = driver.getCurrentUrl(); Assert.assertEquals(URL, "http://qa.fandom.wikia.com/?s=TEST"); SearchInput postsResult = new SearchInput().searchResultsPosts(); String postUrl = driver.getCurrentUrl(); SearchInput videosResult = new SearchInput().searchResultsVideos(); String videoUrl = driver.getCurrentUrl(); Assert.assertNotEquals(postUrl, videoUrl); }
<|startcomment|> I would deprecate it and add a new one. <|endcomment|> <START> String convert(Blob blob) { <END> if (blob.getLength() == 0L) { return ""; } try (InputStream stream = blob.getStream()) { Xml2TextHandler xml2text = new Xml2TextHandler(); return xml2text.parse(stream); } catch (IOException | SAXException | ParserConfigurationException e) { throw new ConversionException("Error during XML2Text conversion", e); } }
<|startcomment|> This should be package-level protected: ```suggestion // Visible for testing static void validateHeaderConfigAction(String action) { ``` <|endcomment|> <START> public static void validateHeaderConfigAction(String action) { <END> if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) { throw new ConfigException(String.format("Invalid header config action: '%s'. " + "Expected one of %s", action, HEADER_ACTIONS)); } }
<|startcomment|> `variableMetadata.getName().length()` invocation is redundant. <|endcomment|> private String getVariableLabel(VariableMetadata variableMetadata) { if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) { return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + " " + <START> variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length(), variableMetadata.getName().length()); <END> } else { return variableMetadata.getName(); } }
<|startcomment|> [existsById(long id)](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html#existsById-ID-) 💯 <|endcomment|> private Long findFreeId(){ <START> while(personRepository.findOne(lastId) != null){ // New person <END> lastId++; } return lastId; }
<|startcomment|> Move to setUp(). You can make mCameraId a local variable again. <|endcomment|> public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException { <START> Assume.assumeTrue(mCameraId != null); <END> mUseCase.addStateChangeListener( mCameraRepository.getCamera( getCameraIdForLensFacingUnchecked(mConfig.getLensFacing()))); mUseCase.doNotifyActive(); mCameraRepository.onGroupActive(mUseCaseGroup); // Wait for the CameraDevice.onOpened callback. mUseCase.mDeviceStateCallback.waitForOnOpened(1); mCameraRepository.onGroupInactive(mUseCaseGroup); // Wait for the CameraDevice.onClosed callback. mUseCase.mDeviceStateCallback.waitForOnClosed(1); }
<|startcomment|> Beware that invoking [`getContent(I18N.getLocale())`](https://github.com/FenixEdu/fenixedu-commons/blob/v1.1.0/src/main/java/org/fenixedu/commons/i18n/LocalizedString.java#L461-L475) is different than just invoking [`getContent()`](https://github.com/FenixEdu/fenixedu-commons/blob/v1.1.0/src/main/java/org/fenixedu/commons/i18n/LocalizedString.java#L480-L496). <|endcomment|> public String getDescription() { <START> return getStatuteType().getName().getContent(I18N.getLocale()) <END> + (studentStatute instanceof SeniorStatute ? (" (" + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + ") ") : ""); }
<|startcomment|> Do this and the other method need to be public? Would `protected` suffice? <|endcomment|> <START> public boolean teleportToSpawn() { <END> Location target = server.getWorlds().get(0).getSpawnLocation(); EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null)); if (event.isCancelled()) { return false; } target = event.getTo(); teleport(target); return true; }
<|startcomment|> Can we please have this variable initialized to an empty array so that we can avoid a null check to be done ? <|endcomment|> public String[] getGroupFilters() { <START> String[] result = null; <END> IAnnotation before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class); if (before != null) { result = ((ConfigurationAnnotation) before).getGroupFilters(); } return result; }
<|startcomment|> some of the protected items here can be package private <|endcomment|> <START> protected PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length, <END> long defaultValue, long base ) throws IOException { this.pagedFile = pagedFile; this.entrySize = entrySize; this.entriesPerPage = pagedFile.pageSize() / entrySize; this.length = length; this.defaultValue = defaultValue; this.base = base; try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) ) { setLength( cursorToSetLength, length ); } if ( defaultValue != 0 ) { setDefaultValue( defaultValue ); } }
<|startcomment|> Don't precompute `selectedPositions.getPositions`. It is unnecessary. And it makes the code harder to follow. <|endcomment|> public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions) { this.yieldSignal = requireNonNull(yieldSignal, "yieldSignal is null"); this.blocks = requireNonNull(page, "page is null").getBlocks(); this.selectedPositions = requireNonNull(selectedPositions, "selectedPositions is null"); this.nextIndexOrPosition = selectedPositions.getOffset(); if (selectedPositions.isList()) { this.positions = selectedPositions.getPositions(); } else { this.positions = null; <START> } <END> }
<|startcomment|> this ternary will not behave as stated in the 1. should annotation <|endcomment|> public String getDicomViewerUrl(Study study) { if (study == null) throw new IllegalArgumentException("study cannot be null"); else if (study.getStudyInstanceUid() == null) throw new IllegalArgumentException("studyInstanceUid cannot be null"); <START> return study.isCompleted() ? this.radiologyProperties.getDicomViewerUrl() + "studyUID=" <END> + study.getStudyInstanceUid() : null; }
<|startcomment|> ..and change as well the variable name `declFromXpath` to `declCorrXpath` also here. <|endcomment|> private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) { <START> Declaration declFromXpath = null; <END> if (!isXPath && pattern.hasXPath()) { Declaration xPathDecl = pattern.getXPathDeclaration(); if (xPathDecl != null) { for ( Declaration decl : constraint.getRequiredDeclarations() ) { if (xPathDecl.equals( decl )) { declFromXpath = decl; break; } } } } return declFromXpath; }
<|startcomment|> the parent setQueryTimeout will throw a SQLException if the parameter is invalid, so this method now no longer throws an InvalidParameterSqlException <|endcomment|> public void setQueryTimeout( int seconds ) throws AlreadyClosedSqlException, <START> InvalidParameterSqlException, <END> SQLException { throwIfClosed(); super.setQueryTimeout(seconds); }
<|startcomment|> Please use Java conventions - param <|endcomment|> private List<Disk> manualAggregateSnapshots() { List<Disk> <START> Param = <END> new ArrayList<>(); DiskImage diskWithSnaps = diskWithSnapshots; diskWithSnaps.getSnapshots().addAll(snapshotsList); Param.add(diskWithSnapshots); Param.add(diskWithoutSnapshots); Param.add(ovfImage); Param.add(cinderDisk); return Param; }
<|startcomment|> Enabling indexing even if autoConfig == false? Maybe this auto-enabling should happen only if autoConfig==true? <|endcomment|> public IndexingConfigurationBuilder autoConfig(boolean autoConfig) { <START> enable(); <END> attributes.attribute(AUTO_CONFIG).set(autoConfig); return this; }
<|startcomment|> dao will return either an empty list or populated one, but never null. <|endcomment|> private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) { return <START> CollectionUtils .isNotEmpty(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, <END> VmDeviceGeneralType.HOSTDEV, vfName)); }
<|startcomment|> static <|endcomment|> <START> private void safeCloseStream(Closeable stream) { <END> if (stream != null) { try { stream.close(); } catch (IOException e) { // swallow error in this case Logger.e(TAG, "Failed to close the stream: ", "", ADALError.IO_EXCEPTION, e); } } }
<|startcomment|> How about the following to simplify the string construction below: ```java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME); ``` <|endcomment|> public static String zkSecuritySysConfigString() { String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM); String clientEnabled = System.getProperty(ZK_SASL_CLIENT); <START> String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY); <END> return "[" + JAVA_LOGIN_CONFIG_PARAM + "=" + loginConfig + ", " + ZK_SASL_CLIENT + "=" + (clientEnabled == null ? "default:" + DEFAULT_ZK_SASL_CLIENT : clientEnabled) + ", " + ZK_LOGIN_CONTEXT_NAME_KEY + "=" + (contextName == null ? "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME : contextName) + "]"; }
<|startcomment|> I would recommend returning a boolean, `true` for a successful update and `false` for the "no-op" case <|endcomment|> <START> public void updateNode(final @Nonnull Node node) throws IOException { <END> if (node == nodes.get(node.getNodeName())) { Queue.withLock(new Runnable() { @Override public void run() { jenkins.trimLabels(); } }); persistNode(node); } }
<|startcomment|> The rest of this class expects backStack to be nonnull. I recommend we initialize backStack to an empty mutable list and specify @NonNull in the setter. <|endcomment|> public void onSaveInstanceState(Bundle outState) { <START> if (backStack != null) { <END> // update the topmost entry in the backstack updateCurrentBackStackItem(); outState.putParcelableArrayList("backStack", backStack); } }
<|startcomment|> Is this necessary? <|endcomment|> public Trader(String name, double cashInHand) { <START> super(); <END> this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); }
<|startcomment|> There can only be one associated task. <|endcomment|> <START> private Iterable<ITask> getTasksAssosciatedWithReviewTask(ITask reviewTask) { <END> String lookupUrl = reviewTask.getUrl(); // TODO: Fetch from mapping with the lookupUrl String taskUrl = "http://someurl"; AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager() .getConnectorForRepositoryTaskUrl(taskUrl); String taskId = repository.getTaskIdFromTaskUrl(taskUrl); String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl); ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId); if (assosciatedTask == null) { return Collections.emptyList(); } return ImmutableSet.of(assosciatedTask); }
<|startcomment|> Override <|endcomment|> <START> protected void toLegacyText(StringBuilder builder) <END> { builder.append(this.value); }
<|startcomment|> `public static boolean isRoute(final URL url)` <|endcomment|> <START> public static boolean isRoute(URL url) { <END> return ROUTE_PROTOCOL.equals(url.getProtocol()) || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY)); }
<|startcomment|> I would delete this synchronized block. Values cannot be modified while we're reading it since we already saw state as 2. It's also OK to move the prior accesses to values to before the synchronized blocks they are currently in, but it may be a better test without doing that. <|endcomment|> void thread2() { int[] vs1; synchronized (lock) { vs1 = values; state = 1; } int s; do { synchronized (lock) { s = state; } } while (s != 2); // Busy loop. int[] vs2; <START> synchronized (lock) { <END> vs2 = values; } int v1 = vs1[0]; int v2 = vs2[0]; System.out.println("b17689750TestMonitor failed: " + v1 + ", " + v2); }
<|startcomment|> Isn't it easier to have the serializationService as a field on this test? Are there any serializationServices created with different settings? Having it as field instead of local variable, will simplify the test methods. <|endcomment|> public void testWriteAndReadObject() throws Exception { <START> InternalSerializationService serializationService = new DefaultSerializationServiceBuilder().build(); <END> String expected = "test input"; String actual = (String) writeAndReadObject(serializationService, expected); assertNotNull(actual); assertEquals(expected, actual); }
<|startcomment|> please add braces for the else block. <|endcomment|> public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } final ArArchiveEntry other = (ArArchiveEntry) obj; if (name == null) { return other.name == null; <START> } else return name.equals(other.name); <END> }
<|startcomment|> why do you need to wrap it in a new `ArrayList`? Seems wasteful. <|endcomment|> public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) { if (bufferList == null || bufferList.isEmpty()) { throw new IllegalArgumentException("Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"); } <START> buffers = new ArrayList<>(bufferList); <END> size = computeSize(bufferList); }
<|startcomment|> I don't know if it's necessary to log this message for each host, since for other unmet conditions we don't log anything. If it looks necessary to you then at least VDS ID would be helpful to know (assuming VM ID is already printed elsewehere). <|endcomment|> boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces, final List<VdsNetworkInterface> allInterfacesForVds) { for (final VmNetworkInterface vmIf : vmNetworkInterfaces) { boolean found = false; for (final VdsNetworkInterface vdsIf : allInterfacesForVds) { if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) { found = true; break; } } if (!found) { <START> log.debug("VDS is not ok for running the VM as network is missing"); <END> return false; } } return true; }
<|startcomment|> Never catch exceptions in test code unless you actually want to do something use. Just declare that this method throws Exception <|endcomment|> public void testStash() { try { // 1) call stash create command git.stashCreate().call(); readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); // 2) call stash list git.stashList().call(); // 3) apply stash git.stashApply().call(); // 4) verify stash applied by outputting file readFile("Stash Created", git.getRepository().getWorkTree() + "/File1.txt"); <START> } catch (Exception e) { <END> e.printStackTrace(); } }
<|startcomment|> Can we include the information from `e` in this exception message? <|endcomment|> public List<WorkerInfo> getWorkerInfoList() throws UnavailableException { if (mSafeModeManager.isInSafeMode()) { throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage()); } try { return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY); } catch (ExecutionException e) { <START> throw new UnavailableException("Unable to get worker info list from cache"); <END> } }
<|startcomment|> Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback. <|endcomment|> public static void tearDownTestCase() throws Exception { if(dataSource != null) { Connection con = dataSource.getConnection(); if(con != null) { // rollback any changes done to DB during the test case execution <START> con.rollback(); <END> } } }
<|startcomment|> Why do we have equality check here? it should have been done by the equals. <|endcomment|> public void checkSelectFilter(final String label, final String value) { selectInputs.computeIfPresent(label, (key, values) -> { values.forEach(i -> { <START> if ((i.getValue().equals(value) || i.getValue() == value) && i.getChecked() == false) { <END> i.setChecked(true); } }); return values; }); }
<|startcomment|> needed? <|endcomment|> public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) { <START> super(); <END> this.storageJobId = storageJobId; this.subchainInfo = subchainInfo; }
<|startcomment|> I think we don't need to check this, as we know that the resize will not result in the threshold being exceeded. <|endcomment|> private void putResize (K key, V value) { K[] keyTable = this.keyTable; V[] valueTable = this.valueTable; for (int i = place(key); ; i = (i + 1) & mask) { // space is available so we insert and break (resize is later) if (keyTable[i] == null) { keyTable[i] = key; valueTable[i] = value; break; } } <START> if (++size >= threshold) { <END> resize(keyTable.length << 1); } }
<|startcomment|> This isn't canModifyData. I think you've overloaded the variable for too many meanings. What we need is: * canModifyDescription * canModifyMergeType * canModifyAgreements * canModifyAccess The first 3 are true only if projectControl.isOwner() is true. The last one is true if projectControl.isOwnerAnyRef() is true, and is what you want to be using here for addPanel. <|endcomment|> protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.projectDetail(projectName, new GerritCallback<ProjectDetail>() { public void onSuccess(final ProjectDetail result) { enableForm(true); display(result); <START> addPanel.setVisible(result.canModifyData); <END> delRight.setVisible(result.canModifyData); } }); }
<|startcomment|> Why not use `EncodeFormat.valueOf` <|endcomment|> public static EncodeFormat checkedValueOf(String name) { try { <START> return Enum.valueOf(EncodeFormat.class, name); <END> } catch (Exception ex) { VoltDB.crashLocalVoltDB("Illegal encoding format " + name, true, ex); } return null; }
<|startcomment|> Minor: there is a shortcut `toObject()` method for doing the deserialization in this class and in `DefaultQueryCache`. Maybe that should be used to be consistent at all places. <|endcomment|> public Set<K> keySet(Predicate predicate) { checkNotNull(predicate, "Predicate cannot be null!"); Set<K> resultingSet = new HashSet<K>(); Set<QueryableEntry> query = indexes.query(predicate); if (query != null) { for (QueryableEntry entry : query) { <START> K key = (K) serializationService.toObject(entry.getKeyData()); <END> resultingSet.add(key); } } else { doFullKeyScan(predicate, resultingSet); } return resultingSet; }
<|startcomment|> also a tiny thing, but sometimes you miss a whitespace after the `->` <|endcomment|> public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception { ClassWithBadGetter oo = new ClassWithBadGetter(); oo.setMyLocations(new HashSet<>()); <START> Assertions.assertThrows(APIException.class,() ->RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField("locations"))); <END> }
<|startcomment|> This should be declared in GerritGlobalModule. <|endcomment|> protected void configure() { <START> DynamicSet.setOf(binder(), CacheRemovalListener.class); <END> install(new FactoryModule() { @Override protected void configure() { factory(ForwardingRemovalListener.Factory.class); } }); bind(DefaultCacheFactory.class); bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class); bind(PersistentCacheFactory.class).to(H2CacheFactory.class); listener().to(H2CacheFactory.class); }
<|startcomment|> This doesn't seem right: we're building `disabledImage` from `image`, so we need to check that `image` has not been disabled. I think something like the following? if (this.image != null && !this.image.isDisposed()) { if (this.disabledImage != null && !this.disabledImage.isDisposed()) { this.disabledImage.dispose(); } disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); } <|endcomment|> private void createDisabledImage() { <START> if (this.disabledImage != null && !this.disabledImage.isDisposed()) <END> disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE); }
<|startcomment|> Should probably be sample.clear(). <|endcomment|> public synchronized void releaseSample(DecoderInputBuffer sample) { <START> sample.data.clear(); <END> mSamplePool.offerLast(sample); }
<|startcomment|> Looks like this builder just concatenate 3 strings without any loops. I guess, it is unnecessary here. <|endcomment|> private String buildClipboardMessage(Row row) { <START> StringBuilder builder = new StringBuilder(); <END> builder.append(row.getLevel()) .append(", ") .append(row.getMessage()); return builder.toString(); }
<|startcomment|> Since a Tombstone is no longer in the hierarchy (result of removing the proxy), this method should probably either return a null or throw an exception <|endcomment|> <START> public RepositoryObject getParent() { <END> return driver.getParentObject(this); }
<|startcomment|> no braces here, more occurrences in this file <|endcomment|> private void setLastUsedBranch() { String lastBranch = settings.get(lastBranchKey); <START> if (lastBranch != null) { <END> branchText.setText(lastBranch); } }
<|startcomment|> `this` is not needed? <|endcomment|> public String toString() { return toStringHelper(this) .omitNullValues() <START> .add("equiCriteria", this.equiCriteria) <END> .add("filter", filter.orElse(null)) .toString(); }
<|startcomment|> Seems more appropriately `logger.warn`. <|endcomment|> private void validateKeyPatternsInConfig(Dictionary<String, ?> config) { Enumeration<String> keys = config.keys(); while (keys.hasMoreElements()) { String key = keys.nextElement(); // the config-key enumeration contains additional keys that we // don't want to process here ... if ("service.pid".equals(key)) { continue; } Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key); if (!matcher.matches()) { logger.error("Given plugwise-config-key '" + key <START> + "' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'"); <END> continue; } } }
<|startcomment|> `GraphvizPrinter` (and all other plan printer) should not expect an `Expression`. Rather than having `isExpression` here, let's fix the tests if they are failing. <|endcomment|> public Void visitFilter(FilterNode node, Void context) { <START> String expression = isExpression(node.getPredicate()) ? node.getPredicate().toString() : formatter.formatRowExpression(node.getPredicate()); <END> printNode(node, "Filter", expression, NODE_COLORS.get(NodeType.FILTER)); return node.getSource().accept(this, context); }
<|startcomment|> Move this line after logging the error, so in any case the error get logged. <|endcomment|> public void run() { resetGlobalProgress(); indexingAll = true; for (ObjectType objectType : ObjectType.values()) { startIndexing(objectType); } try { sleep(pause); } catch (InterruptedException e) { <START> Thread.currentThread().interrupt(); <END> logger.error("Thread interrupted: " + e.getMessage()); } currentIndexState = ObjectType.NONE; indexingAll = false; pollingChannel.send(INDEXING_FINISHED_MESSAGE); }
<|startcomment|> `return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA()));` <|endcomment|> public boolean isAC3() { <START> return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".equals(getCodecA()) || "liba52".equals(getCodecA())); <END> }
<|startcomment|> redundant <|endcomment|> ShardRewriter createShardRewriter( FileSystemContext fileSystemContext, FileSystem fileSystem, long transactionId, OptionalInt bucketNumber, UUID shardUuid, int shardRowCount, Optional<UUID> deltaShardUuid, boolean tableSupportsDeltaDelete, Map<String, Type> columns) { if (tableSupportsDeltaDelete) { return new DeltaShardRewriter( shardUuid, shardRowCount, deltaShardUuid, deletionExecutor, transactionId, bucketNumber, this, fileSystemContext, fileSystem); } <START> else { <END> return new InplaceShardRewriter( shardUuid, columns, deletionExecutor, transactionId, bucketNumber, nodeId, this, fileSystem, storageService, shardRecorder, backupManager); } }
<|startcomment|> TEXT datatype would be more appropriate. <|endcomment|> public void init() { setLabel("Plugin"); addAttribute(ID, ROLE_ID).setLabel("Identifier"); addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel("Label"); <START> addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel("Description").setDataType(HTML); <END> }
<|startcomment|> Space between IOException and { <|endcomment|> <START> @Override public Long call() throws IOException{ <END> String oldname = Thread.currentThread().getName(); Thread.currentThread().setName(oldname+"Decode-"+this.parent.columnChunkMetaData.toString()); this.parent.processPages(recordsToReadInThisPass); Thread.currentThread().setName(oldname); return recordsToReadInThisPass; }
<|startcomment|> Does additional list creation (`new ArrayList<>()`) provide any benefits when compared with the following? ```java this.collectors = asList(collectors); ``` <|endcomment|> public CompositeMetricsCollector(MetricsCollector... collectors) { <START> this.collectors = new ArrayList<>(asList(collectors)); <END> }
<|startcomment|> to nitpick: just use `this` instead of the application. <|endcomment|> @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_READ_CONTACTS) { if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) { loadContacts(); } else { <START> Toast.makeText(getApplicationContext(), "Read contacts permission denied", <END> Toast.LENGTH_LONG).show(); finish(); } } else { super.onRequestPermissionsResult(requestCode, permissions, grantResults); } }
<|startcomment|> I must be missing something. Why not simply buffer.append("body {color:"); appendColor(buffer, fgRGB); buffer.append("; background-color:"); appendColor(buffer, bgRGB); buffer.append(";}"); ? <|endcomment|> private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) { StringBuilder fg= new StringBuilder(); appendColor(fg, fgRGB); StringBuilder bg= new StringBuilder(); appendColor(bg, bgRGB); <START> buffer.append("body {color:" + fg.toString() + "; background-color:" + bg.toString() + ";}"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ <END> }
<|startcomment|> what .... synchronized access to the VoltDB instance not cool. it has transaction performance impact if you want to initialize without invoking the full thing we can do that without having to resource to this <|endcomment|> <START> public static synchronized VoltDBInterface instance() { <END> if (singleton == null) { singleton = new RealVoltDB(); } return singleton; }
<|startcomment|> You can simplify this by reordering the states. <|endcomment|> public int getRenderState() { int state = speed.ordinal(); if (getReverse()) state = 14; if (isPowered()) { if (getReverse()) state += 1; else state += 7; <START> } <END> return state; }
<|startcomment|> Den cast auf (Errors) ist hier überflüssig. <|endcomment|> public void ensureSettingsSavedShowsFormIfValidationFails() throws Exception { doAnswer(invocation -> { <START> Errors errors = (Errors) invocation.getArgument(1); <END> errors.rejectValue("absenceSettings", "error"); return null; }).when(settingsValidator).validate(any(), any()); perform(post("/web/settings")) .andExpect(view().name("settings/settings_form")); }
<|startcomment|> I know this is not directly part of this PR, but this could be changed to `new StringBuilder(iOSVariant.getVariantID())` to avoid one useless `append` (the `StringBuilder()` constructor create StringBuilder with capacity 16, that we immediately expand with the next append) <|endcomment|> private String extractConnectionKey(final iOSVariant iOSVariant) { final StringBuilder sb = new StringBuilder() <START> .append(iOSVariant.getVariantID()) <END> .append(iOSVariant.isProduction() ? "-prod" : "-dev"); return sb.toString(); }
<|startcomment|> Use logger instead for sysout for logging. <|endcomment|> public void printCertificates() { DefaultTable table = new DefaultTable(); for (int i = 0; i < table.rowCount(); i++) { <START> System.out.println("On index " + i + " is : " + table.getItem(i).getText(1)); <END> } }
<|startcomment|> can we revert back to using `LockMode.X` instead of `LockResource.LockMode.X`? <|endcomment|> public void lockEdge() throws Exception { edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.READ, true); edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.WRITE, true); edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.WRITE, true); <START> edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.READ, false); <END> }
<|startcomment|> cast to busimpl should not be needed. getClientId is on the ClientMessageBus interface, no? <|endcomment|> private String getClientId() { <START> return ( (ClientMessageBusImpl) clientMessageBus ).getClientId(); <END> }
<|startcomment|> Are you sure VdsInstallException is the right exception here? <|endcomment|> private void configureManagementNetwork() { final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds()); if (networkConfigurator.awaitVdsmResponse()) { try { networkConfigurator.refreshNetworkConfiguration(); networkConfigurator.createManagementNetworkIfRequired(); } catch (VDSNetworkException e) { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); <START> } catch (VdsInstallException e) { <END> throw new VdsInstallException(VDSStatus.NonOperational, "Failed to configure manamgent network on the host"); } } else { throw new VdsInstallException(VDSStatus.NonResponsive, "Network error during communication with the host"); } }
<|startcomment|> I think you forgot to change this to - `return newResetResponse(header, newNoServerError());` <|endcomment|> <START> public static Response newResetResponse(Header header) { return newRestartResponse(header, newNoServerError()); } <END>
<|startcomment|> Why does this need to be `static`? <|endcomment|> <START> private static Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) { <END> if (!primaryValue.isPresent()) { return safetyValue; } return primaryValue; }
<|startcomment|> This should be a constant, not a magic string. <|endcomment|> public Uris(String scheme, String host) { this.scheme = scheme; this.host = host; this.port = 0; <START> this.rcnamespace = "0|120"; <END> }
<|startcomment|> can change the order to save a temp variable s. <|endcomment|> private void carryOntoHistory(RevCommit c, int carry) { stack = null; for (;;) { carryOntoHistoryInnerLoop(c, carry); CarryStack s = stack; if (s != null) { <START> stack = s.prev; c = s.c; carry = s.carry; <END> continue; } break; } }
<|startcomment|> Could be just ksession.insert(String.valueOf(i)); <|endcomment|> private FactHandle[] insertFacts(KieSession ksession, int n) { FactHandle[] fhs = new FactHandle[n]; for (int i = 0; i < n; i++) { fhs[i] = ksession.insert(i); <START> ksession.insert("" + String.valueOf(i)); <END> } return fhs; }
<|startcomment|> This will create a new instance every time. Cache the instance in a member variable? <|endcomment|> public SecureStore get() { <START> return injector.getInstance(getSecureStoreImpl()); <END> }
<|startcomment|> if (swingTransferable != null && getScoutObject() != null) {...} <|endcomment|> protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) { if (getUpdateSwingFromScoutLock().isAcquired()) { return; } // if (swingTransferable != null) { <START> if (getScoutObject() != null) { <END> final ITreeNode scoutNode = treePathToScoutNode(path); // notify Scout (asynchronous !) Runnable t = new Runnable() { @Override public void run() { getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode); } }; getSwingEnvironment().invokeScoutLater(t, 0); // end notify } } }
<|startcomment|> I don't see this called anywhere in the patch. Is there a reason to make it public? <|endcomment|> <START> public void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) { <END> validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold); this.diskUsageThreshold = diskSpaceThreshold; this.diskUsageWarnThreshold = diskUsageWarnThreshold; }
<|startcomment|> not needed unboxing <|endcomment|> public static void setInstance(Object source, @MappingTarget Object target) { Integer level = LEVEL.get(); fireMethodCalled( level, "setInstance", source, target ); if ( level == null ) { LEVEL.set( 1 ); MAPPING.set( new IdentityHashMap<Object, Object>() ); } else { <START> LEVEL.set( level.intValue() + 1 ); <END> } MAPPING.get().put( source, target ); }
<|startcomment|> Remove throws MiddlewareQueryException <|endcomment|> <START> public List<StandardPreset> getAllStandardPresets() throws MiddlewareQueryException { <END> return this.workbenchDataManager.getStandardPresetDAO().getAll(); }
<|startcomment|> why did you change this? <|endcomment|> protected void executeVDSCommand() { if (_vdsManager != null) { try { <START> _vdsManager.getLockObj().lock(); <END> executeVdsIdCommand(); } finally { _vdsManager.getLockObj().unlock(); } } else { executeVdsIdCommand(); } }
<|startcomment|> Could you use `List#of` or `Collections#singletonList`? <|endcomment|> public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException { TemplateSourceDocument templateSrc = createTemplateSourceDoc("We are introducing ${myStringInCtxt} !", WEBVIEW_R<END>ITION); TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc()); <START> List<TemplateInput> params = Arrays.asList( <END> factory("myStringInCtxt", StringValue, "Beautiful String") ); templateBase.saveParams(TEMPLATE_NAME, params, true); Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME); assertNotNull(result); assertEquals("We are introducing Beautiful String !", result.getString()); }
<|startcomment|> Wonder if this would work/read better if PDPrintStyle had the default values itself and we could just return early instead of creating new objects to make the rest of the code work properly. <|endcomment|> public static PDPrintStyle getLineStyle (JSONObject oskariStyle) { PDPrintStyle style = new PDPrintStyle(); <START> JSONObject stroke = JSONHelper.optJSONObject(oskariStyle, "stroke", () -> new JSONObject()); <END> setStrokeStyle(style, stroke); // polygon doesn't have cap style setLabelStyle(style, oskariStyle); style.setLineCap(LINE_CAP_STYLE.getOrDefault(JSONHelper.optString(stroke,"lineCap"), 0)); return style; }
<|startcomment|> All of the methods on this class should be `synchronized`. Otherwise this change looks good. <|endcomment|> public static void init(Configuration conf) { if (!initDone) { DefaultConfiguration.conf = conf; DefaultConfiguration.initDone = true; <START> } <END> }
<|startcomment|> We return even if this is false. Should we do something in the else case? <|endcomment|> private void rollBackToTimestamp(long timestamp) { if (getVersionUnsafe() > timestamp) { try { rollbackObjectUnsafe(timestamp); // Rollback successfully got us to the right // version, we're done. <START> if (getVersionUnsafe() == timestamp) { <END> return; } } catch (NoRollbackException nre) { log.warn("Rollback[{}] to {} failed {}", this, timestamp, nre); resetUnsafe(); } } }
<|startcomment|> Nit: I think `new KafkaProducer<>(options)` will work here <|endcomment|> public void prepare(Properties options) { Objects.requireNonNull(mapper, "mapper can not be null"); Objects.requireNonNull(topicSelector, "topicSelector can not be null"); <START> producer = new KafkaProducer<K, V>(options); <END> }
<|startcomment|> this must be disposed <|endcomment|> protected Control createSWTControl(Composite parent) throws DatabindingFailedException { final Control control = super.createSWTControl(parent); <START> final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { <END> new ReflectiveItemProviderAdapterFactory(), new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) }); adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory); return control; }
<|startcomment|> `else` is redundant here. <|endcomment|> public boolean isRegistered(VeluxProduct product) { logger.trace("isRegistered(VeluxProduct {}) called.", product.toString()); if (product.isV2()) { return isRegistered(product.getSerialNumber()); <START> } else { <END> return isRegistered(product.getProductUniqueIndex()); } }
<|startcomment|> You can call the value just `value` <|endcomment|> public void tearDown() throws Exception { FileUtils.deleteQuietly(nuxeoHome); // Restore or clear all the system properties manipulated by the current test <START> originSystemProps.forEach((key, originValue) -> { <END> if (originValue == null) { System.clearProperty(key); } else { System.setProperty(key, originValue); } }); originSystemProps.clear(); }
<|startcomment|> Are these two lines of definitions necessary? Isn't it shorter to just use module.getLabel().getState() in assert? <|endcomment|> private void checkDeployedProject(String projectName) { ServersView2 serversView = new ServersView2(); serversView.open(); ServerModule module = serversView.getServer(FULL_SERVER_NAME) .getModule(new RegexMatcher(".*" + projectName + ".*")); new WaitUntil(new ServerModuleHasState(module, ServerState.<START>ED), TimePeriod.getCustom(30)); ModuleLabel moduleLabel = module.getLabel(); ServerState moduleState = moduleLabel.getState(); <START> assertTrue("Module has not been started!", moduleState == ServerState.<START>ED); <END> }
<|startcomment|> Oh please, no! Don't ship a null object! :cry: <|endcomment|> SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) { <START> return new StandardSlackService(baseUrl, teamDomain, null, authTokenCredentialId, botUser, room); <END> }
<|startcomment|> I would move this one first. <|endcomment|> private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) { if ( annotatedType instanceof AnnotatedParameterizedType ) { for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) { if ( isAnnotationPresent( type, processedAnnotations ) ) { return true; } } } <START> if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) { <END> return true; } return false; }
<|startcomment|> int func(); <|endcomment|> static int staticFunc() { InvokeStatic f = new InvokeStatic() { // Noncompliant @Override <START> public String func(int n) { <END> unknown(); staticFunc(); return 0; } }; return f.func(); }
<|startcomment|> But we are moving to UNJOINED anyway, so it won't affect the result right? <|endcomment|> private synchronized void resetGeneration() { this.generation = Generation.NO_GENERATION; rejoinNeeded = true; // only reset the state to un-joined when it is not already in rebalancing <START> if (state != MemberState.REBALANCING) <END> state = MemberState.UNJOINED; }
<|startcomment|> why you need this here? <|endcomment|> public Path generateArtifact(URI uri, int size) throws IOException { <START> new NpmPackageGenerator(Paths.get(uri)); <END> buildPublishJson(); return getPackagePath(); }
<|startcomment|> Minor nit, declaring a new Random each time is not really good practice. <|endcomment|> public void nextTuple() { Utils.sleep(100); <START> Random rand = new Random(); <END> Integer value = rand.nextInt(1000); collector.emit(new Values(value)); }
<|startcomment|> these 3 methods are `public` do you really need them? <|endcomment|> <START> public void register(final Class<?> clazz, final Object converter) { <END> otherWord = ""; }
<|startcomment|> Why are we setting it to true during indexing? <|endcomment|> public void testMarkerOnLastLineNoNewline_495842() throws Exception { try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("", false)))) { writer.write(getAboveComment().trim()); } <START> PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true); <END> indexFiles(); PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false); String result = runQuickFixOneFile(); assertContainedIn("int func() { } // @suppress(\"No return\")", result); }
<|startcomment|> What is the Log.e for? <|endcomment|> public void onLanguageTabSelected(String selectedLanguageCode) { <START> Log.e("####", "HERE"); <END> searchLanguageCode = selectedLanguageCode; startSearch(query, query != null && query.length() > 1); }
<|startcomment|> Move the tag to a constant? <|endcomment|> public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter) { <START> Log.d("Logging EntityProcessor", "before insert"); <END> T result = mDelegate.insert(db, entityAdapter, isSyncAdapter); Log.d("Logging EntityProcessor", "after insert on " + entityAdapter.id()); return result; }
<|startcomment|> This won't copy the map? <|endcomment|> protected UfsStatus(UfsStatus status) { mIsDirectory = status.mIsDirectory; mName = status.mName; mOwner = status.mOwner; mGroup = status.mGroup; mMode = status.mMode; mLastModifiedTimeMs = status.mLastModifiedTimeMs; <START> mXAttr = status.mXAttr; <END> }
<|startcomment|> if repository is null, this will throw an NPE. <|endcomment|> boolean isProjectStyle() { if (myIsFrameworkStyle) { return false; } ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true); assert repository != null : <START> repository.getDisplayName(); <END> return repository.hasResourceItem(ResourceType.STYLE, myStyleName); }
<|startcomment|> Let's use @CacheEvict(value="userSearchLocales") public User saveUser(User user, String password) instead. We will get rid of CacheManager in Context as well. It would be better to evict just for the specified user, but our key consists of user and currentLocale. SaveUser is not called that often so invalidating all entries is no issue anyway. <|endcomment|> public void setUserProperty(String prop, String value) { getUserProperties().put(prop, value); <START> Context.clearCacheForCurrentUser(); <END> }
<|startcomment|> You can revert this change because you don't need it in this specific class. <|endcomment|> JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) { this.processor = processor; this.xmlPathInJar = xmlPathInJar; //Ensure that dynamic list operations supported <START> this.testNames = (testNames == null ? null : new ArrayList<>(testNames)); <END> }
<|startcomment|> will properties provider return the defaultValue in case of no network or value not found ? <|endcomment|> public String resolve(String variable, String defaultValue) { IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver(); //ignoring argument here, as we want to fall back on the propertiesProvider. String result = delegate.resolve(variable, null); if (result == null) { try { <START> result = propertiesProvider.getValue(variable, defaultValue, new NullProgressMonitor()); <END> } catch (CoreException e) { throw new ExpressionResolutionException(e); } } return result; }
<|startcomment|> you can simply return the result of anyMatch without the 'if' and 'return true/false' statements. imo, it would also be nicer to extract the "i -> i.getDiskVmElementForVm(vmBase.getId()).getDiskInterface() == DiskInterface.VirtIO_SCSI" part to a separate method "isVirtioScsiDisk" to make it easier to read <|endcomment|> public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) { if (vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId()) .getDiskInterface() == DiskInterface.VirtIO_SCSI)) { return true; } <START> return false; <END> }
<|startcomment|> Is there a reason for using `Locale.FRENCH`? Also, why is it needed to remove all spaces? Are you just trying to do a `trim()`, or are you removing spaces between words? <|endcomment|> public void setContext(String context){ <START> typingRule.setContext(BloodTestContext.valueOf(context.replaceAll("\\s","").toUpperCase(Locale.FRENCH))); <END> }
<|startcomment|> close already done in Util.read(..) <|endcomment|> private String readClasspathResource(String c) throws IOException { InputStream is = getClass().getResourceAsStream(c); try { return Util.read(is); } finally { if (is != null) { <START> is.close(); <END> } } }
<|startcomment|> can be inlined <|endcomment|> protected void build(UnitVmModel frontend, VM backend) { <START> String name = (String) frontend.getName().getEntity(); <END> VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem(); backend.setVmtGuid(template.getId()); backend.setName(name); backend.setVmDescription((String) frontend.getDescription().getEntity()); backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity()); }
<|startcomment|> @mavrk one test should only be for one method and one combination of parameters. and the goal is that every public method in the service layer is tested. so you should write tests for the methods * getAllDrugs() * getAllDrugs(includeRetired) and for the latter you need one test passing true and one passing false. another case is also what if there are no drugs will it return an empty list? I know this is tedious but thats because when this was written [TDD|https://en.wikipedia.org/wiki/Test-driven_development] which would start with tests wasnt used. <|endcomment|> public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception { int resultWhenTrue = 4; int resultWhenFalse = 2; List<Drug> allDrugs = conceptService.getAllDrugs(); assertEquals(resultWhenTrue, allDrugs.size()); <START> allDrugs = conceptService.getAllDrugs(false); <END> assertEquals(resultWhenFalse, allDrugs.size()); }
<|startcomment|> those inner classes make reading all of this much worse <|endcomment|> public List<BithumbTransactionHistoryResponse.BithumbTransactionHistory> getBithumbTrades( CurrencyPair currencyPair) throws IOException { <START> final BithumbResponse<List<BithumbTransactionHistoryResponse.BithumbTransactionHistory>> <END> transactionHistory = bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair)); return transactionHistory.getData(); }
<|startcomment|> `mChildren` could be `null` <|endcomment|> public void addChild(String name, Long id) { <START> if (mChildren.put(name, id) == null) { <END> mWeight.incrementAndGet(); } }
<|startcomment|> nit: This will result in double logging <|endcomment|> static void reTryKerberos(boolean enabled) { if (enabled) { log.debug("Try relogin kerberos at first!"); try { if (UserGroupInformation.isLoginKeytabBased()) { UserGroupInformation.getLoginUser().reloginFromKeytab(); } else if (UserGroupInformation.isLoginTicketBased()) { UserGroupInformation.getLoginUser().reloginFromTicketCache(); } } catch (IOException e) { <START> log.error("Try relogin kerberos failed!"); <END> throw new RuntimeException(e); } } }
<|startcomment|> braces <|endcomment|> void resetLogic() { for (int i = 0; i < fieldSize; i++) <START> for (int j = 0; j < fieldSize; j++) fieldArray[i][j] = 0; <END> playerMark = CROSS_MARK; aIMark = ZERO_MARK; turn = 0; //first turn autoGameEnabled = false; }
<|startcomment|> Could you replace `Arrays#stream` by `Stream#of` for consistency ? <|endcomment|> protected Stream<URL> listBundleComponents(Bundle bundle) { String list = OSGiRuntimeService.getComponentsList(bundle); String name = bundle.getSymbolicName(); log.debug("PartialBundle: " + name + " components: " + list); if (list == null) { return Stream.empty(); } else { <START> return Arrays.stream(list.split("[, \t\n\r\f]")).map(bundle::getEntry).filter(Objects::nonNull); <END> } }
<|startcomment|> Please use assertj assertion. In case of fail it gives error message explaining different list sizes. Current implementation will just print assertion error, expected true but was false with no reference to list size. <|endcomment|> public void testLoadDataObjectsWithNonNullWorkspaceProject() { <START> assertTrue(dataObjectsService.loadDataObjects(workspaceProject).isEmpty()); <END> }
<|startcomment|> Why this function is public ? It will be used outside of this class ? <|endcomment|> <START> public Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) { <END> Graphics2D g2 = img.createGraphics(); if (backgroundColor != null) { g2.setBackground(backgroundColor); g2.clearRect(0, 0, width, height); } ImageRenderer renderer = new ImageRenderer(); renderer.draw(mt, g2, width, height, rootLayer, pm); return g2; }
<|startcomment|> Not needed, delete. <|endcomment|> public static void refreshResources(IResource[] resources, IProgressMonitor monitor) throws CoreException { try { SubMonitor progress = SubMonitor.convert(monitor, CoreText.ProjectUtil_refreshing, resources.length); for (IResource resource : resources) { if (progress.isCanceled()) break; resource.refreshLocal(IResource.DEPTH_INFINITE, progress.newChild(1)); <START> progress.worked(1); <END> } } finally { monitor.done(); } }
<|startcomment|> we can just use 'return false' instead of 'else return false' <|endcomment|> private boolean isInSelection(Event event) { if (selection.x == selection.y) return false; int offset = getOffsetAtPoint(event.x, event.y, null, true); if (selection.x <= offset && offset < selection.y) return true; <START> else return false; <END> }
<|startcomment|> Is the throws Exception needed here? <|endcomment|> <START> public void setUp() throws Exception { cuMarshalService = new CUMarshalServiceImpl(); xmlFile = new File(EXAMPLE_FILE_NAME); } <END>
<|startcomment|> System.out? Booh! <|endcomment|> public void actionPerformed(ActionEvent e) { if(e.getSource() == okButton){ //controller should be passed to this class only if there is need to modification content of Keystore. <START> System.out.println(certControll); <END> if (certControll != null) { certControll.setAddToKeystore(true); } this.dispose(); }else if(e.getSource() == cancelButton){ if (certControll != null) { certControll.setAddToKeystore(false); } this.dispose(); } }
<|startcomment|> instead of initializing `filterSteps` in `initFilterSteps` could you do the following? ``` filterSteps = createFilterSteps(buildTarget, goToolchain, platform, fileTypes); ``` <|endcomment|> public FilteredSourceFiles( List<Path> rawSrcFiles, BuildTarget buildTarget, GoToolchain goToolchain, GoPlatform platform, List<FileType> fileTypes) { this.rawSrcFiles = rawSrcFiles; this.extraSrcFiles = new ArrayList<>(); <START> initFilterSteps(buildTarget, goToolchain, platform, fileTypes); <END> }
<|startcomment|> Isn't this already present elsewhere in biojava? <|endcomment|> <START> public static char complementBase(char base, boolean RNA) { <END> if (base == 'A' && RNA) return 'U'; if (base == 'A') return 'T'; if (base == 'T' && !RNA) return 'A'; if (base == 'U' && RNA) return 'A'; if (base == 'C') return 'G'; if (base == 'G') return 'C'; return ' '; }
<|startcomment|> Replace with `this(in, null)` <|endcomment|> public TCCLObjectInputStream(InputStream in) throws IOException { super(in); <START> this.classLoader = Thread.currentThread().getContextClassLoader(); <END> }
<|startcomment|> Add the cause to the log. <|endcomment|> private void run() { try { boolean valid = connectionSanityCheck.isValid(); if (!valid) { onInvalidConnection.run(); } } catch (Exception e) { <START> logger.warn("Impossible to correctly monitor the Axon Server connection state."); <END> } }
<|startcomment|> Why did you remove the `stateData`? <|endcomment|> protected String getStateParameter(final WebContext context) { <START> final String stateParameter; <END> final String stateData = getState(); if (CommonHelper.isNotBlank(stateData)) { stateParameter = stateData; } else { stateParameter = CommonHelper.randomString(10); } return stateParameter; }
<|startcomment|> This logic seems potentially fragile. What if someone accidentally types in *two spaces*, e.g. `-c[space][space]test`. Also, have you investigated whether there is a way to potentially use the tools/API in Apache Commons CLI to do this parameter parsing for us (instead of doing string parsing)? If we could just use that CLI API directly, it'd be better than rewriting it ourselves. <|endcomment|> public DSpaceCommandLineParameter(String parameter) { <START> this(StringUtils.substringBefore(parameter, " "), StringUtils.substringAfter(parameter, " ")); <END> }
<|startcomment|> Does this have to be after the above line? Seems like it may as well be right before. Or you could just check that the returned list is empty. Or you can do both. <|endcomment|> protected Transferable createTransferable(JComponent c) { indices = list.getSelectedIndices(); <START> if (list.isSelectionEmpty()) return null; <END> return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList()); }
<|startcomment|> Again don't eat the exception throw it, and wrap it if you cannot update the interface. <|endcomment|> public List<NimbusInfo> getAllNimbuses() { List<NimbusInfo> nimbusInfos = new ArrayList<>(); try { Collection<Participant> participants = leaderLatch.get().getParticipants(); for (Participant participant : participants) { nimbusInfos.add(Zookeeper.toNimbusInfo(participant)); } } catch (Exception e) { LOG.warn("failed to get nimbuses", e); <START> } <END> return nimbusInfos; }
<|startcomment|> deprecate this <|endcomment|> <START> protected void doBegin() throws TransactionException { <END> if (txManager == null) { throw new IllegalStateException(CoreMessages .objectNotRegistered("javax.transaction.TransactionManager", "Transaction Manager").getMessage()); } try { txManager.setTransactionTimeout(getTimeoutInSeconds()); txManager.begin(); synchronized (this) { transaction = txManager.getTransaction(); } } catch (Exception e) { throw new TransactionException(cannotStartTransaction("XA"), e); } }
<|startcomment|> Why not use `org.modeshape.common.util.HashCode.compute(...)` instead of this? Or better yet, why not just return `name.hashCode()`? (When can `name` be null?) <|endcomment|> public int hashCode() { int hash = 7; hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0); <START> return hash; <END> }
<|startcomment|> this should be before the callback I think <|endcomment|> public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) { Exception exception = null; frontendMetrics.securityServicePostProcessRequestRate.mark(); long startTimeMs = System.currentTimeMillis(); if (!isOpen) { exception = new RestServiceException("SecurityService is closed", RestServiceErrorCode.ServiceUnavailable); } else if (restRequest == null || callback == null) { throw new IllegalArgumentException("RestRequest or Callback is null"); } <START> callback.onCompletion(null, exception); <END> frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs); }
<|startcomment|> static <|endcomment|> <START> private IMethod[] <END> toArray(List<IMethod> methods) { return methods.toArray(new IMethod[methods.size()]); }
<|startcomment|> update wouldn't work if the id is always a new id setting a new id is the job of add command <|endcomment|> public UserProfileParameters() { <START> profile.setId(Guid.newGuid()); <END> }
<|startcomment|> It is safe to call dismiss multiple times, in the source for dismiss(), there's a nice global if check along the lines of (mView != null && isVisible()) or something. <|endcomment|> public void onActivityPaused(Activity activity) { if (null != mCurInAppNotification) { <START> mCurInAppNotification.dismiss(); <END> } }
<|startcomment|> Done <|endcomment|> <START> public void createReplyReplyDone() { <END> createButton(buttonparent, buttonReply_ID, buttonReply_caption, true); createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true); buttonBar.pack(); }
<|startcomment|> `SECONDS.toMillis(5)` -> `5`. Timeout parameter of `assertTrueEventually(..)` is in seconds, not milliseconds. <|endcomment|> public void noMoreBubble() { config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), "1"); initExecutor(); final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory(); taskFactory.delayMs = 1000; executor.executeOnPartitions(taskFactory, newPartitions()); final DummyOperation op = new DummyOperation(); executor.execute(op); assertTrueEventually(new AssertTask() { @Override public void run() { assertTrue(op.completed); } <START> }, SECONDS.toMillis(5)); <END> }
<|startcomment|> I guess we could just assert without the temporary variable. <|endcomment|> public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() { CohortMembership cohortMembership = new CohortMembership(12); <START> boolean result = cohortMembership.equals(cohortMembership); <END> assertTrue(result); }
<|startcomment|> nit, could return: withPendingLocalization(this.pendingLocalization, pendingDownload); <|endcomment|> <START> public DynamicState withPendingLocalization(Future<Void> pendingDownload) { <END> return new DynamicState(this.state, this.newAssignment, this.container, this.currentAssignment, this.pendingLocalization, this.startTime, pendingDownload, this.profileActions, this.pendingStopProfileActions); }
<|startcomment|> We could also return true here, which seems to be more obvious to me <|endcomment|> public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) { try { final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password, clientVersionInfo); if (!information.isPresent()) { /* to many bad attempts, otherwise we get an exception */ ModelUtil.logWarning( MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay)); } return <START> information.isPresent(); <END> } catch (final AccessControlException ex) { /* regular bad attempt */ return false; } }
<|startcomment|> duplicate assert <|endcomment|> public void test() throws Exception { ExternalBuildReport report = new ExternalBuildReport("http://some.url.com"); assertEquals("View External Report", report.getDisplayName()); assertEquals("graph.gif", report.getIconFileName()); <START> assertEquals("graph.gif", report.getIconFileName()); <END> assertEquals("http://some.url.com", report.getUrlName()); assertEquals(null, report.getTarget()); }
<|startcomment|> The null `source` looks odd. <|endcomment|> public void publishEvent(Object event) { <START> publishEvent(new PayloadApplicationEvent<Object>(null, event)); <END> }
<|startcomment|> Personally for all these simple things, I would simple it down to a ternary operation for code simplicity. Always keep in mind code size. <|endcomment|> public boolean isList() { <START> if (isProperty) <END> return prop.isList(); else return false; }
<|startcomment|> I don't think we need this check nor this method. simply call geoRepDao.getById(getParameters().getGeoRepSessionId()) when needed, if getParameters().getGeoRepSessionId() we will simply won't get any result <|endcomment|> private GlusterGeoRepSession getGeoRepSession() { if (getParameters().getGeoRepSessionId() != null) { return geoRepDao.getById(getParameters().getGeoRepSessionId()); } <START> return null; <END> }
<|startcomment|> Unfortunately this method is protected. Changing the signature may break someone. @junit-team/junit-committers how should we handle this? We could not add the new feature without breaking the extension point. I'm in favour of modifying the methods signature and making it private. Users should create a new rule instead of extending Timeout. They could use the builder for creating the statement. <|endcomment|> protected Statement createFailOnTimeoutStatement( <START> Statement statement, Description description) throws Exception { <END> return FailOnTimeout.builder() .withTimeout(timeout, timeUnit) .withLookingForStuckThread(lookForStuckThread) .withDescription(description) .build(statement); }
<|startcomment|> The loop fails if `stops` contains _the first_ stop (`0`). The method should be: ``` Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); while (stops.hasNext()) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stops.next())); } return activeTripPatternsForGivenStops.iterator(); ``` <|endcomment|> @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator( IntIterator stops ) { Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>(); int stopIndex = stops.next(); while (stopIndex > 0) { activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stopIndex)); stopIndex = stops.next(); } <START> return activeTripPatternsForGivenStops.iterator(); <END> }
<|startcomment|> This is likely unnecessary. The set of qualifiers is expected to contain all elements. See also `org.jboss.weld.bootstrap.WeldStartup.createContexts(ServiceRegistry)` and other places where this constructor is used. <|endcomment|> public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) { this.context = context; this.type = type; <START> this.qualifiers = asSet(DefaultLiteral.INSTANCE, AnyLiteral.INSTANCE); <END> this.qualifiers.addAll(qualifiers); }
<|startcomment|> Unnecessary; it is still enabled by default in core, disabled in wizard. <|endcomment|> public void setUp() { <START> jenkins.CLI.get().setEnabled(true); <END> Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols()); agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName()); j.jenkins.setAgentProtocols(agentProtocols); }
<|startcomment|> There is a lack of symmetry here. `positionGap` should be initialized in both ctors. <|endcomment|> public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context, BasicQueryWeigher weigher) { this.executionContext = executionContext; this.context = context; this.weigher = weigher; this.positionGap = <START> 1; <END> }
<|startcomment|> `ImmutableList.copyOf` <|endcomment|> public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups) { this.streams = ImmutableList.copyOf(requireNonNull(streams, "streams is null")); this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, "columnEncodings is null")); <START> this.stripeEncryptionGroups = requireNonNull(stripeEncryptionGroups, "stripeEncryptionGroups is null"); <END> }
<|startcomment|> i'm not sure how getValue() is supposed to be called, but I would make it work correctly even if it is called twice. that is, set cx back to zero after you accumulate. <|endcomment|> public Double getValue() { //do not miss the last tuple try { <START> estimator.accumulate(cx); <END> } catch (ExecException ex) { throw new RuntimeException("Error while accumulating sample frequency: " + ex); } return estimator.getEntropy(); }
<|startcomment|> Hmm I think we should remove this line. Seems like it's not needed since `close(null)` will just do nothing. Maybe it's a left-over line from some previous version of the file where the result set got closed properly or something :-) <|endcomment|> private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) { boolean result = true; ResultSet rs = null; try { rs = metaData.getSchemas(); while (rs.next() && result) { result = false; } } catch (SQLException e) { throw JdbcUtils.wrapException(e, "retrieve schema and catalog metadata", JdbcActionType.METADATA); } finally { FileHelper.safeClose(rs); <START> close(null); <END> } return result; }
<|startcomment|> those `if (!event.isPre())` can be avoided by adding `@Listener(observation = Observation.POST)` at class level <|endcomment|> public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) { if (!event.isPre()) { emitSessionDestroyedEvent((String) event.getKey()); } <START> } <END>
<|startcomment|> Flip the `if` and move the invalidate call up inside <|endcomment|> public void invalidate(@Nullable String path) { if (path == null) { <START> return; <END> } invalidate(Uri.parse(path)); }
<|startcomment|> could this block be simplified? ``` java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; } ``` <|endcomment|> public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null && disconnectableRegisterer == null) { return this.withConnectableCallbacks().withDisconnectableCallbacks(); } else if (connectableRegisterer == null) { return this.withConnectableCallbacks(); } else if (disconnectableRegisterer == null) { return this.withDisconnectableCallbacks(); } <START> return this; <END> }
<|startcomment|> I don't like this code duplication. How about if (name != null) { switch (name) { ... } } Assert.isTrue(false); return null; <|endcomment|> public static String localizeProvider(String name) { if (name==null) { Assert.isTrue(false); return null; <START> } <END> switch (name) { case DIRECT_PROVIDER: return Messages.ProxySelector_0; case ECLIPSE_PROVIDER: return Messages.ProxySelector_1; case NATIVE_PROVIDER: return Messages.ProxySelector_2; default: break; } Assert.isTrue(false); return null; }
<|startcomment|> Does this need to be public? <|endcomment|> <START> public String removeSuffix(String loaderFileName, char suffixTerm) { <END> return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm)); }
<|startcomment|> Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others. <|endcomment|> private BootstrapConfigurationImpl() { this.defaultProviderClassName = null; this.constraintValidatorFactoryClassName = null; this.messageInterpolatorClassName = null; this.traversableResolverClassName = null; this.parameterNameProviderClassName = null; this.clockProviderClassName = null; <START> this.valueExtractorClassNames = new HashSet<>( 0 ); <END> this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES; this.isExecutableValidationEnabled = true; this.constraintMappingResourcePaths = newHashSet(); this.properties = newHashMap(); }
<|startcomment|> I am concerned about the addition of buildResult here, since this will cause every single copy to read the data twice for the copy and for the checksum, instead of once as before, which could be expensive when dealing with large files and cause performance regressions. <|endcomment|> public static FileUtils.FileCopyResult copyToFileAndClose(InputStream is, File file) throws IOException { file.getParentFile().mkdirs(); try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) { ByteStreams.copy(is, os); } finally { CloseQuietly.close(is); } <START> return FileUtils.FileCopyResult.buildResult(file.toPath()); <END> }
<|startcomment|> If you are using an AtomicBoolean (and dont do anything else), you no longer need the synchronized keyword here. <|endcomment|> <START> @Override public synchronized boolean cancel( final boolean mayInterruptIfRunning ) { <END> return canceled.compareAndSet( false, true ); }
<|startcomment|> hey @manstis , quick looking at this seems that a potential NPE can be produced here? I mean for `orElse(null).getValue()`? <|endcomment|> protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) { return items .entrySet() .stream() .filter(e -> e.getKey().equals(command)) .findFirst() .orElse(null) <START> .getValue(); <END> }
<|startcomment|> TAG <|endcomment|> public CellIdentityCdma() { <START> super(CellIdentityCdma.class.getSimpleName(), TYPE_CDMA, <END> null, null); mNetworkId = Integer.MAX_VALUE; mSystemId = Integer.MAX_VALUE; mBasestationId = Integer.MAX_VALUE; mLongitude = Integer.MAX_VALUE; mLatitude = Integer.MAX_VALUE; mAlphaLong = null; mAlphaShort = null; }
<|startcomment|> Would encapsulating the underlying implementation of BecauseYouReadCard be better or do we need the PageTitle elsewhere? I'm thinking of my recent PageTitle.getText() bug where I meant to call getDisplayText(). At least the bug could only live in one place. If we expose a large object like PageTitle, we have lots of flexibility to do things beyond what a Card is really meant for. There's some notes on some of the tradeoffs here: https://en.wikipedia.org/wiki/Law_of_Demeter. <|endcomment|> private void header(@NonNull final BecauseYouReadCard card) { CardLargeHeaderView header = new CardLargeHeaderView(getContext()) .setTitle(card.title()) .setSubtitle(card.subtitle()) <START> .setPageTitle(card.pageTitle().getDisplayText()) <END> .setImage(card.image()); header(header); }
<|startcomment|> `DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString()` -> `String.valueOf(DEFAULT_CHECK_TIMEOUT_IN_SECONDS)` now that it's an `int` <|endcomment|> private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) { int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS; try { <START> checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString())); <END> } catch (NumberFormatException e) { log.warn(String.format("Invalid format for %s parameter, using default value instead", PARAM_MONGODB_CHECK_TIMEOUT), e); } return checkTimeout; }
<|startcomment|> This should be a WARN instead of an ERROR. <|endcomment|> private void closeConnection(String deviceId) { DeviceConfig device = deviceConfigCache.get(deviceId); if (device == null) { <START> logger.error("Could not find device '{}'", deviceId); <END> return; } EpsonProjectorDevice remoteController = device.getConnection(); if (remoteController != null) { try { logger.debug("Closing connection to device '{}' ", deviceId); remoteController.disconnect(); } catch (EpsonProjectorException e) { logger.debug("Error occurred when closing connection to device '{}'", deviceId); } } }
<|startcomment|> I'd prefer ImmutableList.of throughout. <|endcomment|> public void testSimpleAnnotation() { assertGeneratedMatches( <START> Lists.newArrayList("import javax.annotation.Nullable;"), <END> Lists.newArrayList("@Nullable"), Lists.newArrayList("@javax.annotation.Nullable")); }
<|startcomment|> I'd expect the union of `POINT (1, 2)` and `LINESTRING EMPTY` to be `POINT (1, 2)`, but this test asserts the result to be `GEOMETRYCOLLECTION (POINT (1 2))`. <|endcomment|> public void testUnionPointWithEmptyLineString() { <START> assertUnion("POINT (1 2)", "LINESTRING EMPTY", "GEOMETRYCOLLECTION (POINT (1 2))"); <END> }
<|startcomment|> protected? <|endcomment|> <START> public Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z) <END> { super(entity, entityRenderer, x, y, z); this.layerRenderer = layerRenderer; }
<|startcomment|> Seems the output name cache should be reset here, not below. <|endcomment|> public void deleteOldDeployments(final IServer server) throws CoreException { File deploymentsRootFolder = getDeploymentsRootFolder(); Arrays.stream(server.getModules()) <START> .forEach(module -> deleteOldDeployment(module, deploymentsRootFolder)); <END> }
<|startcomment|> I would recommend to use <code>this()</code> in this constructor <|endcomment|> public CronTab(String format, int line, Hash hash) throws ANTLRException { <START> set(format, line, hash); <END> }
<|startcomment|> @mdaneshi, do you think it would make sense to have something like this in every static methods that you wrote? ``` if (buf == null || Math.min(buf.length, len) < off + 1 /* required array length for this method to work correctly */) { return false; } ``` I know this is not a common practice currently in libjitsi and we sometimes are a little sloppy when we access arrays, but I believe we should change this and write more defensive code whenever possible. <|endcomment|> public boolean isKeyFrame(byte[] buff, int off, int len) { <START> if (buff == null || len < 1 || buff.length < len) <END> { return false; } int nalType = buff[off] & kTypeMask; // Single NAL Unit Packet if (nalType == kFuA) { // Fragmented NAL units (FU-A). if (parseFuaNaluForKeyFrame(buff, off, len)) { return true; } } else { if (parseSingleNaluForKeyFrame(buff, off, len)) { return true; } } return false; }
<|startcomment|> `@ResponseStatus(HttpStatus.NO_RESPONSE)` Then you can change return type to void and remove the return statement <|endcomment|> <START> public ResponseEntity<?> delete(@RequestBody List<Long> printerIds) throws IOException { <END> for (long id : printerIds) { Printer printer = printerService.get(id); if (printer != null) { printerService.remove(printer); } } return new ResponseEntity<>(HttpStatus.OK); }
<|startcomment|> Use k, like you did in the other files <|endcomment|> public DiskWriteModel getDisk(int deviceId) { return fDisks.computeIfAbsent(deviceId, k -> new <START> DiskWriteModel(deviceId, checkNotNull(getStateSystemBuilder()))); <END> }
<|startcomment|> In the context of GUVNOR-2821 I would expect `assertTrue` here, can you please update the `fakeConditionCol52` method to achieve this? Let me know if you don't see my point. <|endcomment|> public void testIsConditionValidWhenHeaderIsValid() throws Exception { final ConditionCol52 conditionCol1 = fakeConditionCol52("header1"); final ConditionCol52 conditionCol2 = fakeConditionCol52("header2"); final Validator validator = new Validator(fakeCompositeColumn(conditionCol1, conditionCol2)); <START> assertFalse(validator.isConditionValid(conditionCol2)); <END> }
<|startcomment|> does this need to be a class member? <|endcomment|> public StatsManagerMetrics(MetricRegistry registry) { <START> this.registry = registry; <END> statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, "StatsPublishFailureCount")); totalFetchAndAggregateTime = registry.histogram(MetricRegistry.name(StatsManager.class, "TotalFetchAndAggregateTime")); fetchAndAggregateTimePerStore = registry.histogram(MetricRegistry.name(StatsManager.class, "FetchAndAggregateTimePerStore")); }
<|startcomment|> minor: the `replicaList.size() > 0` check isn't really needed <|endcomment|> BlobStatus(List<String> replicaList) { if (replicaList != null && replicaList.size() > 0) { unavailable.addAll(replicaList); } <START> } <END>
<|startcomment|> MemcachedClientCallback should be renamed to StorageClientCallback <|endcomment|> <START> protected MemcachedClientCallback createMemcachedClientCallback() { <END> return new MemcachedClientCallback() { @Override public byte[] get(final String key) throws IOException { return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key )); } }; }
<|startcomment|> Your tests don't rely on `Stripe.clientId` at all, so you should remove this line, rename the method, and get rid of `tearDownMockAndClientId()` entirely. <|endcomment|> public void clientId() throws IOException { <START> Stripe.clientId = "ca_test"; <END> chargeBody = resource("charge.json"); }
<|startcomment|> Maybe it would be good to include the causing exception so user knows why it couldn't be created. <|endcomment|> private XADataSource createXaDataSourceInstance(String className) { try { Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader()); Object instance = BeanUtils.instantiate(dataSourceClass); Assert.isInstanceOf(XADataSource.class, instance); return (XADataSource) instance; } catch (Exception ex) { throw new IllegalStateException( <START> "Unable to create XADataSource instance from '" + className + "'"); <END> } }
<|startcomment|> You need to swap the order of nullcheck / isEmpty, otherwise it will lead to NPE (if getModules returns null, not sure that's possible) and this validator will fail. <|endcomment|> protected Optional<ExampleProjectError> getError(Path projectPath) { POM pom = this.getPom(pomService, projectPath); <START> if (pom.getModules().isEmpty() || pom.getModules() == null) { <END> return Optional.empty(); } else { return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(), "")); } }
<|startcomment|> When is `mTransport == null`? Isn't it always set to something in `open()`? Also, why do you need to check `mBaseTransport`? <|endcomment|> public boolean isOpen() { <START> return mBaseTransport.isOpen() && mTransport != null && mTransport.isOpen(); <END> }
<|startcomment|> why enabled? why restore those? <|endcomment|> public static void restoreSystemProperties() { System.clearProperty("org.uberfire.nio.git.daemon.enabled"); <START> System.clearProperty("org.uberfire.nio.git.ssh.enabled"); <END> System.clearProperty("org.uberfire.sys.repo.monitor.disabled"); }
<|startcomment|> I'd rather see more specific error messages here, as there's a few different scenarios here we should be aware of: * A permanent group's name can *never* be patched. But, its description can be updated. * Same with a Community/Collection group's name (not editable) & description (editable), unless it's detached. In which case it can be patched. So, at a minimum, it seems like we need different errors & checks here. Permanent groups can *never* have name updates, but can have description updates. Community/Collection groups can be updated if the Community/Collection is deleted, but are otherwise considered "permanent". <|endcomment|> protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id, Patch patch) throws AuthorizeException, SQLException { final Group group = dsoService.find(context, id); if (group != null && isPatchUnprocessable(context, group)) { <START> throw new UnprocessableEntityException("This group cannot be patched."); <END> } patchDSpaceObject(apiCategory, model, id, patch); }
<|startcomment|> no need to assign to counterName just to return on next line. However, we probably should add a null check for the evaluationContext. <|endcomment|> protected String computeMetricName(Message<?> message) { <START> String counterName = nameExpression.getValue(evaluationContext, message, CharSequence.class).toString(); <END> return counterName; }
<|startcomment|> Could you break this statement into multiple for readability? <|endcomment|> public boolean supportsBitmapIndex(final BitmapIndexSelector selector) { // We can operate on bitmap indexes if this is a constant expression, or if it reads one column that has // an index and does not have multiple values. The lack of multiple values is important because expression // filters treat multi-value arrays as nulls, which doesn't permit index based filtering. <START> return requiredBindings.isEmpty() <END> || (requiredBindings.size() == 1 && selector.getBitmapIndex(Iterables.getOnlyElement(requiredBindings)) != null && !selector.hasMultipleValues(Iterables.getOnlyElement(requiredBindings))); }
<|startcomment|> this method should be changed to private <|endcomment|> <START> public <END> void setM(Market currentMarket) { this.currentMarket = currentMarket; }
<|startcomment|> Please write it as `!config.getQueryCacheConfigs().isEmpty()` instead of checking the size. <|endcomment|> private long countMapWithAtleastOneQueryCache(Node node) { return maps.stream().filter(distributedObject -> { MapConfig config = node.getConfig().getMapConfig(distributedObject.getName()); if (config != null) { <START> return config.getQueryCacheConfigs().size() >= 1; <END> } return false; }).count(); }
<|startcomment|> probably it is better to change it to ``` String columnName; if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); } else { columnName = propertyAuditingData.getModifiedFlagName(); } ``` <|endcomment|> public void addModifiedColumns( GlobalConfiguration globalCfg, Value value, Element parent, PropertyAuditingData propertyAuditingData) { String columnName = propertyAuditingData.getModifiedFlagName(); if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); <START> } <END> MetadataTools.addModifiedFlagProperty( parent, propertyAuditingData.getName(), globalCfg.getModifiedFlagSuffix(), columnName ); }
<|startcomment|> Why is this final and condition not? Same issue on line 130. Since final is normally not used for local variables in spock, I'd remove it. <|endcomment|> private boolean isFailedEqualityComparison(Throwable exception) { if (!(exception instanceof ConditionNotSatisfiedError)) return false; <START> final ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception; <END> Condition condition = conditionNotSatisfiedError.getCondition(); ExpressionInfo expr = condition.getExpression(); return expr != null && expr.isEqualityComparison() && // it is equality conditionNotSatisfiedError.getCause() == null; // and it is not failed because of exception }
<|startcomment|> These checks are not necessary for logout. <|endcomment|> public final RedirectAction getLogoutRedirectAction(final WebContext context) { // it's an AJAX request -> unauthorized (instead of a redirection) <START> if (ajaxRequestResolver.isAjax(context)) { <END> logger.info("AJAX request detected -> returning 401"); cleanRequestedUrl(context); return null; } // authentication has already been tried -> unauthorized final String attemptedAuth = (String) context.getSessionAttribute(getName() + ATTEMPTED_AUTHENTICATION_SUFFIX); if (CommonHelper.isNotBlank(attemptedAuth)) { return null; } init(context); return retrieveLogoutRedirectAction(context); }
<|startcomment|> debug/trace/remove? <|endcomment|> public void setMainTabSelectedItem(Erratum selectedItem) { <START> logger.info("setMainTabSelectedItem"); //$NON-NLS-1$ <END> updateErrataDetailFormPanel(selectedItem); }
<|startcomment|> If we need to do this, I feel like we can at least do this somewhere else. A binding for something like DiscoveryManagerInitializer with dependencies on these Config classes might work. <|endcomment|> public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) { this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION); this.namespace = namespace; this.config = config.getPrefixedView(namespace); this.dcInfo = dcInfo; // TODO: Remove this when DiscoveryManager is finally no longer used <START> DiscoveryManager.getInstance().setEurekaInstanceConfig(this); <END> }
<|startcomment|> Right here (and in the equivalent 3.0 class) is the only place you're using "this" where a field isn't shadowed, is this intentional? <|endcomment|> public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) { AssertionType assertion = getAssertion(context, null); if (assertion != null) { assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString()); } <START> return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, this.getWebContextProperties(context)); <END> }
<|startcomment|> Drop this empty block. <|endcomment|> public void allBindingsChanged(BindingProvider provider) { logger.trace("allBindingsChanged() called."); <START> if (provider instanceof VeluxBindingProvider) { <END> } super.allBindingsChanged(provider); }
<|startcomment|> Please, remove `final` modifiers as they seem to be redundant. <|endcomment|> private Map<String, String> makeParserFields() { final Map<String, String> fieldMapping = Maps.newHashMap(); for (final SchemaPath sp : getColumns()) { final String drillField = sp.getRootSegment().getPath(); try { <START> final String parserField = HttpdParser.parserFormattedFieldName(drillField); <END> fieldMapping.put(drillField, parserField); } catch (Exception e) { LOG.info("Putting field: " + drillField + " into map", e); } } return fieldMapping; }
<|startcomment|> Message needs changed. What does Retrofit do? Do we care if people overwrite this? I don't, and it breaks your `newBuilder()` desire. <|endcomment|> public Builder client(@NonNull OkHttpClient client) { if (client == null) { throw new NullPointerException("client == null"); } if (downloader != null) { throw new IllegalArgumentException("Downloader already set."); } downloader = new OkHttp3Downloader(client, client.cache(), true); return this; <START> } <END>
<|startcomment|> Just a small remark feel free to skip it. It would have a nicer look if you keep if else logic direct like if (activity == null) { return Optional.empty(); } else { final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); } <|endcomment|> protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) { final Activity activity = placeManager.getActivity(placeRequest); <START> if (activity != null) { <END> final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); } else { return Optional.empty(); } }
<|startcomment|> Generally you don't sort the VMs, and in the one case where you do - you don't really sort them either, but just move one to the top of the list. So firstly, consider dropping this method, making edit() protected and add the logic only in VmAffinityGroupListModel. Secondly, you could drop the comparator there and just iterate over the items to find the specific ID and move it to the top of the list, the comparator thing isn't necessary. <|endcomment|> private void edit() { if (getWindow() != null) { return; } AffinityGroup affinityGroup = getSelectedItem(); if (affinityGroup == null) { return; } <START> sortVms(affinityGroup); <END> AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver()); model.init(); setWindow(model); }
<|startcomment|> Considering the expected exception for this test, it seems like the `assertThat` is superfluous, and all we really want is `itty.hasNext();` <|endcomment|> public void testIteratorCloses() throws Exception { Kabob bob = db.getJdbi().onDemand(Kabob.class); Iterator<Something> itty = bob.iterateAll(); <START> assertThat(itty.hasNext()).isFalse(); <END> }
<|startcomment|> Cant the class name be included here so we know where this method is being called from. <|endcomment|> public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) { Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing); Boolean match = true; <START> assertEquals(swappedIngredients.size(), ings.size()); <END> for (String i : ings) { if (!swappedIngredients.contains(i)) { match = false; break; } } assertTrue(match); }
<|startcomment|> Edge case of duplicate code ;) It could be extracted to a common private method with two params for id and type. Up to you if you want to change it or not ;) <|endcomment|> public List<Document> getClientDocuments(String clientId) throws MambuApiException { <START> if (clientId == null || clientId.trim().isEmpty()) { <END> throw new IllegalArgumentException("ClientId ID must not be null or empty"); } return DocumentsService.getDocuments(mambuAPIService, CLIENTS, clientId); }
<|startcomment|> Now this should return true, since there are disks on the storage domain (Remember that you don't check the validate only the method checkDisksInBackupStorage) Change to assertTrue <|endcomment|> public void testFailForCheckDisksNotInBackupStorage() { final VM vm = new VM(); command.setVm(vm); when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm); command.setCluster(new Cluster()); Guid storageDomainId = initDiskImage(vm); when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true)); <START> assertFalse("checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain", <END> command.checkDisksInBackupStorage()); }
<|startcomment|> shouldn't be the ```max()``` between ```offset``` and ```skip``` to avoid the ```pos``` to be previous than ```offset```? <|endcomment|> public long skip(long n) { if (n > 0) { long skip = bytes.length - pos; if (skip > n) skip = n; pos += skip; return skip; } else { int idx = Math.min(bytes.length, pos); long skip = idx + n; <START> pos = (int) skip; <END> return skip; } }
<|startcomment|> You may want to put this into a try/finally block. <|endcomment|> public void actionPerformed(AnActionEvent e) { BaseAction.State s = setupAction(e); List<String> lastTask = Collections.singletonList(s.getLastRanTask()); s.performTasks(lastTask); <START> s.cleanup(); <END> }
<|startcomment|> rename to s <|endcomment|> public void addAll(SerializableStatus status) { Assert.isLegal(status != null); SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren(); for (SerializableStatus <START> statuse : <END> statuses) { add(statuse); } }
<|startcomment|> how about moving logicalNetworkExists() after changesAreClusterCompatible() ? in case changesAreClusterCompatible() returns false, it will save one DB call :) <|endcomment|> protected boolean canDoAction() { <START> return super.canDoAction() && VdsGroupExists() && logicalNetworkExists() && changesAreClusterCompatible(); <END> }
<|startcomment|> any reason you can't just iterate through the values? schemaTableMapping.values().foreach(v -> v.invalidateAll()); schemaTableMapping.clear(); <|endcomment|> protected void reloadCache() { schemaMappingCache.invalidateAll(); // this preloads the list of schema names Set<String> schemas = getSchemaNames(); // invalidate and remove from the schema table mapping all records, start from scratch for (String key : schemaTableMapping.keySet()) { schemaTableMapping.get(key).invalidateAll(); schemaTableMapping.remove(key); <START> } <END> for (final String schema : schemas) { // this preloads the list of table names for each schema getTableNames(schema); } }
<|startcomment|> This assertion could be removed as it seems to test the Java type system rather than our code <|endcomment|> public void testSetUser() { Configuration configuration = generateConfiguration(); configuration.setUser("24601", "m@rp.fr", "MM"); <START> assertEquals(User.class, configuration.getUser().getClass()); <END> assertEquals("24601", configuration.getUser().getId()); assertEquals("m@rp.fr", configuration.getUser().getEmail()); assertEquals("MM", configuration.getUser().getName()); }
<|startcomment|> No need to call `file.toString()` -> `FileWriter` can take `File` in the constructor as well. <|endcomment|> private void writeStringToFile(File file, String str) throws IOException { <START> try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.toString()))) { <END> bw.write(str); } }
<|startcomment|> Minor: the two calls could be collapsed, since `DimensionHandlerUtils.convertObjectToLong` handles nulls just fine. <|endcomment|> private RelNode possiblyWrapRootWithOuterLimitFromContext( RelRoot root ) { Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT); if (outerLimitObj == null) { return root.rel; } <START> Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true); <END> if (outerLimit == null) { return root.rel; } return LogicalSort.create( root.rel, root.collation, makeBigIntLiteral(0), makeBigIntLiteral(outerLimit) ); }
<|startcomment|> nit - ConfigException is unused <|endcomment|> <START> public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException { <END> QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig(); try { Properties zkProp = getDefaultZKProperties(); zkProp.setProperty("server.1", "localhost:2888:2888"); quorumPeerConfig.parseProperties(zkProp); fail("ConfigException is expected"); } catch (ConfigException ce) { String expectedMessage = "Client and election port must be different! Please update the configuration file on server.1"; assertEquals(expectedMessage, ce.getMessage()); } }
<|startcomment|> ConnectException is not actually thrown by anything... it shouldn't be declared in the `throws` <|endcomment|> public static URLConnection openURLConnection(URL url) <START> throws IOException, ConnectException { <END> return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT); }
<|startcomment|> 1. let's replace with params.forEach 2. it makes more sense that this method will reside in HostSetupNetworksParametersBuilder - I don't see how its related to "ReportFailedChildHostOperationsUtil" <|endcomment|> public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) { <START> for (VdcActionParametersBase param : parameters) { <END> param.setParentCommand(command.getActionType()); param.setParentParameters(command.getParameters()); } }
<|startcomment|> nm. I misread the diff. I thought ```getDatapointsForRange()``` only called ```getNumericMetricDataForRange()``` <|endcomment|> public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) { RollupType rollupType = null; String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey); if ( rollupTypeStr != null ) { rollupType = RollupType.fromString(rollupTypeStr); } if ( rollupType == null ) { rollupType = RollupType.BF_BASIC; } <START> return getNumericMetricDataForRange(locator, range, gran, rollupType); <END> }
<|startcomment|> to be null safe on here, I would suggest using stringutils.equalsignorecase or start the expression with the constant <|endcomment|> public boolean shouldProcessRequestedCashAdvancesFromSaeData() { <START> return (getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND).equalsIgnoreCase(KFSConstants.ParameterValues.YES)); <END> }
<|startcomment|> Looks that works OK, but for me it's hard to read. I would rather see better readable return. <|endcomment|> static Path resolvePath(Path file, String workingDirectory) { <START> return file == null ? null : (file.isAbsolute() ? file : (file.getFileName().startsWith(File.separator) ? file.toAbsolutePath() : (Paths.get(workingDirectory, <END> file.getFileName().toString())))); }
<|startcomment|> Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions. <|endcomment|> public void removeServiceEventListener(Object listener) { assert getExecutor().isInExecutorThread(); ListenerEntry entry = new ListenerEntry(listener, null); <START> if (DsfDebugOptions.DEBUG && DsfDebugOptions.DEBUG_SESSION && DsfDebugOptions.DEBUG_SESSION_LISTENERS) { <END> String msg = new Formatter().format( "%s %s removed as a service listener to %s (id=%s)", //$NON-NLS-1$ DsfPlugin.getDebugTime(), LoggingUtils.toString(listener), LoggingUtils.toString(this), getId() ).toString(); DsfDebugOptions.trace(msg); } fListeners.remove(entry); }
<|startcomment|> I smell an incoming NPE here... <|endcomment|> private static void validateEntityLabel(EntityType entityType) { String label = entityType.getLabel(); <START> if (label.isEmpty()) <END> { throw new MolgenisValidationException( new ConstraintViolation(format("Label of EntityType [%s] is empty", entityType.getId()))); } else if (label.trim().equals("")) { throw new MolgenisValidationException(new ConstraintViolation( format("Label of EntityType [%s] contains only white space", entityType.getId()))); } }
<|startcomment|> We could just call deleteIfExists(path) since it's same. <|endcomment|> public void deleteIfExists(File path, String user, String logPrefix) throws IOException { <START> LOG.info("Deleting path {}", path); <END> Path p = path.toPath(); if (Files.exists(p)) { try { FileUtils.forceDelete(path); } catch (FileNotFoundException ignored) {} } }
<|startcomment|> This could be even `if (dedicatedTransport != transport)` <|endcomment|> protected void releaseTransport(Transport transport) { <START> if (dedicatedTransport == null) { <END> //we aren't using this transport. we can release it super.releaseTransport(transport); } }
<|startcomment|> You probably made it a couple of thousand times slower :-) Keys rarely overlap in this domain creating a StringBuilder has an initialization cost that is not amortized. <|endcomment|> String prepare(String name, Map<String, Map<String, String>> domain) { StringBuilder builder = new StringBuilder(name); while (domain.containsKey(name)) { <START> builder.append("~"); <END> } domain.put(builder.toString(), new LinkedHashMap<>()); return builder.toString(); }
<|startcomment|> is this a RuntimeException? In which case you probably don't want to catch it. <|endcomment|> public synchronized void deleteFile() { closeFile(); File historyTreeFile = fConfig.getStateFile(); try { if (!historyTreeFile.delete()) { /* We didn't succeed in deleting the file */ Activator.getDefault().logError("Failed to delete" + historyTreeFile.getName()); //$NON-NLS-1$ } <START> } catch (SecurityException e) { <END> Activator.getDefault().logError(e.getMessage(), e); } }
<|startcomment|> Replace method content with... super.delete(userEntityFile); ...as the underlying code will not only delete the entity but also fire an event about it. <|endcomment|> public void delete(UserEntityFile userEntityFile) { <START> getEntityManager().remove(userEntityFile); <END> }
<|startcomment|> If we allow to create sub class of this **DubboConfigBindingBeanPostProcessor ** and some **init method** get override then it might cause issue. So better to make init final or provide. What do you say? <|endcomment|> <START> public void init() { <END> if (dubboConfigBinder == null) { try { dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class); } catch (BeansException ignored) { if (log.isDebugEnabled()) { log.debug("DubboConfigBinder Bean can't be found in ApplicationContext."); } // Use Default implementation dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment()); } } dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields); dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields); }
<|startcomment|> I find it even easier to read without the `(...)` <|endcomment|> public static void removeDuplicateImages(Feed feed) { Set<String> known = new HashSet<String>(); for (FeedItem item : feed.getItems()) { <START> String url = (item.hasItemImage()) ? item.getImage().getDownload_url() : null; <END> if (url != null) { if (known.contains(url)) { item.setImage(null); } else { known.add(url); } } } }
<|startcomment|> Shouldn't this also be changed to super.selectedItemsChanged()? <|endcomment|> protected void selectedItemsChanged() { <START> super.onSelectedItemChanged(); <END> updateActionAvailability(); }
<|startcomment|> Shouldn't this loop release memory of "discarded" arrays? E.g. intArrays[intArraysTop] = null? <|endcomment|> public int[] borrowIntArray(int positionCount) { int[] array; <START> while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) { <END> estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length); --intArraysTop; } if (intArraysTop < 0) { array = new int[positionCount]; estimatedSizeInBytes += sizeOfIntArray(positionCount); } else { array = intArrays[intArraysTop]; --intArraysTop; } ++borrowedIntArrays; return array; }
<|startcomment|> I suspect that you want to preserve order here and return a List? <|endcomment|> <START> public Collection<MergeStrategySection> getAllMergeStrategySections() { <END> List<MergeStrategySection> all = new ArrayList<MergeStrategySection>(); all.addAll(getLocalMergeStrategySections()); all.addAll(getInheritedMergeStrategySections()); return all; }
<|startcomment|> Alias should never be null. <|endcomment|> public String getDeleteDescription() { <START> return getName() + (getAlias() == null ? "" : " (" + getAlias() + ")"); <END> }
<|startcomment|> Is CouchbaseLiteException thrown from anything in this method? Or it should return void but throw CouchbaseLiteException instead? <|endcomment|> boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2) <START> throws CouchbaseLiteException { <END> if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID())) return false; setC4Doc(c4doc); // self.c4Doc = _c4Doc; // This will update to the selected revision return true; }
<|startcomment|> `protected`. It would be bad to allow end-user to mutate on this local property. <|endcomment|> <START> public void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) { <END> this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId; }
<|startcomment|> In what case can the file exist but be too long? If we are on a system with a longer filename limit, we should just use the existing file and not worry about the length, I think. <|endcomment|> protected String getFileName(ITask task, Predicate<String> fileExists) { String encodedFileName = CoreUtil.asFileName(task.getTaskId()); // for backwards-compatibility with versions that always encoded file names, // we will use an encoded name if the file with an encoded name already exists <START> if (encodedFileName.length() <= FILENAME_MAX_LEN && fileExists.test(encodedFileName)) { <END> return encodedFileName; } // if file with encoded name does not exist, we will only encode file name if it is required String fileName; if (requiresEncoding(task.getTaskId())) { fileName = encodedFileName; } else { fileName = task.getTaskId(); } // trim the file name if it is too long return trimFilenameIfRequired(fileName); }
<|startcomment|> why the extraction to a variable? I would keep it inlined: ``` return client.indices().create(createIndexRequest(indexName), RequestOptions.DEFAULT).isAcknowledged(); ``` <|endcomment|> public boolean createIndex(String indexName) { Assert.notNull(indexName, "No index defined for Query"); try { CreateIndexRequest indexRequest = createIndexRequest(indexName); <START> return client.indices().create(indexRequest, RequestOptions.DEFAULT).isAcknowledged(); <END> } catch (Exception e) { throw new ElasticsearchException("Failed to create index " + indexName, e); } }
<|startcomment|> What is this property used for? <|endcomment|> public static Properties defaultProperties() { Properties properties = BaseHttpApiMetadata.defaultProperties(); <START> properties.setProperty(ShipyardProperties.SHIPYARD_CREDENTIAL, "<remote-service-key-given-by-shipyard-cli>"); <END> return properties; }
<|startcomment|> It seems this could be changed to `return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP))` <|endcomment|> protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) { if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) { return false; } if (ctx.isOriginLocal()) { // The return value only matters on the originator. // Conditional commands also check the previous value only on the originator. if (!command.readsExistingValues()) { return false; } // TODO Could make DELTA_WRITE/ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to // return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.alwaysReadsExistingValues(); <START> if (command.hasFlag(Flag.SKIP_REMOTE_LOOKUP)) { <END> return false; } } else { // Ignore SKIP_REMOTE_LOOKUP on remote nodes // TODO Can we ignore the CACHE_MODE_LOCAL flag as well? if (!command.alwaysReadsExistingValues()) { return false; } } return true; }
<|startcomment|> ![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the declaration of thrown exception 'java.io.IOException', as it cannot be thrown from constructor's body. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck) <|endcomment|> public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName, <START> LibraryTemplateService libraryTemplateService) throws IOException { <END> super("libraryReceipt", LibraryDto.class, "Libraries", dto, quantity); if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException("Aliquot class cannot be null"); this.project = project; this.aliquotClass = aliquotClass; this.defaultSciName = defaultSciName; this.libraryTemplateService = libraryTemplateService; newBox = dto.getBox(); }
<|startcomment|> getEmailAddress can return null. <|endcomment|> public void evict(AccountExternalId id) { byKey.remove(id.getKey()); byAccountId.remove(id.getAccountId()); <START> byEmail.remove(new EmailWrapper(id.getEmailAddress())); <END> }
<|startcomment|> create a `vparameter.getName()` that delegates to `Parameter` <|endcomment|> public void outjectRequestMap() { for (ValuedParameter vparameter : methodInfo.getValuedParameters()) { <START> result.include(vparameter.getParameter().getName(), vparameter.getValue()); <END> } }
<|startcomment|> seems like these constructors should set `protected` properties on the base class. They're called via `super` below. <|endcomment|> <START> public AbstractBlockFamily(BlockFamilyDefinition definition, BlockShape shape, BlockBuilderHelper blockBuilder) { <END> }
<|startcomment|> Maybe we can move the null check on `mGoogleApiClient` a level above so to protect also the access to `stopAutoManage`. wdyt? <|endcomment|> public void onStop() { super.onStop(); mGoogleApiClient.stopAutoManage(getActivity()); <START> if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) { <END> mGoogleApiClient.disconnect(); } }
<|startcomment|> please remove redundant brackets (isInter...) <|endcomment|> protected Guid getQuotaId() { <START> if (getNewDisk() != null && (isInternalManagedDisk())) { <END> return ((DiskImage) getNewDisk()).getQuotaId(); } return null; }
<|startcomment|> One of these two trace lines should be removed. <|endcomment|> public JClogin() { <START> logger.trace("JClogin(constructor) called."); <END> logger.trace("JClogin(this={}) called.",this); }
<|startcomment|> I think using this util obfuscates the code <|endcomment|> public ScriptingJobs(ScriptingAdaptor adaptor, XenonEngine xenonEngine, SchedulerConnectionFactory connectionFactory) { this.adaptor = adaptor; this.xenonEngine = xenonEngine; this.adaptorName = adaptor.getName(); this.connectionFactory = connectionFactory; <START> connections = Utils.emptyMap(1); <END> }
<|startcomment|> I really dislike how this confuses things. Most of the `/`s are in the templates, but then this one special slash is being added here. This is a really good opportunity for future mistakes. Maybe this is a case for changing from using `String.format()` with templates that all do essentially the same thing for varying numbers of parameters to say just using `String.join()`. <|endcomment|> public TMSKeyBuilder(final String prefix, TileLayerDispatcher layers) { <START> this.prefix = Strings.isNullOrEmpty(prefix) ? "" : prefix + "/"; <END> this.layers = layers; }
<|startcomment|> nit: I somehow liked the old, more concise `UNKNOWN_STATS` <|endcomment|> public void testLeftJoinMissingStats() { PlanNodeStatsEstimate leftStats = planNodeStats( 0, <START> new SymbolStatistics(LEFT_JOIN_COLUMN, SymbolStatsEstimate.unknown()), <END> new SymbolStatistics(LEFT_OTHER_COLUMN, SymbolStatsEstimate.unknown())); PlanNodeStatsEstimate rightStats = planNodeStats( 0, new SymbolStatistics(RIGHT_JOIN_COLUMN, SymbolStatsEstimate.unknown()), new SymbolStatistics(RIGHT_OTHER_COLUMN, SymbolStatsEstimate.unknown())); assertJoinStats(LEFT, leftStats, rightStats, leftStats); }
<|startcomment|> Didn't you remove guava from GWTP? <|endcomment|> public Collection<ClassDefinition> generate(ExtensionContext input) throws UnableToCompleteException { PrintWriter printWriter = tryCreate(); if (printWriter != null) { mergeTemplate(printWriter); commit(printWriter); registerGinBinding(); } else { getLogger().debug("Jackson Mapper Provider already generated. Returning."); } <START> return Lists.newArrayList(getClassDefinition()); <END> }
<|startcomment|> 👍 ah. a good reason to make `picasso3` the package name, so long as it has common names like `Request` in the API. <|endcomment|> @Test public void shouldHandleSchemeInsensitiveCase() { String[] schemes = { "http", "https", "HTTP", "HTTPS", "HTtP", }; for (String scheme : schemes) { final Uri uri = URI_1.buildUpon().scheme(scheme).build(); final Boolean shouldHandle = networkHandler.canHandleRequest( <START> TestUtils.mockRequest(uri) <END> ); assertThat(shouldHandle).isTrue(); } }
<|startcomment|> if (um != null) { Framework.doPrivileged(() -> createUsersAndGroups(um)); } <|endcomment|> public void populate(CoreSession session) throws ClientException { UserManager um = Framework.getLocalService(UserManager.class); Framework.doPrivileged(() -> { // Create some users if (um != null) { createUsersAndGroups(um); } <START> }); <END> }
<|startcomment|> Might be also in finally? <|endcomment|> public void stop(BundleContext context) throws Exception { try { Job.getJobManager().join(LUCENE_JOB_FAMILY, null); <START> plugin = null; <END> } finally { super.stop(context); } }
<|startcomment|> move null check back as first action to not change behaviour. <|endcomment|> public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) { ObjectUtil.checkNotNull(unit, "unit"); if (delay < 0) { delay = 0; } validateScheduled0(delay, unit); return schedule(new ScheduledFutureTask<Void>( this, <START> ObjectUtil.checkNotNull(command, "command"), <END> deadlineNanos(unit.toNanos(delay)))); }
<|startcomment|> I think that `if (in == null) return null` is a slightly better way to deal with this... <|endcomment|> public Integer invoke() { Integer result = 0; try (InputStream in = cache.getViaStream(key)) { int read = 0; while ((read = in.read(buffer)) != -1) result = result + read; return value = result; } catch (IOException e) { throw new RuntimeException(e); <START> } catch (NullPointerException e) { <END> return null; } }
<|startcomment|> check for `cause != null` <|endcomment|> public CoreEvent process(CoreEvent event) throws MuleException { try { return processToApply(event, this); } catch (Exception error) { Throwable cause = error.getCause(); <START> if (cause instanceof RetryContextInitializationException && <END> cause.getCause() instanceof ExpressionRuntimeException) { // Runtime exception caused by Retry Ctx initialization, propagating throw ((ExpressionRuntimeException) cause.getCause()); } else { // Not caused by context initialization. Throwing as raised. throw error; } } }
<|startcomment|> Missing a .get() here after .getKey() as the UUID is the key in the map, not the PatchLineComment.Key object instance. <|endcomment|> private static void addChildren(Map<String, List<PatchLineComment>> parentMap, List<PatchLineComment> children, List<PatchLineComment> outResult) { if (children != null) { for (PatchLineComment c : children) { outResult.add(c); <START> addChildren(parentMap, parentMap.get(c.getKey()), outResult); <END> } } }
<|startcomment|> What is this logging buying us ? Do we really need so much of it? <|endcomment|> public void dispose() { <START> LogManager.logInfo("Disposing", this); //$NON-NLS-1$ <END> fWindow= null; }
<|startcomment|> the second part of the OR is redundant: byte[].class != obj.getClass() <|endcomment|> public boolean equals(byte[] obj, Object otherObj) { if (obj == otherObj) return true; <START> if (obj == null || byte[].class != obj.getClass()) return false; <END> if (otherObj == null || byte[].class != otherObj.getClass()) return false; byte[] byteArray = obj; byte[] otherByteArray = (byte[]) otherObj; return Arrays.equals(byteArray, otherByteArray); }
<|startcomment|> can be private <|endcomment|> <START> public EngineSearcherTotalHitsMatcher(Query query, int totalHits) { <END> this.query = query; this.totalHits = totalHits; }
<|startcomment|> Why don't you push this down to `LogData::getPayload` ? (since that's when deserialize is actually invoked) <|endcomment|> protected boolean processEntryForContext(final ILogData data) { if (data != null) { try { <START> final Object payload = data.getPayload(runtime); <END> } catch (Throwable e) { log.error("Exception caught at address {}, {}, {}", data.getGlobalAddress(), data.getStreams(), data.getType()); throw e; } } return false; }
<|startcomment|> any reason for disabling cache for descending order queries ? <|endcomment|> public boolean isQueryCacheable(Query query) { // O(n) impl, but I don't think we'll ever have a million query types here <START> return !query.isDescending() && !unCacheable.contains(query.getType()); <END> }
<|startcomment|> Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()). <|endcomment|> public static boolean isMoeFile(IResource resource) { if(resource instanceof IFile ) { <START> String fileExtension = resource.getFileExtension(); return fileExtension != null && resource.getFileExtension().equals(MODEL_OBJECT_ELEMENTFILE_EXTENSION); <END> } return false; }
<|startcomment|> could we change to List<Properties> or is this API fixed? <|endcomment|> <START> public Property[] getProperties() { <END> return m_properties.toArray(new Property[m_properties.size()]); }
<|startcomment|> No need for this. The tests must be independent, hence the instance count here should be zero. <|endcomment|> public void setup() throws NoSuchFieldException, IllegalAccessException { // Before "onCreate", we need to record the instance count for the test <START> instanceCountField = OpenHelperManager.class.getDeclaredField("instanceCount"); <END> instanceCountField.setAccessible(true); instanceCount = instanceCountField.getInt(null); activity = Robolectric.buildActivity(OrmLiteActivity_.class).create().get(); }
<|startcomment|> Do we need to do this here? This seems like it's creating a circular dependency of the EMF into Guice, but the EMF depends on Guice. <|endcomment|> public static Injector getInjector() { if ( injector == null ) { <START> injector = Guice.createInjector( new GuiceModule( emf ) ); <END> } return injector; }
<|startcomment|> We don't like System.out :) <|endcomment|> public void serialize() throws Exception { String xml = serializer.serialize(header); <START> System.out.println(xml); <END> XMLAssert.assertXpathExists("/subscriptionHeader/contentUri", xml); XMLAssert.assertXpathExists("/subscriptionHeader/packageHeader", xml); XMLAssert.assertXpathExists("/subscriptionHeader/packageHeader/name", xml); }
<|startcomment|> Instanceof nightmare? <|endcomment|> protected IMicroblockContainerTile getMicroblockTile(IBlockAccess world, BlockPos pos) <START> { <END> TileEntity tile = world.getTileEntity(pos); return tile instanceof IMicroblockContainerTile ? (IMicroblockContainerTile) tile : null; }
<|startcomment|> should be a protected method <|endcomment|> <START> public void setMethod(final ZonemasterRequest.Method method) { <END> this.method = method.getMethod(); this.id = method.getId(); }
<|startcomment|> Multi return is forbidden. <|endcomment|> <START> public Dimension getFloatingItemOffset() { <END> if (editPart instanceof FloatingLabelEditPart) { return ((FloatingLabelEditPart) editPart).getFloatingItemOffset(); } return new Dimension(); }
<|startcomment|> irc is not open if con is null initially. The logic here is a bit muddled. <|endcomment|> private static synchronized ITerminalConnector getConnector(IRemoteConnection irc) throws RemoteConnectionException { ITerminalConnector con = cons.get(irc.getAddress()); if(con == null) { con = TerminalConnectorExtension.makeTerminalConnector( "org.eclipse.ptp.remote.internal.terminal.RemoteToolsConnector"); //$NON-NLS-1$ cons.put(irc.getAddress(),con); <START> } else if(irc.isOpen()) { <END> return null; } else { irc.open(new NullProgressMonitor()); return null; } return con; }
<|startcomment|> Why not declare GLOBAL_ID as a long? <|endcomment|> public long getGlobalClassLoaderId() { <START> return (long) ClassLoaderIdentifier.GLOBAL_ID; <END> }
<|startcomment|> Even though these two are "CMAS Severe Alerts", shouldn't getCmasSeverity() still return CMAS_SEVERITY_EXTREME? Spec says "Severity of Extreme, Urgency of Expected..." <|endcomment|> private int getCmasSeverity() { switch (messageIdentifier) { case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME; case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED: <START> case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY: <END> case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED: case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY: return SmsCbCmasInfo.CMAS_SEVERITY_SEVERE; default: return SmsCbCmasInfo.CMAS_SEVERITY_UNKNOWN; } }
<|startcomment|> instead of thowing we could return an empty list <|endcomment|> public Collection<String> getAliases(final KeyStore keyStore) throws ScriptSignatureException { try { if (keyStore != null) return Collections.list(keyStore.aliases()); } catch (KeyStoreException e) { throw new ScriptSignatureException("Keystore not initialized properly. Try again.", e); } <START> throw new ScriptSignatureException("Keystore not initialized properly. Try again.", null); <END> }
<|startcomment|> Type argument Expression is not need. <|endcomment|> public List<Expression> getExpressions() { <START> List<Expression> result = new ArrayList<Expression>(groupByAttributes); <END> result.add(expression); return result; }
<|startcomment|> Could we keep this API private? <|endcomment|> <START> public boolean isIdentityProvider() { <END> try { PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES); for (ActivityInfo activityInfo : packageInfo.activities) { if (activityInfo.name.equals(IDPAccountPickerActivity.class.getName())) { return true; } } } catch (NameNotFoundException e) { SalesforceSDKLogger.e(TAG, "Exception occurred while examining application info", e); } return false; }
<|startcomment|> @olivergondza noted in the commit that this should not be public as it is for testing only <|endcomment|> <START> public List<BlockedItem> getBlockedItems() { <END> return new ArrayList<BlockedItem>(snapshot.blockedProjects); }
<|startcomment|> I don't think it makes sense for the trace to be null here. We shouldn't have to create a new Message file for this case... <|endcomment|> public IStatus validate(String path) { if (fTrace == null) { <START> return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.TraceTypeHelper_ValidateNoTrace); <END> } return fTrace.validate(null, path); }
<|startcomment|> just wondering...is it worth putting the `rc == FMT` check first for a short-circuiting efficiency improvement? <|endcomment|> public static boolean isTCCPacket(ByteArrayBuffer baf) { int rc = RTCPHeaderUtils.getReportCount(baf); <START> return isRTPFBPacket(baf) && rc == FMT; <END> }
<|startcomment|> @bkmeneguello Are you sure that <code>!=</code> is correct? <|endcomment|> private Result waitForCompletion() throws InterruptedException, IOException { // wait for the completion Result result; <START> while((result = checkForCompletion()) != null) { <END> Thread.sleep(1000); } return result; }
<|startcomment|> Missing fs.close() <|endcomment|> public void testUnderlyingReaders() throws IOException, FormatException { FakeReader reader = new FakeReader(); FileStitcher fs = new FileStitcher(reader); assertNotNull(fs.getUnderlyingReaders()); fs.setId("test_z<0-2>.fake"); assertNotNull(fs.getUnderlyingReaders()); <START> } <END>
<|startcomment|> We can get rid of these variables if they are being used in one place. <|endcomment|> public void shouldGetDiagnosisByUuid() { <START> String uuid = "4e663d66-6b78-11e0-93c3-18a905e044dc"; <END> int diagnosisId = 1; Diagnosis diagnosis = diagnosisDAO.getDiagnosisByUuid(uuid); assertEquals(diagnosisId, (int) diagnosis.getId()); }
<|startcomment|> I don't think the logic is necessary. We can have the default visibility as `GONE`. <|endcomment|> public void setUpCallToAction(String callToActionText) { if (callToActionText == null) { callToActionContainer.setVisibility(GONE); } else { callToActionContainer.setVisibility(VISIBLE); <START> callToActionTextView.setText(callToActionText); <END> } }
<|startcomment|> Could this be protected as well? <|endcomment|> <START> public AbstractTableViewer <END> getTableViewer() { return actionContext.getViewer(); }
<|startcomment|> This probably should be public, and in the interface. <|endcomment|> <START> void start() { <END> if (!started) { log.info("Starting prefetching thread."); executorService.execute(new DefaultGetRecordsCacheDaemon()); } started = true; }
<|startcomment|> Why `new ArrayList<>(`? <|endcomment|> public SymbolTableBuilder(String fullyQualifiedModuleName) { <START> this.fullyQualifiedModuleName = new ArrayList<>(Arrays.asList(fullyQualifiedModuleName.split("\\."))); <END> }
<|startcomment|> Double volatile read is gone. Can get rid of maxTS. <|endcomment|> public long getNextTimestamp() throws TimestampIOException { long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT); <START> long maxTS = _maxReservedTimestamp; // avoid the double volatile read <END> if (nextTS > maxTS) { reserveNextBlock(nextTS); } _numTimestampsCreated.incrementAndGet(); // JMX metric return nextTS; }
<|startcomment|> please remove `this.` on this line and the next <|endcomment|> public TileRenderRunnable( TileCanvasViewGroup viewGroup, Tile tile) { <START> this.mTileCanvasViewGroup = new WeakReference<>( viewGroup ); <END> this.mTile = new WeakReference<>( tile ); }
<|startcomment|> @matthew-a-dunlap please update the docs on `:ExcludeEmailFromExport`. Thanks! <|endcomment|> public Response viewDataverse(@PathParam("identifier") String idtf) { return allowCors(response(req -> ok( json(execCommand(new GetDataverseCommand(req, findDataverseOrDie(idtf))), false, <START> settingsService.isTrueForKey(SettingsServiceBean.Key.ExcludeEmailFromExport, false) <END> )))); }
<|startcomment|> Should this better be: super(id.get()) ? At least in some other places [1] we provide the decoded id to ResourceNotFoundException(String). Shouldn't it be the same in all places, either always the decoded id or always the encoded id? [1] https://gerrit-review.googlesource.com/#/c/41733/1/gerrit-server/src/main/java/com/google/gerrit/server/group/GroupsCollection.java <|endcomment|> public ResourceNotFoundException(IdString id) { <START> super(id.encoded()); <END> }
<|startcomment|> if you use AppiumDriver<?> driver = (AppiumDriver<?>) getDriverSafe(); then there is no sense in if (driver instanceof AppiumDriver) <|endcomment|> private AppiumDriver getDriverSafe() { WebDriver driver = getDriver(); if (driver instanceof EventFiringWebDriver) { driver = ((EventFiringWebDriver) driver).getWrappedDriver(); <START> if (driver instanceof AppiumDriver) { <END> return (AppiumDriver) driver; } } throw new ClassCastException("Appium Driver can not be casted from the actual driver."); }
<|startcomment|> You forgot to revert that <|endcomment|> public void assertSimilarity(final File actualFile, final double maxDistance) throws IOException { BufferedImage tempImg = ImageIO.read(actualFile); File tempFile = File.createTempFile("print-test", ".png"); ImageIO.write(tempImg, "png", tempFile); <START> assertSimilarity(ImageIO.read(tempFile), maxDistance); <END> }
<|startcomment|> Good catch. I also just spotted that a few other log messages in tryDoEnd are attribued to this. It will be clearer to just remove the LRARecord.doEnd prefix I think. <|endcomment|> public URI getLocationHeaderAsURI() { try { return locationHeader != null ? new URI(locationHeader) : null; } catch (URISyntaxException e) { if (LRALogger.logger.isInfoEnabled()) { <START> LRALogger.logger.infof("LRARecord.doEnd missing Location header on ACCEPTED response %s failed: %s", <END> getRequestURI(), e.getMessage()); } return null; } }
<|startcomment|> This seems redundant to me as we are logging in as the current user in the base class. <|endcomment|> public void setup(Method method) throws Exception { logger.info("test name: " + method.getName()); <START> KerberosHelper.loginFromKeytab(MerlinConstants.CURRENT_USER_NAME); <END> bundles[0] = Util.readELBundles()[0][0]; bundles[0] = new Bundle(bundles[0], cluster.getEnvFileName(), cluster.getPrefix()); bundles[0].generateUniqueBundle(); bundles[0].setProcessWorkflow(aggregateWorkflowDir); }
<|startcomment|> Any reason not to check value of the view? <|endcomment|> public View getOverflowMenuAnchor() { View view = getToolbar().findViewById(R.id.menu_overflow_button); <START> return getToolbar(); <END> }
<|startcomment|> I thought we will catch the exception and call close() here and then rethrow <|endcomment|> public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestInfos) throws IOException { if (closed) { throw new IllegalStateException("The NetworkClient is closed."); } List<ResponseInfo> responseInfoList = new ArrayList<ResponseInfo>(); for (RequestInfo requestInfo : requestInfos) { pendingRequests.add(new RequestMetadata(time.milliseconds(), requestInfo, null)); } List<NetworkSend> sends = prepareSends(responseInfoList); selector.poll(POLL_TIMEOUT_MS, sends); handleSelectorEvents(responseInfoList); <START> return responseInfoList; <END> }
<|startcomment|> As far as I know, enums can be used with the ==/!= operators. It's a matter of style, but I prefer them (since an instance of an enum is really the same referenced entity as the enum constant). However, you can do whatever you like, either is fine by me. <|endcomment|> public void handleQuotaColumnVisibility() { isQuotaVisible = false; SystemTreeItemModel treeItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem(); if (treeItem != null <START> && SystemTreeItemType.DataCenter.equals(treeItem.getType())) { <END> StoragePool storagePool = (StoragePool) treeItem.getEntity(); if (!QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) { isQuotaVisible = true; } } onDiskViewTypeChanged(); }
<|startcomment|> shouldn't you force the put? Otherwise, what is returned might be different than what's in the cache, it's also possible that doesn't matter. <|endcomment|> public CompletableFuture<StaticResource> getResource(String name) { StaticResource template = templates.get(name); if (template != null) { return CompletableFuture.completedFuture(template); } return delegate .getResource(name) .exceptionally((th) -> { templates.putIfAbsent(name, null); return null; } ) <START> .thenApply( (file) -> { templates.putIfAbsent(name, file); return file; }); <END> }
<|startcomment|> OpenSSL also supports it in a similar way on the server-side. See SSL_OP_NO_TICKET on this page: https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_options.html. <|endcomment|> public void testSessionTicketsWithTLSv13AndNoKey() throws Throwable { assumeTrue(OpenSsl.isTlsv13Supported()); <START> assumeTrue(OpenSsl.isBoringSSL()); <END> testSessionTickets(SslUtils.PROTOCOL_TLS_V1_3, false); }
<|startcomment|> a BeforeClass has to be static (it doesn't tell you until you actually try to run it) I was wondering why this passed Hudson, but then remembered the perf tests don't run, yet... <|endcomment|> <START> public void setUp() { <END> TmfEventMatching.registerMatchObject(new TcpEventMatching()); TmfEventMatching.registerMatchObject(new TcpLttngEventMatching()); }
<|startcomment|> Would it make more sense to mark the brand parameter of setBrand as @NonNull instead of checking it here? <|endcomment|> protected void updateTitle(String brand) { <START> if (brand != null) { <END> IBrandManager brandManager = TasksUiPlugin.getDefault().getBrandManager(); setTitle(brandManager.getConnectorLabel(getConnector(), brand)); } }
<|startcomment|> I'd rather throw an exception <|endcomment|> public static int getSegmentForKey(Object key, Cache cache) { KeyPartitioner keyPartitioner = extractComponent(cache, KeyPartitioner.class); if (keyPartitioner != null) { return keyPartitioner.getSegment(key); } <START> return SegmentSpecificCommand.UNKNOWN_SEGMENT; <END> }
